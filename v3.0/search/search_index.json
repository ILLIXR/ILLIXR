{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ILLIXR","text":"<p>Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is     the first fully open-source Extended Reality (XR) system and testbed. The modular, extensible, and OpenXR-compatible ILLIXR runtime     integrates state-of-the-art XR components into a complete XR system. The testbed is part of the broader ILLIXR consortium,     an industry-supported community effort to democratize XR systems     research, development, and benchmarking.</p> <p>You can find the complete ILLIXR system here.</p> <p>ILLIXR also provides its components in standalone configurations to enable architects and     system designers to research each component in isolation. The standalone components are packaged together in the v1-latest release of ILLIXR. </p> <p>ILLIXR's modular and extensible runtime allows adding new components and swapping different     implementations of a given component. ILLIXR currently contains the following components: </p> <ul> <li> <p>Perception</p> <ul> <li>Eye Tracking<ol> <li>RITNet **</li> </ol> </li> <li>Scene Reconstruction<ol> <li>ElasticFusion **</li> <li>KinectFusion **</li> </ol> </li> <li>Simultaneous Localization and Mapping<ol> <li>OpenVINS **</li> <li>Kimera-VIO **</li> </ol> </li> <li>Cameras and IMUs<ol> <li>ZED Mini</li> <li>Intel RealSense</li> </ol> </li> </ul> </li> <li> <p>Visual</p> <ul> <li>Chromatic aberration correction</li> <li>Computational holography for adaptive multi-focal displays **</li> <li>Lens distortion correction</li> <li>Asynchronous Reprojection (TimeWarp)</li> </ul> </li> <li> <p>Aural</p> <ul> <li>Audio encoding **</li> <li>Audio playback **</li> </ul> </li> </ul> <p>(** Source is hosted in an external repository under the ILLIXR project.)</p> <p>We continue to add more components (new components and new implementations). </p> <p>Many of the current components of ILLIXR were developed by domain experts and obtained from     publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features,     or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for     proper attribution to its authors.</p>"},{"location":"#papers-talks-demos-consortium","title":"Papers, talks, demos, consortium","text":"<p>A paper with details on ILLIXR, including its components, runtime, telemetry support,     and a comprehensive analysis of performance, power, and quality on desktop and embedded systems.</p> <p>A talk presented at NVIDIA GTC'21 describing ILLIXR and announcing the ILLIXR consortium:     Video.     Slides. </p> <p>A demo of an OpenXR application running with ILLIXR.</p> <p>The ILLIXR consortium is an industry-supported community effort to democratize     XR systems research, development, and benchmarking. Visit our web site for more information.</p>"},{"location":"#citation","title":"Citation","text":"<p>We request that you cite our following paper when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.</p> <pre><code>@inproceedings{HuzaifaDesai2021,\n  author={Huzaifa, Muhammad and Desai, Rishi and Grayson, Samuel and Jiang, Xutao and Jing, Ying and Lee, Jae and Lu, Fang and Pang, Yihan and Ravichandran, Joseph and Sinclair, Finn and Tian, Boyuan and Yuan, Hengzhi and Zhang, Jeffrey and Adve, Sarita V.},\n  booktitle={2021 IEEE International Symposium on Workload Characterization (IISWC)}, \n  title={ILLIXR: Enabling End-to-End Extended Reality Research}, \n  year={2021},\n  volume={},\n  number={},\n  pages={24-38},\n  doi={10.1109/IISWC53511.2021.00014}\n}\n</code></pre>"},{"location":"#getting-started-and-documentation","title":"Getting Started and Documentation","text":"<p>For more information, see our Getting Started page.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The ILLIXR project started in Sarita Adve\u2019s research group,     co-led by PhD candidate Muhammad Huzaifa, at the University of Illinois at Urbana-Champaign. Other major contributors include     Rishi Desai,     Samuel Grayson,     Xutao Jiang,     Ying Jing,     Jae Lee,     Fang Lu,     Yihan Pang,     Joseph Ravichandran,     Giordano Salvador,     Finn Sinclair,     Boyuan Tian,     Henghzhi Yuan,     and     Jeffrey Zhang.</p> <p>ILLIXR came together after many consultations with researchers and practitioners in many domains:     audio,     graphics,     optics,     robotics,     signal processing,     and     extended reality systems. We are deeply grateful for all of these discussions and specifically to the following:     Wei Cu,     Aleksandra Faust,     Liang Gao,     Matt Horsnell,     Amit Jindal,     Steve LaValle,     Steve Lovegrove,     Andrew Maimone,     Vegard \u00d8ye,     Martin Persson,     Archontis Politis,     Eric Shaffer,     Paris Smaragdis,     Sachin Talathi,     and     Chris Widdowson.</p> <p>Our OpenXR implementation is derived from Monado. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.</p> <p>The development of ILLIXR was supported by     the Applications Driving Architectures (ADA) Research Center         (a JUMP Center co-sponsored by SRC and DARPA),     the Center for Future Architectures Research (C-FAR, a STARnet research center),     a Semiconductor Research Corporation program sponsored by MARCO and DARPA,     and     by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations     from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset.</p> <p>Wesley Darvin came up with the name for ILLIXR.</p>"},{"location":"#licensing-structure","title":"Licensing Structure","text":"<p>ILLIXR is available as open-source software under the permissive     University of Illinois/NCSA Open Source License. As mentioned above, ILLIXR largely consists of components developed by domain experts and     modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software. The external libraries and softwares included in ILLIXR each have their own licenses and     must be used according to those licenses:</p> <ul> <li> <p>ElasticFusion \\ ElasticFusion license</p> </li> <li> <p>KinectFusion \\ MIT License</p> </li> <li> <p>GTSAM \\ Simplified BSD License</p> </li> <li> <p>HOTlab \\ GNU Lesser General Public License v3.0</p> </li> <li> <p>Kimera-VIO \\ Simplified BSD License</p> </li> <li> <p>libspatialaudio \\ GNU Lesser General Public License v2.1</p> </li> <li> <p>Monado \\ Boost Software License 1.0</p> </li> <li> <p>moodycamel::ConcurrentQueue \\ Simplified BSD License</p> </li> <li> <p>Open-VINS \\ GNU General Public License v3.0</p> </li> <li> <p>RITnet \\ MIT License</p> </li> </ul> <p>Note that ILLIXR's extensibility allows the source to be configured and compiled using only     permissively licensed software.</p>"},{"location":"#get-in-touch","title":"Get in Touch","text":"<p>Whether you are a computer architect, a compiler writer, a systems person, work on XR related algorithms     or applications, or just anyone interested in XR research, development, or products,     we would love to hear from you and hope you will contribute! You can join     the ILLIXR consortium,     Discord,     or mailing list,     or send us an email,     or just send us a pull request!</p>"},{"location":"CONTRIBUTING/","title":"Contributing Guidelines","text":"<p>Please follow these steps when making pull requests (PRs):</p> <ol> <li> <p>First, create an issue describing the problem that needs to be fixed.     If an issue already exists, skip this step.     If you are looking for an issue to fix, see the \"good first issue\" label.</p> </li> <li> <p>Assign the issue to yourself and add appropriate labels.     If you are an external contributor, comment on the issue so one of the ILLIXR team members         can assign the issue to you.</p> </li> <li> <p>Before you start making changes, make a new branch.     The branch MUST be named <code>issue-&lt;issue number&gt;-&lt;some descriptive name&gt;</code>.     For instance, <code>issue-32-fix-mem-leak</code> addresses the memory leak described in Issue #32.</p> </li> <li> <p>Fix the issue.</p> </li> <li> <p>Add your name to <code>ILLIXR/CONTRIBUTORS</code>.</p> </li> <li> <p>Push commits up to GitHub.</p> </li> <li> <p>Open a PR, and link it to the issue that the PR aims to resolve.     Please give the PR a descriptive name.</p> </li> <li> <p>As you make progress on your PR, keep your branch up-to-date with the <code>master</code> branch which         may have been updated after starting your PR.     Your PR MUST be updated to reflect changes to <code>master</code> in order to be merged.     Use the following procedure for updating your branch and when you are ready to commit your changes:</p> <pre><code>## While on your PR branch &lt;issue-branch&gt; hosted at &lt;your-remote&gt; repository:\ngit commit # or git stash                                               ## Line A\ngit checkout master\n\ngit pull &lt;illixr-remote&gt; master --rebase &amp;&amp; git fetch &lt;illixr-remote&gt;   ## Line B\n\ngit checkout &lt;issue-branch&gt;\ngit rebase master                                                       ## Line C\n\n## If you stashed your changes on 'Line A':\ngit stash apply &lt;stash-number&gt; &amp;&amp; git commit\n\ngit push &lt;your-remote&gt; &lt;issue-branch&gt; --force-with-lease                ## Line D\n</code></pre> <p>For ILLIXR team members (others jump here):</p> <ul> <li> <p>In the example above, <code>&lt;illixr-remote&gt;</code> and <code>&lt;your-remote&gt;</code> are the same.</p> </li> <li> <p>When collaborating on branches in our repository, <code>Line B</code> may pull in changes that overwrite         the git commit history when performing <code>Line C</code>.     Subsequently, performing <code>Line D</code> will rewrite the history in the public branch.     To preserve branch commit histories in the case that a rollback is needed, we will employ         a checkpointing process for force updated branches.     This process will be manually performed, but may be automated in the future.</p> <p>If <code>Line B</code> shows an update to master, the following example illustrates your local repository     just after performing <code>Line B</code>:</p> <pre><code>A -- B -- C -- P -- Q -- R                                          ## master\n           \\\n            D -- E -- F                                             ## issue-123-fixing-bug\n</code></pre> <p>In this example, commits <code>P</code>, <code>Q</code>, and <code>R</code> have been merged to <code>master</code>     (from feature branches not shown) after feature branch <code>issue-123-fixing-bug</code> was     forked from <code>master</code>.</p> <p>To checkpoint the <code>issue-123-fixing-bug</code> branch while it is checked out:</p> <pre><code>git branch issue-123.0-fixing-bug                                   ## Make alias for old issue-123-fixing-bug\ngit checkout -b issue-123.1-fixing-bug                              ## Make new branch to rebase with master\ngit rebase master                                                   ## Replay issue-123-fixing-bug onto master\ngit branch -D issue-123-fixing-bug                                  ## Remove old issue-123-fixing-bug\ngit branch issue-123-fixing-bug                                     ## Make issue-123-fixing-bug an alias of new branch\ngit push &lt;illixr-remote&gt; issue-123.{0,1}-fixing-bug                 ## Push new checkpointed branches to remote\ngit push &lt;illixr-remote&gt; issue-123-fixing-bug --force-with-lease    ## Force update issue-123-fixing-bug\n</code></pre> <p>Note: The term alias here is used to refer to branches which point to the same commit. This usage is different from standard Git Aliases used for git command shortcuts.</p> <p>After checkpointing, your local repository should look as follows:</p> <pre><code>                           D' -- E' -- F'                           ## issue-123.1-fixing-bug, issue-123-fixing-bug\n                          /\nA -- B -- C -- P -- Q -- R                                          ## master\n           \\\n            D -- E -- F                                             ## issue-123.0-fixing-bug\n</code></pre> <p>Commits <code>D</code>, <code>E</code>, and <code>F</code> have been added to a new branch starting from <code>R</code>,     but now have been given new hashes. This new branch is our up-to-date copy of the feature branch <code>issue-123-fixing-bug</code>.</p> <p>While working on a checkpointed branch, keep aliases up-to-date using <code>git rebase</code>:</p> <pre><code>git commit                                                          ## Add changes to issue-123.1-fixing-bug\ngit checkout issue-123-fixing-bug                                   ## Switch to main issue-123-fixing-bug branch\ngit rebase issue-123.1-fixing-bug                                   ## Fast-forward issue-123-fixing-bug to issue-123.1-fixing-bug\n</code></pre> <p>Conflicts are possible when two or more collaborators push changes concurrently to     the same branch. As long as each collaborator ensures that the branch update process starts at <code>Line A</code>,     conflicts can be detected and handled locally. In other words, every call to <code>git-push</code> should be preceeded by a call to <code>git-pull</code>,     following the process from <code>Line A</code> to <code>Line D</code> (or equivalent; git's CLI allows many     ways to achieve the same results).</p> <p>Note: <code>Line B</code> rebases the <code>master</code> branch assuming that we have checked out <code>master</code>. Forgetting to specify <code>master</code> in <code>Line B</code> may result in a lossy forced update in the     example below. Forgetting to checkout <code>master</code> will immediately apply your checked out feature branch's     changes, possibly also resulting in a lossy forced update.</p> <p>The output of <code>Line B</code> for a collaborator after the checkpointing process may contain     something like this:</p> <pre><code>From github.com:ILLIXR/ILLIXR\n  A..R          master                  -&gt; &lt;illixr-remote&gt;/master\n+ A..F'         issue-123-fixing-bug    -&gt; &lt;illixr-remote&gt;/issue-123-fixing-bug  (forced update)\n* [new branch]  issue-123.0-fixing-bug  -&gt; &lt;illixr-remote&gt;/issue-123.0-fixing-bug\n* [new branch]  issue-123.1-fixing-bug  -&gt; &lt;illixr-remote&gt;/issue-123.1-fixing-bug\n</code></pre> <p>Conflicts which do not involve updates to the <code>master</code> branch can be resolved simply     by rebasing the current feature branch with the updated feature branch,     applying new changes on top of the updated feature branch:</p> <pre><code>## For the latest checkpoint X (local) and Y (remote), let Z := Y + 1 in\ngit checkout issue-123.X-fixing-bug -b issue-123.Z-fixing-bug       ## Make new branch issue-123.Z-fixing-bug\ngit rebase &lt;illixr-remote&gt;/issue-123.Y-fixing-bug                   ## Replay updates from issue-123.X-fixing-bug\ngit push &lt;illixr-remote&gt; issue-123.Z-fixing-bug                     ## Make sure to update issue-123-fixing-bug after\n</code></pre> <p>The <code>--force-with-lease</code> argument in <code>Line D</code> is not required for our new checkpoint branch,     since a new branch should not conflict with a non-existing remote branch. We expect the subversion number for a new branch resulting from our     checkpoint conflict resolution to be new and unique. If the push fails, another conflict has occurred, and checkpoint conflict resolution     should be repeated. <code>Line D</code> should be safe to perform for the main feature branch now that we have     replayed our commits on top of the updated feature branch.</p> <p>Note: In the above example, the <code>git-rebase</code> is performed using the remote copy of     the checkpointed branch. We do this because <code>Line B</code> will not fast-forward or force update our local branches     (with the same subversion number as a conflicting remote branch, if any).</p> <p>In the case of a conflict with updates to <code>master</code>, <code>Line A</code> should show updates to     both the <code>master</code> branch and the feature branch to be pushed in <code>Line D</code>. A checkpointed version of the feature branch may also appear. This is because a feature branch should only be checkpointed in the presence of a     change to the <code>master</code> branch. Forced pushes should generally not be used for any other purpose. If multiple updates to <code>master</code> and the feature branch have occured, additional     checkpointed versions of the feature branch may also appear. In this scenario, we need to rebase our latest version of the feature branch with     the latest version of the feature branch pulled from <code>&lt;illixr-remote&gt;</code>.</p> </li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#philosophy","title":"Philosophy","text":"<p>Why are the above steps necessary?</p> <ol> <li> <p>Assigning the issue to yourself ensures that multiple people don't work on the same thing         in parallel.</p> </li> <li> <p>The branch naming scheme organizes things a bit for us, and also makes it easy to find branches.</p> </li> <li> <p>Linking the issue to the PR ensures that we know which issue is being resolved,         and also automatically closes the issue when the PR gets merged.</p> </li> <li> <p>Using rebases keeps the <code>master</code> and feature branch histories streamlined (minimizing branching),         thus making it easier to compose feature branches for integration testing.     See this article on rebasing public branches for more information.</p> </li> </ol> <p>If your PR has not seen activity from the ILLIXR team after a long period of time (e.g., 2 weeks),     feel free to contact the team directly on the GitHub Issue Conversation tab or at     the Gitter forum linked below.</p>"},{"location":"CONTRIBUTING/#other-procedures","title":"Other Procedures","text":"<ol> <li> <p>Branch Management:</p> <p>The branch rebasing and checkpointing process detailed above is tedious, and may be automated in     the future. Check back in with this document occasionally for improvements to the branch management process.</p> </li> <li> <p>Code Formatting:</p> <p>As ILLIXR grows, contributions will need to be standardized to accomodate multiple collaborators     with different coding styles. During code review of a PR, you may be asked to reformat your code to match the standards set for     ILLIXR code base. This process may be manually triggered by a comment from a review, or automated via Git and GitHub     in the future.</p> </li> <li> <p>Issue Templates:</p> <p>To make collaboration easier, templates for Issues and Pull Requests will be added to     the GitHub web interface. If an appropriate template exists for your task, please ensure to select it before submitting.</p> </li> </ol>"},{"location":"CONTRIBUTING/#getting-help","title":"Getting Help","text":"<p>You can get seek help from our development community in three places:</p> <ol> <li> <p>Main documentation site</p> </li> <li> <p>API documentation site</p> </li> <li> <p>Gitter community forum</p> </li> </ol>"},{"location":"LICENSE/","title":"ILLIXR License","text":"<p>Copyright (c) 2019 The Board of Trustees of the University of Illinois.  All rights reserved.</p> <p>Developed by: Professor Sarita Adve's research group               University of Illinois at Urbana-Champaign               http://rsim.cs.illinois.edu</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: * Redistributions of source code must retain the above copyright notice,   this list of conditions and the following disclaimers. * Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimers in the documentation   and/or other materials provided with the distribution. * Neither the names of Professor Sarita Adve's research group, University of   Illinois at Urbana-Champaign, nor the names of its contributors may be used   to endorse or promote products derived from this Software without specific   prior written permission.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.</p>"},{"location":"building_illixr/","title":"Building ILLIXR","text":"<p>The ILLIXR application is kick-started through a tool called Runner     (found in <code>runner/</code> and <code>runner.sh</code>). The Runner tool is responsible for     preparing the environment,     downloading required assets/code,     compiling each plugin,     and     launching the ILLIXR application. Runner is necessary for our project since ILLIXR manages plugins and data that span     many locations and launch configurations. A configuration (defined via a YAML file in <code>ILLIXR/configs/</code>) specifies parameters     and plugins required to launch ILLIXR for a specific design/evaluation scenario.</p>"},{"location":"building_illixr/#compilation-and-usage","title":"Compilation and Usage","text":"<p>To run ILLIXR (from the root directory of the project) using     the default <code>native</code> launch configuration,</p> <pre><code>./runner.sh configs/native.yaml\n</code></pre> <p>To drop into <code>gdb</code>, add <code>command: gdb -q --args $cmd</code> in the <code>action</code> block of     <code>configs/native.yaml</code>, and use the same command.</p> <p>To run ILLIXR with Monado,</p> <pre><code>./runner.sh configs/monado.yaml\n</code></pre> <p>The OpenXR application to run is defined in the <code>action.openxr_app</code>     (a YAML object).</p>"},{"location":"building_illixr/#configuration","title":"Configuration","text":"<p>As introduced in the introduction to the ILLIXR build process, a Configuration     (or config) describes the key information needed to launch an ILLIXR application. This section provides a detailed breakdown of the structure of a configuration file. The default <code>ILLIXR/configs/native.yaml</code> for the <code>native</code> action will be used as     the running example.</p> <p>The first block in the config file contains a list of <code>plugin_groups</code>,     where each <code>plugin_group</code> is a list of plugins.</p> <pre><code>plugin_groups:\n  - plugin_group:\n      - path: plugin1/\n      - path: plugin2/\n      - path: plugin3/\n      - path: plugin4/\n</code></pre> <p>This defines a list of plugins by their location, <code>path</code>. Allowed paths will be described below. The <code>plugin_groups</code> get flattened and those plugins are initialized in order at runtime. Several of the default plugins are order-sensitive.</p> <p>The next block in the config defines the offline IMU data, camera data, and ground-truth data.</p> <pre><code>data:\n  subpath: mav0\n  relative_to:\n    archive_path:\n      download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip'\n</code></pre> <p>Next, we define the location of OBJ files for <code>gldemo</code>.</p> <pre><code>demo_data: demo_data/\n</code></pre> <p>Then, we define the Action to be taken for the configuration. Each action has a name, and can contain a number of member fields beyond this.</p> <pre><code>action:\n  name: native\n  command: gdb -q --args $cmd\n</code></pre> <p>The <code>native</code> action supports an optional <code>command</code> argument. In that argument <code>$cmd</code> is replaced with the separated command-line arguments to run ILLIXR,     while <code>$quoted_cmd</code> is replaced with a single string comprising all command-line arguments. The <code>command</code> argument also supports <code>$env_cmd</code>, which interpret command-line argument     assignments in the form of <code>VARNAME=VALUE</code> as environment variable mappings. See the configuration glossary entry for more details about supported actions.</p> <p>Finally, we support two compilation profiles:     <code>opt</code>, which compiles with <code>-O3</code> and disables debug prints and assertions,     and     <code>dbg</code>, which compiles with debug flags and enables debug prints and assertions.</p> <pre><code>profile: opt\n</code></pre> <p>You can <code>!include</code> other configuration files via pyyaml-include. Consider separating the site-specific configuration options into its own file.</p>"},{"location":"building_illixr/#specifying-paths","title":"Specifying Paths","text":"<p>A path refers to a location of a resource. There are 5 ways of specifying a path:</p> <ul> <li> <p>Simple path:     Either absolute or relative path in the native filesystem.</p> </li> <li> <p>Git repo:     A git repository.</p> <pre><code>- git_repo: https://github.com/user/repo.git\n  version: master # branch name, SHA-256, or tag\n</code></pre> </li> <li> <p>Download URL:     A resource downloaded from the internet.</p> <pre><code>- download_url: https://example.com/file.txt\n</code></pre> </li> <li> <p>Zip archive:     A path that points within the contents of a zip archive.     Note that <code>archive_path</code> is itself a path (recursive).</p> <pre><code>- archive_path: path/to/archive.zip\n- archive_path:\n    download_url: https://example.com/file.zip\n</code></pre> </li> <li> <p>Complex path:     A hard-coded path relative to another path (recursive).     This is useful to specify a subdirectory of a git repository or zip archive.</p> <pre><code>- subpath: path/within/git_repo\n  relative_to:\n    git_repo: ...\n    version: ...\n</code></pre> </li> </ul>"},{"location":"building_illixr/#rationale","title":"Rationale","text":"<ul> <li> <p>Previously, we would have to specify which plugins to build and which to run separately,         violating DRY principle.</p> </li> <li> <p>Previously, configuration had to be hard-coded into the component source code,         or passed as parsed/unparsed as strings in env-vars on a per-component basis.     This gives us a consistent way to deal with all configurations.</p> </li> <li> <p>Currently, plugins are specified by a path to the directory containing their source code         and build system.</p> </li> </ul>"},{"location":"building_illixr/#philosophy","title":"Philosophy","text":"<ul> <li> <p>Each plugin should not have to know or care how the others are compiled.     In the future, they may even be distributed separately, just as SOs.     Therefore, each plugin needs its own build system.</p> </li> <li> <p>Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins         should be extremely easy.</p> </li> <li> <p>It should be easy to build in parallel.</p> </li> <li> <p>Always rebuild every time, so the binary is always \"fresh.\"     This is a great convenience when experimenting.     However, this implies that rebuilding must be fast when not much has changed.</p> </li> <li> <p>Make is the de facto standard for building C/C++ programs.     GNU Make, and the makefile language begets no shortage of problems         [1,2,3,4,5], but we choose     Make for its tradeoff of between simplicity and functionality.     What it lacks in functionality (compared to CMake, Ninja, scons, Bazel, Meson)         it makes up for in simplicity.     It's still the build system in which it is the easiest to invoke arbitrary commands in         shell and the easiest to have a <code>common.mk</code> included in each plugin.     This decision to use Make should be revisited, when this project outgrows its ability,         but for now, Make remains, in our judgement, the best tool for the job.</p> </li> </ul>"},{"location":"debugging_illixr/","title":"ILLIXR Debugging Tips","text":""},{"location":"debugging_illixr/#debugging-locally","title":"Debugging Locally","text":"<p>The config described in Building ILLIXR supports running the runtime with     arbitrary commands like <code>gdb</code>. When debugging locally, we recommend using either <code>gdb</code> or <code>valgrind</code> in this way.</p>"},{"location":"debugging_illixr/#debugging-pull-requests-or-with-a-clean-environment","title":"Debugging Pull Requests or with a Clean Environment","text":""},{"location":"debugging_illixr/#1-get-a-docker-image","title":"1. Get a Docker Image","text":""},{"location":"debugging_illixr/#from-your-local-project","title":"From your Local Project","text":"<p>From the root directory in your project, run:</p> <pre><code>docker build [--build-arg=JOBS=\"&lt;integer&gt;\"] [--no-cache] --tag &lt;repository&gt;:&lt;tag&gt; .\n</code></pre> <p>Note the optional <code>Dockerfile</code> argument, <code>JOBS</code>, which specifies the number of threads/tasks to use for building. Also note the optional argument, <code>--no-cache</code>, which forces Docker to rerun commands in <code>Dockerfile</code>     (see this article for more information). For this project's main module, you can use something like <code>illixr-illixr</code> for the <code>&lt;repository&gt;</code> value,     and your current branch name or release version as the <code>&lt;tag&gt;</code> value.</p> <p>Note that building the docker image can take some time (up to 40min on a 4-core desktop machine) and uses somewhere between 2-4GB of RAM.</p>"},{"location":"debugging_illixr/#from-a-github-pull-requests-cicd-flow","title":"From a GitHub Pull Request's CI/CD Flow","text":"<p>Follow these steps when a CI/CD build fails on a PR:</p> <ul> <li> <p>Click <code>details</code> on the failing build.</p> </li> <li> <p>In the build view go to the Push Docker Image tab and copy the <code>docker push ghcr.io/illixr/illixr-tests:&lt;branch-name&gt;</code> command.</p> </li> <li> <p>Then in your terminal, run:</p> <pre><code>docker pull ghcr.io/illixr/illixr-tests:&lt;branch-name&gt;\n</code></pre> </li> </ul>"},{"location":"debugging_illixr/#2-test-your-image-in-the-docker-container","title":"2. Test your Image in the Docker container","text":"<p>Verify that your image was created successfully:</p> <pre><code>docker image ls\n</code></pre> <p>Take note of your image's <code>REPOSITORY</code> and <code>TAG</code> values. Now run:</p> <pre><code>docker run -it --entrypoint /bin/bash &lt;repository&gt;:&lt;tag&gt;\n</code></pre> <p>You are now in a bash shell in a docker container.</p> <p>From here you can test whichever project flow you wish, such as the usual <code>./runner.sh configs/native.yaml</code>,     or the CI/CD testing flow (<code>./runner.sh configs/ci.yaml</code>).</p>"},{"location":"external_switchboard_and_phonebook/","title":"Using Switchboard and Phonebook Externally","text":"<p>Switchboard was designed as a self-contained entity from ILLIXR that one can reuse in other projects. The relevant API is here for Switchboard and here for Phonebook.</p> <p>One simply needs to copy these files, maintaining directory structure.</p> <pre><code>common/switchboard.hpp\ncommon/phonebook.hpp\ncommon/record_logger.hpp\ncommon/managed_thread.hpp\ncommon/concurrentqueue/blockingconcurrentqueue.hpp\ncommon/concurrentqueue/concurrentqueue.hpp\ncommon/concurrentqueue/lightweightsemaphore.hpp\n</code></pre> <p>This will serve as our <code>main.cpp</code>:</p> <pre><code>#include &lt;iostream&gt;\n#include \"common/switchboard.hpp\"\n\nclass service : public ILLIXR::phonebook::service {\npublic:\n    void act() { std::cout &lt;&lt; \"Hello from service\\n\"; };\n};\n\nclass data : public ILLIXR::switchboard::event {\npublic:\n    data(size_t id_) : id{id_} { }\n    size_t id;\n};\n\nint main() {\n    ILLIXR::phonebook main_pb;\n    main_pb.register_impl&lt;service&gt;(std::make_shared&lt;service&gt;());\n    main_pb.lookup_impl&lt;service&gt;()-&gt;act();\n\n    // From docs of Switchboard: if first arg is null, logging is disabled.\n    // Logging should be disabled if we are running externally.\n    ILLIXR::switchboard main_sb {nullptr};\n    auto writer = main_sb.get_writer&lt;data&gt;(\"topic\");\n    auto reader = main_sb.get_reader&lt;data&gt;(\"topic\");\n    writer.put(writer.allocate&lt;data&gt;(42));\n    std::cout &lt;&lt; \"The answer to life... is \" &lt;&lt; reader.get_ro()-&gt;id &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>We use Switchboard and Phonebook with <code>clang</code> 10 or greater, but you can probably make this work in GCC or other compilers as long as they support C++17.</p> <p>For example:</p> <pre><code># Must copy with directory structure\nmkdir -p common/concurrentqueue\ncp path/to/ILLIXR/common/switchboard.hpp common\ncp path/to/ILLIXR/common/phonebook.hpp common\ncp path/to/ILLIXR/common/record_logger.hpp common\ncp path/to/ILLIXR/common/managed_thread.hpp common\ncp path/to/ILLIXR/common/concurrentqueue/blockingconcurrentqueue.hpp common/concurrentqueue/blockingconcurrentqueue.hpp\ncp path/to/ILLIXR/common/concurrentqueue/concurrentqueue.hpp common/concurrentqueue/concurrentqueue.hpp\ncp path/to/ILLIXR/common/concurrentqueue/lightweightsemaphore.hpp common/concurrentqueue/lightweightsemaphore.hpp\nemacs main.cpp # copy and paste from this doc\n\n# This will *probbaly* work with any C++-17 compatible compiler, but I've tested with clang-10.\n# Nix is my preferred package manager, but you can use whichever you like.\n# This command will not affect system packages, just create a temporary environment with the right clang.\nnix-shell -p clang_10\n\n# Compile\nclang++ -Wextra -pthread -std=c++17 main.cpp\n\n# Run\n./a.out\n</code></pre> <p>The output is:</p> <pre><code>Register 7service\nHello from service\nCreating: topic for 4data\nThe answer to life... is 42\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>These instructions have been tested with Ubuntu 18.04 and 20.04.</p>"},{"location":"getting_started/#illixr-runtime-without-monado","title":"ILLIXR Runtime without Monado","text":"<ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/ILLIXR/ILLIXR\n</code></pre> <p>Note for ILLIXR versions older than <code>v2.2.0</code>:</p> <p>Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately:</p> <pre><code>git submodule update --init --recursive\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>./install_deps.sh [--jobs &lt;integer&gt;]\n</code></pre> <p>This script installs some Ubuntu/Debian packages and builds several dependencies from source. Without any arguments, the script will print the help message, and proceed using default values. To change the number of threads/tasks to use for building, specify using the <code>--jobs</code> argument. Other available options can be inspected using the <code>--help</code> flag.</p> </li> <li> <p>Inspect <code>configs/native.yaml</code>.</p> <p>The schema definition is in <code>runner/config_schema.yaml</code>. For more details on the runner and the config files, see Building ILLIXR.</p> </li> <li> <p>Build and run ILLIXR without Monado:</p> <pre><code>./runner.sh configs/native.yaml\n</code></pre> <p>If you are running ILLIXR without a graphical environment,     try ILLIXR headlessly using Xvfb:</p> <pre><code>./runner.sh configs/headless.yaml\n</code></pre> </li> <li> <p>To clean up after building, run:</p> <pre><code>./runner.sh configs/clean.yaml\n</code></pre> <p>Or simply:</p> <pre><code>./clean.sh\n</code></pre> </li> </ol>"},{"location":"getting_started/#illixr-runtime-with-monado","title":"ILLIXR Runtime with Monado","text":"<p>ILLIXR leverages Monado, an open-source implementation of OpenXR,     to support a wide range of OpenXR client applications. Because of a low-level driver issue, Monado only supports Ubuntu 18.04+.</p> <ol> <li> <p>Compile and run:</p> <pre><code>./runner.sh configs/monado.yaml\n</code></pre> </li> </ol>"},{"location":"getting_started/#illixr-under-virtualization","title":"ILLIXR under Virtualization","text":"<p>ILLIXR can be run inside a QEMU-KVM image. Check out the instructions here.</p>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Try browsing the source for the runtime and provided plugins. The source code is divided into components in the following directories:</p> <ul> <li> <p><code>ILLIXR/runtime/</code>:     A directory holding the implementation for loading and interfacing plugins.     This directory contains Spindle.</p> </li> <li> <p><code>ILLIXR/common/</code>:     A directory holding resources and utilities available globally to all plugins.     Most plugins symlink this directory into theirs.     This directory contains the interfaces for Switchboard and Phonebook.</p> </li> <li> <p><code>ILLIXR/&lt;plugin_dir&gt;/</code>:     A unique directory for each plugin.     Most of the core XR functionality is implemented via plugins.     See Default Components for more details.</p> </li> </ul> <p>If you edit any of the source files, the runner will detect and rebuild the respective binary     the next time it runs. If you want to add your own plugin, see Writing Your Plugin.</p> <p>Otherwise, proceed to the next section, Building ILLIXR.</p>"},{"location":"glossary/","title":"Glossary of ILLIXR Terminology","text":"<p>A collection of ILLIXR and ILLIXR-adjacent terms and their definitions can be found     on this page your reference.</p>"},{"location":"glossary/#general","title":"General","text":""},{"location":"glossary/#runtime","title":"Runtime","text":"<p>The ILLIXR system runtime is responsible for the dynamic orchestration of ILLIXR     device resources,     system resources,     and     client applications.</p> <p>The runtime implementation is located in <code>ILLIXR/runtime/</code>. See the Building ILLIXR and Monado Overiew pages for details about the ILLIXR runtime.</p>"},{"location":"glossary/#plugin","title":"Plugin","text":"<p>A modular component that can be detected and enabled for use by an ILLIXR application. A plugin can be internal or external to the ILLIXR project. Each plugin is compiled and launched dynamically at runtime based on the     ILLIXR configuration used. ILLIXR also implements a Monado runtime translation Plugin.</p> <p>For a list of supported plugins and their details, see the ILLIXR Plugins page. For instructions for how to modify or write your own plugins, see the Modifying a Plugin     and Writing Your Plugin pages.</p> <p>See the Plugin API documentation.</p>"},{"location":"glossary/#configuration","title":"Config(uration)","text":"<p>A file describing the key information required to launch an ILLIXR application. Configurations for ILLIXR are implemented as YAML files. Each configuration comprises an action, a profile, and a list of plugins as     defined by our configuration specification Schema.</p> <ul> <li> <p>Action (Previously Loader):     An action encapsulates a task for Runner.</p> <ul> <li> <p><code>native</code>:     The default application launch configuration.     Does not use our Monado runtime integration.     Defined in <code>ILLIXR/configs/native.yaml</code>.</p> </li> <li> <p><code>native-lookup</code>:     Same as <code>native</code>, but using a ground truth lookup from a file for         the pose instead of computing it.     Defined in <code>ILLIXR/configs/native-lookup.yaml</code>.</p> </li> <li> <p><code>headless</code>:     Same as <code>native</code>, but using Xvfb to run without a graphical environment.     Defined in <code>ILLIXR/configs/headless.yaml</code>.</p> </li> <li> <p><code>ci</code>:     Same as <code>headless</code>, but using Docker virtualization and debug-enabled compilation.     Defined in <code>ILLIXR/configs/ci.yaml</code>.</p> </li> <li> <p><code>monado</code>:     Similar to <code>native</code>, but uses our Monado runtime integration.     Defined in <code>ILLIXR/configs/monado.yaml</code>.</p> </li> <li> <p><code>clean</code>:     A meta-task that fetches all supported plugins and then cleans up builds across         the entire ILLIXR project.     Defined in <code>ILLIXR/configs/clean.yaml</code> and supported by <code>ILLIXR/clean.sh</code>.</p> </li> <li> <p><code>docs</code>:     A meta-task that generates and populates the documention subdirectories in the project.</p> </li> </ul> </li> <li> <p>Profile:     A profile captures the compilation mode used by Runner.</p> <ul> <li> <p><code>opt</code>:     Sets Runner to compile the ILLIXR application and plugins with optimizations.</p> </li> <li> <p><code>dbg</code>:     Sets Runner to compile the ILLIXR application and plugins without optimizations,         while enabling debug logic and debug logging.</p> </li> </ul> </li> <li> <p>Schema:     A schema captures the specification describing the allowable structure of         a configuration file.     Our schema is implemented using the json-schema specification.     Defined in <code>ILLIXR/runner/config_schema.yaml</code>.</p> </li> </ul> <p>For more details about the structure of a configuration, see the Building ILLIXR page.</p>"},{"location":"glossary/#framebuffer","title":"Framebuffer","text":"<p>A region of memory used to hold graphical information to be output to a display or graphics device.</p> <ul> <li> <p>Frame:     A single frame (image) to be output to a display at a certain instant of time based on the         system's frame rate.</p> </li> <li> <p>Frame Rate:     The interval period between complete (as defined by the output resolution) frame updates         and refreshes.     In many systems, the target frame rate is determined by a fixed vertical sync (VSYNC) period.</p> </li> <li> <p>Depth Buffer:     A framebuffer representing the depth information of a 3D scene.     Depth information is useful for applications such as graphics and SLAM.</p> </li> <li> <p>Eye Buffer:     A framebuffer dedicated for display through a HMD lens to be perceived by a user's eye.</p> </li> </ul> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#swap-chain","title":"Swap Chain","text":"<p>A set of virtual framebuffers to be output to a display. Only one framebuffer in a swap chain is displayed at a time, enabling the     other virtual framebuffers to be concurrently modified in memory.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#compositor","title":"Compositor","text":"<p>A window manager that establishes a framebuffer for each window of a graphical system. A compositor merges information across its windows to construct a unified framebuffer.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#head-mounted-display","title":"Head-mounted Display","text":"<p>A display device worn on the head and face for use with VR and XR applications. Also known as a HMD.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#eye-tracking","title":"Eye Tracking","text":"<p>The process of measuring the eye movement of a user (who is possibly also wearing a HMD).</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#event-stream","title":"Event Stream","text":"<p>A communication interface supporting writes, sychronous reads, and asynchronous reads. For synchronous reads, every value written to the stream is visible to consumers. For asynchronous reads, only the latest values written are guaranteed to be visible to consumers.</p>"},{"location":"glossary/#pose","title":"Pose","text":"<p>The combination of orientation and position of an object, used for computer vision     and robotics applications. ILLIXR applications make use of poses to track the user's HMD within the virtual environment. Internally, ILLIXR has multiple classifications of poses which are used for various purposes.</p> <ul> <li> <p>Slow Pose:     A slow pose is a ... TODO</p> </li> <li> <p>Fast Pose:     A fast pose is a ... TODO</p> </li> <li> <p>True Pose:     A true pose is a ... TODO Depracated starting ILLIXR release <code>v2.X.X</code>.</p> </li> <li> <p>Pose Prediction:     To improve the user's perception latency experience the time between, pose prediction         uses history and current system information to pre-compute the user's next pose     Pre-computing the next pose allows for components downstream from the pose output         in the event stream dataflow graph to begin computation.</p> </li> </ul> <p>Pose Prediction is implemented in the <code>pose_prediction</code> ILLIXR plugin.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#ground-truth","title":"Ground Truth","text":"<p>The most accurate source of measurement available for a data set. Typically, ground truth measurements are provided for the evaluation of sensor data where the sensor     or other data source is not as accurate or reliable as the source for the ground truth.</p> <ul> <li> <p>Ground Truth Poses:     A collection of poses used to evaluate the accuracy of pose generation and prediction algorithms.</p> </li> <li> <p>Ground Truth Images:     A collection of images used to evaluate the accuracy of visual processing algorithms,         like SLAM and VIO.</p> </li> </ul> <p>See the ILLIXR Plugins page for information about sensors implemented in ILLIXR.</p>"},{"location":"glossary/#inertial-measurement-unit","title":"Inertial Measurement Unit","text":"<p>A device that reports its orientation in space and any forces applied it. Also known as an IMU.</p> <p>An IMU is implemented in the <code>offline_imu_cam</code> ILLIXR plugin.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#simultaneous-localization-and-mapping","title":"Simultaneous Localization and Mapping","text":"<p>The computational process of creating a map of an unknown environment, and finding one's location     within that space. Also known as SLAM.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#visual-interial-odometry","title":"Visual Interial Odometry","text":"<p>The process of computing a pose estimate from incoming visual information and measurements     from the IMU. Also known as VIO. Often used in combination with SLAM techniques.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#asynchronous-reprojection","title":"Asynchronous Reprojection","text":"<p>The processing of rendered video for motion interpolation. Asynchronous reprojection improves the perception of the rendered video to the HMD     when rendering misses it target frame rate.</p> <p>Asynchronous reprojection is implemented in the <code>timewarpgl</code> ILLIXR plugin.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#distortion-correction","title":"Distortion Correction","text":"<p>The processing of visual anomalies in images where rectilinear features have been warped.</p> <p>For more information, see the Wikipedia artice.</p>"},{"location":"glossary/#chromatic-abberation-correction","title":"Chromatic Abberation Correction","text":"<p>The processing of visual anomalies in images where colors are diffracted due to imperfect optics     or other perturbing factors.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#components","title":"Components","text":""},{"location":"glossary/#runner","title":"Runner","text":"<p>An ILLIXR tool responsible for     preparing the environment,     downloading required assets &amp; code,     compiling each plugin,     and     launching the ILLIXR application. The implementation resides in <code>ILLIXR/runner/</code>, and can be launched with     the appropriate environment setup via <code>ILLIXR/runner.sh</code>.</p> <ul> <li>Action (Previously Loader):     See Configuration.</li> </ul>"},{"location":"glossary/#spindle","title":"Spindle","text":"<p>An ILLIXR component responsible for launching and managing plugin threads. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Spindle API documentation.</p>"},{"location":"glossary/#phonebook","title":"Phonebook","text":"<p>An ILLIXR service directory used to introspectively interface plugins and their data. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Phonebook API documentation.</p>"},{"location":"glossary/#switchboard","title":"Switchboard","text":"<p>An ILLIXR event stream manager that maintains data pipelines between plugins. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Switchboard API documentation.</p>"},{"location":"glossary/#technologies","title":"Technologies","text":""},{"location":"glossary/#openxr","title":"OpenXR","text":"<p>An open standard for Augmented and Virtual Reality. ILLIXR components target the OpenXR standard and interact with the ILLIXR device     via the Application Interface.</p> <p>For more information, visit the official site from the Khronos Group.</p>"},{"location":"glossary/#monado","title":"Monado","text":"<p>An open source, modular implementation of the OpenXR standard for GNU/Linux.</p> <p>See the ILLIXR Monado Overview and Monado Dataflow pages for details about our     runtime integration using Monado.</p> <p>For more information, visit the official Monado development site.</p>"},{"location":"glossary/#godot","title":"Godot","text":"<p>An open source game development engine. ILLIXR applications targeting the OpenXR use Godot to access the engine's integration     with the OpenXR standard via Monado.</p> <p>For more information, visit the official Godot site.</p>"},{"location":"glossary/#xvfb","title":"Xvfb","text":"<p>A virtual framebuffer for the X11 Window Sytem. ILLIXR uses Xvfb to enable running the graphical ILLIXR application without requiring the user     to have a graphical environment configured at application launch.</p> <p>For more information, see the Xfvb man page.</p>"},{"location":"glossary/#docker","title":"Docker","text":"<p>A platform and containerization framework for deploying applications under virtualization. ILLIXR uses Docker to deploy and test code in a continuous integration and deployment pipeline.</p> <p>For more information, see the Docker overview and getting started page.</p>"},{"location":"glossary/#qemu-kvm","title":"QEMU-KVM","text":"<p>An open source virtulization tool and machine emulator. See the instructions for running ILLIXR under Virtualization.</p> <p>For more information, see the official QEMU page.</p>"},{"location":"glossary/#yaml","title":"YAML","text":"<p>A markup language and data serilization standard designed to be user friendly. We make use of the PyYAML and pyyaml-include libraries to implement     our Configuration implementation.</p> <p>For more information, visit the official YAML page.</p>"},{"location":"glossary/#sqlite","title":"SQLite","text":"<p>A SQL database engine implementation in C designed to be lightweight and easy to use. The ILLIXR project allows user to records application statistics to a local database     for efficient processing. See the Logging and Metrics page for usage details.</p> <p>For more information, see the SQLite development site.</p>"},{"location":"glossary/#vulkan","title":"Vulkan","text":"<p>A cross-platform graphics API that allows developers to efficiently target     low-level hardware features.</p> <p>For more information, see the official Vulkan page from the Khronos Group.</p>"},{"location":"glossary/#opengl","title":"OpenGL","text":"<p>A cross-platform graphics API that allows developers to create graphics applications     easily and portably. Also known as GL.</p> <ul> <li> <p>GL Context:     A data structure storing the state of an OpenGL application instance.     Within a GL context resides framebuffer data.     It is not thread safe to share contexts without appropriate synchronization.</p> </li> <li> <p>GLFW:     An open source implementation of OpenGL.     Supports Windows, MacOS and, Linux (X11 and Wayland).     See the GLFW development site.</p> </li> </ul> <p>For more information, see the official OpenGL page from the Khronos Group.</p>"},{"location":"glossary/#ubuntu","title":"Ubuntu","text":"<p>An open source GNU/Linux operating system and distribution. ILLIXR currently supports the Long Term Support (LTS) versions of Ubuntu:     18.04 LTS (Bionic)     and     20.04 LTS (Focal).</p> <p>For more information, visit the official Ubuntu site.</p>"},{"location":"illixr_plugins/","title":"ILLIXR plugins","text":"<p>This page details the structure of ILLIXR's plugins and how they interact with each other.</p>"},{"location":"illixr_plugins/#default-plugins","title":"Default Plugins","text":"<ul> <li> <p><code>offline_imu_cam</code>:     Reads IMU data and images from files on disk, emulating a real sensor on the headset         (feeds the application input measurements with timing similar to an actual IMU).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_cam_type</code> on <code>imu_cam</code> topic.</li> </ul> </li> <li> <p><code>ground_truth_slam</code>:     Reads the ground truth from the same dataset as the <code>offline_imu_cam</code> plugin.     Ground truth data can be compared against the measurements from <code>offline_imu_cam</code> for accuracy.     Timing information is taken from the <code>offline_imu_cam</code> measurements/data.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> on <code>true_pose</code> topic.</li> <li>Asynchronously reads <code>imu_cam_type</code> on <code>imu_cam</code> topic.</li> </ul> </li> <li> <p><code>kimera_vio</code>:     Runs Kimera-VIO (upstream) on the input, and outputs the headset's pose.     In practice, the Kimera-VIO plugin publishes a fairly slow pose, so IMU integration         and pose prediction is required to infer a fast pose.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> on <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> on <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_cam_type</code> on <code>imu_cam</code> topic.</li> </ul> </li> <li> <p><code>gtsam_integrator</code>:     Integrates over all IMU samples since the last published SLAM pose to provide a         fast pose every time a new IMU sample arrives using the GTSAM library (upstream).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_raw_type</code> on <code>imu_raw</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_cam_type</code> on <code>imu_cam</code> topic.</li> <li>Asynchronously reads <code>imu_integrator_input</code> on <code>imu_integrator_input</code> topic.</li> </ul> </li> <li> <p><code>pose_prediction</code>:     Uses the latest IMU value to predict a pose for a future point in time.     Implements the <code>pose_prediction</code> service (defined in <code>common</code>),         so poses can be served directly to other plugins.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>pose_type</code> on <code>slow_pose</code> topic,         but it is only used as a fallback.</li> <li>Asynchronously reads <code>imu_raw</code> on <code>imu_raw</code> topic.</li> <li>Asynchronously reads <code>pose_type</code> on <code>true_pose</code> topic,         but it is only used if the client asks for the true pose.</li> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic.     This tells <code>pose_predict</code> what time to estimate for.</li> </ul> </li> <li> <p><code>gldemo</code>:     Renders a static scene (into left and right eye buffers) given the pose         from <code>pose_prediction</code>.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> <li>Publishes <code>rendered_frame</code> on <code>eyebuffer</code> topic.</li> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic.</li> </ul> </li> <li> <p><code>timewarp_gl</code>:     Asynchronous reprojection of the eye buffers.     The timewarp ends just after vsync, so it can deduce when the next vsync will be.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> <li>Asynchronously reads <code>rendered_frame</code> on <code>eyebuffer</code> topic.</li> <li>Publishes <code>time_type</code> on <code>vsync_estimate</code> topic.</li> <li>Publishes <code>hologram_input</code> on <code>hologram_in</code> topic.</li> <li>Publishes <code>texture_pose</code> on <code>texture_pose</code> topic if <code>ILLIXR_OFFLOAD_ENABLE</code> is set in the env.</li> </ul> </li> <li> <p><code>debugview</code>:     Renders incoming frames from the graphics pipeline for debugging live executions of the application.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> <li>Asynchronously reads <code>fast_pose</code> on <code>imu_raw</code> topic. (IMU biases are unused).</li> <li>Asynchronously reads <code>slow_pose</code> on <code>slow_pose</code> topic.</li> <li>Synchronously reads <code>imu_cam</code> on <code>imu_cam</code> topic.</li> </ul> </li> <li> <p><code>audio_pipeline</code>:     Launches a thread for binaural recording and one for binaural playback.     Audio output is not yet routed to the system's speakers or microphone,         but the plugin's compute workload is still representative of a real system.     By default this plugin is enabled (see <code>native</code> configuration).</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> </ul> </li> </ul> <p>Below this point, we will use Switchboard terminology. Read the API documentation on Switchboard for more information.</p> <p></p> <ul> <li> <p>In the above figure, rectangles are plugins.</p> </li> <li> <p>Solid arrows from plugins to topics represent publishing.</p> </li> <li> <p>Solid arrows from topics to plugins represent synchronous reading.     Some action is taken for every event which gets published on the topic.</p> </li> <li> <p>Dashed arrows from topics to plugins represent asynchronous reading.     Plugin readers only need the latest event on their topic.</p> </li> <li> <p>Imagine the topic as a trough filling with events from its publisher.     Synchronous readers (AKA subscribers) drain the trough,         while asynchronous readers just skim fresh events off the top of the trough.</p> </li> </ul> <p>See Writing Your Plugin to extend ILLIXR.</p>"},{"location":"illixr_plugins/#other-supported-plugins","title":"Other Supported Plugins","text":"<p>ILLIXR supports additional plugins to replace some of the default plugins.</p> <ul> <li> <p><code>hologram</code>:     Adapts the eyebuffer for use on a holographic display.     By default, this plugin is disabled, since an NVIDIA GPU is currently required.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>hologram_input</code> on <code>hologram_in</code> topic.     Hologram is too slow to run for every input,         so the plugin implements an asynchronous reader which can drop inputs.</li> </ul> </li> <li> <p><code>open_vins</code>:     An alternate SLAM (upstream) implementation that uses a MSCKF         (Multi-State Constrained Kalman Filter) to determine poses via camera/IMU.</p> <p>Topic details:</p> <ul> <li>Same interface as <code>Kimera-VIO</code>.</li> </ul> </li> <li> <p><code>rk4_integrator</code>:     Integrates over all IMU samples since the last published SLAM pose to         provide a fast pose every time a new IMU sample arrives using RK4 integration.</p> <p>Topic details:</p> <ul> <li>Same interface as <code>gtsam_integrator</code>.</li> </ul> </li> <li> <p><code>pose_lookup</code>:     Implements the <code>pose_predict</code> service, but uses ground truth from the dataset.     The plugin peeks \"into the future\" to determine what the exact pose will be at a certain time.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic.     This tells <code>pose_lookup</code> what time to lookup.</li> </ul> </li> <li> <p><code>offload_data</code>:     Writes frames and poses output from the asynchronous reprojection plugin to disk for analysis.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>texture_pose</code> on <code>texture_pose</code> topic.</li> </ul> </li> <li> <p><code>zed</code>:     Reads images and IMU measurements from the ZED Mini.     Unlike <code>offline_imu_cam</code>, <code>zed</code> additionally has RGB and depth data.     Note that this plugin implements two threads: one for the camera, and one for the IMU.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_cam_type</code> on <code>imu_cam</code> topic.</li> <li>Publishes <code>rgb_depth_type</code> on <code>rgb_depth</code> topic.</li> </ul> </li> <li> <p><code>realsense</code>:     Reads images and IMU measurements from the Intel Realsense.</p> <p>Topic details:</p> <ul> <li>Same interface as <code>zed</code>.</li> </ul> </li> </ul> <p>See Building ILLIXR for more information on adding plugins to a config file.</p>"},{"location":"logging_and_metrics/","title":"Logging and Metrics","text":"<p>The ILLIXR project supports several ways for an ILLIXR application to log and report details about     its execution.</p>"},{"location":"logging_and_metrics/#logging","title":"Logging","text":"<p>ILLIXR implements a modular logging system that enables users to capture and record key statistics     in real-time.</p> <ul> <li> <p><code>record_logger</code>:     The base class describing ILLIXR's logging interface.</p> </li> <li> <p><code>noop_logger</code>:     Implements a trivially empty implementation of <code>record_logger</code>.     Can be used for debugging or performance if runtime statistics are not needed.</p> </li> <li> <p><code>sqlite_record_logger</code>:     Extends the <code>record_logger</code> to store records in a local SQLite database.</p> </li> </ul>"},{"location":"logging_and_metrics/#metrics","title":"Metrics","text":"<p>ILLIXR allows users to generate higher order statistics from logged results called Metrics.</p> <p>TODO</p>"},{"location":"modifying_a_plugin/","title":"Modifying a plugin","text":""},{"location":"modifying_a_plugin/#tutorial","title":"Tutorial","text":"<p>This is how you can modify an existing ILLIXR plugin</p> <ol> <li> <p>Clone the repository for the component you want to modify.     For example:</p> <pre><code>git clone https://github.com/ILLIXR/audio_pipeline.git\n</code></pre> </li> <li> <p>Modify the config file like this:</p> <p>Original Config</p> <pre><code>plugin_group:\n  - path: timewarp_gl/\n  - name: audio\n    path:\n      git_repo: https://github.com/ILLIXR/audio_pipeline.git\n      version: 3433bb452b2ec661c9d3ef65d9cf3a2805e94cdc\n</code></pre> <p>New Config</p> <pre><code>plugin_group:\n  - path: timewarp_gl/\n  - path: /PATH/TO/LOCAL/AUDIO-PLUGIN\n</code></pre> </li> <li> <p>See the instructions on Building ILLIXR to learn how to run ILLIXR.</p> </li> <li> <p>To push the modification to upstream ILLIXR, push up the changes to the plugin's repository         and modify the original config with the commit version updated.     Then create a PR on the main ILLIXR repository.</p> </li> </ol>"},{"location":"monado_illixr_runtime_overview/","title":"Monado Integration Overview","text":"<p>ILLIXR's Plugins provide XR services, and the Runtime ties them together. However, we don't want to force developers to write their whole application specifically     for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR,     so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado, an existing, open-source implementation     of the standard.</p> <ul> <li> <p>When running ILLIXR without Monado, the ILLIXR runtime is the entry-point.     Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app.</p> </li> <li> <p>When running from Monado, however, as mandated by OpenXR specifications,         the application is the entry point.     As a result, the ILLIXR runtime system is loaded at a later point as a shared library.     This page documents the changes to the ILLIXR runtime when an OpenXR application is used.</p> </li> </ul>"},{"location":"monado_illixr_runtime_overview/#openxr-application-launch","title":"OpenXR Application Launch","text":"<p>As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a     configuration JSON file pointed to by an environment variable and loads the OpenXR runtime,     which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronos Group for more details.</p>"},{"location":"monado_illixr_runtime_overview/#monado-device-probe-and-illixr-initialization","title":"Monado Device Probe and ILLIXR Initialization","text":"<p>During initialization, Monado asks all drivers to probe for and initialize HMDs     and controllers, internally known as <code>xdev</code>s. Our ILLIXR driver will always respond to Monado with one discovered HMD that     will be used to capture OpenXR queries and events from Monado's state tracker. The driver obtains the path to the ILLIXR runtime <code>.so</code> file and a list of plugins from     environment variables.</p> <p>After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime,     which we capture and send to the ILLIXR driver. At this moment, all necessary data is ready and ILLIXR will be launched.</p>"},{"location":"monado_illixr_runtime_overview/#illixr-runtime-launch","title":"ILLIXR Runtime Launch","text":"<p>When used with Monado, the ILLIXR Runtime is compiled into     a shared library instead of an executable. The library exports its two major functionalities:     initializing Switchboard and Phonebook,     and     loading Plugins.</p> <p>The driver starts to load the runtime by loading the shared library into the current     (application's) address space and calls the Switchboard and Phonebook initialization. Then, it calls the plugin loading for each ILLIXR plugin     (except <code>gldemo</code>, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path     to load a Translation Plugin into ILLIXR as the application. If the plugin implements a long running computation, it may block the main ILLIXR thread     which drives the entire application. To remedy this, a plugin should implement long running processing in its own thread. This way, the driver will be able to reacquire control and return to Monado     and the application efficiently.</p>"},{"location":"monado_illixr_runtime_overview/#translation-plugin","title":"Translation Plugin","text":"<p>When the application and all ILLIXR plugins are up and running,     the translation plugin handles the connection between Monado and ILLIXR. It might be confusing to see that this plugin is part of the ILLIXR driver which is part of     Monado while at the same time also part of ILLIXR as a plugin. However, Monado and ILLIXR are running in different threads in the same address space. The translation plugin is the interface of these two parallel systems.</p> <p>The translation plugin handles two types of events at the moment:     pose requests and frame submissions. From the view of Monado, the translation plugin is the destination of all requests:     from the application,     to Monado's state trackers,     to the xdev interface who is responsible for servicing the request. From the view of ILLIXR, the translation plugin behaves the same as the <code>gldemo</code> application:     reading pose and submitting frames.</p> <p>For implementation details regarding the representation of poses and frames in Monado     and in ILLIXR, please see ILLIXR's Monado Integration Dataflow.</p>"},{"location":"monado_integration_dataflow/","title":"Monado Dataflow","text":""},{"location":"monado_integration_dataflow/#monado-integration-dataflow","title":"Monado Integration Dataflow","text":"<p>The dataflow for the ILLIXR Monado integration comprises two steps: 1.  getting pose data from ILLIXR,     and 1.  sending a user rendered frame back to ILLIXR.</p> <p>In Monado, ILLIXR is recognized as an HMD for Monado, while in ILLIXR,     Monado looks like a user application (such as <code>gldemo</code>). After ILLIXR is initialized from Monado, and Monado is registered as a plugin for ILLIXR,     the most recent pose information can be easily obtained via Switchboard.</p> <p>The compositor side of Monado integration with ILLIXR is implemented more subtly. The original Monado compositor primarily performs distortion correction     and aberration correction in a Vulkan back-end compositor. The compositor also has two client compositors (one for OpenGL applications and another     for Vulkan applications) which pass frame data to the back-end compositor. ILLIXR integration intercepts the frame at GL client compositor and sends it to Switchboard     of ILLIXR, which is then used by <code>timewarp_gl</code> component.</p> <p>To get an OpenGL frame and use it without copying pixels, ILLIXR needs to get the user     application GL context. This is done at OpenXR session creation time, where ILLIXR is initialized. Note that, logically, ILLIXR is initialized during OpenXR instance creation,     or is otherwise running in the background all the time. Currently, ILLIXR is initialized at session creation time, since ILLIXR only supports single     OpenXR session, and requires a user application GL context upon initialization,</p> <p>The current ILLIXR integration for Monado is a temporary solution and has some drawbacks caused     by the concurrent and continued development from both the Monado and ILLIXR projects. The integration:</p> <ol> <li> <p>Does not use the pose that user application declares to use at rendering         (using the OpenXR specification).     This is due to incongruencies with Monado's internal interfaces and representations.     The pose difference used by timewarp is computed using the most recent query         for a pose update.</p> </li> <li> <p>Cannot submit frame data with a depth buffer.</p> </li> <li> <p>Cannot have poses that make use of OpenXR Spaces.     Raw pose data is instead retrieved from the application's SLAM algorithms.</p> </li> <li> <p>Does not support controller action.</p> </li> <li> <p>Only supports GL user-space applications.</p> </li> <li> <p>User-space applications cannot acquire more than one swap chain buffer for each eye         during the the processing of a frame.</p> </li> <li> <p>Must initialize ILLIXR during the session initialization.</p> </li> </ol>"},{"location":"updating_tags_and_docs/","title":"Updating Tags and Documentation","text":""},{"location":"updating_tags_and_docs/#updating-tags","title":"Updating Tags","text":"<p>For releases, perform these steps from <code>master</code> once the desired features have been merged in.</p> <ol> <li> <p>Get latest tags:</p> <pre><code>git pull --tags -f\n</code></pre> </li> <li> <p>Tag your branch. Please use semantic versioning to name the tag; i.e., <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>:</p> <pre><code>git tag -f &lt;tag-name&gt; ## `-f` is required if updating an existing tag\n</code></pre> </li> <li> <p>Push your tag upstream:</p> <pre><code>git push origin --tags\n</code></pre> </li> </ol>"},{"location":"updating_tags_and_docs/#updating-documentation","title":"Updating Documentation","text":"<p>Perform these steps from the root directory of the project.</p> <ol> <li> <p>Create the directory where the generated files will be placed:</p> <pre><code>mkdir -p site/api\n</code></pre> </li> <li> <p>Run <code>doxygen</code> to generate API documentation:</p> <pre><code>doxygen doxygen.conf\n</code></pre> </li> <li> <p>Run <code>mkdocs</code> to deploy new documentation:</p> <pre><code>mkdocs gh-deploy\n</code></pre> </li> </ol>"},{"location":"virtualization/","title":"Setting up ILLIXR in QEMU","text":""},{"location":"virtualization/#build-qemu","title":"Build QEMU","text":"<p>Run <code>ILLIXR/install_deps.sh</code> and select <code>yes</code> when asked to install QEMU. This will build QEMU and install it to <code>/opt/ILLIXR</code>.</p>"},{"location":"virtualization/#why-build-qemu-from-source","title":"Why build QEMU from source?","text":"<p>The version of QEMU available through package managers doesn't always ship with all     the options we need to run ILLIXR, so building QEMU from source is the best option. This <code>qemu</code> installation will not conflict with existing <code>qemu</code> installs on your system.</p>"},{"location":"virtualization/#setup-ubuntu-in-the-vm","title":"Setup Ubuntu in the VM","text":"<p>Run <code>ILLIXR/qemu/run.sh</code> to download Ubuntu 18.04, create a virtual hard drive     (<code>illixr.qcow2</code>), and launch <code>qemu</code> from <code>/opt/ILLIXR</code>.</p> <p>Your VM image will be created at <code>ILLIXR/qemu/illixr.qcow2</code>. Ubuntu will be downloaded and saved at <code>ILLIXR/qemu/ubuntu-18.04.5-desktop-amd64.iso</code>.</p> <p>You will be prompted to install Ubuntu;     follow the instructions and install Ubuntu to the virtual hard drive.</p> <p></p> <p>Choose the \"erase all\" option and confirm:</p> <p> </p> <p>Pick any account name and password you like.</p> <p></p> <p>Once Ubuntu is installed you will be asked to reboot. Close <code>qemu</code> and then run <code>./run.sh</code> again to boot into your brand new Ubuntu install!</p>"},{"location":"virtualization/#booting-the-vm","title":"Booting the VM","text":"<p>To launch the VM from now on, just use <code>ILLIXR/qemu/run.sh</code>. This will boot from the Ubuntu image we created earlier (<code>illixr.qcow2</code>). Once Ubuntu is installed, it is safe to delete <code>ubuntu-18.04.5-desktop-amd64.iso</code>.</p>"},{"location":"virtualization/#setting-up-the-vm","title":"Setting up the VM","text":"<p>Once inside the VM, set up and run ILLIXR as found on the Getting Started page.</p>"},{"location":"virtualization/#uninstalling","title":"Uninstalling","text":"<p>To delete your local VM, just delete <code>ILLIXR/qemu/illixr.qcow2</code>.</p> <p><code>ILLIXR/qemu/ubuntu-18.04.5-desktop-amd64.iso</code> can be deleted anytime you want after Ubuntu     is installed to your VM.</p> <p>If you've deleted <code>illixr.qcow2</code>, you can run <code>run.sh</code> to recreate it and reinstall everything.</p>"},{"location":"writing_your_plugin/","title":"Writing Your Plugin","text":""},{"location":"writing_your_plugin/#adding-a-new-plugin-common-case","title":"Adding a New Plugin (Common Case)","text":"<p>In the common case, you only need to define a <code>Makefile</code> with the line <code>include common/common.mk</code>     and symlink common (<code>ln -s ../common common</code>). The included recipe file provides the necessary targets and uses the compiler <code>$(CXX)</code>,     which is defined based on the OS and environment variables. The included <code>Makefile</code>:</p> <ul> <li> <p>Compiles <code>plugin.cpp</code> and any other <code>*.cpp</code> files into the plugin.</p> </li> <li> <p>Will invoke a recompile of the target any time any <code>*.hpp</code> or <code>*.cpp</code> file changes.</p> </li> <li> <p>Compiles with C++17.     You can change this in your plugin by defining         <code>STDCXX = ...</code> before the <code>include</code>.     This change will not affect other plugins; just yours.</p> </li> <li> <p>Accepts specifying libraries by appending to <code>LDFLAGS</code> and <code>CFLAGS</code>.     For example:</p> <pre><code>LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3)\nCFLAGS  := $(CFLAGS) $(shell pkg-config --cflags eigen3)\n</code></pre> <p>See the source for the other flags and variables that you can set.</p> </li> </ul> <p>Finally, place the path of your plugin directory in the <code>plugin_group</code> list     for the configuration you would like to run (e.g. <code>ILLIXR/configs/native.yaml</code>).</p>"},{"location":"writing_your_plugin/#adding-a-new-plugin-general-case","title":"Adding a New Plugin (General Case)","text":"<p>Each plugin can have a completely independent build system, as long as:</p> <ul> <li> <p>It defines a <code>Makefile</code> with targets for <code>plugin.dbg.so</code>, <code>plugin.opt.so</code>, and <code>clean</code>.     Inside this <code>Makefile</code>, one can defer to another build system.</p> </li> <li> <p>Its compiler maintains ABI compatibility with the compilers used in every other plugin.     Using the same version of Clang or GCC on the same architecture is sufficient for this.</p> </li> <li> <p>Its path is in the <code>plugin_group</code> list for the configuration you would like         to run (e.g. <code>ILLIXR/configs/native.yaml</code>).</p> </li> </ul>"},{"location":"writing_your_plugin/#tutorial","title":"Tutorial","text":"<p>You can extend ILLIXR for your own purposes. To add your own functionality via the plugin interface:</p> <ol> <li> <p>Create a new directory anywhere for your new plugin and set it up for ILLIXR.     We recommend you also push this plugin to a git repository on Github/Gitlab if you want it         as a part of upstream ILLIXR in the future.</p> <ul> <li> <p>Create a <code>Makefile</code> with the following contents.     See Building ILLIXR for more details and alternative setups.</p> <pre><code>include common/common.mk\n</code></pre> </li> </ul> </li> <li> <p>You must decide if your plugin should inherit the standardized <code>threadloop</code>         or <code>plugin</code>.</p> <ul> <li> <p>If your plugin just needs to run one computation repeatedly, then your         plugin class should extend <code>threadloop</code>. Your code goes in         <code>_p_one_iteration</code>, which gets called in a hot loop. <code>threadloop</code>         inherits from plugin, but adds threading functionality. If you don't         use <code>_p_one_iteration</code>, inheriting from <code>threadloop</code> is superfluous;         Inherit from plugin directly instead.</p> </li> <li> <p>If you need custom concurrency (more complicated than a loop), triggered         concurrency (by events fired in other plugins), or no concurrency         then your plugin class should extend <code>plugin</code>. Your code goes         in the <code>start</code> method.</p> </li> <li> <p>If you want to schedule data-driven work in either case, call   <code>sb-&gt;schedule(...)</code>.</p> </li> <li> <p>If you spin your own threads, they must wait for       <code>pb-&gt;lookup_impl&lt;Stoplight&gt;()-&gt;wait_for_ready()</code> the first time they       run. This allows the start of all threads in ILLIXR to be       synchronized.</p> </li> <li> <p>They must be joined-or-disowned at-or-before       <code>plugin::stop()</code>. This allows ILLIXR to shutdown cleanly.</p> </li> </ul> </li> <li> <p>Write a file called <code>plugin.cpp</code> with this body, replacing every instance of <code>plugin_name</code>:</p> <pre><code>/// A minimal/no-op ILLIXR plugin\n\n#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\nusing namespace ILLIXR;\n\n/// Inherit from plugin if you don't need the threadloop\n/// Inherit from threadloop to provide a new thread to perform the task\nclass basic_plugin : public threadloop {\npublic:\n    basic_plugin(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n    {\n        std::cout &lt;&lt; \"Constructing basic_plugin.\" &lt;&lt; std::endl;\n    }\n\n    /// Note the virtual.\n    virtual ~basic_plugin() override {\n        std::cout &lt;&lt; \"Deconstructing basic_plugin.\" &lt;&lt; std::endl;\n    }\n\n    /// For `threadloop` style plugins, do not override the start() method unless you know what you're doing!\n    /// _p_one_iteration() is called in a thread created by threadloop::start()\n    void _p_one_iteration() override {\n        std::cout &lt;&lt; \"This goes to the log when `log` is set in the config.\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"This goes to the console.\" &lt;&lt; std::endl;\n        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n    }\n\n};\n\n/// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(basic_plugin);\n</code></pre> </li> <li> <p>At this point, you should be able to build your plugin with ILLIXR.     Move to the ILLIXR repo and update <code>configs/native.yaml</code>.     If the new plugin is the same type as one of the other components you will need to         remove that component from the config before running the new component.     For example, if the new component is a SLAM then the old SLAM needs to be removed from         the config.     See Building ILLIXR for more details on the config file.</p> <pre><code>plugin_groups:\n  - !include \"rt_slam_plugins.yaml\"\n  - !include \"core_plugins.yaml\"\n  - plugin_group:\n     - path: /PATH/TO/NEW/PLUGIN\n     - path: ground_truth_slam/\n     - path: gldemo/\n     - path: debugview/\n\ndata:\n  subpath: mav0\n  relative_to:\n  archive_path:\n  download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip'\n  demo_data: demo_data/\n  loader:\n    name: native\n    # command: gdb -q --args %a\n    profile: opt\n</code></pre> </li> <li> <p>Finally, run ILLIXR with your new plugin with the following command:</p> <pre><code>./runner.sh configs/native.yaml\n</code></pre> </li> <li> <p>This is all that is required to be a plugin which can be loaded by Spindle in         the ILLIXR runtime.     Reading and writing from Phonebook and Switchboard is optional,         but nearly every plugin does it.     See <code>default_plugins.md</code> for more details.</p> <p>First, we can query the <code>phonebook</code> to get various services     including <code>switchboard</code>. Then we query <code>switchboard</code> for event-streams (topics). We will read <code>topic1</code>, write to <code>topic2</code>, and schedule computation on <code>topic 3</code>. See the API documentation for <code>phonebook</code> and <code>switchboard</code> for more details.</p> <pre><code>#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\n/* When datatypes have to be common across plugins\n *     (e.g. a phonebook service or switchboard topic),\n *      they are defined in this header,\n *      which is accessible to all plugins.\n */\n#include \"common/data_format.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    /* After the constructor, C++ permits a list of member-constructors.\n     * We use uniform initialization (curly-braces) [1] instead of parens to\n     *     avoid ambiguity [2].\n     * We put the comma at the start of the line, so that lines can be copied around\n     *     or deleted freely (except for the first).\n     *\n     * [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n     * [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n     */\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n          /// Find the switchboard in phonebook\n        , sb{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n          /// Create a handle to a topic in switchboard for subscribing\n        , topic1{sb-&gt;get_reader&lt;topic1_type&gt;(\"topic1\")}\n          /// Create a handle to a topic in switchboard for publishing\n        , topic2{sb-&gt;get_writer&lt;topic2_type&gt;(\"topic2\")}\n    {\n        /// Read topic 1\n        switchboard::ptr&lt;const topic1_type&gt; event1 = topic1.get_ro();\n\n        /// Write to topic 2\n        topic2.put(\n            topic2.allocate&lt;topic2_type&gt;(\n                arg_1, // topic2_type::topic2_type() arg_type_1\n                ...,   // ...\n                arg_k  // topic2_type::topic2_type() arg_type_k\n            )\n        );\n\n        /// Read topic 3 synchronously\n        sb-&gt;schedule&lt;topic3_type&gt;(\n            get_name(),\n            \"topic3\",\n            [&amp;](switchboard::ptr&lt;const topic3_type&gt; event3, std::size_t) {\n                /* This is a [lambda expression][1]\n                 *\n                 * [1]: https://en.cppreference.com/w/cpp/language/lambda\n                 */\n                std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n                callback(event3);\n            }\n        );\n    }\n\n    virtual void _p_one_iteration override() {\n        std::cout &lt;&lt; \"Running\" &lt;&lt; std::endl;\n        auto target = std::chrono::system_clock::now()\n                    + std::chrono::milliseconds{10};\n        reliable_sleep(target);\n    }\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; sb;\n    switchboard::reader&lt;topic1_type&gt; topic1;\n    switchboard::writer&lt;topic2&gt; topic2;\n};\n\n/// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n</code></pre> </li> </ol>"},{"location":"legacy/v1/","title":"ILLIXR","text":"<p>This is the final release of ILLIXR that contains only standalone components. All future releases will contain both the components and the runtime, and can be found here.</p>"},{"location":"legacy/v1/#illixr","title":"ILLIXR","text":"<p>ILLIXR (pronounced like elixir) is an open-source Extended Reality (XR) benchmark suite. It contains several core state-of-the-art components of a generic XR pipeline,     components that are required in most, if not all, XR applications. We use the term components and not kernels or computations because each component     of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components,     all of which are included as sub-modules in this repo.</p> <ol> <li>Simultaneous Localization and Mapping</li> <li>Scene reconstruction</li> <li>Eye tracking</li> <li>Ambisonic encoding</li> <li>Ambisonic manipulation and binauralization</li> <li>Lens distortion correction</li> <li>Chromatic aberration correction</li> <li>Time warp</li> <li>Computational holography for adaptive multi-focal displays</li> </ol> <p>We plan on adding more components to ILLIXR     (e.g., graphics and multiple versions for individual components),     including a runtime to integrate all of the components into a full XR system. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance     computer architecture,     systems,     and     hardware-software co-design     research for XR by making available key state-of-the-art components of both modern     and future XR applications. </p> <p>Many of the current components of ILLIXR were developed by domain experts and obtained     from publicly available repositories. They were modified for one or more of the following reasons:     fixing compilation,     adding features,     or     removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository     for proper attribution to its authors.</p> <p>Detailed descriptions of each component, including performance and energy profiles,     can be found in our paper.</p>"},{"location":"legacy/v1/#publications","title":"Publications","text":"<p>We request that you cite our following paper when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.</p> <pre><code>@misc{HuzaifaDesai2020,\n    title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research},\n    author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve},\n    year={2020},\n    eprint={2004.04643},\n    primaryClass={cs.DC}\n}\n</code></pre>"},{"location":"legacy/v1/#setup","title":"Setup","text":"<p>Each component of ILLIXR is packaged as its own repository for modularity. Please refer to the setup instructions of each individual component in <code>benchmark/</code>.</p> <p>To clone this repo use the following command: <pre><code>git clone https://github.com/ILLIXR/ILLIXR.git --recursive\n</code></pre></p>"},{"location":"legacy/v1/#acknowledgements","title":"Acknowledgements","text":"<p>Muhammad Huzaifa led the development of ILLIXR in Sarita Adve\u2019s research group     at the University of Illinois at Urbana-Champaign. Other major contributors include     Rishi Desai,     Samuel Grayson,     Xutao Jiang,     Ying Jing,     Fang Lu,     Joseph Ravichandran,     and     Finn Sinclair.</p> <p>ILLIXR came together after many consultations with researchers and practitioners in many domains:     audio,     graphics,     optics,     robotics,     signal processing,     and     extended reality systems. We are deeply grateful for all of these discussions and specifically to the following:     Wei Cu,     Aleksandra Faust,     Liang Gao,     Matt Horsnell,     Amit Jindal,     Steve LaValle,     Steve Lovegrove,     Andrew Maimone,     Vegard \u00d8ye,     Martin Persson,     Archontis Politis,     Eric Shaffer,     Paris Smaragdis,     Sachin Talathi,     and     Chris Widdowson.</p> <p>The development of ILLIXR was supported by     the Applications Driving Architectures (ADA) Research Center,         a JUMP Center co-sponsored by SRC and DARPA,     the Center for Future Architectures Research (C-FAR),         one of the six centers of STARnet,     a Semiconductor Research Corporation program sponsored by MARCO and DARPA,     and     by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations     from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset.</p> <p>Wesley Darvin came up with the name for ILLIXR. Abdulrahman Mahmoud helped with the design of this website.</p>"},{"location":"legacy/v1/#licensing-structure","title":"Licensing Structure","text":"<p>ILLIXR is available as open-source software under     the University of Illinois/NCSA Open Source License. As mentioned above, ILLIXR largely consists of components developed by domain experts and     modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software. The external libraries and softwares included in ILLIXR each have their own licenses and     must be used according to those licenses:</p> <ul> <li>Open-VINS - GNU General Public License v3.0</li> <li>ElasticFusion - ElasticFusion license</li> <li>RITnet - MIT License</li> <li>libspatialaudio - GNU Lesser General Public License v2.1</li> <li>HOTlab - GNU Lesser General Public License v3.0</li> </ul>"},{"location":"legacy/v1/#get-in-touch","title":"Get In Touch","text":"<p>Whether you are     a computer architect,     a systems person,     an XR application developer,     or     just anyone interested in XR,     we would love to hear your feedback on ILLIXR! ILLIXR is a living benchmark suite and we would like to both refine existing components     and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture     and systems research for XR, and can benefit from contributions from other researchers     and organizations. If you would like to be a part of this effort, please contact us at     illixr at cs dot illinois dot edu.</p>"},{"location":"legacy/v1/README-audio/","title":"Audio Pipeline","text":"<p>Part of ILLIXR, the Illinios Extended Reality Benchmark Suite. The audio pipeline is responsible for both recording and playing back spatialized audio for XR.</p>"},{"location":"legacy/v1/README-audio/#build","title":"Build","text":"<p>This version simplifies the build process to automate building of both libspatialaudio     and audio pipeline itself. If you have a old version of this module and updating to the new version doesn't build correctly,     you may need to purge the old module and clone this new version again.</p> <p>Build debug:</p> <pre><code>make\n</code></pre> <p>or</p> <pre><code>make solo.dbg\n</code></pre> <p>Build release:</p> <pre><code>make solo.opt\n</code></pre> <p>If you are switching between builds, please do <code>make deepclean</code></p> <p>Also note that release build (-O3) would show great performance improvement over debug build.</p>"},{"location":"legacy/v1/README-audio/#usage","title":"Usage","text":"<pre><code>./solo.dbg &lt;number of 1024-sample-block to process&gt; &lt;optional: decode/encode&gt;\n</code></pre> <ol> <li>Number of blocks to process is a required parameter.</li> <li>Decode/encode specifies the different audio processing procedures to take on,         which is specificially designed for profiling.     No output would be generated.</li> </ol> <p>If encode or decode is not specified, the code will do both encode and decode     on preset input sound sample files and generate a spatialized output audio at <code>output.wav</code>.</p>"},{"location":"legacy/v1/README-audio/#example","title":"Example:","text":"<pre><code>./solo.dbg 500\n</code></pre> <p>This will generate a ~10 seconds spatialized audio output from two sound samples under <code>./sample/</code></p> <pre><code>./solo.dbg 2000 encode\n</code></pre> <p>This will encode 2000 sample blocks of audio input into ambisonics format.</p>"},{"location":"legacy/v1/README-audio/#notes","title":"Notes","text":"<p>The input and output are hardcoded to be 48000 sample rate, 16-bit PCM wav file.</p> <p>Also if you want to hear the output sound, limit the process sample blocks so that     the output is not longer than input! Otherwise, garbage sound samples would be generated.</p>"},{"location":"legacy/v1/README-audio/#components","title":"Components","text":""},{"location":"legacy/v1/README-audio/#libspatialaudio","title":"libspatialaudio","text":"<p>Submodule libspatialaudio provides the backend library for     Ambisonics encoding,     decoding,     rotation,     zoom,     and     binauralizer (HRTF included).</p>"},{"location":"legacy/v1/README-audio/#audio-pipeline-code","title":"audio pipeline code","text":""},{"location":"legacy/v1/README-audio/#soundcpp","title":"sound.cpp","text":"<p>Describes a sound source in the ambisonics sound-field,     including the input file for the sound source and its position in the sound-field.</p>"},{"location":"legacy/v1/README-audio/#audiocpp","title":"audio.cpp","text":"<p>Encapsulate preset processing steps of     sound source reading,     encoding,     rotating,     zooming,     and     decoding.</p>"},{"location":"legacy/v1/README-audio/#license","title":"License","text":"<p>This code is available under the University of Illinois/NCSA Open Source License. The sound samples provided in ./sample/ are available under the Creative Commons 0 license.</p>"},{"location":"legacy/v1/README-efusion/","title":"ElasticFusion","text":"<p>Real-time dense visual SLAM system capable of capturing comprehensive dense     globally consistent surfel-based maps of room scale environments explored using     an RGB-D camera.</p> <p>Part of ILLIXR, the Illinios Extended Reality Benchmark Suite. This version of ElasticFusion has been modified to enable fast odometry and disable the GUI. Please use the following command to replicate the results from the paper:</p> <pre><code>./ElasticFusion -l dyson_lab.klg -fo -nso -sc -q\n</code></pre> <p>The description of each flag is provided in \"How Do I Use It?\" below.</p>"},{"location":"legacy/v1/README-efusion/#related-publications","title":"Related Publications","text":"<p>Please cite this work if you make use of our system in any of your own endeavors:</p> <ul> <li>ElasticFusion: Real-Time Dense SLAM and Light Source Estimation,         T. Whelan, R. F. Salas-Moreno, B. Glocker, A. J. Davison and S. Leutenegger, IJRR '16</li> <li>ElasticFusion: Dense SLAM Without A Pose Graph,         T. Whelan, S. Leutenegger, R. F. Salas-Moreno, B. Glocker and A. J. Davison, RSS '15</li> </ul>"},{"location":"legacy/v1/README-efusion/#1-what-do-i-need-to-build-it","title":"1. What do I need to build it?","text":""},{"location":"legacy/v1/README-efusion/#11-ubuntu","title":"1.1. Ubuntu","text":"<ul> <li>Ubuntu 14.04, 15.04 or 16.04 (Though many other linux distros will work fine)</li> <li>CMake</li> <li>OpenGL</li> <li>CUDA &gt;= 7.0</li> <li>OpenNI2</li> <li>SuiteSparse</li> <li>Eigen</li> <li>zlib</li> <li>libjpeg</li> <li>Pangolin</li> <li>librealsense - Optional (for Intel RealSense cameras)</li> </ul> <p>Firstly, add nVidia's official CUDA repository to your apt sources,     then run the following command to pull in most dependencies from the official repos:</p> <pre><code>sudo apt-get install -y cmake-qt-gui git build-essential libusb-1.0-0-dev libudev-dev openjdk-7-jdk freeglut3-dev libglew-dev cuda-7-5 libsuitesparse-dev libeigen3-dev zlib1g-dev libjpeg-dev\n</code></pre> <p>Afterwards install OpenNI2 and Pangolin from source. Note, you may need to manually tell CMake where OpenNI2 is since Occipital's fork does not     have an install option. It is important to build Pangolin last so that it can find some of the libraries it has     optional dependencies on. </p> <p>When you have all of the dependencies installed, build the Core followed by the GUI. </p>"},{"location":"legacy/v1/README-efusion/#12-windows-visual-studio","title":"1.2. Windows - Visual Studio","text":"<ul> <li>Windows 7/10 with Visual Studio 2013 Update 5 (Though other configurations may work)</li> <li>CMake</li> <li>OpenGL</li> <li>CUDA &gt;= 7.0</li> <li>OpenNI2</li> <li>SuiteSparse</li> <li>Eigen</li> <li>Pangolin<ul> <li>zlib (Pangolin can automatically download and build this)</li> <li>libjpeg (Pangolin can automatically download and build this)</li> </ul> </li> <li>librealsense - Optional (for Intel RealSense cameras)</li> </ul> <p>Firstly install cmake and cuda. Then download and build from source OpenNI2, SuiteSparse. Next download Eigen (no need to build it since it is a header-only library). Then download and build from source Pangolin but pay attention to the following cmake settings.  There will be a lot of dependencies where path was not found. That is OK except OPENNI2 and EIGEN3 (those should be set to valid paths). You also need to set MSVC_USE_STATIC_CRT to false in order to correctly link     to ElasticFusion projects. Also, you can set BUILD_EXAMPLES to false since we don't need them and some were crashing     on my machine.</p> <p>Finally, build Core and GUI.</p>"},{"location":"legacy/v1/README-efusion/#2-is-there-an-easier-way-to-build-it","title":"2. Is there an easier way to build it?","text":"<p>Yes, if you run the build.sh script on a fresh clean install     of Ubuntu 14.04, 15.04, or 16.04, enter your password for sudo a few times and wait     a few minutes all dependencies will get downloaded and installed and     it should build everything correctly. This has not been tested on anything but fresh installs, so I would advise using it     with caution if you already have some of the dependencies installed.</p>"},{"location":"legacy/v1/README-efusion/#3-installation-issues","title":"3. Installation issues","text":"<p><code>#include &lt;Eigen/Core&gt;</code> not found</p> <pre><code>sudo ln -sf /usr/include/eigen3/Eigen /usr/include/Eigen\nsudo ln -sf /usr/include/eigen3/unsupported /usr/include/unsupported\n</code></pre> <p>invalid use of incomplete type \u2018const struct Eigen ...</p> <p>Pangolin must be installed AFTER all the other libraries to make use of optional dependencies.</p> <p>GLSL 3.30 is not supported. Supported versions are 1.10, 1.20, 1.30, 1.00 ES and 3.00 ES</p> <p>Make sure you are running ElasticFusion on your nVidia GPU. In particular, if you have an Optimus GPU -   If you use Prime, follow instructions here -   If you use Bumblebee, remember to run as <code>optirun ./ElasticFusion</code></p>"},{"location":"legacy/v1/README-efusion/#4-how-do-i-use-it","title":"4. How do I use it?","text":"<p>There are three subprojects in the repo:</p> <ul> <li>The Core is the main engine which builds into a shared library that you can link         into other projects and treat like an API. </li> <li>The GUI is the graphical interface used to run the system on either live sensor data         or a logged data file. </li> <li>The GPUTest is a small benchmarking program you can use to tune         the CUDA kernel launch parameters used in the main engine. </li> </ul> <p>The GUI (ElasticFusion) can take a bunch of parameters when launching it from the command line. They are as follows:</p> <ul> <li>-cal  : Loads a camera calibration file specified as fx fy cx cy. <li>-l  : Processes the specified .klg log file. <li>-p  : Loads ground truth poses to use instead of estimated pose. <li>-c  : Surfel confidence threshold (default 10). <li>-d  : Cutoff distance for depth processing (default 3m). <li>-i  : Relative ICP/RGB tracking weight (default 10). <li>-ie  : Local loop closure residual threshold (default 5e-05). <li>-ic  : Local loop closure inlier threshold (default 35000). <li>-cv  : Local loop closure covariance threshold (default 1e-05). <li>-pt  : Global loop closure photometric threshold (default 115). <li>-ft  : Fern encoding threshold (default 0.3095). <li>-t  : Time window length (default 200). <li>-s  : Frames to skip at start of log. <li>-e  : Cut off frame of log. <li>-f : Flip RGB/BGR.</li> <li>-icl : Enable this if using the ICL-NUIM dataset         (flips normals to account for negative focal length on that data).</li> <li>-o : Open loop mode.</li> <li>-rl : Enable relocalisation.</li> <li>-fs : Frame skip if processing a log to simulate real-time.</li> <li>-q : Quit when finished a log.</li> <li>-fo : Fast odometry (single level pyramid).</li> <li>-nso : Disables SO(3) pre-alignment in tracking.</li> <li>-r : Rewind and loop log forever. </li> <li>-ftf : Do frame-to-frame RGB tracking. </li> <li>-sc : Showcase mode (minimal GUI).</li> <p>Essentially by default ./ElasticFusion will try run off an attached ASUS sensor live. You can provide a .klg log file instead with the -l parameter.  You can capture .klg format logs using either Logger1 or Logger2.</p>"},{"location":"legacy/v1/README-efusion/#5-how-do-i-just-use-the-core-api","title":"5. How do I just use the Core API?","text":"<p>The libefusion.so shared library which gets built by the Core is what you want to link against.</p> <p>An example of this can be seen in the GUI code. Essentially all you need to do is utilise the provided Findefusion.cmake file in GUI/src     and include the following in your CMakeLists.txt file:</p> <pre><code>find_package(efusion REQUIRED)\ninclude_directories(${EFUSION_INCLUDE_DIR})\ntarget_link_libraries(MyProject ${EFUSION_LIBRARY})\n</code></pre> <p>To then use the Core API, make sure to include the header file in your source file: <pre><code>    #include &lt;ElasticFusion.h&gt;\n</code></pre></p> <p>Initialise the static configuration parameters once somewhere at the start of your program     (this smells, but whatever): <pre><code>    Resolution::getInstance(640, 480);\n    Intrinsics::getInstance(528, 528, 320, 240);\n</code></pre></p> <p>Create an OpenGL context before creating an ElasticFusion object,     as ElasticFusion uses OpenGL internally. You can do this whatever way you wish, using Pangolin is probably easiest given it's a dependency: <pre><code>    pangolin::Params windowParams;\n    windowParams.Set(\"SAMPLE_BUFFERS\", 0);\n    windowParams.Set(\"SAMPLES\", 0);\n    pangolin::CreateWindowAndBind(\"Main\", 1280, 800, windowParams);\n</code></pre></p> <p>Make an ElasticFusion object and start using it: <pre><code>    ElasticFusion eFusion;\n    eFusion.processFrame(rgb, depth, timestamp, currentPose, weightMultiplier);\n</code></pre></p> <p>See the source code of MainController.cpp in the GUI source to see more usage.</p>"},{"location":"legacy/v1/README-efusion/#6-datasets","title":"6. Datasets","text":"<p>We have provided a sample dataset which you can run easily with ElasticFusion     for download here. Launch it as follows:</p> <pre><code>./ElasticFusion -l dyson_lab.klg\n</code></pre>"},{"location":"legacy/v1/README-efusion/#7-license","title":"7. License","text":"<p>ElasticFusion is freely available for non-commercial use only. Full terms and conditions which govern its use are detailed here and in the LICENSE.txt file.</p>"},{"location":"legacy/v1/README-efusion/#8-faq","title":"8. FAQ","text":"<p>What are the hardware requirements?</p> <p>A very fast nVidia GPU (3.5TFLOPS+), and a fast CPU (something like an i7). If you want to use a non-nVidia GPU you can rewrite the tracking code or substitute it     with something else, as the rest of the pipeline is actually written in     the OpenGL Shading Language. </p> <p>How can I get performance statistics?</p> <p>Download Stopwatch and run StopwatchViewer at the same time as ElasticFusion. </p> <p>I ran a large dataset and got assert(graph.size() / 16 &lt; MAX_NODES) failed</p> <p>Currently there's a limit on the number of nodes in the deformation graph down to lazy coding     (using a really wide texture instead of a proper 2D one). So we're bound by the maximum dimension of a texture, which is 16384 on modern cards/OpenGL. Either fix the code so this isn't a problem any more, or increase the modulo factor     in Shaders/sample.geom. </p> <p>I have a nice new laptop with a good GPU but it's still slow</p> <p>If your laptop is running on battery power the GPU will throttle down to save power,     so that's unlikely to work (as an aside, Kintinuous will run at 30Hz on     a modern laptop on battery power these days). You can try disabling SO(3) pre-alignment, enabling fast odometry,     only using either ICP or RGB tracking and not both, running in open loop mode     or disabling the tracking pyramid. All of these will cost you accuracy. </p> <p>I saved a map, how can I view it?</p> <p>Download Meshlab. Select Render-&gt;Shaders-&gt;Splatting. </p> <p>The map keeps getting corrupted - tracking is failing - loop closures     are incorrect/not working</p> <p>Firstly, if you're running live and not processing a log file, ensure you're hitting 30Hz,     this is important. Secondly, you cannot move the sensor extremely fast because this violates     the assumption behind projective data association. In addition to this, you're probably using a primesense, which means you're suffering     from motion blur, unsynchronised cameras and rolling shutter. All of these are aggravated by fast motion and hinder tracking performance. </p> <p>If you're not getting loop closures and expecting some, pay attention to     the inlier and residual graphs in the bottom right, these are an indicator of how closae     you are to a local loop closure. For global loop closures, you're depending on fern keyframe encoding to save you,     which like all appearance-based place recognition methods, has its limitations. </p> <p>Is there a ROS bridge/node?</p> <p>No. The system relies on an extremely fast and tight coupling between the mapping and tracking     on the GPU, which I don't believe ROS supports natively in terms of message passing. </p> <p>This doesn't seem to work like it did in the videos/papers</p> <p>A substantial amount of refactoring was carried out in order to open source this system,     including rewriting a lot of functionality to avoid certain licenses and reduce dependencies. Although great care was taken during this process, it is possible that     performance regressions were introduced and have not yet been discovered.</p>"},{"location":"legacy/v1/README-hotlab/","title":"Computational Holography","text":"<p>Part of ILLIXR, the Illinios Extended Reality Benchmark Suite. This component is responsible for calculating image holograms (per-pixel phase masks) using     the Weighted Gerchberg\u2013Saxton (GSW) algorithm.</p>"},{"location":"legacy/v1/README-hotlab/#files","title":"Files","text":""},{"location":"legacy/v1/README-hotlab/#generatehologramcu","title":"generateHologram.cu","text":""},{"location":"legacy/v1/README-hotlab/#generatehologram","title":"generateHologram","text":"<p>Host side kernel launch code.</p>"},{"location":"legacy/v1/README-hotlab/#propagatetospotpositions","title":"propagateToSpotPositions","text":"<p>CUDA kernel that propagates phases from the SLM plane to the depth plane using Fresnel summation.</p>"},{"location":"legacy/v1/README-hotlab/#propagatetospotsum","title":"propagateToSpotSum","text":"<p>CUDA kernel that sums up the per-thread block results from the propagateToSpotPositions() kernel.</p>"},{"location":"legacy/v1/README-hotlab/#propagatetoslm","title":"propagateToSLM","text":"<p>CUDA kernel that calculates the error function at the depth planes and updates the SLM phases.</p>"},{"location":"legacy/v1/README-hotlab/#goldenhologramcu","title":"goldenHologram.cu","text":"<p>The original hologram implementation. This implementation did not support arbitrary SLM sizes     and colored holograms.</p>"},{"location":"legacy/v1/README-hotlab/#installation-usage","title":"Installation &amp; Usage","text":"<p>Under <code>C/source/</code></p> <pre><code>make all\nmake jetson\n</code></pre> <p><code>make all</code> compiles for the SM75 architecture, while <code>make jetson</code> compiles for SM70. To run this code on a older NVIDIA GPU, please change the SM architecture accordingly.</p> <p>To run our modified hologram code:</p> <pre><code>./hologram\n</code></pre> <p>To run the original hologram code:</p> <pre><code>./goldenHologram\n</code></pre>"},{"location":"legacy/v1/README-hotlab/#license","title":"License","text":"<p>This code is available under the LGPL license.</p>"},{"location":"legacy/v1/README-openvins/","title":"OpenVINS","text":"<p>Part of ILLIXR, the Illinios Extended Reality Benchmark Suite. For instructions on how to use OpenVINS for ILLIXR, see ILLIXR_INSTRUCTIONS.MD</p>"},{"location":"legacy/v1/README-openvins/#open-vins","title":"Open VINS","text":"<p>Welcome to the Open VINS project! The Open VINS project houses some core computer vision code along with     a state-of-the art filter-based visual-inertial estimator. The core filter is an Extended Kalman filter which fuses inertial information     with sparse visual feature tracks. These visual feature tracks are fused leveraging     the Multi-State Constraint Kalman Filter (MSCKF) sliding window formulation which     allows for 3D features to update the state estimate without directly estimating     the feature states in the filter. Inspired by graph-based optimization systems, the included filter has modularity allowing     for convenient covariance management with a proper type-based state system. Please take a look at the feature list below for full details on what the system supports.</p> <ul> <li>Github project page - https://github.com/rpng/open_vins</li> <li>Documentation - https://docs.openvins.com/</li> <li>Getting started guide - https://docs.openvins.com/getting-started.html</li> <li>Publication reference - TBD</li> </ul>"},{"location":"legacy/v1/README-openvins/#news-events","title":"News / Events","text":"<ul> <li>August 21, 2019 - Open sourced ov_maplab for interfacing OpenVINS with         the maplab library.</li> <li>August 15, 2019 - Initial release of OpenVINS repository and documentation website! </li> </ul>"},{"location":"legacy/v1/README-openvins/#project-features","title":"Project Features","text":"<ul> <li>Sliding window visual-inertial MSCKF</li> <li>Modular covariance type system</li> <li>Comprehensive documentation and derivations</li> <li>Extendable visual-inertial simulator<ul> <li>On manifold SE(3) b-spline</li> <li>Arbitrary number of cameras</li> <li>Arbitrary sensor rate</li> <li>Automatic feature generation</li> </ul> </li> <li>Five different feature representations<ol> <li>Global XYZ</li> <li>Global inverse depth</li> <li>Anchored XYZ</li> <li>Anchored inverse depth</li> <li>Anchored MSCKF inverse depth</li> </ol> </li> <li>Calibration of sensor intrinsics and extrinsics<ul> <li>Camera to IMU transform </li> <li>Camera to IMU time offset</li> <li>Camera intrinsics</li> </ul> </li> <li>Environmental SLAM feature<ul> <li>OpenCV ARUCO tag SLAM features</li> <li>Sparse feature SLAM features</li> </ul> </li> <li>Visual tracking support<ul> <li>Monocular camera</li> <li>Stereo camera</li> <li>KLT or descriptor based</li> </ul> </li> <li>Static IMU initialization (sfm will be open sourced later)</li> <li>Out of the box evaluation on EurocMav and TUM-VI datasets</li> <li>Extensive evaluation suite (ATE, RPE, NEES, RMSE, etc..)</li> </ul>"},{"location":"legacy/v1/README-openvins/#credit-licensing","title":"Credit / Licensing","text":"<p>This code was written by the Robot Perception and Navigation Group (RPNG)     at the University of Delaware. If you have any issues with the code please open an issue on our github page     with relevant implementation details and references. For researchers that have leveraged or compared to this work, please cite the following: <pre><code>@article{TBD,\n  author    = {},\n  title     = {},\n  journal   = {},\n  volume    = {},\n  year      = {2019},\n}\n</code></pre></p> <p>The codebase is licensed under the GNU General Public License v3 (GPL-3).</p>"},{"location":"legacy/v1/README-ritnet/","title":"RITnet","text":"<p>This is part of ILLIXR, the Illinios Extended Reality Benchmark Suite. The following explains how to use RITnet. The code is based on Python3, and the profiling results are based on <code>test.py</code>. For the testing images, the size per image should be <code>640x400</code> in gray scale. Please put them under <code>Semantic_Segmentation_Dataset/test/images</code>.</p>"},{"location":"legacy/v1/README-ritnet/#ritnet","title":"RITnet","text":"<p>RITnet is the winnning model of the OpenEDS Semantic Segmentation Challenge. If you use this code, please cite: <pre><code>@misc{chaudhary2019ritnet,\n    title={RITnet: Real-time Semantic Segmentation of the Eye for Gaze Tracking},\n    author={Aayush K. Chaudhary and Rakshit Kothari and Manoj Acharya and Shusil Dangi and Nitinraj Nair and Reynold Bailey and Christopher Kanan and Gabriel Diaz and Jeff B. Pelz},\n    year={2019},\n    eprint={1910.00694},\n    archivePrefix={arXiv},\n    primaryClass={cs.CV}\n}\n</code></pre></p> <p>Instructions:</p> <p><code>python train.py --help</code></p> <p>To train the model with densenet model:</p> <p><code>python train.py --model densenet --expname FINAL --bs 8 --useGPU True --dataset Semantic_Segmentation_Dataset/</code></p> <p>To test the result:</p> <p><code>python test.py --model densenet --load best_model.pkl --bs 4 --dataset Semantic_Segmentation_Dataset/</code></p> <p>If you type in <code>python test.py</code>, the batch size will be 8.</p>"},{"location":"legacy/v1/README-ritnet/#contents-in-the-zip-folder","title":"Contents in the zip folder","text":"<pre><code>best_model.pkl     :: Our final model (potential winner model) which contains all the weights in Float32 format (Number of Parameters 248900).\nrequirements.txt   :: Includes all the necessary packages for the source code to run \nenvironment.yml    :: List of all packages and version of one of our system in which the code was run successfully. \ndataset.py  ::Data loader and augmentation\ntrain.py    ::Train code\ntest.py     ::Test code\ndensenet.py ::Model code\nutils.py    ::List of utility files\nopt.py      ::List of arguments for argparser\nmodels.py   ::List of all models\nstarburst_black.png:: A fixed structured pattern (with translation) used on train images to handle cases such as multiple reflections.(Train Image: 000000240768.png)\nStarburst generation from train image 000000240768.pdf  ::Procedure how starburst pattern is generated\n</code></pre> <p>The requirements.txt file contains all the packages necessary for the code to run. We have also included an environment.yml file to recreate the conda environment we used.</p> <p>We have submitted two models from this version of code:</p> <ol> <li>Epoch: 151 Validation accuracy: 95.7780  Test accuracy: 95.276  (Potential Winner Model:         Last Submission)</li> <li>Epoch: 117 Validation accuracy: 95.7023  Test accuracy: 95.159  (Our Second Last Submission)</li> </ol> <p>We could reach upto Epoch: 240 Validation accuracy: 95.7820 Test accuracy:NA (Not submitted: result after the deadline)</p> <p>The dataset.py contains data loader, preprocessing and post processing step Required Preprocessing for all images (test, train and validation set).</p> <ol> <li>Gamma correction by a factor of 0.8</li> <li>local Contrast limited adaptive histogram equalization algorithm         with clipLimit=1.5, tileGridSize=(8,8)</li> <li>Normalization [Mean 0.5, std=0.5]</li> </ol> <p>Train Image Augmentation Procedure Followed (Not Required during test)</p> <ol> <li>Random horizontal flip with 50% probability.</li> <li>Starburst pattern augmentation with 20% probability. </li> <li>Random length lines (1 to 9) augmentation around a random center with 20% probability. </li> <li>Gaussian blur with kernel size (7,7) and random sigma (2 to 7) with 20% probability. </li> <li>Translation of image and labels in any direction with random factor less than 20         with 20% probability.</li> </ol> <pre><code>----------------------------------------------------------------\n        Layer (type)               Output Shape         Param #\n================================================================\n            Conv2d-1         [-1, 32, 640, 400]             320\n           Dropout-2         [-1, 32, 640, 400]               0\n         LeakyReLU-3         [-1, 32, 640, 400]               0\n            Conv2d-4         [-1, 32, 640, 400]           1,088\n            Conv2d-5         [-1, 32, 640, 400]           9,248\n           Dropout-6         [-1, 32, 640, 400]               0\n         LeakyReLU-7         [-1, 32, 640, 400]               0\n            Conv2d-8         [-1, 32, 640, 400]           2,112\n            Conv2d-9         [-1, 32, 640, 400]           9,248\n          Dropout-10         [-1, 32, 640, 400]               0\n        LeakyReLU-11         [-1, 32, 640, 400]               0\n      BatchNorm2d-12         [-1, 32, 640, 400]              64\nDenseNet2D_down_block-13         [-1, 32, 640, 400]               0\n        AvgPool2d-14         [-1, 32, 320, 200]               0\n           Conv2d-15         [-1, 32, 320, 200]           9,248\n          Dropout-16         [-1, 32, 320, 200]               0\n        LeakyReLU-17         [-1, 32, 320, 200]               0\n           Conv2d-18         [-1, 32, 320, 200]           2,080\n           Conv2d-19         [-1, 32, 320, 200]           9,248\n          Dropout-20         [-1, 32, 320, 200]               0\n        LeakyReLU-21         [-1, 32, 320, 200]               0\n           Conv2d-22         [-1, 32, 320, 200]           3,104\n           Conv2d-23         [-1, 32, 320, 200]           9,248\n          Dropout-24         [-1, 32, 320, 200]               0\n        LeakyReLU-25         [-1, 32, 320, 200]               0\n      BatchNorm2d-26         [-1, 32, 320, 200]              64\nDenseNet2D_down_block-27         [-1, 32, 320, 200]               0\n        AvgPool2d-28         [-1, 32, 160, 100]               0\n           Conv2d-29         [-1, 32, 160, 100]           9,248\n          Dropout-30         [-1, 32, 160, 100]               0\n        LeakyReLU-31         [-1, 32, 160, 100]               0\n           Conv2d-32         [-1, 32, 160, 100]           2,080\n           Conv2d-33         [-1, 32, 160, 100]           9,248\n          Dropout-34         [-1, 32, 160, 100]               0\n        LeakyReLU-35         [-1, 32, 160, 100]               0\n           Conv2d-36         [-1, 32, 160, 100]           3,104\n           Conv2d-37         [-1, 32, 160, 100]           9,248\n          Dropout-38         [-1, 32, 160, 100]               0\n        LeakyReLU-39         [-1, 32, 160, 100]               0\n      BatchNorm2d-40         [-1, 32, 160, 100]              64\nDenseNet2D_down_block-41         [-1, 32, 160, 100]               0\n        AvgPool2d-42           [-1, 32, 80, 50]               0\n           Conv2d-43           [-1, 32, 80, 50]           9,248\n          Dropout-44           [-1, 32, 80, 50]               0\n        LeakyReLU-45           [-1, 32, 80, 50]               0\n           Conv2d-46           [-1, 32, 80, 50]           2,080\n           Conv2d-47           [-1, 32, 80, 50]           9,248\n          Dropout-48           [-1, 32, 80, 50]               0\n        LeakyReLU-49           [-1, 32, 80, 50]               0\n           Conv2d-50           [-1, 32, 80, 50]           3,104\n           Conv2d-51           [-1, 32, 80, 50]           9,248\n          Dropout-52           [-1, 32, 80, 50]               0\n        LeakyReLU-53           [-1, 32, 80, 50]               0\n      BatchNorm2d-54           [-1, 32, 80, 50]              64\nDenseNet2D_down_block-55           [-1, 32, 80, 50]               0\n        AvgPool2d-56           [-1, 32, 40, 25]               0\n           Conv2d-57           [-1, 32, 40, 25]           9,248\n          Dropout-58           [-1, 32, 40, 25]               0\n        LeakyReLU-59           [-1, 32, 40, 25]               0\n           Conv2d-60           [-1, 32, 40, 25]           2,080\n           Conv2d-61           [-1, 32, 40, 25]           9,248\n          Dropout-62           [-1, 32, 40, 25]               0\n        LeakyReLU-63           [-1, 32, 40, 25]               0\n           Conv2d-64           [-1, 32, 40, 25]           3,104\n           Conv2d-65           [-1, 32, 40, 25]           9,248\n          Dropout-66           [-1, 32, 40, 25]               0\n        LeakyReLU-67           [-1, 32, 40, 25]               0\n      BatchNorm2d-68           [-1, 32, 40, 25]              64\nDenseNet2D_down_block-69           [-1, 32, 40, 25]               0\n           Conv2d-70           [-1, 32, 80, 50]           2,080\n           Conv2d-71           [-1, 32, 80, 50]           9,248\n          Dropout-72           [-1, 32, 80, 50]               0\n        LeakyReLU-73           [-1, 32, 80, 50]               0\n           Conv2d-74           [-1, 32, 80, 50]           3,104\n           Conv2d-75           [-1, 32, 80, 50]           9,248\n          Dropout-76           [-1, 32, 80, 50]               0\n        LeakyReLU-77           [-1, 32, 80, 50]               0\nDenseNet2D_up_block_concat-78           [-1, 32, 80, 50]               0\n           Conv2d-79         [-1, 32, 160, 100]           2,080\n           Conv2d-80         [-1, 32, 160, 100]           9,248\n          Dropout-81         [-1, 32, 160, 100]               0\n        LeakyReLU-82         [-1, 32, 160, 100]               0\n           Conv2d-83         [-1, 32, 160, 100]           3,104\n           Conv2d-84         [-1, 32, 160, 100]           9,248\n          Dropout-85         [-1, 32, 160, 100]               0\n        LeakyReLU-86         [-1, 32, 160, 100]               0\nDenseNet2D_up_block_concat-87         [-1, 32, 160, 100]               0\n           Conv2d-88         [-1, 32, 320, 200]           2,080\n           Conv2d-89         [-1, 32, 320, 200]           9,248\n          Dropout-90         [-1, 32, 320, 200]               0\n        LeakyReLU-91         [-1, 32, 320, 200]               0\n           Conv2d-92         [-1, 32, 320, 200]           3,104\n           Conv2d-93         [-1, 32, 320, 200]           9,248\n          Dropout-94         [-1, 32, 320, 200]               0\n        LeakyReLU-95         [-1, 32, 320, 200]               0\nDenseNet2D_up_block_concat-96         [-1, 32, 320, 200]               0\n           Conv2d-97         [-1, 32, 640, 400]           2,080\n           Conv2d-98         [-1, 32, 640, 400]           9,248\n          Dropout-99         [-1, 32, 640, 400]               0\n       LeakyReLU-100         [-1, 32, 640, 400]               0\n          Conv2d-101         [-1, 32, 640, 400]           3,104\n          Conv2d-102         [-1, 32, 640, 400]           9,248\n         Dropout-103         [-1, 32, 640, 400]               0\n       LeakyReLU-104         [-1, 32, 640, 400]               0\nDenseNet2D_up_block_concat-105         [-1, 32, 640, 400]               0\n         Dropout-106         [-1, 32, 640, 400]               0\n          Conv2d-107          [-1, 4, 640, 400]             132\n================================================================\nTotal params: 248,900\nTrainable params: 248,900\nNon-trainable params: 0\n----------------------------------------------------------------\nInput size (MB): 0.98\nForward/backward pass size (MB): 1920.41\nParams size (MB): 0.95\nEstimated Total Size (MB): 1922.34\n----------------------------------------------------------------\n</code></pre>"},{"location":"legacy/v1/README-visualpp/","title":"Visual Post-processing","text":""},{"location":"legacy/v1/README-visualpp/#visual-post-processing-pipeline","title":"Visual Post-Processing Pipeline","text":"<p>Part of ILLIXR, the Illinios Extended Reality Benchmark Suite. This repo contains code for     lens distortion correction,     chromatic aberration correction,     and     timewarp.</p> <p>Some of the FBO intialization code is borrowed from Song Ho Ahn's excellent tutorial series. The particular FBO code used is found at his website.</p> <p>The image loader is based on Morten Nobel-J\u00f8rgensen's blog post.</p>"},{"location":"legacy/v1/README-visualpp/#compiling-and-running","title":"Compiling and Running","text":"<p>Compile on Linux with the included makefile. Run with <code>./fbo &lt;input image&gt;</code></p> <p>We provide three examples, <code>landscape.png</code>, <code>museum.png</code>, and <code>tundra.png</code>,     but any PNG image should work.</p>"},{"location":"api/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace ILLIXR RAC_ERRNO_MSG. <ul> <li>class Event A boolean condition-variable. </li> <li>class Stoplight Start/stop synchronization for the whole application. </li> <li>struct accel </li> <li>class data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>class dynamic_lib </li> <li>struct fast_pose_type </li> <li>class gen_guid This class generates unique IDs. </li> <li>struct hmd_physical_info </li> <li>struct hologram_input </li> <li>struct imu_cam_type </li> <li>struct imu_integrator_input </li> <li>struct imu_integrator_seq </li> <li>struct imu_params </li> <li>struct imu_raw_type </li> <li>class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. </li> <li>namespace math_util </li> <li>class phonebook A service locator forILLIXR . <ul> <li>class service A 'service' that can be registered in the phonebook. </li> </ul> </li> <li>class plugin A dynamically-loadable plugin for Spindle. </li> <li>struct pose_type </li> <li>class record This class represents a tuple of fields which get logged by <code>record_logger</code> . </li> <li>class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class record_header Schema of each record. </li> <li>class record_logger The ILLIXR logging service for structured records. </li> <li>struct rendered_frame </li> <li>class rgb_depth_type </li> <li>class runtime </li> <li>class start_end_logger a utility for logging to start and end times to a file </li> <li>class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). <ul> <li>class event Virtual class for event types. </li> <li>class event_wrapper Helper class for making event types. </li> <li>class reader A handle which can read the latest event on a topic. </li> <li>class writer A handle which can publish events to a topic. </li> </ul> </li> <li>struct texture_pose </li> <li>class threadloop A reusable threadloop for plugins. </li> <li>class xlib_gl_extended_window </li> </ul> </li> <li>class topic Represents a topic. </li> <li>class topic_subscription Represents a single topic_subscription (callback and queue) </li> <li>namespace linalg <ul> <li>namespace aliases </li> <li>struct converter </li> <li>struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; </li> <li>struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; </li> <li>namespace detail <ul> <li>struct any_compare </li> <li>struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct apply </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; </li> <li>struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; </li> <li>struct clamp </li> <li>struct empty </li> <li>struct getter </li> <li>struct getter&lt; 0 &gt; </li> <li>struct getter&lt; 1 &gt; </li> <li>struct getter&lt; 2 &gt; </li> <li>struct getter&lt; 3 &gt; </li> <li>struct lerp </li> <li>struct make_seq_impl </li> <li>struct make_seq_impl&lt; A, 0 &gt; </li> <li>struct make_seq_impl&lt; A, 1 &gt; </li> <li>struct make_seq_impl&lt; A, 2 &gt; </li> <li>struct make_seq_impl&lt; A, 3 &gt; </li> <li>struct make_seq_impl&lt; A, 4 &gt; </li> <li>struct max </li> <li>struct min </li> <li>struct op_add </li> <li>struct op_and </li> <li>struct op_cmp </li> <li>struct op_div </li> <li>struct op_eq </li> <li>struct op_ge </li> <li>struct op_gt </li> <li>struct op_int </li> <li>struct op_le </li> <li>struct op_lsh </li> <li>struct op_lt </li> <li>struct op_mod </li> <li>struct op_mul </li> <li>struct op_ne </li> <li>struct op_neg </li> <li>struct op_not </li> <li>struct op_or </li> <li>struct op_pos </li> <li>struct op_rsh </li> <li>struct op_sub </li> <li>struct op_un </li> <li>struct op_xor </li> <li>struct ord </li> <li>struct scalar_type </li> <li>struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; </li> <li>struct scalar_type&lt; vec&lt; T, M &gt; &gt; </li> <li>struct scalars </li> <li>struct scalars&lt; T, U... &gt; </li> <li>struct scalars&lt;&gt; </li> <li>struct select </li> <li>struct seq </li> <li>struct std_abs </li> <li>struct std_acos </li> <li>struct std_asin </li> <li>struct std_atan </li> <li>struct std_atan2 </li> <li>struct std_ceil </li> <li>struct std_copysign </li> <li>struct std_cos </li> <li>struct std_cosh </li> <li>struct std_exp </li> <li>struct std_floor </li> <li>struct std_fmod </li> <li>struct std_log </li> <li>struct std_log10 </li> <li>struct std_pow </li> <li>struct std_round </li> <li>struct std_sin </li> <li>struct std_sinh </li> <li>struct std_sqrt </li> <li>struct std_tan </li> <li>struct std_tanh </li> </ul> </li> <li>struct identity_t </li> <li>struct mat </li> <li>struct mat&lt; T, M, 1 &gt; </li> <li>struct mat&lt; T, M, 2 &gt; </li> <li>struct mat&lt; T, M, 3 &gt; </li> <li>struct mat&lt; T, M, 4 &gt; </li> <li>namespace ostream_overloads </li> <li>struct vec </li> <li>struct vec&lt; T, 1 &gt; </li> <li>struct vec&lt; T, 2 &gt; </li> <li>struct vec&lt; T, 3 &gt; </li> <li>struct vec&lt; T, 4 &gt; </li> </ul> </li> <li>class pose_prediction </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_in_destructor </li> <li>class should_profile_class </li> <li>namespace std <ul> <li>namespace conditional </li> <li>struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; </li> </ul> </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> </ul>"},{"location":"api/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir common <ul> <li>file cpu_timer.hpp </li> <li>file data_format.hpp </li> <li>file dynamic_lib.hpp </li> <li>file error_util.hpp </li> <li>file extended_window.hpp </li> <li>file global_module_defs.hpp </li> <li>file linalg.hpp </li> <li>file logger.hpp </li> <li>file managed_thread.hpp </li> <li>file math_util.hpp </li> <li>file phonebook.hpp </li> <li>file plugin.hpp </li> <li>file pose_prediction.hpp </li> <li>file record_logger.hpp </li> <li>file runtime.hpp </li> <li>file shader_util.hpp </li> <li>file stoplight.hpp </li> <li>file switchboard.hpp </li> <li>file threadloop.hpp </li> </ul> </li> </ul>"},{"location":"api/namespaceILLIXR/","title":"Namespace ILLIXR","text":"<p>Namespace List &gt; ILLIXR</p> <p>RAC_ERRNO_MSG. </p>"},{"location":"api/namespaceILLIXR/#namespaces","title":"Namespaces","text":"Type Name namespace math_util"},{"location":"api/namespaceILLIXR/#classes","title":"Classes","text":"Type Name class Event A boolean condition-variable. class Stoplight Start/stop synchronization for the whole application. struct accel class data_use_indicator A helper class that lets one dynamically determine if some data gets used. class dynamic_lib struct fast_pose_type class gen_guid This class generates unique IDs. struct hmd_physical_info struct hologram_input struct imu_cam_type struct imu_integrator_input struct imu_integrator_seq struct imu_params struct imu_raw_type class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. class phonebook A service locator forILLIXR . class plugin A dynamically-loadable plugin for Spindle. struct pose_type class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_logger The ILLIXR logging service for structured records. struct rendered_frame class rgb_depth_type class runtime class start_end_logger a utility for logging to start and end times to a file class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). struct texture_pose class threadloop A reusable threadloop for plugins. class xlib_gl_extended_window"},{"location":"api/namespaceILLIXR/#public-types","title":"Public Types","text":"Type Name typedef plugin *(* plugin_factory typedef std::size_t plugin_id_t typedef std::chrono::system_clock::time_point time_type typedef unsigned long long ullong typedef std::unique_ptr&lt; void, std::function&lt; void(void *)&gt; &gt; void_ptr"},{"location":"api/namespaceILLIXR/#public-attributes","title":"Public Attributes","text":"Type Name const record_header __plugin_start_header   = <code>/* multi line expression */</code> const record_header __switchboard_callback_header   = <code>/* multi line expression */</code> const record_header __switchboard_topic_stop_header   = <code>/* multi line expression */</code> const record_header __threadloop_iteration_header   = <code>/* multi line expression */</code>"},{"location":"api/namespaceILLIXR/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const bool ENABLE_VERBOSE_ERRORS   = <code>{[**ILLIXR::str\\_to\\_bool**](namespaceILLIXR.md#function-str_to_bool)([**ILLIXR::getenv\\_or**](namespaceILLIXR.md#function-getenv_or)(\"ILLIXR\\_ENABLE\\_VERBOSE\\_ERRORS\", \"False\"))}</code> constexpr int FB_HEIGHT   = <code>1440</code> constexpr int FB_WIDTH   = <code>2560</code> std::chrono::milliseconds LOG_BUFFER_DELAY   = <code>{1000}</code>"},{"location":"api/namespaceILLIXR/#public-functions","title":"Public Functions","text":"Type Name void abort (const std::string &amp; msg=\"\", const int error_val=1) Exits the application during a fatal error. std::string getenv_or (std::string var, std::string default_) Temporary environment variable getter. Not needed once #198 is merged. void report_and_clear_errno (const std::string &amp; file, const int &amp; line, const std::string &amp; function, const std::string &amp; msg=\"\") Support function to report errno values when debugging (NDEBUG). runtime * runtime_factory (GLXContext appGLCtx)  bool str_to_bool (std::string var) Convert a string containing a (python) boolean to the bool type."},{"location":"api/namespaceILLIXR/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR/#typedef-plugin_factory","title":"typedef plugin_factory","text":"<pre><code>typedef plugin *(* ILLIXR::plugin_factory) (phonebook *);\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-plugin_id_t","title":"typedef plugin_id_t","text":"<pre><code>typedef std::size_t ILLIXR::plugin_id_t;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-time_type","title":"typedef time_type","text":"<pre><code>typedef std::chrono::system_clock::time_point ILLIXR::time_type;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-ullong","title":"typedef ullong","text":"<pre><code>typedef unsigned long long ILLIXR::ullong;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-void_ptr","title":"typedef void_ptr","text":"<pre><code>using ILLIXR::void_ptr = typedef std::unique_ptr&lt;void, std::function&lt;void(void*)&gt; &gt;;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-__plugin_start_header","title":"variable __plugin_start_header","text":"<pre><code>const record_header ILLIXR::__plugin_start_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-__switchboard_callback_header","title":"variable __switchboard_callback_header","text":"<pre><code>const record_header ILLIXR::__switchboard_callback_header;\n</code></pre> <p>@Should be private to Switchboard. </p>"},{"location":"api/namespaceILLIXR/#variable-__switchboard_topic_stop_header","title":"variable __switchboard_topic_stop_header","text":"<pre><code>const record_header ILLIXR::__switchboard_topic_stop_header;\n</code></pre> <p>@Should be private to Switchboard. </p>"},{"location":"api/namespaceILLIXR/#variable-__threadloop_iteration_header","title":"variable __threadloop_iteration_header","text":"<pre><code>const record_header ILLIXR::__threadloop_iteration_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-enable_verbose_errors","title":"variable ENABLE_VERBOSE_ERRORS","text":"<pre><code>const bool ILLIXR::ENABLE_VERBOSE_ERRORS;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-fb_height","title":"variable FB_HEIGHT","text":"<pre><code>constexpr int ILLIXR::FB_HEIGHT;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-fb_width","title":"variable FB_WIDTH","text":"<pre><code>constexpr int ILLIXR::FB_WIDTH;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-log_buffer_delay","title":"variable LOG_BUFFER_DELAY","text":"<pre><code>std::chrono::milliseconds ILLIXR::LOG_BUFFER_DELAY;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR/#function-abort","title":"function abort","text":"<p>Exits the application during a fatal error. <pre><code>inline void ILLIXR::abort (\n    const std::string &amp; msg=\"\",\n    const int error_val=1\n) \n</code></pre></p> <p>Switches to using abort during debugging over std::exit so that we can capture SIGABRT for debugging. </p>"},{"location":"api/namespaceILLIXR/#function-getenv_or","title":"function getenv_or","text":"<p>Temporary environment variable getter. Not needed once #198 is merged. <pre><code>inline std::string ILLIXR::getenv_or (\n    std::string var,\n    std::string default_\n) \n</code></pre></p>"},{"location":"api/namespaceILLIXR/#function-report_and_clear_errno","title":"function report_and_clear_errno","text":"<p>Support function to report errno values when debugging (NDEBUG). <pre><code>inline void ILLIXR::report_and_clear_errno (\n    const std::string &amp; file,\n    const int &amp; line,\n    const std::string &amp; function,\n    const std::string &amp; msg=\"\"\n) \n</code></pre></p> <p>If errno is set, this function will report errno's value and the calling context. It will subsequently clear errno (reset value to 0). Otherwise, this function does nothing. </p>"},{"location":"api/namespaceILLIXR/#function-runtime_factory","title":"function runtime_factory","text":"<pre><code>runtime * ILLIXR::runtime_factory (\n    GLXContext appGLCtx\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-str_to_bool","title":"function str_to_bool","text":"<p>Convert a string containing a (python) boolean to the bool type. <pre><code>inline bool ILLIXR::str_to_bool (\n    std::string var\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1Event/","title":"Class ILLIXR::Event","text":"<p>ClassList &gt; ILLIXR &gt; Event</p> <p>A boolean condition-variable. More...</p> <ul> <li><code>#include &lt;stoplight.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1Event/#public-functions","title":"Public Functions","text":"Type Name void clear () Clears the condition-variable. bool is_set () constTest if is set without blocking. void set (bool new_value=true) Sets the condition-variable to new_value. void wait () constWait indefinitely for the event to be set. bool wait_timeout (const std::chrono::duration&lt; Rep, Period &gt; &amp; duration) constWait for the event to be set with a timeout."},{"location":"api/classILLIXR_1_1Event/#detailed-description","title":"Detailed Description","text":"<p>Inspired by https://docs.python.org/3/library/threading.html#event-objects </p>"},{"location":"api/classILLIXR_1_1Event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1Event/#function-clear","title":"function clear","text":"<p>Clears the condition-variable. <pre><code>inline void ILLIXR::Event::clear () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1Event/#function-is_set","title":"function is_set","text":"<p>Test if is set without blocking. <pre><code>inline bool ILLIXR::Event::is_set () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1Event/#function-set","title":"function set","text":"<p>Sets the condition-variable to new_value. <pre><code>inline void ILLIXR::Event::set (\n    bool new_value=true\n) \n</code></pre></p> <p>Defaults to true, so that set() sets the bool. </p>"},{"location":"api/classILLIXR_1_1Event/#function-wait","title":"function wait","text":"<p>Wait indefinitely for the event to be set. <pre><code>inline void ILLIXR::Event::wait () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1Event/#function-wait_timeout","title":"function wait_timeout","text":"<p>Wait for the event to be set with a timeout. <pre><code>template&lt;class Clock, class Rep, class Period&gt;\ninline bool ILLIXR::Event::wait_timeout (\n    const std::chrono::duration&lt; Rep, Period &gt; &amp; duration\n) const\n</code></pre></p> <p>Returns whether the event was actually set. </p> <p>The documentation for this class was generated from the following file <code>common/stoplight.hpp</code></p>"},{"location":"api/classILLIXR_1_1Stoplight/","title":"Class ILLIXR::Stoplight","text":"<p>ClassList &gt; ILLIXR &gt; Stoplight</p> <p>Start/stop synchronization for the whole application. More...</p> <ul> <li><code>#include &lt;stoplight.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1Stoplight/#public-functions","title":"Public Functions","text":"Type Name bool check_should_stop () const bool check_shutdown_complete () const void signal_ready ()  void signal_should_stop ()  void signal_shutdown_complete ()  void wait_for_ready () const void wait_for_shutdown_complete () const"},{"location":"api/classILLIXR_1_1Stoplight/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1Stoplight/#detailed-description","title":"Detailed Description","text":"<p>Threads should: * Do intiailization actions. * Wait for ready() * Do their main work in a loop until should_stop(). * Do their shutdown actions.</p> <p>The main thread should: * Construct and start all plugins and construct all services. * Set ready(). * Wait for shutdown_complete().</p> <p>The stopping thread should: * Someone should set should_stop(). * stop() and destruct each plugin and destruct each service. * Set shutdown_complete(). </p>"},{"location":"api/classILLIXR_1_1Stoplight/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1Stoplight/#function-check_should_stop","title":"function check_should_stop","text":"<pre><code>inline bool ILLIXR::Stoplight::check_should_stop () const\n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-check_shutdown_complete","title":"function check_shutdown_complete","text":"<pre><code>inline bool ILLIXR::Stoplight::check_shutdown_complete () const\n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-signal_ready","title":"function signal_ready","text":"<pre><code>inline void ILLIXR::Stoplight::signal_ready () \n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-signal_should_stop","title":"function signal_should_stop","text":"<pre><code>inline void ILLIXR::Stoplight::signal_should_stop () \n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-signal_shutdown_complete","title":"function signal_shutdown_complete","text":"<pre><code>inline void ILLIXR::Stoplight::signal_shutdown_complete () \n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-wait_for_ready","title":"function wait_for_ready","text":"<pre><code>inline void ILLIXR::Stoplight::wait_for_ready () const\n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-wait_for_shutdown_complete","title":"function wait_for_shutdown_complete","text":"<pre><code>inline void ILLIXR::Stoplight::wait_for_shutdown_complete () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/stoplight.hpp</code></p>"},{"location":"api/structILLIXR_1_1accel/","title":"Struct ILLIXR::accel","text":"<p>ClassList &gt; ILLIXR &gt; accel</p> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1data__use__indicator/","title":"Class ILLIXR::data_use_indicator","text":"<p>ClassList &gt; ILLIXR &gt; data_use_indicator</p> <p>A helper class that lets one dynamically determine if some data gets used. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions","title":"Public Functions","text":"Type Name data_use_indicator ()  data_use_indicator (const data_use_indicator &amp; other)  bool is_used () const void mark_unused () const void mark_used () const data_use_indicator &amp; operator= (const data_use_indicator &amp; other)"},{"location":"api/classILLIXR_1_1data__use__indicator/#detailed-description","title":"Detailed Description","text":"<p>When a data_use_indicator gets copied, the original is considered used and the new one is considered unused. </p>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-12","title":"function data_use_indicator [1/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator () \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-22","title":"function data_use_indicator [2/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator (\n    const data_use_indicator &amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-is_used","title":"function is_used","text":"<pre><code>inline bool ILLIXR::data_use_indicator::is_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_unused","title":"function mark_unused","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_unused () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-operator","title":"function operator=","text":"<pre><code>inline data_use_indicator &amp; ILLIXR::data_use_indicator::operator= (\n    const data_use_indicator &amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1dynamic__lib/","title":"Class ILLIXR::dynamic_lib","text":"<p>ClassList &gt; ILLIXR &gt; dynamic_lib</p>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions","title":"Public Functions","text":"Type Name dynamic_lib (dynamic_lib &amp;&amp; other)  const T get (const std::string &amp; symbol_name) const dynamic_lib &amp; operator= (dynamic_lib &amp;&amp; other)  const void * operator[] (const std::string &amp; symbol_name) const ~dynamic_lib ()"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions","title":"Public Static Functions","text":"Type Name dynamic_lib create (const std::string &amp; path)  dynamic_lib create (const std::string_view &amp; path)"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-dynamic_lib-22","title":"function dynamic_lib [2/2]","text":"<pre><code>inline ILLIXR::dynamic_lib::dynamic_lib (\n    dynamic_lib &amp;&amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-get","title":"function get","text":"<pre><code>template&lt;typename T&gt;\ninline const T ILLIXR::dynamic_lib::get (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator","title":"function operator=","text":"<pre><code>inline dynamic_lib &amp; ILLIXR::dynamic_lib::operator= (\n    dynamic_lib &amp;&amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const void * ILLIXR::dynamic_lib::operator[] (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-dynamic_lib","title":"function ~dynamic_lib","text":"<pre><code>inline ILLIXR::dynamic_lib::~dynamic_lib () \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-create-12","title":"function create [1/2]","text":"<pre><code>static inline dynamic_lib ILLIXR::dynamic_lib::create (\n    const std::string &amp; path\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-create-22","title":"function create [2/2]","text":"<pre><code>static inline dynamic_lib ILLIXR::dynamic_lib::create (\n    const std::string_view &amp; path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/dynamic_lib.hpp</code></p>"},{"location":"api/structILLIXR_1_1fast__pose__type/","title":"Struct ILLIXR::fast_pose_type","text":"<p>ClassList &gt; ILLIXR &gt; fast_pose_type</p>"},{"location":"api/structILLIXR_1_1fast__pose__type/#public-attributes","title":"Public Attributes","text":"Type Name pose_type pose time_type predict_computed_time time_type predict_target_time"},{"location":"api/structILLIXR_1_1fast__pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1fast__pose__type/#variable-pose","title":"variable pose","text":"<pre><code>pose_type ILLIXR::fast_pose_type::pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1fast__pose__type/#variable-predict_computed_time","title":"variable predict_computed_time","text":"<pre><code>time_type ILLIXR::fast_pose_type::predict_computed_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1fast__pose__type/#variable-predict_target_time","title":"variable predict_target_time","text":"<pre><code>time_type ILLIXR::fast_pose_type::predict_target_time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1gen__guid/","title":"Class ILLIXR::gen_guid","text":"<p>ClassList &gt; ILLIXR &gt; gen_guid</p> <p>This class generates unique IDs. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions","title":"Public Functions","text":"Type Name std::size_t get (std::size_t namespace_=0, std::size_t subnamespace=0, std::size_t subsubnamespace=0) Generate a number, unique from other calls to the same namespace/subnamespace/subsubnamepsace."},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1gen__guid/#detailed-description","title":"Detailed Description","text":"<p>If you need unique IDs (e.g. for each component), have each component call this class through Phonebook. It returns unique IDs.</p> <p>You can use namespaces to express logical containment. The return value will be unique between other <code>get</code> calls to the same namespace. This is useful for components and sub-components. For example, If component with ID 0 has 3 subcomponents, one might call get(0) to name each of them. Then, suppose component with ID 1 has 2 subcomponents, one might call get(1) twice to name those. The subcomponent IDs could be reused (non-unique), but tuple (component ID, subcomponent ID) will still be unique. You can also just use the global namespace for everything, if you do not care about generating small integers for the IDs. </p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1gen__guid/#function-get","title":"function get","text":"<p>Generate a number, unique from other calls to the same namespace/subnamespace/subsubnamepsace. <pre><code>inline std::size_t ILLIXR::gen_guid::get (\n    std::size_t namespace_=0,\n    std::size_t subnamespace=0,\n    std::size_t subsubnamespace=0\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/","title":"Struct ILLIXR::hmd_physical_info","text":"<p>ClassList &gt; ILLIXR &gt; hmd_physical_info</p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes","title":"Public Attributes","text":"Type Name float K float chromaticAberration int displayPixelsHigh int displayPixelsWide float ipd float lensSeparationInMeters float metersPerTanAngleAtCenter float visibleMetersHigh float visibleMetersWide int visiblePixelsHigh int visiblePixelsWide"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-k","title":"variable K","text":"<pre><code>float ILLIXR::hmd_physical_info::K[11];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-chromaticaberration","title":"variable chromaticAberration","text":"<pre><code>float ILLIXR::hmd_physical_info::chromaticAberration[4];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelshigh","title":"variable displayPixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelswide","title":"variable displayPixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-ipd","title":"variable ipd","text":"<pre><code>float ILLIXR::hmd_physical_info::ipd;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-lensseparationinmeters","title":"variable lensSeparationInMeters","text":"<pre><code>float ILLIXR::hmd_physical_info::lensSeparationInMeters;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-meterspertanangleatcenter","title":"variable metersPerTanAngleAtCenter","text":"<pre><code>float ILLIXR::hmd_physical_info::metersPerTanAngleAtCenter;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemetershigh","title":"variable visibleMetersHigh","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemeterswide","title":"variable visibleMetersWide","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelshigh","title":"variable visiblePixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelswide","title":"variable visiblePixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsWide;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1hologram__input/","title":"Struct ILLIXR::hologram_input","text":"<p>ClassList &gt; ILLIXR &gt; hologram_input</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes","title":"Public Attributes","text":"Type Name int seq"},{"location":"api/structILLIXR_1_1hologram__input/#public-functions","title":"Public Functions","text":"Type Name hologram_input ()  hologram_input (int seq_)"},{"location":"api/structILLIXR_1_1hologram__input/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__input/#variable-seq","title":"variable seq","text":"<pre><code>int ILLIXR::hologram_input::seq;\n</code></pre>"},{"location":"api/structILLIXR_1_1hologram__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__input/#function-hologram_input-12","title":"function hologram_input [1/2]","text":"<pre><code>inline ILLIXR::hologram_input::hologram_input () \n</code></pre>"},{"location":"api/structILLIXR_1_1hologram__input/#function-hologram_input-22","title":"function hologram_input [2/2]","text":"<pre><code>inline ILLIXR::hologram_input::hologram_input (\n    int seq_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__cam__type/","title":"Struct ILLIXR::imu_cam_type","text":"<p>ClassList &gt; ILLIXR &gt; imu_cam_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3f angular_v ullong dataset_time std::optional&lt; cv::Mat &gt; img0 std::optional&lt; cv::Mat &gt; img1 Eigen::Vector3f linear_a time_type time"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-functions","title":"Public Functions","text":"Type Name imu_cam_type (time_type time_, Eigen::Vector3f angular_v_, Eigen::Vector3f linear_a_, std::optional&lt; cv::Mat &gt; img0_, std::optional&lt; cv::Mat &gt; img1_, ullong dataset_time_)"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-angular_v","title":"variable angular_v","text":"<pre><code>Eigen::Vector3f ILLIXR::imu_cam_type::angular_v;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-dataset_time","title":"variable dataset_time","text":"<pre><code>ullong ILLIXR::imu_cam_type::dataset_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-img0","title":"variable img0","text":"<pre><code>std::optional&lt;cv::Mat&gt; ILLIXR::imu_cam_type::img0;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-img1","title":"variable img1","text":"<pre><code>std::optional&lt;cv::Mat&gt; ILLIXR::imu_cam_type::img1;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-linear_a","title":"variable linear_a","text":"<pre><code>Eigen::Vector3f ILLIXR::imu_cam_type::linear_a;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-time","title":"variable time","text":"<pre><code>time_type ILLIXR::imu_cam_type::time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1imu__cam__type/#function-imu_cam_type","title":"function imu_cam_type","text":"<pre><code>inline ILLIXR::imu_cam_type::imu_cam_type (\n    time_type time_,\n    Eigen::Vector3f angular_v_,\n    Eigen::Vector3f linear_a_,\n    std::optional&lt; cv::Mat &gt; img0_,\n    std::optional&lt; cv::Mat &gt; img1_,\n    ullong dataset_time_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__integrator__input/","title":"Struct ILLIXR::imu_integrator_input","text":"<p>ClassList &gt; ILLIXR &gt; imu_integrator_input</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3d biasAcc Eigen::Vector3d biasGyro double last_cam_integration_time imu_params params Eigen::Matrix&lt; double, 3, 1 &gt; position Eigen::Quaterniond quat double t_offset Eigen::Matrix&lt; double, 3, 1 &gt; velocity"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-functions","title":"Public Functions","text":"Type Name imu_integrator_input (double last_cam_integration_time_, double t_offset_, imu_params params_, Eigen::Vector3d biasAcc_, Eigen::Vector3d biasGyro_, Eigen::Matrix&lt; double, 3, 1 &gt; position_, Eigen::Matrix&lt; double, 3, 1 &gt; velocity_, Eigen::Quaterniond quat_)"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-biasacc","title":"variable biasAcc","text":"<pre><code>Eigen::Vector3d ILLIXR::imu_integrator_input::biasAcc;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-biasgyro","title":"variable biasGyro","text":"<pre><code>Eigen::Vector3d ILLIXR::imu_integrator_input::biasGyro;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-last_cam_integration_time","title":"variable last_cam_integration_time","text":"<pre><code>double ILLIXR::imu_integrator_input::last_cam_integration_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-params","title":"variable params","text":"<pre><code>imu_params ILLIXR::imu_integrator_input::params;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-position","title":"variable position","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_integrator_input::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-quat","title":"variable quat","text":"<pre><code>Eigen::Quaterniond ILLIXR::imu_integrator_input::quat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-t_offset","title":"variable t_offset","text":"<pre><code>double ILLIXR::imu_integrator_input::t_offset;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-velocity","title":"variable velocity","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_integrator_input::velocity;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1imu__integrator__input/#function-imu_integrator_input","title":"function imu_integrator_input","text":"<pre><code>inline ILLIXR::imu_integrator_input::imu_integrator_input (\n    double last_cam_integration_time_,\n    double t_offset_,\n    imu_params params_,\n    Eigen::Vector3d biasAcc_,\n    Eigen::Vector3d biasGyro_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; position_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; velocity_,\n    Eigen::Quaterniond quat_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__integrator__seq/","title":"Struct ILLIXR::imu_integrator_seq","text":"<p>ClassList &gt; ILLIXR &gt; imu_integrator_seq</p>"},{"location":"api/structILLIXR_1_1imu__integrator__seq/#public-attributes","title":"Public Attributes","text":"Type Name int seq"},{"location":"api/structILLIXR_1_1imu__integrator__seq/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__integrator__seq/#variable-seq","title":"variable seq","text":"<pre><code>int ILLIXR::imu_integrator_seq::seq;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__params/","title":"Struct ILLIXR::imu_params","text":"<p>ClassList &gt; ILLIXR &gt; imu_params</p>"},{"location":"api/structILLIXR_1_1imu__params/#public-attributes","title":"Public Attributes","text":"Type Name double acc_noise double acc_walk double gyro_noise double gyro_walk double imu_integration_sigma Eigen::Matrix&lt; double, 3, 1 &gt; n_gravity double nominal_rate"},{"location":"api/structILLIXR_1_1imu__params/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__params/#variable-acc_noise","title":"variable acc_noise","text":"<pre><code>double ILLIXR::imu_params::acc_noise;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-acc_walk","title":"variable acc_walk","text":"<pre><code>double ILLIXR::imu_params::acc_walk;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-gyro_noise","title":"variable gyro_noise","text":"<pre><code>double ILLIXR::imu_params::gyro_noise;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-gyro_walk","title":"variable gyro_walk","text":"<pre><code>double ILLIXR::imu_params::gyro_walk;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-imu_integration_sigma","title":"variable imu_integration_sigma","text":"<pre><code>double ILLIXR::imu_params::imu_integration_sigma;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-n_gravity","title":"variable n_gravity","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_params::n_gravity;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-nominal_rate","title":"variable nominal_rate","text":"<pre><code>double ILLIXR::imu_params::nominal_rate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__raw__type/","title":"Struct ILLIXR::imu_raw_type","text":"<p>ClassList &gt; ILLIXR &gt; imu_raw_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Matrix&lt; double, 3, 1 &gt; a_hat Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2 time_type imu_time Eigen::Matrix&lt; double, 3, 1 &gt; pos Eigen::Quaterniond quat Eigen::Matrix&lt; double, 3, 1 &gt; vel Eigen::Matrix&lt; double, 3, 1 &gt; w_hat Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-functions","title":"Public Functions","text":"Type Name imu_raw_type (Eigen::Matrix&lt; double, 3, 1 &gt; w_hat_, Eigen::Matrix&lt; double, 3, 1 &gt; a_hat_, Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2_, Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2_, Eigen::Matrix&lt; double, 3, 1 &gt; pos_, Eigen::Matrix&lt; double, 3, 1 &gt; vel_, Eigen::Quaterniond quat_, time_type imu_time_)"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-a_hat","title":"variable a_hat","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_raw_type::a_hat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-a_hat2","title":"variable a_hat2","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_raw_type::a_hat2;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-imu_time","title":"variable imu_time","text":"<pre><code>time_type ILLIXR::imu_raw_type::imu_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-pos","title":"variable pos","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_raw_type::pos;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-quat","title":"variable quat","text":"<pre><code>Eigen::Quaterniond ILLIXR::imu_raw_type::quat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-vel","title":"variable vel","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_raw_type::vel;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-w_hat","title":"variable w_hat","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_raw_type::w_hat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-w_hat2","title":"variable w_hat2","text":"<pre><code>Eigen::Matrix&lt;double,3,1&gt; ILLIXR::imu_raw_type::w_hat2;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1imu__raw__type/#function-imu_raw_type","title":"function imu_raw_type","text":"<pre><code>inline ILLIXR::imu_raw_type::imu_raw_type (\n    Eigen::Matrix&lt; double, 3, 1 &gt; w_hat_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; a_hat_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; pos_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; vel_,\n    Eigen::Quaterniond quat_,\n    time_type imu_time_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1managed__thread/","title":"Class ILLIXR::managed_thread","text":"<p>ClassList &gt; ILLIXR &gt; managed_thread</p> <p>An object that manages a std::thread; it joins and exits when the object gets destructed. </p> <ul> <li><code>#include &lt;managed_thread.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1managed__thread/#public-types","title":"Public Types","text":"Type Name enum state Possible states for a managed_thread ."},{"location":"api/classILLIXR_1_1managed__thread/#public-functions","title":"Public Functions","text":"Type Name state get_state ()  managed_thread () noexceptConstructs a non-startable thread. managed_thread (std::function&lt; void()&gt; body, std::function&lt; void()&gt; on_start=std::function&lt; void()&gt;{}, std::function&lt; void()&gt; on_stop=std::function&lt; void()&gt;{}) noexceptConstructs a startable thread. void start () Moves a managed_thread from startable to running. void stop () Moves a managed_thread from running to stopped. ~managed_thread () noexceptStops a thread, if necessary."},{"location":"api/classILLIXR_1_1managed__thread/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1managed__thread/#enum-state","title":"enum state","text":"<p>Possible states for a managed_thread . <pre><code>enum ILLIXR::managed_thread::state {\n    nonstartable,\n    startable,\n    running,\n    stopped\n};\n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1managed__thread/#function-get_state","title":"function get_state","text":"<pre><code>inline state ILLIXR::managed_thread::get_state () \n</code></pre>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread-12","title":"function managed_thread [1/2]","text":"<p>Constructs a non-startable thread. <pre><code>inline ILLIXR::managed_thread::managed_thread () noexcept\n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread-22","title":"function managed_thread [2/2]","text":"<p>Constructs a startable thread. <pre><code>inline ILLIXR::managed_thread::managed_thread (\n    std::function&lt; void()&gt; body,\n    std::function&lt; void()&gt; on_start=std::function&lt; void()&gt;{},\n    std::function&lt; void()&gt; on_stop=std::function&lt; void()&gt;{}\n) noexcept\n</code></pre></p> <p><code>on_stop</code> is called once (if present) <code>on_start</code> is called as the thread is joining <code>body</code> is called in a tight loop </p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-start","title":"function start","text":"<p>Moves a managed_thread from startable to running. <pre><code>inline void ILLIXR::managed_thread::start () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-stop","title":"function stop","text":"<p>Moves a managed_thread from running to stopped. <pre><code>inline void ILLIXR::managed_thread::stop () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread","title":"function ~managed_thread","text":"<p>Stops a thread, if necessary. <pre><code>inline ILLIXR::managed_thread::~managed_thread () noexcept\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>common/managed_thread.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1math__util/","title":"Namespace ILLIXR::math_util","text":"<p>Namespace List &gt; ILLIXR &gt; math_util</p>"},{"location":"api/namespaceILLIXR_1_1math__util/#public-functions","title":"Public Functions","text":"Type Name void projection (Eigen::Matrix4f * result, const float tanAngleLeft, const float tanAngleRight, const float tanAngleUp, float const tanAngleDown, const float nearZ, const float farZ)  void projection_fov (Eigen::Matrix4f * result, const float fovLeft, const float fovRight, const float fovUp, const float fovDown, const float nearZ, const float farZ)"},{"location":"api/namespaceILLIXR_1_1math__util/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1math__util/#function-projection","title":"function projection","text":"<pre><code>void ILLIXR::math_util::projection (\n    Eigen::Matrix4f * result,\n    const float tanAngleLeft,\n    const float tanAngleRight,\n    const float tanAngleUp,\n    float const tanAngleDown,\n    const float nearZ,\n    const float farZ\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#function-projection_fov","title":"function projection_fov","text":"<pre><code>void ILLIXR::math_util::projection_fov (\n    Eigen::Matrix4f * result,\n    const float fovLeft,\n    const float fovRight,\n    const float fovUp,\n    const float fovDown,\n    const float nearZ,\n    const float farZ\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/math_util.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook/","title":"Class ILLIXR::phonebook","text":"<p>ClassList &gt; ILLIXR &gt; phonebook</p> <p>A service locator forILLIXR .More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#classes","title":"Classes","text":"Type Name class service A 'service' that can be registered in the phonebook."},{"location":"api/classILLIXR_1_1phonebook/#public-functions","title":"Public Functions","text":"Type Name std::shared_ptr&lt; specific_service &gt; lookup_impl () constLook up an implementation of <code>specific_service</code> , which should be registered first. void register_impl (std::shared_ptr&lt; specific_service &gt; impl) Registers an implementation of <code>baseclass</code> for future calls to lookup."},{"location":"api/classILLIXR_1_1phonebook/#detailed-description","title":"Detailed Description","text":"<p>This will be explained through an exmaple: Suppose one dynamically-loaded plugin, <code>A_plugin</code>, needs a service, <code>B_service</code>, provided by another, <code>B_plugin</code>. <code>A_plugin</code> cannot statically construct a <code>B_service</code>, because the implementation <code>B_plugin</code> is dynamically loaded. However, <code>B_plugin</code> can register an implementation of <code>B_service</code> when it is loaded, and <code>A_plugin</code> can lookup that implementation without knowing it.</p> <p><code>B_service.hpp</code> in <code>common</code>:  <pre><code>class B_service {\npublic:\n    virtual void frobnicate(foo data) = 0;\n};\n</code></pre></p> <p><code>B_plugin.hpp</code>:  <pre><code>class B_impl : public B_service {\npublic:\n    virtual void frobnicate(foo data) {\n        // ...\n    }\n};\nvoid blah_blah(phonebook* pb) {\n    // Expose `this` as the \"official\" implementation of `B_service` for this run.\n    pb-&gt;register_impl&lt;B_service&gt;(std::make_shared&lt;B_impl&gt;());\n}\n</code></pre></p> <p><code>A_plugin.cpp</code>:  <pre><code>#include \"B_service.hpp\"\nvoid blah_blah(phonebook* pb) {\n    B_service* b = pb-&gt;lookup_impl&lt;B_service&gt;();\n    b-&gt;frobnicate(data);\n}\n</code></pre></p> <p>If the implementation of <code>B_service</code> is not known to <code>A_plugin</code> (the usual case), <code>B_service should be an [abstract class][2]. In either case</code>B_service<code>should be in</code>common`, so both plugins can refer to it.</p> <p>One could even selectively return a different implementation of <code>B_service</code> depending on the caller (through the parameters), but we have not encountered the need for that yet. </p>"},{"location":"api/classILLIXR_1_1phonebook/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook/#function-lookup_impl","title":"function lookup_impl","text":"<p>Look up an implementation of <code>specific_service</code> , which should be registered first. <pre><code>template&lt;typename specific_service&gt;\ninline std::shared_ptr&lt; specific_service &gt; ILLIXR::phonebook::lookup_impl () const\n</code></pre></p> <p>Safe to be called from any thread.</p> <p>Do not call <code>delete</code> on the returned object; it is still managed by phonebook.</p> <p>Exception:</p> <ul> <li><code>if</code> an implementation is not already registered. </li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#function-register_impl","title":"function register_impl","text":"<p>Registers an implementation of <code>baseclass</code> for future calls to lookup. <pre><code>template&lt;typename specific_service&gt;\ninline void ILLIXR::phonebook::register_impl (\n    std::shared_ptr&lt; specific_service &gt; impl\n) \n</code></pre></p> <p>Safe to be called from any thread.</p> <p>The implementation will be owned by phonebook (phonebook calls <code>delete</code>). </p> <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/","title":"Class ILLIXR::phonebook::service","text":"<p>ClassList &gt; ILLIXR &gt; phonebook &gt; service</p> <p>A 'service' that can be registered in the phonebook. More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::Stoplight,  ILLIXR::gen_guid,  ILLIXR::record_logger,  ILLIXR::switchboard,  ILLIXR::xlib_gl_extended_window,  pose_prediction</p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions","title":"Public Functions","text":"Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#detailed-description","title":"Detailed Description","text":"<p>These must be 'destructible', have a virtual destructor that phonebook can call in its destructor. </p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook_1_1service/#function-service","title":"function ~service","text":"<pre><code>inline virtual ILLIXR::phonebook::service::~service () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1plugin/","title":"Class ILLIXR::plugin","text":"<p>ClassList &gt; ILLIXR &gt; plugin</p> <p>A dynamically-loadable plugin for Spindle. </p> <ul> <li><code>#include &lt;plugin.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1plugin/#public-functions","title":"Public Functions","text":"Type Name std::string get_name () noexcept const plugin (const std::string &amp; name_, phonebook * pb_)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes","title":"Protected Attributes","text":"Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id std::string name const phonebook * pb const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#function-get_name","title":"function get_name","text":"<pre><code>inline std::string ILLIXR::plugin::get_name () noexcept const\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin","title":"function plugin","text":"<pre><code>inline ILLIXR::plugin::plugin (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-start","title":"function start","text":"<p>A method which Spindle calls when it starts the component. <pre><code>inline virtual void ILLIXR::plugin::start () \n</code></pre></p> <p>This is necessary because a constructor can't call derived virtual methods (due to structure of C++). See <code>threadloop</code> for an example of this use-case. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-stop","title":"function stop","text":"<p>A method which Spindle calls when it stops the component. <pre><code>inline virtual void ILLIXR::plugin::stop () \n</code></pre></p> <p>This is necessary because the parent class might define some actions that need to be taken prior to destructing the derived class. For example, threadloop must halt and join the thread before the derived class can be safely destructed. However, the derived class's destructor is called before its parent (threadloop), so threadloop doesn't get a chance to join the thread before the derived class is destroyed, and the thread accesses freed memory. Instead, we call plugin-&gt;stop manually before destrying anything. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin_1","title":"function ~plugin","text":"<pre><code>virtual ILLIXR::plugin::~plugin () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#variable-gen_guid_","title":"variable gen_guid_","text":"<pre><code>const std::shared_ptr&lt;gen_guid&gt; ILLIXR::plugin::gen_guid_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-id","title":"variable id","text":"<pre><code>const std::size_t ILLIXR::plugin::id;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-name","title":"variable name","text":"<pre><code>std::string ILLIXR::plugin::name;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-pb","title":"variable pb","text":"<pre><code>const phonebook* ILLIXR::plugin::pb;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-record_logger_","title":"variable record_logger_","text":"<pre><code>const std::shared_ptr&lt;record_logger&gt; ILLIXR::plugin::record_logger_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/plugin.hpp</code></p>"},{"location":"api/structILLIXR_1_1pose__type/","title":"Struct ILLIXR::pose_type","text":"<p>ClassList &gt; ILLIXR &gt; pose_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Quaternionf orientation Eigen::Vector3f position time_type sensor_time"},{"location":"api/structILLIXR_1_1pose__type/#public-functions","title":"Public Functions","text":"Type Name pose_type ()  pose_type (time_type sensor_time_, Eigen::Vector3f position_, Eigen::Quaternionf orientation_)"},{"location":"api/structILLIXR_1_1pose__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1pose__type/#variable-orientation","title":"variable orientation","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_type::orientation;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3f ILLIXR::pose_type::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-sensor_time","title":"variable sensor_time","text":"<pre><code>time_type ILLIXR::pose_type::sensor_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1pose__type/#function-pose_type-12","title":"function pose_type [1/2]","text":"<pre><code>inline ILLIXR::pose_type::pose_type () \n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#function-pose_type-22","title":"function pose_type [2/2]","text":"<pre><code>inline ILLIXR::pose_type::pose_type (\n    time_type sensor_time_,\n    Eigen::Vector3f position_,\n    Eigen::Quaternionf orientation_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1record/","title":"Class ILLIXR::record","text":"<p>ClassList &gt; ILLIXR &gt; record</p> <p>This class represents a tuple of fields which get logged by <code>record_logger</code> .More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record/#public-functions","title":"Public Functions","text":"Type Name const record_header &amp; get_record_header () const T get_value (unsigned column) const void mark_used () const record (const record_header &amp; rh_, std::vector&lt; std::any &gt; values_)  record ()  ~record ()"},{"location":"api/classILLIXR_1_1record/#detailed-description","title":"Detailed Description","text":"<p><code>rh_</code> is a pointer rather than a reference for historical reasons. It should not be null. </p>"},{"location":"api/classILLIXR_1_1record/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record/#function-get_record_header","title":"function get_record_header","text":"<pre><code>inline const record_header &amp; ILLIXR::record::get_record_header () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-get_value","title":"function get_value","text":"<pre><code>template&lt;typename T&gt;\ninline T ILLIXR::record::get_value (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::record::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record-12","title":"function record [1/2]","text":"<pre><code>inline ILLIXR::record::record (\n    const record_header &amp; rh_,\n    std::vector&lt; std::any &gt; values_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record-22","title":"function record [2/2]","text":"<pre><code>inline ILLIXR::record::record () \n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record","title":"function ~record","text":"<pre><code>inline ILLIXR::record::~record () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__coalescer/","title":"Class ILLIXR::record_coalescer","text":"<p>ClassList &gt; ILLIXR &gt; record_coalescer</p> <p>Coalesces logs of the same type to be written back as a single-transaction. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions","title":"Public Functions","text":"Type Name void flush () Flush buffer of logs to the underlying logger. void log (record r) Appends a log to the buffer, which will eventually be written. void maybe_flush () Use internal decision process, and possibly trigger flush. operator bool () const record_coalescer (std::shared_ptr&lt; record_logger &gt; logger_)  ~record_coalescer ()"},{"location":"api/classILLIXR_1_1record__coalescer/#detailed-description","title":"Detailed Description","text":"<p>Records should all be of the same type. TODO: remove this constraint. Use <code>log&lt;record_type&gt;(Args... args)</code> and <code>std::forward</code>.</p> <p>In some backend-implementations, logging many logs of the same type is more efficient than logging them individually; However, the client often wants to produce one log-record at a time. This class resolves this mismatch by buffering logs from the client. Every time a new log is added, an internal decision process determines whether or not to flush the buffer, or keep accumulating and wait unitl later.</p> <p>Currently this internal decision process is \"is the oldest log in the buffer more than 1 second old?\". I chose this because this frequency should have very little overhead, even if every component is also coalescing at 1 per second.</p> <p>At destructor time, any remaining logs are flushed.</p> <p>Use like:</p> <pre><code>log_coalescer(logger);\nlc.log(make_my_record(id, it, skip_it, ...));\n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__coalescer/#function-flush","title":"function flush","text":"<p>Flush buffer of logs to the underlying logger. <pre><code>inline void ILLIXR::record_coalescer::flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-log","title":"function log","text":"<p>Appends a log to the buffer, which will eventually be written. <pre><code>inline void ILLIXR::record_coalescer::log (\n    record r\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-maybe_flush","title":"function maybe_flush","text":"<p>Use internal decision process, and possibly trigger flush. <pre><code>inline void ILLIXR::record_coalescer::maybe_flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline ILLIXR::record_coalescer::operator bool () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer","title":"function record_coalescer","text":"<pre><code>inline ILLIXR::record_coalescer::record_coalescer (\n    std::shared_ptr&lt; record_logger &gt; logger_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer_1","title":"function ~record_coalescer","text":"<pre><code>inline ILLIXR::record_coalescer::~record_coalescer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__header/","title":"Class ILLIXR::record_header","text":"<p>ClassList &gt; ILLIXR &gt; record_header</p> <p>Schema of each record. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__header/#public-functions","title":"Public Functions","text":"Type Name const std::string &amp; get_column_name (unsigned column) const const std::type_info &amp; get_column_type (unsigned column) const unsigned get_columns () const std::size_t get_id () const const std::string &amp; get_name () const bool operator!= (const record_header &amp; other) const bool operator== (const record_header &amp; other) constCompares two schemata. record_header (std::string name_, std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_)  std::string to_string () const"},{"location":"api/classILLIXR_1_1record__header/#detailed-description","title":"Detailed Description","text":"<p>name_ should be globally unique. </p>"},{"location":"api/classILLIXR_1_1record__header/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__header/#function-get_column_name","title":"function get_column_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_column_name (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_column_type","title":"function get_column_type","text":"<pre><code>inline const std::type_info &amp; ILLIXR::record_header::get_column_type (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_columns","title":"function get_columns","text":"<pre><code>inline unsigned ILLIXR::record_header::get_columns () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_id","title":"function get_id","text":"<pre><code>inline std::size_t ILLIXR::record_header::get_id () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_name","title":"function get_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_name () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator","title":"function operator!=","text":"<pre><code>inline bool ILLIXR::record_header::operator!= (\n    const record_header &amp; other\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator_1","title":"function operator==","text":"<p>Compares two schemata. <pre><code>inline bool ILLIXR::record_header::operator== (\n    const record_header &amp; other\n) const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__header/#function-record_header","title":"function record_header","text":"<pre><code>inline ILLIXR::record_header::record_header (\n    std::string name_,\n    std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string ILLIXR::record_header::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__logger/","title":"Class ILLIXR::record_logger","text":"<p>ClassList &gt; ILLIXR &gt; record_logger</p> <p>The ILLIXR logging service for structured records.More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions","title":"Public Functions","text":"Type Name virtual void log (const record &amp; r) = 0Writes one log record. virtual void log (const std::vector&lt; record &gt; &amp; rs) Writes many of the same type of log record. virtual ~record_logger ()"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1record__logger/#detailed-description","title":"Detailed Description","text":"<p>This has two advantages over printf logging. It has lower overhead (because it goes into a database), won't result in spliced messages (no stdout race-conditions), and is used uniformly by ILLIXR components. </p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__logger/#function-log-12","title":"function log [1/2]","text":"<p>Writes one log record. <pre><code>virtual void ILLIXR::record_logger::log (\n    const record &amp; r\n) = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__logger/#function-log-22","title":"function log [2/2]","text":"<p>Writes many of the same type of log record. <pre><code>inline virtual void ILLIXR::record_logger::log (\n    const std::vector&lt; record &gt; &amp; rs\n) \n</code></pre></p> <p>This is more efficient than calling log many times. </p>"},{"location":"api/classILLIXR_1_1record__logger/#function-record_logger","title":"function ~record_logger","text":"<pre><code>inline virtual ILLIXR::record_logger::~record_logger () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendered__frame/","title":"Struct ILLIXR::rendered_frame","text":"<p>ClassList &gt; ILLIXR &gt; rendered_frame</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes","title":"Public Attributes","text":"Type Name fast_pose_type render_pose time_type render_time time_type sample_time GLuint swap_indices GLuint texture_handles"},{"location":"api/structILLIXR_1_1rendered__frame/#public-functions","title":"Public Functions","text":"Type Name rendered_frame ()  rendered_frame (GLuint texture_handles_, GLuint swap_indices_, fast_pose_type render_pose_, time_type sample_time_, time_type render_time_)"},{"location":"api/structILLIXR_1_1rendered__frame/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame/#variable-render_pose","title":"variable render_pose","text":"<pre><code>fast_pose_type ILLIXR::rendered_frame::render_pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-render_time","title":"variable render_time","text":"<pre><code>time_type ILLIXR::rendered_frame::render_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-sample_time","title":"variable sample_time","text":"<pre><code>time_type ILLIXR::rendered_frame::sample_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-swap_indices","title":"variable swap_indices","text":"<pre><code>GLuint ILLIXR::rendered_frame::swap_indices[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-texture_handles","title":"variable texture_handles","text":"<pre><code>GLuint ILLIXR::rendered_frame::texture_handles[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame/#function-rendered_frame-12","title":"function rendered_frame [1/2]","text":"<pre><code>inline ILLIXR::rendered_frame::rendered_frame () \n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#function-rendered_frame-22","title":"function rendered_frame [2/2]","text":"<pre><code>inline ILLIXR::rendered_frame::rendered_frame (\n    GLuint texture_handles_,\n    GLuint swap_indices_,\n    fast_pose_type render_pose_,\n    time_type sample_time_,\n    time_type render_time_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1rgb__depth__type/","title":"Class ILLIXR::rgb_depth_type","text":"<p>ClassList &gt; ILLIXR &gt; rgb_depth_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/classILLIXR_1_1rgb__depth__type/#public-functions","title":"Public Functions","text":"Type Name rgb_depth_type (std::optional&lt; cv::Mat &gt; _rgb, std::optional&lt; cv::Mat &gt; _depth, ullong _timestamp)"},{"location":"api/classILLIXR_1_1rgb__depth__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/classILLIXR_1_1rgb__depth__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1rgb__depth__type/#function-rgb_depth_type","title":"function rgb_depth_type","text":"<pre><code>inline ILLIXR::rgb_depth_type::rgb_depth_type (\n    std::optional&lt; cv::Mat &gt; _rgb,\n    std::optional&lt; cv::Mat &gt; _depth,\n    ullong _timestamp\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1runtime/","title":"Class ILLIXR::runtime","text":"<p>ClassList &gt; ILLIXR &gt; runtime</p>"},{"location":"api/classILLIXR_1_1runtime/#public-functions","title":"Public Functions","text":"Type Name virtual void load_plugin_factory (plugin_factory plugin) = 0 virtual void load_so (const std::vector&lt; std::string &gt; &amp; so) = 0 virtual void load_so (const std::string_view so) = 0 virtual void stop () = 0 virtual void wait () = 0 virtual ~runtime () = default"},{"location":"api/classILLIXR_1_1runtime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1runtime/#function-load_plugin_factory","title":"function load_plugin_factory","text":"<pre><code>virtual void ILLIXR::runtime::load_plugin_factory (\n    plugin_factory plugin\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_so-12","title":"function load_so [1/2]","text":"<pre><code>virtual void ILLIXR::runtime::load_so (\n    const std::vector&lt; std::string &gt; &amp; so\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_so-22","title":"function load_so [2/2]","text":"<pre><code>virtual void ILLIXR::runtime::load_so (\n    const std::string_view so\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-stop","title":"function stop","text":"<pre><code>virtual void ILLIXR::runtime::stop () = 0\n</code></pre> <p>Requests that the runtime is completely stopped. Clients must call this before deleting the runtime. </p>"},{"location":"api/classILLIXR_1_1runtime/#function-wait","title":"function wait","text":"<pre><code>virtual void ILLIXR::runtime::wait () = 0\n</code></pre> <p>Returns when the runtime is completely stopped. </p>"},{"location":"api/classILLIXR_1_1runtime/#function-runtime","title":"function ~runtime","text":"<pre><code>virtual ILLIXR::runtime::~runtime () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/runtime.hpp</code></p>"},{"location":"api/classILLIXR_1_1start__end__logger/","title":"Class ILLIXR::start_end_logger","text":"<p>ClassList &gt; ILLIXR &gt; start_end_logger</p> <p>a utility for logging to start and end times to a file </p> <ul> <li><code>#include &lt;logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1start__end__logger/#public-functions","title":"Public Functions","text":"Type Name int log_end (std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time)  int log_start (std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time)  start_end_logger (std::string component_name)  ~start_end_logger ()"},{"location":"api/classILLIXR_1_1start__end__logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1start__end__logger/#function-log_end","title":"function log_end","text":"<pre><code>inline int ILLIXR::start_end_logger::log_end (\n    std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-log_start","title":"function log_start","text":"<pre><code>inline int ILLIXR::start_end_logger::log_start (\n    std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-start_end_logger","title":"function start_end_logger","text":"<pre><code>inline ILLIXR::start_end_logger::start_end_logger (\n    std::string component_name\n) \n</code></pre> <p>Log apperas in <code>log/$component_name</code>. </p>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-start_end_logger_1","title":"function ~start_end_logger","text":"<pre><code>inline ILLIXR::start_end_logger::~start_end_logger () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard/","title":"Class ILLIXR::switchboard","text":"<p>ClassList &gt; ILLIXR &gt; switchboard</p> <p>A manager for typesafe, threadsafe, named event-streams (called topics). More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1switchboard/#classes","title":"Classes","text":"Type Name class event Virtual class for event types. class event_wrapper &lt;typename underlying_type&gt;Helper class for making event types. class reader &lt;typename specific_event&gt;A handle which can read the latest event on a topic. class writer &lt;typename specific_event&gt;A handle which can publish events to a topic."},{"location":"api/classILLIXR_1_1switchboard/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; specific_event &gt; ptr The type of shared pointer returned by switchboard."},{"location":"api/classILLIXR_1_1switchboard/#public-functions","title":"Public Functions","text":"Type Name reader&lt; specific_event &gt; get_reader (const std::string &amp; topic_name) Gets a handle to read to the latest value from the topic <code>topic_name</code> . writer&lt; specific_event &gt; get_writer (const std::string &amp; topic_name) Gets a handle to publish to the topic <code>topic_name</code> . void schedule (plugin_id_t plugin_id, std::string topic_name, std::function&lt; void(ptr&lt; const specific_event &gt; &amp;&amp;, std::size_t)&gt; fn) Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . void stop () Stops calling switchboard callbacks. switchboard (const phonebook * pb)"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1switchboard/#detailed-description","title":"Detailed Description","text":"<ul> <li>Writing: One can write to a topic (in any thread) through the object returned by <code>get_writer()</code>.</li> <li>There are two ways of reading: asynchronous reading and synchronous reading:</li> <li>Asynchronous reading returns the most-recent event on the topic (idempotently). One can do this through (in any thread) the object returned by <code>get_reader()</code>.</li> <li>Synchronous reading schedules a callback to be executed on every event which gets published. One can schedule computation by <code>schedule()</code>, which will run the computation in a thread managed by switchboard.</li> </ul> <pre><code>// Get a reader on topic1\nswitchboard::reader&lt;topic1_type&gt; topic1 = switchboard.get_reader&lt;topic1_type&gt;(\"topic1\");\n\n// Get a writer on topic2\nswitchboard::writer&lt;topic2_type&gt; topic2 = switchboard.get_writer&lt;topic2_type&gt;(\"topic2\");\n\nwhile (true) {\n    // Read topic 1\n    switchboard::ptr&lt;topic1_type&gt; event1 = topic1.get_rw();\n\n    // Write to topic 2 using topic 1 input\n    topic2.put(topic2.allocate&lt;topic2_type&gt;( do_something(event1-&gt;foo) ));\n}\n\n// Read topic 3 synchronously\nswitchboard.schedule&lt;topic3_type&gt;(plugin_id, \"topic3\", [&amp;](switchboard::ptr&lt;topic3_type&gt; event3, std::size_t it) {\n    // This is a lambda expression\n    // https://en.cppreference.com/w/cpp/language/lambda\n    std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3-&gt;foo &lt;&lt; \" for iteration \" &lt;&lt; it &lt;&lt; std::endl;\n});\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#typedef-ptr","title":"typedef ptr","text":"<p>The type of shared pointer returned by switchboard. <pre><code>using ILLIXR::switchboard::ptr =  std::shared_ptr&lt;specific_event&gt;;\n</code></pre></p> <p>TODO: Make this agnostic to the type of <code>ptr</code> Currently, it depends on <code>ptr</code> == shared_ptr </p>"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#function-get_reader","title":"function get_reader","text":"<p>Gets a handle to read to the latest value from the topic <code>topic_name</code> . <pre><code>template&lt;typename specific_event&gt;\ninline reader &lt; specific_event &gt; ILLIXR::switchboard::get_reader (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_writer","title":"function get_writer","text":"<p>Gets a handle to publish to the topic <code>topic_name</code> . <pre><code>template&lt;typename specific_event&gt;\ninline writer &lt; specific_event &gt; ILLIXR::switchboard::get_writer (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-schedule","title":"function schedule","text":"<p>Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . <pre><code>template&lt;typename specific_event&gt;\ninline void ILLIXR::switchboard::schedule (\n    plugin_id_t plugin_id,\n    std::string topic_name,\n    std::function&lt; void( ptr &lt; const specific_event &gt; &amp;&amp;, std::size_t)&gt; fn\n) \n</code></pre></p> <p>Switchboard maintains a threadpool to call <code>fn</code>.</p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>if</code> topic already exists and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-stop","title":"function stop","text":"<p>Stops calling switchboard callbacks. <pre><code>inline void ILLIXR::switchboard::stop () \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Leave topics in place, so existing reader/writer handles will not crash. </p>"},{"location":"api/classILLIXR_1_1switchboard/#function-switchboard","title":"function switchboard","text":"<pre><code>inline ILLIXR::switchboard::switchboard (\n    const phonebook * pb\n) \n</code></pre> <p>If <code>pb</code> is null, then logging is disabled. </p> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/","title":"Class ILLIXR::switchboard::event","text":"<p>ClassList &gt; ILLIXR &gt; switchboard &gt; event</p> <p>Virtual class for event types. More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::hologram_input,  ILLIXR::imu_cam_type,  ILLIXR::imu_integrator_input,  ILLIXR::imu_raw_type,  ILLIXR::pose_type,  ILLIXR::rendered_frame,  ILLIXR::rgb_depth_type,  ILLIXR::switchboard::event_wrapper,  ILLIXR::texture_pose</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#public-functions","title":"Public Functions","text":"Type Name virtual ~event () = default"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#detailed-description","title":"Detailed Description","text":"<p>Minimum requirement: Events must be destructible. Casting events from various sources to void* (aka type-punning) breaks [strict-aliasing][1] and is undefined behavior in modern C++. Therefore, we require a common supertype for all events. We will cast them to this common supertype, event* instead.</p> <p>[1] https://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1event/#function-event","title":"function ~event","text":"<pre><code>virtual ILLIXR::switchboard::event::~event () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/","title":"Class ILLIXR::switchboard::event_wrapper","text":"<p>template &lt;typename underlying_type&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; event_wrapper</p> <p>Helper class for making event types. More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions","title":"Public Functions","text":"Type Name event_wrapper ()  event_wrapper (underlying_type underlying_data_)  operator underlying_type () const underlying_type &amp; operator* ()  const underlying_type &amp; operator* () const"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#detailed-description","title":"Detailed Description","text":"<p>Since topic has no static type-information on the contained events, this class does not either.</p> <pre><code>event_wrapper&lt;int&gt; int_event = 5;\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-event_wrapper-12","title":"function event_wrapper [1/2]","text":"<pre><code>inline ILLIXR::switchboard::event_wrapper::event_wrapper () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-event_wrapper-22","title":"function event_wrapper [2/2]","text":"<pre><code>inline ILLIXR::switchboard::event_wrapper::event_wrapper (\n    underlying_type underlying_data_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator-underlying_type","title":"function operator underlying_type","text":"<pre><code>inline ILLIXR::switchboard::event_wrapper::operator underlying_type () const\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator","title":"function operator*","text":"<pre><code>inline underlying_type &amp; ILLIXR::switchboard::event_wrapper::operator* () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator_1","title":"function operator*","text":"<pre><code>inline const underlying_type &amp; ILLIXR::switchboard::event_wrapper::operator* () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/","title":"Class ILLIXR::switchboard::reader","text":"<p>template &lt;typename specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; reader</p> <p>A handle which can read the latest event on a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; const specific_event &gt; get_ro () constGets a non-null \"read-only\" copy of the latest value. ptr&lt; const specific_event &gt; get_ro_nullable () noexcept constGets a \"read-only\" copy of the latest value. ptr&lt; specific_event &gt; get_rw () constGets a non-null mutable copy of the latest value. reader (topic &amp; topic_)"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_ro","title":"function get_ro","text":"<p>Gets a non-null \"read-only\" copy of the latest value. <pre><code>inline ptr &lt; const specific_event &gt; ILLIXR::switchboard::reader::get_ro () const\n</code></pre></p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If no event is on the topic yet. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_ro_nullable","title":"function get_ro_nullable","text":"<p>Gets a \"read-only\" copy of the latest value. <pre><code>inline ptr &lt; const specific_event &gt; ILLIXR::switchboard::reader::get_ro_nullable () noexcept const\n</code></pre></p> <p>This will return null if no event is on the topic yet. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_rw","title":"function get_rw","text":"<p>Gets a non-null mutable copy of the latest value. <pre><code>inline ptr &lt; specific_event &gt; ILLIXR::switchboard::reader::get_rw () const\n</code></pre></p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If no event is on the topic yet. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-reader","title":"function reader","text":"<pre><code>inline ILLIXR::switchboard::reader::reader (\n    topic &amp; topic_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/","title":"Class ILLIXR::switchboard::writer","text":"<p>template &lt;typename specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; writer</p> <p>A handle which can publish events to a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; specific_event &gt; allocate (Args &amp;&amp;... args) Like <code>new</code> /<code>malloc</code> but more efficient for this specific case. void put (ptr&lt; specific_event &gt; &amp;&amp; this_specific_event) Publish <code>ev</code> to this topic. writer (topic &amp; topic_)"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-allocate","title":"function allocate","text":"<p>Like <code>new</code> /<code>malloc</code> but more efficient for this specific case. <pre><code>template&lt;class... Args&gt;\ninline ptr &lt; specific_event &gt; ILLIXR::switchboard::writer::allocate (\n    Args &amp;&amp;... args\n) \n</code></pre></p> <p>There is an optimization available which has not yet been implemented: switchboard can reuse memory from old events, like a slab allocator. Suppose module A publishes data for module B. B's deallocation through the destructor, and A's allocation through this method completes the cycle in a double-buffer (AKA swap-chain). </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-put","title":"function put","text":"<p>Publish <code>ev</code> to this topic. <pre><code>inline void ILLIXR::switchboard::writer::put (\n    ptr &lt; specific_event &gt; &amp;&amp; this_specific_event\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-writer","title":"function writer","text":"<pre><code>inline ILLIXR::switchboard::writer::writer (\n    topic &amp; topic_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/structILLIXR_1_1texture__pose/","title":"Struct ILLIXR::texture_pose","text":"<p>ClassList &gt; ILLIXR &gt; texture_pose</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1texture__pose/#public-attributes","title":"Public Attributes","text":"Type Name unsigned char * image Eigen::Quaternionf latest_quaternion int offload_time TODO: Should texture_pose.seq be a long long. time_type pose_time Eigen::Vector3f position Eigen::Quaternionf render_quaternion int seq"},{"location":"api/structILLIXR_1_1texture__pose/#public-functions","title":"Public Functions","text":"Type Name texture_pose ()  texture_pose (int seq_, int offload_time_, unsigned char * image_, time_type pose_time_, Eigen::Vector3f position_, Eigen::Quaternionf latest_quaternion_, Eigen::Quaternionf render_quaternion_)"},{"location":"api/structILLIXR_1_1texture__pose/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1texture__pose/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1texture__pose/#variable-image","title":"variable image","text":"<pre><code>unsigned char* ILLIXR::texture_pose::image;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-latest_quaternion","title":"variable latest_quaternion","text":"<pre><code>Eigen::Quaternionf ILLIXR::texture_pose::latest_quaternion;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-offload_time","title":"variable offload_time","text":"<p>TODO: Should texture_pose.seq be a long long. <pre><code>int ILLIXR::texture_pose::offload_time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-pose_time","title":"variable pose_time","text":"<pre><code>time_type ILLIXR::texture_pose::pose_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3f ILLIXR::texture_pose::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-render_quaternion","title":"variable render_quaternion","text":"<pre><code>Eigen::Quaternionf ILLIXR::texture_pose::render_quaternion;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-seq","title":"variable seq","text":"<pre><code>int ILLIXR::texture_pose::seq;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1texture__pose/#function-texture_pose-12","title":"function texture_pose [1/2]","text":"<pre><code>inline ILLIXR::texture_pose::texture_pose () \n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#function-texture_pose-22","title":"function texture_pose [2/2]","text":"<pre><code>inline ILLIXR::texture_pose::texture_pose (\n    int seq_,\n    int offload_time_,\n    unsigned char * image_,\n    time_type pose_time_,\n    Eigen::Vector3f position_,\n    Eigen::Quaternionf latest_quaternion_,\n    Eigen::Quaternionf render_quaternion_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1threadloop/","title":"Class ILLIXR::threadloop","text":"<p>ClassList &gt; ILLIXR &gt; threadloop</p> <p>A reusable threadloop for plugins. More...</p> <ul> <li><code>#include &lt;threadloop.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions","title":"Public Functions","text":"Type Name virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (std::string name_, phonebook * pb_)  virtual ~threadloop () override"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (const std::string &amp; name_, phonebook * pb_)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1threadloop/#protected-types","title":"Protected Types","text":"Type Name enum skip_option"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes","title":"Protected Attributes","text":"Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id std::string name const phonebook * pb const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions","title":"Protected Functions","text":"Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1threadloop/#detailed-description","title":"Detailed Description","text":"<p>The thread continuously runs <code>_p_one_iteration()</code> and is stopable by <code>stop()</code>.</p> <p>This factors out the common code I noticed in many different plugins. </p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-start","title":"function start","text":"<p>Starts the thread. <pre><code>inline virtual void ILLIXR::threadloop::start () override\n</code></pre></p> <p>This cannot go into the constructor because it starts a thread which calls <code>_p_one_iteration()</code> which is virtual in the child class.</p> <p>Calling a virtual child method from the parent constructor will not work as expected 1. Instead, the ISO CPP FAQ recommends calling a <code>start()</code> method immediately after construction 2. </p> <p>Implements ILLIXR::plugin::start</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-stop","title":"function stop","text":"<p>Joins the thread. <pre><code>inline virtual void ILLIXR::threadloop::stop () override\n</code></pre></p> <p>Must have already stopped the stoplight. </p> <p>Implements ILLIXR::plugin::stop</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop","title":"function threadloop","text":"<pre><code>inline ILLIXR::threadloop::threadloop (\n    std::string name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop_1","title":"function ~threadloop","text":"<pre><code>inline virtual ILLIXR::threadloop::~threadloop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#enum-skip_option","title":"enum skip_option","text":"<pre><code>enum ILLIXR::threadloop::skip_option {\n    run,\n    skip_and_spin,\n    skip_and_yield,\n    stop\n};\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#variable-iteration_no","title":"variable iteration_no","text":"<pre><code>std::size_t ILLIXR::threadloop::iteration_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#variable-skip_no","title":"variable skip_no","text":"<pre><code>std::size_t ILLIXR::threadloop::skip_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Override with the computation the thread does every loop. <pre><code>virtual void ILLIXR::threadloop::_p_one_iteration () = 0\n</code></pre></p> <p>This gets called in rapid succession. </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_should_skip","title":"function _p_should_skip","text":"<p>Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ <pre><code>inline virtual skip_option ILLIXR::threadloop::_p_should_skip () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<p>Gets called at setup time, from the new thread. <pre><code>inline virtual void ILLIXR::threadloop::_p_thread_setup () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-should_terminate","title":"function should_terminate","text":"<p>Whether the thread has been asked to terminate. <pre><code>inline bool ILLIXR::threadloop::should_terminate () \n</code></pre></p> <p>Check this before doing long-running computation; it makes termination more responsive. </p> <p>The documentation for this class was generated from the following file <code>common/threadloop.hpp</code></p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/","title":"Class ILLIXR::xlib_gl_extended_window","text":"<p>ClassList &gt; ILLIXR &gt; xlib_gl_extended_window</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes","title":"Public Attributes","text":"Type Name Display * dpy GLXContext glc int height int width Window win"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions","title":"Public Functions","text":"Type Name xlib_gl_extended_window (int _width, int _height, GLXContext _shared_gl_context)  ~xlib_gl_extended_window ()"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-dpy","title":"variable dpy","text":"<pre><code>Display* ILLIXR::xlib_gl_extended_window::dpy;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-glc","title":"variable glc","text":"<pre><code>GLXContext ILLIXR::xlib_gl_extended_window::glc;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-height","title":"variable height","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::height;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-width","title":"variable width","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::width;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-win","title":"variable win","text":"<pre><code>Window ILLIXR::xlib_gl_extended_window::win;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window","title":"function xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::xlib_gl_extended_window (\n    int _width,\n    int _height,\n    GLXContext _shared_gl_context\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window_1","title":"function ~xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::~xlib_gl_extended_window () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/extended_window.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/","title":"Class ILLIXR::switchboard::topic","text":"<p>ClassList &gt; topic</p> <p>Represents a topic. More...</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; const event &gt; get () constGets a read-only copy of the most recent event on the topic. const std::string &amp; name ()  void put (ptr&lt; const event &gt; &amp;&amp; this_event) Publishes <code>this_event</code> to the topic. void schedule (plugin_id_t plugin_id, std::function&lt; void(ptr&lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback) Schedules <code>callback</code> on the topic (<code>plugin_id</code> is for accounting) void stop () Stop and remove all topic_subscription threads. topic (std::string name, const std::type_info &amp; ty, std::shared_ptr&lt; record_logger &gt; record_logger_)  const std::type_info &amp; ty ()"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#detailed-description","title":"Detailed Description","text":"<p>Note, this class cannot have any static type-information about the contained events because I need to hold all of the topics in a homogeneous container (can't add topic&lt;int&gt; and topic&lt;float&gt; to the same std::vector&lt;topic&lt;WHAT_GOES_HERE&gt;&gt;).</p> <p>Therefore, this class uses type-erasure, and regards all events as type <code>event</code>. I could have used <code>std::any</code> for this, but I think inheriting <code>event</code> will be slightly more efficient because it avoids a heap-allocation.</p> <p>However, this class can have dynamic type-information in _m_ty, that gets set and checked at runtime. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-get","title":"function get","text":"<p>Gets a read-only copy of the most recent event on the topic. <pre><code>inline ptr &lt; const event &gt; topic::get () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-name","title":"function name","text":"<pre><code>inline const std::string &amp; topic::name () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-put","title":"function put","text":"<p>Publishes <code>this_event</code> to the topic. <pre><code>inline void topic::put (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre></p> <p>Thread-safe * Caveat:This (circular) queue based solution may race if &gt;= N write attempts to the N-sized queue interrupt a concurrent reader (using 'get').The reader's critical section is as follows:   * Read the latest serial number   * Compute the serial's modulus   * Dereference and access the position in the queue/array</p> <p>The critical section is extremely small, so a race is unlikely, albeit possible. The probability of a data race decreases geometrically with N. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-schedule","title":"function schedule","text":"<p>Schedules <code>callback</code> on the topic (<code>plugin_id</code> is for accounting) <pre><code>inline void topic::schedule (\n    plugin_id_t plugin_id,\n    std::function&lt; void( ptr &lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback\n) \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-stop","title":"function stop","text":"<p>Stop and remove all topic_subscription threads. <pre><code>inline void topic::stop () \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-topic","title":"function topic","text":"<pre><code>inline topic::topic (\n    std::string name,\n    const std::type_info &amp; ty,\n    std::shared_ptr&lt; record_logger &gt; record_logger_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-ty","title":"function ty","text":"<pre><code>inline const std::type_info &amp; topic::ty () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/","title":"Class ILLIXR::switchboard::topic_subscription","text":"<p>ClassList &gt; topic_subscription</p> <p>Represents a single topic_subscription (callback and queue) More...</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#public-functions","title":"Public Functions","text":"Type Name void enqueue (ptr&lt; const event &gt; &amp;&amp; this_event) Tells the subscriber about <code>this_event</code> . topic_subscription (const std::string &amp; topic_name, plugin_id_t plugin_id, std::function&lt; void(ptr&lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback, std::shared_ptr&lt; record_logger &gt; record_logger_)"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#detailed-description","title":"Detailed Description","text":"<p>This class treats everything as <code>event</code>s (type-erased) because <code>topic</code> treats everything as <code>event</code>s.</p> <p>Each topic can have 0 or more topic_subscriptions. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#function-enqueue","title":"function enqueue","text":"<p>Tells the subscriber about <code>this_event</code> . <pre><code>inline void topic_subscription::enqueue (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#function-topic_subscription","title":"function topic_subscription","text":"<pre><code>inline topic_subscription::topic_subscription (\n    const std::string &amp; topic_name,\n    plugin_id_t plugin_id,\n    std::function&lt; void( ptr &lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback,\n    std::shared_ptr&lt; record_logger &gt; record_logger_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/namespacelinalg/","title":"Namespace linalg","text":"<p>Namespace List &gt; linalg</p>"},{"location":"api/namespacelinalg/#namespaces","title":"Namespaces","text":"Type Name namespace aliases namespace detail namespace ostream_overloads"},{"location":"api/namespacelinalg/#classes","title":"Classes","text":"Type Name struct converter &lt;class T, class U&gt; struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; &lt;class T&gt; struct identity_t struct mat &lt;class T, M, N&gt; struct mat&lt; T, M, 1 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 2 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 3 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 4 &gt; &lt;class T, M&gt; struct vec &lt;class T, M&gt; struct vec&lt; T, 1 &gt; &lt;class T&gt; struct vec&lt; T, 2 &gt; &lt;class T&gt; struct vec&lt; T, 3 &gt; &lt;class T&gt; struct vec&lt; T, 4 &gt; &lt;class T&gt;"},{"location":"api/namespacelinalg/#public-types","title":"Public Types","text":"Type Name typedef typename detail::apply&lt; F, void, A... &gt;::type apply_t enum fwd_axis typedef typename detail::scalar_type&lt; A &gt;::type scalar_t enum z_range"},{"location":"api/namespacelinalg/#public-attributes","title":"Public Attributes","text":"Type Name constexpr identity_t identity   = <code>{1}</code>"},{"location":"api/namespacelinalg/#public-functions","title":"Public Functions","text":"Type Name apply_t&lt; detail::std_abs, A &gt; abs (const A &amp; a)  apply_t&lt; detail::std_acos, A &gt; acos (const A &amp; a)  constexpr mat&lt; T, 1, 1 &gt; adjugate (const mat&lt; T, 1, 1 &gt; &amp;)  constexpr mat&lt; T, 2, 2 &gt; adjugate (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr mat&lt; T, 3, 3 &gt; adjugate (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr mat&lt; T, 4, 4 &gt; adjugate (const mat&lt; T, 4, 4 &gt; &amp; a)  constexpr bool all (const A &amp; a)  T angle (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr bool any (const A &amp; a)  constexpr apply_t&lt; F, A... &gt; apply (F func, const A &amp;... args)  int argmax (const vec&lt; T, M &gt; &amp; a)  int argmin (const vec&lt; T, M &gt; &amp; a)  apply_t&lt; detail::std_asin, A &gt; asin (const A &amp; a)  apply_t&lt; detail::std_atan, A &gt; atan (const A &amp; a)  apply_t&lt; detail::std_atan2, A, B &gt; atan2 (const A &amp; a, const B &amp; b)  T * begin (vec&lt; T, M &gt; &amp; a)  const T * begin (const vec&lt; T, M &gt; &amp; a)  vec&lt; T, M &gt; * begin (mat&lt; T, M, N &gt; &amp; a)  const vec&lt; T, M &gt; * begin (const mat&lt; T, M, N &gt; &amp; a)  apply_t&lt; detail::std_ceil, A &gt; ceil (const A &amp; a)  constexpr apply_t&lt; detail::clamp, X, L, H &gt; clamp (const X &amp; x, const L &amp; l, const H &amp; h)  constexpr mat&lt; T, N, N &gt; comatrix (const mat&lt; T, N, N &gt; &amp; a)  constexpr detail::any_compare&lt; A, B &gt;::type compare (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_copysign, A, B &gt; copysign (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_cos, A &gt; cos (const A &amp; a)  apply_t&lt; detail::std_cosh, A &gt; cosh (const A &amp; a)  constexpr T cross (const vec&lt; T, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, 2 &gt; cross (T a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, 2 &gt; cross (const vec&lt; T, 2 &gt; &amp; a, T b)  constexpr vec&lt; T, 3 &gt; cross (const vec&lt; T, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr T determinant (const mat&lt; T, 1, 1 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 4, 4 &gt; &amp; a)  constexpr vec&lt; T, 1 &gt; diagonal (const mat&lt; T, 1, 1 &gt; &amp; a)  constexpr vec&lt; T, 2 &gt; diagonal (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr vec&lt; T, 3 &gt; diagonal (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr vec&lt; T, 4 &gt; diagonal (const mat&lt; T, 4, 4 &gt; &amp; a)  T distance (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr T distance2 (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr T dot (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  T * end (vec&lt; T, M &gt; &amp; a)  const T * end (const vec&lt; T, M &gt; &amp; a)  vec&lt; T, M &gt; * end (mat&lt; T, M, N &gt; &amp; a)  const vec&lt; T, M &gt; * end (const mat&lt; T, M, N &gt; &amp; a)  constexpr apply_t&lt; detail::op_eq, A, B &gt; equal (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_exp, A &gt; exp (const A &amp; a)  apply_t&lt; detail::std_floor, A &gt; floor (const A &amp; a)  apply_t&lt; detail::std_fmod, A, B &gt; fmod (const A &amp; a, const B &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 1 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 2 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 3 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 4 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 1 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 2 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 3 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 4 &gt; &amp; b)  mat&lt; T, 4, 4 &gt; frustum_matrix (T x0, T x1, T y0, T y1, T n, T f, fwd_axis a=neg_z, z_range z=neg_one_to_one)  constexpr apply_t&lt; detail::op_ge, A, B &gt; gequal (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_gt, A, B &gt; greater (const A &amp; a, const B &amp; b)  constexpr mat&lt; T, N, N &gt; inverse (const mat&lt; T, N, N &gt; &amp; a)  T length (const vec&lt; T, M &gt; &amp; a)  constexpr T length2 (const vec&lt; T, M &gt; &amp; a)  constexpr apply_t&lt; detail::op_le, A, B &gt; lequal (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::lerp, A, B, T &gt; lerp (const A &amp; a, const B &amp; b, const T &amp; t)  constexpr apply_t&lt; detail::op_lt, A, B &gt; less (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_log, A &gt; log (const A &amp; a)  apply_t&lt; detail::std_log10, A &gt; log10 (const A &amp; a)  constexpr apply_t&lt; F, A &gt; map (const A &amp; a, F func)  constexpr apply_t&lt; detail::max, A, B &gt; max (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; maxelem (const A &amp; a)  constexpr apply_t&lt; detail::min, A, B &gt; min (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; minelem (const A &amp; a)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 1 &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  constexpr mat&lt; T, M, 1 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 1 &gt; &amp; b)  constexpr mat&lt; T, M, 2 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 2 &gt; &amp; b)  constexpr mat&lt; T, M, 3 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 3 &gt; &amp; b)  constexpr mat&lt; T, M, 4 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 4 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const vec&lt; T, P &gt; &amp; c)  constexpr mat&lt; T, M, Q &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c, const vec&lt; T, Q &gt; &amp; d)  constexpr mat&lt; T, M, R &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c, const mat&lt; T, Q, R &gt; &amp; d)  constexpr apply_t&lt; detail::op_ne, A, B &gt; nequal (const A &amp; a, const B &amp; b)  vec&lt; T, M &gt; nlerp (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b, T t)  vec&lt; T, M &gt; normalize (const vec&lt; T, M &gt; &amp; a)  constexpr apply_t&lt; detail::op_not, A &gt; operator! (const A &amp; a)  virtual constexpr auto operator!= (const A &amp; a, const B &amp; b) = 0 constexpr apply_t&lt; detail::op_mod, A, B &gt; operator% (const A &amp; a, const B &amp; b)  constexpr auto operator%= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_int, A, B &gt; operator&amp; (const A &amp; a, const B &amp; b)  constexpr auto operator&amp;= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_mul, A, B &gt; operator* (const A &amp; a, const B &amp; b)  constexpr auto operator*= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_pos, A &gt; operator+ (const A &amp; a)  constexpr apply_t&lt; detail::op_add, A, B &gt; operator+ (const A &amp; a, const B &amp; b)  constexpr auto operator+= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_neg, A &gt; operator- (const A &amp; a)  constexpr apply_t&lt; detail::op_sub, A, B &gt; operator- (const A &amp; a, const B &amp; b)  constexpr auto operator-= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_div, A, B &gt; operator/ (const A &amp; a, const B &amp; b)  constexpr auto operator/= (A &amp; a, const B &amp; b)  constexpr auto operator&lt; (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_lsh, A, B &gt; operator&lt;&lt; (const A &amp; a, const B &amp; b)  constexpr auto operator&lt;&lt;= (A &amp; a, const B &amp; b)  virtual constexpr auto operator&lt;= (const A &amp; a, const B &amp; b) = 0 virtual constexpr auto operator== (const A &amp; a, const B &amp; b) = 0 constexpr auto operator&gt; (const A &amp; a, const B &amp; b)  virtual constexpr auto operator&gt;= (const A &amp; a, const B &amp; b) = 0 constexpr apply_t&lt; detail::op_rsh, A, B &gt; operator&gt;&gt; (const A &amp; a, const B &amp; b)  constexpr auto operator&gt;&gt;= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_xor, A, B &gt; operator^ (const A &amp; a, const B &amp; b)  constexpr auto operator^= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_un, A, B &gt; operator| (const A &amp; a, const B &amp; b)  constexpr auto operator|= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_cmp, A &gt; operator~ (const A &amp; a)  constexpr mat&lt; T, M, 1 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b)  constexpr mat&lt; T, M, 2 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr mat&lt; T, M, 3 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr mat&lt; T, M, 4 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  mat&lt; T, 4, 4 &gt; perspective_matrix (T fovy, T aspect, T n, T f, fwd_axis a=neg_z, z_range z=neg_one_to_one)  mat&lt; T, 4, 4 &gt; pose_matrix (const vec&lt; T, 4 &gt; &amp; q, const vec&lt; T, 3 &gt; &amp; p)  apply_t&lt; detail::std_pow, A, B &gt; pow (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; product (const A &amp; a)  T qangle (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 3 &gt; qaxis (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 4 &gt; qconj (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qexp (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qinv (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qlog (const vec&lt; T, 4 &gt; &amp; q)  constexpr mat&lt; T, 3, 3 &gt; qmat (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 4 &gt; qmul (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  constexpr vec&lt; T, 4 &gt; qmul (const vec&lt; T, 4 &gt; &amp; a, R... r)  vec&lt; T, 4 &gt; qnlerp (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b, T t)  vec&lt; T, 4 &gt; qpow (const vec&lt; T, 4 &gt; &amp; q, const T &amp; p)  constexpr vec&lt; T, 3 &gt; qrot (const vec&lt; T, 4 &gt; &amp; q, const vec&lt; T, 3 &gt; &amp; v)  vec&lt; T, 4 &gt; qslerp (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b, T t)  constexpr vec&lt; T, 3 &gt; qxdir (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 3 &gt; qydir (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 3 &gt; qzdir (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 2 &gt; rot (T a, const vec&lt; T, 2 &gt; &amp; v)  mat&lt; T, 4, 4 &gt; rotation_matrix (const vec&lt; T, 4 &gt; &amp; rotation)  vec&lt; T, 4 &gt; rotation_quat (const vec&lt; T, 3 &gt; &amp; axis, T angle)  vec&lt; T, 4 &gt; rotation_quat (const mat&lt; T, 3, 3 &gt; &amp; m)  apply_t&lt; detail::std_round, A &gt; round (const A &amp; a)  mat&lt; T, 4, 4 &gt; scaling_matrix (const vec&lt; T, 3 &gt; &amp; scaling)  constexpr apply_t&lt; detail::select, P, A, B &gt; select (const P &amp; p, const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_sin, A &gt; sin (const A &amp; a)  apply_t&lt; detail::std_sinh, A &gt; sinh (const A &amp; a)  vec&lt; T, M &gt; slerp (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b, T t)  apply_t&lt; detail::std_sqrt, A &gt; sqrt (const A &amp; a)  constexpr mat&lt; T, I1-I0, J1-J0 &gt; submat (const mat&lt; T, M, N &gt; &amp; a)  constexpr vec&lt; T, I1-I0 &gt; subvec (const vec&lt; T, M &gt; &amp; a)  constexpr scalar_t&lt; A &gt; sum (const A &amp; a)  constexpr vec&lt; T, sizeof...(I)&gt; swizzle (const vec&lt; T, M &gt; &amp; a)  apply_t&lt; detail::std_tan, A &gt; tan (const A &amp; a)  apply_t&lt; detail::std_tanh, A &gt; tanh (const A &amp; a)  constexpr T trace (const mat&lt; T, N, N &gt; &amp; a)  mat&lt; T, 4, 4 &gt; translation_matrix (const vec&lt; T, 3 &gt; &amp; translation)  constexpr mat&lt; T, M, 1 &gt; transpose (const mat&lt; T, 1, M &gt; &amp; m)  constexpr mat&lt; T, M, 2 &gt; transpose (const mat&lt; T, 2, M &gt; &amp; m)  constexpr mat&lt; T, M, 3 &gt; transpose (const mat&lt; T, 3, M &gt; &amp; m)  constexpr mat&lt; T, M, 4 &gt; transpose (const mat&lt; T, 4, M &gt; &amp; m)  T uangle (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr apply_t&lt; F, A, B &gt; zip (const A &amp; a, const B &amp; b, F func)"},{"location":"api/namespacelinalg/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg/#typedef-apply_t","title":"typedef apply_t","text":"<pre><code>using linalg::apply_t = typedef typename detail::apply&lt;F,void,A...&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg/#enum-fwd_axis","title":"enum fwd_axis","text":"<pre><code>enum linalg::fwd_axis {\n    neg_z,\n    pos_z\n};\n</code></pre>"},{"location":"api/namespacelinalg/#typedef-scalar_t","title":"typedef scalar_t","text":"<pre><code>using linalg::scalar_t = typedef typename detail::scalar_type&lt;A&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg/#enum-z_range","title":"enum z_range","text":"<pre><code>enum linalg::z_range {\n    neg_one_to_one,\n    zero_to_one\n};\n</code></pre>"},{"location":"api/namespacelinalg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacelinalg/#variable-identity","title":"variable identity","text":"<pre><code>constexpr identity_t linalg::identity;\n</code></pre>"},{"location":"api/namespacelinalg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg/#function-abs","title":"function abs","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_abs, A &gt; linalg::abs (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-acos","title":"function acos","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_acos, A &gt; linalg::acos (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 1, 1 &gt; linalg::adjugate (\n    const mat&lt; T, 1, 1 &gt; &amp;\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_1","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 2, 2 &gt; linalg::adjugate (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_2","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 3, 3 &gt; linalg::adjugate (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_3","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 4, 4 &gt; linalg::adjugate (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-all","title":"function all","text":"<pre><code>template&lt;class A&gt;\nconstexpr bool linalg::all (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-angle","title":"function angle","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::angle (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-any","title":"function any","text":"<pre><code>template&lt;class A&gt;\nconstexpr bool linalg::any (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-apply","title":"function apply","text":"<pre><code>template&lt;class F, class... A&gt;\nconstexpr apply_t&lt; F, A... &gt; linalg::apply (\n    F func,\n    const A &amp;... args\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-argmax","title":"function argmax","text":"<pre><code>template&lt;class T, int M&gt;\nint linalg::argmax (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-argmin","title":"function argmin","text":"<pre><code>template&lt;class T, int M&gt;\nint linalg::argmin (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-asin","title":"function asin","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_asin, A &gt; linalg::asin (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-atan","title":"function atan","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_atan, A &gt; linalg::atan (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-atan2","title":"function atan2","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_atan2, A, B &gt; linalg::atan2 (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin","title":"function begin","text":"<pre><code>template&lt;class T, int M&gt;\nT * linalg::begin (\n    vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_1","title":"function begin","text":"<pre><code>template&lt;class T, int M&gt;\nconst T * linalg::begin (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_2","title":"function begin","text":"<pre><code>template&lt;class T, int M, int N&gt;\nvec&lt; T, M &gt; * linalg::begin (\n    mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_3","title":"function begin","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconst vec&lt; T, M &gt; * linalg::begin (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-ceil","title":"function ceil","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_ceil, A &gt; linalg::ceil (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-clamp","title":"function clamp","text":"<pre><code>template&lt;class X, class L, class H&gt;\nconstexpr apply_t&lt; detail::clamp, X, L, H &gt; linalg::clamp (\n    const X &amp; x,\n    const L &amp; l,\n    const H &amp; h\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-comatrix","title":"function comatrix","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr mat&lt; T, N, N &gt; linalg::comatrix (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-compare","title":"function compare","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr detail::any_compare&lt; A, B &gt;::type linalg::compare (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-copysign","title":"function copysign","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_copysign, A, B &gt; linalg::copysign (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cos","title":"function cos","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_cos, A &gt; linalg::cos (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cosh","title":"function cosh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_cosh, A &gt; linalg::cosh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::cross (\n    const vec&lt; T, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_1","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::cross (\n    T a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_2","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::cross (\n    const vec&lt; T, 2 &gt; &amp; a,\n    T b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_3","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::cross (\n    const vec&lt; T, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 1, 1 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_1","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_2","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_3","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 1 &gt; linalg::diagonal (\n    const mat&lt; T, 1, 1 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_1","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::diagonal (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_2","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::diagonal (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_3","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::diagonal (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-distance","title":"function distance","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::distance (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-distance2","title":"function distance2","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::distance2 (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-dot","title":"function dot","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::dot (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end","title":"function end","text":"<pre><code>template&lt;class T, int M&gt;\nT * linalg::end (\n    vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_1","title":"function end","text":"<pre><code>template&lt;class T, int M&gt;\nconst T * linalg::end (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_2","title":"function end","text":"<pre><code>template&lt;class T, int M, int N&gt;\nvec&lt; T, M &gt; * linalg::end (\n    mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_3","title":"function end","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconst vec&lt; T, M &gt; * linalg::end (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-equal","title":"function equal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_eq, A, B &gt; linalg::equal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-exp","title":"function exp","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_exp, A &gt; linalg::exp (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-floor","title":"function floor","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_floor, A &gt; linalg::floor (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fmod","title":"function fmod","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_fmod, A, B &gt; linalg::fmod (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_1","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_2","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_3","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_4","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_5","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_6","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_7","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-frustum_matrix","title":"function frustum_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::frustum_matrix (\n    T x0,\n    T x1,\n    T y0,\n    T y1,\n    T n,\n    T f,\n    fwd_axis a=neg_z,\n    z_range z=neg_one_to_one\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-gequal","title":"function gequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_ge, A, B &gt; linalg::gequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-greater","title":"function greater","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_gt, A, B &gt; linalg::greater (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-inverse","title":"function inverse","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr mat&lt; T, N, N &gt; linalg::inverse (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-length","title":"function length","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::length (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-length2","title":"function length2","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::length2 (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-lequal","title":"function lequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_le, A, B &gt; linalg::lequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-lerp","title":"function lerp","text":"<pre><code>template&lt;class A, class B, class T&gt;\nconstexpr apply_t&lt; detail::lerp, A, B, T &gt; linalg::lerp (\n    const A &amp; a,\n    const B &amp; b,\n    const T &amp; t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-less","title":"function less","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_lt, A, B &gt; linalg::less (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-log","title":"function log","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_log, A &gt; linalg::log (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-log10","title":"function log10","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_log10, A &gt; linalg::log10 (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-map","title":"function map","text":"<pre><code>template&lt;class A, class F&gt;\nconstexpr apply_t&lt; F, A &gt; linalg::map (\n    const A &amp; a,\n    F func\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-max","title":"function max","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::max, A, B &gt; linalg::max (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-maxelem","title":"function maxelem","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::maxelem (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-min","title":"function min","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::min, A, B &gt; linalg::min (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-minelem","title":"function minelem","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::minelem (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 1 &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_1","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_2","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_3","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_4","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_5","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_6","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_7","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_8","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const vec&lt; T, P &gt; &amp; c\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_9","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q&gt;\nconstexpr mat&lt; T, M, Q &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_10","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c,\n    const vec&lt; T, Q &gt; &amp; d\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_11","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q, int R&gt;\nconstexpr mat&lt; T, M, R &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c,\n    const mat&lt; T, Q, R &gt; &amp; d\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-nequal","title":"function nequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_ne, A, B &gt; linalg::nequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-nlerp","title":"function nlerp","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::nlerp (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-normalize","title":"function normalize","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::normalize (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator","title":"function operator!","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_not, A &gt; linalg::operator! (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_1","title":"function operator!=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator!= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_2","title":"function operator%","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_mod, A, B &gt; linalg::operator% (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_3","title":"function operator%=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator%= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_4","title":"function operator&amp;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_int, A, B &gt; linalg::operator&amp; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_5","title":"function operator&amp;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&amp;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_6","title":"function operator*","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_mul, A, B &gt; linalg::operator* (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_7","title":"function operator*=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator*= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_8","title":"function operator+","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_pos, A &gt; linalg::operator+ (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_9","title":"function operator+","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_add, A, B &gt; linalg::operator+ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_10","title":"function operator+=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator+= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-","title":"function operator-","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_neg, A &gt; linalg::operator- (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-_1","title":"function operator-","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_sub, A, B &gt; linalg::operator- (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-_2","title":"function operator-=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator-= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_11","title":"function operator/","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_div, A, B &gt; linalg::operator/ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_12","title":"function operator/=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator/= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_13","title":"function operator&lt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&lt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_14","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_lsh, A, B &gt; linalg::operator&lt;&lt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_15","title":"function operator&lt;&lt;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&lt;&lt;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_16","title":"function operator&lt;=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator&lt;= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_17","title":"function operator==","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator== (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_18","title":"function operator&gt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&gt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_19","title":"function operator&gt;=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator&gt;= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_20","title":"function operator&gt;&gt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_rsh, A, B &gt; linalg::operator&gt;&gt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_21","title":"function operator&gt;&gt;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&gt;&gt;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_22","title":"function operator^","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_xor, A, B &gt; linalg::operator^ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_23","title":"function operator^=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator^= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_24","title":"function operator|","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_un, A, B &gt; linalg::operator| (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_25","title":"function operator|=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator|= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_26","title":"function operator~","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_cmp, A &gt; linalg::operator~ (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_1","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_2","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_3","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-perspective_matrix","title":"function perspective_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::perspective_matrix (\n    T fovy,\n    T aspect,\n    T n,\n    T f,\n    fwd_axis a=neg_z,\n    z_range z=neg_one_to_one\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-pose_matrix","title":"function pose_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::pose_matrix (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const vec&lt; T, 3 &gt; &amp; p\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-pow","title":"function pow","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_pow, A, B &gt; linalg::pow (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-product","title":"function product","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::product (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qangle","title":"function qangle","text":"<pre><code>template&lt;class T&gt;\nT linalg::qangle (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qaxis","title":"function qaxis","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 3 &gt; linalg::qaxis (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qconj","title":"function qconj","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qconj (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qexp","title":"function qexp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qexp (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qinv","title":"function qinv","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qinv (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qlog","title":"function qlog","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qlog (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmat","title":"function qmat","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 3, 3 &gt; linalg::qmat (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmul","title":"function qmul","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qmul (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmul_1","title":"function qmul","text":"<pre><code>template&lt;class T, class... R&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qmul (\n    const vec&lt; T, 4 &gt; &amp; a,\n    R... r\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qnlerp","title":"function qnlerp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qnlerp (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qpow","title":"function qpow","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qpow (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const T &amp; p\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qrot","title":"function qrot","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qrot (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const vec&lt; T, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qslerp","title":"function qslerp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qslerp (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qxdir","title":"function qxdir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qxdir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qydir","title":"function qydir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qydir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qzdir","title":"function qzdir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qzdir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rot","title":"function rot","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 2 &gt; linalg::rot (\n    T a,\n    const vec&lt; T, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_matrix","title":"function rotation_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::rotation_matrix (\n    const vec&lt; T, 4 &gt; &amp; rotation\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_quat","title":"function rotation_quat","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::rotation_quat (\n    const vec&lt; T, 3 &gt; &amp; axis,\n    T angle\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_quat_1","title":"function rotation_quat","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::rotation_quat (\n    const mat&lt; T, 3, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-round","title":"function round","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_round, A &gt; linalg::round (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-scaling_matrix","title":"function scaling_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::scaling_matrix (\n    const vec&lt; T, 3 &gt; &amp; scaling\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-select","title":"function select","text":"<pre><code>template&lt;class P, class A, class B&gt;\nconstexpr apply_t&lt; detail::select, P, A, B &gt; linalg::select (\n    const P &amp; p,\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sin","title":"function sin","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sin, A &gt; linalg::sin (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sinh","title":"function sinh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sinh, A &gt; linalg::sinh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-slerp","title":"function slerp","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::slerp (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sqrt","title":"function sqrt","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sqrt, A &gt; linalg::sqrt (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-submat","title":"function submat","text":"<pre><code>template&lt;int I0, int J0, int I1, int J1, class T, int M, int N&gt;\nconstexpr mat&lt; T, I1-I0, J1-J0 &gt; linalg::submat (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-subvec","title":"function subvec","text":"<pre><code>template&lt;int I0, int I1, class T, int M&gt;\nconstexpr vec&lt; T, I1-I0 &gt; linalg::subvec (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sum","title":"function sum","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::sum (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-swizzle","title":"function swizzle","text":"<pre><code>template&lt;int... I, class T, int M&gt;\nconstexpr vec&lt; T, sizeof...(I)&gt; linalg::swizzle (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-tan","title":"function tan","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_tan, A &gt; linalg::tan (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-tanh","title":"function tanh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_tanh, A &gt; linalg::tanh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-trace","title":"function trace","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr T linalg::trace (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-translation_matrix","title":"function translation_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::translation_matrix (\n    const vec&lt; T, 3 &gt; &amp; translation\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::transpose (\n    const mat&lt; T, 1, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_1","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::transpose (\n    const mat&lt; T, 2, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_2","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::transpose (\n    const mat&lt; T, 3, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_3","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::transpose (\n    const mat&lt; T, 4, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-uangle","title":"function uangle","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::uangle (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-zip","title":"function zip","text":"<pre><code>template&lt;class A, class B, class F&gt;\nconstexpr apply_t&lt; F, A, B &gt; linalg::zip (\n    const A &amp; a,\n    const B &amp; b,\n    F func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1aliases/","title":"Namespace linalg::aliases","text":"<p>Namespace List &gt; linalg &gt; aliases</p>"},{"location":"api/namespacelinalg_1_1aliases/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; bool, 1 &gt; bool1 typedef mat&lt; bool, 1, 1 &gt; bool1x1 typedef mat&lt; bool, 1, 2 &gt; bool1x2 typedef mat&lt; bool, 1, 3 &gt; bool1x3 typedef mat&lt; bool, 1, 4 &gt; bool1x4 typedef vec&lt; bool, 2 &gt; bool2 typedef mat&lt; bool, 2, 1 &gt; bool2x1 typedef mat&lt; bool, 2, 2 &gt; bool2x2 typedef mat&lt; bool, 2, 3 &gt; bool2x3 typedef mat&lt; bool, 2, 4 &gt; bool2x4 typedef vec&lt; bool, 3 &gt; bool3 typedef mat&lt; bool, 3, 1 &gt; bool3x1 typedef mat&lt; bool, 3, 2 &gt; bool3x2 typedef mat&lt; bool, 3, 3 &gt; bool3x3 typedef mat&lt; bool, 3, 4 &gt; bool3x4 typedef vec&lt; bool, 4 &gt; bool4 typedef mat&lt; bool, 4, 1 &gt; bool4x1 typedef mat&lt; bool, 4, 2 &gt; bool4x2 typedef mat&lt; bool, 4, 3 &gt; bool4x3 typedef mat&lt; bool, 4, 4 &gt; bool4x4 typedef vec&lt; uint8_t, 1 &gt; byte1 typedef vec&lt; uint8_t, 2 &gt; byte2 typedef vec&lt; uint8_t, 3 &gt; byte3 typedef vec&lt; uint8_t, 4 &gt; byte4 typedef vec&lt; double, 1 &gt; double1 typedef mat&lt; double, 1, 1 &gt; double1x1 typedef mat&lt; double, 1, 2 &gt; double1x2 typedef mat&lt; double, 1, 3 &gt; double1x3 typedef mat&lt; double, 1, 4 &gt; double1x4 typedef vec&lt; double, 2 &gt; double2 typedef mat&lt; double, 2, 1 &gt; double2x1 typedef mat&lt; double, 2, 2 &gt; double2x2 typedef mat&lt; double, 2, 3 &gt; double2x3 typedef mat&lt; double, 2, 4 &gt; double2x4 typedef vec&lt; double, 3 &gt; double3 typedef mat&lt; double, 3, 1 &gt; double3x1 typedef mat&lt; double, 3, 2 &gt; double3x2 typedef mat&lt; double, 3, 3 &gt; double3x3 typedef mat&lt; double, 3, 4 &gt; double3x4 typedef vec&lt; double, 4 &gt; double4 typedef mat&lt; double, 4, 1 &gt; double4x1 typedef mat&lt; double, 4, 2 &gt; double4x2 typedef mat&lt; double, 4, 3 &gt; double4x3 typedef mat&lt; double, 4, 4 &gt; double4x4 typedef vec&lt; float, 1 &gt; float1 typedef mat&lt; float, 1, 1 &gt; float1x1 typedef mat&lt; float, 1, 2 &gt; float1x2 typedef mat&lt; float, 1, 3 &gt; float1x3 typedef mat&lt; float, 1, 4 &gt; float1x4 typedef vec&lt; float, 2 &gt; float2 typedef mat&lt; float, 2, 1 &gt; float2x1 typedef mat&lt; float, 2, 2 &gt; float2x2 typedef mat&lt; float, 2, 3 &gt; float2x3 typedef mat&lt; float, 2, 4 &gt; float2x4 typedef vec&lt; float, 3 &gt; float3 typedef mat&lt; float, 3, 1 &gt; float3x1 typedef mat&lt; float, 3, 2 &gt; float3x2 typedef mat&lt; float, 3, 3 &gt; float3x3 typedef mat&lt; float, 3, 4 &gt; float3x4 typedef vec&lt; float, 4 &gt; float4 typedef mat&lt; float, 4, 1 &gt; float4x1 typedef mat&lt; float, 4, 2 &gt; float4x2 typedef mat&lt; float, 4, 3 &gt; float4x3 typedef mat&lt; float, 4, 4 &gt; float4x4 typedef vec&lt; int, 1 &gt; int1 typedef mat&lt; int, 1, 1 &gt; int1x1 typedef mat&lt; int, 1, 2 &gt; int1x2 typedef mat&lt; int, 1, 3 &gt; int1x3 typedef mat&lt; int, 1, 4 &gt; int1x4 typedef vec&lt; int, 2 &gt; int2 typedef mat&lt; int, 2, 1 &gt; int2x1 typedef mat&lt; int, 2, 2 &gt; int2x2 typedef mat&lt; int, 2, 3 &gt; int2x3 typedef mat&lt; int, 2, 4 &gt; int2x4 typedef vec&lt; int, 3 &gt; int3 typedef mat&lt; int, 3, 1 &gt; int3x1 typedef mat&lt; int, 3, 2 &gt; int3x2 typedef mat&lt; int, 3, 3 &gt; int3x3 typedef mat&lt; int, 3, 4 &gt; int3x4 typedef vec&lt; int, 4 &gt; int4 typedef mat&lt; int, 4, 1 &gt; int4x1 typedef mat&lt; int, 4, 2 &gt; int4x2 typedef mat&lt; int, 4, 3 &gt; int4x3 typedef mat&lt; int, 4, 4 &gt; int4x4 typedef vec&lt; int16_t, 1 &gt; short1 typedef vec&lt; int16_t, 2 &gt; short2 typedef vec&lt; int16_t, 3 &gt; short3 typedef vec&lt; int16_t, 4 &gt; short4 typedef vec&lt; unsigned, 1 &gt; uint1 typedef vec&lt; unsigned, 2 &gt; uint2 typedef vec&lt; unsigned, 3 &gt; uint3 typedef vec&lt; unsigned, 4 &gt; uint4 typedef vec&lt; uint16_t, 1 &gt; ushort1 typedef vec&lt; uint16_t, 2 &gt; ushort2 typedef vec&lt; uint16_t, 3 &gt; ushort3 typedef vec&lt; uint16_t, 4 &gt; ushort4"},{"location":"api/namespacelinalg_1_1aliases/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1","title":"typedef bool1","text":"<pre><code>typedef vec&lt;bool,1&gt; linalg::aliases::bool1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x1","title":"typedef bool1x1","text":"<pre><code>typedef mat&lt;bool,1,1&gt; linalg::aliases::bool1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x2","title":"typedef bool1x2","text":"<pre><code>typedef mat&lt;bool,1,2&gt; linalg::aliases::bool1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x3","title":"typedef bool1x3","text":"<pre><code>typedef mat&lt;bool,1,3&gt; linalg::aliases::bool1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x4","title":"typedef bool1x4","text":"<pre><code>typedef mat&lt;bool,1,4&gt; linalg::aliases::bool1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2","title":"typedef bool2","text":"<pre><code>typedef vec&lt;bool,2&gt; linalg::aliases::bool2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x1","title":"typedef bool2x1","text":"<pre><code>typedef mat&lt;bool,2,1&gt; linalg::aliases::bool2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x2","title":"typedef bool2x2","text":"<pre><code>typedef mat&lt;bool,2,2&gt; linalg::aliases::bool2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x3","title":"typedef bool2x3","text":"<pre><code>typedef mat&lt;bool,2,3&gt; linalg::aliases::bool2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x4","title":"typedef bool2x4","text":"<pre><code>typedef mat&lt;bool,2,4&gt; linalg::aliases::bool2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3","title":"typedef bool3","text":"<pre><code>typedef vec&lt;bool,3&gt; linalg::aliases::bool3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x1","title":"typedef bool3x1","text":"<pre><code>typedef mat&lt;bool,3,1&gt; linalg::aliases::bool3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x2","title":"typedef bool3x2","text":"<pre><code>typedef mat&lt;bool,3,2&gt; linalg::aliases::bool3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x3","title":"typedef bool3x3","text":"<pre><code>typedef mat&lt;bool,3,3&gt; linalg::aliases::bool3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x4","title":"typedef bool3x4","text":"<pre><code>typedef mat&lt;bool,3,4&gt; linalg::aliases::bool3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4","title":"typedef bool4","text":"<pre><code>typedef vec&lt;bool,4&gt; linalg::aliases::bool4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x1","title":"typedef bool4x1","text":"<pre><code>typedef mat&lt;bool,4,1&gt; linalg::aliases::bool4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x2","title":"typedef bool4x2","text":"<pre><code>typedef mat&lt;bool,4,2&gt; linalg::aliases::bool4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x3","title":"typedef bool4x3","text":"<pre><code>typedef mat&lt;bool,4,3&gt; linalg::aliases::bool4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x4","title":"typedef bool4x4","text":"<pre><code>typedef mat&lt;bool,4,4&gt; linalg::aliases::bool4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte1","title":"typedef byte1","text":"<pre><code>typedef vec&lt;uint8_t,1&gt; linalg::aliases::byte1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte2","title":"typedef byte2","text":"<pre><code>typedef vec&lt;uint8_t,2&gt; linalg::aliases::byte2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte3","title":"typedef byte3","text":"<pre><code>typedef vec&lt;uint8_t,3&gt; linalg::aliases::byte3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte4","title":"typedef byte4","text":"<pre><code>typedef vec&lt;uint8_t,4&gt; linalg::aliases::byte4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1","title":"typedef double1","text":"<pre><code>typedef vec&lt;double,1&gt; linalg::aliases::double1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x1","title":"typedef double1x1","text":"<pre><code>typedef mat&lt;double,1,1&gt; linalg::aliases::double1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x2","title":"typedef double1x2","text":"<pre><code>typedef mat&lt;double,1,2&gt; linalg::aliases::double1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x3","title":"typedef double1x3","text":"<pre><code>typedef mat&lt;double,1,3&gt; linalg::aliases::double1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x4","title":"typedef double1x4","text":"<pre><code>typedef mat&lt;double,1,4&gt; linalg::aliases::double1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2","title":"typedef double2","text":"<pre><code>typedef vec&lt;double,2&gt; linalg::aliases::double2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x1","title":"typedef double2x1","text":"<pre><code>typedef mat&lt;double,2,1&gt; linalg::aliases::double2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x2","title":"typedef double2x2","text":"<pre><code>typedef mat&lt;double,2,2&gt; linalg::aliases::double2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x3","title":"typedef double2x3","text":"<pre><code>typedef mat&lt;double,2,3&gt; linalg::aliases::double2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x4","title":"typedef double2x4","text":"<pre><code>typedef mat&lt;double,2,4&gt; linalg::aliases::double2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3","title":"typedef double3","text":"<pre><code>typedef vec&lt;double,3&gt; linalg::aliases::double3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x1","title":"typedef double3x1","text":"<pre><code>typedef mat&lt;double,3,1&gt; linalg::aliases::double3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x2","title":"typedef double3x2","text":"<pre><code>typedef mat&lt;double,3,2&gt; linalg::aliases::double3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x3","title":"typedef double3x3","text":"<pre><code>typedef mat&lt;double,3,3&gt; linalg::aliases::double3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x4","title":"typedef double3x4","text":"<pre><code>typedef mat&lt;double,3,4&gt; linalg::aliases::double3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4","title":"typedef double4","text":"<pre><code>typedef vec&lt;double,4&gt; linalg::aliases::double4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x1","title":"typedef double4x1","text":"<pre><code>typedef mat&lt;double,4,1&gt; linalg::aliases::double4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x2","title":"typedef double4x2","text":"<pre><code>typedef mat&lt;double,4,2&gt; linalg::aliases::double4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x3","title":"typedef double4x3","text":"<pre><code>typedef mat&lt;double,4,3&gt; linalg::aliases::double4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x4","title":"typedef double4x4","text":"<pre><code>typedef mat&lt;double,4,4&gt; linalg::aliases::double4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1","title":"typedef float1","text":"<pre><code>typedef vec&lt;float,1&gt; linalg::aliases::float1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x1","title":"typedef float1x1","text":"<pre><code>typedef mat&lt;float,1,1&gt; linalg::aliases::float1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x2","title":"typedef float1x2","text":"<pre><code>typedef mat&lt;float,1,2&gt; linalg::aliases::float1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x3","title":"typedef float1x3","text":"<pre><code>typedef mat&lt;float,1,3&gt; linalg::aliases::float1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x4","title":"typedef float1x4","text":"<pre><code>typedef mat&lt;float,1,4&gt; linalg::aliases::float1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2","title":"typedef float2","text":"<pre><code>typedef vec&lt;float,2&gt; linalg::aliases::float2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x1","title":"typedef float2x1","text":"<pre><code>typedef mat&lt;float,2,1&gt; linalg::aliases::float2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x2","title":"typedef float2x2","text":"<pre><code>typedef mat&lt;float,2,2&gt; linalg::aliases::float2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x3","title":"typedef float2x3","text":"<pre><code>typedef mat&lt;float,2,3&gt; linalg::aliases::float2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x4","title":"typedef float2x4","text":"<pre><code>typedef mat&lt;float,2,4&gt; linalg::aliases::float2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3","title":"typedef float3","text":"<pre><code>typedef vec&lt;float,3&gt; linalg::aliases::float3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x1","title":"typedef float3x1","text":"<pre><code>typedef mat&lt;float,3,1&gt; linalg::aliases::float3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x2","title":"typedef float3x2","text":"<pre><code>typedef mat&lt;float,3,2&gt; linalg::aliases::float3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x3","title":"typedef float3x3","text":"<pre><code>typedef mat&lt;float,3,3&gt; linalg::aliases::float3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x4","title":"typedef float3x4","text":"<pre><code>typedef mat&lt;float,3,4&gt; linalg::aliases::float3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4","title":"typedef float4","text":"<pre><code>typedef vec&lt;float,4&gt; linalg::aliases::float4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x1","title":"typedef float4x1","text":"<pre><code>typedef mat&lt;float,4,1&gt; linalg::aliases::float4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x2","title":"typedef float4x2","text":"<pre><code>typedef mat&lt;float,4,2&gt; linalg::aliases::float4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x3","title":"typedef float4x3","text":"<pre><code>typedef mat&lt;float,4,3&gt; linalg::aliases::float4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x4","title":"typedef float4x4","text":"<pre><code>typedef mat&lt;float,4,4&gt; linalg::aliases::float4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1","title":"typedef int1","text":"<pre><code>typedef vec&lt;int,1&gt; linalg::aliases::int1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x1","title":"typedef int1x1","text":"<pre><code>typedef mat&lt;int,1,1&gt; linalg::aliases::int1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x2","title":"typedef int1x2","text":"<pre><code>typedef mat&lt;int,1,2&gt; linalg::aliases::int1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x3","title":"typedef int1x3","text":"<pre><code>typedef mat&lt;int,1,3&gt; linalg::aliases::int1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x4","title":"typedef int1x4","text":"<pre><code>typedef mat&lt;int,1,4&gt; linalg::aliases::int1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2","title":"typedef int2","text":"<pre><code>typedef vec&lt;int,2&gt; linalg::aliases::int2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x1","title":"typedef int2x1","text":"<pre><code>typedef mat&lt;int,2,1&gt; linalg::aliases::int2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x2","title":"typedef int2x2","text":"<pre><code>typedef mat&lt;int,2,2&gt; linalg::aliases::int2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x3","title":"typedef int2x3","text":"<pre><code>typedef mat&lt;int,2,3&gt; linalg::aliases::int2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x4","title":"typedef int2x4","text":"<pre><code>typedef mat&lt;int,2,4&gt; linalg::aliases::int2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3","title":"typedef int3","text":"<pre><code>typedef vec&lt;int,3&gt; linalg::aliases::int3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x1","title":"typedef int3x1","text":"<pre><code>typedef mat&lt;int,3,1&gt; linalg::aliases::int3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x2","title":"typedef int3x2","text":"<pre><code>typedef mat&lt;int,3,2&gt; linalg::aliases::int3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x3","title":"typedef int3x3","text":"<pre><code>typedef mat&lt;int,3,3&gt; linalg::aliases::int3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x4","title":"typedef int3x4","text":"<pre><code>typedef mat&lt;int,3,4&gt; linalg::aliases::int3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4","title":"typedef int4","text":"<pre><code>typedef vec&lt;int,4&gt; linalg::aliases::int4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x1","title":"typedef int4x1","text":"<pre><code>typedef mat&lt;int,4,1&gt; linalg::aliases::int4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x2","title":"typedef int4x2","text":"<pre><code>typedef mat&lt;int,4,2&gt; linalg::aliases::int4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x3","title":"typedef int4x3","text":"<pre><code>typedef mat&lt;int,4,3&gt; linalg::aliases::int4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x4","title":"typedef int4x4","text":"<pre><code>typedef mat&lt;int,4,4&gt; linalg::aliases::int4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short1","title":"typedef short1","text":"<pre><code>typedef vec&lt;int16_t,1&gt; linalg::aliases::short1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short2","title":"typedef short2","text":"<pre><code>typedef vec&lt;int16_t,2&gt; linalg::aliases::short2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short3","title":"typedef short3","text":"<pre><code>typedef vec&lt;int16_t,3&gt; linalg::aliases::short3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short4","title":"typedef short4","text":"<pre><code>typedef vec&lt;int16_t,4&gt; linalg::aliases::short4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint1","title":"typedef uint1","text":"<pre><code>typedef vec&lt;unsigned,1&gt; linalg::aliases::uint1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint2","title":"typedef uint2","text":"<pre><code>typedef vec&lt;unsigned,2&gt; linalg::aliases::uint2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint3","title":"typedef uint3","text":"<pre><code>typedef vec&lt;unsigned,3&gt; linalg::aliases::uint3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint4","title":"typedef uint4","text":"<pre><code>typedef vec&lt;unsigned,4&gt; linalg::aliases::uint4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort1","title":"typedef ushort1","text":"<pre><code>typedef vec&lt;uint16_t,1&gt; linalg::aliases::ushort1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort2","title":"typedef ushort2","text":"<pre><code>typedef vec&lt;uint16_t,2&gt; linalg::aliases::ushort2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort3","title":"typedef ushort3","text":"<pre><code>typedef vec&lt;uint16_t,3&gt; linalg::aliases::ushort3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort4","title":"typedef ushort4","text":"<pre><code>typedef vec&lt;uint16_t,4&gt; linalg::aliases::ushort4;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter/","title":"Struct linalg::converter","text":"<p>template &lt;class T, class U&gt;</p> <p>ClassList &gt; linalg &gt; converter</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 1, 1 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 1, 1 &gt; linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 2, 2 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 2, 2 &gt; linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 3, 3 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 3, 3 &gt; linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 4, 4 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 4, 4 &gt; linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 1 &gt; operator() (const vec&lt; T, 1 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 1 &gt; linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::operator() (\n    const vec&lt; T, 1 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 2 &gt; operator() (const vec&lt; T, 2 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 2 &gt; linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::operator() (\n    const vec&lt; T, 2 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 3 &gt; operator() (const vec&lt; T, 3 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 3 &gt; linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::operator() (\n    const vec&lt; T, 3 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 4 &gt; operator() (const vec&lt; T, 4 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 4 &gt; linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::operator() (\n    const vec&lt; T, 4 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 1 &gt; operator() (const std::array&lt; T, 1 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 1 &gt; linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;::operator() (\n    const std::array&lt; T, 1 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 2 &gt; operator() (const std::array&lt; T, 2 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 2 &gt; linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;::operator() (\n    const std::array&lt; T, 2 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 3 &gt; operator() (const std::array&lt; T, 3 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 3 &gt; linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;::operator() (\n    const std::array&lt; T, 3 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 4 &gt; operator() (const std::array&lt; T, 4 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 4 &gt; linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;::operator() (\n    const std::array&lt; T, 4 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1detail/","title":"Namespace linalg::detail","text":"<p>Namespace List &gt; linalg &gt; detail</p>"},{"location":"api/namespacelinalg_1_1detail/#classes","title":"Classes","text":"Type Name struct any_compare &lt;class A, class B&gt; struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct apply &lt;class F, class Void, T&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; &lt;class F, M, N, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; &lt;class F, M, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; &lt;class F, A&gt; struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct clamp struct empty struct getter &lt;I&gt; struct getter&lt; 0 &gt; &lt;&gt; struct getter&lt; 1 &gt; &lt;&gt; struct getter&lt; 2 &gt; &lt;&gt; struct getter&lt; 3 &gt; &lt;&gt; struct lerp struct make_seq_impl &lt;A, N&gt; struct make_seq_impl&lt; A, 0 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 1 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 2 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 3 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 4 &gt; &lt;A&gt; struct max struct min struct op_add struct op_and struct op_cmp struct op_div struct op_eq struct op_ge struct op_gt struct op_int struct op_le struct op_lsh struct op_lt struct op_mod struct op_mul struct op_ne struct op_neg struct op_not struct op_or struct op_pos struct op_rsh struct op_sub struct op_un struct op_xor struct ord &lt;class T&gt; struct scalar_type &lt;class A&gt; struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; &lt;class T, M, N&gt; struct scalar_type&lt; vec&lt; T, M &gt; &gt; &lt;class T, M&gt; struct scalars &lt;T&gt; struct scalars&lt; T, U... &gt; &lt;class T, U&gt; struct scalars&lt;&gt; &lt;&gt; struct select struct seq &lt;I&gt; struct std_abs struct std_acos struct std_asin struct std_atan struct std_atan2 struct std_ceil struct std_copysign struct std_cos struct std_cosh struct std_exp struct std_floor struct std_fmod struct std_log struct std_log10 struct std_pow struct std_round struct std_sin struct std_sinh struct std_sqrt struct std_tan struct std_tanh"},{"location":"api/namespacelinalg_1_1detail/#public-types","title":"Public Types","text":"Type Name typedef typename std::enable_if&lt;!std::is_same&lt; T, U &gt;::value, decltype(converter&lt; T, U &gt;{}(std::declval&lt; U &gt;()))&gt;::type conv_t typedef typename make_seq_impl&lt; A, B-A &gt;::type make_seq typedef decltype(std::declval&lt; F &gt;()(std::declval&lt; T &gt;()...)) ret_t typedef typename scalars&lt; T... &gt;::type scalars_t"},{"location":"api/namespacelinalg_1_1detail/#public-functions","title":"Public Functions","text":"Type Name constexpr bool operator!= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&lt; (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&lt;= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator== (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&gt; (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&gt;= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  vec&lt; T, sizeof...(I)&gt; constexpr swizzle (const vec&lt; T, M &gt; &amp; v, seq&lt; I... &gt;)  mat&lt; T, sizeof...(I), sizeof...(J)&gt; constexpr swizzle (const mat&lt; T, M, N &gt; &amp; m, seq&lt; I... &gt; i, seq&lt; J... &gt;)"},{"location":"api/namespacelinalg_1_1detail/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg_1_1detail/#typedef-conv_t","title":"typedef conv_t","text":"<pre><code>using linalg::detail::conv_t = typedef typename std::enable_if&lt;!std::is_same&lt;T,U&gt;::value, decltype(converter&lt;T,U&gt;{}(std::declval&lt;U&gt;()))&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-make_seq","title":"typedef make_seq","text":"<pre><code>using linalg::detail::make_seq = typedef typename make_seq_impl&lt;A,B-A&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-ret_t","title":"typedef ret_t","text":"<pre><code>using linalg::detail::ret_t = typedef decltype(std::declval&lt;F&gt;()(std::declval&lt;T&gt;()...));\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-scalars_t","title":"typedef scalars_t","text":"<pre><code>using linalg::detail::scalars_t = typedef typename scalars&lt;T...&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg_1_1detail/#function-operator","title":"function operator!=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator!= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_1","title":"function operator&lt;","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&lt; (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_2","title":"function operator&lt;=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&lt;= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_3","title":"function operator==","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator== (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_4","title":"function operator&gt;","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&gt; (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_5","title":"function operator&gt;=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&gt;= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-swizzle","title":"function swizzle","text":"<pre><code>template&lt;class T, int M, int... I&gt;\nvec&lt; T, sizeof...(I)&gt; constexpr linalg::detail::swizzle (\n    const vec&lt; T, M &gt; &amp; v,\n    seq&lt; I... &gt;\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-swizzle_1","title":"function swizzle","text":"<pre><code>template&lt;class T, int M, int N, int... I, int... J&gt;\nmat&lt; T, sizeof...(I), sizeof...(J)&gt; constexpr linalg::detail::swizzle (\n    const mat&lt; T, M, N &gt; &amp; m,\n    seq&lt; I... &gt; i,\n    seq&lt; J... &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare/","title":"Struct linalg::detail::any_compare","text":"<p>template &lt;class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 1 &gt; &amp; a, const mat&lt; T, M, 1 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;::operator() (\n    const mat&lt; T, M, 1 &gt; &amp; a,\n    const mat&lt; T, M, 1 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 2 &gt; &amp; a, const mat&lt; T, M, 2 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;::operator() (\n    const mat&lt; T, M, 2 &gt; &amp; a,\n    const mat&lt; T, M, 2 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 3 &gt; &amp; a, const mat&lt; T, M, 3 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;::operator() (\n    const mat&lt; T, M, 3 &gt; &amp; a,\n    const mat&lt; T, M, 3 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 4 &gt; &amp; a, const mat&lt; T, M, 4 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;::operator() (\n    const mat&lt; T, M, 4 &gt; &amp; a,\n    const mat&lt; T, M, 4 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 1 &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::operator() (\n    const vec&lt; T, 1 &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::operator() (\n    const vec&lt; T, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::operator() (\n    const vec&lt; T, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::operator() (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply/","title":"Struct linalg::detail::apply","text":"<p>template &lt;class F, class Void, class... T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#enum-apply-f-scalars_t-mat-a-m-n","title":"enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A &gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a, const mat&lt; B, M, N &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#enum-apply-f-scalars_t-mat-a-m-n-mat-b-m-n","title":"enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a,\n    const mat&lt; B, M, N &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#enum-apply-f-scalars_t-vec-a-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#enum-apply-f-scalars_t-vec-a-m-vec-b-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#enum-apply-f-scalars_t-vec-a-m-vec-b-m-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, A a, const mat&lt; B, M, N &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#enum-apply-f-scalars_t-a-a-mat-b-m-n","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    A a,\n    const mat&lt; B, M, N &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#enum-apply-f-scalars_t-a-a-vec-b-m","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#enum-apply-f-scalars_t-a-a-vec-b-m-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, B b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#enum-apply-f-scalars_t-a-b-a-b-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    B b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#enum-apply-f-scalars_t-a-c-a-vec-b-m-c","title":"enum apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;","text":"<p>template &lt;class F, class... A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; typedef ret_t&lt; F, A... &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt;&gt;, F f, A... a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#enum-apply-f-scalars_t-a-a","title":"enum apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; {\n    size =0\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::type =  ret_t&lt;F,A...&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#function-impl","title":"function impl","text":"<pre><code>static inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::impl (\n    seq&lt;&gt;,\n    F f,\n    A... a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a, B b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#enum-apply-f-scalars_t-b-mat-a-m-n-b","title":"enum apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a,\n    B b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#enum-apply-f-scalars_t-b-vec-a-m-b","title":"enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#enum-apply-f-scalars_t-b-vec-a-m-b-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#enum-apply-f-scalars_t-b-c-vec-a-m-b-c","title":"enum apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#enum-apply-f-scalars_t-c-vec-a-m-vec-b-m-c","title":"enum apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1clamp/","title":"Struct linalg::detail::clamp","text":"<p>ClassList &gt; linalg &gt; detail &gt; clamp</p>"},{"location":"api/structlinalg_1_1detail_1_1clamp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1clamp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1clamp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::clamp::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1empty/","title":"Struct linalg::detail::empty","text":"<p>ClassList &gt; linalg &gt; detail &gt; empty</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter/","title":"Struct linalg::detail::getter","text":"<p>template &lt;int I&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/","title":"Struct linalg::detail::getter&lt; 0 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 0 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 0 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/","title":"Struct linalg::detail::getter&lt; 1 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 1 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 1 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/","title":"Struct linalg::detail::getter&lt; 2 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 2 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 2 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/","title":"Struct linalg::detail::getter&lt; 3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 3 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 3 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1lerp/","title":"Struct linalg::detail::lerp","text":"<p>ClassList &gt; linalg &gt; detail &gt; lerp</p>"},{"location":"api/structlinalg_1_1detail_1_1lerp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1lerp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1lerp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::lerp::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl/","title":"Struct linalg::detail::make_seq_impl","text":"<p>template &lt;int A, int N&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 0 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 0 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt;&gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 0 &gt;::type =  seq&lt;&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 1 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 1 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 1 &gt;::type =  seq&lt;A+0&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 2 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 2 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 2 &gt;::type =  seq&lt;A+0,A+1&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 3 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 3 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1, A+2 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 3 &gt;::type =  seq&lt;A+0,A+1,A+2&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 4 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 4 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1, A+2, A+3 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 4 &gt;::type =  seq&lt;A+0,A+1,A+2,A+3&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1max/","title":"Struct linalg::detail::max","text":"<p>ClassList &gt; linalg &gt; detail &gt; max</p>"},{"location":"api/structlinalg_1_1detail_1_1max/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1max/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1max/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::max::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1min/","title":"Struct linalg::detail::min","text":"<p>ClassList &gt; linalg &gt; detail &gt; min</p>"},{"location":"api/structlinalg_1_1detail_1_1min/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1min/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1min/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::min::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__add/","title":"Struct linalg::detail::op_add","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_add</p>"},{"location":"api/structlinalg_1_1detail_1_1op__add/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__add/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__add/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_add::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__and/","title":"Struct linalg::detail::op_and","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_and</p>"},{"location":"api/structlinalg_1_1detail_1_1op__and/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__and/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__and/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_and::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/","title":"Struct linalg::detail::op_cmp","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_cmp</p>"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_cmp::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__div/","title":"Struct linalg::detail::op_div","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_div</p>"},{"location":"api/structlinalg_1_1detail_1_1op__div/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__div/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__div/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_div::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__eq/","title":"Struct linalg::detail::op_eq","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_eq</p>"},{"location":"api/structlinalg_1_1detail_1_1op__eq/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__eq/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__eq/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_eq::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__ge/","title":"Struct linalg::detail::op_ge","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_ge</p>"},{"location":"api/structlinalg_1_1detail_1_1op__ge/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__ge/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__ge/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_ge::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__gt/","title":"Struct linalg::detail::op_gt","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_gt</p>"},{"location":"api/structlinalg_1_1detail_1_1op__gt/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__gt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__gt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_gt::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__int/","title":"Struct linalg::detail::op_int","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_int</p>"},{"location":"api/structlinalg_1_1detail_1_1op__int/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__int/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__int/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_int::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__le/","title":"Struct linalg::detail::op_le","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_le</p>"},{"location":"api/structlinalg_1_1detail_1_1op__le/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__le/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__le/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_le::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/","title":"Struct linalg::detail::op_lsh","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_lsh</p>"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_lsh::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__lt/","title":"Struct linalg::detail::op_lt","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_lt</p>"},{"location":"api/structlinalg_1_1detail_1_1op__lt/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__lt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__lt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_lt::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__mod/","title":"Struct linalg::detail::op_mod","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_mod</p>"},{"location":"api/structlinalg_1_1detail_1_1op__mod/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__mod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__mod/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_mod::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__mul/","title":"Struct linalg::detail::op_mul","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_mul</p>"},{"location":"api/structlinalg_1_1detail_1_1op__mul/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__mul/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__mul/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_mul::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__ne/","title":"Struct linalg::detail::op_ne","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_ne</p>"},{"location":"api/structlinalg_1_1detail_1_1op__ne/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__ne/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__ne/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_ne::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__neg/","title":"Struct linalg::detail::op_neg","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_neg</p>"},{"location":"api/structlinalg_1_1detail_1_1op__neg/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__neg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__neg/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_neg::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__not/","title":"Struct linalg::detail::op_not","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_not</p>"},{"location":"api/structlinalg_1_1detail_1_1op__not/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__not/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__not/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_not::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__or/","title":"Struct linalg::detail::op_or","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_or</p>"},{"location":"api/structlinalg_1_1detail_1_1op__or/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__or/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__or/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_or::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__pos/","title":"Struct linalg::detail::op_pos","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_pos</p>"},{"location":"api/structlinalg_1_1detail_1_1op__pos/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__pos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__pos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_pos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/","title":"Struct linalg::detail::op_rsh","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_rsh</p>"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_rsh::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__sub/","title":"Struct linalg::detail::op_sub","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_sub</p>"},{"location":"api/structlinalg_1_1detail_1_1op__sub/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__sub/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__sub/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_sub::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__un/","title":"Struct linalg::detail::op_un","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_un</p>"},{"location":"api/structlinalg_1_1detail_1_1op__un/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__un/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__un/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_un::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__xor/","title":"Struct linalg::detail::op_xor","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_xor</p>"},{"location":"api/structlinalg_1_1detail_1_1op__xor/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__xor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__xor/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_xor::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1ord/","title":"Struct linalg::detail::ord","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; ord</p>"},{"location":"api/structlinalg_1_1detail_1_1ord/#public-attributes","title":"Public Attributes","text":"Type Name T a T b"},{"location":"api/structlinalg_1_1detail_1_1ord/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1ord/#variable-a","title":"variable a","text":"<pre><code>T linalg::detail::ord&lt; T &gt;::a;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1ord/#variable-b","title":"variable b","text":"<pre><code>T linalg::detail::ord&lt; T &gt;::b;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type/","title":"Struct linalg::detail::scalar_type","text":"<p>template &lt;class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;","text":"<p>template &lt;class T, int M, int N&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type&lt; mat&lt; T, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/","title":"Struct linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type&lt; vec&lt; T, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars/","title":"Struct linalg::detail::scalars","text":"<p>template &lt;class... T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_01T_00_01U_8_8_8_01_4/","title":"Struct linalg::detail::scalars&lt; T, U... &gt;","text":"<p>template &lt;class T, class... U&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars&lt; T, U... &gt;</p> <p>Inherits the following classes: std::conditional::type</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/","title":"Struct linalg::detail::scalars&lt;&gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars&lt;&gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#public-types","title":"Public Types","text":"Type Name typedef void type"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalars&lt;&gt;::type =  void;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1select/","title":"Struct linalg::detail::select","text":"<p>ClassList &gt; linalg &gt; detail &gt; select</p>"},{"location":"api/structlinalg_1_1detail_1_1select/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1select/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1select/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::select::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1seq/","title":"Struct linalg::detail::seq","text":"<p>template &lt;int... I&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; seq</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__abs/","title":"Struct linalg::detail::std_abs","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_abs</p>"},{"location":"api/structlinalg_1_1detail_1_1std__abs/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__abs/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__abs/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_abs::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__acos/","title":"Struct linalg::detail::std_acos","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_acos</p>"},{"location":"api/structlinalg_1_1detail_1_1std__acos/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__acos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__acos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_acos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__asin/","title":"Struct linalg::detail::std_asin","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_asin</p>"},{"location":"api/structlinalg_1_1detail_1_1std__asin/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__asin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__asin/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_asin::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan/","title":"Struct linalg::detail::std_atan","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_atan</p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__atan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__atan/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_atan::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/","title":"Struct linalg::detail::std_atan2","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_atan2</p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_atan2::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/","title":"Struct linalg::detail::std_ceil","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_ceil</p>"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_ceil::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/","title":"Struct linalg::detail::std_copysign","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_copysign</p>"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_copysign::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__cos/","title":"Struct linalg::detail::std_cos","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_cos</p>"},{"location":"api/structlinalg_1_1detail_1_1std__cos/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__cos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__cos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_cos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/","title":"Struct linalg::detail::std_cosh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_cosh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_cosh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__exp/","title":"Struct linalg::detail::std_exp","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_exp</p>"},{"location":"api/structlinalg_1_1detail_1_1std__exp/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__exp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__exp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_exp::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__floor/","title":"Struct linalg::detail::std_floor","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_floor</p>"},{"location":"api/structlinalg_1_1detail_1_1std__floor/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__floor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__floor/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_floor::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/","title":"Struct linalg::detail::std_fmod","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_fmod</p>"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_fmod::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__log/","title":"Struct linalg::detail::std_log","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_log</p>"},{"location":"api/structlinalg_1_1detail_1_1std__log/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__log/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__log/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_log::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__log10/","title":"Struct linalg::detail::std_log10","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_log10</p>"},{"location":"api/structlinalg_1_1detail_1_1std__log10/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__log10/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__log10/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_log10::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__pow/","title":"Struct linalg::detail::std_pow","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_pow</p>"},{"location":"api/structlinalg_1_1detail_1_1std__pow/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__pow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__pow/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_pow::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__round/","title":"Struct linalg::detail::std_round","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_round</p>"},{"location":"api/structlinalg_1_1detail_1_1std__round/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__round/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__round/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_round::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sin/","title":"Struct linalg::detail::std_sin","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sin</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sin/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sin/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sin::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/","title":"Struct linalg::detail::std_sinh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sinh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sinh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/","title":"Struct linalg::detail::std_sqrt","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sqrt</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sqrt::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__tan/","title":"Struct linalg::detail::std_tan","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_tan</p>"},{"location":"api/structlinalg_1_1detail_1_1std__tan/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__tan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__tan/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_tan::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/","title":"Struct linalg::detail::std_tanh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_tanh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_tanh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1identity__t/","title":"Struct linalg::identity_t","text":"<p>ClassList &gt; linalg &gt; identity_t</p>"},{"location":"api/structlinalg_1_1identity__t/#public-functions","title":"Public Functions","text":"Type Name constexpr identity_t (int)"},{"location":"api/structlinalg_1_1identity__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1identity__t/#function-identity_t","title":"function identity_t","text":"<pre><code>inline explicit constexpr linalg::identity_t::identity_t (\n    int\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat/","title":"Struct linalg::mat","text":"<p>template &lt;class T, int M, int N&gt;</p> <p>ClassList &gt; linalg &gt; mat</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/","title":"Struct linalg::mat&lt; T, M, 1 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 1 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 1 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int) const LINALG_CONSTEXPR14 V &amp; operator[] (int)  constexpr vec&lt; T, 1 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 1 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 1 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 1 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const V &amp; x_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const mat&lt; U, M, 1 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 1 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 1 &gt;::operator[] (\n    int\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 1 &gt;::operator[] (\n    int\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 1 &gt; linalg::mat&lt; T, M, 1 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/","title":"Struct linalg::mat&lt; T, M, 2 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 2 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x V y"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 2 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 2 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 2 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 2 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 2 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 2 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const mat&lt; U, M, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 2 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 2 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 2 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 2 &gt; linalg::mat&lt; T, M, 2 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/","title":"Struct linalg::mat&lt; T, M, 3 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 3 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x V y V z"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_, const V &amp; z_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 3 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 3 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 3 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-z","title":"variable z","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 3 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_,\n    const V &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const mat&lt; U, M, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 3 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 3 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 3 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 3 &gt; linalg::mat&lt; T, M, 3 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/","title":"Struct linalg::mat&lt; T, M, 4 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 4 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V w V x V y V z"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_, const V &amp; z_, const V &amp; w_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 4 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 4 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 4 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-w","title":"variable w","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::w;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-z","title":"variable z","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 4 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_,\n    const V &amp; z_,\n    const V &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const mat&lt; U, M, 4 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 4 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 4 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 4 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 4 &gt; linalg::mat&lt; T, M, 4 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1ostream__overloads/","title":"Namespace linalg::ostream_overloads","text":"<p>Namespace List &gt; linalg &gt; ostream_overloads</p>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#public-functions","title":"Public Functions","text":"Type Name std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 1 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 2 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 3 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 4 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 1 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 2 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 3 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 4 &gt; &amp; m)"},{"location":"api/namespacelinalg_1_1ostream__overloads/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 1 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 4 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 1 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_5","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_6","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_7","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 4 &gt; &amp; m\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec/","title":"Struct linalg::vec","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; vec</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/","title":"Struct linalg::vec&lt; T, 1 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 1 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int) const LINALG_CONSTEXPR14 T &amp; operator[] (int)  constexpr vec ()  constexpr vec (const T &amp; x_)  constexpr vec (const vec&lt; U, 1 &gt; &amp; v)  constexpr vec (const U &amp; u)"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 1 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 1 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 1 &gt;::operator[] (\n    int\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 1 &gt;::operator[] (\n    int\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-14","title":"function vec [1/4]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 1 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-24","title":"function vec [2/4]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const T &amp; x_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-34","title":"function vec [3/4]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const vec&lt; U, 1 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-44","title":"function vec [4/4]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const U &amp; u\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/","title":"Struct linalg::vec&lt; T, 2 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 2 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x T y"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 2 &gt; &amp; v)  constexpr vec (const U &amp; u)"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 2 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 2 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 2 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 2 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 2 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-16","title":"function vec [1/6]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 2 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-26","title":"function vec [2/6]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-36","title":"function vec [3/6]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-46","title":"function vec [4/6]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-56","title":"function vec [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const vec&lt; U, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-66","title":"function vec [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const U &amp; u\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/","title":"Struct linalg::vec&lt; T, 3 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 3 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x T y T z"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_, const T &amp; z_)  constexpr vec (const vec&lt; T, 2 &gt; &amp; xy, const T &amp; z_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 3 &gt; &amp; v)  constexpr vec (const U &amp; u)  constexpr const vec&lt; T, 2 &gt; &amp; xy () const vec&lt; T, 2 &gt; &amp; xy ()"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-z","title":"variable z","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 3 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 3 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 3 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-17","title":"function vec [1/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-27","title":"function vec [2/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_,\n    const T &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-37","title":"function vec [3/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const vec&lt; T, 2 &gt; &amp; xy,\n    const T &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-47","title":"function vec [4/7]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-57","title":"function vec [5/7]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-67","title":"function vec [6/7]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const vec&lt; U, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-77","title":"function vec [7/7]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-xy-12","title":"function xy [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 3 &gt;::xy () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-xy-22","title":"function xy [2/2]","text":"<pre><code>inline vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 3 &gt;::xy () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/","title":"Struct linalg::vec&lt; T, 4 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 4 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T w T x T y T z"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_, const T &amp; z_, const T &amp; w_)  constexpr vec (const vec&lt; T, 2 &gt; &amp; xy, const T &amp; z_, const T &amp; w_)  constexpr vec (const vec&lt; T, 3 &gt; &amp; xyz, const T &amp; w_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 4 &gt; &amp; v)  constexpr vec (const U &amp; u)  constexpr const vec&lt; T, 2 &gt; &amp; xy () const vec&lt; T, 2 &gt; &amp; xy ()  constexpr const vec&lt; T, 3 &gt; &amp; xyz () const vec&lt; T, 3 &gt; &amp; xyz ()"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-w","title":"variable w","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::w;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-z","title":"variable z","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 4 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 4 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 4 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-18","title":"function vec [1/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-28","title":"function vec [2/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_,\n    const T &amp; z_,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-38","title":"function vec [3/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; T, 2 &gt; &amp; xy,\n    const T &amp; z_,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-48","title":"function vec [4/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; T, 3 &gt; &amp; xyz,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-58","title":"function vec [5/8]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-68","title":"function vec [6/8]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-78","title":"function vec [7/8]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; U, 4 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-88","title":"function vec [8/8]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xy-12","title":"function xy [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xy () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xy-22","title":"function xy [2/2]","text":"<pre><code>inline vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xy () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xyz-12","title":"function xyz [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 3 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xyz () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xyz-22","title":"function xyz [2/2]","text":"<pre><code>inline vec&lt; T, 3 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xyz () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/classpose__prediction/","title":"Class pose_prediction","text":"<p>ClassList &gt; pose_prediction</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classpose__prediction/#public-functions","title":"Public Functions","text":"Type Name virtual pose_type correct_pose (const pose_type pose) const = 0 virtual bool fast_pose_reliable () const = 0 virtual fast_pose_type get_fast_pose () const = 0 virtual fast_pose_type get_fast_pose (time_type future_time) const = 0 virtual Eigen::Quaternionf get_offset () = 0 virtual pose_type get_true_pose () const = 0 virtual void set_offset (const Eigen::Quaternionf &amp; orientation) = 0 virtual bool true_pose_reliable () const = 0 virtual ~pose_prediction ()"},{"location":"api/classpose__prediction/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classpose__prediction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classpose__prediction/#function-correct_pose","title":"function correct_pose","text":"<pre><code>virtual pose_type pose_prediction::correct_pose (\n    const pose_type pose\n) const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<pre><code>virtual bool pose_prediction::fast_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_fast_pose-12","title":"function get_fast_pose [1/2]","text":"<pre><code>virtual fast_pose_type pose_prediction::get_fast_pose () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_fast_pose-22","title":"function get_fast_pose [2/2]","text":"<pre><code>virtual fast_pose_type pose_prediction::get_fast_pose (\n    time_type future_time\n) const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_offset","title":"function get_offset","text":"<pre><code>virtual Eigen::Quaternionf pose_prediction::get_offset () = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_true_pose","title":"function get_true_pose","text":"<pre><code>virtual pose_type pose_prediction::get_true_pose () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-set_offset","title":"function set_offset","text":"<pre><code>virtual void pose_prediction::set_offset (\n    const Eigen::Quaternionf &amp; orientation\n) = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<pre><code>virtual bool pose_prediction::true_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-pose_prediction","title":"function ~pose_prediction","text":"<pre><code>inline virtual pose_prediction::~pose_prediction () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/pose_prediction.hpp</code></p>"},{"location":"api/classprint__timer/","title":"Class print_timer","text":"<p>template &lt;typename now_fn, typename time_point, typename duration&gt;</p> <p>ClassList &gt; print_timer</p> <p>Like timer, but prints the output. More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classprint__timer/#public-functions","title":"Public Functions","text":"Type Name print_timer (const std::string &amp; name, const now_fn &amp; now)"},{"location":"api/classprint__timer/#detailed-description","title":"Detailed Description","text":"<p>See PRINT_CPU_TIME_FOR_THIS_BLOCK(name) </p>"},{"location":"api/classprint__timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer/#function-print_timer","title":"function print_timer","text":"<pre><code>inline print_timer::print_timer (\n    const std::string &amp; name,\n    const now_fn &amp; now\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer2/","title":"Class print_timer2","text":"<p>ClassList &gt; print_timer2</p>"},{"location":"api/classprint__timer2/#public-functions","title":"Public Functions","text":"Type Name print_timer2 (std::string name_)  ~print_timer2 ()"},{"location":"api/classprint__timer2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer2/#function-print_timer2","title":"function print_timer2","text":"<pre><code>inline print_timer2::print_timer2 (\n    std::string name_\n) \n</code></pre>"},{"location":"api/classprint__timer2/#function-print_timer2_1","title":"function ~print_timer2","text":"<pre><code>inline print_timer2::~print_timer2 () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer_1_1print__in__destructor/","title":"Class print_timer::print_in_destructor","text":"<p>ClassList &gt; print_in_destructor</p>"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions","title":"Public Functions","text":"Type Name print_in_destructor (const std::string &amp; account_name, const duration &amp; _duration)  ~print_in_destructor ()"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor","title":"function print_in_destructor","text":"<pre><code>inline print_in_destructor::print_in_destructor (\n    const std::string &amp; account_name,\n    const duration &amp; _duration\n) \n</code></pre>"},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor_1","title":"function ~print_in_destructor","text":"<pre><code>inline print_in_destructor::~print_in_destructor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/classshould__profile__class/","title":"Class should_profile_class","text":"<p>ClassList &gt; should_profile_class</p>"},{"location":"api/classshould__profile__class/#public-functions","title":"Public Functions","text":"Type Name bool operator() ()  should_profile_class ()"},{"location":"api/classshould__profile__class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classshould__profile__class/#function-operator","title":"function operator()","text":"<pre><code>inline bool should_profile_class::operator() () \n</code></pre>"},{"location":"api/classshould__profile__class/#function-should_profile_class","title":"function should_profile_class","text":"<pre><code>inline should_profile_class::should_profile_class () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p>"},{"location":"api/namespacestd/#namespaces","title":"Namespaces","text":"Type Name namespace conditional"},{"location":"api/namespacestd/#classes","title":"Classes","text":"Type Name struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; &lt;class T&gt; <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacestd_1_1conditional/","title":"Namespace std::conditional","text":"<p>Namespace List &gt; std &gt; conditional</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 1 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 1 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 2 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 2 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 3 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 3 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 4 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 4 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 1 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 1 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 2 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 2 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 3 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 3 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 4 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 4 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/classtimer/","title":"Class timer","text":"<p>template &lt;typename now_fn, typename time_point, typename durationt&gt;</p> <p>ClassList &gt; timer</p> <p>a timer that times until the end of the code block ([RAII]). More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classtimer/#public-functions","title":"Public Functions","text":"Type Name timer (const now_fn &amp; now, durationt &amp; _duration)  ~timer ()"},{"location":"api/classtimer/#detailed-description","title":"Detailed Description","text":"<p>See [2] for how code-blocks are defined in C++.</p> <p><code>now</code> can be any type that takes no arguments and returns a subtractable type.</p> <p>Example usage:</p> <pre><code>{\n    // stuff that won't get timed.\n    std::chrono::nanoseconds ns;\n    timer&lt;decltype((thread_cpu_time))&gt; timer_obj {thread_cpu_time, ns};\n    // stuff that gets timed.\n}\n// stuff that won't get timed.\nstd::cout &lt;&lt; ns.count() &lt;&lt; std::endl;\n</code></pre>"},{"location":"api/classtimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classtimer/#function-timer","title":"function timer","text":"<pre><code>inline timer::timer (\n    const now_fn &amp; now,\n    durationt &amp; _duration\n) \n</code></pre>"},{"location":"api/classtimer/#function-timer_1","title":"function ~timer","text":"<pre><code>inline timer::~timer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/dir_bdd9a5d540de89e9fe90efdfc6973a4f/","title":"Dir common","text":"<p>FileList &gt; common</p>"},{"location":"api/dir_bdd9a5d540de89e9fe90efdfc6973a4f/#files","title":"Files","text":"Type Name file cpu_timer.hpp file data_format.hpp file dynamic_lib.hpp file error_util.hpp file extended_window.hpp file global_module_defs.hpp file linalg.hpp file logger.hpp file managed_thread.hpp file math_util.hpp file phonebook.hpp file plugin.hpp file pose_prediction.hpp file record_logger.hpp file runtime.hpp file shader_util.hpp file stoplight.hpp file switchboard.hpp file threadloop.hpp <p>The documentation for this class was generated from the following file <code>common/</code></p>"},{"location":"api/cpu__timer_8hpp/","title":"File cpu_timer.hpp","text":"<p>FileList &gt; common &gt; cpu_timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include \"error_util.hpp\"</code></li> </ul>"},{"location":"api/cpu__timer_8hpp/#classes","title":"Classes","text":"Type Name class print_timer &lt;typename now_fn, typename time_point, typename duration&gt;Like timer, but prints the output. class print_timer2 class should_profile_class class timer &lt;typename now_fn, typename time_point, typename durationt&gt;a timer that times until the end of the code block ([RAII])."},{"location":"api/cpu__timer_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name should_profile_class should_profile"},{"location":"api/cpu__timer_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (Duration t)  std::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (Duration t)  std::thread timed_thread (const std::string &amp; account_name, Function &amp;&amp; f, Args &amp;&amp;... args) Use this in place of std::thread(...) to print times."},{"location":"api/cpu__timer_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::nanoseconds cpp_clock_gettime (clockid_t clock_id) A C++ translation of clock_gettime __ std::size_t gen_serial_no ()  std::chrono::nanoseconds thread_cpu_time () Gets the CPU time for the calling thread."},{"location":"api/cpu__timer_8hpp/#macros","title":"Macros","text":"Type Name define PRINT_CPU_TIME_FOR_THIS_BLOCK (name) <code>[**print\\_timer**](classprint__timer.md)&amp;lt;decltype((thread\\_cpu\\_time))&amp;gt; PRINT\\_CPU\\_TIME\\_FOR\\_THIS\\_BLOCK {name, thread\\_cpu\\_time};</code> define PRINT_RECORD_FOR_THIS_BLOCK (name) <code>print\\_timer2 PRINT\\_RECORD\\_FOR\\_THIS\\_BLOCK\\_timer {name};</code> define PRINT_WALL_TIME_FOR_THIS_BLOCK (name) <code>[**print\\_timer**](classprint__timer.md)&amp;lt;decltype((std::chrono::high\\_resolution\\_clock::now))&amp;gt; PRINT\\_WALL\\_TIME\\_FOR\\_THIS\\_BLOCK {name, std::chrono::high\\_resolution\\_clock::now};</code>"},{"location":"api/cpu__timer_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/cpu__timer_8hpp/#variable-should_profile","title":"variable should_profile","text":"<pre><code>should_profile_class should_profile;\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-count_duration","title":"function count_duration","text":"<pre><code>template&lt;typename Duration, typename Out&gt;\nstd::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-count_duration_1","title":"function count_duration","text":"<pre><code>template&lt;typename Duration&gt;\nstd::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-timed_thread","title":"function timed_thread","text":"<p>Use this in place of std::thread(...) to print times. <pre><code>template&lt;class Function, class... Args&gt;\nstd::thread timed_thread (\n    const std::string &amp; account_name,\n    Function &amp;&amp; f,\n    Args &amp;&amp;... args\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-cpp_clock_gettime","title":"function cpp_clock_gettime","text":"<p>A C++ translation of clock_gettime __ <pre><code>static inline std::chrono::nanoseconds cpp_clock_gettime (\n    clockid_t clock_id\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#function-gen_serial_no","title":"function gen_serial_no","text":"<pre><code>static std::size_t gen_serial_no () \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-thread_cpu_time","title":"function thread_cpu_time","text":"<p>Gets the CPU time for the calling thread. <pre><code>static inline std::chrono::nanoseconds thread_cpu_time () \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/cpu__timer_8hpp/#define-print_cpu_time_for_this_block","title":"define PRINT_CPU_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_CPU_TIME_FOR_THIS_BLOCK (\n    name\n) `print_timer &lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK {name, thread_cpu_time};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_record_for_this_block","title":"define PRINT_RECORD_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_RECORD_FOR_THIS_BLOCK (\n    name\n) `print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer {name};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_wall_time_for_this_block","title":"define PRINT_WALL_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_WALL_TIME_FOR_THIS_BLOCK (\n    name\n) `print_timer &lt;decltype((std::chrono::high_resolution_clock::now))&gt; PRINT_WALL_TIME_FOR_THIS_BLOCK {name, std::chrono::high_resolution_clock::now};`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/cpu__timer_8hpp_source/","title":"File cpu_timer.hpp","text":"<p>File List &gt; common &gt; cpu_timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n#include &lt;cerrno&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;thread&gt;\n\n#include \"error_util.hpp\"\n\n\nstatic inline std::chrono::nanoseconds\ncpp_clock_gettime(clockid_t clock_id) {\n    /* This ensures the compiler won't reorder this function call; Pretend like it has memory side-effects. */\n    asm volatile (\"\"\n                  : /* OutputOperands */\n                  : /* InputOperands */\n                  : \"memory\" /* Clobbers */);\n    struct timespec ts;\n\n    RAC_ERRNO_MSG(\"cpu_timer before clock_gettime\");\n\n    if (clock_gettime(clock_id, &amp;ts)) {\n        throw std::runtime_error{std::string{\"clock_gettime returned \"} + strerror(errno)};\n    }\n    RAC_ERRNO_MSG(\"cpu_timer after clock_gettime\");\n\n    asm volatile (\"\"\n                  : /* OutputOperands */\n                  : /* InputOperands */\n                  : \"memory\" /* Clobbers */);\n    return std::chrono::seconds{ts.tv_sec} + std::chrono::nanoseconds{ts.tv_nsec};\n}\n\nstatic inline std::chrono::nanoseconds\nthread_cpu_time() {\n    RAC_ERRNO_MSG(\"cpu_timer before cpp_clock_gettime\");\n    return cpp_clock_gettime(CLOCK_THREAD_CPUTIME_ID);\n}\n\ntemplate &lt;\n    typename now_fn,\n    typename time_point = decltype(std::declval&lt;now_fn&gt;()()),\n    typename durationt = decltype(std::declval&lt;time_point&gt;() - std::declval&lt;time_point&gt;())\n    &gt;\nclass timer {\npublic:\n    timer(const now_fn&amp; now, durationt&amp; _duration)\n        : _p_now{now} , _p_duration{_duration} {\n        _p_start = _p_now();\n    }\n\n    ~timer() {\n        _p_duration = _p_now() - _p_start;\n    }\n\nprivate:\n    const now_fn&amp; _p_now;\n    durationt&amp; _p_duration;\n    time_point _p_start;\n};\n\ntemplate &lt;typename Duration, typename Out = decltype(std::declval&lt;Duration&gt;().count())&gt;\ntypename std::enable_if&lt;std::is_integral&lt;Out&gt;::value, Out&gt;::type\ncount_duration(Duration t) {\n    return std::chrono::duration_cast&lt;\n        std::chrono::nanoseconds,\n        typename Duration::rep,\n        typename Duration::period\n        &gt;(t).count();\n}\n\ntemplate &lt;typename Duration&gt;\ntypename std::enable_if&lt;std::is_integral&lt;Duration&gt;::value, Duration&gt;::type\ncount_duration(Duration t) {\n    return t;\n}\n\ntemplate &lt;\n    typename now_fn,\n    typename time_point = decltype(std::declval&lt;now_fn&gt;()()),\n    typename duration = decltype(std::declval&lt;time_point&gt;() - std::declval&lt;time_point&gt;())\n    &gt;\nclass print_timer {\nprivate:\n    class print_in_destructor {\n    public:\n        print_in_destructor(const std::string&amp; account_name, const duration&amp; _duration)\n            : _p_account_name{account_name}\n            , _p_duration{_duration}\n        { }\n        ~print_in_destructor() {\n            // std::ostringstream os;\n            // os &lt;&lt; \"cpu_timer,\" &lt;&lt; _p_account_name &lt;&lt; \",\" &lt;&lt; count_duration&lt;duration&gt;(_p_duration) &lt;&lt; \"\\n\";\n            if (rand() % 100 == 0) {\n                #ifndef NDEBUG\n                    std::cout &lt;&lt; \"cpu_timer.hpp is DEPRECATED. See logging.hpp.\\n\";\n                #endif\n            }\n        }\n    private:\n        const std::string _p_account_name;\n        const duration&amp; _p_duration;\n    };\n\n    // NOTE that the destructors get called in reverse order!\n    // This is important, because _p_timer's destructor records the timing information\n    // Then, _p_print_in_destructor prints it\n    // Then, we can destroy _p_duration.\n    duration _p_duration;\n    const print_in_destructor _p_print_in_destructor;\n    const timer&lt;now_fn, time_point, duration&gt; _p_timer;\npublic:\n    print_timer(const std::string&amp; name, const now_fn&amp; now)\n        : _p_print_in_destructor{name, _p_duration}\n        , _p_timer{now, _p_duration}\n    { }\n};\n\nstatic std::size_t gen_serial_no() {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count();\n}\n\nclass should_profile_class {\npublic:\n    should_profile_class() {\n        const char* ILLIXR_STDOUT_METRICS = getenv(\"ILLIXR_STDOUT_METRICS\");\n        actually_should_profile = ILLIXR_STDOUT_METRICS &amp;&amp; (strcmp(ILLIXR_STDOUT_METRICS, \"y\") == 0);\n    }\n    bool operator()() {\n        return actually_should_profile;\n    }\nprivate:\n    bool actually_should_profile;\n};\n\nstatic should_profile_class should_profile;\n\nclass print_timer2 {\nprivate:\n    const std::string name;\n    const std::size_t serial_no;\n    std::size_t wall_time_start;\n    std::size_t cpu_time_start;\npublic:\n    print_timer2(std::string name_)\n        : name{name_}\n        , serial_no{should_profile() ? gen_serial_no() : std::size_t{0}}\n        , wall_time_start{should_profile()\n            ? std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count()\n            : std::size_t{0}\n        }\n        , cpu_time_start{should_profile() ? thread_cpu_time().count() : std::size_t{0}}\n    { }\n    ~print_timer2() {\n        if (should_profile()) {\n            auto cpu_time_stop = thread_cpu_time().count();\n            auto wall_time_stop  = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count();\n\n            std::cout &lt;&lt; \"cpu_timer,\" &lt;&lt; name &lt;&lt; \",\" &lt;&lt; serial_no &lt;&lt; \",\" &lt;&lt; wall_time_start &lt;&lt; \",\" &lt;&lt; wall_time_stop &lt;&lt; \",\" &lt;&lt; cpu_time_start &lt;&lt; \",\" &lt;&lt; cpu_time_stop &lt;&lt; \"\\n\";\n        }\n    }\n};\n\n#define PRINT_CPU_TIME_FOR_THIS_BLOCK(name)                                 \\\n    print_timer&lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK {name, thread_cpu_time};\n\n#define PRINT_WALL_TIME_FOR_THIS_BLOCK(name)                                    \\\n    print_timer&lt;decltype((std::chrono::high_resolution_clock::now))&gt; PRINT_WALL_TIME_FOR_THIS_BLOCK {name, std::chrono::high_resolution_clock::now};\n\n#define PRINT_RECORD_FOR_THIS_BLOCK(name)                                    \\\n    print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer {name};\n\ntemplate&lt; class Function, class... Args &gt;\nstd::thread timed_thread(const std::string&amp; account_name, Function&amp;&amp; f, Args&amp;&amp;... args) {\n    // Unfortunately we make copies of f and args.\n    // According to StackOverflow, this is unavoidable.\n    // See Sam Varshavchik's comment on https://stackoverflow.com/a/62380971/1078199\n    return std::thread([=] {\n        {   PRINT_RECORD_FOR_THIS_BLOCK(account_name);\n            std::invoke(f, args...);\n        }\n    });\n}\n</code></pre>"},{"location":"api/data__format_8hpp/","title":"File data_format.hpp","text":"<p>FileList &gt; common &gt; data_format.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;boost/optional.hpp&gt;</code></li> <li><code>#include &lt;opencv2/core/mat.hpp&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;GL/gl.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"switchboard.hpp\"</code></li> </ul>"},{"location":"api/data__format_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/data__format_8hpp/#classes","title":"Classes","text":"Type Name struct accel struct fast_pose_type struct hmd_physical_info struct hologram_input struct imu_cam_type struct imu_integrator_input struct imu_integrator_seq struct imu_params struct imu_raw_type struct pose_type struct rendered_frame class rgb_depth_type struct texture_pose"},{"location":"api/data__format_8hpp/#macros","title":"Macros","text":"Type Name define NANO_SEC <code>1000000000.0</code> define USE_ALT_EYE_FORMAT"},{"location":"api/data__format_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/data__format_8hpp/#define-nano_sec","title":"define NANO_SEC","text":"<pre><code>#define NANO_SEC `1000000000.0`\n</code></pre>"},{"location":"api/data__format_8hpp/#define-use_alt_eye_format","title":"define USE_ALT_EYE_FORMAT","text":"<pre><code>#define USE_ALT_EYE_FORMAT \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/data__format_8hpp_source/","title":"File data_format.hpp","text":"<p>File List &gt; common &gt; data_format.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;boost/optional.hpp&gt;\n\n#include &lt;opencv2/core/mat.hpp&gt;\n#undef Success // For 'Success' conflict\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;GL/gl.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n//#undef Complex // For 'Complex' conflict\n#include \"phonebook.hpp\" \n#include \"switchboard.hpp\"\n\n// Tell gldemo and timewarp_gl to use two texture handle for left and right eye\n#define USE_ALT_EYE_FORMAT\n#define NANO_SEC 1000000000.0\n\nnamespace ILLIXR {\n\n    typedef std::chrono::system_clock::time_point time_type;\n    typedef unsigned long long ullong;\n\n    // Data type that combines the IMU and camera data at a certain timestamp.\n    // If there is only IMU data for a certain timestamp, img0 and img1 will be null\n    // time is the current UNIX time where dataset_time is the time read from the csv\n    struct imu_cam_type : public switchboard::event {\n        time_type time;\n        Eigen::Vector3f angular_v;\n        Eigen::Vector3f linear_a;\n        std::optional&lt;cv::Mat&gt; img0;\n        std::optional&lt;cv::Mat&gt; img1;\n        ullong dataset_time;\n        imu_cam_type(time_type time_,\n                     Eigen::Vector3f angular_v_,\n                     Eigen::Vector3f linear_a_,\n                     std::optional&lt;cv::Mat&gt; img0_,\n                     std::optional&lt;cv::Mat&gt; img1_,\n                     ullong dataset_time_)\n            : time{time_}\n            , angular_v{angular_v_}\n            , linear_a{linear_a_}\n            , img0{img0_}\n            , img1{img1_}\n            , dataset_time{dataset_time_}\n        { }\n    };\n\n    class rgb_depth_type : public switchboard::event {\n        std::optional&lt;cv::Mat&gt; rgb;\n        std::optional&lt;cv::Mat&gt; depth;\n        [[maybe_unused]] ullong timestamp;\n    public:\n        rgb_depth_type(\n                       std::optional&lt;cv::Mat&gt; _rgb,\n                       std::optional&lt;cv::Mat&gt; _depth,\n                       ullong _timestamp\n                       )\n            : rgb{_rgb}\n            , depth{_depth}\n            , timestamp{_timestamp}\n        { }\n    };\n\n    // Values needed to initialize the IMU integrator\n    typedef struct {\n        double gyro_noise;\n        double acc_noise;\n        double gyro_walk;\n        double acc_walk;\n        Eigen::Matrix&lt;double,3,1&gt; n_gravity;\n        double imu_integration_sigma;\n        double nominal_rate;\n    } imu_params;\n\n    // IMU biases, initialization params, and slow pose needed by the IMU integrator\n    struct imu_integrator_input : public switchboard::event {\n        double last_cam_integration_time;\n        double t_offset;\n        imu_params params;\n\n        Eigen::Vector3d biasAcc;\n        Eigen::Vector3d biasGyro;\n        Eigen::Matrix&lt;double,3,1&gt; position;\n        Eigen::Matrix&lt;double,3,1&gt; velocity;\n        Eigen::Quaterniond quat;\n        imu_integrator_input(\n                             double last_cam_integration_time_,\n                             double t_offset_,\n                             imu_params params_,\n                             Eigen::Vector3d biasAcc_,\n                             Eigen::Vector3d biasGyro_,\n                             Eigen::Matrix&lt;double,3,1&gt; position_,\n                             Eigen::Matrix&lt;double,3,1&gt; velocity_,\n                             Eigen::Quaterniond quat_\n                             )\n            : last_cam_integration_time{last_cam_integration_time_}\n            , t_offset{t_offset_}\n            , params{params_}\n            , biasAcc{biasAcc_}\n            , biasGyro{biasGyro_}\n            , position{position_}\n            , velocity{velocity_}\n            , quat{quat_}\n        { }\n    };\n\n    // Output of the IMU integrator to be used by pose prediction\n    struct imu_raw_type : public switchboard::event {\n        // Biases from the last two IMU integration iterations used by RK4 for pose predict\n        Eigen::Matrix&lt;double,3,1&gt; w_hat;\n        Eigen::Matrix&lt;double,3,1&gt; a_hat;\n        Eigen::Matrix&lt;double,3,1&gt; w_hat2;\n        Eigen::Matrix&lt;double,3,1&gt; a_hat2;\n\n        // Faster pose propagated forwards by the IMU integrator\n        Eigen::Matrix&lt;double,3,1&gt; pos;\n        Eigen::Matrix&lt;double,3,1&gt; vel;\n        Eigen::Quaterniond quat;\n        time_type imu_time;\n        imu_raw_type(Eigen::Matrix&lt;double,3,1&gt; w_hat_,\n                     Eigen::Matrix&lt;double,3,1&gt; a_hat_,\n                     Eigen::Matrix&lt;double,3,1&gt; w_hat2_,\n                     Eigen::Matrix&lt;double,3,1&gt; a_hat2_,\n                     Eigen::Matrix&lt;double,3,1&gt; pos_,\n                     Eigen::Matrix&lt;double,3,1&gt; vel_,\n                     Eigen::Quaterniond quat_,\n                     time_type imu_time_)\n            : w_hat{w_hat_}\n            , a_hat{a_hat_}\n            , w_hat2{w_hat2_}\n            , a_hat2{a_hat2_}\n            , pos{pos_}\n            , vel{vel_}\n            , quat{quat_}\n            , imu_time{imu_time_}\n        { }\n    };\n\n    struct pose_type : public switchboard::event {\n        time_type sensor_time; // Recorded time of sensor data ingestion\n        Eigen::Vector3f position;\n        Eigen::Quaternionf orientation;\n        pose_type() { }\n        pose_type(time_type sensor_time_,\n                  Eigen::Vector3f position_,\n                  Eigen::Quaternionf orientation_)\n            : sensor_time{sensor_time_}\n            , position{position_}\n            , orientation{orientation_}\n        { }\n    };\n\n    typedef struct {\n        pose_type pose;\n        time_type predict_computed_time; // Time at which the prediction was computed\n        time_type predict_target_time; // Time that prediction targeted.\n    } fast_pose_type;\n\n    // Using arrays as a swapchain\n    // Array of left eyes, array of right eyes\n    // This more closely matches the format used by Monado\n    struct rendered_frame : public switchboard::event {\n        GLuint texture_handles[2]; // Does not change between swaps in swapchain\n        GLuint swap_indices[2]; // Which element of the swapchain\n        fast_pose_type render_pose; // The pose used when rendering this frame.\n        time_type sample_time;\n        time_type render_time;\n        rendered_frame() { }\n        rendered_frame(GLuint texture_handles_[2],\n                       GLuint swap_indices_[2],\n                       fast_pose_type render_pose_,\n                       time_type sample_time_,\n                       time_type render_time_)\n            : render_pose(render_pose_)\n            , sample_time(sample_time_)\n            , render_time(render_time_)\n        {\n            texture_handles[0]  = texture_handles_[0];\n            texture_handles[1]  = texture_handles_[1];\n            swap_indices[0]     = swap_indices_[0];\n            swap_indices[1]     = swap_indices_[1];\n        }\n    };\n\n    struct hologram_input : public switchboard::event {\n        int seq;\n        hologram_input() { }\n        hologram_input(int seq_) : seq{seq_} { }\n    };\n\n    typedef struct {\n        int seq;        \n    } imu_integrator_seq;\n\n    /* I use \"accel\" instead of \"3-vector\" as a datatype, because\n    this checks that you meant to use an acceleration in a certain\n    place. */\n    struct accel { };\n\n    // High-level HMD specification, timewarp plugin\n    // may/will calculate additional HMD info based on these specifications\n    struct hmd_physical_info {\n        float   ipd;\n        int     displayPixelsWide;\n        int     displayPixelsHigh;\n        float   chromaticAberration[4];\n        float   K[11];\n        int     visiblePixelsWide;\n        int     visiblePixelsHigh;\n        float   visibleMetersWide;\n        float   visibleMetersHigh;\n        float   lensSeparationInMeters;\n        float   metersPerTanAngleAtCenter;\n    };\n\n    struct texture_pose : public switchboard::event {\n        int seq; \n        int offload_time;\n        unsigned char *image;\n        time_type pose_time;\n        Eigen::Vector3f position;\n        Eigen::Quaternionf latest_quaternion;\n        Eigen::Quaternionf render_quaternion;\n        texture_pose() { }\n        texture_pose(\n            int seq_,\n            int offload_time_,\n            unsigned char *image_,\n            time_type pose_time_,\n            Eigen::Vector3f position_,\n            Eigen::Quaternionf latest_quaternion_,\n            Eigen::Quaternionf render_quaternion_\n        ) : seq{seq_}\n          , offload_time{offload_time_}\n          , image{image_}\n          , pose_time{pose_time_}\n          , position{position_}\n          , latest_quaternion{latest_quaternion_}\n          , render_quaternion{render_quaternion_}\n        { }\n    };\n}\n</code></pre>"},{"location":"api/dynamic__lib_8hpp/","title":"File dynamic_lib.hpp","text":"<p>FileList &gt; common &gt; dynamic_lib.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;dlfcn.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"global_module_defs.hpp\"</code></li> <li><code>#include \"error_util.hpp\"</code></li> </ul>"},{"location":"api/dynamic__lib_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/dynamic__lib_8hpp/#classes","title":"Classes","text":"Type Name class dynamic_lib <p>The documentation for this class was generated from the following file <code>common/dynamic_lib.hpp</code></p>"},{"location":"api/dynamic__lib_8hpp_source/","title":"File dynamic_lib.hpp","text":"<p>File List &gt; common &gt; dynamic_lib.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;dlfcn.h&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;functional&gt;\n#include &lt;algorithm&gt;\n\n#include \"global_module_defs.hpp\"\n#include \"error_util.hpp\"\n\nnamespace ILLIXR {\n\nusing void_ptr = std::unique_ptr&lt;void, std::function&lt;void(void*)&gt;&gt;;\n/*\nUsage:\n    void* thing;\n    void_ptr wrapped_thing = {thing, [](void* thing) {\n        // destructor goes here.\n    }}\n    // wrapped_thing.get() returns underlying thing.\n */\n\nclass dynamic_lib {\nprivate:\n    dynamic_lib(\n        void_ptr&amp;&amp; handle\n        , const std::string&amp; lib_path = \"\"\n    ) : _m_handle{std::move(handle)}\n      , _m_lib_path{std::move(lib_path)}\n    { }\n\npublic:\n    dynamic_lib(dynamic_lib&amp;&amp; other)\n        : _m_handle{std::move(other._m_handle)}\n        , _m_lib_path{std::move(other._m_lib_path)}\n    { }\n\n    dynamic_lib&amp; operator=(dynamic_lib&amp;&amp; other) {\n        if (this != &amp;other) {\n            _m_handle   = std::move(other._m_handle);\n            _m_lib_path = std::move(other._m_lib_path);\n        }\n        return *this;\n    }\n\n    ~dynamic_lib() {\n#ifndef NDEBUG\n        if (!_m_lib_path.empty()) {\n            std::cout &lt;&lt; \"[dynamic_lib] Destructing library : \" &lt;&lt; _m_lib_path &lt;&lt; std::endl;\n        }\n#endif \n    }\n\n    static dynamic_lib create(const std::string&amp; path) {\n        return dynamic_lib::create(std::string_view{path.c_str()});\n    }\n\n    static dynamic_lib create(const std::string_view&amp; path) {\n        char* error;\n\n        // dlopen man page says that it can set errno sp\n        RAC_ERRNO_MSG(\"dynamic_lib before dlopen\");\n        void* handle = dlopen(path.data(), RTLD_LAZY | RTLD_LOCAL);\n        RAC_ERRNO_MSG(\"dynamic_lib after dlopen\");\n\n        if ((error = dlerror()) || !handle) {\n            throw std::runtime_error{\n                \"dlopen(\\\"\" + std::string{path} + \"\\\"): \" + (error == nullptr ? \"NULL\" : std::string{error})\n            };\n        }\n\n        return dynamic_lib{\n            void_ptr{handle, [](void* handle) {\n                RAC_ERRNO();\n\n                char* error;\n                int ret = dlclose(handle);\n                if ((error = dlerror()) || ret) {\n                    const std::string msg_error {\"dlclose(): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n                    std::cerr &lt;&lt; \"[dynamic_lib] \" &lt;&lt; msg_error &lt;&lt; std::endl;\n                    throw std::runtime_error{msg_error};\n                }\n            }},\n            std::string{path} \n        };\n    }\n\n    const void* operator[](const std::string&amp; symbol_name) const {\n        RAC_ERRNO_MSG(\"dynamic_lib at start of operator[]\");\n\n        char* error;\n        void* symbol = dlsym(_m_handle.get(), symbol_name.c_str());\n        if ((error = dlerror())) {\n            throw std::runtime_error{\n                \"dlsym(\\\"\" + symbol_name + \"\\\"): \" + (error == nullptr ? \"NULL\" : std::string{error})\n            };\n        }\n        return symbol;\n    }\n\n    template &lt;typename T&gt;\n    const T get(const std::string&amp; symbol_name) const {\n        const void* obj = (*this)[symbol_name];\n        // return reinterpret_cast&lt;const T&gt;((*this)[symbol_name]);\n        return (const T) obj;\n    }\n\nprivate:\n    void_ptr    _m_handle;\n    std::string _m_lib_path;\n};\n\n}\n</code></pre>"},{"location":"api/error__util_8hpp/","title":"File error_util.hpp","text":"<p>FileList &gt; common &gt; error_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"global_module_defs.hpp\"</code></li> </ul>"},{"location":"api/error__util_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/error__util_8hpp/#macros","title":"Macros","text":"Type Name define RAC_ERRNO () <code>[**ILLIXR::report\\_and\\_clear\\_errno**](namespaceILLIXR.md#function-report_and_clear_errno)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_, \\_\\_func\\_\\_)</code>Parameterless macro for report_and_clear_errno. define RAC_ERRNO_MSG (msg) <code>[**ILLIXR::report\\_and\\_clear\\_errno**](namespaceILLIXR.md#function-report_and_clear_errno)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_, \\_\\_func\\_\\_, msg)</code>RAC_ERRNO."},{"location":"api/error__util_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/error__util_8hpp/#define-rac_errno","title":"define RAC_ERRNO","text":"<p>Parameterless macro for report_and_clear_errno. <pre><code>#define RAC_ERRNO (\n\n) `ILLIXR::report_and_clear_errno (__FILE__, __LINE__, __func__)`\n</code></pre></p>"},{"location":"api/error__util_8hpp/#define-rac_errno_msg","title":"define RAC_ERRNO_MSG","text":"<p>RAC_ERRNO. <pre><code>#define RAC_ERRNO_MSG (\n    msg\n) `ILLIXR::report_and_clear_errno (__FILE__, __LINE__, __func__, msg)`\n</code></pre></p> <p>Parameterized macro for report_and_clear_errno.</p> <p>Prints a message from the calling context for additional info. </p> <p>The documentation for this class was generated from the following file <code>common/error_util.hpp</code></p>"},{"location":"api/error__util_8hpp_source/","title":"File error_util.hpp","text":"<p>File List &gt; common &gt; error_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cerrno&gt;\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\n#include \"global_module_defs.hpp\"\n\n\n#ifndef RAC_ERRNO\n#define RAC_ERRNO() ILLIXR::report_and_clear_errno(__FILE__, __LINE__, __func__)\n#endif \n\n#ifndef RAC_ERRNO_MSG\n#define RAC_ERRNO_MSG(msg) ILLIXR::report_and_clear_errno(__FILE__, __LINE__, __func__, msg)\n#endif \n\n\nnamespace ILLIXR {\n\nstatic const bool ENABLE_VERBOSE_ERRORS {ILLIXR::str_to_bool(ILLIXR::getenv_or(\"ILLIXR_ENABLE_VERBOSE_ERRORS\", \"False\"))};\n\ninline void report_and_clear_errno(\n    [[maybe_unused]] const std::string&amp; file,\n    [[maybe_unused]] const int&amp; line,\n    [[maybe_unused]] const std::string&amp; function,\n    [[maybe_unused]] const std::string&amp; msg = \"\"\n) {\n#ifndef NDEBUG\n    if (errno &gt; 0) {\n        if (ILLIXR::ENABLE_VERBOSE_ERRORS) {\n            std::cerr &lt;&lt; \"|| Errno was set: \" &lt;&lt; errno &lt;&lt; \" @ \" &lt;&lt; file &lt;&lt; \":\" &lt;&lt; line &lt;&lt; \"[\" &lt;&lt; function &lt;&lt; \"]\" &lt;&lt; std::endl;\n            if (!msg.empty()) {\n                std::cerr &lt;&lt; \"|&gt; Message: \" &lt;&lt; msg &lt;&lt; std::endl;\n            }\n        }\n        errno = 0;\n    }\n#endif \n}\n\n\ninline void abort(const std::string&amp; msg = \"\", [[maybe_unused]] const int error_val = 1) {\n    std::cerr &lt;&lt; \"** ERROR ** \" &lt;&lt; msg &lt;&lt; std::endl;\n#ifndef NDEBUG\n    std::abort();\n#else \n    std::exit(error_val);\n#endif \n}\n\n} \n</code></pre>"},{"location":"api/extended__window_8hpp/","title":"File extended_window.hpp","text":"<p>FileList &gt; common &gt; extended_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;X11/X.h&gt;</code></li> <li><code>#include &lt;X11/Xlib.h&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include &lt;GL/glu.h&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"global_module_defs.hpp\"</code></li> <li><code>#include \"error_util.hpp\"</code></li> </ul>"},{"location":"api/extended__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/extended__window_8hpp/#classes","title":"Classes","text":"Type Name class xlib_gl_extended_window"},{"location":"api/extended__window_8hpp/#public-types","title":"Public Types","text":"Type Name typedef GLXContext(* glXCreateContextAttribsARBProc"},{"location":"api/extended__window_8hpp/#macros","title":"Macros","text":"Type Name define GLX_CONTEXT_MAJOR_VERSION_ARB <code>0x2091</code> define GLX_CONTEXT_MINOR_VERSION_ARB <code>0x2092</code>"},{"location":"api/extended__window_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/extended__window_8hpp/#typedef-glxcreatecontextattribsarbproc","title":"typedef glXCreateContextAttribsARBProc","text":"<pre><code>typedef GLXContext(* glXCreateContextAttribsARBProc) (Display *, GLXFBConfig, GLXContext, Bool, const int *);\n</code></pre>"},{"location":"api/extended__window_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/extended__window_8hpp/#define-glx_context_major_version_arb","title":"define GLX_CONTEXT_MAJOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MAJOR_VERSION_ARB `0x2091`\n</code></pre>"},{"location":"api/extended__window_8hpp/#define-glx_context_minor_version_arb","title":"define GLX_CONTEXT_MINOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MINOR_VERSION_ARB `0x2092`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/extended_window.hpp</code></p>"},{"location":"api/extended__window_8hpp_source/","title":"File extended_window.hpp","text":"<p>File List &gt; common &gt; extended_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cerrno&gt;\n#include &lt;cassert&gt;\n#include &lt;X11/X.h&gt;\n#include &lt;X11/Xlib.h&gt;\n#include &lt;GL/glx.h&gt;\n#include &lt;GL/glu.h&gt;\n#include \"phonebook.hpp\"\n#include \"global_module_defs.hpp\"\n#include \"error_util.hpp\"\n\n//GLX context magics\n#define GLX_CONTEXT_MAJOR_VERSION_ARB       0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB       0x2092\ntypedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);\n\nnamespace ILLIXR {\n    class xlib_gl_extended_window : public phonebook::service {\n    public:\n        int        width;\n        int        height;\n        Display*   dpy;\n        Window     win;\n        GLXContext glc;\n        xlib_gl_extended_window(int _width, int _height, GLXContext _shared_gl_context) {\n            width = _width;\n            height = _height;\n\n#ifndef NDEBUG\n            std::cout &lt;&lt; \"Opening display\" &lt;&lt; std::endl;\n#endif\n            RAC_ERRNO_MSG(\"extended_window at start of xlib_gl_extended_window constructor\");\n\n            dpy = XOpenDisplay(nullptr);\n            if (dpy == nullptr) {\n                ILLIXR::abort(\"Cannot connect to X server\");\n            } else {\n                // Apparently, XOpenDisplay's _true_ error indication is whether dpy is nullptr.\n                // https://cboard.cprogramming.com/linux-programming/119957-xlib-perversity.html\n                // if (errno != 0) {\n                //  std::cerr &lt;&lt; \"XOpenDisplay succeeded, but errno = \" &lt;&lt; errno &lt;&lt; \"; This is benign, so I'm clearing it now.\\n\";\n                // }\n                errno = 0;\n            }\n\n            Window root = DefaultRootWindow(dpy);\n            // Get a matching FB config\n            static int visual_attribs[] =\n            {\n                GLX_X_RENDERABLE    , True,\n                GLX_DRAWABLE_TYPE   , GLX_WINDOW_BIT,\n                GLX_RENDER_TYPE     , GLX_RGBA_BIT,\n                GLX_X_VISUAL_TYPE   , GLX_TRUE_COLOR,\n                GLX_RED_SIZE        , 8,\n                GLX_GREEN_SIZE      , 8,\n                GLX_BLUE_SIZE       , 8,\n                GLX_ALPHA_SIZE      , 8,\n                GLX_DEPTH_SIZE      , 24,\n                GLX_STENCIL_SIZE    , 8,\n                GLX_DOUBLEBUFFER    , True,\n                None\n            };\n\n#ifndef NDEBUG\n            std::cout &lt;&lt; \"Getting matching framebuffer configs\" &lt;&lt; std::endl;\n#endif\n            RAC_ERRNO_MSG(\"extended_window before glXChooseFBConfig\");\n\n            int fbcount = 0;\n            int screen = DefaultScreen(dpy);\n            GLXFBConfig* fbc = glXChooseFBConfig(dpy, screen, visual_attribs, &amp;fbcount);\n            if (!fbc) {\n                ILLIXR::abort(\"Failed to retrieve a framebuffer config\");\n            }\n\n#ifndef NDEBUG\n            std::cout &lt;&lt; \"Found \" &lt;&lt; fbcount &lt;&lt; \" matching FB configs\" &lt;&lt; std::endl;\n\n            // Pick the FB config/visual with the most samples per pixel\n            std::cout &lt;&lt; \"Getting XVisualInfos\" &lt;&lt; std::endl;\n#endif\n            int best_fbc = -1, worst_fbc = -1, best_num_samp = -1, worst_num_samp = 999;\n            int i;\n            for (i = 0; i &lt; fbcount; ++i) {\n                XVisualInfo *vi = glXGetVisualFromFBConfig(dpy, fbc[i]);\n                if (vi) {\n                    int samp_buf, samples;\n                    glXGetFBConfigAttrib(dpy, fbc[i], GLX_SAMPLE_BUFFERS, &amp;samp_buf);\n                    glXGetFBConfigAttrib(dpy, fbc[i], GLX_SAMPLES       , &amp;samples );\n#ifndef NDEBUG\n                    std::cout &lt;&lt; \"Matching fbconfig \" &lt;&lt; i\n                              &lt;&lt; \", visual ID 0x\" &lt;&lt; std::hex &lt;&lt; vi-&gt;visualid &lt;&lt; std::dec\n                              &lt;&lt; \": SAMPLE_BUFFERS = \" &lt;&lt; samp_buf\n                              &lt;&lt; \", SAMPLES = \" &lt;&lt; samples\n                              &lt;&lt; std::endl;\n#endif\n                    if (best_fbc &lt; 0 || (samp_buf &amp;&amp; samples &gt; best_num_samp)) {\n                        best_fbc = i, best_num_samp = samples;\n                    }\n                    if (worst_fbc &lt; 0 || (!samp_buf || samples &lt; worst_num_samp)) {\n                        worst_fbc = i, worst_num_samp = samples;\n                    }\n                }\n                XFree(vi);\n            }\n\n            assert(0 &lt;= best_fbc &amp;&amp; best_fbc &lt; fbcount);\n            GLXFBConfig bestFbc = fbc[best_fbc];\n\n            // Free the FBConfig list allocated by glXChooseFBConfig()\n            XFree(fbc);\n\n            // Get a visual\n            XVisualInfo *vi = glXGetVisualFromFBConfig(dpy, bestFbc);\n#ifndef NDEBUG\n            std::cout &lt;&lt; \"Chose visual ID = 0x\" &lt;&lt; std::hex &lt;&lt; vi-&gt;visualid &lt;&lt; std::dec &lt;&lt; std::endl;\n\n            std::cout &lt;&lt; \"Creating colormap\" &lt;&lt; std::endl;\n#endif\n            _m_cmap = XCreateColormap(dpy, root, vi-&gt;visual, AllocNone);\n\n#ifndef NDEBUG\n            std::cout &lt;&lt; \"Creating window\" &lt;&lt; std::endl;\n#endif\n            XSetWindowAttributes attributes;\n            attributes.colormap = _m_cmap;\n            attributes.background_pixel = 0;\n            attributes.border_pixel = 0;\n            attributes.event_mask = ExposureMask | KeyPressMask;\n            win = XCreateWindow(dpy, root, 0, 0, width, height, 0, vi-&gt;depth, InputOutput, vi-&gt;visual,\n                CWBackPixel | CWColormap | CWBorderPixel | CWEventMask, &amp;attributes);\n            if (!win) {\n                ILLIXR::abort(\"Failed to create window\");\n            }\n            XStoreName(dpy, win, \"ILLIXR Extended Window\");\n            XMapWindow(dpy, win);\n\n            // Done with visual info\n            XFree(vi);\n\n#ifndef NDEBUG\n            std::cout &lt;&lt; \"Creating context\" &lt;&lt; std::endl;\n#endif\n            glXCreateContextAttribsARBProc glXCreateContextAttribsARB = 0;\n            glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)\n                glXGetProcAddressARB((const GLubyte *) \"glXCreateContextAttribsARB\");\n            int context_attribs[] = {\n                GLX_CONTEXT_MAJOR_VERSION_ARB, 3,\n                GLX_CONTEXT_MINOR_VERSION_ARB, 3,\n                None\n            };\n\n            glc = glXCreateContextAttribsARB(dpy, bestFbc, _shared_gl_context, True, context_attribs);\n\n            // Sync to process errors\n            RAC_ERRNO_MSG(\"extended_window before XSync\");\n            XSync(dpy, false);\n            RAC_ERRNO_MSG(\"extended_window after XSync\");\n\n#ifndef NDEBUG\n            // Doing glXMakeCurrent here makes a third thread, the runtime one, enter the mix, and\n            // then there are three GL threads: runtime, timewarp, and gldemo, and the switching of\n            // contexts without synchronization during the initialization phase causes a data race.\n            // This is why native.yaml sometimes succeeds and sometimes doesn't. Headless succeeds\n            // because this behavior is OpenGL implementation dependent, and apparently mesa\n            // differs from NVIDIA in this regard.\n            // The proper fix is #173. Comment the below back in once #173 is done. In any case,\n            // this is just for debugging and does not affect any functionality.\n\n            /*\n            const bool gl_result_0 = static_cast&lt;bool&gt;(glXMakeCurrent(dpy, win, glc));\n            int major = 0, minor = 0;\n            glGetIntegerv(GL_MAJOR_VERSION, &amp;major);\n            glGetIntegerv(GL_MINOR_VERSION, &amp;minor);\n            std::cout &lt;&lt; \"OpenGL context created\" &lt;&lt; std::endl\n                      &lt;&lt; \"Version \" &lt;&lt; major &lt;&lt; \".\" &lt;&lt; minor &lt;&lt; std::endl\n                      &lt;&lt; \"Vender \" &lt;&lt; glGetString(GL_VENDOR) &lt;&lt; std::endl\n                      &lt;&lt; \"Renderer \" &lt;&lt; glGetString(GL_RENDERER) &lt;&lt; std::endl;\n            const bool gl_result_1 = static_cast&lt;bool&gt;(glXMakeCurrent(dpy, None, nullptr));\n            */\n#endif\n        }\n\n        ~xlib_gl_extended_window() {\n            RAC_ERRNO_MSG(\"xlib_gl_extended_window at start of destructor\");\n\n            [[maybe_unused]] const bool gl_result = static_cast&lt;bool&gt;(glXMakeCurrent(dpy, None, nullptr));\n            assert(gl_result &amp;&amp; \"glXMakeCurrent should not fail\");\n\n            glXDestroyContext(dpy, glc);\n            XDestroyWindow(dpy, win);\n            Window root = DefaultRootWindow(dpy);\n            XDestroyWindow(dpy, root);\n            XFreeColormap(dpy, _m_cmap);\n\n            XCloseDisplay(dpy);\n\n            RAC_ERRNO_MSG(\"xlib_gl_extended_window at end of destructor\");\n        }\n\n    private:\n        Colormap _m_cmap;\n    };\n}\n</code></pre>"},{"location":"api/global__module__defs_8hpp/","title":"File global_module_defs.hpp","text":"<p>FileList &gt; common &gt; global_module_defs.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> </ul>"},{"location":"api/global__module__defs_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/global__module__defs_8hpp/#macros","title":"Macros","text":"Type Name define FB_HEIGHT <code>FB\\_HEIGHT</code> define FB_WIDTH <code>FB\\_WIDTH</code>"},{"location":"api/global__module__defs_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/global__module__defs_8hpp/#define-fb_height","title":"define FB_HEIGHT","text":"<pre><code>#define FB_HEIGHT `FB_HEIGHT`\n</code></pre>"},{"location":"api/global__module__defs_8hpp/#define-fb_width","title":"define FB_WIDTH","text":"<pre><code>#define FB_WIDTH `FB_WIDTH`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/global_module_defs.hpp</code></p>"},{"location":"api/global__module__defs_8hpp_source/","title":"File global_module_defs.hpp","text":"<p>File List &gt; common &gt; global_module_defs.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\nThis is the file where default values are defined\n*/\n\n#pragma once\n\n#include &lt;string&gt;\n#include &lt;stdexcept&gt;\n\n\nnamespace ILLIXR {\n\n#ifndef FB_WIDTH\n#define FB_WIDTH FB_WIDTH\n\n//Setting default Framebuffer width\nstatic constexpr int FB_WIDTH = 2560; //Pixels\n#endif\n\n#ifndef FB_HEIGHT\n#define FB_HEIGHT FB_HEIGHT\n\n//Setting default framebuffer height\nstatic constexpr int FB_HEIGHT = 1440; //Pixels\n#endif //FB_HEIGHT\n\ninline bool str_to_bool(std::string var) {\n    return (var == \"True\")  ? true  :\n           (var == \"False\") ? false :\n           throw std::runtime_error(\"Invalid conversion from std::string to bool\");\n}\n\ninline std::string getenv_or(std::string var, std::string default_) {\n    if (std::getenv(var.c_str())) {\n        return {std::getenv(var.c_str())};\n    } else {\n        return default_;\n    }\n}\n\n} \n</code></pre>"},{"location":"api/linalg_8hpp/","title":"File linalg.hpp","text":"<p>FileList &gt; common &gt; linalg.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;iosfwd&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"api/linalg_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace linalg namespace aliases namespace detail namespace ostream_overloads namespace std"},{"location":"api/linalg_8hpp/#classes","title":"Classes","text":"Type Name struct converter &lt;class T, class U&gt; struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; &lt;class T&gt; struct any_compare &lt;class A, class B&gt; struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct apply &lt;class F, class Void, T&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; &lt;class F, M, N, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; &lt;class F, M, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; &lt;class F, A&gt; struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct clamp struct empty struct getter&lt; 0 &gt; &lt;&gt; struct getter&lt; 1 &gt; &lt;&gt; struct getter&lt; 2 &gt; &lt;&gt; struct getter&lt; 3 &gt; &lt;&gt; struct lerp struct make_seq_impl&lt; A, 0 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 1 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 2 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 3 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 4 &gt; &lt;A&gt; struct max struct min struct op_add struct op_and struct op_cmp struct op_div struct op_eq struct op_ge struct op_gt struct op_int struct op_le struct op_lsh struct op_lt struct op_mod struct op_mul struct op_ne struct op_neg struct op_not struct op_or struct op_pos struct op_rsh struct op_sub struct op_un struct op_xor struct ord &lt;class T&gt; struct scalar_type &lt;class A&gt; struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; &lt;class T, M, N&gt; struct scalar_type&lt; vec&lt; T, M &gt; &gt; &lt;class T, M&gt; struct scalars&lt; T, U... &gt; &lt;class T, U&gt; struct scalars&lt;&gt; &lt;&gt; struct select struct seq &lt;I&gt; struct std_abs struct std_acos struct std_asin struct std_atan struct std_atan2 struct std_ceil struct std_copysign struct std_cos struct std_cosh struct std_exp struct std_floor struct std_fmod struct std_log struct std_log10 struct std_pow struct std_round struct std_sin struct std_sinh struct std_sqrt struct std_tan struct std_tanh struct identity_t struct mat&lt; T, M, 1 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 2 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 3 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 4 &gt; &lt;class T, M&gt; struct vec&lt; T, 1 &gt; &lt;class T&gt; struct vec&lt; T, 2 &gt; &lt;class T&gt; struct vec&lt; T, 3 &gt; &lt;class T&gt; struct vec&lt; T, 4 &gt; &lt;class T&gt; struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; &lt;class T&gt;"},{"location":"api/linalg_8hpp/#macros","title":"Macros","text":"Type Name define LINALG_CONSTEXPR14 define LINALG_H"},{"location":"api/linalg_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/linalg_8hpp/#define-linalg_constexpr14","title":"define LINALG_CONSTEXPR14","text":"<pre><code>#define LINALG_CONSTEXPR14 \n</code></pre>"},{"location":"api/linalg_8hpp/#define-linalg_h","title":"define LINALG_H","text":"<pre><code>#define LINALG_H \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/linalg_8hpp_source/","title":"File linalg.hpp","text":"<p>File List &gt; common &gt; linalg.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// linalg.h - v2.0 - Single-header public domain linear algebra library\n//\n// The intent of this library is to provide the bulk of the functionality\n// you need to write programs that frequently use small, fixed-size vectors\n// and matrices, in domains such as computational geometry or computer\n// graphics. It strives for terse, readable source code.\n//\n// The original author of this software is Sterling Orsten, and its permanent\n// home is &lt;http://github.com/sgorsten/linalg/&gt;. If you find this software\n// useful, an acknowledgement in your source text and/or product documentation\n// is appreciated, but not required.\n//\n// The author acknowledges significant insights and contributions by:\n//     Stan Melax &lt;http://github.com/melax/&gt;\n//     Dimitri Diakopoulos &lt;http://github.com/ddiakopoulos/&gt;\n\n\n\n// This is free and unencumbered software released into the public domain.\n// \n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n// \n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n// \n// For more information, please refer to &lt;http://unlicense.org/&gt;\n\n\n\n#pragma once\n#ifndef LINALG_H\n#define LINALG_H\n\n#include &lt;cmath&gt;        // For various unary math functions, such as std::sqrt\n#include &lt;cstdlib&gt;      // To resolve std::abs ambiguity on clang\n#include &lt;cstdint&gt;      // For implementing namespace linalg::aliases\n#include &lt;array&gt;        // For std::array\n#include &lt;iosfwd&gt;       // For forward definitions of std::ostream\n#include &lt;type_traits&gt;  // For std::enable_if, std::is_same, std::declval\n\n// In Visual Studio 2015, `constexpr` applied to a member function implies `const`, which causes ambiguous overload resolution\n#if _MSC_VER &lt;= 1900\n#define LINALG_CONSTEXPR14\n#else\n#define LINALG_CONSTEXPR14 constexpr\n#endif\n\nnamespace linalg\n{\n    // Small, fixed-length vector type, consisting of exactly M elements of type T, and presumed to be a column-vector unless otherwise noted.\n    template&lt;class T, int M&gt; struct vec;\n\n    // Small, fixed-size matrix type, consisting of exactly M rows and N columns of type T, stored in column-major order.\n    template&lt;class T, int M, int N&gt; struct mat;\n\n    // Specialize converter&lt;T,U&gt; with a function application operator that converts type U to type T to enable implicit conversions\n    template&lt;class T, class U&gt; struct converter {};\n    namespace detail \n    { \n        template&lt;class T, class U&gt; using conv_t = typename std::enable_if&lt;!std::is_same&lt;T,U&gt;::value, decltype(converter&lt;T,U&gt;{}(std::declval&lt;U&gt;()))&gt;::type;\n\n        // Trait for retrieving scalar type of any linear algebra object\n        template&lt;class A&gt; struct scalar_type {};\n        template&lt;class T, int M       &gt; struct scalar_type&lt;vec&lt;T,M  &gt;&gt; { using type = T; };\n        template&lt;class T, int M, int N&gt; struct scalar_type&lt;mat&lt;T,M,N&gt;&gt; { using type = T; };\n\n        // Type returned by the compare(...) function which supports all six comparison operators against 0\n        template&lt;class T&gt; struct ord { T a,b; };\n        template&lt;class T&gt; constexpr bool operator == (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.a == o.b; }\n        template&lt;class T&gt; constexpr bool operator != (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.a == o.b); }\n        template&lt;class T&gt; constexpr bool operator &lt; (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.a &lt; o.b; }\n        template&lt;class T&gt; constexpr bool operator &gt; (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.b &lt; o.a; }\n        template&lt;class T&gt; constexpr bool operator &lt;= (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.b &lt; o.a); }\n        template&lt;class T&gt; constexpr bool operator &gt;= (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.a &lt; o.b); }\n\n        // Patterns which can be used with the compare(...) function\n        template&lt;class A, class B&gt; struct any_compare {};\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,1&gt;,vec&lt;T,1&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,1&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) const { return ord&lt;T&gt;{a.x,b.x}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,2&gt;,vec&lt;T,2&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : ord&lt;T&gt;{a.y,b.y}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,3&gt;,vec&lt;T,3&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : !(a.y==b.y) ? ord&lt;T&gt;{a.y,b.y} : ord&lt;T&gt;{a.z,b.z}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,4&gt;,vec&lt;T,4&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : !(a.y==b.y) ? ord&lt;T&gt;{a.y,b.y} : !(a.z==b.z) ? ord&lt;T&gt;{a.z,b.z} : ord&lt;T&gt;{a.w,b.w}; } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,1&gt;,mat&lt;T,M,1&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,1&gt; &amp; a, const mat&lt;T,M,1&gt; &amp; b) const { return compare(a.x,b.x); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,2&gt;,mat&lt;T,M,2&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,2&gt; &amp; a, const mat&lt;T,M,2&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : compare(a.y,b.y); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,3&gt;,mat&lt;T,M,3&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,3&gt; &amp; a, const mat&lt;T,M,3&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : a.y!=b.y ? compare(a.y,b.y) : compare(a.z,b.z); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,4&gt;,mat&lt;T,M,4&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,4&gt; &amp; a, const mat&lt;T,M,4&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : a.y!=b.y ? compare(a.y,b.y) : a.z!=b.z ? compare(a.z,b.z) : compare(a.w,b.w); } }; \n\n        // Helper for compile-time index-based access to members of vector and matrix types\n        template&lt;int I&gt; struct getter;\n        template&lt;&gt; struct getter&lt;0&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.x) { return a.x; } };\n        template&lt;&gt; struct getter&lt;1&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.y) { return a.y; } };\n        template&lt;&gt; struct getter&lt;2&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.z) { return a.z; } };\n        template&lt;&gt; struct getter&lt;3&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.w) { return a.w; } };\n\n        // Stand-in for std::integer_sequence/std::make_integer_sequence\n        template&lt;int... I&gt; struct seq {};\n        template&lt;int A, int N&gt; struct make_seq_impl;\n        template&lt;int A&gt; struct make_seq_impl&lt;A,0&gt; { using type=seq&lt;&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,1&gt; { using type=seq&lt;A+0&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,2&gt; { using type=seq&lt;A+0,A+1&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,3&gt; { using type=seq&lt;A+0,A+1,A+2&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,4&gt; { using type=seq&lt;A+0,A+1,A+2,A+3&gt;; };\n        template&lt;int A, int B&gt; using make_seq = typename make_seq_impl&lt;A,B-A&gt;::type;\n        template&lt;class T, int M, int... I&gt; vec&lt;T,sizeof...(I)&gt; constexpr swizzle(const vec&lt;T,M&gt; &amp; v, seq&lt;I...&gt;) { return {getter&lt;I&gt;{}(v)...}; }\n        template&lt;class T, int M, int N, int... I, int... J&gt; mat&lt;T,sizeof...(I),sizeof...(J)&gt; constexpr swizzle(const mat&lt;T,M,N&gt; &amp; m, seq&lt;I...&gt; i, seq&lt;J...&gt;) { return {swizzle(getter&lt;J&gt;{}(m),i)...}; }\n\n        // SFINAE helpers to determine result of function application\n        template&lt;class F, class... T&gt; using ret_t = decltype(std::declval&lt;F&gt;()(std::declval&lt;T&gt;()...));\n\n        // SFINAE helper which is defined if all provided types are scalars\n        struct empty {};\n        template&lt;class... T&gt; struct scalars;\n        template&lt;&gt; struct scalars&lt;&gt; { using type=void; };\n        template&lt;class T, class... U&gt; struct scalars&lt;T,U...&gt; : std::conditional&lt;std::is_arithmetic&lt;T&gt;::value, scalars&lt;U...&gt;, empty&gt;::type {};\n        template&lt;class... T&gt; using scalars_t = typename scalars&lt;T...&gt;::type;\n\n        // Helpers which indicate how apply(F, ...) should be called for various arguments\n        template&lt;class F, class Void, class... T&gt; struct apply {}; // Patterns which contain only vectors or scalars\n        template&lt;class F, int M, class A                  &gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;                    &gt; { using type=vec&lt;ret_t&lt;F,A    &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a                                        ) { return {f(getter&lt;I&gt;{}(a)                                )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;          &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b                    ) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b)                )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;B  &gt;, vec&lt;A,M&gt;, B                 &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b                    ) { return {f(getter&lt;I&gt;{}(a), b                             )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;A  &gt;, A,        vec&lt;B,M&gt;          &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b                    ) { return {f(a,              getter&lt;I&gt;{}(b)                )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;, vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b, const vec&lt;C,M&gt; &amp; c) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b), getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;C  &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;, C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b, C                c) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b), c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;B  &gt;, vec&lt;A,M&gt;, B,        vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b, const vec&lt;C,M&gt; &amp; c) { return {f(getter&lt;I&gt;{}(a), b,              getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;B,C&gt;, vec&lt;A,M&gt;, B,        C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b, C                c) { return {f(getter&lt;I&gt;{}(a), b,              c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A  &gt;, A,        vec&lt;B,M&gt;, vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b, const vec&lt;C,M&gt; &amp; c) { return {f(a,              getter&lt;I&gt;{}(b), getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A,C&gt;, A,        vec&lt;B,M&gt;, C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b, C                c) { return {f(a,              getter&lt;I&gt;{}(b), c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A,B&gt;, A,        B,        vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, B                b, const vec&lt;C,M&gt; &amp; c) { return {f(a,              b,              getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, int N, class A         &gt; struct apply&lt;F, scalars_t&lt; &gt;, mat&lt;A,M,N&gt;            &gt; { using type=mat&lt;ret_t&lt;F,A  &gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a                      ) { return {apply&lt;F, void, vec&lt;A,M&gt;          &gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a)                )...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt; &gt;, mat&lt;A,M,N&gt;, mat&lt;B,M,N&gt;&gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a, const mat&lt;B,M,N&gt; &amp; b) { return {apply&lt;F, void, vec&lt;A,M&gt;, vec&lt;B,M&gt;&gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a), getter&lt;J&gt;{}(b))...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt;B&gt;, mat&lt;A,M,N&gt;, B         &gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a, B                  b) { return {apply&lt;F, void, vec&lt;A,M&gt;, B       &gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a), b             )...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt;A&gt;, A,          mat&lt;B,M,N&gt;&gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, A                  a, const mat&lt;B,M,N&gt; &amp; b) { return {apply&lt;F, void, A,        vec&lt;B,M&gt;&gt;::impl(make_seq&lt;0,M&gt;{}, f, a,              getter&lt;J&gt;{}(b))...}; } };\n        template&lt;class F, class... A&gt; struct apply&lt;F, scalars_t&lt;A...&gt;, A...&gt; { using type = ret_t&lt;F,A...&gt;; enum {size=0}; static constexpr type impl(seq&lt;&gt;, F f, A... a) { return f(a...); } };\n\n        // Function objects for selecting between alternatives\n        struct min    { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? a : b)&gt;::type { return a&lt;b ? a : b; } };\n        struct max    { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? b : a)&gt;::type { return a&lt;b ? b : a; } };\n        struct clamp  { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? b : a&lt;c ? a : c)&gt;::type { return a&lt;b ? b : a&lt;c ? a : c; } };\n        struct select { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; typename std::remove_reference&lt;decltype(a ? b : c)&gt;::type             { return a ? b : c; } };\n        struct lerp   { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; decltype(a*(1-c) + b*c)                                               { return a*(1-c) + b*c; } };\n\n        // Function objects for applying operators\n        struct op_pos { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(+a) { return +a; } };\n        struct op_neg { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(-a) { return -a; } };\n        struct op_not { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(!a) { return !a; } };\n        struct op_cmp { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(~(a)) { return ~a; } };\n        struct op_mul { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a * b)  { return a * b; } };\n        struct op_div { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a / b)  { return a / b; } };\n        struct op_mod { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a % b)  { return a % b; } };\n        struct op_add { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a + b)  { return a + b; } };\n        struct op_sub { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a - b)  { return a - b; } };\n        struct op_lsh { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt;&lt; b) { return a &lt;&lt; b; } };\n        struct op_rsh { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt;&gt; b) { return a &gt;&gt; b; } };\n        struct op_lt  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt; b)  { return a &lt; b; } };\n        struct op_gt  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt; b)  { return a &gt; b; } };\n        struct op_le  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt;= b) { return a &lt;= b; } };\n        struct op_ge  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt;= b) { return a &gt;= b; } };\n        struct op_eq  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a == b) { return a == b; } };\n        struct op_ne  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a != b) { return a != b; } };\n        struct op_int { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &amp; b)  { return a &amp; b; } };        \n        struct op_xor { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a ^ b)  { return a ^ b; } };\n        struct op_un  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a | b)  { return a | b; } };\n        struct op_and { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &amp;&amp; b) { return a &amp;&amp; b; } };\n        struct op_or  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a || b) { return a || b; } };\n\n        // Function objects for applying standard library math functions\n        struct std_abs      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::abs  (a)) { return std::abs  (a); } };\n        struct std_floor    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::floor(a)) { return std::floor(a); } };\n        struct std_ceil     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::ceil (a)) { return std::ceil (a); } };\n        struct std_exp      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::exp  (a)) { return std::exp  (a); } };\n        struct std_log      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::log  (a)) { return std::log  (a); } };\n        struct std_log10    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::log10(a)) { return std::log10(a); } };\n        struct std_sqrt     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sqrt (a)) { return std::sqrt (a); } };\n        struct std_sin      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sin  (a)) { return std::sin  (a); } };\n        struct std_cos      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::cos  (a)) { return std::cos  (a); } };\n        struct std_tan      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::tan  (a)) { return std::tan  (a); } };\n        struct std_asin     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::asin (a)) { return std::asin (a); } };\n        struct std_acos     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::acos (a)) { return std::acos (a); } };\n        struct std_atan     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::atan (a)) { return std::atan (a); } };\n        struct std_sinh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sinh (a)) { return std::sinh (a); } };\n        struct std_cosh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::cosh (a)) { return std::cosh (a); } };\n        struct std_tanh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::tanh (a)) { return std::tanh (a); } };\n        struct std_round    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::round(a)) { return std::round(a); } };\n        struct std_fmod     { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::fmod    (a, b)) { return std::fmod    (a, b); } };\n        struct std_pow      { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::pow     (a, b)) { return std::pow     (a, b); } };\n        struct std_atan2    { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::atan2   (a, b)) { return std::atan2   (a, b); } };\n        struct std_copysign { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::copysign(a, b)) { return std::copysign(a, b); } };\n    }\n\n    // Small, fixed-length vector type, consisting of exactly M elements of type T, and presumed to be a column-vector unless otherwise noted\n    template&lt;class T&gt; struct vec&lt;T,1&gt;\n    {\n        T                           x;\n        constexpr                   vec()                               : x() {}\n        constexpr                   vec(const T &amp; x_)                   : x(x_) {}\n        // NOTE: vec&lt;T,1&gt; does NOT have a constructor from pointer, this can conflict with initializing its single element from zero\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,1&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x)) {}\n        constexpr const T &amp;         operator[] (int)   const            { return x; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int)                    { return x; }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,2&gt;\n    {\n        T                           x,y;\n        constexpr                   vec()                               : x(), y() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_)     : x(x_), y(y_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1]) {}\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,2&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:y; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:y; }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,3&gt;\n    {\n        T                           x,y,z;\n        constexpr                   vec()                               : x(), y(), z() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_, \n                                        const T &amp; z_)                   : x(x_), y(y_), z(z_) {}\n        constexpr                   vec(const vec&lt;T,2&gt; &amp; xy,\n                                        const T &amp; z_)                   : vec(xy.x, xy.y, z_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1], p[2]) {}\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,3&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y), static_cast&lt;T&gt;(v.z)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:i==1?y:z; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:i==1?y:z; }\n        constexpr const vec&lt;T,2&gt; &amp;  xy() const                          { return *reinterpret_cast&lt;const vec&lt;T,2&gt; *&gt;(this); }\n        vec&lt;T,2&gt; &amp;                  xy()                                { return *reinterpret_cast&lt;vec&lt;T,2&gt; *&gt;(this); }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,4&gt;\n    {\n        T                           x,y,z,w;\n        constexpr                   vec()                               : x(), y(), z(), w() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_,\n                                        const T &amp; z_, const T &amp; w_)     : x(x_), y(y_), z(z_), w(w_) {}\n        constexpr                   vec(const vec&lt;T,2&gt; &amp; xy, \n                                        const T &amp; z_, const T &amp; w_)     : vec(xy.x, xy.y, z_, w_) {}\n        constexpr                   vec(const vec&lt;T,3&gt; &amp; xyz,\n                                        const T &amp; w_)                   : vec(xyz.x, xyz.y, xyz.z, w_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s, s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1], p[2], p[3]) {}\n        template&lt;class U&gt; \n        constexpr explicit          vec(const vec&lt;U,4&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y), static_cast&lt;T&gt;(v.z), static_cast&lt;T&gt;(v.w)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:i==1?y:i==2?z:w; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:i==1?y:i==2?z:w; }\n        constexpr const vec&lt;T,2&gt; &amp;  xy() const                          { return *reinterpret_cast&lt;const vec&lt;T,2&gt; *&gt;(this); }\n        constexpr const vec&lt;T,3&gt; &amp;  xyz() const                         { return *reinterpret_cast&lt;const vec&lt;T,3&gt; *&gt;(this); }\n        vec&lt;T,2&gt; &amp;                  xy()                                { return *reinterpret_cast&lt;vec&lt;T,2&gt; *&gt;(this); }                \n        vec&lt;T,3&gt; &amp;                  xyz()                               { return *reinterpret_cast&lt;vec&lt;T,3&gt; *&gt;(this); }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n\n    // Small, fixed-size matrix type, consisting of exactly M rows and N columns of type T, stored in column-major order.\n    template&lt;class T, int M&gt; struct mat&lt;T,M,1&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x;\n        constexpr                   mat()                               : x() {}\n        constexpr                   mat(const V &amp; x_)                   : x(x_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,1&gt; &amp; m)           : mat(V(m.x)) {}\n        constexpr vec&lt;T,1&gt;          row(int i) const                    { return {x[i]}; }\n        constexpr const V &amp;         operator[] (int) const              { return x; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int)                    { return x; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,2&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y;\n        constexpr                   mat()                               : x(), y() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_)     : x(x_), y(y_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,2&gt; &amp; m)           : mat(V(m.x), V(m.y)) {}\n        constexpr vec&lt;T,2&gt;          row(int i) const                    { return {x[i], y[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:y; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:y; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,3&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y,z;\n        constexpr                   mat()                               : x(), y(), z() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_, \n                                        const V &amp; z_)                   : x(x_), y(y_), z(z_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s), z(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1), z(p+M*2) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,3&gt; &amp; m)           : mat(V(m.x), V(m.y), V(m.z)) {}\n        constexpr vec&lt;T,3&gt;          row(int i) const                    { return {x[i], y[i], z[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:j==1?y:z; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:j==1?y:z; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,4&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y,z,w;\n        constexpr                   mat()                               : x(), y(), z(), w() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_,\n                                        const V &amp; z_, const V &amp; w_)     : x(x_), y(y_), z(z_), w(w_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s), z(s), w(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1), z(p+M*2), w(p+M*3) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,4&gt; &amp; m)           : mat(V(m.x), V(m.y), V(m.z), V(m.w)) {}\n        constexpr vec&lt;T,4&gt;          row(int i) const                    { return {x[i], y[i], z[i], w[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:j==1?y:j==2?z:w; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:j==1?y:j==2?z:w; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n\n    // Define a type which will convert to the multiplicative identity of any square matrix\n    struct identity_t { constexpr explicit identity_t(int) {} };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,1,1&gt;, identity_t&gt; { mat&lt;T,1,1&gt; operator() (identity_t) const { return {vec&lt;T,1&gt;{1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,2,2&gt;, identity_t&gt; { mat&lt;T,2,2&gt; operator() (identity_t) const { return {{1,0},{0,1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,3,3&gt;, identity_t&gt; { mat&lt;T,3,3&gt; operator() (identity_t) const { return {{1,0,0},{0,1,0},{0,0,1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,4,4&gt;, identity_t&gt; { mat&lt;T,4,4&gt; operator() (identity_t) const { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}; } };\n    constexpr identity_t identity {1};\n\n    // Produce a scalar by applying f(A,B) -&gt; A to adjacent pairs of elements from a vec/mat in left-to-right/column-major order (matching the associativity of arithmetic and logical operators)\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,1&gt; &amp; b) { return f(a, b.x); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,2&gt; &amp; b) { return f(f(a, b.x), b.y); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,3&gt; &amp; b) { return f(f(f(a, b.x), b.y), b.z); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,4&gt; &amp; b) { return f(f(f(f(a, b.x), b.y), b.z), b.w); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,1&gt; &amp; b) { return fold(f, a, b.x); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,2&gt; &amp; b) { return fold(f, fold(f, a, b.x), b.y); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,3&gt; &amp; b) { return fold(f, fold(f, fold(f, a, b.x), b.y), b.z); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,4&gt; &amp; b) { return fold(f, fold(f, fold(f, fold(f, a, b.x), b.y), b.z), b.w); }\n\n    // Type aliases for the result of calling apply(...) with various arguments, can be used with return type SFINAE to constrian overload sets\n    template&lt;class F, class... A&gt; using apply_t = typename detail::apply&lt;F,void,A...&gt;::type;\n    template&lt;class A&gt; using scalar_t = typename detail::scalar_type&lt;A&gt;::type; // Underlying scalar type when performing elementwise operations\n\n    // apply(f,...) applies the provided function in an elementwise fashion to its arguments, producing an object of the same dimensions\n    template&lt;class F, class... A&gt; constexpr apply_t&lt;F,A...&gt; apply(F func, const A &amp; ... args) { return detail::apply&lt;F,void,A...&gt;::impl(detail::make_seq&lt;0,detail::apply&lt;F,void,A...&gt;::size&gt;{}, func, args...); }\n\n    // map(a,f) is equivalent to apply(f,a)\n    template&lt;class A, class F&gt; constexpr apply_t&lt;F,A&gt; map(const A &amp; a, F func) { return apply(func, a); }\n\n    // zip(a,b,f) is equivalent to apply(f,a,b)\n    template&lt;class A, class B, class F&gt; constexpr apply_t&lt;F,A,B&gt; zip(const A &amp; a, const B &amp; b, F func) { return apply(func, a, b); }\n\n    // Relational operators are defined to compare the elements of two vectors or matrices lexicographically, in column-major order\n    template&lt;class A, class B&gt; constexpr typename detail::any_compare&lt;A,B&gt;::type compare(const A &amp; a, const B &amp; b) { return detail::any_compare&lt;A,B&gt;()(a,b); }\n    template&lt;class A, class B&gt; constexpr auto operator == (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) == 0) { return compare(a,b) == 0; }\n    template&lt;class A, class B&gt; constexpr auto operator != (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) != 0) { return compare(a,b) != 0; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;  (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &lt;  0) { return compare(a,b) &lt;  0; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;  (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &gt;  0) { return compare(a,b) &gt;  0; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;= (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &lt;= 0) { return compare(a,b) &lt;= 0; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;= (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &gt;= 0) { return compare(a,b) &gt;= 0; }\n\n    // Functions for coalescing scalar values\n    template&lt;class A&gt; constexpr bool any (const A &amp; a) { return fold(detail::op_or{}, false, a); }\n    template&lt;class A&gt; constexpr bool all (const A &amp; a) { return fold(detail::op_and{}, true, a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; sum    (const A &amp; a) { return fold(detail::op_add{}, scalar_t&lt;A&gt;(0), a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; product(const A &amp; a) { return fold(detail::op_mul{}, scalar_t&lt;A&gt;(1), a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; minelem(const A &amp; a) { return fold(detail::min{}, a.x, a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; maxelem(const A &amp; a) { return fold(detail::max{}, a.x, a); }\n    template&lt;class T, int M&gt; int argmin(const vec&lt;T,M&gt; &amp; a) { int j=0; for(int i=1; i&lt;M; ++i) if(a[i] &lt; a[j]) j = i; return j; }\n    template&lt;class T, int M&gt; int argmax(const vec&lt;T,M&gt; &amp; a) { int j=0; for(int i=1; i&lt;M; ++i) if(a[i] &gt; a[j]) j = i; return j; }\n\n    // Unary operators are defined component-wise for linalg types\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_pos, A&gt; operator + (const A &amp; a) { return apply(detail::op_pos{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_neg, A&gt; operator - (const A &amp; a) { return apply(detail::op_neg{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_cmp, A&gt; operator ~ (const A &amp; a) { return apply(detail::op_cmp{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_not, A&gt; operator ! (const A &amp; a) { return apply(detail::op_not{}, a); }\n\n    // Binary operators are defined component-wise for linalg types\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_add, A, B&gt; operator +  (const A &amp; a, const B &amp; b) { return apply(detail::op_add{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_sub, A, B&gt; operator -  (const A &amp; a, const B &amp; b) { return apply(detail::op_sub{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_mul, A, B&gt; operator *  (const A &amp; a, const B &amp; b) { return apply(detail::op_mul{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_div, A, B&gt; operator /  (const A &amp; a, const B &amp; b) { return apply(detail::op_div{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_mod, A, B&gt; operator %  (const A &amp; a, const B &amp; b) { return apply(detail::op_mod{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_un,  A, B&gt; operator |  (const A &amp; a, const B &amp; b) { return apply(detail::op_un{},  a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_xor, A, B&gt; operator ^  (const A &amp; a, const B &amp; b) { return apply(detail::op_xor{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_int, A, B&gt; operator &amp;  (const A &amp; a, const B &amp; b) { return apply(detail::op_int{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_lsh, A, B&gt; operator &lt;&lt; (const A &amp; a, const B &amp; b) { return apply(detail::op_lsh{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_rsh, A, B&gt; operator &gt;&gt; (const A &amp; a, const B &amp; b) { return apply(detail::op_rsh{}, a, b); }\n\n    // Binary assignment operators a $= b is always defined as though it were explicitly written a = a $ b\n    template&lt;class A, class B&gt; constexpr auto operator +=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a + b) { return a = a + b; }\n    template&lt;class A, class B&gt; constexpr auto operator -=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a - b) { return a = a - b; }\n    template&lt;class A, class B&gt; constexpr auto operator *=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a * b) { return a = a * b; }\n    template&lt;class A, class B&gt; constexpr auto operator /=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a / b) { return a = a / b; }\n    template&lt;class A, class B&gt; constexpr auto operator %=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a % b) { return a = a % b; }\n    template&lt;class A, class B&gt; constexpr auto operator |=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a | b) { return a = a | b; }\n    template&lt;class A, class B&gt; constexpr auto operator ^=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a ^ b) { return a = a ^ b; }\n    template&lt;class A, class B&gt; constexpr auto operator &amp;=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a &amp; b) { return a = a &amp; b; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;&lt;= (A &amp; a, const B &amp; b) -&gt; decltype(a = a &lt;&lt; b) { return a = a &lt;&lt; b; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;&gt;= (A &amp; a, const B &amp; b) -&gt; decltype(a = a &gt;&gt; b) { return a = a &gt;&gt; b; }\n\n    // Swizzles and subobjects\n    template&lt;int... I, class T, int M&gt;                              constexpr vec&lt;T,sizeof...(I)&gt;   swizzle(const vec&lt;T,M&gt; &amp; a)   { return {detail::getter&lt;I&gt;(a)...}; }\n    template&lt;int I0, int I1, class T, int M&gt;                        constexpr vec&lt;T,I1-I0&gt;          subvec (const vec&lt;T,M&gt; &amp; a)   { return detail::swizzle(a, detail::make_seq&lt;I0,I1&gt;{}); }\n    template&lt;int I0, int J0, int I1, int J1, class T, int M, int N&gt; constexpr mat&lt;T,I1-I0,J1-J0&gt;    submat (const mat&lt;T,M,N&gt; &amp; a) { return detail::swizzle(a, detail::make_seq&lt;I0,I1&gt;{}, detail::make_seq&lt;J0,J1&gt;{}); }\n\n    // Component-wise standard library math functions\n    template&lt;class A&gt; apply_t&lt;detail::std_abs,   A&gt; abs  (const A &amp; a) { return apply(detail::std_abs{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_floor, A&gt; floor(const A &amp; a) { return apply(detail::std_floor{}, a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_ceil,  A&gt; ceil (const A &amp; a) { return apply(detail::std_ceil{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_exp,   A&gt; exp  (const A &amp; a) { return apply(detail::std_exp{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_log,   A&gt; log  (const A &amp; a) { return apply(detail::std_log{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_log10, A&gt; log10(const A &amp; a) { return apply(detail::std_log10{}, a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sqrt,  A&gt; sqrt (const A &amp; a) { return apply(detail::std_sqrt{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sin,   A&gt; sin  (const A &amp; a) { return apply(detail::std_sin{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_cos,   A&gt; cos  (const A &amp; a) { return apply(detail::std_cos{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_tan,   A&gt; tan  (const A &amp; a) { return apply(detail::std_tan{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_asin,  A&gt; asin (const A &amp; a) { return apply(detail::std_asin{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_acos,  A&gt; acos (const A &amp; a) { return apply(detail::std_acos{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_atan,  A&gt; atan (const A &amp; a) { return apply(detail::std_atan{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sinh,  A&gt; sinh (const A &amp; a) { return apply(detail::std_sinh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_cosh,  A&gt; cosh (const A &amp; a) { return apply(detail::std_cosh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_tanh,  A&gt; tanh (const A &amp; a) { return apply(detail::std_tanh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_round, A&gt; round(const A &amp; a) { return apply(detail::std_round{}, a); }\n\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_fmod,     A, B&gt; fmod    (const A &amp; a, const B &amp; b) { return apply(detail::std_fmod{},     a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_pow,      A, B&gt; pow     (const A &amp; a, const B &amp; b) { return apply(detail::std_pow{},      a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_atan2,    A, B&gt; atan2   (const A &amp; a, const B &amp; b) { return apply(detail::std_atan2{},    a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_copysign, A, B&gt; copysign(const A &amp; a, const B &amp; b) { return apply(detail::std_copysign{}, a, b); }\n\n    // Component-wise relational functions on vectors\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_eq, A, B&gt; equal  (const A &amp; a, const B &amp; b) { return apply(detail::op_eq{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_ne, A, B&gt; nequal (const A &amp; a, const B &amp; b) { return apply(detail::op_ne{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_lt, A, B&gt; less   (const A &amp; a, const B &amp; b) { return apply(detail::op_lt{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_gt, A, B&gt; greater(const A &amp; a, const B &amp; b) { return apply(detail::op_gt{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_le, A, B&gt; lequal (const A &amp; a, const B &amp; b) { return apply(detail::op_le{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_ge, A, B&gt; gequal (const A &amp; a, const B &amp; b) { return apply(detail::op_ge{}, a, b); }\n\n    // Component-wise selection functions on vectors\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::min, A, B&gt; min(const A &amp; a, const B &amp; b) { return apply(detail::min{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::max, A, B&gt; max(const A &amp; a, const B &amp; b) { return apply(detail::max{}, a, b); }\n    template&lt;class X, class L, class H&gt; constexpr apply_t&lt;detail::clamp,  X, L, H&gt; clamp (const X &amp; x, const L &amp; l, const H &amp; h) { return apply(detail::clamp{},  x, l, h); }\n    template&lt;class P, class A, class B&gt; constexpr apply_t&lt;detail::select, P, A, B&gt; select(const P &amp; p, const A &amp; a, const B &amp; b) { return apply(detail::select{}, p, a, b); }\n    template&lt;class A, class B, class T&gt; constexpr apply_t&lt;detail::lerp,   A, B, T&gt; lerp  (const A &amp; a, const B &amp; b, const T &amp; t) { return apply(detail::lerp{},   a, b, t); }\n\n    // Support for vector algebra\n    template&lt;class T&gt; constexpr T        cross    (const vec&lt;T,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b)      { return a.x*b.y-a.y*b.x; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; cross    (T a, const vec&lt;T,2&gt; &amp; b)                     { return {-a*b.y, a*b.x}; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; cross    (const vec&lt;T,2&gt; &amp; a, T b)                     { return {a.y*b, -a.x*b}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt; cross    (const vec&lt;T,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b)      { return {a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x}; }\n    template&lt;class T, int M&gt; constexpr T dot      (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return sum(a*b); }\n    template&lt;class T, int M&gt; constexpr T length2  (const vec&lt;T,M&gt; &amp; a)                          { return dot(a,a); }\n    template&lt;class T, int M&gt; T           length   (const vec&lt;T,M&gt; &amp; a)                          { return std::sqrt(length2(a)); }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    normalize(const vec&lt;T,M&gt; &amp; a)                          { return a / length(a); }\n    template&lt;class T, int M&gt; constexpr T distance2(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return length2(b-a); }\n    template&lt;class T, int M&gt; T           distance (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return length(b-a); }\n    template&lt;class T, int M&gt; T           uangle   (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { T d=dot(a,b); return d &gt; 1 ? 0 : std::acos(d &lt; -1 ? -1 : d); }\n    template&lt;class T, int M&gt; T           angle    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return uangle(normalize(a), normalize(b)); }\n    template&lt;class T&gt; vec&lt;T,2&gt;           rot      (T a, const vec&lt;T,2&gt; &amp; v)                     { const T s = std::sin(a), c = std::cos(a); return {v.x*c - v.y*s, v.x*s + v.y*c}; }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    nlerp    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b, T t) { return normalize(lerp(a,b,t)); }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    slerp    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b, T t) { T th=uangle(a,b); return th == 0 ? a : a*(std::sin(th*(1-t))/std::sin(th)) + b*(std::sin(th*t)/std::sin(th)); }\n\n    // Support for quaternion algebra using 4D vectors, representing xi + yj + zk + w\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; qconj(const vec&lt;T,4&gt; &amp; q)                     { return {-q.x,-q.y,-q.z,q.w}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qinv (const vec&lt;T,4&gt; &amp; q)                     { return qconj(q)/length2(q); }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qexp (const vec&lt;T,4&gt; &amp; q)                     { const auto v = q.xyz(); const auto vv = length(v); return std::exp(q.w) * vec&lt;T,4&gt;{v * (vv &gt; 0 ? std::sin(vv)/vv : 0), std::cos(vv)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qlog (const vec&lt;T,4&gt; &amp; q)                     { const auto v = q.xyz(); const auto vv = length(v), qq = length(q); return {v * (vv &gt; 0 ? std::acos(q.w/qq)/vv : 0), std::log(qq)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qpow (const vec&lt;T,4&gt; &amp; q, const T &amp; p)        { const auto v = q.xyz(); const auto vv = length(v), qq = length(q), th = std::acos(q.w/qq); return std::pow(qq,p)*vec&lt;T,4&gt;{v * (vv &gt; 0 ? std::sin(p*th)/vv : 0), std::cos(p*th)}; }\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; qmul (const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return {a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y, a.y*b.w+a.w*b.y+a.z*b.x-a.x*b.z, a.z*b.w+a.w*b.z+a.x*b.y-a.y*b.x, a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z}; }\n    template&lt;class T, class... R&gt; constexpr vec&lt;T,4&gt; qmul(const vec&lt;T,4&gt; &amp; a, R... r)  { return qmul(a, qmul(r...)); }\n\n    // Support for 3D spatial rotations using quaternions, via qmul(qmul(q, v), qconj(q))\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qxdir (const vec&lt;T,4&gt; &amp; q)                          { return {q.w*q.w+q.x*q.x-q.y*q.y-q.z*q.z, (q.x*q.y+q.z*q.w)*2, (q.z*q.x-q.y*q.w)*2}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qydir (const vec&lt;T,4&gt; &amp; q)                          { return {(q.x*q.y-q.z*q.w)*2, q.w*q.w-q.x*q.x+q.y*q.y-q.z*q.z, (q.y*q.z+q.x*q.w)*2}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qzdir (const vec&lt;T,4&gt; &amp; q)                          { return {(q.z*q.x+q.y*q.w)*2, (q.y*q.z-q.x*q.w)*2, q.w*q.w-q.x*q.x-q.y*q.y+q.z*q.z}; }\n    template&lt;class T&gt; constexpr mat&lt;T,3,3&gt; qmat  (const vec&lt;T,4&gt; &amp; q)                          { return {qxdir(q), qydir(q), qzdir(q)}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qrot  (const vec&lt;T,4&gt; &amp; q, const vec&lt;T,3&gt; &amp; v)      { return qxdir(q)*v.x + qydir(q)*v.y + qzdir(q)*v.z; }\n    template&lt;class T&gt; T                    qangle(const vec&lt;T,4&gt; &amp; q)                          { return std::atan2(length(q.xyz()), q.w)*2; }\n    template&lt;class T&gt; vec&lt;T,3&gt;             qaxis (const vec&lt;T,4&gt; &amp; q)                          { return normalize(q.xyz()); }\n    template&lt;class T&gt; vec&lt;T,4&gt;             qnlerp(const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b, T t) { return nlerp(a, dot(a,b) &lt; 0 ? -b : b, t); }\n    template&lt;class T&gt; vec&lt;T,4&gt;             qslerp(const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b, T t) { return slerp(a, dot(a,b) &lt; 0 ? -b : b, t); }\n\n    // Support for matrix algebra\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,1&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) { return a.x*b.x; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) { return a.x*b.x + a.y*b.y; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,1&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,1&gt; &amp; b) { return {mul(a,b.x)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,2&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,2&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,3&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,3&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y), mul(a,b.z)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,4&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,4&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y), mul(a,b.z), mul(a,b.w)}; }\n    template&lt;class T, int M, int N, int P&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const vec&lt;T,P&gt; &amp; c) { return mul(mul(a,b),c); }\n    template&lt;class T, int M, int N, int P, int Q&gt; constexpr mat&lt;T,M,Q&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c) { return mul(mul(a,b),c); }\n    template&lt;class T, int M, int N, int P, int Q&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c, const vec&lt;T,Q&gt; &amp; d) { return mul(mul(a,b,c),d); }\n    template&lt;class T, int M, int N, int P, int Q, int R&gt; constexpr mat&lt;T,M,R&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c, const mat&lt;T,Q,R&gt; &amp; d) { return mul(mul(a,b,c),d); }\n    // TODO: Variadic version of mul(...) that works on all compilers\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,1&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) { return {a*b.x}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,2&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) { return {a*b.x, a*b.y}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,3&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) { return {a*b.x, a*b.y, a*b.z}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,4&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return {a*b.x, a*b.y, a*b.z, a*b.w}; }\n    template&lt;class T&gt; constexpr vec&lt;T,1&gt; diagonal(const mat&lt;T,1,1&gt; &amp; a) { return {a.x.x}; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; diagonal(const mat&lt;T,2,2&gt; &amp; a) { return {a.x.x, a.y.y}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt; diagonal(const mat&lt;T,3,3&gt; &amp; a) { return {a.x.x, a.y.y, a.z.z}; }\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; diagonal(const mat&lt;T,4,4&gt; &amp; a) { return {a.x.x, a.y.y, a.z.z, a.w.w}; }\n    template&lt;class T, int N&gt; constexpr T trace(const mat&lt;T,N,N&gt; &amp; a) { return sum(diagonal(a)); }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,1&gt; transpose(const mat&lt;T,1,M&gt; &amp; m) { return {m.row(0)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,2&gt; transpose(const mat&lt;T,2,M&gt; &amp; m) { return {m.row(0), m.row(1)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,3&gt; transpose(const mat&lt;T,3,M&gt; &amp; m) { return {m.row(0), m.row(1), m.row(2)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,4&gt; transpose(const mat&lt;T,4,M&gt; &amp; m) { return {m.row(0), m.row(1), m.row(2), m.row(3)}; }\n    template&lt;class T&gt; constexpr mat&lt;T,1,1&gt; adjugate(const mat&lt;T,1,1&gt; &amp;)   { return {vec&lt;T,1&gt;{1}}; }\n    template&lt;class T&gt; constexpr mat&lt;T,2,2&gt; adjugate(const mat&lt;T,2,2&gt; &amp; a) { return {{a.y.y, -a.x.y}, {-a.y.x, a.x.x}}; }\n    template&lt;class T&gt; constexpr mat&lt;T,3,3&gt; adjugate(const mat&lt;T,3,3&gt; &amp; a);\n    template&lt;class T&gt; constexpr mat&lt;T,4,4&gt; adjugate(const mat&lt;T,4,4&gt; &amp; a);\n    template&lt;class T, int N&gt; constexpr mat&lt;T,N,N&gt; comatrix(const mat&lt;T,N,N&gt; &amp; a) { return transpose(adjugate(a)); }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,1,1&gt; &amp; a) { return a.x.x; }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,2,2&gt; &amp; a) { return a.x.x*a.y.y - a.x.y*a.y.x; }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,3,3&gt; &amp; a) { return a.x.x*(a.y.y*a.z.z - a.z.y*a.y.z) + a.x.y*(a.y.z*a.z.x - a.z.z*a.y.x) + a.x.z*(a.y.x*a.z.y - a.z.x*a.y.y); }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,4,4&gt; &amp; a);\n    template&lt;class T, int N&gt; constexpr mat&lt;T,N,N&gt; inverse(const mat&lt;T,N,N&gt; &amp; a) { return adjugate(a)/determinant(a); }\n\n    // Vectors and matrices can be used as ranges\n    template&lt;class T, int M&gt;       T * begin(      vec&lt;T,M&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M&gt; const T * begin(const vec&lt;T,M&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M&gt;       T * end  (      vec&lt;T,M&gt; &amp; a) { return begin(a) + M; }\n    template&lt;class T, int M&gt; const T * end  (const vec&lt;T,M&gt; &amp; a) { return begin(a) + M; }\n    template&lt;class T, int M, int N&gt;       vec&lt;T,M&gt; * begin(      mat&lt;T,M,N&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M, int N&gt; const vec&lt;T,M&gt; * begin(const mat&lt;T,M,N&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M, int N&gt;       vec&lt;T,M&gt; * end  (      mat&lt;T,M,N&gt; &amp; a) { return begin(a) + N; }\n    template&lt;class T, int M, int N&gt; const vec&lt;T,M&gt; * end  (const mat&lt;T,M,N&gt; &amp; a) { return begin(a) + N; }\n\n    // Factory functions for 3D spatial transformations (will possibly be removed or changed in a future version)\n    enum fwd_axis { neg_z, pos_z };                 // Should projection matrices be generated assuming forward is {0,0,-1} or {0,0,1}\n    enum z_range { neg_one_to_one, zero_to_one };   // Should projection matrices map z into the range of [-1,1] or [0,1]?\n    template&lt;class T&gt; vec&lt;T,4&gt;   rotation_quat     (const vec&lt;T,3&gt; &amp; axis, T angle)         { return {axis*std::sin(angle/2), std::cos(angle/2)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;   rotation_quat     (const mat&lt;T,3,3&gt; &amp; m);\n    template&lt;class T&gt; mat&lt;T,4,4&gt; translation_matrix(const vec&lt;T,3&gt; &amp; translation)           { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{translation,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; rotation_matrix   (const vec&lt;T,4&gt; &amp; rotation)              { return {{qxdir(rotation),0}, {qydir(rotation),0}, {qzdir(rotation),0}, {0,0,0,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; scaling_matrix    (const vec&lt;T,3&gt; &amp; scaling)               { return {{scaling.x,0,0,0}, {0,scaling.y,0,0}, {0,0,scaling.z,0}, {0,0,0,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; pose_matrix       (const vec&lt;T,4&gt; &amp; q, const vec&lt;T,3&gt; &amp; p) { return {{qxdir(q),0}, {qydir(q),0}, {qzdir(q),0}, {p,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; frustum_matrix    (T x0, T x1, T y0, T y1, T n, T f, fwd_axis a = neg_z, z_range z = neg_one_to_one);\n    template&lt;class T&gt; mat&lt;T,4,4&gt; perspective_matrix(T fovy, T aspect, T n, T f, fwd_axis a = neg_z, z_range z = neg_one_to_one) { T y = n*std::tan(fovy / 2), x = y*aspect; return frustum_matrix(-x, x, -y, y, n, f, a, z); }\n\n    // Provide implicit conversion between linalg::vec&lt;T,M&gt; and std::array&lt;T,M&gt;\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,1&gt;, std::array&lt;T,1&gt;&gt; { vec&lt;T,1&gt; operator() (const std::array&lt;T,1&gt; &amp; a) const { return {a[0]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,2&gt;, std::array&lt;T,2&gt;&gt; { vec&lt;T,2&gt; operator() (const std::array&lt;T,2&gt; &amp; a) const { return {a[0], a[1]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,3&gt;, std::array&lt;T,3&gt;&gt; { vec&lt;T,3&gt; operator() (const std::array&lt;T,3&gt; &amp; a) const { return {a[0], a[1], a[2]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,4&gt;, std::array&lt;T,4&gt;&gt; { vec&lt;T,4&gt; operator() (const std::array&lt;T,4&gt; &amp; a) const { return {a[0], a[1], a[2], a[3]}; } };\n\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,1&gt;, vec&lt;T,1&gt;&gt; { std::array&lt;T,1&gt; operator() (const vec&lt;T,1&gt; &amp; a) const { return {a[0]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,2&gt;, vec&lt;T,2&gt;&gt; { std::array&lt;T,2&gt; operator() (const vec&lt;T,2&gt; &amp; a) const { return {a[0], a[1]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,3&gt;, vec&lt;T,3&gt;&gt; { std::array&lt;T,3&gt; operator() (const vec&lt;T,3&gt; &amp; a) const { return {a[0], a[1], a[2]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,4&gt;, vec&lt;T,4&gt;&gt; { std::array&lt;T,4&gt; operator() (const vec&lt;T,4&gt; &amp; a) const { return {a[0], a[1], a[2], a[3]}; } };\n\n    // Provide typedefs for common element types and vector/matrix sizes\n    namespace aliases\n    {\n        typedef vec&lt;bool,1&gt; bool1; typedef vec&lt;uint8_t,1&gt; byte1; typedef vec&lt;int16_t,1&gt; short1; typedef vec&lt;uint16_t,1&gt; ushort1;\n        typedef vec&lt;bool,2&gt; bool2; typedef vec&lt;uint8_t,2&gt; byte2; typedef vec&lt;int16_t,2&gt; short2; typedef vec&lt;uint16_t,2&gt; ushort2; \n        typedef vec&lt;bool,3&gt; bool3; typedef vec&lt;uint8_t,3&gt; byte3; typedef vec&lt;int16_t,3&gt; short3; typedef vec&lt;uint16_t,3&gt; ushort3; \n        typedef vec&lt;bool,4&gt; bool4; typedef vec&lt;uint8_t,4&gt; byte4; typedef vec&lt;int16_t,4&gt; short4; typedef vec&lt;uint16_t,4&gt; ushort4;\n        typedef vec&lt;int,1&gt; int1; typedef vec&lt;unsigned,1&gt; uint1; typedef vec&lt;float,1&gt; float1; typedef vec&lt;double,1&gt; double1;\n        typedef vec&lt;int,2&gt; int2; typedef vec&lt;unsigned,2&gt; uint2; typedef vec&lt;float,2&gt; float2; typedef vec&lt;double,2&gt; double2;\n        typedef vec&lt;int,3&gt; int3; typedef vec&lt;unsigned,3&gt; uint3; typedef vec&lt;float,3&gt; float3; typedef vec&lt;double,3&gt; double3;\n        typedef vec&lt;int,4&gt; int4; typedef vec&lt;unsigned,4&gt; uint4; typedef vec&lt;float,4&gt; float4; typedef vec&lt;double,4&gt; double4;\n        typedef mat&lt;bool,1,1&gt; bool1x1; typedef mat&lt;int,1,1&gt; int1x1; typedef mat&lt;float,1,1&gt; float1x1; typedef mat&lt;double,1,1&gt; double1x1;\n        typedef mat&lt;bool,1,2&gt; bool1x2; typedef mat&lt;int,1,2&gt; int1x2; typedef mat&lt;float,1,2&gt; float1x2; typedef mat&lt;double,1,2&gt; double1x2;\n        typedef mat&lt;bool,1,3&gt; bool1x3; typedef mat&lt;int,1,3&gt; int1x3; typedef mat&lt;float,1,3&gt; float1x3; typedef mat&lt;double,1,3&gt; double1x3;\n        typedef mat&lt;bool,1,4&gt; bool1x4; typedef mat&lt;int,1,4&gt; int1x4; typedef mat&lt;float,1,4&gt; float1x4; typedef mat&lt;double,1,4&gt; double1x4;\n        typedef mat&lt;bool,2,1&gt; bool2x1; typedef mat&lt;int,2,1&gt; int2x1; typedef mat&lt;float,2,1&gt; float2x1; typedef mat&lt;double,2,1&gt; double2x1;\n        typedef mat&lt;bool,2,2&gt; bool2x2; typedef mat&lt;int,2,2&gt; int2x2; typedef mat&lt;float,2,2&gt; float2x2; typedef mat&lt;double,2,2&gt; double2x2;\n        typedef mat&lt;bool,2,3&gt; bool2x3; typedef mat&lt;int,2,3&gt; int2x3; typedef mat&lt;float,2,3&gt; float2x3; typedef mat&lt;double,2,3&gt; double2x3;\n        typedef mat&lt;bool,2,4&gt; bool2x4; typedef mat&lt;int,2,4&gt; int2x4; typedef mat&lt;float,2,4&gt; float2x4; typedef mat&lt;double,2,4&gt; double2x4;\n        typedef mat&lt;bool,3,1&gt; bool3x1; typedef mat&lt;int,3,1&gt; int3x1; typedef mat&lt;float,3,1&gt; float3x1; typedef mat&lt;double,3,1&gt; double3x1;\n        typedef mat&lt;bool,3,2&gt; bool3x2; typedef mat&lt;int,3,2&gt; int3x2; typedef mat&lt;float,3,2&gt; float3x2; typedef mat&lt;double,3,2&gt; double3x2;\n        typedef mat&lt;bool,3,3&gt; bool3x3; typedef mat&lt;int,3,3&gt; int3x3; typedef mat&lt;float,3,3&gt; float3x3; typedef mat&lt;double,3,3&gt; double3x3;\n        typedef mat&lt;bool,3,4&gt; bool3x4; typedef mat&lt;int,3,4&gt; int3x4; typedef mat&lt;float,3,4&gt; float3x4; typedef mat&lt;double,3,4&gt; double3x4;\n        typedef mat&lt;bool,4,1&gt; bool4x1; typedef mat&lt;int,4,1&gt; int4x1; typedef mat&lt;float,4,1&gt; float4x1; typedef mat&lt;double,4,1&gt; double4x1;\n        typedef mat&lt;bool,4,2&gt; bool4x2; typedef mat&lt;int,4,2&gt; int4x2; typedef mat&lt;float,4,2&gt; float4x2; typedef mat&lt;double,4,2&gt; double4x2;\n        typedef mat&lt;bool,4,3&gt; bool4x3; typedef mat&lt;int,4,3&gt; int4x3; typedef mat&lt;float,4,3&gt; float4x3; typedef mat&lt;double,4,3&gt; double4x3;\n        typedef mat&lt;bool,4,4&gt; bool4x4; typedef mat&lt;int,4,4&gt; int4x4; typedef mat&lt;float,4,4&gt; float4x4; typedef mat&lt;double,4,4&gt; double4x4;\n    }\n\n    // Provide output streaming operators, writing something that resembles an aggregate literal that could be used to construct the specified value\n    namespace ostream_overloads\n    {\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,1&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,2&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,3&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; ',' &lt;&lt; v[2] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,4&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; ',' &lt;&lt; v[2] &lt;&lt; ',' &lt;&lt; v[3] &lt;&lt; '}'; }\n\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,1&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,2&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,3&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; ',' &lt;&lt; m[2] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,4&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; ',' &lt;&lt; m[2] &lt;&lt; ',' &lt;&lt; m[3] &lt;&lt; '}'; }\n    }\n}\n\nnamespace std \n{ \n    // Provide specializations for std::hash&lt;...&gt; with linalg types\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,1&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,1&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,2&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,2&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,3&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,3&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1) ^ (h(v.z) &lt;&lt; 2); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,4&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,4&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1) ^ (h(v.z) &lt;&lt; 2) ^ (h(v.w) &lt;&lt; 3); } };\n\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,1&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,1&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,2&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,2&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,3&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,3&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M) ^ (h(v.z) &lt;&lt; (M*2)); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,4&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,4&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M) ^ (h(v.z) &lt;&lt; (M*2)) ^ (h(v.w) &lt;&lt; (M*3)); } };\n}\n\n// Definitions of functions too long to be defined inline\ntemplate&lt;class T&gt; constexpr linalg::mat&lt;T,3,3&gt; linalg::adjugate(const mat&lt;T,3,3&gt; &amp; a) \n{ \n    return {{a.y.y*a.z.z - a.z.y*a.y.z, a.z.y*a.x.z - a.x.y*a.z.z, a.x.y*a.y.z - a.y.y*a.x.z},\n            {a.y.z*a.z.x - a.z.z*a.y.x, a.z.z*a.x.x - a.x.z*a.z.x, a.x.z*a.y.x - a.y.z*a.x.x},\n            {a.y.x*a.z.y - a.z.x*a.y.y, a.z.x*a.x.y - a.x.x*a.z.y, a.x.x*a.y.y - a.y.x*a.x.y}}; \n}\n\ntemplate&lt;class T&gt; constexpr linalg::mat&lt;T,4,4&gt; linalg::adjugate(const mat&lt;T,4,4&gt; &amp; a) \n{ \n    return {{a.y.y*a.z.z*a.w.w + a.w.y*a.y.z*a.z.w + a.z.y*a.w.z*a.y.w - a.y.y*a.w.z*a.z.w - a.z.y*a.y.z*a.w.w - a.w.y*a.z.z*a.y.w,\n             a.x.y*a.w.z*a.z.w + a.z.y*a.x.z*a.w.w + a.w.y*a.z.z*a.x.w - a.w.y*a.x.z*a.z.w - a.z.y*a.w.z*a.x.w - a.x.y*a.z.z*a.w.w,\n             a.x.y*a.y.z*a.w.w + a.w.y*a.x.z*a.y.w + a.y.y*a.w.z*a.x.w - a.x.y*a.w.z*a.y.w - a.y.y*a.x.z*a.w.w - a.w.y*a.y.z*a.x.w,\n             a.x.y*a.z.z*a.y.w + a.y.y*a.x.z*a.z.w + a.z.y*a.y.z*a.x.w - a.x.y*a.y.z*a.z.w - a.z.y*a.x.z*a.y.w - a.y.y*a.z.z*a.x.w},\n            {a.y.z*a.w.w*a.z.x + a.z.z*a.y.w*a.w.x + a.w.z*a.z.w*a.y.x - a.y.z*a.z.w*a.w.x - a.w.z*a.y.w*a.z.x - a.z.z*a.w.w*a.y.x,\n             a.x.z*a.z.w*a.w.x + a.w.z*a.x.w*a.z.x + a.z.z*a.w.w*a.x.x - a.x.z*a.w.w*a.z.x - a.z.z*a.x.w*a.w.x - a.w.z*a.z.w*a.x.x,\n             a.x.z*a.w.w*a.y.x + a.y.z*a.x.w*a.w.x + a.w.z*a.y.w*a.x.x - a.x.z*a.y.w*a.w.x - a.w.z*a.x.w*a.y.x - a.y.z*a.w.w*a.x.x,\n             a.x.z*a.y.w*a.z.x + a.z.z*a.x.w*a.y.x + a.y.z*a.z.w*a.x.x - a.x.z*a.z.w*a.y.x - a.y.z*a.x.w*a.z.x - a.z.z*a.y.w*a.x.x},\n            {a.y.w*a.z.x*a.w.y + a.w.w*a.y.x*a.z.y + a.z.w*a.w.x*a.y.y - a.y.w*a.w.x*a.z.y - a.z.w*a.y.x*a.w.y - a.w.w*a.z.x*a.y.y,\n             a.x.w*a.w.x*a.z.y + a.z.w*a.x.x*a.w.y + a.w.w*a.z.x*a.x.y - a.x.w*a.z.x*a.w.y - a.w.w*a.x.x*a.z.y - a.z.w*a.w.x*a.x.y,\n             a.x.w*a.y.x*a.w.y + a.w.w*a.x.x*a.y.y + a.y.w*a.w.x*a.x.y - a.x.w*a.w.x*a.y.y - a.y.w*a.x.x*a.w.y - a.w.w*a.y.x*a.x.y,\n             a.x.w*a.z.x*a.y.y + a.y.w*a.x.x*a.z.y + a.z.w*a.y.x*a.x.y - a.x.w*a.y.x*a.z.y - a.z.w*a.x.x*a.y.y - a.y.w*a.z.x*a.x.y},\n            {a.y.x*a.w.y*a.z.z + a.z.x*a.y.y*a.w.z + a.w.x*a.z.y*a.y.z - a.y.x*a.z.y*a.w.z - a.w.x*a.y.y*a.z.z - a.z.x*a.w.y*a.y.z,\n             a.x.x*a.z.y*a.w.z + a.w.x*a.x.y*a.z.z + a.z.x*a.w.y*a.x.z - a.x.x*a.w.y*a.z.z - a.z.x*a.x.y*a.w.z - a.w.x*a.z.y*a.x.z,\n             a.x.x*a.w.y*a.y.z + a.y.x*a.x.y*a.w.z + a.w.x*a.y.y*a.x.z - a.x.x*a.y.y*a.w.z - a.w.x*a.x.y*a.y.z - a.y.x*a.w.y*a.x.z,\n             a.x.x*a.y.y*a.z.z + a.z.x*a.x.y*a.y.z + a.y.x*a.z.y*a.x.z - a.x.x*a.z.y*a.y.z - a.y.x*a.x.y*a.z.z - a.z.x*a.y.y*a.x.z}}; \n}\n\ntemplate&lt;class T&gt; constexpr T linalg::determinant(const mat&lt;T,4,4&gt; &amp; a) \n{ \n    return a.x.x*(a.y.y*a.z.z*a.w.w + a.w.y*a.y.z*a.z.w + a.z.y*a.w.z*a.y.w - a.y.y*a.w.z*a.z.w - a.z.y*a.y.z*a.w.w - a.w.y*a.z.z*a.y.w)\n         + a.x.y*(a.y.z*a.w.w*a.z.x + a.z.z*a.y.w*a.w.x + a.w.z*a.z.w*a.y.x - a.y.z*a.z.w*a.w.x - a.w.z*a.y.w*a.z.x - a.z.z*a.w.w*a.y.x)\n         + a.x.z*(a.y.w*a.z.x*a.w.y + a.w.w*a.y.x*a.z.y + a.z.w*a.w.x*a.y.y - a.y.w*a.w.x*a.z.y - a.z.w*a.y.x*a.w.y - a.w.w*a.z.x*a.y.y)\n         + a.x.w*(a.y.x*a.w.y*a.z.z + a.z.x*a.y.y*a.w.z + a.w.x*a.z.y*a.y.z - a.y.x*a.z.y*a.w.z - a.w.x*a.y.y*a.z.z - a.z.x*a.w.y*a.y.z); \n}\n\ntemplate&lt;class T&gt; linalg::vec&lt;T,4&gt; linalg::rotation_quat(const mat&lt;T,3,3&gt; &amp; m)\n{\n    const vec&lt;T,4&gt; q {m.x.x-m.y.y-m.z.z, m.y.y-m.x.x-m.z.z, m.z.z-m.x.x-m.y.y, m.x.x+m.y.y+m.z.z}, s[] {\n        {1, m.x.y + m.y.x, m.z.x + m.x.z, m.y.z - m.z.y}, \n        {m.x.y + m.y.x, 1, m.y.z + m.z.y, m.z.x - m.x.z},\n        {m.x.z + m.z.x, m.y.z + m.z.y, 1, m.x.y - m.y.x},\n        {m.y.z - m.z.y, m.z.x - m.x.z, m.x.y - m.y.x, 1}};\n    return copysign(normalize(sqrt(max(T(0), T(1)+q))), s[argmax(q)]);\n}\n\ntemplate&lt;class T&gt; linalg::mat&lt;T,4,4&gt; linalg::frustum_matrix(T x0, T x1, T y0, T y1, T n, T f, fwd_axis a, z_range z) \n{ \n    const T s = a == pos_z ? T(1) : T(-1), o = z == neg_one_to_one ? n : 0;\n    return {{2*n/(x1-x0),0,0,0}, {0,2*n/(y1-y0),0,0}, {-s*(x0+x1)/(x1-x0),-s*(y0+y1)/(y1-y0),s*(f+o)/(f-n),s}, {0,0,-(n+o)*f/(f-n),0}};\n}\n\n#endif\n</code></pre>"},{"location":"api/logger_8hpp/","title":"File logger.hpp","text":"<p>FileList &gt; common &gt; logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> </ul>"},{"location":"api/logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/logger_8hpp/#classes","title":"Classes","text":"Type Name class start_end_logger a utility for logging to start and end times to a file <p>The documentation for this class was generated from the following file <code>common/logger.hpp</code></p>"},{"location":"api/logger_8hpp_source/","title":"File logger.hpp","text":"<p>File List &gt; common &gt; logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;chrono&gt;\n#include \"phonebook.hpp\"\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nnamespace ILLIXR{\n\n    class start_end_logger\n    {\n    private:\n        std::string component_name;\n        std::ofstream log_file;\n        enum class start_end_state{\n            started,\n            ended,\n            bad\n        };\n        start_end_state log_state;\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; init_time;\n    public:\n        start_end_logger(std::string component_name){\n            log_file.open(\"log/\" + component_name);\n            if (log_file) {\n                log_state = start_end_state::ended;\n                log_file &lt;&lt; \"logger.hpp is DEPRECATED. See logging.hpp\" &lt;&lt; std::endl;\n            } else {\n                log_state = start_end_state::bad;\n            }\n            init_time = std::chrono::high_resolution_clock::now();\n        }\n        ~start_end_logger(){\n            log_file.close();\n        }\n        int log_start(std::chrono::time_point&lt;std::chrono::system_clock&gt; log_time){\n            // check status\n            if (log_state == start_end_state::bad) return -1;\n            if (log_state == start_end_state::started){\n                log_state = start_end_state::bad;\n                log_file &lt;&lt; \"bad logging state, logging terminated\" &lt;&lt; std::endl;\n                return -1;\n            }\n\n            log_state = start_end_state::started;\n            log_file &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(log_time - init_time).count() &lt;&lt; \",\";\n\n            return 0;\n        }\n        int log_end(std::chrono::time_point&lt;std::chrono::system_clock&gt; log_time){\n            // check status\n            if (log_state == start_end_state::bad) return -1;\n            if (log_state == start_end_state::ended){\n                log_state = start_end_state::bad;\n                log_file &lt;&lt; \"bad logging state, logging terminated\" &lt;&lt; std::endl;\n                return -1;\n            }\n\n            log_state = start_end_state::ended;\n            log_file &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(log_time - init_time).count() &lt;&lt; std::endl;\n\n            return 0;\n        }\n    };\n}\n</code></pre>"},{"location":"api/managed__thread_8hpp/","title":"File managed_thread.hpp","text":"<p>FileList &gt; common &gt; managed_thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> </ul>"},{"location":"api/managed__thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/managed__thread_8hpp/#classes","title":"Classes","text":"Type Name class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. <p>The documentation for this class was generated from the following file <code>common/managed_thread.hpp</code></p>"},{"location":"api/managed__thread_8hpp_source/","title":"File managed_thread.hpp","text":"<p>File List &gt; common &gt; managed_thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;thread&gt;\n#include &lt;functional&gt;\n#include &lt;atomic&gt;\n\nnamespace ILLIXR {\n\nclass managed_thread {\nprivate:\n    std::atomic&lt;bool&gt; _m_stop {false};\n    std::thread _m_thread;\n    std::function&lt;void()&gt; _m_body;\n    std::function&lt;void()&gt; _m_on_start;\n    std::function&lt;void()&gt; _m_on_stop;\n\n    void thread_main() {\n        assert(_m_body);\n        if (_m_on_start) {\n            _m_on_start();\n        }\n        while (!this-&gt;_m_stop.load()) {\n            _m_body();\n        }\n        if (_m_on_stop) {\n            _m_on_stop();\n        }\n    }\n\npublic:\n\n    managed_thread() noexcept { }\n\n    managed_thread(std::function&lt;void()&gt; body, std::function&lt;void()&gt; on_start = std::function&lt;void()&gt;{}, std::function&lt;void()&gt; on_stop = std::function&lt;void()&gt;{}) noexcept\n        : _m_body{body}\n        , _m_on_start{on_start}\n        , _m_on_stop{on_stop}\n    { }\n\n    ~managed_thread() noexcept {\n        if (get_state() == state::running) {\n            stop();\n        }\n        assert(get_state() == state::stopped || get_state() == state::startable || get_state() == state::nonstartable);\n        // assert(!_m_thread.joinable());\n    }\n\n    enum class state {\n        nonstartable,\n        startable,\n        running,\n        stopped,\n    };\n\n    state get_state() {\n        bool stopped = _m_stop.load();\n        if (false) {\n        } else if (!_m_body) {\n            return state::nonstartable;\n        } else if (!stopped &amp;&amp; !_m_thread.joinable()) {\n            return state::startable;\n        } else if (!stopped &amp;&amp;  _m_thread.joinable()) {\n            return state::running;\n        } else if (stopped) {\n            return state::stopped;\n        } else {\n            throw std::logic_error{\"Unknown state\"};\n        }\n    }\n\n    void start() {\n        assert(get_state() == state::startable);\n        _m_thread = std::thread{&amp;managed_thread::thread_main, this};\n        assert(get_state() == state::running);\n    }\n\n    void stop() {\n        assert(get_state() == state::running);\n        _m_stop.store(true);\n        _m_thread.join();\n        assert(get_state() == state::stopped);\n    }\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/math__util_8hpp/","title":"File math_util.hpp","text":"<p>FileList &gt; common &gt; math_util.hpp</p> <p>Go to the source code of this file</p>"},{"location":"api/math__util_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace math_util <p>The documentation for this class was generated from the following file <code>common/math_util.hpp</code></p>"},{"location":"api/math__util_8hpp_source/","title":"File math_util.hpp","text":"<p>File List &gt; common &gt; math_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace ILLIXR {\n    namespace math_util {\n\n        // Calculates a projection matrix with given properties. Implementation\n        // borrowed from J.M.P. Van Waveren's ksAlgebra library, as found in\n        // https://github.com/KhronosGroup/Vulkan-Samples-Deprecated/blob/master/samples/apps/atw/atw_opengl.c\n        void projection_fov(Eigen::Matrix4f* result,\n                                   const float fovLeft, const float fovRight,\n                                   const float fovUp, const float fovDown,\n                                   const float nearZ, const float farZ);\n\n        // Calculates a projection matrix with given properties. Implementation\n        // borrowed from J.M.P. Van Waveren's ksAlgebra library, as found in\n        // https://github.com/KhronosGroup/Vulkan-Samples-Deprecated/blob/master/samples/apps/atw/atw_opengl.c\n        void projection( Eigen::Matrix4f* result,\n                                const float tanAngleLeft, const float tanAngleRight,\n                                const float tanAngleUp, float const tanAngleDown,\n                                const float nearZ, const float farZ );\n\n        void projection_fov(Eigen::Matrix4f* result,\n                                   const float fovLeft, const float fovRight,\n                                   const float fovUp, const float fovDown,\n                                   const float nearZ, const float farZ) {\n\n            const float tanLeft = - tanf( fovLeft * ( M_PI / 180.0f ) );\n            const float tanRight = tanf( fovRight * ( M_PI / 180.0f ) );\n\n            const float tanDown = - tanf( fovDown * ( M_PI / 180.0f ) );\n            const float tanUp = tanf( fovUp * ( M_PI / 180.0f ) );\n\n            projection(result, tanLeft, tanRight, tanUp, tanDown, nearZ, farZ );\n        }\n\n        void projection( Eigen::Matrix4f* result,\n                                const float tanAngleLeft, const float tanAngleRight,\n                                const float tanAngleUp, float const tanAngleDown,\n                                const float nearZ, const float farZ ) {\n            const float tanAngleWidth = tanAngleRight - tanAngleLeft;\n            // Set to tanAngleUp - tanAngleDown for a clip space with positive Y up (OpenGL / D3D / Metal).\n            const float tanAngleHeight = tanAngleUp - tanAngleDown;\n            // Set to nearZ for a [-1,1] Z clip space (OpenGL / OpenGL ES).\n            const float offsetZ = nearZ;\n\n            if ( farZ &lt;= nearZ )\n            {\n                // place the far plane at infinity\n                (*result)(0,0) = 2 / tanAngleWidth;\n                (*result)(0,1) = 0;\n                (*result)(0,2) = ( tanAngleRight + tanAngleLeft ) / tanAngleWidth;\n                (*result)(0,3) = 0;\n\n                (*result)(1,0) = 0;\n                (*result)(1,1) = 2 / tanAngleHeight;\n                (*result)(1,2) = ( tanAngleUp + tanAngleDown ) / tanAngleHeight;\n                (*result)(1,3) = 0;\n\n                (*result)(2,0) = 0;\n                (*result)(2,1) = 0;\n                (*result)(2,2) = -1;\n                (*result)(2,3) = -( nearZ + offsetZ );\n\n                (*result)(3,0) = 0;\n                (*result)(3,1) = 0;\n                (*result)(3,2) = -1;\n                (*result)(3,3) = 0;\n            }\n            else\n            {\n                // normal projection\n                (*result)(0,0) = 2 / tanAngleWidth;\n                (*result)(0,1) = 0;\n                (*result)(0,2) = ( tanAngleRight + tanAngleLeft ) / tanAngleWidth;\n                (*result)(0,3) = 0;\n\n                (*result)(1,0) = 0;\n                (*result)(1,1) = 2 / tanAngleHeight;\n                (*result)(1,2) = ( tanAngleUp + tanAngleDown ) / tanAngleHeight;\n                (*result)(1,3) = 0;\n\n                (*result)(2,0) = 0;\n                (*result)(2,1) = 0;\n                (*result)(2,2) = -( farZ + offsetZ ) / ( farZ - nearZ );\n                (*result)(2,3) = -( farZ * ( nearZ + offsetZ ) ) / ( farZ - nearZ );\n\n                (*result)(3,0) = 0;\n                (*result)(3,1) = 0;\n                (*result)(3,2) = -1;\n                (*result)(3,3) = 0;\n            }\n        }\n    };\n}\n</code></pre>"},{"location":"api/phonebook_8hpp/","title":"File phonebook.hpp","text":"<p>FileList &gt; common &gt; phonebook.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"api/phonebook_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/phonebook_8hpp/#classes","title":"Classes","text":"Type Name class phonebook A service locator forILLIXR . class service A 'service' that can be registered in the phonebook. <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/phonebook_8hpp_source/","title":"File phonebook.hpp","text":"<p>File List &gt; common &gt; phonebook.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;typeindex&gt;\n#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;memory&gt;\n#include &lt;unordered_map&gt;\n\nnamespace ILLIXR {\n\n    class phonebook {\n        /*\n          Proof of thread-safety:\n          - Since all instance members are private, acquiring a lock in each method implies the class is datarace-free.\n          - Since there is only one lock and this does not call any code containing locks, this is deadlock-free.\n          - Both of these methods are only used during initialization, so the locks are not contended in steady-state.\n\n          However, to write a correct program, one must also check the thread-safety of the elements\n          inserted into this class by the caller.\n        */\n\n    public:\n\n        class service {\n        public:\n            virtual ~service() { }\n        };\n\n        template &lt;typename specific_service&gt;\n        void register_impl(std::shared_ptr&lt;specific_service&gt; impl) {\n            const std::unique_lock&lt;std::shared_mutex&gt; lock{_m_mutex};\n\n            const std::type_index type_index = std::type_index(typeid(specific_service));\n#ifndef NDEBUG\n            std::cerr &lt;&lt; \"Register \" &lt;&lt; type_index.name() &lt;&lt; std::endl;\n#endif\n            assert(_m_registry.count(type_index) == 0);\n            _m_registry.try_emplace(type_index, impl);\n        }\n\n        template &lt;typename specific_service&gt;\n        std::shared_ptr&lt;specific_service&gt; lookup_impl() const {\n            const std::shared_lock&lt;std::shared_mutex&gt; lock{_m_mutex};\n\n            const std::type_index type_index = std::type_index(typeid(specific_service));\n\n#ifndef NDEBUG\n            // if this assert fails, and there are no duplicate base classes, ensure the hash_code's are unique.\n            if (_m_registry.count(type_index) != 1) {\n                throw std::runtime_error{\"Attempted to lookup an unregistered implementation \" + std::string{type_index.name()}};\n            }\n#endif\n\n            std::shared_ptr&lt;service&gt; this_service = _m_registry.at(type_index);\n            assert(this_service);\n\n            std::shared_ptr&lt;specific_service&gt; this_specific_service = std::dynamic_pointer_cast&lt;specific_service&gt;(this_service);\n            assert(this_specific_service);\n\n            return this_specific_service;\n        }\n\n    private:\n        std::unordered_map&lt;std::type_index, const std::shared_ptr&lt;service&gt;&gt; _m_registry;\n        mutable std::shared_mutex _m_mutex;\n    };\n}\n</code></pre>"},{"location":"api/plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; common &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> </ul>"},{"location":"api/plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugin_8hpp/#classes","title":"Classes","text":"Type Name class plugin A dynamically-loadable plugin for Spindle."},{"location":"api/plugin_8hpp/#macros","title":"Macros","text":"Type Name define PLUGIN_MAIN (plugin_class) <code>/* multi line expression */</code>"},{"location":"api/plugin_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugin_8hpp/#define-plugin_main","title":"define PLUGIN_MAIN","text":"<pre><code>#define PLUGIN_MAIN (\n    plugin_class\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/plugin.hpp</code></p>"},{"location":"api/plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; common &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n#include \"record_logger.hpp\"\n\nnamespace ILLIXR {\n\n    using plugin_id_t = std::size_t;\n\n    /*\n     * This gets included, but it is functionally 'private'. Hence the double-underscores.\n     */\n    const record_header __plugin_start_header {\n        \"plugin_name\",\n        {\n            {\"plugin_id\", typeid(plugin_id_t)},\n            {\"plugin_name\", typeid(std::string)},\n        },\n    };\n\n    class plugin {\n    public:\n\n        virtual void start() {\n            record_logger_-&gt;log(record{__plugin_start_header, {\n                {id},\n                {name},\n            }});\n        }\n\n        virtual void stop() { }\n\n        plugin(const std::string&amp; name_, phonebook* pb_)\n            : name{name_}\n            , pb{pb_}\n            , record_logger_{pb-&gt;lookup_impl&lt;record_logger&gt;()}\n            , gen_guid_{pb-&gt;lookup_impl&lt;gen_guid&gt;()}\n            , id{gen_guid_-&gt;get()}\n        { }\n\n        virtual ~plugin() = default;\n\n        std::string get_name() const noexcept { return name; }\n\n    protected:\n        std::string name;\n        const phonebook* pb;\n        const std::shared_ptr&lt;record_logger&gt; record_logger_;\n        const std::shared_ptr&lt;gen_guid&gt; gen_guid_;\n        const std::size_t id;\n    };\n\n#define PLUGIN_MAIN(plugin_class)                                   \\\n    extern \"C\" plugin* this_plugin_factory(phonebook* pb) {         \\\n        plugin_class* obj = new plugin_class {#plugin_class, pb};   \\\n        return obj;                                                 \\\n    }\n}\n</code></pre>"},{"location":"api/pose__prediction_8hpp/","title":"File pose_prediction.hpp","text":"<p>FileList &gt; common &gt; pose_prediction.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"data_format.hpp\"</code></li> </ul>"},{"location":"api/pose__prediction_8hpp/#classes","title":"Classes","text":"Type Name class pose_prediction <p>The documentation for this class was generated from the following file <code>common/pose_prediction.hpp</code></p>"},{"location":"api/pose__prediction_8hpp_source/","title":"File pose_prediction.hpp","text":"<p>File List &gt; common &gt; pose_prediction.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"phonebook.hpp\"\n#include \"data_format.hpp\"\n\nusing namespace ILLIXR;\n\nclass pose_prediction : public phonebook::service {\npublic:\n    virtual fast_pose_type get_fast_pose() const = 0;\n    virtual pose_type get_true_pose() const = 0;\n    virtual fast_pose_type get_fast_pose(time_type future_time) const = 0;\n    virtual bool fast_pose_reliable() const = 0;\n    virtual bool true_pose_reliable() const = 0;\n    virtual void set_offset(const Eigen::Quaternionf&amp; orientation) = 0;\n    virtual Eigen::Quaternionf get_offset() = 0;\n    virtual pose_type correct_pose(const pose_type pose) const = 0;\n    virtual ~pose_prediction() { }\n};\n</code></pre>"},{"location":"api/record__logger_8hpp/","title":"File record_logger.hpp","text":"<p>FileList &gt; common &gt; record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;any&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> </ul>"},{"location":"api/record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/record__logger_8hpp/#classes","title":"Classes","text":"Type Name class data_use_indicator A helper class that lets one dynamically determine if some data gets used. class gen_guid This class generates unique IDs. class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_logger The ILLIXR logging service for structured records. <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/record__logger_8hpp_source/","title":"File record_logger.hpp","text":"<p>File List &gt; common &gt; record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;any&gt;\n#include &lt;atomic&gt;\n#include &lt;unordered_map&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include \"phonebook.hpp\"\n\nnamespace ILLIXR {\n\n    class record_header {\n    public:\n        record_header(std::string name_, std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns_)\n            : id{std::hash&lt;std::string&gt;{}(name_)}\n            , name{name_}\n            , columns{columns_}\n        { }\n\n        bool operator==(const record_header&amp; other) const {\n            // Check pointer first\n            if (this == &amp;other) {\n                return true;\n            }\n\n            if (name != other.name\n                || columns.size() != other.columns.size()\n                || id != other.id) {\n                return false;\n            }\n            for (std::size_t i = 0; i &lt; columns.size(); ++i) {\n                if (columns[i] != other.columns[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        bool operator!=(const record_header&amp; other) const {\n            return !(*this == other);\n        }\n        std::size_t get_id() const { return id; }\n        const std::string&amp; get_name() const { return name; }\n        const std::string&amp; get_column_name(unsigned column) const { return columns[column].first; }\n        const std::type_info&amp; get_column_type(unsigned column) const { return columns[column].second; }\n        unsigned get_columns() const { return columns.size(); }\n        std::string to_string() const {\n            std::string ret = std::string{\"record_header \"} + name + std::string{\" { \"};\n            for (const auto&amp; pair : columns) {\n                ret += std::string{pair.second.name()} + std::string{\" \"} + pair.first + std::string{\"; \"};\n            }\n            ret.erase(ret.size() - 2);\n            ret += std::string{\" }\"};\n            return ret;\n        }\n\n    private:\n        std::size_t id;\n        std::string name;\n        const std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns;\n    };\n\n    class data_use_indicator {\n    public:\n        data_use_indicator() : used{false} { }\n        data_use_indicator(const data_use_indicator&amp; other) : used{false} {\n            other.used = true;\n        }\n        data_use_indicator&amp; operator=(const data_use_indicator&amp; other) {\n            if (&amp;other != this) {\n                other.used = true;\n                used = false;\n            }\n            return *this;\n        }\n        /*\n          copy constructors are just as efficient as move constructors would be,\n          so I won't define move constructors. C++ will invoke copy instead (for no loss).\n        */\n        bool is_used() const { return used; }\n        void mark_used() const { used = true; }\n        void mark_unused() const { used = false; }\n    private:\n        mutable bool used;\n    };\n\n    class record {\n    public:\n        record(const record_header&amp; rh_, std::vector&lt;std::any&gt; values_)\n            : rh{rh_}\n            , values{values_}\n        {\n#ifndef NDEBUG\n            assert(rh);\n            if (values.size() != rh-&gt;get().get_columns()) {\n                std::cerr &lt;&lt; values.size() &lt;&lt; \" elements passed, but rh for \" &lt;&lt; rh-&gt;get().get_name() &lt;&lt; \" only specifies \" &lt;&lt; rh-&gt;get().get_columns() &lt;&lt; \".\" &lt;&lt; std::endl;\n                abort();\n            }\n            for (std::size_t column = 0; column &lt; values.size(); ++column) {\n                if (values[column].type() != rh-&gt;get().get_column_type(column)) {\n                    std::cerr &lt;&lt; \"Caller got wrong type for column \" &lt;&lt; column &lt;&lt; \" of \" &lt;&lt; rh-&gt;get().get_name() &lt;&lt; \". \"\n                              &lt;&lt; \"Caller passed: \" &lt;&lt; values[column].type().name() &lt;&lt; \"; \"\n                              &lt;&lt; \"recod_header for specifies: \" &lt;&lt; rh-&gt;get().get_column_type(column).name() &lt;&lt; \". \"\n                              &lt;&lt; std::endl;\n                    abort();\n                }\n            }\n#endif\n        }\n\n        record() { }\n\n        ~record() {\n#ifndef NDEBUG\n            if (rh &amp;&amp; !data_use_indicator_.is_used()) {\n                std::cerr &lt;&lt; \"Record was deleted without being logged.\" &lt;&lt; std::endl;\n                abort();\n            }\n#endif\n        }\n\n        template&lt;typename T&gt;\n        T get_value(unsigned column) const {\n#ifndef NDEBUG\n            assert(rh);\n            data_use_indicator_.mark_used();\n            if (rh-&gt;get().get_column_type(column) != typeid(T)) {\n                std::ostringstream ss;\n                ss &lt;&lt; \"Caller column type for \" &lt;&lt; column &lt;&lt; \" of \" &lt;&lt; rh-&gt;get().get_name() &lt;&lt; \". \"\n                   &lt;&lt; \"Caller passed: \" &lt;&lt; typeid(T).name() &lt;&lt; \"; \"\n                   &lt;&lt; \"record_header specifies: \" &lt;&lt; rh-&gt;get().get_column_type(column).name() &lt;&lt; \". \";\n                throw std::runtime_error{ss.str()};\n            }\n#endif\n            return std::any_cast&lt;T&gt;(values[column]);\n        }\n\n        const record_header&amp; get_record_header() const {\n            assert(rh);\n            return rh-&gt;get();\n        }\n\n        void mark_used() const {\n#ifndef NDEBUG\n            assert(rh);\n            data_use_indicator_.mark_used();\n#endif\n        }\n\n    private:\n        // Holding a pointer to a record_header is more efficient than\n        // requiring each record to hold a list of its column names\n        // and table name. This is just one pointer.\n        std::optional&lt;std::reference_wrapper&lt;const record_header&gt;&gt; rh;\n        std::vector&lt;std::any&gt; values;\n#ifndef NDEBUG\n        data_use_indicator data_use_indicator_;\n#endif\n    };\n\n    class record_logger : public phonebook::service {\n    public:\n\n        virtual ~record_logger() { }\n\n        virtual void log(const record&amp; r) = 0;\n\n        virtual void log(const std::vector&lt;record&gt;&amp; rs) {\n            for (const record&amp; r : rs) {\n                log(r);\n            }\n        }\n    };\n\n    class gen_guid : public phonebook::service {\n    public:\n        std::size_t get(std::size_t namespace_ = 0, std::size_t subnamespace = 0, std::size_t subsubnamespace = 0) {\n            if (guid_starts[namespace_][subnamespace].count(subsubnamespace) == 0) {\n                guid_starts[namespace_][subnamespace][subsubnamespace].store(1);\n            }\n            return guid_starts[namespace_][subnamespace][subsubnamespace]++;\n        }\n    private:\n        std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::atomic&lt;std::size_t&gt;&gt;&gt;&gt; guid_starts;\n    };\n\n\n    static std::chrono::milliseconds LOG_BUFFER_DELAY {1000};\n\n    class record_coalescer {\n    private:\n        std::shared_ptr&lt;record_logger&gt; logger;\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; last_log;\n        std::vector&lt;record&gt; buffer;\n\n    public:\n        record_coalescer(std::shared_ptr&lt;record_logger&gt; logger_)\n            : logger{logger_}\n            , last_log{std::chrono::high_resolution_clock::now()}\n        { }\n\n        ~record_coalescer() {\n            flush();\n        }\n\n        void log(record r) {\n            if (logger) {\n                buffer.push_back(r);\n                // Log coalescer should only be used with\n                // In the common case, they will be the same pointer, quickly check the pointers.\n                // In the less common case, we check for object-structural equality.\n#ifndef NDEBUG\n                if (&amp;r.get_record_header() != &amp;buffer[0].get_record_header()\n                    &amp;&amp; r.get_record_header() == buffer[0].get_record_header()) {\n                    std::cerr &lt;&lt; \"Tried to push a record of type \" &lt;&lt; r.get_record_header().to_string() &lt;&lt; \" to a record logger for type \" &lt;&lt; buffer[0].get_record_header().to_string() &lt;&lt; std::endl;\n                    abort();\n                }\n#endif\n                maybe_flush();\n            }\n        }\n\n        void maybe_flush() {\n            if (std::chrono::high_resolution_clock::now() &gt; last_log + LOG_BUFFER_DELAY) {\n                flush();\n            }\n        }\n\n        void flush() {\n            if (logger) {\n                std::vector&lt;record&gt; buffer2;\n                buffer.swap(buffer2);\n                logger-&gt;log(buffer2);\n                last_log = std::chrono::high_resolution_clock::now();\n            }\n        }\n\n        operator bool() const {\n            return bool(logger);\n        }\n    };\n}\n</code></pre>"},{"location":"api/runtime_8hpp/","title":"File runtime.hpp","text":"<p>FileList &gt; common &gt; runtime.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include \"extended_window.hpp\"</code></li> </ul>"},{"location":"api/runtime_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/runtime_8hpp/#classes","title":"Classes","text":"Type Name class runtime <p>The documentation for this class was generated from the following file <code>common/runtime.hpp</code></p>"},{"location":"api/runtime_8hpp_source/","title":"File runtime.hpp","text":"<p>File List &gt; common &gt; runtime.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;GL/glx.h&gt;\n#include \"extended_window.hpp\"\n\nnamespace ILLIXR {\n    class plugin;\n\n    typedef plugin* (*plugin_factory) (phonebook*);\n\n    class runtime {\n    public:\n        virtual void load_so(const std::vector&lt;std::string&gt;&amp; so) = 0;\n        virtual void load_so(const std::string_view so) = 0;\n        virtual void load_plugin_factory(plugin_factory plugin) = 0;\n\n        virtual void wait() = 0;\n\n        virtual void stop() = 0;\n\n        virtual ~runtime() = default;\n\n    };\n\n#ifdef ILLIXR_MONADO_MAINLINE\n    extern \"C\" runtime* runtime_factory();\n#else\n    extern \"C\" runtime* runtime_factory(GLXContext appGLCtx);\n#endif \n\n}\n</code></pre>"},{"location":"api/shader__util_8hpp/","title":"File shader_util.hpp","text":"<p>FileList &gt; common &gt; shader_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"GL/gl.h\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"error_util.hpp\"</code></li> </ul>"},{"location":"api/shader__util_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr std::size_t GL_MAX_LOG_LENGTH   = <code>4096U</code>"},{"location":"api/shader__util_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void GLAPIENTRY MessageCallback (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * message, const void * userParam)  GLuint init_and_link (const char * vertex_shader, const char * fragment_shader)"},{"location":"api/shader__util_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/shader__util_8hpp/#variable-gl_max_log_length","title":"variable GL_MAX_LOG_LENGTH","text":"<pre><code>constexpr std::size_t GL_MAX_LOG_LENGTH;\n</code></pre>"},{"location":"api/shader__util_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/shader__util_8hpp/#function-messagecallback","title":"function MessageCallback","text":"<pre><code>static void GLAPIENTRY MessageCallback (\n    GLenum source,\n    GLenum type,\n    GLuint id,\n    GLenum severity,\n    GLsizei length,\n    const GLchar * message,\n    const void * userParam\n) \n</code></pre>"},{"location":"api/shader__util_8hpp/#function-init_and_link","title":"function init_and_link","text":"<pre><code>static GLuint init_and_link (\n    const char * vertex_shader,\n    const char * fragment_shader\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/shader_util.hpp</code></p>"},{"location":"api/shader__util_8hpp_source/","title":"File shader_util.hpp","text":"<p>File List &gt; common &gt; shader_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include \"GL/gl.h\"\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n#include \"error_util.hpp\"\n\nusing namespace ILLIXR;\n\nstatic constexpr std::size_t GL_MAX_LOG_LENGTH = 4096U;\n\n\nstatic void GLAPIENTRY\n    MessageCallback([[maybe_unused]] GLenum source,\n                    [[maybe_unused]] GLenum type,\n                    [[maybe_unused]] GLuint id,\n                    [[maybe_unused]] GLenum severity,\n                    [[maybe_unused]] GLsizei length,\n                    [[maybe_unused]] const GLchar* message,\n                    [[maybe_unused]] const void* userParam )\n{\n#ifndef NDEBUG\n    if (severity == GL_DEBUG_SEVERITY_NOTIFICATION) {\n        return;\n    }\n    std::cerr &lt;&lt; \"GL CALLBACK: \" &lt;&lt; (type == GL_DEBUG_TYPE_ERROR ? \"** GL ERROR **\" : \"\")\n              &lt;&lt; \" type = 0x\" &lt;&lt; std::hex &lt;&lt; type &lt;&lt; std::dec\n              &lt;&lt; \", severity = 0x\" &lt;&lt; std::hex &lt;&lt; severity &lt;&lt; std::dec\n              &lt;&lt; \", message = \" &lt;&lt; message\n              &lt;&lt; std::endl;\n    // https://www.khronos.org/opengl/wiki/Debug_Output#Message_Components\n    if (severity == GL_DEBUG_SEVERITY_HIGH) {\n        ILLIXR::abort();\n    } \n#endif\n}\n\nstatic GLuint init_and_link (const char* vertex_shader, const char* fragment_shader){\n\n    // GL handles for intermediary objects.\n    GLint result, vertex_shader_handle, fragment_shader_handle, shader_program;\n\n    vertex_shader_handle = glCreateShader(GL_VERTEX_SHADER);\n    GLint vshader_len = strlen(vertex_shader);\n    glShaderSource(vertex_shader_handle, 1, &amp;vertex_shader, &amp;vshader_len);\n    glCompileShader(vertex_shader_handle);\n    glGetShaderiv(vertex_shader_handle, GL_COMPILE_STATUS, &amp;result);\n    if (result == GL_FALSE) {\n        GLsizei length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetShaderInfoLog(vertex_shader_handle, GL_MAX_LOG_LENGTH*sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get vertex_shader_handle: \" + msg);\n    }\n\n    GLint fragResult = GL_FALSE;\n    fragment_shader_handle = glCreateShader(GL_FRAGMENT_SHADER);\n    GLint fshader_len = strlen(fragment_shader);\n    glShaderSource(fragment_shader_handle, 1, &amp;fragment_shader, &amp;fshader_len);\n    glCompileShader(fragment_shader_handle);\n    glGetShaderiv(fragment_shader_handle, GL_COMPILE_STATUS, &amp;fragResult);\n    if (fragResult == GL_FALSE) {\n        GLsizei length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetShaderInfoLog(fragment_shader_handle, GL_MAX_LOG_LENGTH*sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get fragment_shader_handle: \" + msg);\n    }\n\n    // Create program and link shaders\n    shader_program = glCreateProgram();\n    glAttachShader(shader_program, vertex_shader_handle);\n    glAttachShader(shader_program, fragment_shader_handle);\n    const GLenum gl_err_attach = glGetError();\n    if (gl_err_attach != GL_NO_ERROR) {\n        ILLIXR::abort(\"[shader_util] AttachShader or createProgram failed\");\n    }\n\n    // Link and verify\n\n    glLinkProgram(shader_program);\n\n    const GLenum gl_err_link = glGetError();\n    if (gl_err_link != GL_NO_ERROR) {\n        ILLIXR::abort(\"[shader_util] Linking failed\");\n    }\n\n    glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;result);\n    if (result == GL_FALSE) {\n        GLsizei length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetProgramInfoLog(shader_program, GL_MAX_LOG_LENGTH*sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get shader program: \" + msg);\n    }\n\n    // After successful link, detach shaders from shader program\n    glDetachShader(shader_program, vertex_shader_handle);\n    glDetachShader(shader_program, fragment_shader_handle);\n\n    return shader_program;\n}\n</code></pre>"},{"location":"api/stoplight_8hpp/","title":"File stoplight.hpp","text":"<p>FileList &gt; common &gt; stoplight.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> </ul>"},{"location":"api/stoplight_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/stoplight_8hpp/#classes","title":"Classes","text":"Type Name class Event A boolean condition-variable. class Stoplight Start/stop synchronization for the whole application. <p>The documentation for this class was generated from the following file <code>common/stoplight.hpp</code></p>"},{"location":"api/stoplight_8hpp_source/","title":"File stoplight.hpp","text":"<p>File List &gt; common &gt; stoplight.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;mutex&gt;\n#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include \"phonebook.hpp\"\n\nnamespace ILLIXR {\n\nclass Event {\nprivate:\n    mutable std::mutex _m_mutex;\n    mutable std::condition_variable _m_cv;\n    std::atomic&lt;bool&gt; _m_value = false;\n\npublic:\n\n    void set(bool new_value = true) {\n        {\n            std::lock_guard lock {_m_mutex};\n            _m_value = new_value;\n        }\n        if (new_value) {\n            _m_cv.notify_all();\n        }\n    }\n\n    void clear() { set(false); }\n\n    bool is_set() const {\n        return _m_value;\n    }\n\n    void wait() const {\n        std::unique_lock&lt;std::mutex&gt; lock {_m_mutex};\n        // Check if we even need to wait\n        if (_m_value) {\n            return;\n        }\n        _m_cv.wait(lock, [this] { return _m_value.load(); });\n    }\n\n    template &lt;class Clock, class Rep, class Period&gt;\n    bool wait_timeout(const std::chrono::duration&lt;Rep, Period&gt;&amp; duration) const {\n        auto timeout_time = Clock::now() + duration;\n        if (_m_value) {\n            return true;\n        }\n        std::unique_lock&lt;std::mutex&gt; lock {_m_mutex};\n        while (_m_cv.wait_until(lock, timeout_time) != std::cv_status::timeout) {\n            if (_m_value) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nclass Stoplight : public phonebook::service {\npublic:\n    void wait_for_ready() const {\n        _m_ready.wait();\n    }\n\n    void signal_ready() {\n        _m_ready.set();\n    }\n\n    bool check_should_stop() const {\n        return _m_should_stop.is_set();\n    }\n\n    void signal_should_stop() {\n        _m_should_stop.set();\n    }\n\n    void wait_for_shutdown_complete() const {\n        _m_shutdown_complete.wait();\n    }\n\n    bool check_shutdown_complete() const {\n        return _m_shutdown_complete.is_set();\n    }\n\n    void signal_shutdown_complete() {\n        _m_shutdown_complete.set();\n    }\nprivate:\n    Event _m_ready;\n    Event _m_should_stop;\n    Event _m_shutdown_complete;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/switchboard_8hpp/","title":"File switchboard.hpp","text":"<p>FileList &gt; common &gt; switchboard.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> <li><code>#include \"managed_thread.hpp\"</code></li> <li><code>#include \"concurrentqueue/blockingconcurrentqueue.hpp\"</code></li> </ul>"},{"location":"api/switchboard_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/switchboard_8hpp/#classes","title":"Classes","text":"Type Name class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class event Virtual class for event types. class event_wrapper &lt;typename underlying_type&gt;Helper class for making event types. class reader &lt;typename specific_event&gt;A handle which can read the latest event on a topic. class writer &lt;typename specific_event&gt;A handle which can publish events to a topic."},{"location":"api/switchboard_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::nanoseconds thread_cpu_time ()"},{"location":"api/switchboard_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/switchboard_8hpp/#function-thread_cpu_time","title":"function thread_cpu_time","text":"<pre><code>static std::chrono::nanoseconds thread_cpu_time () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/switchboard_8hpp_source/","title":"File switchboard.hpp","text":"<p>File List &gt; common &gt; switchboard.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;memory&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;\n#include &lt;array&gt;\n#include &lt;sstream&gt;\n#include &lt;atomic&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;type_traits&gt;\n#include &lt;functional&gt;\n#include &lt;chrono&gt;\n#include &lt;exception&gt;\n#include \"phonebook.hpp\"\n#if __has_include(\"cpu_timer.hpp\")\n    #include \"cpu_timer.hpp\"\n#else\n    static std::chrono::nanoseconds thread_cpu_time() { return {}; }\n#endif\n#include \"record_logger.hpp\"\n#include \"managed_thread.hpp\"\n#include \"concurrentqueue/blockingconcurrentqueue.hpp\"\n\nnamespace ILLIXR {\n\nusing plugin_id_t = std::size_t;\n\nconst record_header __switchboard_callback_header {\"switchboard_callback\", {\n    {\"plugin_id\", typeid(plugin_id_t)},\n    {\"topic_name\", typeid(std::string)},\n    {\"iteration_no\", typeid(std::size_t)},\n    {\"cpu_time_start\", typeid(std::chrono::nanoseconds)},\n    {\"cpu_time_stop\" , typeid(std::chrono::nanoseconds)},\n    {\"wall_time_start\", typeid(std::chrono::high_resolution_clock::time_point)},\n    {\"wall_time_stop\" , typeid(std::chrono::high_resolution_clock::time_point)},\n}};\n\nconst record_header __switchboard_topic_stop_header {\"switchboard_topic_stop\", {\n    {\"plugin_id\", typeid(plugin_id_t)},\n    {\"topic_name\", typeid(std::string)},\n    {\"enqueued\", typeid(std::size_t)},\n    {\"dequeued\", typeid(std::size_t)},\n    {\"idle_cycles\", typeid(std::size_t)},\n}};\n\nclass switchboard : public phonebook::service {\npublic:\n\n    template &lt;typename specific_event&gt;\n    using ptr = std::shared_ptr&lt;specific_event&gt;;\n\n    class event {\n    public:\n        virtual ~event() = default;\n    };\n\n    template &lt;typename underlying_type&gt;\n    class event_wrapper : public event {\n    private:\n        underlying_type underlying_data;\n    public:\n        event_wrapper() { }\n\n        event_wrapper(underlying_type underlying_data_)\n            : underlying_data{underlying_data_}\n        { }\n        operator underlying_type() const { return underlying_data; }\n        underlying_type&amp; operator*() { return underlying_data; }\n        const underlying_type&amp; operator*() const { return underlying_data; }\n    };\n\nprivate:\n    class topic_subscription {\n    private:\n        const std::string&amp; _m_topic_name;\n        plugin_id_t _m_plugin_id;\n        std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt; _m_callback;\n        const std::shared_ptr&lt;record_logger&gt; _m_record_logger;\n        record_coalescer _m_cb_log;\n        moodycamel::BlockingConcurrentQueue&lt;ptr&lt;const event&gt;&gt; _m_queue {8 /*max size estimate*/};\n        moodycamel::ConsumerToken _m_ctok {_m_queue};\n        static constexpr std::chrono::milliseconds _m_queue_timeout {100};\n        std::size_t _m_enqueued {0};\n        std::size_t _m_dequeued {0};\n        std::size_t _m_idle_cycles {0};\n\n        // This needs to be last,\n        // so it is destructed before the data it uses.\n        managed_thread _m_thread;\n\n        void thread_on_start() {\n#ifndef NDEBUG\n            std::cerr &lt;&lt; \"Thread \" &lt;&lt; std::this_thread::get_id() &lt;&lt; \" start\" &lt;&lt; std::endl;\n#endif\n        }\n\n        void thread_body() {\n            // Try to pull event off of queue\n            ptr&lt;const event&gt; this_event;\n            std::int64_t timeout_usecs = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(_m_queue_timeout).count();\n            // Note the use of timed blocking wait\n            if (_m_queue.wait_dequeue_timed(_m_ctok, this_event, timeout_usecs)) {\n                // Process event\n                // Also, record and log the time\n                _m_dequeued++;\n                auto cb_start_cpu_time  = thread_cpu_time();\n                auto cb_start_wall_time = std::chrono::high_resolution_clock::now();\n                // std::cerr &lt;&lt; \"deq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get_ro())) &lt;&lt; \" \" &lt;&lt; this_event.use_count() &lt;&lt; \" v\\n\";\n                _m_callback(std::move(this_event), _m_dequeued);\n                if (_m_cb_log) {\n                    _m_cb_log.log(record{__switchboard_callback_header, {\n                        {_m_plugin_id},\n                        {_m_topic_name},\n                        {_m_dequeued},\n                        {cb_start_cpu_time},\n                        {thread_cpu_time()},\n                        {cb_start_wall_time},\n                        {std::chrono::high_resolution_clock::now()},\n                    }});\n                }\n            } else {\n                // Nothing to do.\n                _m_idle_cycles++;\n            }\n        }\n\n\n        void thread_on_stop() {\n            // Drain queue\n            std::size_t unprocessed = _m_enqueued - _m_dequeued;\n            {\n                ptr&lt;const event&gt; this_event;\n                for (std::size_t i = 0; i &lt; unprocessed; ++i) {\n                    [[maybe_unused]] bool ret = _m_queue.try_dequeue(_m_ctok, this_event);\n                    assert(ret);\n                    // std::cerr &lt;&lt; \"deq (stopping) \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get_ro())) &lt;&lt; \" \" &lt;&lt; this_event.use_count() &lt;&lt; \" v\\n\";\n                    this_event.reset();\n                }\n            }\n\n            // Log stats\n            if (_m_record_logger) {\n                _m_record_logger-&gt;log(record{__switchboard_topic_stop_header, {\n                    {_m_plugin_id},\n                    {_m_topic_name},\n                    {_m_dequeued},\n                    {unprocessed},\n                    {_m_idle_cycles},\n                }});\n            }\n        }\n\n    public:\n        topic_subscription(const std::string&amp; topic_name, plugin_id_t plugin_id, std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt; callback, std::shared_ptr&lt;record_logger&gt; record_logger_)\n            : _m_topic_name{topic_name}\n            , _m_plugin_id{plugin_id}\n            , _m_callback{callback}\n            , _m_record_logger{record_logger_}\n            , _m_cb_log{record_logger_}\n            , _m_thread{[this]{this-&gt;thread_body();}, [this]{this-&gt;thread_on_start();}, [this]{this-&gt;thread_on_stop();}}\n        {\n            _m_thread.start();\n        }\n\n        void enqueue(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            if (_m_thread.get_state() == managed_thread::state::running) {\n                [[maybe_unused]] bool ret = _m_queue.enqueue(std::move(this_event));\n                assert(ret);\n                _m_enqueued++;\n            }\n        }\n    };\n\n    class topic {\n    private:\n        const std::string _m_name;\n        const std::type_info&amp; _m_ty;\n        const std::shared_ptr&lt;record_logger&gt; _m_record_logger;\n        std::atomic&lt;size_t&gt; _m_latest_index;\n        static constexpr std::size_t _m_latest_buffer_size = 256;\n        std::array&lt;ptr&lt;const event&gt;, _m_latest_buffer_size&gt; _m_latest_buffer;\n        std::list&lt;topic_subscription&gt; _m_subscriptions;\n        std::shared_mutex _m_subscriptions_lock;\n\n    public:\n        topic(\n            std::string name,\n            const std::type_info&amp; ty,\n            std::shared_ptr&lt;record_logger&gt; record_logger_\n        )   : _m_name{name}\n            , _m_ty{ty}\n            , _m_record_logger{record_logger_}\n            , _m_latest_index{0}\n        { }\n\n        const std::string&amp; name() { return _m_name; }\n\n        const std::type_info&amp; ty() { return _m_ty; }\n\n        ptr&lt;const event&gt; get() const {\n            size_t idx = _m_latest_index.load() % _m_latest_buffer_size;\n            ptr&lt;const event&gt; this_event = _m_latest_buffer[idx];\n            // if (this_event) {\n            //  std::cerr &lt;&lt; \"get \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get())) &lt;&lt; \" \" &lt;&lt; this_event.use_count() &lt;&lt; \"v \\n\";\n            // }\n            return this_event;\n        }\n\n        void put(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            assert(this_event != nullptr);\n            assert(this_event.unique() || this_event.use_count() &lt;= 2);  \n\n            /* The pointer that this gets exchanged with needs to get dropped. */\n            size_t index = (_m_latest_index.load() + 1) % _m_latest_buffer_size;\n            _m_latest_buffer[index] = this_event;\n            _m_latest_index++;\n\n            // Read/write on _m_subscriptions.\n            // Must acquire shared state on _m_subscriptions_lock\n            std::unique_lock lock{_m_subscriptions_lock};\n            for (topic_subscription&amp; ts : _m_subscriptions) {\n                // std::cerr &lt;&lt; \"enq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt; this_event-&gt;use_count() &lt;&lt; \" ^\\n\";\n                ptr&lt;const event&gt; event_ptr_copy {this_event};\n                ts.enqueue(std::move(event_ptr_copy));\n            }\n            // std::cerr &lt;&lt; \"put done \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt; this_event-&gt;use_count() &lt;&lt; \" (= 1 + len(sub)) \\n\";\n        }\n\n        void schedule(\n            plugin_id_t plugin_id,\n            std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt; callback)\n        {\n            // Write on _m_subscriptions.\n            // Must acquire unique state on _m_subscriptions_lock\n            const std::unique_lock lock{_m_subscriptions_lock};\n            _m_subscriptions.emplace_back(_m_name, plugin_id, callback, _m_record_logger);\n        }\n\n        void stop() {\n            // Write on _m_subscriptions.\n            // Must acquire unique state on _m_subscriptions_lock\n            const std::unique_lock lock{_m_subscriptions_lock};\n            _m_subscriptions.clear();\n        }\n    };\n\npublic:\n\n    template &lt;typename specific_event&gt;\n    class reader {\n    private:\n        topic&amp; _m_topic;\n\n    public:\n        reader(topic&amp; topic_)\n            : _m_topic{topic_}\n        {\n#ifndef NDEBUG\n            if (typeid(specific_event) != _m_topic.ty()) {\n                std::cerr &lt;&lt; \"topic '\" &lt;&lt; _m_topic.name() &lt;&lt; \"' holds type \" &lt;&lt; _m_topic.ty().name()\n                          &lt;&lt; \", but caller used type\" &lt;&lt; typeid(specific_event).name() &lt;&lt; std::endl;\n                abort();\n            }\n#endif\n        }\n\n       ptr&lt;const specific_event&gt; get_ro_nullable() const noexcept {\n           ptr&lt;const event&gt; this_event = _m_topic.get();\n           ptr&lt;const specific_event&gt; this_specific_event = std::dynamic_pointer_cast&lt;const specific_event&gt;(this_event);\n\n           if (this_event != nullptr) {\n               assert(this_specific_event /* Otherwise, dynamic cast failed; dynamic type information could be wrong*/);\n               return this_specific_event;\n           } else {\n               return ptr&lt;const specific_event&gt;{nullptr};\n           }\n       }\n\n        ptr&lt;const specific_event&gt; get_ro() const {\n            ptr&lt;const specific_event&gt; this_specific_event = get_ro_nullable();\n            if (this_specific_event != nullptr) {\n                return this_specific_event;\n            } else {\n                throw std::runtime_error(\"No event on topic\");\n            }\n        }\n\n        ptr&lt;specific_event&gt; get_rw() const {\n            /*\n              This method is currently not more efficient than calling get_ro() and making a copy,\n              but in the future it could be.\n             */\n            ptr&lt;const specific_event&gt; this_specific_event = get_ro();\n            return std::make_shared&lt;specific_event&gt;(*this_specific_event);\n        }\n    };\n\n    template &lt;typename specific_event&gt;\n    class writer {\n    private:\n        // Reference to the underlying topic\n        topic&amp; _m_topic;\n\n    public:\n        writer(topic&amp; topic_)\n            : _m_topic{topic_}\n        { }\n\n        template&lt;class... Args&gt;\n        ptr&lt;specific_event&gt; allocate(Args&amp;&amp;... args) {\n            return std::make_shared&lt;specific_event&gt;(std::forward&lt;Args&gt;(args)...);\n        }\n\n        void put(ptr&lt;specific_event&gt;&amp;&amp; this_specific_event) {\n            assert(typeid(specific_event) == _m_topic.ty());\n            assert(this_specific_event != nullptr);\n            assert(this_specific_event.unique());\n            ptr&lt;const event&gt; this_event = std::const_pointer_cast&lt;const event&gt;(std::static_pointer_cast&lt;event&gt;(std::move(this_specific_event)));\n            assert(this_event.unique() || this_event.use_count() &lt;= 2); \n            _m_topic.put(std::move(this_event));\n        }\n    };\n\nprivate:\n    std::unordered_map&lt;std::string, topic&gt; _m_registry;\n    std::shared_mutex _m_registry_lock;\n    std::shared_ptr&lt;record_logger&gt; _m_record_logger;\n\n    template &lt;typename specific_event&gt;\n    topic&amp; try_register_topic(const std::string&amp; topic_name) {\n        {\n            const std::shared_lock lock{_m_registry_lock};\n            auto found = _m_registry.find(topic_name);\n            if (found != _m_registry.end()) {\n                topic&amp; topic_ = found-&gt;second;\n#ifndef NDEBUG\n                if (typeid(specific_event) != topic_.ty()) {\n                    std::cerr &lt;&lt; \"topic '\" &lt;&lt; topic_name &lt;&lt; \"' holds type \" &lt;&lt; topic_.ty().name()\n                              &lt;&lt; \", but caller used type\" &lt;&lt; typeid(specific_event).name()\n                              &lt;&lt; std::endl;\n                    abort();\n                }\n#endif\n                return topic_;\n            }\n        }\n\n#ifndef NDEBUG\n        std::cerr &lt;&lt; \"Creating: \" &lt;&lt; topic_name &lt;&lt; \" for \" &lt;&lt; typeid(specific_event).name() &lt;&lt; std::endl;\n#endif\n        // Topic not found. Need to create it here.\n        const std::unique_lock lock{_m_registry_lock};\n        return _m_registry.try_emplace(topic_name, topic_name, typeid(specific_event), _m_record_logger).first-&gt;second;\n\n    }\n\npublic:\n\n    switchboard(const phonebook* pb)\n        : _m_record_logger{pb ? pb-&gt;lookup_impl&lt;record_logger&gt;() : nullptr}\n    { }\n\n    template &lt;typename specific_event&gt;\n    void schedule(plugin_id_t plugin_id, std::string topic_name, std::function&lt;void(ptr&lt;const specific_event&gt;&amp;&amp;, std::size_t)&gt; fn) {\n        try_register_topic&lt;specific_event&gt;(topic_name).schedule(plugin_id, [=](ptr&lt;const event&gt;&amp;&amp; this_event, std::size_t it_no) {\n            assert(this_event);\n            ptr&lt;const specific_event&gt; this_specific_event = std::dynamic_pointer_cast&lt;const specific_event&gt;(std::move(this_event));\n            assert(this_specific_event);\n            fn(std::move(this_specific_event), it_no);\n        });\n    }\n\n    template &lt;typename specific_event&gt;\n    writer&lt;specific_event&gt; get_writer(const std::string&amp; topic_name) {\n        return writer&lt;specific_event&gt;{try_register_topic&lt;specific_event&gt;(topic_name)};\n    }\n\n    template &lt;typename specific_event&gt;\n    reader&lt;specific_event&gt; get_reader(const std::string&amp; topic_name) {\n        return reader&lt;specific_event&gt;{try_register_topic&lt;specific_event&gt;(topic_name)};\n    }\n\n    void stop() {\n        const std::shared_lock lock{_m_registry_lock};\n        for (auto&amp; pair : _m_registry) {\n            pair.second.stop();\n        }\n    }\n};\n\n}\n</code></pre>"},{"location":"api/threadloop_8hpp/","title":"File threadloop.hpp","text":"<p>FileList &gt; common &gt; threadloop.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"cpu_timer.hpp\"</code></li> <li><code>#include \"stoplight.hpp\"</code></li> <li><code>#include \"error_util.hpp\"</code></li> </ul>"},{"location":"api/threadloop_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/threadloop_8hpp/#classes","title":"Classes","text":"Type Name class threadloop A reusable threadloop for plugins. <p>The documentation for this class was generated from the following file <code>common/threadloop.hpp</code></p>"},{"location":"api/threadloop_8hpp_source/","title":"File threadloop.hpp","text":"<p>File List &gt; common &gt; threadloop.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;future&gt;\n#include &lt;algorithm&gt;\n#include \"plugin.hpp\"\n#include \"cpu_timer.hpp\"\n#include \"stoplight.hpp\"\n#include \"error_util.hpp\"\n\nnamespace ILLIXR {\n\nconst record_header __threadloop_iteration_header {\"threadloop_iteration\", {\n    {\"plugin_id\", typeid(std::size_t)},\n    {\"iteration_no\", typeid(std::size_t)},\n    {\"skips\", typeid(std::size_t)},\n    {\"cpu_time_start\", typeid(std::chrono::nanoseconds)},\n    {\"cpu_time_stop\" , typeid(std::chrono::nanoseconds)},\n    {\"wall_time_start\", typeid(std::chrono::high_resolution_clock::time_point)},\n    {\"wall_time_stop\" , typeid(std::chrono::high_resolution_clock::time_point)},\n}};\n\nclass threadloop : public plugin {\npublic:\n    threadloop(std::string name_, phonebook* pb_)\n        : plugin{name_, pb_}\n        , _m_stoplight{pb-&gt;lookup_impl&lt;Stoplight&gt;()}\n    { }\n\n    virtual void start() override {\n        plugin::start();\n        _m_thread = std::thread(std::bind(&amp;threadloop::thread_main, this));\n        assert(!_m_stoplight-&gt;check_should_stop());\n        assert(_m_thread.joinable());\n    }\n\n    virtual void stop() override {\n        assert(_m_stoplight-&gt;check_should_stop());\n        assert(_m_thread.joinable());\n        _m_thread.join();\n    }\n\n    virtual ~threadloop() override {\n        assert(_m_stoplight-&gt;check_should_stop());\n        assert(!_m_thread.joinable());\n    }\n\nprotected:\n    std::size_t iteration_no = 0;\n    std::size_t skip_no = 0;\n\nprivate:\n\n    void thread_main() {\n        record_coalescer it_log {record_logger_};\n        std::cout &lt;&lt; \"thread,\" &lt;&lt; std::this_thread::get_id() &lt;&lt; \",threadloop,\" &lt;&lt; name &lt;&lt; std::endl;\n\n        _p_thread_setup();\n\n        _m_stoplight-&gt;wait_for_ready();\n        while (!_m_stoplight-&gt;check_should_stop()) {\n            skip_option s = _p_should_skip();\n\n            switch (s) {\n            case skip_option::skip_and_yield:\n                std::this_thread::yield();\n                ++skip_no;\n                break;\n            case skip_option::skip_and_spin:\n                ++skip_no;\n                break;\n            case skip_option::run: {\n                auto iteration_start_cpu_time  = thread_cpu_time();\n                auto iteration_start_wall_time = std::chrono::high_resolution_clock::now();\n\n                RAC_ERRNO();\n                _p_one_iteration();\n                RAC_ERRNO();\n\n                it_log.log(record{__threadloop_iteration_header, {\n                    {id},\n                    {iteration_no},\n                    {skip_no},\n                    {iteration_start_cpu_time},\n                    {thread_cpu_time()},\n                    {iteration_start_wall_time},\n                    {std::chrono::high_resolution_clock::now()},\n                }});\n                ++iteration_no;\n                skip_no = 0;\n                break;\n            }\n            case skip_option::stop:\n                // Break out of the switch AND the loop\n                // See https://stackoverflow.com/questions/27788326/breaking-out-of-nested-loop-c\n                goto break_loop;\n            }\n        }\n    break_loop:\n        [[maybe_unused]] int cpp_requires_a_statement_after_a_label_plz_optimize_me_away;\n    }\n\nprotected:\n\n    enum class skip_option {\n        run,\n\n        skip_and_spin,\n\n        skip_and_yield,\n\n        stop,\n    };\n\n    virtual skip_option _p_should_skip() { return skip_option::run; }\n\n    virtual void _p_thread_setup() { }\n\n    virtual void _p_one_iteration() = 0;\n\n    bool should_terminate() {\n        return _m_terminate.load();\n    }\n\nprivate:\n    std::atomic&lt;bool&gt; _m_terminate {false};\n    std::thread _m_thread;\n    std::shared_ptr&lt;const Stoplight&gt; _m_stoplight;\n};\n\n}\n</code></pre>"},{"location":"api/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace ILLIXR RAC_ERRNO_MSG. <ul> <li>namespace math_util </li> </ul> </li> <li>namespace linalg <ul> <li>namespace aliases </li> <li>namespace detail </li> <li>namespace ostream_overloads </li> </ul> </li> <li>namespace std <ul> <li>namespace conditional </li> </ul> </li> </ul>"},{"location":"api/classes/","title":"Class Index","text":""},{"location":"api/classes/#a","title":"a","text":"<ul> <li>accel (ILLIXR)</li> <li>any_compare (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; (linalg::detail)</li> <li>apply (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail)</li> </ul>"},{"location":"api/classes/#c","title":"c","text":"<ul> <li>clamp (linalg::detail)</li> <li>converter (linalg)</li> <li>converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; (linalg)</li> </ul>"},{"location":"api/classes/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR)</li> <li>dynamic_lib (ILLIXR)</li> </ul>"},{"location":"api/classes/#e","title":"e","text":"<ul> <li>empty (linalg::detail)</li> <li>Event (ILLIXR)</li> <li>event (ILLIXR::switchboard)</li> <li>event_wrapper (ILLIXR::switchboard)</li> </ul>"},{"location":"api/classes/#f","title":"f","text":"<ul> <li>fast_pose_type (ILLIXR)</li> </ul>"},{"location":"api/classes/#g","title":"g","text":"<ul> <li>gen_guid (ILLIXR)</li> <li>getter (linalg::detail)</li> <li>getter&lt; 0 &gt; (linalg::detail)</li> <li>getter&lt; 1 &gt; (linalg::detail)</li> <li>getter&lt; 2 &gt; (linalg::detail)</li> <li>getter&lt; 3 &gt; (linalg::detail)</li> </ul>"},{"location":"api/classes/#h","title":"h","text":"<ul> <li>hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 1 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 2 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 3 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 4 &gt; &gt; (std)</li> <li>hmd_physical_info (ILLIXR)</li> <li>hologram_input (ILLIXR)</li> </ul>"},{"location":"api/classes/#i","title":"i","text":"<ul> <li>identity_t (linalg)</li> <li>imu_cam_type (ILLIXR)</li> <li>imu_integrator_input (ILLIXR)</li> <li>imu_integrator_seq (ILLIXR)</li> <li>imu_params (ILLIXR)</li> <li>imu_raw_type (ILLIXR)</li> </ul>"},{"location":"api/classes/#l","title":"l","text":"<ul> <li>lerp (linalg::detail)</li> </ul>"},{"location":"api/classes/#m","title":"m","text":"<ul> <li>make_seq_impl (linalg::detail)</li> <li>make_seq_impl&lt; A, 0 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 1 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 2 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 3 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 4 &gt; (linalg::detail)</li> <li>managed_thread (ILLIXR)</li> <li>mat (linalg)</li> <li>mat&lt; T, M, 1 &gt; (linalg)</li> <li>mat&lt; T, M, 2 &gt; (linalg)</li> <li>mat&lt; T, M, 3 &gt; (linalg)</li> <li>mat&lt; T, M, 4 &gt; (linalg)</li> <li>max (linalg::detail)</li> <li>min (linalg::detail)</li> </ul>"},{"location":"api/classes/#o","title":"o","text":"<ul> <li>op_add (linalg::detail)</li> <li>op_and (linalg::detail)</li> <li>op_cmp (linalg::detail)</li> <li>op_div (linalg::detail)</li> <li>op_eq (linalg::detail)</li> <li>op_ge (linalg::detail)</li> <li>op_gt (linalg::detail)</li> <li>op_int (linalg::detail)</li> <li>op_le (linalg::detail)</li> <li>op_lsh (linalg::detail)</li> <li>op_lt (linalg::detail)</li> <li>op_mod (linalg::detail)</li> <li>op_mul (linalg::detail)</li> <li>op_ne (linalg::detail)</li> <li>op_neg (linalg::detail)</li> <li>op_not (linalg::detail)</li> <li>op_or (linalg::detail)</li> <li>op_pos (linalg::detail)</li> <li>op_rsh (linalg::detail)</li> <li>op_sub (linalg::detail)</li> <li>op_un (linalg::detail)</li> <li>op_xor (linalg::detail)</li> <li>ord (linalg::detail)</li> </ul>"},{"location":"api/classes/#p","title":"p","text":"<ul> <li>phonebook (ILLIXR)</li> <li>plugin (ILLIXR)</li> <li>pose_prediction</li> <li>pose_type (ILLIXR)</li> <li>print_in_destructor</li> <li>print_timer</li> <li>print_timer2</li> </ul>"},{"location":"api/classes/#r","title":"r","text":"<ul> <li>reader (ILLIXR::switchboard)</li> <li>record (ILLIXR)</li> <li>record_coalescer (ILLIXR)</li> <li>record_header (ILLIXR)</li> <li>record_logger (ILLIXR)</li> <li>rendered_frame (ILLIXR)</li> <li>rgb_depth_type (ILLIXR)</li> <li>runtime (ILLIXR)</li> </ul>"},{"location":"api/classes/#s","title":"s","text":"<ul> <li>scalar_type (linalg::detail)</li> <li>scalar_type&lt; mat&lt; T, M, N &gt; &gt; (linalg::detail)</li> <li>scalar_type&lt; vec&lt; T, M &gt; &gt; (linalg::detail)</li> <li>scalars (linalg::detail)</li> <li>scalars&lt; T, U... &gt; (linalg::detail)</li> <li>scalars&lt;&gt; (linalg::detail)</li> <li>select (linalg::detail)</li> <li>seq (linalg::detail)</li> <li>service (ILLIXR::phonebook)</li> <li>should_profile_class</li> <li>start_end_logger (ILLIXR)</li> <li>std_abs (linalg::detail)</li> <li>std_acos (linalg::detail)</li> <li>std_asin (linalg::detail)</li> <li>std_atan (linalg::detail)</li> <li>std_atan2 (linalg::detail)</li> <li>std_ceil (linalg::detail)</li> <li>std_copysign (linalg::detail)</li> <li>std_cos (linalg::detail)</li> <li>std_cosh (linalg::detail)</li> <li>std_exp (linalg::detail)</li> <li>std_floor (linalg::detail)</li> <li>std_fmod (linalg::detail)</li> <li>std_log (linalg::detail)</li> <li>std_log10 (linalg::detail)</li> <li>std_pow (linalg::detail)</li> <li>std_round (linalg::detail)</li> <li>std_sin (linalg::detail)</li> <li>std_sinh (linalg::detail)</li> <li>std_sqrt (linalg::detail)</li> <li>std_tan (linalg::detail)</li> <li>std_tanh (linalg::detail)</li> <li>Stoplight (ILLIXR)</li> <li>switchboard (ILLIXR)</li> </ul>"},{"location":"api/classes/#t","title":"t","text":"<ul> <li>texture_pose (ILLIXR)</li> <li>threadloop (ILLIXR)</li> <li>timer</li> <li>topic</li> <li>topic_subscription</li> </ul>"},{"location":"api/classes/#v","title":"v","text":"<ul> <li>vec (linalg)</li> <li>vec&lt; T, 1 &gt; (linalg)</li> <li>vec&lt; T, 2 &gt; (linalg)</li> <li>vec&lt; T, 3 &gt; (linalg)</li> <li>vec&lt; T, 4 &gt; (linalg)</li> </ul>"},{"location":"api/classes/#w","title":"w","text":"<ul> <li>writer (ILLIXR::switchboard)</li> </ul>"},{"location":"api/classes/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR)</li> </ul>"},{"location":"api/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class ILLIXR::Event A boolean condition-variable. </li> <li>class ILLIXR::phonebook::service A 'service' that can be registered in the phonebook. <ul> <li>class ILLIXR::Stoplight Start/stop synchronization for the whole application. </li> <li>class ILLIXR::gen_guid This class generates unique IDs. </li> <li>class ILLIXR::record_logger The ILLIXR logging service for structured records.</li> <li>class ILLIXR::switchboard A manager for typesafe, threadsafe, named event-streams (called topics). </li> <li>class ILLIXR::xlib_gl_extended_window </li> <li>class pose_prediction </li> </ul> </li> <li>class ILLIXR::data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>class ILLIXR::dynamic_lib </li> <li>class ILLIXR::managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. </li> <li>class ILLIXR::phonebook A service locator forILLIXR .</li> <li>class ILLIXR::plugin A dynamically-loadable plugin for Spindle. <ul> <li>class ILLIXR::threadloop A reusable threadloop for plugins. </li> </ul> </li> <li>class ILLIXR::record This class represents a tuple of fields which get logged by <code>record_logger</code> .</li> <li>class ILLIXR::record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class ILLIXR::record_header Schema of each record. </li> <li>class ILLIXR::switchboard::event Virtual class for event types. <ul> <li>struct ILLIXR::hologram_input </li> <li>struct ILLIXR::imu_cam_type </li> <li>struct ILLIXR::imu_integrator_input </li> <li>struct ILLIXR::imu_raw_type </li> <li>struct ILLIXR::pose_type </li> <li>struct ILLIXR::rendered_frame </li> <li>class ILLIXR::rgb_depth_type </li> <li>class ILLIXR::switchboard::event_wrapper Helper class for making event types. </li> <li>struct ILLIXR::texture_pose </li> </ul> </li> <li>class ILLIXR::runtime </li> <li>class ILLIXR::start_end_logger a utility for logging to start and end times to a file </li> <li>class ILLIXR::switchboard::reader A handle which can read the latest event on a topic. </li> <li>class ILLIXR::switchboard::writer A handle which can publish events to a topic. </li> <li>class ILLIXR::switchboard::topic Represents a topic. </li> <li>class ILLIXR::switchboard::topic_subscription Represents a single topic_subscription (callback and queue) </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_timer::print_in_destructor </li> <li>class should_profile_class </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> <li>struct ILLIXR::accel </li> <li>struct ILLIXR::fast_pose_type </li> <li>struct ILLIXR::hmd_physical_info </li> <li>struct ILLIXR::imu_integrator_seq </li> <li>struct ILLIXR::imu_params </li> <li>struct linalg::converter </li> <li>struct linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; </li> <li>struct linalg::detail::any_compare </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct linalg::detail::apply </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; </li> <li>struct linalg::detail::clamp </li> <li>struct linalg::detail::empty </li> <li>struct linalg::detail::getter </li> <li>struct linalg::detail::getter&lt; 0 &gt; </li> <li>struct linalg::detail::getter&lt; 1 &gt; </li> <li>struct linalg::detail::getter&lt; 2 &gt; </li> <li>struct linalg::detail::getter&lt; 3 &gt; </li> <li>struct linalg::detail::lerp </li> <li>struct linalg::detail::make_seq_impl </li> <li>struct linalg::detail::make_seq_impl&lt; A, 0 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 1 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 2 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 3 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 4 &gt; </li> <li>struct linalg::detail::max </li> <li>struct linalg::detail::min </li> <li>struct linalg::detail::op_add </li> <li>struct linalg::detail::op_and </li> <li>struct linalg::detail::op_cmp </li> <li>struct linalg::detail::op_div </li> <li>struct linalg::detail::op_eq </li> <li>struct linalg::detail::op_ge </li> <li>struct linalg::detail::op_gt </li> <li>struct linalg::detail::op_int </li> <li>struct linalg::detail::op_le </li> <li>struct linalg::detail::op_lsh </li> <li>struct linalg::detail::op_lt </li> <li>struct linalg::detail::op_mod </li> <li>struct linalg::detail::op_mul </li> <li>struct linalg::detail::op_ne </li> <li>struct linalg::detail::op_neg </li> <li>struct linalg::detail::op_not </li> <li>struct linalg::detail::op_or </li> <li>struct linalg::detail::op_pos </li> <li>struct linalg::detail::op_rsh </li> <li>struct linalg::detail::op_sub </li> <li>struct linalg::detail::op_un </li> <li>struct linalg::detail::op_xor </li> <li>struct linalg::detail::ord </li> <li>struct linalg::detail::scalar_type </li> <li>struct linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt; </li> <li>struct linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt; </li> <li>struct linalg::detail::scalars </li> <li>struct linalg::detail::scalars&lt;&gt; </li> <li>struct linalg::detail::select </li> <li>struct linalg::detail::seq </li> <li>struct linalg::detail::std_abs </li> <li>struct linalg::detail::std_acos </li> <li>struct linalg::detail::std_asin </li> <li>struct linalg::detail::std_atan </li> <li>struct linalg::detail::std_atan2 </li> <li>struct linalg::detail::std_ceil </li> <li>struct linalg::detail::std_copysign </li> <li>struct linalg::detail::std_cos </li> <li>struct linalg::detail::std_cosh </li> <li>struct linalg::detail::std_exp </li> <li>struct linalg::detail::std_floor </li> <li>struct linalg::detail::std_fmod </li> <li>struct linalg::detail::std_log </li> <li>struct linalg::detail::std_log10 </li> <li>struct linalg::detail::std_pow </li> <li>struct linalg::detail::std_round </li> <li>struct linalg::detail::std_sin </li> <li>struct linalg::detail::std_sinh </li> <li>struct linalg::detail::std_sqrt </li> <li>struct linalg::detail::std_tan </li> <li>struct linalg::detail::std_tanh </li> <li>struct linalg::identity_t </li> <li>struct linalg::mat </li> <li>struct linalg::mat&lt; T, M, 1 &gt; </li> <li>struct linalg::mat&lt; T, M, 2 &gt; </li> <li>struct linalg::mat&lt; T, M, 3 &gt; </li> <li>struct linalg::mat&lt; T, M, 4 &gt; </li> <li>struct linalg::vec </li> <li>struct linalg::vec&lt; T, 1 &gt; </li> <li>struct linalg::vec&lt; T, 2 &gt; </li> <li>struct linalg::vec&lt; T, 3 &gt; </li> <li>struct linalg::vec&lt; T, 4 &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt; </li> <li>class std::conditional::type <ul> <li>struct linalg::detail::scalars&lt; T, U... &gt; </li> </ul> </li> </ul>"},{"location":"api/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"api/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"api/class_members/","title":"Class Members","text":""},{"location":"api/class_members/#a","title":"a","text":"<ul> <li>angular_v (ILLIXR::imu_cam_type)</li> <li>acc_noise (ILLIXR::imu_params)</li> <li>acc_walk (ILLIXR::imu_params)</li> <li>a_hat (ILLIXR::imu_raw_type)</li> <li>a_hat2 (ILLIXR::imu_raw_type)</li> <li>allocate (ILLIXR::switchboard::writer)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>a (linalg::detail::ord)</li> <li>actually_should_profile (should_profile_class)</li> </ul>"},{"location":"api/class_members/#b","title":"b","text":"<ul> <li>biasAcc (ILLIXR::imu_integrator_input)</li> <li>biasGyro (ILLIXR::imu_integrator_input)</li> <li>buffer (ILLIXR::record_coalescer)</li> <li>b (linalg::detail::ord)</li> </ul>"},{"location":"api/class_members/#c","title":"c","text":"<ul> <li>clear (ILLIXR::Event)</li> <li>check_should_stop (ILLIXR::Stoplight)</li> <li>check_shutdown_complete (ILLIXR::Stoplight)</li> <li>create (ILLIXR::dynamic_lib)</li> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>columns (ILLIXR::record_header)</li> <li>component_name (ILLIXR::start_end_logger)</li> <li>correct_pose (pose_prediction)</li> <li>cpu_time_start (print_timer2)</li> </ul>"},{"location":"api/class_members/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>dataset_time (ILLIXR::imu_cam_type)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>depth (ILLIXR::rgb_depth_type)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#e","title":"e","text":"<ul> <li>event_wrapper (ILLIXR::switchboard::event_wrapper)</li> <li>enqueue (ILLIXR::switchboard::topic_subscription)</li> </ul>"},{"location":"api/class_members/#f","title":"f","text":"<ul> <li>flush (ILLIXR::record_coalescer)</li> <li>fast_pose_reliable (pose_prediction)</li> </ul>"},{"location":"api/class_members/#g","title":"g","text":"<ul> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid, ILLIXR::switchboard::topic)</li> <li>guid_starts (ILLIXR::gen_guid)</li> <li>gyro_noise (ILLIXR::imu_params)</li> <li>gyro_walk (ILLIXR::imu_params)</li> <li>get_state (ILLIXR::managed_thread)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>get_ro (ILLIXR::switchboard::reader)</li> <li>get_ro_nullable (ILLIXR::switchboard::reader)</li> <li>get_rw (ILLIXR::switchboard::reader)</li> <li>get_reader (ILLIXR::switchboard)</li> <li>get_writer (ILLIXR::switchboard)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_offset (pose_prediction)</li> <li>get_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_members/#h","title":"h","text":"<ul> <li>hologram_input (ILLIXR::hologram_input)</li> <li>height (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#i","title":"i","text":"<ul> <li>is_set (ILLIXR::Event)</li> <li>is_used (ILLIXR::data_use_indicator)</li> <li>ipd (ILLIXR::hmd_physical_info)</li> <li>img0 (ILLIXR::imu_cam_type)</li> <li>img1 (ILLIXR::imu_cam_type)</li> <li>imu_cam_type (ILLIXR::imu_cam_type)</li> <li>imu_integrator_input (ILLIXR::imu_integrator_input)</li> <li>imu_integration_sigma (ILLIXR::imu_params)</li> <li>imu_raw_type (ILLIXR::imu_raw_type)</li> <li>imu_time (ILLIXR::imu_raw_type)</li> <li>id (ILLIXR::plugin, ILLIXR::record_header)</li> <li>init_time (ILLIXR::start_end_logger)</li> <li>image (ILLIXR::texture_pose)</li> <li>iteration_no (ILLIXR::threadloop)</li> <li>impl (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>identity_t (linalg::identity_t)</li> </ul>"},{"location":"api/class_members/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_members/#l","title":"l","text":"<ul> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>linear_a (ILLIXR::imu_cam_type)</li> <li>last_cam_integration_time (ILLIXR::imu_integrator_input)</li> <li>lookup_impl (ILLIXR::phonebook)</li> <li>last_log (ILLIXR::record_coalescer)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger)</li> <li>logger (ILLIXR::record_coalescer)</li> <li>load_plugin_factory (ILLIXR::runtime)</li> <li>load_so (ILLIXR::runtime)</li> <li>log_end (ILLIXR::start_end_logger)</li> <li>log_file (ILLIXR::start_end_logger)</li> <li>log_start (ILLIXR::start_end_logger)</li> <li>log_state (ILLIXR::start_end_logger)</li> <li>latest_quaternion (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_members/#m","title":"m","text":"<ul> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> <li>managed_thread (ILLIXR::managed_thread)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> <li>mat (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#n","title":"n","text":"<ul> <li>n_gravity (ILLIXR::imu_params)</li> <li>nominal_rate (ILLIXR::imu_params)</li> <li>name (ILLIXR::plugin, ILLIXR::record_header, ILLIXR::switchboard::topic, print_timer2)</li> </ul>"},{"location":"api/class_members/#o","title":"o","text":"<ul> <li>operator= (ILLIXR::data_use_indicator, ILLIXR::dynamic_lib)</li> <li>operator[] (ILLIXR::dynamic_lib, linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>orientation (ILLIXR::pose_type)</li> <li>operator bool (ILLIXR::record_coalescer)</li> <li>operator!= (ILLIXR::record_header)</li> <li>operator== (ILLIXR::record_header)</li> <li>operator underlying_type (ILLIXR::switchboard::event_wrapper)</li> <li>operator* (ILLIXR::switchboard::event_wrapper)</li> <li>offload_time (ILLIXR::texture_pose)</li> <li>operator() (linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;, linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;, linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;, linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;, linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::clamp, linalg::detail::getter&lt; 0 &gt;, linalg::detail::getter&lt; 1 &gt;, linalg::detail::getter&lt; 2 &gt;, linalg::detail::getter&lt; 3 &gt;, linalg::detail::lerp, linalg::detail::max, linalg::detail::min, linalg::detail::op_add, linalg::detail::op_and, linalg::detail::op_cmp, linalg::detail::op_div, linalg::detail::op_eq, linalg::detail::op_ge, linalg::detail::op_gt, linalg::detail::op_int, linalg::detail::op_le, linalg::detail::op_lsh, linalg::detail::op_lt, linalg::detail::op_mod, linalg::detail::op_mul, linalg::detail::op_ne, linalg::detail::op_neg, linalg::detail::op_not, linalg::detail::op_or, linalg::detail::op_pos, linalg::detail::op_rsh, linalg::detail::op_sub, linalg::detail::op_un, linalg::detail::op_xor, linalg::detail::select, linalg::detail::std_abs, linalg::detail::std_acos, linalg::detail::std_asin, linalg::detail::std_atan, linalg::detail::std_atan2, linalg::detail::std_ceil, linalg::detail::std_copysign, linalg::detail::std_cos, linalg::detail::std_cosh, linalg::detail::std_exp, linalg::detail::std_floor, linalg::detail::std_fmod, linalg::detail::std_log, linalg::detail::std_log10, linalg::detail::std_pow, linalg::detail::std_round, linalg::detail::std_sin, linalg::detail::std_sinh, linalg::detail::std_sqrt, linalg::detail::std_tan, linalg::detail::std_tanh, should_profile_class, std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;)</li> <li>operator U (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#p","title":"p","text":"<ul> <li>pose (ILLIXR::fast_pose_type)</li> <li>predict_computed_time (ILLIXR::fast_pose_type)</li> <li>predict_target_time (ILLIXR::fast_pose_type)</li> <li>params (ILLIXR::imu_integrator_input)</li> <li>position (ILLIXR::imu_integrator_input, ILLIXR::pose_type, ILLIXR::texture_pose)</li> <li>pos (ILLIXR::imu_raw_type)</li> <li>pb (ILLIXR::plugin)</li> <li>plugin (ILLIXR::plugin)</li> <li>pose_type (ILLIXR::pose_type)</li> <li>put (ILLIXR::switchboard::writer, ILLIXR::switchboard::topic)</li> <li>ptr (ILLIXR::switchboard)</li> <li>pose_time (ILLIXR::texture_pose)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> </ul>"},{"location":"api/class_members/#q","title":"q","text":"<ul> <li>quat (ILLIXR::imu_integrator_input, ILLIXR::imu_raw_type)</li> </ul>"},{"location":"api/class_members/#r","title":"r","text":"<ul> <li>register_impl (ILLIXR::phonebook)</li> <li>record_logger_ (ILLIXR::plugin)</li> <li>record (ILLIXR::record)</li> <li>rh (ILLIXR::record)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>render_pose (ILLIXR::rendered_frame)</li> <li>render_time (ILLIXR::rendered_frame)</li> <li>rendered_frame (ILLIXR::rendered_frame)</li> <li>rgb (ILLIXR::rgb_depth_type)</li> <li>rgb_depth_type (ILLIXR::rgb_depth_type)</li> <li>reader (ILLIXR::switchboard::reader)</li> <li>render_quaternion (ILLIXR::texture_pose)</li> <li>row (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#s","title":"s","text":"<ul> <li>set (ILLIXR::Event)</li> <li>signal_ready (ILLIXR::Stoplight)</li> <li>signal_should_stop (ILLIXR::Stoplight)</li> <li>signal_shutdown_complete (ILLIXR::Stoplight)</li> <li>seq (ILLIXR::hologram_input, ILLIXR::imu_integrator_seq, ILLIXR::texture_pose)</li> <li>start (ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::threadloop)</li> <li>state (ILLIXR::managed_thread)</li> <li>stop (ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::threadloop, ILLIXR::switchboard::topic)</li> <li>sensor_time (ILLIXR::pose_type)</li> <li>sample_time (ILLIXR::rendered_frame)</li> <li>swap_indices (ILLIXR::rendered_frame)</li> <li>start_end_logger (ILLIXR::start_end_logger)</li> <li>start_end_state (ILLIXR::start_end_logger)</li> <li>schedule (ILLIXR::switchboard, ILLIXR::switchboard::topic)</li> <li>switchboard (ILLIXR::switchboard)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>skip_no (ILLIXR::threadloop)</li> <li>skip_option (ILLIXR::threadloop)</li> <li>set_offset (pose_prediction)</li> <li>serial_no (print_timer2)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_members/#t","title":"t","text":"<ul> <li>time (ILLIXR::imu_cam_type)</li> <li>t_offset (ILLIXR::imu_integrator_input)</li> <li>thread_main (ILLIXR::managed_thread, ILLIXR::threadloop)</li> <li>to_string (ILLIXR::record_header)</li> <li>texture_handles (ILLIXR::rendered_frame)</li> <li>timestamp (ILLIXR::rgb_depth_type)</li> <li>try_register_topic (ILLIXR::switchboard)</li> <li>texture_pose (ILLIXR::texture_pose)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>topic (ILLIXR::switchboard::topic)</li> <li>ty (ILLIXR::switchboard::topic)</li> <li>thread_body (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_start (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_stop (ILLIXR::switchboard::topic_subscription)</li> <li>topic_subscription (ILLIXR::switchboard::topic_subscription)</li> <li>type (linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;, linalg::detail::make_seq_impl&lt; A, 0 &gt;, linalg::detail::make_seq_impl&lt; A, 1 &gt;, linalg::detail::make_seq_impl&lt; A, 2 &gt;, linalg::detail::make_seq_impl&lt; A, 3 &gt;, linalg::detail::make_seq_impl&lt; A, 4 &gt;, linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;, linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;, linalg::detail::scalars&lt;&gt;)</li> <li>true_pose_reliable (pose_prediction)</li> <li>timer (timer)</li> </ul>"},{"location":"api/class_members/#u","title":"u","text":"<ul> <li>used (ILLIXR::data_use_indicator)</li> <li>underlying_data (ILLIXR::switchboard::event_wrapper)</li> </ul>"},{"location":"api/class_members/#v","title":"v","text":"<ul> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> <li>velocity (ILLIXR::imu_integrator_input)</li> <li>vel (ILLIXR::imu_raw_type)</li> <li>values (ILLIXR::record)</li> <li>V (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> <li>vec (linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#w","title":"w","text":"<ul> <li>wait (ILLIXR::Event, ILLIXR::runtime)</li> <li>wait_timeout (ILLIXR::Event)</li> <li>wait_for_ready (ILLIXR::Stoplight)</li> <li>wait_for_shutdown_complete (ILLIXR::Stoplight)</li> <li>w_hat (ILLIXR::imu_raw_type)</li> <li>w_hat2 (ILLIXR::imu_raw_type)</li> <li>writer (ILLIXR::switchboard::writer)</li> <li>width (ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>w (linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>wall_time_start (print_timer2)</li> </ul>"},{"location":"api/class_members/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>x (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xy (linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xyz (linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#y","title":"y","text":"<ul> <li>y (linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#z","title":"z","text":"<ul> <li>z (linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#_1","title":"~","text":"<ul> <li>~dynamic_lib (ILLIXR::dynamic_lib)</li> <li>~managed_thread (ILLIXR::managed_thread)</li> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~start_end_logger (ILLIXR::start_end_logger)</li> <li>~event (ILLIXR::switchboard::event)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>~pose_prediction (pose_prediction)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_members/#_","title":"_","text":"<ul> <li>_m_cv (ILLIXR::Event)</li> <li>_m_mutex (ILLIXR::Event, ILLIXR::phonebook)</li> <li>_m_value (ILLIXR::Event)</li> <li>_m_ready (ILLIXR::Stoplight)</li> <li>_m_should_stop (ILLIXR::Stoplight)</li> <li>_m_shutdown_complete (ILLIXR::Stoplight)</li> <li>_m_handle (ILLIXR::dynamic_lib)</li> <li>_m_lib_path (ILLIXR::dynamic_lib)</li> <li>_m_body (ILLIXR::managed_thread)</li> <li>_m_on_start (ILLIXR::managed_thread)</li> <li>_m_on_stop (ILLIXR::managed_thread)</li> <li>_m_stop (ILLIXR::managed_thread)</li> <li>_m_thread (ILLIXR::managed_thread, ILLIXR::threadloop, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry (ILLIXR::phonebook, ILLIXR::switchboard)</li> <li>_m_topic (ILLIXR::switchboard::reader, ILLIXR::switchboard::writer)</li> <li>_m_record_logger (ILLIXR::switchboard, ILLIXR::switchboard::topic, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry_lock (ILLIXR::switchboard)</li> <li>_m_stoplight (ILLIXR::threadloop)</li> <li>_m_terminate (ILLIXR::threadloop)</li> <li>_p_one_iteration (ILLIXR::threadloop)</li> <li>_p_should_skip (ILLIXR::threadloop)</li> <li>_p_thread_setup (ILLIXR::threadloop)</li> <li>_m_cmap (ILLIXR::xlib_gl_extended_window)</li> <li>_m_latest_buffer (ILLIXR::switchboard::topic)</li> <li>_m_latest_buffer_size (ILLIXR::switchboard::topic)</li> <li>_m_latest_index (ILLIXR::switchboard::topic)</li> <li>_m_name (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions_lock (ILLIXR::switchboard::topic)</li> <li>_m_ty (ILLIXR::switchboard::topic)</li> <li>_m_callback (ILLIXR::switchboard::topic_subscription)</li> <li>_m_cb_log (ILLIXR::switchboard::topic_subscription)</li> <li>_m_ctok (ILLIXR::switchboard::topic_subscription)</li> <li>_m_dequeued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_enqueued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_idle_cycles (ILLIXR::switchboard::topic_subscription)</li> <li>_m_plugin_id (ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue (ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue_timeout (ILLIXR::switchboard::topic_subscription)</li> <li>_m_topic_name (ILLIXR::switchboard::topic_subscription)</li> <li>_p_duration (print_timer, print_timer::print_in_destructor, timer)</li> <li>_p_print_in_destructor (print_timer)</li> <li>_p_timer (print_timer)</li> <li>_p_account_name (print_timer::print_in_destructor)</li> <li>_p_now (timer)</li> <li>_p_start (timer)</li> </ul>"},{"location":"api/class_member_functions/","title":"Class Member Functions","text":""},{"location":"api/class_member_functions/#a","title":"a","text":"<ul> <li>allocate (ILLIXR::switchboard::writer)</li> </ul>"},{"location":"api/class_member_functions/#c","title":"c","text":"<ul> <li>clear (ILLIXR::Event)</li> <li>check_should_stop (ILLIXR::Stoplight)</li> <li>check_shutdown_complete (ILLIXR::Stoplight)</li> <li>create (ILLIXR::dynamic_lib)</li> <li>correct_pose (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> </ul>"},{"location":"api/class_member_functions/#e","title":"e","text":"<ul> <li>event_wrapper (ILLIXR::switchboard::event_wrapper)</li> <li>enqueue (ILLIXR::switchboard::topic_subscription)</li> </ul>"},{"location":"api/class_member_functions/#f","title":"f","text":"<ul> <li>flush (ILLIXR::record_coalescer)</li> <li>fast_pose_reliable (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#g","title":"g","text":"<ul> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid, ILLIXR::switchboard::topic)</li> <li>get_state (ILLIXR::managed_thread)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>get_ro (ILLIXR::switchboard::reader)</li> <li>get_ro_nullable (ILLIXR::switchboard::reader)</li> <li>get_rw (ILLIXR::switchboard::reader)</li> <li>get_reader (ILLIXR::switchboard)</li> <li>get_writer (ILLIXR::switchboard)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_offset (pose_prediction)</li> <li>get_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#h","title":"h","text":"<ul> <li>hologram_input (ILLIXR::hologram_input)</li> </ul>"},{"location":"api/class_member_functions/#i","title":"i","text":"<ul> <li>is_set (ILLIXR::Event)</li> <li>is_used (ILLIXR::data_use_indicator)</li> <li>imu_cam_type (ILLIXR::imu_cam_type)</li> <li>imu_integrator_input (ILLIXR::imu_integrator_input)</li> <li>imu_raw_type (ILLIXR::imu_raw_type)</li> <li>impl (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>identity_t (linalg::identity_t)</li> </ul>"},{"location":"api/class_member_functions/#l","title":"l","text":"<ul> <li>lookup_impl (ILLIXR::phonebook)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger)</li> <li>load_plugin_factory (ILLIXR::runtime)</li> <li>load_so (ILLIXR::runtime)</li> <li>log_end (ILLIXR::start_end_logger)</li> <li>log_start (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_member_functions/#m","title":"m","text":"<ul> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>managed_thread (ILLIXR::managed_thread)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> <li>mat (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#n","title":"n","text":"<ul> <li>name (ILLIXR::switchboard::topic)</li> </ul>"},{"location":"api/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (ILLIXR::data_use_indicator, ILLIXR::dynamic_lib)</li> <li>operator[] (ILLIXR::dynamic_lib, linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>operator bool (ILLIXR::record_coalescer)</li> <li>operator!= (ILLIXR::record_header)</li> <li>operator== (ILLIXR::record_header)</li> <li>operator underlying_type (ILLIXR::switchboard::event_wrapper)</li> <li>operator* (ILLIXR::switchboard::event_wrapper)</li> <li>operator() (linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;, linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;, linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;, linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;, linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::clamp, linalg::detail::getter&lt; 0 &gt;, linalg::detail::getter&lt; 1 &gt;, linalg::detail::getter&lt; 2 &gt;, linalg::detail::getter&lt; 3 &gt;, linalg::detail::lerp, linalg::detail::max, linalg::detail::min, linalg::detail::op_add, linalg::detail::op_and, linalg::detail::op_cmp, linalg::detail::op_div, linalg::detail::op_eq, linalg::detail::op_ge, linalg::detail::op_gt, linalg::detail::op_int, linalg::detail::op_le, linalg::detail::op_lsh, linalg::detail::op_lt, linalg::detail::op_mod, linalg::detail::op_mul, linalg::detail::op_ne, linalg::detail::op_neg, linalg::detail::op_not, linalg::detail::op_or, linalg::detail::op_pos, linalg::detail::op_rsh, linalg::detail::op_sub, linalg::detail::op_un, linalg::detail::op_xor, linalg::detail::select, linalg::detail::std_abs, linalg::detail::std_acos, linalg::detail::std_asin, linalg::detail::std_atan, linalg::detail::std_atan2, linalg::detail::std_ceil, linalg::detail::std_copysign, linalg::detail::std_cos, linalg::detail::std_cosh, linalg::detail::std_exp, linalg::detail::std_floor, linalg::detail::std_fmod, linalg::detail::std_log, linalg::detail::std_log10, linalg::detail::std_pow, linalg::detail::std_round, linalg::detail::std_sin, linalg::detail::std_sinh, linalg::detail::std_sqrt, linalg::detail::std_tan, linalg::detail::std_tanh, should_profile_class, std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;)</li> <li>operator U (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#p","title":"p","text":"<ul> <li>plugin (ILLIXR::plugin)</li> <li>pose_type (ILLIXR::pose_type)</li> <li>put (ILLIXR::switchboard::writer, ILLIXR::switchboard::topic)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> </ul>"},{"location":"api/class_member_functions/#r","title":"r","text":"<ul> <li>register_impl (ILLIXR::phonebook)</li> <li>record (ILLIXR::record)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>rendered_frame (ILLIXR::rendered_frame)</li> <li>rgb_depth_type (ILLIXR::rgb_depth_type)</li> <li>reader (ILLIXR::switchboard::reader)</li> <li>row (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#s","title":"s","text":"<ul> <li>set (ILLIXR::Event)</li> <li>signal_ready (ILLIXR::Stoplight)</li> <li>signal_should_stop (ILLIXR::Stoplight)</li> <li>signal_shutdown_complete (ILLIXR::Stoplight)</li> <li>start (ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::threadloop)</li> <li>stop (ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::threadloop, ILLIXR::switchboard::topic)</li> <li>start_end_logger (ILLIXR::start_end_logger)</li> <li>schedule (ILLIXR::switchboard, ILLIXR::switchboard::topic)</li> <li>switchboard (ILLIXR::switchboard)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>set_offset (pose_prediction)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_member_functions/#t","title":"t","text":"<ul> <li>thread_main (ILLIXR::managed_thread, ILLIXR::threadloop)</li> <li>to_string (ILLIXR::record_header)</li> <li>try_register_topic (ILLIXR::switchboard)</li> <li>texture_pose (ILLIXR::texture_pose)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>topic (ILLIXR::switchboard::topic)</li> <li>ty (ILLIXR::switchboard::topic)</li> <li>thread_body (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_start (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_stop (ILLIXR::switchboard::topic_subscription)</li> <li>topic_subscription (ILLIXR::switchboard::topic_subscription)</li> <li>true_pose_reliable (pose_prediction)</li> <li>timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#v","title":"v","text":"<ul> <li>vec (linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#w","title":"w","text":"<ul> <li>wait (ILLIXR::Event, ILLIXR::runtime)</li> <li>wait_timeout (ILLIXR::Event)</li> <li>wait_for_ready (ILLIXR::Stoplight)</li> <li>wait_for_shutdown_complete (ILLIXR::Stoplight)</li> <li>writer (ILLIXR::switchboard::writer)</li> </ul>"},{"location":"api/class_member_functions/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>xy (linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xyz (linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#_1","title":"~","text":"<ul> <li>~dynamic_lib (ILLIXR::dynamic_lib)</li> <li>~managed_thread (ILLIXR::managed_thread)</li> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~start_end_logger (ILLIXR::start_end_logger)</li> <li>~event (ILLIXR::switchboard::event)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>~pose_prediction (pose_prediction)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#_","title":"_","text":"<ul> <li>_p_one_iteration (ILLIXR::threadloop)</li> <li>_p_should_skip (ILLIXR::threadloop)</li> <li>_p_thread_setup (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/","title":"Class Member Variables","text":""},{"location":"api/class_member_variables/#a","title":"a","text":"<ul> <li>angular_v (ILLIXR::imu_cam_type)</li> <li>acc_noise (ILLIXR::imu_params)</li> <li>acc_walk (ILLIXR::imu_params)</li> <li>a_hat (ILLIXR::imu_raw_type)</li> <li>a_hat2 (ILLIXR::imu_raw_type)</li> <li>a (linalg::detail::ord)</li> <li>actually_should_profile (should_profile_class)</li> </ul>"},{"location":"api/class_member_variables/#b","title":"b","text":"<ul> <li>biasAcc (ILLIXR::imu_integrator_input)</li> <li>biasGyro (ILLIXR::imu_integrator_input)</li> <li>buffer (ILLIXR::record_coalescer)</li> <li>b (linalg::detail::ord)</li> </ul>"},{"location":"api/class_member_variables/#c","title":"c","text":"<ul> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>columns (ILLIXR::record_header)</li> <li>component_name (ILLIXR::start_end_logger)</li> <li>cpu_time_start (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#d","title":"d","text":"<ul> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>dataset_time (ILLIXR::imu_cam_type)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>depth (ILLIXR::rgb_depth_type)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#g","title":"g","text":"<ul> <li>guid_starts (ILLIXR::gen_guid)</li> <li>gyro_noise (ILLIXR::imu_params)</li> <li>gyro_walk (ILLIXR::imu_params)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#h","title":"h","text":"<ul> <li>height (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#i","title":"i","text":"<ul> <li>ipd (ILLIXR::hmd_physical_info)</li> <li>img0 (ILLIXR::imu_cam_type)</li> <li>img1 (ILLIXR::imu_cam_type)</li> <li>imu_integration_sigma (ILLIXR::imu_params)</li> <li>imu_time (ILLIXR::imu_raw_type)</li> <li>id (ILLIXR::plugin, ILLIXR::record_header)</li> <li>init_time (ILLIXR::start_end_logger)</li> <li>image (ILLIXR::texture_pose)</li> <li>iteration_no (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#l","title":"l","text":"<ul> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>linear_a (ILLIXR::imu_cam_type)</li> <li>last_cam_integration_time (ILLIXR::imu_integrator_input)</li> <li>last_log (ILLIXR::record_coalescer)</li> <li>logger (ILLIXR::record_coalescer)</li> <li>log_file (ILLIXR::start_end_logger)</li> <li>log_state (ILLIXR::start_end_logger)</li> <li>latest_quaternion (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#m","title":"m","text":"<ul> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#n","title":"n","text":"<ul> <li>n_gravity (ILLIXR::imu_params)</li> <li>nominal_rate (ILLIXR::imu_params)</li> <li>name (ILLIXR::plugin, ILLIXR::record_header, print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#o","title":"o","text":"<ul> <li>orientation (ILLIXR::pose_type)</li> <li>offload_time (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#p","title":"p","text":"<ul> <li>pose (ILLIXR::fast_pose_type)</li> <li>predict_computed_time (ILLIXR::fast_pose_type)</li> <li>predict_target_time (ILLIXR::fast_pose_type)</li> <li>params (ILLIXR::imu_integrator_input)</li> <li>position (ILLIXR::imu_integrator_input, ILLIXR::pose_type, ILLIXR::texture_pose)</li> <li>pos (ILLIXR::imu_raw_type)</li> <li>pb (ILLIXR::plugin)</li> <li>pose_time (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#q","title":"q","text":"<ul> <li>quat (ILLIXR::imu_integrator_input, ILLIXR::imu_raw_type)</li> </ul>"},{"location":"api/class_member_variables/#r","title":"r","text":"<ul> <li>record_logger_ (ILLIXR::plugin)</li> <li>rh (ILLIXR::record)</li> <li>render_pose (ILLIXR::rendered_frame)</li> <li>render_time (ILLIXR::rendered_frame)</li> <li>rgb (ILLIXR::rgb_depth_type)</li> <li>render_quaternion (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#s","title":"s","text":"<ul> <li>seq (ILLIXR::hologram_input, ILLIXR::imu_integrator_seq, ILLIXR::texture_pose)</li> <li>sensor_time (ILLIXR::pose_type)</li> <li>sample_time (ILLIXR::rendered_frame)</li> <li>swap_indices (ILLIXR::rendered_frame)</li> <li>skip_no (ILLIXR::threadloop)</li> <li>serial_no (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#t","title":"t","text":"<ul> <li>time (ILLIXR::imu_cam_type)</li> <li>t_offset (ILLIXR::imu_integrator_input)</li> <li>texture_handles (ILLIXR::rendered_frame)</li> <li>timestamp (ILLIXR::rgb_depth_type)</li> </ul>"},{"location":"api/class_member_variables/#u","title":"u","text":"<ul> <li>used (ILLIXR::data_use_indicator)</li> <li>underlying_data (ILLIXR::switchboard::event_wrapper)</li> </ul>"},{"location":"api/class_member_variables/#v","title":"v","text":"<ul> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> <li>velocity (ILLIXR::imu_integrator_input)</li> <li>vel (ILLIXR::imu_raw_type)</li> <li>values (ILLIXR::record)</li> </ul>"},{"location":"api/class_member_variables/#w","title":"w","text":"<ul> <li>w_hat (ILLIXR::imu_raw_type)</li> <li>w_hat2 (ILLIXR::imu_raw_type)</li> <li>width (ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>w (linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>wall_time_start (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#x","title":"x","text":"<ul> <li>x (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#y","title":"y","text":"<ul> <li>y (linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#z","title":"z","text":"<ul> <li>z (linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#_","title":"_","text":"<ul> <li>_m_cv (ILLIXR::Event)</li> <li>_m_mutex (ILLIXR::Event, ILLIXR::phonebook)</li> <li>_m_value (ILLIXR::Event)</li> <li>_m_ready (ILLIXR::Stoplight)</li> <li>_m_should_stop (ILLIXR::Stoplight)</li> <li>_m_shutdown_complete (ILLIXR::Stoplight)</li> <li>_m_handle (ILLIXR::dynamic_lib)</li> <li>_m_lib_path (ILLIXR::dynamic_lib)</li> <li>_m_body (ILLIXR::managed_thread)</li> <li>_m_on_start (ILLIXR::managed_thread)</li> <li>_m_on_stop (ILLIXR::managed_thread)</li> <li>_m_stop (ILLIXR::managed_thread)</li> <li>_m_thread (ILLIXR::managed_thread, ILLIXR::threadloop, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry (ILLIXR::phonebook, ILLIXR::switchboard)</li> <li>_m_topic (ILLIXR::switchboard::reader, ILLIXR::switchboard::writer)</li> <li>_m_record_logger (ILLIXR::switchboard, ILLIXR::switchboard::topic, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry_lock (ILLIXR::switchboard)</li> <li>_m_stoplight (ILLIXR::threadloop)</li> <li>_m_terminate (ILLIXR::threadloop)</li> <li>_m_cmap (ILLIXR::xlib_gl_extended_window)</li> <li>_m_latest_buffer (ILLIXR::switchboard::topic)</li> <li>_m_latest_buffer_size (ILLIXR::switchboard::topic)</li> <li>_m_latest_index (ILLIXR::switchboard::topic)</li> <li>_m_name (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions_lock (ILLIXR::switchboard::topic)</li> <li>_m_ty (ILLIXR::switchboard::topic)</li> <li>_m_callback (ILLIXR::switchboard::topic_subscription)</li> <li>_m_cb_log (ILLIXR::switchboard::topic_subscription)</li> <li>_m_ctok (ILLIXR::switchboard::topic_subscription)</li> <li>_m_dequeued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_enqueued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_idle_cycles (ILLIXR::switchboard::topic_subscription)</li> <li>_m_plugin_id (ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue (ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue_timeout (ILLIXR::switchboard::topic_subscription)</li> <li>_m_topic_name (ILLIXR::switchboard::topic_subscription)</li> <li>_p_duration (print_timer, print_timer::print_in_destructor, timer)</li> <li>_p_print_in_destructor (print_timer)</li> <li>_p_timer (print_timer)</li> <li>_p_account_name (print_timer::print_in_destructor)</li> <li>_p_now (timer)</li> <li>_p_start (timer)</li> </ul>"},{"location":"api/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"api/class_member_typedefs/#p","title":"p","text":"<ul> <li>ptr (ILLIXR::switchboard)</li> </ul>"},{"location":"api/class_member_typedefs/#t","title":"t","text":"<ul> <li>type (linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;, linalg::detail::make_seq_impl&lt; A, 0 &gt;, linalg::detail::make_seq_impl&lt; A, 1 &gt;, linalg::detail::make_seq_impl&lt; A, 2 &gt;, linalg::detail::make_seq_impl&lt; A, 3 &gt;, linalg::detail::make_seq_impl&lt; A, 4 &gt;, linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;, linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;, linalg::detail::scalars&lt;&gt;)</li> </ul>"},{"location":"api/class_member_typedefs/#v","title":"v","text":"<ul> <li>V (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_enums/","title":"Class Member Enums","text":""},{"location":"api/class_member_enums/#a","title":"a","text":"<ul> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> </ul>"},{"location":"api/class_member_enums/#s","title":"s","text":"<ul> <li>state (ILLIXR::managed_thread)</li> <li>start_end_state (ILLIXR::start_end_logger)</li> <li>skip_option (ILLIXR::threadloop)</li> </ul>"},{"location":"api/namespace_members/","title":"Namespace Members","text":""},{"location":"api/namespace_members/#a","title":"a","text":"<ul> <li>abort (ILLIXR)</li> <li>abs (linalg)</li> <li>acos (linalg)</li> <li>adjugate (linalg)</li> <li>all (linalg)</li> <li>angle (linalg)</li> <li>any (linalg)</li> <li>apply (linalg)</li> <li>apply_t (linalg)</li> <li>argmax (linalg)</li> <li>argmin (linalg)</li> <li>asin (linalg)</li> <li>atan (linalg)</li> <li>atan2 (linalg)</li> </ul>"},{"location":"api/namespace_members/#b","title":"b","text":"<ul> <li>begin (linalg)</li> <li>bool1 (linalg::aliases)</li> <li>bool1x1 (linalg::aliases)</li> <li>bool1x2 (linalg::aliases)</li> <li>bool1x3 (linalg::aliases)</li> <li>bool1x4 (linalg::aliases)</li> <li>bool2 (linalg::aliases)</li> <li>bool2x1 (linalg::aliases)</li> <li>bool2x2 (linalg::aliases)</li> <li>bool2x3 (linalg::aliases)</li> <li>bool2x4 (linalg::aliases)</li> <li>bool3 (linalg::aliases)</li> <li>bool3x1 (linalg::aliases)</li> <li>bool3x2 (linalg::aliases)</li> <li>bool3x3 (linalg::aliases)</li> <li>bool3x4 (linalg::aliases)</li> <li>bool4 (linalg::aliases)</li> <li>bool4x1 (linalg::aliases)</li> <li>bool4x2 (linalg::aliases)</li> <li>bool4x3 (linalg::aliases)</li> <li>bool4x4 (linalg::aliases)</li> <li>byte1 (linalg::aliases)</li> <li>byte2 (linalg::aliases)</li> <li>byte3 (linalg::aliases)</li> <li>byte4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#c","title":"c","text":"<ul> <li>ceil (linalg)</li> <li>clamp (linalg)</li> <li>comatrix (linalg)</li> <li>compare (linalg)</li> <li>copysign (linalg)</li> <li>cos (linalg)</li> <li>cosh (linalg)</li> <li>cross (linalg)</li> <li>conv_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_members/#d","title":"d","text":"<ul> <li>determinant (linalg)</li> <li>diagonal (linalg)</li> <li>distance (linalg)</li> <li>distance2 (linalg)</li> <li>dot (linalg)</li> <li>double1 (linalg::aliases)</li> <li>double1x1 (linalg::aliases)</li> <li>double1x2 (linalg::aliases)</li> <li>double1x3 (linalg::aliases)</li> <li>double1x4 (linalg::aliases)</li> <li>double2 (linalg::aliases)</li> <li>double2x1 (linalg::aliases)</li> <li>double2x2 (linalg::aliases)</li> <li>double2x3 (linalg::aliases)</li> <li>double2x4 (linalg::aliases)</li> <li>double3 (linalg::aliases)</li> <li>double3x1 (linalg::aliases)</li> <li>double3x2 (linalg::aliases)</li> <li>double3x3 (linalg::aliases)</li> <li>double3x4 (linalg::aliases)</li> <li>double4 (linalg::aliases)</li> <li>double4x1 (linalg::aliases)</li> <li>double4x2 (linalg::aliases)</li> <li>double4x3 (linalg::aliases)</li> <li>double4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#e","title":"e","text":"<ul> <li>ENABLE_VERBOSE_ERRORS (ILLIXR)</li> <li>end (linalg)</li> <li>equal (linalg)</li> <li>exp (linalg)</li> </ul>"},{"location":"api/namespace_members/#f","title":"f","text":"<ul> <li>FB_HEIGHT (ILLIXR)</li> <li>FB_WIDTH (ILLIXR)</li> <li>floor (linalg)</li> <li>fmod (linalg)</li> <li>fold (linalg)</li> <li>frustum_matrix (linalg)</li> <li>fwd_axis (linalg)</li> <li>float1 (linalg::aliases)</li> <li>float1x1 (linalg::aliases)</li> <li>float1x2 (linalg::aliases)</li> <li>float1x3 (linalg::aliases)</li> <li>float1x4 (linalg::aliases)</li> <li>float2 (linalg::aliases)</li> <li>float2x1 (linalg::aliases)</li> <li>float2x2 (linalg::aliases)</li> <li>float2x3 (linalg::aliases)</li> <li>float2x4 (linalg::aliases)</li> <li>float3 (linalg::aliases)</li> <li>float3x1 (linalg::aliases)</li> <li>float3x2 (linalg::aliases)</li> <li>float3x3 (linalg::aliases)</li> <li>float3x4 (linalg::aliases)</li> <li>float4 (linalg::aliases)</li> <li>float4x1 (linalg::aliases)</li> <li>float4x2 (linalg::aliases)</li> <li>float4x3 (linalg::aliases)</li> <li>float4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#g","title":"g","text":"<ul> <li>getenv_or (ILLIXR)</li> <li>gequal (linalg)</li> <li>greater (linalg)</li> </ul>"},{"location":"api/namespace_members/#i","title":"i","text":"<ul> <li>identity (linalg)</li> <li>inverse (linalg)</li> <li>int1 (linalg::aliases)</li> <li>int1x1 (linalg::aliases)</li> <li>int1x2 (linalg::aliases)</li> <li>int1x3 (linalg::aliases)</li> <li>int1x4 (linalg::aliases)</li> <li>int2 (linalg::aliases)</li> <li>int2x1 (linalg::aliases)</li> <li>int2x2 (linalg::aliases)</li> <li>int2x3 (linalg::aliases)</li> <li>int2x4 (linalg::aliases)</li> <li>int3 (linalg::aliases)</li> <li>int3x1 (linalg::aliases)</li> <li>int3x2 (linalg::aliases)</li> <li>int3x3 (linalg::aliases)</li> <li>int3x4 (linalg::aliases)</li> <li>int4 (linalg::aliases)</li> <li>int4x1 (linalg::aliases)</li> <li>int4x2 (linalg::aliases)</li> <li>int4x3 (linalg::aliases)</li> <li>int4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#l","title":"l","text":"<ul> <li>LOG_BUFFER_DELAY (ILLIXR)</li> <li>length (linalg)</li> <li>length2 (linalg)</li> <li>lequal (linalg)</li> <li>lerp (linalg)</li> <li>less (linalg)</li> <li>log (linalg)</li> <li>log10 (linalg)</li> </ul>"},{"location":"api/namespace_members/#m","title":"m","text":"<ul> <li>make_seq (linalg::detail)</li> <li>map (linalg)</li> <li>max (linalg)</li> <li>maxelem (linalg)</li> <li>min (linalg)</li> <li>minelem (linalg)</li> <li>mul (linalg)</li> </ul>"},{"location":"api/namespace_members/#n","title":"n","text":"<ul> <li>nequal (linalg)</li> <li>nlerp (linalg)</li> <li>normalize (linalg)</li> </ul>"},{"location":"api/namespace_members/#o","title":"o","text":"<ul> <li>operator!= (linalg::detail, linalg)</li> <li>operator&lt; (linalg::detail, linalg)</li> <li>operator&lt;= (linalg::detail, linalg)</li> <li>operator== (linalg::detail, linalg)</li> <li>operator&gt; (linalg::detail, linalg)</li> <li>operator&gt;= (linalg::detail, linalg)</li> <li>operator&lt;&lt; (linalg::ostream_overloads, linalg)</li> <li>operator! (linalg)</li> <li>operator% (linalg)</li> <li>operator%= (linalg)</li> <li>operator&amp; (linalg)</li> <li>operator&amp;= (linalg)</li> <li>operator* (linalg)</li> <li>operator*= (linalg)</li> <li>operator+ (linalg)</li> <li>operator+= (linalg)</li> <li>operator- (linalg)</li> <li>operator-= (linalg)</li> <li>operator/ (linalg)</li> <li>operator/= (linalg)</li> <li>operator&lt;&lt;= (linalg)</li> <li>operator&gt;&gt; (linalg)</li> <li>operator&gt;&gt;= (linalg)</li> <li>operator^ (linalg)</li> <li>operator^= (linalg)</li> <li>operator| (linalg)</li> <li>operator|= (linalg)</li> <li>operator~ (linalg)</li> <li>outerprod (linalg)</li> </ul>"},{"location":"api/namespace_members/#p","title":"p","text":"<ul> <li>projection (ILLIXR::math_util)</li> <li>projection_fov (ILLIXR::math_util)</li> <li>plugin_factory (ILLIXR)</li> <li>plugin_id_t (ILLIXR)</li> <li>perspective_matrix (linalg)</li> <li>pose_matrix (linalg)</li> <li>pow (linalg)</li> <li>product (linalg)</li> </ul>"},{"location":"api/namespace_members/#q","title":"q","text":"<ul> <li>qangle (linalg)</li> <li>qaxis (linalg)</li> <li>qconj (linalg)</li> <li>qexp (linalg)</li> <li>qinv (linalg)</li> <li>qlog (linalg)</li> <li>qmat (linalg)</li> <li>qmul (linalg)</li> <li>qnlerp (linalg)</li> <li>qpow (linalg)</li> <li>qrot (linalg)</li> <li>qslerp (linalg)</li> <li>qxdir (linalg)</li> <li>qydir (linalg)</li> <li>qzdir (linalg)</li> </ul>"},{"location":"api/namespace_members/#r","title":"r","text":"<ul> <li>report_and_clear_errno (ILLIXR)</li> <li>runtime_factory (ILLIXR)</li> <li>ret_t (linalg::detail)</li> <li>rot (linalg)</li> <li>rotation_matrix (linalg)</li> <li>rotation_quat (linalg)</li> <li>round (linalg)</li> </ul>"},{"location":"api/namespace_members/#s","title":"s","text":"<ul> <li>str_to_bool (ILLIXR)</li> <li>short1 (linalg::aliases)</li> <li>short2 (linalg::aliases)</li> <li>short3 (linalg::aliases)</li> <li>short4 (linalg::aliases)</li> <li>scalars_t (linalg::detail)</li> <li>swizzle (linalg::detail, linalg)</li> <li>scalar_t (linalg)</li> <li>scaling_matrix (linalg)</li> <li>select (linalg)</li> <li>sin (linalg)</li> <li>sinh (linalg)</li> <li>slerp (linalg)</li> <li>sqrt (linalg)</li> <li>submat (linalg)</li> <li>subvec (linalg)</li> <li>sum (linalg)</li> </ul>"},{"location":"api/namespace_members/#t","title":"t","text":"<ul> <li>time_type (ILLIXR)</li> <li>tan (linalg)</li> <li>tanh (linalg)</li> <li>trace (linalg)</li> <li>translation_matrix (linalg)</li> <li>transpose (linalg)</li> </ul>"},{"location":"api/namespace_members/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> <li>uint1 (linalg::aliases)</li> <li>uint2 (linalg::aliases)</li> <li>uint3 (linalg::aliases)</li> <li>uint4 (linalg::aliases)</li> <li>ushort1 (linalg::aliases)</li> <li>ushort2 (linalg::aliases)</li> <li>ushort3 (linalg::aliases)</li> <li>ushort4 (linalg::aliases)</li> <li>uangle (linalg)</li> </ul>"},{"location":"api/namespace_members/#v","title":"v","text":"<ul> <li>void_ptr (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#z","title":"z","text":"<ul> <li>z_range (linalg)</li> <li>zip (linalg)</li> </ul>"},{"location":"api/namespace_members/#_","title":"_","text":"<ul> <li>__plugin_start_header (ILLIXR)</li> <li>__switchboard_callback_header (ILLIXR)</li> <li>__switchboard_topic_stop_header (ILLIXR)</li> <li>__threadloop_iteration_header (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"api/namespace_member_functions/#a","title":"a","text":"<ul> <li>abort (ILLIXR)</li> <li>abs (linalg)</li> <li>acos (linalg)</li> <li>adjugate (linalg)</li> <li>all (linalg)</li> <li>angle (linalg)</li> <li>any (linalg)</li> <li>apply (linalg)</li> <li>argmax (linalg)</li> <li>argmin (linalg)</li> <li>asin (linalg)</li> <li>atan (linalg)</li> <li>atan2 (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#b","title":"b","text":"<ul> <li>begin (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#c","title":"c","text":"<ul> <li>ceil (linalg)</li> <li>clamp (linalg)</li> <li>comatrix (linalg)</li> <li>compare (linalg)</li> <li>copysign (linalg)</li> <li>cos (linalg)</li> <li>cosh (linalg)</li> <li>cross (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#d","title":"d","text":"<ul> <li>determinant (linalg)</li> <li>diagonal (linalg)</li> <li>distance (linalg)</li> <li>distance2 (linalg)</li> <li>dot (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#e","title":"e","text":"<ul> <li>end (linalg)</li> <li>equal (linalg)</li> <li>exp (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#f","title":"f","text":"<ul> <li>floor (linalg)</li> <li>fmod (linalg)</li> <li>fold (linalg)</li> <li>frustum_matrix (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#g","title":"g","text":"<ul> <li>getenv_or (ILLIXR)</li> <li>gequal (linalg)</li> <li>greater (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#i","title":"i","text":"<ul> <li>inverse (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#l","title":"l","text":"<ul> <li>length (linalg)</li> <li>length2 (linalg)</li> <li>lequal (linalg)</li> <li>lerp (linalg)</li> <li>less (linalg)</li> <li>log (linalg)</li> <li>log10 (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#m","title":"m","text":"<ul> <li>map (linalg)</li> <li>max (linalg)</li> <li>maxelem (linalg)</li> <li>min (linalg)</li> <li>minelem (linalg)</li> <li>mul (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#n","title":"n","text":"<ul> <li>nequal (linalg)</li> <li>nlerp (linalg)</li> <li>normalize (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator!= (linalg::detail, linalg)</li> <li>operator&lt; (linalg::detail, linalg)</li> <li>operator&lt;= (linalg::detail, linalg)</li> <li>operator== (linalg::detail, linalg)</li> <li>operator&gt; (linalg::detail, linalg)</li> <li>operator&gt;= (linalg::detail, linalg)</li> <li>operator&lt;&lt; (linalg::ostream_overloads, linalg)</li> <li>operator! (linalg)</li> <li>operator% (linalg)</li> <li>operator%= (linalg)</li> <li>operator&amp; (linalg)</li> <li>operator&amp;= (linalg)</li> <li>operator* (linalg)</li> <li>operator*= (linalg)</li> <li>operator+ (linalg)</li> <li>operator+= (linalg)</li> <li>operator- (linalg)</li> <li>operator-= (linalg)</li> <li>operator/ (linalg)</li> <li>operator/= (linalg)</li> <li>operator&lt;&lt;= (linalg)</li> <li>operator&gt;&gt; (linalg)</li> <li>operator&gt;&gt;= (linalg)</li> <li>operator^ (linalg)</li> <li>operator^= (linalg)</li> <li>operator| (linalg)</li> <li>operator|= (linalg)</li> <li>operator~ (linalg)</li> <li>outerprod (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#p","title":"p","text":"<ul> <li>projection (ILLIXR::math_util)</li> <li>projection_fov (ILLIXR::math_util)</li> <li>perspective_matrix (linalg)</li> <li>pose_matrix (linalg)</li> <li>pow (linalg)</li> <li>product (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#q","title":"q","text":"<ul> <li>qangle (linalg)</li> <li>qaxis (linalg)</li> <li>qconj (linalg)</li> <li>qexp (linalg)</li> <li>qinv (linalg)</li> <li>qlog (linalg)</li> <li>qmat (linalg)</li> <li>qmul (linalg)</li> <li>qnlerp (linalg)</li> <li>qpow (linalg)</li> <li>qrot (linalg)</li> <li>qslerp (linalg)</li> <li>qxdir (linalg)</li> <li>qydir (linalg)</li> <li>qzdir (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#r","title":"r","text":"<ul> <li>report_and_clear_errno (ILLIXR)</li> <li>runtime_factory (ILLIXR)</li> <li>rot (linalg)</li> <li>rotation_matrix (linalg)</li> <li>rotation_quat (linalg)</li> <li>round (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#s","title":"s","text":"<ul> <li>str_to_bool (ILLIXR)</li> <li>swizzle (linalg::detail, linalg)</li> <li>scaling_matrix (linalg)</li> <li>select (linalg)</li> <li>sin (linalg)</li> <li>sinh (linalg)</li> <li>slerp (linalg)</li> <li>sqrt (linalg)</li> <li>submat (linalg)</li> <li>subvec (linalg)</li> <li>sum (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#t","title":"t","text":"<ul> <li>tan (linalg)</li> <li>tanh (linalg)</li> <li>trace (linalg)</li> <li>translation_matrix (linalg)</li> <li>transpose (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#u","title":"u","text":"<ul> <li>uangle (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#z","title":"z","text":"<ul> <li>zip (linalg)</li> </ul>"},{"location":"api/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"api/namespace_member_variables/#e","title":"e","text":"<ul> <li>ENABLE_VERBOSE_ERRORS (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#f","title":"f","text":"<ul> <li>FB_HEIGHT (ILLIXR)</li> <li>FB_WIDTH (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#i","title":"i","text":"<ul> <li>identity (linalg)</li> </ul>"},{"location":"api/namespace_member_variables/#l","title":"l","text":"<ul> <li>LOG_BUFFER_DELAY (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#_","title":"_","text":"<ul> <li>__plugin_start_header (ILLIXR)</li> <li>__switchboard_callback_header (ILLIXR)</li> <li>__switchboard_topic_stop_header (ILLIXR)</li> <li>__threadloop_iteration_header (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"api/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>apply_t (linalg)</li> </ul>"},{"location":"api/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>bool1 (linalg::aliases)</li> <li>bool1x1 (linalg::aliases)</li> <li>bool1x2 (linalg::aliases)</li> <li>bool1x3 (linalg::aliases)</li> <li>bool1x4 (linalg::aliases)</li> <li>bool2 (linalg::aliases)</li> <li>bool2x1 (linalg::aliases)</li> <li>bool2x2 (linalg::aliases)</li> <li>bool2x3 (linalg::aliases)</li> <li>bool2x4 (linalg::aliases)</li> <li>bool3 (linalg::aliases)</li> <li>bool3x1 (linalg::aliases)</li> <li>bool3x2 (linalg::aliases)</li> <li>bool3x3 (linalg::aliases)</li> <li>bool3x4 (linalg::aliases)</li> <li>bool4 (linalg::aliases)</li> <li>bool4x1 (linalg::aliases)</li> <li>bool4x2 (linalg::aliases)</li> <li>bool4x3 (linalg::aliases)</li> <li>bool4x4 (linalg::aliases)</li> <li>byte1 (linalg::aliases)</li> <li>byte2 (linalg::aliases)</li> <li>byte3 (linalg::aliases)</li> <li>byte4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>conv_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>double1 (linalg::aliases)</li> <li>double1x1 (linalg::aliases)</li> <li>double1x2 (linalg::aliases)</li> <li>double1x3 (linalg::aliases)</li> <li>double1x4 (linalg::aliases)</li> <li>double2 (linalg::aliases)</li> <li>double2x1 (linalg::aliases)</li> <li>double2x2 (linalg::aliases)</li> <li>double2x3 (linalg::aliases)</li> <li>double2x4 (linalg::aliases)</li> <li>double3 (linalg::aliases)</li> <li>double3x1 (linalg::aliases)</li> <li>double3x2 (linalg::aliases)</li> <li>double3x3 (linalg::aliases)</li> <li>double3x4 (linalg::aliases)</li> <li>double4 (linalg::aliases)</li> <li>double4x1 (linalg::aliases)</li> <li>double4x2 (linalg::aliases)</li> <li>double4x3 (linalg::aliases)</li> <li>double4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>float1 (linalg::aliases)</li> <li>float1x1 (linalg::aliases)</li> <li>float1x2 (linalg::aliases)</li> <li>float1x3 (linalg::aliases)</li> <li>float1x4 (linalg::aliases)</li> <li>float2 (linalg::aliases)</li> <li>float2x1 (linalg::aliases)</li> <li>float2x2 (linalg::aliases)</li> <li>float2x3 (linalg::aliases)</li> <li>float2x4 (linalg::aliases)</li> <li>float3 (linalg::aliases)</li> <li>float3x1 (linalg::aliases)</li> <li>float3x2 (linalg::aliases)</li> <li>float3x3 (linalg::aliases)</li> <li>float3x4 (linalg::aliases)</li> <li>float4 (linalg::aliases)</li> <li>float4x1 (linalg::aliases)</li> <li>float4x2 (linalg::aliases)</li> <li>float4x3 (linalg::aliases)</li> <li>float4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>int1 (linalg::aliases)</li> <li>int1x1 (linalg::aliases)</li> <li>int1x2 (linalg::aliases)</li> <li>int1x3 (linalg::aliases)</li> <li>int1x4 (linalg::aliases)</li> <li>int2 (linalg::aliases)</li> <li>int2x1 (linalg::aliases)</li> <li>int2x2 (linalg::aliases)</li> <li>int2x3 (linalg::aliases)</li> <li>int2x4 (linalg::aliases)</li> <li>int3 (linalg::aliases)</li> <li>int3x1 (linalg::aliases)</li> <li>int3x2 (linalg::aliases)</li> <li>int3x3 (linalg::aliases)</li> <li>int3x4 (linalg::aliases)</li> <li>int4 (linalg::aliases)</li> <li>int4x1 (linalg::aliases)</li> <li>int4x2 (linalg::aliases)</li> <li>int4x3 (linalg::aliases)</li> <li>int4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>make_seq (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>plugin_factory (ILLIXR)</li> <li>plugin_id_t (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>ret_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>short1 (linalg::aliases)</li> <li>short2 (linalg::aliases)</li> <li>short3 (linalg::aliases)</li> <li>short4 (linalg::aliases)</li> <li>scalars_t (linalg::detail)</li> <li>scalar_t (linalg)</li> </ul>"},{"location":"api/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>time_type (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> <li>uint1 (linalg::aliases)</li> <li>uint2 (linalg::aliases)</li> <li>uint3 (linalg::aliases)</li> <li>uint4 (linalg::aliases)</li> <li>ushort1 (linalg::aliases)</li> <li>ushort2 (linalg::aliases)</li> <li>ushort3 (linalg::aliases)</li> <li>ushort4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>void_ptr (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"api/namespace_member_enums/#f","title":"f","text":"<ul> <li>fwd_axis (linalg)</li> </ul>"},{"location":"api/namespace_member_enums/#z","title":"z","text":"<ul> <li>z_range (linalg)</li> </ul>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#c","title":"c","text":"<ul> <li>count_duration (cpu_timer.hpp)</li> <li>cpp_clock_gettime (cpu_timer.hpp)</li> </ul>"},{"location":"api/functions/#g","title":"g","text":"<ul> <li>gen_serial_no (cpu_timer.hpp)</li> </ul>"},{"location":"api/functions/#i","title":"i","text":"<ul> <li>init_and_link (shader_util.hpp)</li> </ul>"},{"location":"api/functions/#m","title":"m","text":"<ul> <li>MessageCallback (shader_util.hpp)</li> </ul>"},{"location":"api/functions/#t","title":"t","text":"<ul> <li>thread_cpu_time (cpu_timer.hpp, switchboard.hpp)</li> <li>timed_thread (cpu_timer.hpp)</li> </ul>"},{"location":"api/macros/","title":"Macros","text":""},{"location":"api/macros/#f","title":"f","text":"<ul> <li>FB_HEIGHT (global_module_defs.hpp)</li> <li>FB_WIDTH (global_module_defs.hpp)</li> </ul>"},{"location":"api/macros/#g","title":"g","text":"<ul> <li>GLX_CONTEXT_MAJOR_VERSION_ARB (extended_window.hpp)</li> <li>GLX_CONTEXT_MINOR_VERSION_ARB (extended_window.hpp)</li> </ul>"},{"location":"api/macros/#l","title":"l","text":"<ul> <li>LINALG_CONSTEXPR14 (linalg.hpp)</li> <li>LINALG_H (linalg.hpp)</li> </ul>"},{"location":"api/macros/#n","title":"n","text":"<ul> <li>NANO_SEC (data_format.hpp)</li> </ul>"},{"location":"api/macros/#p","title":"p","text":"<ul> <li>PRINT_CPU_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_RECORD_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_WALL_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PLUGIN_MAIN (plugin.hpp)</li> </ul>"},{"location":"api/macros/#r","title":"r","text":"<ul> <li>RAC_ERRNO (error_util.hpp)</li> <li>RAC_ERRNO_MSG (error_util.hpp)</li> </ul>"},{"location":"api/macros/#u","title":"u","text":"<ul> <li>USE_ALT_EYE_FORMAT (data_format.hpp)</li> </ul>"},{"location":"api/variables/","title":"Variables","text":""},{"location":"api/variables/#g","title":"g","text":"<ul> <li>glXCreateContextAttribsARBProc (extended_window.hpp)</li> <li>GL_MAX_LOG_LENGTH (shader_util.hpp)</li> </ul>"},{"location":"api/variables/#s","title":"s","text":"<ul> <li>should_profile (cpu_timer.hpp)</li> </ul>"},{"location":"api/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}