{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ILLIXR Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first fully open-source Extended Reality (XR) system and testbed. The modular, extensible, and OpenXR -compatible ILLIXR runtime integrates state-of-the-art XR components into a complete XR system. The testbed is part of the broader ILLIXR consortium , an industry-supported community effort to democratize XR systems research, development, and benchmarking. You can find the complete ILLIXR system here . ILLIXR also provides its components in standalone configurations to enable architects and system designers to research each component in isolation. The standalone components are packaged together in the as of the v3.1.0 release of ILLIXR. ILLIXR's modular and extensible runtime allows adding new components and swapping different implementations of a given component. ILLIXR currently contains the following components: Perception Eye Tracking RITNet ** Scene Reconstruction ElasticFusion ** KinectFusion ** Simultaneous Localization and Mapping OpenVINS ** Cameras and IMUs ZED Mini Intel RealSense Visual Chromatic aberration correction Computational holography for adaptive multi-focal displays ** Lens distortion correction Asynchronous Reprojection (TimeWarp) Aural Audio encoding ** Audio playback ** (** Source is hosted in an external repository under the ILLIXR project .) We continue to add more components (new components and new implementations). Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked GitHub repository for proper attribution to its authors. Papers, talks, demos, consortium A paper with details on ILLIXR, including its components, runtime, telemetry support, and a comprehensive analysis of performance, power, and quality on desktop and embedded systems. A talk presented at NVIDIA GTC'21 describing ILLIXR and announcing the ILLIXR consortium: Video . Slides . A demo of an OpenXR application running with ILLIXR. For more up-to-date list of related papers, demos, and talks, please visit illixr.org . The ILLIXR consortium is an industry-supported community effort to democratize XR systems research, development, and benchmarking. Visit our website for more information. The ILLIXR consortium is also holding a biweekly consortium meeting. For past meetings, for more information, past meeting recordings, and request for presenting, please visit here . Please join our Discord for announcement. Citation We request that you cite our following paper when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published. @ARTICLE {9741292, author = {M. Huzaifa and R. Desai and S. Grayson and X. Jiang and Y. Jing and J. Lee and F. Lu and Y. Pang and J. Ravichandran and F. Sinclair and B. Tian and H. Yuan and J. Zhang and S. V. Adve}, journal = {IEEE Micro}, title = {ILLIXR: An Open Testbed to Enable Extended Reality Systems Research}, year = {2022}, volume = {42}, number = {04}, issn = {1937-4143}, pages = {97-106}, abstract = {We present Illinois Extended Reality testbed (ILLIXR), the first fully open-source XR system and research testbed. ILLIXR enables system innovations with end-to-end co-designed hardware, compiler, OS, and algorithms, and driven by end-user perceived Quality-of-Experience (QoE) metrics. Using ILLIXR, we provide the first comprehensive quantitative analysis of performance, power, and QoE for a complete XR system and its individual components. We describe several implications of our results that propel new directions in architecture, systems, and algorithms research for domain-specific systems in general, and XR in particular.}, keywords = {x reality;pipelines;measurement;visualization;cameras;runtime;headphones}, doi = {10.1109/MM.2022.3161018}, publisher = {IEEE Computer Society}, address = {Los Alamitos, CA, USA}, month = {jul} } Getting Started and Documentation For more information, see our Getting Started page . Acknowledgements The ILLIXR project started in Sarita Adve\u2019s research group , co-led by PhD candidate Muhammad Huzaifa, at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Yihan Pang, Joseph Ravichandran, Giordano Salvador, Finn Sinclair, Boyuan Tian, Henghzhi Yuan, and Jeffrey Zhang. ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson. Our OpenXR implementation is derived from Monado . We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik. The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center (a JUMP Center co-sponsored by SRC and DARPA), the Center for Future Architectures Research (C-FAR, a STARnet research center), a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset . Wesley Darvin came up with the name for ILLIXR. Licensing Structure ILLIXR is available as open-source software under the permissive University of Illinois/NCSA Open Source License . As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software . The external libraries and software included in ILLIXR each have their own licenses and must be used according to those licenses: ElasticFusion \\ ElasticFusion license KinectFusion \\ MIT License GTSAM \\ Simplified BSD License HOTlab \\ GNU Lesser General Public License v3.0 libspatialaudio \\ GNU Lesser General Public License v2.1 Monado \\ Boost Software License 1.0 moodycamel::ConcurrentQueue \\ Simplified BSD License Open-VINS \\ GNU General Public License v3.0 RITnet \\ MIT License Note that ILLIXR's extensibility allows the source to be configured and compiled using only permissively licensed software. Get in Touch Whether you are a computer architect, a compiler writer, a systems person, work on XR related algorithms or applications, or just anyone interested in XR research, development, or products, we would love to hear from you and hope you will contribute! You can join the ILLIXR consortium , Discord , or mailing list , or send us an email , or just send us a pull request!","title":"ILLIXR"},{"location":"#illixr","text":"Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first fully open-source Extended Reality (XR) system and testbed. The modular, extensible, and OpenXR -compatible ILLIXR runtime integrates state-of-the-art XR components into a complete XR system. The testbed is part of the broader ILLIXR consortium , an industry-supported community effort to democratize XR systems research, development, and benchmarking. You can find the complete ILLIXR system here . ILLIXR also provides its components in standalone configurations to enable architects and system designers to research each component in isolation. The standalone components are packaged together in the as of the v3.1.0 release of ILLIXR. ILLIXR's modular and extensible runtime allows adding new components and swapping different implementations of a given component. ILLIXR currently contains the following components: Perception Eye Tracking RITNet ** Scene Reconstruction ElasticFusion ** KinectFusion ** Simultaneous Localization and Mapping OpenVINS ** Cameras and IMUs ZED Mini Intel RealSense Visual Chromatic aberration correction Computational holography for adaptive multi-focal displays ** Lens distortion correction Asynchronous Reprojection (TimeWarp) Aural Audio encoding ** Audio playback ** (** Source is hosted in an external repository under the ILLIXR project .) We continue to add more components (new components and new implementations). Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked GitHub repository for proper attribution to its authors.","title":"ILLIXR"},{"location":"#papers-talks-demos-consortium","text":"A paper with details on ILLIXR, including its components, runtime, telemetry support, and a comprehensive analysis of performance, power, and quality on desktop and embedded systems. A talk presented at NVIDIA GTC'21 describing ILLIXR and announcing the ILLIXR consortium: Video . Slides . A demo of an OpenXR application running with ILLIXR. For more up-to-date list of related papers, demos, and talks, please visit illixr.org . The ILLIXR consortium is an industry-supported community effort to democratize XR systems research, development, and benchmarking. Visit our website for more information. The ILLIXR consortium is also holding a biweekly consortium meeting. For past meetings, for more information, past meeting recordings, and request for presenting, please visit here . Please join our Discord for announcement.","title":"Papers, talks, demos, consortium"},{"location":"#citation","text":"We request that you cite our following paper when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published. @ARTICLE {9741292, author = {M. Huzaifa and R. Desai and S. Grayson and X. Jiang and Y. Jing and J. Lee and F. Lu and Y. Pang and J. Ravichandran and F. Sinclair and B. Tian and H. Yuan and J. Zhang and S. V. Adve}, journal = {IEEE Micro}, title = {ILLIXR: An Open Testbed to Enable Extended Reality Systems Research}, year = {2022}, volume = {42}, number = {04}, issn = {1937-4143}, pages = {97-106}, abstract = {We present Illinois Extended Reality testbed (ILLIXR), the first fully open-source XR system and research testbed. ILLIXR enables system innovations with end-to-end co-designed hardware, compiler, OS, and algorithms, and driven by end-user perceived Quality-of-Experience (QoE) metrics. Using ILLIXR, we provide the first comprehensive quantitative analysis of performance, power, and QoE for a complete XR system and its individual components. We describe several implications of our results that propel new directions in architecture, systems, and algorithms research for domain-specific systems in general, and XR in particular.}, keywords = {x reality;pipelines;measurement;visualization;cameras;runtime;headphones}, doi = {10.1109/MM.2022.3161018}, publisher = {IEEE Computer Society}, address = {Los Alamitos, CA, USA}, month = {jul} }","title":"Citation"},{"location":"#getting-started-and-documentation","text":"For more information, see our Getting Started page .","title":"Getting Started and Documentation"},{"location":"#acknowledgements","text":"The ILLIXR project started in Sarita Adve\u2019s research group , co-led by PhD candidate Muhammad Huzaifa, at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Yihan Pang, Joseph Ravichandran, Giordano Salvador, Finn Sinclair, Boyuan Tian, Henghzhi Yuan, and Jeffrey Zhang. ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson. Our OpenXR implementation is derived from Monado . We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik. The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center (a JUMP Center co-sponsored by SRC and DARPA), the Center for Future Architectures Research (C-FAR, a STARnet research center), a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset . Wesley Darvin came up with the name for ILLIXR.","title":"Acknowledgements"},{"location":"#licensing-structure","text":"ILLIXR is available as open-source software under the permissive University of Illinois/NCSA Open Source License . As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software . The external libraries and software included in ILLIXR each have their own licenses and must be used according to those licenses: ElasticFusion \\ ElasticFusion license KinectFusion \\ MIT License GTSAM \\ Simplified BSD License HOTlab \\ GNU Lesser General Public License v3.0 libspatialaudio \\ GNU Lesser General Public License v2.1 Monado \\ Boost Software License 1.0 moodycamel::ConcurrentQueue \\ Simplified BSD License Open-VINS \\ GNU General Public License v3.0 RITnet \\ MIT License Note that ILLIXR's extensibility allows the source to be configured and compiled using only permissively licensed software.","title":"Licensing Structure"},{"location":"#get-in-touch","text":"Whether you are a computer architect, a compiler writer, a systems person, work on XR related algorithms or applications, or just anyone interested in XR research, development, or products, we would love to hear from you and hope you will contribute! You can join the ILLIXR consortium , Discord , or mailing list , or send us an email , or just send us a pull request!","title":"Get in Touch"},{"location":"CONTRIBUTING/","text":"Contributing Guidelines Please follow these steps when making pull requests (PRs): First, create an issue describing the problem that needs to be fixed. If an issue already exists, skip this step. If you are looking for an issue to fix, see the \"good first issue\" label . Assign the issue to yourself and add appropriate labels. If you are an external contributor, comment on the issue so one of the ILLIXR team members can assign the issue to you. Before you start making changes, make a new branch. The branch MUST be named issue-<issue number>-<some descriptive name> . For instance, issue-32-fix-mem-leak addresses the memory leak described in Issue #32. Fix the issue. Add your name to ILLIXR/CONTRIBUTORS . Push commits up to GitHub. Open a PR, and link it to the issue that the PR aims to resolve. Please give the PR a descriptive name. As you make progress on your PR, keep your branch up-to-date with the master branch which may have been updated after starting your PR. Your PR MUST be updated to reflect changes to master in order to be merged. Use the following procedure for updating your branch and when you are ready to commit your changes: ## While on your PR branch <issue-branch> hosted at <your-remote> repository: git commit # or git stash ## Line A git checkout master git pull <illixr-remote> master --rebase && git fetch <illixr-remote> ## Line B git checkout <issue-branch> git rebase master ## Line C ## If you stashed your changes on 'Line A': git stash apply <stash-number> && git commit git push <your-remote> <issue-branch> --force-with-lease ## Line D For ILLIXR team members (others jump here ): In the example above, <illixr-remote> and <your-remote> are the same. When collaborating on branches in our repository, Line B may pull in changes that overwrite the git commit history when performing Line C . Subsequently, performing Line D will rewrite the history in the public branch. To preserve branch commit histories in the case that a rollback is needed, we will employ a checkpointing process for force updated branches. This process will be manually performed, but may be automated in the future. If Line B shows an update to master, the following example illustrates your local repository just after performing Line B : A -- B -- C -- P -- Q -- R ## master \\ D -- E -- F ## issue-123-fixing-bug In this example, commits P , Q , and R have been merged to master (from feature branches not shown) after feature branch issue-123-fixing-bug was forked from master . To checkpoint the issue-123-fixing-bug branch while it is checked out: git branch issue-123.0-fixing-bug ## Make alias for old issue-123-fixing-bug git checkout -b issue-123.1-fixing-bug ## Make new branch to rebase with master git rebase master ## Replay issue-123-fixing-bug onto master git branch -D issue-123-fixing-bug ## Remove old issue-123-fixing-bug git branch issue-123-fixing-bug ## Make issue-123-fixing-bug an alias of new branch git push <illixr-remote> issue-123.{0,1}-fixing-bug ## Push new checkpointed branches to remote git push <illixr-remote> issue-123-fixing-bug --force-with-lease ## Force update issue-123-fixing-bug Note: The term alias here is used to refer to branches which point to the same commit. This usage is different from standard Git Aliases used for git command shortcuts. After checkpointing, your local repository should look as follows: D' -- E' -- F' ## issue-123.1-fixing-bug, issue-123-fixing-bug / A -- B -- C -- P -- Q -- R ## master \\ D -- E -- F ## issue-123.0-fixing-bug Commits D , E , and F have been added to a new branch starting from R , but now have been given new hashes. This new branch is our up-to-date copy of the feature branch issue-123-fixing-bug . While working on a checkpointed branch, keep aliases up-to-date using git rebase : git commit ## Add changes to issue-123.1-fixing-bug git checkout issue-123-fixing-bug ## Switch to main issue-123-fixing-bug branch git rebase issue-123.1-fixing-bug ## Fast-forward issue-123-fixing-bug to issue-123.1-fixing-bug Conflicts are possible when two or more collaborators push changes concurrently to the same branch. As long as each collaborator ensures that the branch update process starts at Line A , conflicts can be detected and handled locally. In other words, every call to git-push should be preceeded by a call to git-pull , following the process from Line A to Line D (or equivalent; git's CLI allows many ways to achieve the same results). Note: Line B rebases the master branch assuming that we have checked out master . Forgetting to specify master in Line B may result in a lossy forced update in the example below. Forgetting to checkout master will immediately apply your checked out feature branch's changes, possibly also resulting in a lossy forced update. The output of Line B for a collaborator after the checkpointing process may contain something like this: From github.com:ILLIXR/ILLIXR A..R master -> <illixr-remote>/master + A..F' issue-123-fixing-bug -> <illixr-remote>/issue-123-fixing-bug (forced update) * [new branch] issue-123.0-fixing-bug -> <illixr-remote>/issue-123.0-fixing-bug * [new branch] issue-123.1-fixing-bug -> <illixr-remote>/issue-123.1-fixing-bug Conflicts which do not involve updates to the master branch can be resolved simply by rebasing the current feature branch with the updated feature branch, applying new changes on top of the updated feature branch: ## For the latest checkpoint X (local) and Y (remote), let Z := Y + 1 in git checkout issue-123.X-fixing-bug -b issue-123.Z-fixing-bug ## Make new branch issue-123.Z-fixing-bug git rebase <illixr-remote>/issue-123.Y-fixing-bug ## Replay updates from issue-123.X-fixing-bug git push <illixr-remote> issue-123.Z-fixing-bug ## Make sure to update issue-123-fixing-bug after The --force-with-lease argument in Line D is not required for our new checkpoint branch, since a new branch should not conflict with a non-existing remote branch. We expect the subversion number for a new branch resulting from our checkpoint conflict resolution to be new and unique. If the push fails, another conflict has occurred, and checkpoint conflict resolution should be repeated. Line D should be safe to perform for the main feature branch now that we have replayed our commits on top of the updated feature branch. Note: In the above example, the git-rebase is performed using the remote copy of the checkpointed branch. We do this because Line B will not fast-forward or force update our local branches (with the same subversion number as a conflicting remote branch, if any). In the case of a conflict with updates to master , Line A should show updates to both the master branch and the feature branch to be pushed in Line D . A checkpointed version of the feature branch may also appear. This is because a feature branch should only be checkpointed in the presence of a change to the master branch. Forced pushes should generally not be used for any other purpose. If multiple updates to master and the feature branch have occured, additional checkpointed versions of the feature branch may also appear. In this scenario, we need to rebase our latest version of the feature branch with the latest version of the feature branch pulled from <illixr-remote> . Philosophy Why are the above steps necessary? Assigning the issue to yourself ensures that multiple people don't work on the same thing in parallel. The branch naming scheme organizes things a bit for us, and also makes it easy to find branches. Linking the issue to the PR ensures that we know which issue is being resolved, and also automatically closes the issue when the PR gets merged. Using rebases keeps the master and feature branch histories streamlined (minimizing branching), thus making it easier to compose feature branches for integration testing. See this article on rebasing public branches for more information. If your PR has not seen activity from the ILLIXR team after a long period of time (e.g., 2 weeks), feel free to contact the team directly on the GitHub Issue Conversation tab or at the Gitter forum linked below. Other Procedures Branch Management: The branch rebasing and checkpointing process detailed above is tedious, and may be automated in the future. Check back in with this document occasionally for improvements to the branch management process. Code Formatting: As ILLIXR grows, contributions will need to be standardized to accomodate multiple collaborators with different coding styles. During code review of a PR, you may be asked to reformat your code to match the standards set for ILLIXR code base. This process may be manually triggered by a comment from a review, or automated via Git and GitHub in the future. Issue Templates: To make collaboration easier, templates for Issues and Pull Requests will be added to the GitHub web interface. If an appropriate template exists for your task, please ensure to select it before submitting. Getting Help You can get seek help from our development community in three places: Main documentation site API documentation site Gitter community forum","title":"Contributing Guidelines"},{"location":"CONTRIBUTING/#contributing-guidelines","text":"Please follow these steps when making pull requests (PRs): First, create an issue describing the problem that needs to be fixed. If an issue already exists, skip this step. If you are looking for an issue to fix, see the \"good first issue\" label . Assign the issue to yourself and add appropriate labels. If you are an external contributor, comment on the issue so one of the ILLIXR team members can assign the issue to you. Before you start making changes, make a new branch. The branch MUST be named issue-<issue number>-<some descriptive name> . For instance, issue-32-fix-mem-leak addresses the memory leak described in Issue #32. Fix the issue. Add your name to ILLIXR/CONTRIBUTORS . Push commits up to GitHub. Open a PR, and link it to the issue that the PR aims to resolve. Please give the PR a descriptive name. As you make progress on your PR, keep your branch up-to-date with the master branch which may have been updated after starting your PR. Your PR MUST be updated to reflect changes to master in order to be merged. Use the following procedure for updating your branch and when you are ready to commit your changes: ## While on your PR branch <issue-branch> hosted at <your-remote> repository: git commit # or git stash ## Line A git checkout master git pull <illixr-remote> master --rebase && git fetch <illixr-remote> ## Line B git checkout <issue-branch> git rebase master ## Line C ## If you stashed your changes on 'Line A': git stash apply <stash-number> && git commit git push <your-remote> <issue-branch> --force-with-lease ## Line D For ILLIXR team members (others jump here ): In the example above, <illixr-remote> and <your-remote> are the same. When collaborating on branches in our repository, Line B may pull in changes that overwrite the git commit history when performing Line C . Subsequently, performing Line D will rewrite the history in the public branch. To preserve branch commit histories in the case that a rollback is needed, we will employ a checkpointing process for force updated branches. This process will be manually performed, but may be automated in the future. If Line B shows an update to master, the following example illustrates your local repository just after performing Line B : A -- B -- C -- P -- Q -- R ## master \\ D -- E -- F ## issue-123-fixing-bug In this example, commits P , Q , and R have been merged to master (from feature branches not shown) after feature branch issue-123-fixing-bug was forked from master . To checkpoint the issue-123-fixing-bug branch while it is checked out: git branch issue-123.0-fixing-bug ## Make alias for old issue-123-fixing-bug git checkout -b issue-123.1-fixing-bug ## Make new branch to rebase with master git rebase master ## Replay issue-123-fixing-bug onto master git branch -D issue-123-fixing-bug ## Remove old issue-123-fixing-bug git branch issue-123-fixing-bug ## Make issue-123-fixing-bug an alias of new branch git push <illixr-remote> issue-123.{0,1}-fixing-bug ## Push new checkpointed branches to remote git push <illixr-remote> issue-123-fixing-bug --force-with-lease ## Force update issue-123-fixing-bug Note: The term alias here is used to refer to branches which point to the same commit. This usage is different from standard Git Aliases used for git command shortcuts. After checkpointing, your local repository should look as follows: D' -- E' -- F' ## issue-123.1-fixing-bug, issue-123-fixing-bug / A -- B -- C -- P -- Q -- R ## master \\ D -- E -- F ## issue-123.0-fixing-bug Commits D , E , and F have been added to a new branch starting from R , but now have been given new hashes. This new branch is our up-to-date copy of the feature branch issue-123-fixing-bug . While working on a checkpointed branch, keep aliases up-to-date using git rebase : git commit ## Add changes to issue-123.1-fixing-bug git checkout issue-123-fixing-bug ## Switch to main issue-123-fixing-bug branch git rebase issue-123.1-fixing-bug ## Fast-forward issue-123-fixing-bug to issue-123.1-fixing-bug Conflicts are possible when two or more collaborators push changes concurrently to the same branch. As long as each collaborator ensures that the branch update process starts at Line A , conflicts can be detected and handled locally. In other words, every call to git-push should be preceeded by a call to git-pull , following the process from Line A to Line D (or equivalent; git's CLI allows many ways to achieve the same results). Note: Line B rebases the master branch assuming that we have checked out master . Forgetting to specify master in Line B may result in a lossy forced update in the example below. Forgetting to checkout master will immediately apply your checked out feature branch's changes, possibly also resulting in a lossy forced update. The output of Line B for a collaborator after the checkpointing process may contain something like this: From github.com:ILLIXR/ILLIXR A..R master -> <illixr-remote>/master + A..F' issue-123-fixing-bug -> <illixr-remote>/issue-123-fixing-bug (forced update) * [new branch] issue-123.0-fixing-bug -> <illixr-remote>/issue-123.0-fixing-bug * [new branch] issue-123.1-fixing-bug -> <illixr-remote>/issue-123.1-fixing-bug Conflicts which do not involve updates to the master branch can be resolved simply by rebasing the current feature branch with the updated feature branch, applying new changes on top of the updated feature branch: ## For the latest checkpoint X (local) and Y (remote), let Z := Y + 1 in git checkout issue-123.X-fixing-bug -b issue-123.Z-fixing-bug ## Make new branch issue-123.Z-fixing-bug git rebase <illixr-remote>/issue-123.Y-fixing-bug ## Replay updates from issue-123.X-fixing-bug git push <illixr-remote> issue-123.Z-fixing-bug ## Make sure to update issue-123-fixing-bug after The --force-with-lease argument in Line D is not required for our new checkpoint branch, since a new branch should not conflict with a non-existing remote branch. We expect the subversion number for a new branch resulting from our checkpoint conflict resolution to be new and unique. If the push fails, another conflict has occurred, and checkpoint conflict resolution should be repeated. Line D should be safe to perform for the main feature branch now that we have replayed our commits on top of the updated feature branch. Note: In the above example, the git-rebase is performed using the remote copy of the checkpointed branch. We do this because Line B will not fast-forward or force update our local branches (with the same subversion number as a conflicting remote branch, if any). In the case of a conflict with updates to master , Line A should show updates to both the master branch and the feature branch to be pushed in Line D . A checkpointed version of the feature branch may also appear. This is because a feature branch should only be checkpointed in the presence of a change to the master branch. Forced pushes should generally not be used for any other purpose. If multiple updates to master and the feature branch have occured, additional checkpointed versions of the feature branch may also appear. In this scenario, we need to rebase our latest version of the feature branch with the latest version of the feature branch pulled from <illixr-remote> .","title":"Contributing Guidelines"},{"location":"CONTRIBUTING/#philosophy","text":"Why are the above steps necessary? Assigning the issue to yourself ensures that multiple people don't work on the same thing in parallel. The branch naming scheme organizes things a bit for us, and also makes it easy to find branches. Linking the issue to the PR ensures that we know which issue is being resolved, and also automatically closes the issue when the PR gets merged. Using rebases keeps the master and feature branch histories streamlined (minimizing branching), thus making it easier to compose feature branches for integration testing. See this article on rebasing public branches for more information. If your PR has not seen activity from the ILLIXR team after a long period of time (e.g., 2 weeks), feel free to contact the team directly on the GitHub Issue Conversation tab or at the Gitter forum linked below.","title":"Philosophy"},{"location":"CONTRIBUTING/#other-procedures","text":"Branch Management: The branch rebasing and checkpointing process detailed above is tedious, and may be automated in the future. Check back in with this document occasionally for improvements to the branch management process. Code Formatting: As ILLIXR grows, contributions will need to be standardized to accomodate multiple collaborators with different coding styles. During code review of a PR, you may be asked to reformat your code to match the standards set for ILLIXR code base. This process may be manually triggered by a comment from a review, or automated via Git and GitHub in the future. Issue Templates: To make collaboration easier, templates for Issues and Pull Requests will be added to the GitHub web interface. If an appropriate template exists for your task, please ensure to select it before submitting.","title":"Other Procedures"},{"location":"CONTRIBUTING/#getting-help","text":"You can get seek help from our development community in three places: Main documentation site API documentation site Gitter community forum","title":"Getting Help"},{"location":"LICENSE/","text":"Copyright (c) 2019 The Board of Trustees of the University of Illinois. All rights reserved. Developed by: Professor Sarita Adve's research group University of Illinois at Urbana-Champaign http://rsim.cs.illinois.edu Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution. * Neither the names of Professor Sarita Adve's research group, University of Illinois at Urbana-Champaign, nor the names of its contributors may be used to endorse or promote products derived from this Software without specific prior written permission. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.","title":"ILLIXR License"},{"location":"debugging_illixr/","text":"ILLIXR Debugging Tips Debugging Locally The config described in Getting Started supports running the runtime with arbitrary commands like gdb . When debugging locally, we recommend using either gdb or valgrind in this way. Debugging Pull Requests or with a Clean Environment 1. Get a Docker Image From your Local Project From the root directory in your project, run: docker build [--build-arg=JOBS=\"<integer>\"] [--no-cache] --tag <repository>:<tag> . Note the optional Dockerfile argument, JOBS , which specifies the number of threads/tasks to use for building. Also note the optional argument, --no-cache , which forces Docker to rerun commands in Dockerfile (see this article for more information). For this project's main module, you can use something like illixr-illixr for the <repository> value, and your current branch name or release version as the <tag> value. Note that building the docker image can take some time (up to 40min on a 4-core desktop machine) and uses somewhere between 2-4GB of RAM. From a GitHub Pull Request's CI/CD Flow Follow these steps when a CI/CD build fails on a PR: Click details on the failing build. In the build view go to the Push Docker Image tab and copy the docker push ghcr.io/illixr/illixr-tests:<branch-name> command. Then in your terminal, run: docker pull ghcr.io/illixr/illixr-tests:<branch-name> 2. Test your Image in the Docker container Verify that your image was created successfully: docker image ls Take note of your image's REPOSITORY and TAG values. Now run: docker run -it --entrypoint /bin/bash <repository>:<tag> You are now in a bash shell in a docker container. From here you can test whichever project flow you wish, such as the usual main.opt.exe --yaml illixr.yaml .","title":"ILLIXR Debugging Tips"},{"location":"debugging_illixr/#illixr-debugging-tips","text":"","title":"ILLIXR Debugging Tips"},{"location":"debugging_illixr/#debugging-locally","text":"The config described in Getting Started supports running the runtime with arbitrary commands like gdb . When debugging locally, we recommend using either gdb or valgrind in this way.","title":"Debugging Locally"},{"location":"debugging_illixr/#debugging-pull-requests-or-with-a-clean-environment","text":"","title":"Debugging Pull Requests or with a Clean Environment"},{"location":"debugging_illixr/#1-get-a-docker-image","text":"","title":"1. Get a Docker Image"},{"location":"debugging_illixr/#from-your-local-project","text":"From the root directory in your project, run: docker build [--build-arg=JOBS=\"<integer>\"] [--no-cache] --tag <repository>:<tag> . Note the optional Dockerfile argument, JOBS , which specifies the number of threads/tasks to use for building. Also note the optional argument, --no-cache , which forces Docker to rerun commands in Dockerfile (see this article for more information). For this project's main module, you can use something like illixr-illixr for the <repository> value, and your current branch name or release version as the <tag> value. Note that building the docker image can take some time (up to 40min on a 4-core desktop machine) and uses somewhere between 2-4GB of RAM.","title":"From your Local Project"},{"location":"debugging_illixr/#from-a-github-pull-requests-cicd-flow","text":"Follow these steps when a CI/CD build fails on a PR: Click details on the failing build. In the build view go to the Push Docker Image tab and copy the docker push ghcr.io/illixr/illixr-tests:<branch-name> command. Then in your terminal, run: docker pull ghcr.io/illixr/illixr-tests:<branch-name>","title":"From a GitHub Pull Request's CI/CD Flow"},{"location":"debugging_illixr/#2-test-your-image-in-the-docker-container","text":"Verify that your image was created successfully: docker image ls Take note of your image's REPOSITORY and TAG values. Now run: docker run -it --entrypoint /bin/bash <repository>:<tag> You are now in a bash shell in a docker container. From here you can test whichever project flow you wish, such as the usual main.opt.exe --yaml illixr.yaml .","title":"2. Test your Image in the Docker container"},{"location":"external_switchboard_and_phonebook/","text":"Using Switchboard and Phonebook Externally Switchboard was designed as a self-contained entity from ILLIXR that one can reuse in other projects. The relevant API is here for Switchboard and here for Phonebook . One simply needs to copy these files, maintaining directory structure. illixr/switchboard.hpp illixr/phonebook.hpp illixr/record_logger.hpp illixr/managed_thread.hpp illixr/concurrentqueue/blockingconcurrentqueue.hpp illixr/concurrentqueue/concurrentqueue.hpp illixr/concurrentqueue/lightweightsemaphore.hpp This will serve as our main.cpp : #include <iostream> #include \"illixr/switchboard.hpp\" class service : public ILLIXR::phonebook::service { public: void act() { std::cout << \"Hello from service\\n\"; }; }; class data : public ILLIXR::switchboard::event { public: data(size_t id_) : id{id_} { } size_t id; }; int main() { ILLIXR::phonebook main_pb; main_pb.register_impl<service>(std::make_shared<service>()); main_pb.lookup_impl<service>()->act(); // From docs of Switchboard: if first arg is null, logging is disabled. // Logging should be disabled if we are running externally. ILLIXR::switchboard main_sb {nullptr}; auto writer = main_sb.get_writer<data>(\"topic\"); auto reader = main_sb.get_reader<data>(\"topic\"); writer.put(writer.allocate<data>(42)); std::cout << \"The answer to life... is \" << reader.get_ro()->id << std::endl; return 0; } Switchboard and Phonebook will only work with compilers that support C++17 or better. For example: # Must copy with directory structure mkdir -p illixr/concurrentqueue cp path/to/ILLIXR/illixr/switchboard.hpp illixr cp path/to/ILLIXR/illixr/phonebook.hpp illixr cp path/to/ILLIXR/illixr/record_logger.hpp illixr cp path/to/ILLIXR/illixr/managed_thread.hpp illixr cp path/to/ILLIXR/illixr/concurrentqueue/blockingconcurrentqueue.hpp illixr/concurrentqueue/blockingconcurrentqueue.hpp cp path/to/ILLIXR/illixr/concurrentqueue/concurrentqueue.hpp illixr/concurrentqueue/concurrentqueue.hpp cp path/to/ILLIXR/illixr/concurrentqueue/lightweightsemaphore.hpp illixr/concurrentqueue/lightweightsemaphore.hpp emacs main.cpp # copy and paste from this doc # This will *probbaly* work with any C++-17 compatible compiler, but I've tested with clang-10. # Nix is my preferred package manager, but you can use whichever you like. # This command will not affect system packages, just create a temporary environment with the right clang. nix-shell -p clang_10 # Compile clang++ -Wextra -pthread -std=c++17 main.cpp # Run ./a.out The output is: Register 7service Hello from service Creating: topic for 4data The answer to life... is 42","title":"Using Switchboard and Phonebook Externally"},{"location":"external_switchboard_and_phonebook/#using-switchboard-and-phonebook-externally","text":"Switchboard was designed as a self-contained entity from ILLIXR that one can reuse in other projects. The relevant API is here for Switchboard and here for Phonebook . One simply needs to copy these files, maintaining directory structure. illixr/switchboard.hpp illixr/phonebook.hpp illixr/record_logger.hpp illixr/managed_thread.hpp illixr/concurrentqueue/blockingconcurrentqueue.hpp illixr/concurrentqueue/concurrentqueue.hpp illixr/concurrentqueue/lightweightsemaphore.hpp This will serve as our main.cpp : #include <iostream> #include \"illixr/switchboard.hpp\" class service : public ILLIXR::phonebook::service { public: void act() { std::cout << \"Hello from service\\n\"; }; }; class data : public ILLIXR::switchboard::event { public: data(size_t id_) : id{id_} { } size_t id; }; int main() { ILLIXR::phonebook main_pb; main_pb.register_impl<service>(std::make_shared<service>()); main_pb.lookup_impl<service>()->act(); // From docs of Switchboard: if first arg is null, logging is disabled. // Logging should be disabled if we are running externally. ILLIXR::switchboard main_sb {nullptr}; auto writer = main_sb.get_writer<data>(\"topic\"); auto reader = main_sb.get_reader<data>(\"topic\"); writer.put(writer.allocate<data>(42)); std::cout << \"The answer to life... is \" << reader.get_ro()->id << std::endl; return 0; } Switchboard and Phonebook will only work with compilers that support C++17 or better. For example: # Must copy with directory structure mkdir -p illixr/concurrentqueue cp path/to/ILLIXR/illixr/switchboard.hpp illixr cp path/to/ILLIXR/illixr/phonebook.hpp illixr cp path/to/ILLIXR/illixr/record_logger.hpp illixr cp path/to/ILLIXR/illixr/managed_thread.hpp illixr cp path/to/ILLIXR/illixr/concurrentqueue/blockingconcurrentqueue.hpp illixr/concurrentqueue/blockingconcurrentqueue.hpp cp path/to/ILLIXR/illixr/concurrentqueue/concurrentqueue.hpp illixr/concurrentqueue/concurrentqueue.hpp cp path/to/ILLIXR/illixr/concurrentqueue/lightweightsemaphore.hpp illixr/concurrentqueue/lightweightsemaphore.hpp emacs main.cpp # copy and paste from this doc # This will *probbaly* work with any C++-17 compatible compiler, but I've tested with clang-10. # Nix is my preferred package manager, but you can use whichever you like. # This command will not affect system packages, just create a temporary environment with the right clang. nix-shell -p clang_10 # Compile clang++ -Wextra -pthread -std=c++17 main.cpp # Run ./a.out The output is: Register 7service Hello from service Creating: topic for 4data The answer to life... is 42","title":"Using Switchboard and Phonebook Externally"},{"location":"getting_started/","text":"Getting Started The ILLIXR application is configured and built via CMake. The CMake system checks for required dependencies, builds each requested plugin, builds the main ILLIXR binary, and (optionally) installs these components. ILLIXR currently only builds on Linux systems, and has been tested on the following configurations: Ubuntu 20.04 22.04 Fedora[^1] 37 38 CentOS[^1] stream9 [^1]: Primary development is aimed at Ubuntu systems, full support for Fedora and CentOS may lag behind. Other versions of these operating systems may work, but will likely require some manual installation of dependencies. For other Linux distributions (e.g. RHEL) it will require significant manual installation of dependencies as many are not available in the distribution repos. The instructions below are a generalized version. Building ILLIXR Clone the repository git clone https://github.com/ILLIXR/ILLIXR Install dependencies There are two levels of dependencies in ILLIXR: those that are required for any type of build, and those that are required only for specific plugins. Select your operating system and version ILLIXR may compile with other versions of the above operating systems, but some of the necessary prerequesite packages are not supplied by the OS repos and will need to be compiled by hand. You should be able to use the package and cmake commands for other versions of the same OS (other than the missing packages) to compile ILLIXR. RHEL is not supported at this time as many of the prerequisite packages are not natively available. Pick the ILLIXR plugins you want to use Include virtualization support: See ILLIXR Under Virtualization for details. Use the following to install the dependencies for the selected plugins: Build command Use the following to build and install ILLIXR. You can specify the install location by giving the path to CMAKE_INSTALL_PREFIX . If you want the default install path then do not add the option to the command line. Note that if your install prefix requires sudo privileges then you will need to run both the build and install under sudo (this is due to the way cmake builds and installs some of the pre-packaged dependencies during the build phase). Common CMake command line arguments (always prepend with a -D ): CMAKE_INSTALL_PREFIX The root path to install the libraries and binary to. This defaults to /usr/local . CMAKE_BUILD_TYPE The build type to do: Debug, Release, RelWithDebInfo YAML_FILE The profile file of plugins to build and install. The default is None, meaning plugins should be specified individually on the command line. USE_<PLUGIN_NAME>=ON Build the specifically named plugin (e.g -DUSE_TIMEWARP_GL=ON to build the timewarp_gl plugin ). Any number of plugins can be specified on the command line in this fashion. An alternate to specifying the plugins as command line arguments is to create a YAML file which specifies the plugins to build. Using -DYAML_FILE=&lt;FILE_NAME&gt; as the command line argument specifying the YAML file to use. Note: You may need to specify the full path to the YAML_FILE. See profile for the format. The current list of plugins is: - audio_pipeline - debugview - depthai - display_vk - fauxpose - gldemo - ground_truth_slam - gtsam_integrator - native_renderer - offline_cam - offline_imu - offload_data - offload_vio.device_rx - offload_vio.device_tx - offload_vio.server_rx - offload_vio.server_tx - openni - openvins - passthrough_integrator - pose_lookup - pose_prediction - realsense - record_imu_cam - record_rgb_depth - rk4_integrator - timewarp_gl - timewarp_vk - vkdemo - zed The CMake process will also create a YAML file call illixr.yaml which can be used as input to the binary. Running ILLIXR To run the ILLIXR binary just call main.<>.exe with any of the following command line arguments. (the &lt;&gt; indicate an infix specifying the build type, for Debug use dbg , for Release use opt , for RelWithDebInfo use optdbg ) --duration=<>, the duration to run for in seconds (default is 60) --data=<>, the data file to use --demo_data=<>, the demo data to use --enable_offload, ?? --enable_alignment, ?? --enable_verbose_errors, give more information about errors --enable_pre_sleep, ?? -p,--plugins=<>, comma separated list of plugins to use (case sensitive, all lowercase, no spaces) -r,--run=<>, comma separated list of plugins to use (case sensitive, all lowercase, no spaces), supersedes plugins entry. This is only necessary if a plugin builds more than one library (e.g. offload_vio builds 4 libraries) as each must be loaded individually. -y,--yaml<>, the profile file to use which specifies some or all of the above arguments (e.g. the generated illixr.yaml ) --vis, the visualizer to use (openvins currently) Regarding parameters for the binary, the following priority will be used: 1. If the parameter is specified on the command line it will have the highest priority 2. If the parameter has a value in the yaml file this value will only be used if it is not specified on the command line (second priority) 3. If the parameter has a value as an environment variable this value will only be used if it is not specified on the command line nor yaml file Profile file format An example of a YAML profile file is plugins: timewarp_gl,gldemo,ground_truth_slam,offload_vio run: timewarp_gl,gldemo,ground_truth_slam,offload_vio.device_rx visualizers: openvins duration: 5 data: data/mav0 demo_data: demo_data build_type: Debug install_prefix: /home/user/illixr enable_offload: true enable_alignment: false enable_verbose_errors: false enable_pre_sleep: false Where the entries are defined as (* indicates required field): plugins * : Comma separated list of plugins (case sensitive) to build or load at runtime. run : Comma separated list of plugins (case sensitive) which are used at run time. This is only needed in cases like offload_vio where multiple plugin libraries are built by a single plugin, but must be loaded individually. (e.g. offload_vio.server_rx) visualizers : Comma separated list of visualizers to build or load at runtime (currently openvins is available). At runtime, if multiple visualizers are listed, only the first one will be used. duration : The duration to run ILLIXR for in seconds. data : Path to the data file to dowload (build step) or use at runtime. If a URL is given (must start with http or https) the file will be downloaded and extracted; the path to the extracted data will be put in the illixr.yaml file. demo_data : The path to the demonstration data to use at runtime (ignored by build steps) build_type : The type of build to perform (Debug, Release, or RelWithDebInfo). Ignored at run time. install_prefix : The root path to where the compiled libraries and binaries should be installed. (e.g. specifying /home/user will install libraries in /home/user/lib and binaries in /home/user/bin). Note : The prefix is also used for installing any packages that were downloaded and build from external repositories (e.g. DBoW2, GTSAM, etc). At runtime this path is added to LD_LIBRARY_PATH to aid in finding the plugin libraries. enable_offload : ? Default is false enable_alignment : ? Default is false enable_verbose_errors : Controls the verbosity of error messages. Default is false enable_pre_sleep : ? Default is false In general, you should not edit a profile file directly. The exception to this is when you are testing things on your own machine. Profile files are generated automatically from the master profiles/plugins.yaml during the cmake configuration stage. This is done so that any changes to a profile or the addition or removal of a plugin can be managed from a single file. The build system will generate an illixr.yaml file which contains entries from the command line and any input profile file and can be freely edited (it is generated every time cmake is called). ILLIXR Graphics Backends ILLIXR currently supports both OpenGL and Vulkan backends (indicated as gl and vk in the config suffixes). Since some plugins should behave differently (and compile differently) based on what backend is being used, it's important to run make clean if you want to try swapping between the two backends. Rationale The current system can use profile files to control everything from the build to running ILLIXR, inkeeping with the DRY principle . However, for maximum flexibility control can also be done at the command line level as well. Philosophy Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Re-running make (and optionally cmake first) will only rebuild those parts of the code with have changed. Next Steps Try browsing the source for the runtime and provided plugins. The source code is divided into components in the following directories: ILLIXR/src/ : A directory holding the implementation for loading and interfacing plugins. This directory contains Spindle . ILLIXR/include/illixr/ : A directory holding resources and utilities available globally to all plugins. This directory contains the interfaces for Switchboard and Phonebook . ILLIXR/plugins/<plugin_dir>/ : A unique directory for each plugin. Most of the core XR functionality is implemented via plugins. See Default Components for more details. If you edit any of the source files, the CMake system will detect and rebuild the respective binary the next time it runs. If you want to add your own plugin, see Writing Your Plugin . const dependencies = {}; const plugs = {}; const operatingSystems = {}; const profiles = []; var selectedOS = \"\"; var selectedOSv = \"\"; const plugins = new Set(); const module_json = { \"systems\": [ { \"name\": \"CentOS\", \"versions\": [ \"9\" ] }, { \"name\": \"Fedora\", \"versions\": [ \"37\", \"38\" ] }, { \"name\": \"Ubuntu\", \"versions\": [ \"20\", \"22\" ] } ], \"plugins\": [ { \"name\": \"audio_pipeline\", \"cmake_flag\": \"USE_AUDIO_PIPELINE=ON\", \"dependencies\": [ \"git\" ] }, { \"name\": \"debugview\", \"cmake_flag\": \"USE_DEBUGVIEW=ON\", \"dependencies\": [ \"glfw3\", \"OpenCV\" ] }, { \"name\": \"depthai\", \"cmake_flag\": \"USE_DEPTHAI=ON\", \"dependencies\": [ \"OpenCV\" ] }, { \"name\": \"display_vk\", \"cmake_flag\": \"USE_DISPLAY_VK=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"gldemo\", \"cmake_flag\": \"USE_GLDEMO=ON\", \"dependencies\": [] }, { \"name\": \"ground_truth_slam\", \"cmake_flag\": \"USE_GROUND_TRUTH_SLAM=ON\", \"dependencies\": [] }, { \"name\": \"gtsam_integrator\", \"cmake_flag\": \"USE_GTSAM_INTEGRATOR=ON\", \"dependencies\": [ \"git\" ] }, { \"name\": \"native_renderer\", \"cmake_flag\": \"USE_NATIVE_RENDERER=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"offline_cam\", \"cmake_flag\": \"USE_OFFLINE_CAM=ON\", \"dependencies\": [ \"OpenCV\" ] }, { \"name\": \"offline_imu\", \"cmake_flag\": \"USE_OFFLINE_IMU=ON\", \"dependencies\": [] }, { \"name\": \"offload_data\", \"cmake_flag\": \"USE_OFFLOAD_DATA=ON\", \"dependencies\": [ \"boost\" ] }, { \"name\": \"offload_vio.device_rx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.DEVICE_RX=ON\", \"dependencies\": [ \"git\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"offload_vio.device_tx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.DEVICE_TX=ON\", \"dependencies\": [ \"git\", \"glib\", \"gstreamer\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"offload_vio.server_tx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.SERVER_TX=ON\", \"dependencies\": [ \"git\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"offload_vio.server_rx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.SERVER_RX=ON\", \"dependencies\": [ \"git\", \"glib\", \"gstreamer\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"openni\", \"cmake_flag\": \"USE_OPENNI=ON\", \"dependencies\": [ \"libopenni2\", \"OpenCV\" ] }, { \"name\": \"openvins\", \"cmake_flag\": \"USE_OPENVINS=ON\", \"dependencies\": [ \"boost\" ] }, { \"name\": \"orb_slam\", \"cmake_flag\": \"USE_ORB_SLAM=ON\", \"dependencies\": [ \"git\", \"boost\", \"fmt\", \"patch\" ] }, { \"name\": \"passthrough_integrator\", \"cmake_flag\": \"USE_PASSTHROUGH_INTEGRATOR=ON\", \"dependencies\": [] }, { \"name\": \"pose_lookup\", \"cmake_flag\": \"USE_POSE_LOOKUP=ON\", \"dependencies\": [] }, { \"name\": \"pose_prediction\", \"cmake_flag\": \"USE_POSE_PREDICTION=ON\", \"dependencies\": [] }, { \"name\": \"realsense\", \"cmake_flag\": \"USE_REALSENSE=ON\", \"dependencies\": [ \"OpenCV\", \"realsense\" ] }, { \"name\": \"record_imu_cam\", \"cmake_flag\": \"USE_RECORD_IMU_CAM=ON\", \"dependencies\": [ \"boost\", \"OpenCV\" ] }, { \"name\": \"record_rgb_depth\", \"cmake_flag\": \"USE_RECORD_RGB_DEPTH=ON\", \"dependencies\": [ \"boost\", \"OpenCV\" ] }, { \"name\": \"rk4_integrator\", \"cmake_flag\": \"USE_RK4_INTEGRATOR=ON\", \"dependencies\": [] }, { \"name\": \"timewarp_gl\", \"cmake_flag\": \"USE_TIMEWARP_GL=ON\", \"dependencies\": [ \"git\", \"glslang\", \"gflags\", \"JPEG\", \"PNG\", \"TIFF\", \"udev\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"OpenXR\", \"Vulkan\", \"libusb\", \"libuvc\", \"SDL2\" ] }, { \"name\": \"timewarp_vk\", \"cmake_flag\": \"USE_TIMEWARP_VK=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"vkdemo\", \"cmake_flag\": \"USE_VKDEMO=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"zed\", \"cmake_flag\": \"USE_ZED=ON\", \"dependencies\": [ \"OpenCV\", \"zed_SDK\" ] } ], \"dependencies\": [ { \"boost\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libboost-all-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libboost-all-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"boost-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"boost-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"boost-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"ecal\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"ecal\", \"postnotes\": \"\", \"notes\": \"Ubuntu 20 does not have a system supplied package for eCAL, but it can be installed from the vendor by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#ecal20\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"ecal20\\\">sudo add-apt-repository ppa:ecal/ecal-latest -y -u\\nsudo apt-get update</pre></div>\" }, \"22\": { \"pkg\": \"ecal\", \"postnotes\": \"\", \"notes\": \"Ubuntu 22 does not have a system supplied package for eCAL, but it can be installed from the vendor by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#ecal22\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"ecal22\\\">sudo add-apt-repository ppa:ecal/ecal-latest -y -u\\nsudo apt-get update</pre></div>\" } }, \"Fedora\": { \"37\": { \"pkg\": \"graphviz hdf5-devel libcurl-devel qwt-qt5-devel qt5-qtbase-devel libyaml-devel zlib-devel openssl-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"graphviz hdf5-devel libcurl-devel qwt-qt5-devel qt5-qtbase-devel libyaml-devel zlib-devel openssl-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"graphviz hdf5-devel libcurl-devel qwt-qt5-devel qt5-qtbase-devel libyaml-devel zlib-devel openssl-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"fmt\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libfmt-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libfmt-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"fmt-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"fmt-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"fmt-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"gflags\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libgflags-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libgflags-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"gflags-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"gflags-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"gflags-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"git\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glfw3\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libglfw3-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libglfw3-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glfw-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glfw-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glfw-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glib\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libglib2.0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libglib2.0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glib-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glib-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glib-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glm\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libglm-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libglm-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glm-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glm-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glm-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glog\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libgoogle-glog-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libgoogle-glog-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glog-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glog-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glog-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glslang\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"glslang-dev glslang-tools\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"glslang-dev glslang-tools\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glslang-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glslang-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glslang-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"gstreamer\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"gstreamer-devel gstreamer1-plugins-base-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"gstreamer-devel gstreamer1-plugins-base-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"gstreamer-devel gstreamer1-plugins-base-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"JPEG\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libjpeg-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libjpeg-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libjpeg-turbo-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libjpeg-turbo-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libjpeg-turbo-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"libopenni2\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libopenni2-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libopenni2-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"openni-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"openni-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"No OpenNI package is natively available for CentOS\" } } } } }, { \"libusb\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libusb-1.0.0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libusb-1.0.0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libusb1-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libusb1-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libusb1-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"libuvc\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libuvc-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libuvc-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"Fedora does not supply libuvc from its repositories. You will need to install it from <a href=\\\"https://github.com/libuvc/libuvc\\\">https://github.com/libuvc/libuvc</a>.\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"Fedora does not supply libuvc from its repositories. You will need to install it from <a href=\\\"https://github.com/libuvc/libuvc\\\">https://github.com/libuvc/libuvc</a>.\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"CentOS does not supply libuvc from its repositories. You will need to install it from <a href=\\\"https://github.com/libuvc/libuvc\\\">https://github.com/libuvc/libuvc</a>.\" } } } } }, { \"OpenCV\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libopencv-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libopencv-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"opencv-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"opencv-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"vtk-devel\", \"postnotes\": \",\", \"notes\": \"Centos does not provide a complete version of OpenCV in their repos, in particular the 'viz' component is missing. You will need to install the VTK-devel package and the ILLIXR build system will compile OpenCV from source.<P>You may also need to run the following:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#opencvC\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"opencvC\\\">sudo dnf -y install dnf-plugins-core epel-release\\nsudo dnf config-manager --set-enabled crb</pre></div>\" } } } } }, { \"OpenXR\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libopenxr-dev libopenxr1-monado\", \"postnotes\": \"\", \"notes\": \"Ubuntu 20 does not have a system supplied package for OpenXR, but it can be installed from the vendor by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#openU20\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"openU20\\\">sudo apt-get -y install wget software-properties-common\\nsudo apt-get update\\nsudo add-apt-repository ppa:monado-xr/monado -y -u\\nsudo wget -nv https://monado.freedesktop.org/keys/monado-ci.asc -O /etc/apt/trusted.gpg.d/monado-ci.asc\\nsudo echo 'deb https://monado.pages.freedesktop.org/monado/apt focal main' | tee /etc/apt/sources.list.d/monado-ci.list\\nsudo apt update</pre></div>\" }, \"22\": { \"pkg\": \"libopenxr-dev libopenxr1-monado\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"openxr-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"openxr-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"openxr-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"patch\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"PNG\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libpng-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libpng-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libpng-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libpng-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libpng-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"protobuf\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libprotobuf-dev libprotoc-dev protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libprotobuf-dev libprotoc-dev protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"protobuf-devel protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"protobuf-devel protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"protobuf-devel protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"qemu\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"qemu qemu-system qemu-system-data qeum-utils qemu-user libqcow-dev libqcow-utils\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"qemu qemu-system qemu-system-data qeum-utils qemu-user libqcow-dev libqcow-utils\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"??\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"??\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"??\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"realsense\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"librealsense2-dev librealsense2-gl-dev\", \"postnotes\": \"\", \"notes\": \"Ubuntu does not have a system supplied package for librealsense, but it can be installed from the vendor (Intel) by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#realU20\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"realU20\\\">sudo apt-get -y install curl apt-transport-https lsb-core\\nsudo mkdir -p /etc/apt/keyrings\\nsudo curl -sSf https://librealsense.intel.com/Debian/librealsense.pgp | tee /etc/apt/keyrings/librealsense.pgp > /dev/null\\nsudo echo \\\"deb [signed-by=/etc/apt/keyrings/librealsense.pgp] https://librealsense.intel.com/Debian/apt-repo `lsb_release -cs` main\\\" | tee /etc/apt/sources.list.d/librealsense.list > /dev/null\\nsudo apt-get update</pre></div>\" }, \"22\": { \"pkg\": \"librealsense2-dev librealsense2-gl-dev\", \"postnotes\": \"\", \"notes\": \"Ubuntu does not have a system supplied package for librealsense, but it can be installed from the vendor (Intel) by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#realU22\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"realU22\\\">sudo apt-get -y install curl apt-transport-https lsb-core\\nsudo mkdir -p /etc/apt/keyrings\\nsudo curl -sSf https://librealsense.intel.com/Debian/librealsense.pgp | tee /etc/apt/keyrings/librealsense.pgp > /dev/null\\nsudo echo \\\"deb [signed-by=/etc/apt/keyrings/librealsense.pgp] https://librealsense.intel.com/Debian/apt-repo `lsb_release -cs` main\\\" | tee /etc/apt/sources.list.d/librealsense.list > /dev/null\\nsudo apt-get update</pre></div>\" } }, \"Fedora\": { \"37\": { \"pkg\": \"librealsense-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"librealsense-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"git zip unzip libtool\", \"postnotes\": \"Centos does not provide a vendor version of librealsense, but it can be automatically compiled and installed with the following, possibly as sudo (run after installing the above packages):<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#realC9\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"realC9\\\">git clone https://github.com/Microsoft/vcpkg.git\\ncd vcpkg\\n./bootstrap-vcpkg.sh\\n./vcpkg integrate install\\n./vcpkg install realsense2</pre></div>\", \"notes\": \"\" } } } } }, { \"SDL2\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libsdl2-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libsdl2-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"SDL2-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"SDL2-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"SDL2-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"TIFF\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libtiff-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libtiff-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libtiff-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libtiff-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libtiff-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"udev\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"udev libudev-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"udev libudev-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"systemd-udev systemd-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"systemd-udev systemd-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"systemd systemd-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"Vulkan\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libvulkan-dev vulkan-validationlayers\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libvulkan-dev vulkan-validationlayers\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"vulkan-loader-devel vulkan-validation-layers\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"vulkan-loader-devel vulkan-validation-layers\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"vulkan-loader-devel vulkan-validation-layers\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"wayland-server\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libwayland-dev wayland-protocols\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libwayland-dev wayland-protocols\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"wayland-devel wayland-protocols-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"wayland-devel wayland-protocols-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"wayland-devel wayland-protocols-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"x11-xcb\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libx11-xcb-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libx11-xcb-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libX11-xcb libxcb-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libX11-xcb libxcb-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libX11-xcb libxcb-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"xcb-glx\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libxcb-glx0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libxcb-glx0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"xcb-randr\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libxcb-randr0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libxcb-randr0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"xkbcommon\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libxkbcommon-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libxkbcommon-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libxkbcommon-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libxkbcommon-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libxkbcommon-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"zed_SDK\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"zstd\", \"postnotes\": \"\", \"notes\": \"ZED SDK is required for the zed plugin. It must be installed manually. See <a href=\\\"https://www.stereolabs.com/docs/installation/linux/\\\">here</a> for details. It also requires some CUDA packages which should be available <a href=\\\"https://developer.nvidia.com/cuda-toolkit-archive\\\">here</a> or through your Ubuntu repo.\" }, \"22\": { \"pkg\": \"zstd\", \"postnotes\": \"\", \"notes\": \"ZED SDK (version 3) is required for the zed plugin. It must be installed manually. See <a href=\\\"https://www.stereolabs.com/docs/installation/linux/\\\">here</a> for details. It also requires some CUDA packages which should be available <a href=\\\"https://developer.nvidia.com/cuda-toolkit-archive\\\">here</a> or through your Ubuntu repo.\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } } } } } ], \"profiles\": [ { \"name\": \"ci\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"timewarp_gl\", \"audio_pipeline\"]}, { \"name\": \"headless\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"audio_pipeline\"]}, { \"name\": \"monado_gl\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"timewarp_gl\", \"audio_pipeline\"], \"build_flags\": \"-DILLIXR_MONADO\"}, { \"name\": \"monado_vk\", \"plugins\": [\"gtsam_integrator\", \"offline_cam\", \"offline_imu\", \"pose_prediction\", \"timewarp_vk\", \"audio_pipeline\"], \"build_flags\": \"-DILLIXR_VULKAN\"}, { \"name\": \"native_gl\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"timewarp_gl\", \"debugview\", \"offload_data\", \"audio_pipeline\"]}, { \"name\": \"native_vk\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"display_vk\", \"timewarp_vk\", \"vkdemo\", \"native_renderer\", \"debugview\"], \"build_flags\": \"-DILLIXR_VULKAN\"}, { \"name\": \"native_lookup\", \"plugins\": [\"pose_lookup\", \"gldemo\", \"debugview\", \"offload_data\", \"audio_pipeline\"]}, { \"name\": \"offload_device\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"debugview\", \"timewarp_gl\", \"offload_vio.device_rx\", \"offload_vio.device_tx\", \"audio_pipeline\"]}, { \"name\": \"offload_monado_vk\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"timewarp_vk\", \"offload_vio.device_rx\", \"offload_vio.device_tx\", \"audio_pipeline\"], \"build_flags\": \"-DILLIXR_VULKAN\"}, { \"name\": \"offload_server\", \"plugins\": [\"offload_vio.server_rx\", \"offload_vio.server_tx\"]}, { \"name\": \"fauxpose\", \"plugins\": [\"fauxpose\", \"gldemo\", \"debugview\", \"audio_pipeline\"] } ] }; function makeCopyable(code, name) { return \"<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#\" + name + \"\\\" title=\\\"Copy\\\">\\n</button>\\n<pre class=\\\"language-shell\\\" id=\\\"\" + name + \"\\\">\" + code + \"</pre>\\n</div>\\n\"; } function loadModules(){ for(let os of module_json[\"systems\"]) { operatingSystems[os.name] = os.versions; } for(let item of module_json[\"dependencies\"]) { let nm = \"\"; for(let i in item){ nm = i; } dependencies[nm] = {'pkg': item[nm].pkg, 'plugins' : []}; } for(let item of module_json[\"plugins\"]) { plugins.add(item.name); plugs[item.name] = item.cmake_flag; for(let dep of item.dependencies) { dependencies[dep].plugins.push(item.name); } } for(let grp of module_json[\"profiles\"]) { profiles.push(grp.name); profiles[grp.name] = []; for(let plug of grp.plugins) { profiles[grp.name].push(plug); } } } function updateSudo() { let sudoLine = \"\"; let notes = document.getElementById(\"notes\"); let pkgnotes = \"\"; let pkginfo = \"\"; let postnotes = document.getElementById(\"postnotes\"); let depinstall = document.getElementById(\"depinstall\"); notes.innerHTML = \"\"; if(selectedOS == \"Ubuntu\") { sudoLine = \"sudo apt-get install libglew-dev libglu1-mesa-dev libsqlite3-dev libx11-dev libgl-dev pkg-config libopencv-dev libeigen3-dev libc6-dev libspdlog-dev\"; postnotes.innerHTML = \"\"; } else if(selectedOS == \"Fedora\") { sudoLine = \"sudo dnf install glew-devel mesa-libGLU-devel sqlite-devel libX11-devel mesa-libGL-devel pkgconf-pkg-config opencv-devel eigen3-devel glibc-devel spdlog-devel\"; postnotes.innerHTML = \"Potential issues:<ul><li>If cmake is having trouble with some of the package-config (.pc) files used to locate packages you may need to run the following:\" + makeCopyable(\"sudo sed -i 's/\\^\\[ \\\\t\\]\\*//g' /usr/lib64/pkgconfig/*\", \"postF\") + \"</li><li>If the build step is having issues finding some of the include files you may need the following:\" + makeCopyable(\"sudo ln -s /usr/include /include\", \"post2F\") + \"</li></ul>\"; } else { sudoLine = \"sudo yum install glew-devel mesa-libGLU-devel sqlite-devel libX11-devel mesa-libGL-devel pkgconf-pkg-config vtk-devel eigen3-devel glibc-devel spdlog-devel\"; postnotes.innerHTML = \"Potential issues:<ul><li>If cmake is having trouble with some of the package-config (.pc) files used to locate packages you may need to run the following:\" + makeCopyable(\"sudo sed -i 's/\\^\\[ \\\\t\\]\\*//g' /usr/lib64/pkgconfig/*\", \"postC\") + \"</li><li>If the build step is having issues finding some of the include files you may need the following:\" + makeCopyable(\"sudo ln -s /usr/include /include\", \"post2C\") + \"</li></ul>\"; } for(let m in dependencies) { let checked = false; for(let p of dependencies[m].plugins) { checked ||= document.getElementById(p).checked; } if(checked) { sudoLine += \" \" + dependencies[m].pkg[selectedOS][selectedOSv].pkg; if(dependencies[m].pkg[selectedOS][selectedOSv].postnotes !== \"\") { pkgnotes += \"<P>\" + dependencies[m].pkg[selectedOS][selectedOSv].postnotes; } if(dependencies[m].pkg[selectedOS][selectedOSv].notes !== \"\") { if(pkginfo !== \"\") { pkginfo += \"<P>\"; } pkginfo += dependencies[m].pkg[selectedOS][selectedOSv].notes; } } } if(document.getElementById(\"withVirt\").checked) { sudoLine += \" \" + dependencies[\"qemu\"].pkg[selectedOS][selectedOSv].pkg; } if(pkginfo !== \"\") { notes.innerHTML = \"<h3>Notes:</h3>\" + pkginfo; } if(selectedOS == \"Ubuntu\" && (document.getElementById(\"offload_vio.device_tx\").checked || document.getElementById(\"offload_vio.device_rx\").checked || document.getElementById(\"offload_vio.server_tx\").checked || document.getElementById(\"offload_vio.server_rx\").checked)) { pkgnotes += \"<P><br>For the offload_vio plugins it is strongly recommended to install DeepStream. Please see the installation instructions <a href=\\\"https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_Quickstart.html#remove-all-previous-deepstream-installations\\\">here</a>.\"; } depinstall.innerHTML = pkgnotes; document.getElementById(\"output\").innerHTML = sudoLine; cmakeLine = \"cd ILLIXR\\nmkdir build\\ncd build\\ncmake .. -DCMAKE_INSTALL_PREFIX=&lt;LOCATION&gt;\"; let profile_check = false; for(let g of profiles) { if(document.getElementById(\"profile_\" + g).checked) { cmakeLine += \" -DYAML_FILE=profiles/\" + g.toLowerCase() + \".yaml\"; profile_check = true; break; } } if(!profile_check) { for(let p of plugins) { if(document.getElementById(p).checked) { cmakeLine += \" -D\" + plugs[p]; } } } cmakeLine += \"\\ncmake --build . -j4\\ncmake --build . -t docs # if you want to build the documentation\\ncmake --install .\"; document.getElementById(\"cmake\").innerHTML = makeCopyable(cmakeLine, \"cmakeC\"); $('.code-box-copy').codeBoxCopy(); } function updateOS(os_str) { const items = os_str.split(\".\"); selectedOS = items[0]; selectedOSv = items[1]; updateSudo(); } function checkAll() { for(let p of plugins) { document.getElementById(p).checked = document.getElementById(\"ALL_plugins\").checked; } updateSudo(); } function checkProfile(profile_name) { for(let p of plugins) { let setChecked = false; for(let pl of profiles[profile_name]) { if(p == pl) { setChecked = true; break; } } document.getElementById(p).checked = setChecked; } updateSudo(); } function updateChecked() { document.getElementById(\"None_plugins\").checked = true; updateSudo(); } async function setUpPage() { loadModules(); let osref = document.getElementById(\"operating_system\"); let osrow = osref.insertRow(-1); for(let x in operatingSystems) { let txt = x + \":\"; for(let ver of operatingSystems[x]) { txt += \"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type='radio' id='\" + x + \".\" + ver + \"' name='os_choice' value='\" + x + \".\" + ver + \"' onclick='updateOS(this.value);'>\" + ver; } let cell = osrow.insertCell(-1); cell.style.verticalAlign = \"top\"; cell.innerHTML = txt; } selectedOS = \"Ubuntu\"; selectedOSv = \"22\"; document.getElementById(selectedOS + \".\" + selectedOSv).checked = true; let tabRef = document.getElementById(\"profile_table\"); let count = 0; let currentRow = tabRef.insertRow(-1); let profilecell = currentRow.insertCell(-1); profilecell.innerHTML = \"<b>Profiles:</b>\"; profilecell.setAttribute(\"colspan\", profiles.length + 2); currentRow = tabRef.insertRow(-1); for(let g of profiles) { if(count >= 4) { currentRow = tabRef.insertRow(-1); count = 0; } let cell = currentRow.insertCell(-1); let radio = document.createElement(\"INPUT\"); radio.setAttribute(\"type\", \"radio\"); radio.setAttribute(\"onclick\", \"checkProfile('\" + g + \"');\"); radio.setAttribute(\"id\", \"profile_\" + g); radio.setAttribute(\"value\", \"profile_\" + g); radio.setAttribute(\"name\", \"profile_selection\"); let label = document.createElement(\"LABEL\"); label.setAttribute(\"for\", \"profile_\" + g); label.appendChild(document.createTextNode(g)); cell.appendChild(radio); cell.appendChild(label); count++; } count = 0; let none_cell = currentRow.insertCell(-1); let none_check = document.createElement(\"INPUT\"); none_check.setAttribute(\"type\", \"radio\"); none_check.setAttribute(\"onclick\", \"updateSudo();\"); none_check.setAttribute(\"id\", \"None_plugins\"); none_check.setAttribute(\"value\", \"None_plugins\"); none_check.setAttribute(\"name\", \"profile_selection\"); none_check.checked = true; let none_label = document.createElement(\"LABEL\"); none_label.setAttribute(\"for\", \"None_plugins\"); none_label.appendChild(document.createTextNode(\"None\")); none_cell.appendChild(none_check); none_cell.appendChild(none_label); tabRef = document.getElementById(\"listing_table\"); currentRow = tabRef.insertRow(-1); for(const dep of plugins) { if(count >= 4) { currentRow = tabRef.insertRow(-1); count = 0; } let cell = currentRow.insertCell(-1); let x = document.createElement(\"INPUT\"); x.setAttribute(\"type\", \"checkbox\"); x.setAttribute(\"onclick\", \"updateChecked();\"); x.setAttribute(\"id\", dep); let y = document.createElement(\"LABEL\"); y.setAttribute(\"for\", dep); y.appendChild(document.createTextNode(dep)); cell.appendChild(x); cell.appendChild(y); count += 1; } updateSudo(); } window.onload = setUpPage();","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"The ILLIXR application is configured and built via CMake. The CMake system checks for required dependencies, builds each requested plugin, builds the main ILLIXR binary, and (optionally) installs these components. ILLIXR currently only builds on Linux systems, and has been tested on the following configurations: Ubuntu 20.04 22.04 Fedora[^1] 37 38 CentOS[^1] stream9 [^1]: Primary development is aimed at Ubuntu systems, full support for Fedora and CentOS may lag behind. Other versions of these operating systems may work, but will likely require some manual installation of dependencies. For other Linux distributions (e.g. RHEL) it will require significant manual installation of dependencies as many are not available in the distribution repos. The instructions below are a generalized version.","title":"Getting Started"},{"location":"getting_started/#building-illixr","text":"","title":"Building ILLIXR"},{"location":"getting_started/#clone-the-repository","text":"git clone https://github.com/ILLIXR/ILLIXR","title":"Clone the repository"},{"location":"getting_started/#install-dependencies","text":"There are two levels of dependencies in ILLIXR: those that are required for any type of build, and those that are required only for specific plugins.","title":"Install dependencies"},{"location":"getting_started/#select-your-operating-system-and-version","text":"ILLIXR may compile with other versions of the above operating systems, but some of the necessary prerequesite packages are not supplied by the OS repos and will need to be compiled by hand. You should be able to use the package and cmake commands for other versions of the same OS (other than the missing packages) to compile ILLIXR. RHEL is not supported at this time as many of the prerequisite packages are not natively available.","title":"Select your operating system and version"},{"location":"getting_started/#pick-the-illixr-plugins-you-want-to-use","text":"Include virtualization support: See ILLIXR Under Virtualization for details. Use the following to install the dependencies for the selected plugins:","title":"Pick the ILLIXR plugins you want to use"},{"location":"getting_started/#build-command","text":"Use the following to build and install ILLIXR. You can specify the install location by giving the path to CMAKE_INSTALL_PREFIX . If you want the default install path then do not add the option to the command line. Note that if your install prefix requires sudo privileges then you will need to run both the build and install under sudo (this is due to the way cmake builds and installs some of the pre-packaged dependencies during the build phase). Common CMake command line arguments (always prepend with a -D ): CMAKE_INSTALL_PREFIX The root path to install the libraries and binary to. This defaults to /usr/local . CMAKE_BUILD_TYPE The build type to do: Debug, Release, RelWithDebInfo YAML_FILE The profile file of plugins to build and install. The default is None, meaning plugins should be specified individually on the command line. USE_<PLUGIN_NAME>=ON Build the specifically named plugin (e.g -DUSE_TIMEWARP_GL=ON to build the timewarp_gl plugin ). Any number of plugins can be specified on the command line in this fashion. An alternate to specifying the plugins as command line arguments is to create a YAML file which specifies the plugins to build. Using -DYAML_FILE=&lt;FILE_NAME&gt; as the command line argument specifying the YAML file to use. Note: You may need to specify the full path to the YAML_FILE. See profile for the format. The current list of plugins is: - audio_pipeline - debugview - depthai - display_vk - fauxpose - gldemo - ground_truth_slam - gtsam_integrator - native_renderer - offline_cam - offline_imu - offload_data - offload_vio.device_rx - offload_vio.device_tx - offload_vio.server_rx - offload_vio.server_tx - openni - openvins - passthrough_integrator - pose_lookup - pose_prediction - realsense - record_imu_cam - record_rgb_depth - rk4_integrator - timewarp_gl - timewarp_vk - vkdemo - zed The CMake process will also create a YAML file call illixr.yaml which can be used as input to the binary.","title":"Build command"},{"location":"getting_started/#running-illixr","text":"To run the ILLIXR binary just call main.<>.exe with any of the following command line arguments. (the &lt;&gt; indicate an infix specifying the build type, for Debug use dbg , for Release use opt , for RelWithDebInfo use optdbg ) --duration=<>, the duration to run for in seconds (default is 60) --data=<>, the data file to use --demo_data=<>, the demo data to use --enable_offload, ?? --enable_alignment, ?? --enable_verbose_errors, give more information about errors --enable_pre_sleep, ?? -p,--plugins=<>, comma separated list of plugins to use (case sensitive, all lowercase, no spaces) -r,--run=<>, comma separated list of plugins to use (case sensitive, all lowercase, no spaces), supersedes plugins entry. This is only necessary if a plugin builds more than one library (e.g. offload_vio builds 4 libraries) as each must be loaded individually. -y,--yaml<>, the profile file to use which specifies some or all of the above arguments (e.g. the generated illixr.yaml ) --vis, the visualizer to use (openvins currently) Regarding parameters for the binary, the following priority will be used: 1. If the parameter is specified on the command line it will have the highest priority 2. If the parameter has a value in the yaml file this value will only be used if it is not specified on the command line (second priority) 3. If the parameter has a value as an environment variable this value will only be used if it is not specified on the command line nor yaml file","title":"Running ILLIXR"},{"location":"getting_started/#profile-file-format","text":"An example of a YAML profile file is plugins: timewarp_gl,gldemo,ground_truth_slam,offload_vio run: timewarp_gl,gldemo,ground_truth_slam,offload_vio.device_rx visualizers: openvins duration: 5 data: data/mav0 demo_data: demo_data build_type: Debug install_prefix: /home/user/illixr enable_offload: true enable_alignment: false enable_verbose_errors: false enable_pre_sleep: false Where the entries are defined as (* indicates required field): plugins * : Comma separated list of plugins (case sensitive) to build or load at runtime. run : Comma separated list of plugins (case sensitive) which are used at run time. This is only needed in cases like offload_vio where multiple plugin libraries are built by a single plugin, but must be loaded individually. (e.g. offload_vio.server_rx) visualizers : Comma separated list of visualizers to build or load at runtime (currently openvins is available). At runtime, if multiple visualizers are listed, only the first one will be used. duration : The duration to run ILLIXR for in seconds. data : Path to the data file to dowload (build step) or use at runtime. If a URL is given (must start with http or https) the file will be downloaded and extracted; the path to the extracted data will be put in the illixr.yaml file. demo_data : The path to the demonstration data to use at runtime (ignored by build steps) build_type : The type of build to perform (Debug, Release, or RelWithDebInfo). Ignored at run time. install_prefix : The root path to where the compiled libraries and binaries should be installed. (e.g. specifying /home/user will install libraries in /home/user/lib and binaries in /home/user/bin). Note : The prefix is also used for installing any packages that were downloaded and build from external repositories (e.g. DBoW2, GTSAM, etc). At runtime this path is added to LD_LIBRARY_PATH to aid in finding the plugin libraries. enable_offload : ? Default is false enable_alignment : ? Default is false enable_verbose_errors : Controls the verbosity of error messages. Default is false enable_pre_sleep : ? Default is false In general, you should not edit a profile file directly. The exception to this is when you are testing things on your own machine. Profile files are generated automatically from the master profiles/plugins.yaml during the cmake configuration stage. This is done so that any changes to a profile or the addition or removal of a plugin can be managed from a single file. The build system will generate an illixr.yaml file which contains entries from the command line and any input profile file and can be freely edited (it is generated every time cmake is called).","title":"Profile file format"},{"location":"getting_started/#illixr-graphics-backends","text":"ILLIXR currently supports both OpenGL and Vulkan backends (indicated as gl and vk in the config suffixes). Since some plugins should behave differently (and compile differently) based on what backend is being used, it's important to run make clean if you want to try swapping between the two backends.","title":"ILLIXR Graphics Backends"},{"location":"getting_started/#rationale","text":"The current system can use profile files to control everything from the build to running ILLIXR, inkeeping with the DRY principle . However, for maximum flexibility control can also be done at the command line level as well.","title":"Rationale"},{"location":"getting_started/#philosophy","text":"Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Re-running make (and optionally cmake first) will only rebuild those parts of the code with have changed.","title":"Philosophy"},{"location":"getting_started/#next-steps","text":"Try browsing the source for the runtime and provided plugins. The source code is divided into components in the following directories: ILLIXR/src/ : A directory holding the implementation for loading and interfacing plugins. This directory contains Spindle . ILLIXR/include/illixr/ : A directory holding resources and utilities available globally to all plugins. This directory contains the interfaces for Switchboard and Phonebook . ILLIXR/plugins/<plugin_dir>/ : A unique directory for each plugin. Most of the core XR functionality is implemented via plugins. See Default Components for more details. If you edit any of the source files, the CMake system will detect and rebuild the respective binary the next time it runs. If you want to add your own plugin, see Writing Your Plugin . const dependencies = {}; const plugs = {}; const operatingSystems = {}; const profiles = []; var selectedOS = \"\"; var selectedOSv = \"\"; const plugins = new Set(); const module_json = { \"systems\": [ { \"name\": \"CentOS\", \"versions\": [ \"9\" ] }, { \"name\": \"Fedora\", \"versions\": [ \"37\", \"38\" ] }, { \"name\": \"Ubuntu\", \"versions\": [ \"20\", \"22\" ] } ], \"plugins\": [ { \"name\": \"audio_pipeline\", \"cmake_flag\": \"USE_AUDIO_PIPELINE=ON\", \"dependencies\": [ \"git\" ] }, { \"name\": \"debugview\", \"cmake_flag\": \"USE_DEBUGVIEW=ON\", \"dependencies\": [ \"glfw3\", \"OpenCV\" ] }, { \"name\": \"depthai\", \"cmake_flag\": \"USE_DEPTHAI=ON\", \"dependencies\": [ \"OpenCV\" ] }, { \"name\": \"display_vk\", \"cmake_flag\": \"USE_DISPLAY_VK=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"gldemo\", \"cmake_flag\": \"USE_GLDEMO=ON\", \"dependencies\": [] }, { \"name\": \"ground_truth_slam\", \"cmake_flag\": \"USE_GROUND_TRUTH_SLAM=ON\", \"dependencies\": [] }, { \"name\": \"gtsam_integrator\", \"cmake_flag\": \"USE_GTSAM_INTEGRATOR=ON\", \"dependencies\": [ \"git\" ] }, { \"name\": \"native_renderer\", \"cmake_flag\": \"USE_NATIVE_RENDERER=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"offline_cam\", \"cmake_flag\": \"USE_OFFLINE_CAM=ON\", \"dependencies\": [ \"OpenCV\" ] }, { \"name\": \"offline_imu\", \"cmake_flag\": \"USE_OFFLINE_IMU=ON\", \"dependencies\": [] }, { \"name\": \"offload_data\", \"cmake_flag\": \"USE_OFFLOAD_DATA=ON\", \"dependencies\": [ \"boost\" ] }, { \"name\": \"offload_vio.device_rx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.DEVICE_RX=ON\", \"dependencies\": [ \"git\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"offload_vio.device_tx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.DEVICE_TX=ON\", \"dependencies\": [ \"git\", \"glib\", \"gstreamer\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"offload_vio.server_tx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.SERVER_TX=ON\", \"dependencies\": [ \"git\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"offload_vio.server_rx\", \"cmake_flag\": \"USE_OFFLOAD_VIO.SERVER_RX=ON\", \"dependencies\": [ \"git\", \"glib\", \"gstreamer\", \"ecal\", \"protobuf\", \"OpenCV\" ] }, { \"name\": \"openni\", \"cmake_flag\": \"USE_OPENNI=ON\", \"dependencies\": [ \"libopenni2\", \"OpenCV\" ] }, { \"name\": \"openvins\", \"cmake_flag\": \"USE_OPENVINS=ON\", \"dependencies\": [ \"boost\" ] }, { \"name\": \"orb_slam\", \"cmake_flag\": \"USE_ORB_SLAM=ON\", \"dependencies\": [ \"git\", \"boost\", \"fmt\", \"patch\" ] }, { \"name\": \"passthrough_integrator\", \"cmake_flag\": \"USE_PASSTHROUGH_INTEGRATOR=ON\", \"dependencies\": [] }, { \"name\": \"pose_lookup\", \"cmake_flag\": \"USE_POSE_LOOKUP=ON\", \"dependencies\": [] }, { \"name\": \"pose_prediction\", \"cmake_flag\": \"USE_POSE_PREDICTION=ON\", \"dependencies\": [] }, { \"name\": \"realsense\", \"cmake_flag\": \"USE_REALSENSE=ON\", \"dependencies\": [ \"OpenCV\", \"realsense\" ] }, { \"name\": \"record_imu_cam\", \"cmake_flag\": \"USE_RECORD_IMU_CAM=ON\", \"dependencies\": [ \"boost\", \"OpenCV\" ] }, { \"name\": \"record_rgb_depth\", \"cmake_flag\": \"USE_RECORD_RGB_DEPTH=ON\", \"dependencies\": [ \"boost\", \"OpenCV\" ] }, { \"name\": \"rk4_integrator\", \"cmake_flag\": \"USE_RK4_INTEGRATOR=ON\", \"dependencies\": [] }, { \"name\": \"timewarp_gl\", \"cmake_flag\": \"USE_TIMEWARP_GL=ON\", \"dependencies\": [ \"git\", \"glslang\", \"gflags\", \"JPEG\", \"PNG\", \"TIFF\", \"udev\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"OpenXR\", \"Vulkan\", \"libusb\", \"libuvc\", \"SDL2\" ] }, { \"name\": \"timewarp_vk\", \"cmake_flag\": \"USE_TIMEWARP_VK=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"vkdemo\", \"cmake_flag\": \"USE_VKDEMO=ON\", \"dependencies\": [ \"OpenCV\", \"Vulkan\", \"glfw3\", \"glm\", \"OpenXR\", \"libusb\", \"libuvc\", \"udev\", \"JPEG\", \"PNG\", \"TIFF\", \"wayland-server\", \"x11-xcb\", \"xcb-glx\", \"xcb-randr\", \"xkbcommon\", \"SDL2\" ] }, { \"name\": \"zed\", \"cmake_flag\": \"USE_ZED=ON\", \"dependencies\": [ \"OpenCV\", \"zed_SDK\" ] } ], \"dependencies\": [ { \"boost\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libboost-all-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libboost-all-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"boost-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"boost-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"boost-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"ecal\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"ecal\", \"postnotes\": \"\", \"notes\": \"Ubuntu 20 does not have a system supplied package for eCAL, but it can be installed from the vendor by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#ecal20\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"ecal20\\\">sudo add-apt-repository ppa:ecal/ecal-latest -y -u\\nsudo apt-get update</pre></div>\" }, \"22\": { \"pkg\": \"ecal\", \"postnotes\": \"\", \"notes\": \"Ubuntu 22 does not have a system supplied package for eCAL, but it can be installed from the vendor by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#ecal22\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"ecal22\\\">sudo add-apt-repository ppa:ecal/ecal-latest -y -u\\nsudo apt-get update</pre></div>\" } }, \"Fedora\": { \"37\": { \"pkg\": \"graphviz hdf5-devel libcurl-devel qwt-qt5-devel qt5-qtbase-devel libyaml-devel zlib-devel openssl-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"graphviz hdf5-devel libcurl-devel qwt-qt5-devel qt5-qtbase-devel libyaml-devel zlib-devel openssl-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"graphviz hdf5-devel libcurl-devel qwt-qt5-devel qt5-qtbase-devel libyaml-devel zlib-devel openssl-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"fmt\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libfmt-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libfmt-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"fmt-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"fmt-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"fmt-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"gflags\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libgflags-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libgflags-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"gflags-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"gflags-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"gflags-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"git\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"git\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glfw3\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libglfw3-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libglfw3-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glfw-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glfw-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glfw-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glib\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libglib2.0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libglib2.0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glib-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glib-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glib-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glm\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libglm-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libglm-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glm-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glm-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glm-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glog\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libgoogle-glog-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libgoogle-glog-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glog-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glog-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glog-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"glslang\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"glslang-dev glslang-tools\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"glslang-dev glslang-tools\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"glslang-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"glslang-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"glslang-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"gstreamer\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"gstreamer-devel gstreamer1-plugins-base-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"gstreamer-devel gstreamer1-plugins-base-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"gstreamer-devel gstreamer1-plugins-base-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"JPEG\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libjpeg-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libjpeg-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libjpeg-turbo-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libjpeg-turbo-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libjpeg-turbo-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"libopenni2\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libopenni2-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libopenni2-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"openni-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"openni-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"No OpenNI package is natively available for CentOS\" } } } } }, { \"libusb\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libusb-1.0.0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libusb-1.0.0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libusb1-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libusb1-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libusb1-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"libuvc\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libuvc-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libuvc-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"Fedora does not supply libuvc from its repositories. You will need to install it from <a href=\\\"https://github.com/libuvc/libuvc\\\">https://github.com/libuvc/libuvc</a>.\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"Fedora does not supply libuvc from its repositories. You will need to install it from <a href=\\\"https://github.com/libuvc/libuvc\\\">https://github.com/libuvc/libuvc</a>.\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"CentOS does not supply libuvc from its repositories. You will need to install it from <a href=\\\"https://github.com/libuvc/libuvc\\\">https://github.com/libuvc/libuvc</a>.\" } } } } }, { \"OpenCV\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libopencv-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libopencv-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"opencv-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"opencv-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"vtk-devel\", \"postnotes\": \",\", \"notes\": \"Centos does not provide a complete version of OpenCV in their repos, in particular the 'viz' component is missing. You will need to install the VTK-devel package and the ILLIXR build system will compile OpenCV from source.<P>You may also need to run the following:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#opencvC\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"opencvC\\\">sudo dnf -y install dnf-plugins-core epel-release\\nsudo dnf config-manager --set-enabled crb</pre></div>\" } } } } }, { \"OpenXR\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libopenxr-dev libopenxr1-monado\", \"postnotes\": \"\", \"notes\": \"Ubuntu 20 does not have a system supplied package for OpenXR, but it can be installed from the vendor by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#openU20\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"openU20\\\">sudo apt-get -y install wget software-properties-common\\nsudo apt-get update\\nsudo add-apt-repository ppa:monado-xr/monado -y -u\\nsudo wget -nv https://monado.freedesktop.org/keys/monado-ci.asc -O /etc/apt/trusted.gpg.d/monado-ci.asc\\nsudo echo 'deb https://monado.pages.freedesktop.org/monado/apt focal main' | tee /etc/apt/sources.list.d/monado-ci.list\\nsudo apt update</pre></div>\" }, \"22\": { \"pkg\": \"libopenxr-dev libopenxr1-monado\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"openxr-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"openxr-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"openxr-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"patch\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"patch\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"PNG\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libpng-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libpng-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libpng-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libpng-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libpng-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"protobuf\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libprotobuf-dev libprotoc-dev protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libprotobuf-dev libprotoc-dev protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"protobuf-devel protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"protobuf-devel protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"protobuf-devel protobuf-compiler\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"qemu\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"qemu qemu-system qemu-system-data qeum-utils qemu-user libqcow-dev libqcow-utils\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"qemu qemu-system qemu-system-data qeum-utils qemu-user libqcow-dev libqcow-utils\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"??\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"??\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"??\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"realsense\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"librealsense2-dev librealsense2-gl-dev\", \"postnotes\": \"\", \"notes\": \"Ubuntu does not have a system supplied package for librealsense, but it can be installed from the vendor (Intel) by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#realU20\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"realU20\\\">sudo apt-get -y install curl apt-transport-https lsb-core\\nsudo mkdir -p /etc/apt/keyrings\\nsudo curl -sSf https://librealsense.intel.com/Debian/librealsense.pgp | tee /etc/apt/keyrings/librealsense.pgp > /dev/null\\nsudo echo \\\"deb [signed-by=/etc/apt/keyrings/librealsense.pgp] https://librealsense.intel.com/Debian/apt-repo `lsb_release -cs` main\\\" | tee /etc/apt/sources.list.d/librealsense.list > /dev/null\\nsudo apt-get update</pre></div>\" }, \"22\": { \"pkg\": \"librealsense2-dev librealsense2-gl-dev\", \"postnotes\": \"\", \"notes\": \"Ubuntu does not have a system supplied package for librealsense, but it can be installed from the vendor (Intel) by adding the following repo to your system:<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#realU22\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"realU22\\\">sudo apt-get -y install curl apt-transport-https lsb-core\\nsudo mkdir -p /etc/apt/keyrings\\nsudo curl -sSf https://librealsense.intel.com/Debian/librealsense.pgp | tee /etc/apt/keyrings/librealsense.pgp > /dev/null\\nsudo echo \\\"deb [signed-by=/etc/apt/keyrings/librealsense.pgp] https://librealsense.intel.com/Debian/apt-repo `lsb_release -cs` main\\\" | tee /etc/apt/sources.list.d/librealsense.list > /dev/null\\nsudo apt-get update</pre></div>\" } }, \"Fedora\": { \"37\": { \"pkg\": \"librealsense-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"librealsense-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"git zip unzip libtool\", \"postnotes\": \"Centos does not provide a vendor version of librealsense, but it can be automatically compiled and installed with the following, possibly as sudo (run after installing the above packages):<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#realC9\\\" title=\\\"Copy\\\"></button><pre class=\\\"language-shell\\\" id=\\\"realC9\\\">git clone https://github.com/Microsoft/vcpkg.git\\ncd vcpkg\\n./bootstrap-vcpkg.sh\\n./vcpkg integrate install\\n./vcpkg install realsense2</pre></div>\", \"notes\": \"\" } } } } }, { \"SDL2\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libsdl2-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libsdl2-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"SDL2-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"SDL2-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"SDL2-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"TIFF\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libtiff-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libtiff-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libtiff-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libtiff-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libtiff-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"udev\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"udev libudev-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"udev libudev-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"systemd-udev systemd-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"systemd-udev systemd-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"systemd systemd-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"Vulkan\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libvulkan-dev vulkan-validationlayers\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libvulkan-dev vulkan-validationlayers\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"vulkan-loader-devel vulkan-validation-layers\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"vulkan-loader-devel vulkan-validation-layers\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"vulkan-loader-devel vulkan-validation-layers\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"wayland-server\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libwayland-dev wayland-protocols\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libwayland-dev wayland-protocols\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"wayland-devel wayland-protocols-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"wayland-devel wayland-protocols-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"wayland-devel wayland-protocols-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"x11-xcb\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libx11-xcb-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libx11-xcb-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libX11-xcb libxcb-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libX11-xcb libxcb-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libX11-xcb libxcb-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"xcb-glx\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libxcb-glx0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libxcb-glx0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"xcb-randr\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libxcb-randr0-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libxcb-randr0-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"xkbcommon\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"libxkbcommon-dev\", \"postnotes\": \"\", \"notes\": \"\" }, \"22\": { \"pkg\": \"libxkbcommon-dev\", \"postnotes\": \"\", \"notes\": \"\" } }, \"Fedora\": { \"37\": { \"pkg\": \"libxkbcommon-devel\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"libxkbcommon-devel\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"libxkbcommon-devel\", \"postnotes\": \"\", \"notes\": \"\" } } } } }, { \"zed_SDK\": { \"pkg\": { \"Ubuntu\": { \"20\": { \"pkg\": \"zstd\", \"postnotes\": \"\", \"notes\": \"ZED SDK is required for the zed plugin. It must be installed manually. See <a href=\\\"https://www.stereolabs.com/docs/installation/linux/\\\">here</a> for details. It also requires some CUDA packages which should be available <a href=\\\"https://developer.nvidia.com/cuda-toolkit-archive\\\">here</a> or through your Ubuntu repo.\" }, \"22\": { \"pkg\": \"zstd\", \"postnotes\": \"\", \"notes\": \"ZED SDK (version 3) is required for the zed plugin. It must be installed manually. See <a href=\\\"https://www.stereolabs.com/docs/installation/linux/\\\">here</a> for details. It also requires some CUDA packages which should be available <a href=\\\"https://developer.nvidia.com/cuda-toolkit-archive\\\">here</a> or through your Ubuntu repo.\" } }, \"Fedora\": { \"37\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" }, \"38\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } }, \"CentOS\": { \"9\": { \"pkg\": \"\", \"postnotes\": \"\", \"notes\": \"\" } } } } } ], \"profiles\": [ { \"name\": \"ci\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"timewarp_gl\", \"audio_pipeline\"]}, { \"name\": \"headless\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"audio_pipeline\"]}, { \"name\": \"monado_gl\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"timewarp_gl\", \"audio_pipeline\"], \"build_flags\": \"-DILLIXR_MONADO\"}, { \"name\": \"monado_vk\", \"plugins\": [\"gtsam_integrator\", \"offline_cam\", \"offline_imu\", \"pose_prediction\", \"timewarp_vk\", \"audio_pipeline\"], \"build_flags\": \"-DILLIXR_VULKAN\"}, { \"name\": \"native_gl\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"timewarp_gl\", \"debugview\", \"offload_data\", \"audio_pipeline\"]}, { \"name\": \"native_vk\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"display_vk\", \"timewarp_vk\", \"vkdemo\", \"native_renderer\", \"debugview\"], \"build_flags\": \"-DILLIXR_VULKAN\"}, { \"name\": \"native_lookup\", \"plugins\": [\"pose_lookup\", \"gldemo\", \"debugview\", \"offload_data\", \"audio_pipeline\"]}, { \"name\": \"offload_device\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"ground_truth_slam\", \"gldemo\", \"debugview\", \"timewarp_gl\", \"offload_vio.device_rx\", \"offload_vio.device_tx\", \"audio_pipeline\"]}, { \"name\": \"offload_monado_vk\", \"plugins\": [\"offline_imu\", \"offline_cam\", \"gtsam_integrator\", \"pose_prediction\", \"timewarp_vk\", \"offload_vio.device_rx\", \"offload_vio.device_tx\", \"audio_pipeline\"], \"build_flags\": \"-DILLIXR_VULKAN\"}, { \"name\": \"offload_server\", \"plugins\": [\"offload_vio.server_rx\", \"offload_vio.server_tx\"]}, { \"name\": \"fauxpose\", \"plugins\": [\"fauxpose\", \"gldemo\", \"debugview\", \"audio_pipeline\"] } ] }; function makeCopyable(code, name) { return \"<div class=\\\"code-box-copy\\\">\\n<button class=\\\"code-box-copy__btn\\\" data-clipboard-target=\\\"#\" + name + \"\\\" title=\\\"Copy\\\">\\n</button>\\n<pre class=\\\"language-shell\\\" id=\\\"\" + name + \"\\\">\" + code + \"</pre>\\n</div>\\n\"; } function loadModules(){ for(let os of module_json[\"systems\"]) { operatingSystems[os.name] = os.versions; } for(let item of module_json[\"dependencies\"]) { let nm = \"\"; for(let i in item){ nm = i; } dependencies[nm] = {'pkg': item[nm].pkg, 'plugins' : []}; } for(let item of module_json[\"plugins\"]) { plugins.add(item.name); plugs[item.name] = item.cmake_flag; for(let dep of item.dependencies) { dependencies[dep].plugins.push(item.name); } } for(let grp of module_json[\"profiles\"]) { profiles.push(grp.name); profiles[grp.name] = []; for(let plug of grp.plugins) { profiles[grp.name].push(plug); } } } function updateSudo() { let sudoLine = \"\"; let notes = document.getElementById(\"notes\"); let pkgnotes = \"\"; let pkginfo = \"\"; let postnotes = document.getElementById(\"postnotes\"); let depinstall = document.getElementById(\"depinstall\"); notes.innerHTML = \"\"; if(selectedOS == \"Ubuntu\") { sudoLine = \"sudo apt-get install libglew-dev libglu1-mesa-dev libsqlite3-dev libx11-dev libgl-dev pkg-config libopencv-dev libeigen3-dev libc6-dev libspdlog-dev\"; postnotes.innerHTML = \"\"; } else if(selectedOS == \"Fedora\") { sudoLine = \"sudo dnf install glew-devel mesa-libGLU-devel sqlite-devel libX11-devel mesa-libGL-devel pkgconf-pkg-config opencv-devel eigen3-devel glibc-devel spdlog-devel\"; postnotes.innerHTML = \"Potential issues:<ul><li>If cmake is having trouble with some of the package-config (.pc) files used to locate packages you may need to run the following:\" + makeCopyable(\"sudo sed -i 's/\\^\\[ \\\\t\\]\\*//g' /usr/lib64/pkgconfig/*\", \"postF\") + \"</li><li>If the build step is having issues finding some of the include files you may need the following:\" + makeCopyable(\"sudo ln -s /usr/include /include\", \"post2F\") + \"</li></ul>\"; } else { sudoLine = \"sudo yum install glew-devel mesa-libGLU-devel sqlite-devel libX11-devel mesa-libGL-devel pkgconf-pkg-config vtk-devel eigen3-devel glibc-devel spdlog-devel\"; postnotes.innerHTML = \"Potential issues:<ul><li>If cmake is having trouble with some of the package-config (.pc) files used to locate packages you may need to run the following:\" + makeCopyable(\"sudo sed -i 's/\\^\\[ \\\\t\\]\\*//g' /usr/lib64/pkgconfig/*\", \"postC\") + \"</li><li>If the build step is having issues finding some of the include files you may need the following:\" + makeCopyable(\"sudo ln -s /usr/include /include\", \"post2C\") + \"</li></ul>\"; } for(let m in dependencies) { let checked = false; for(let p of dependencies[m].plugins) { checked ||= document.getElementById(p).checked; } if(checked) { sudoLine += \" \" + dependencies[m].pkg[selectedOS][selectedOSv].pkg; if(dependencies[m].pkg[selectedOS][selectedOSv].postnotes !== \"\") { pkgnotes += \"<P>\" + dependencies[m].pkg[selectedOS][selectedOSv].postnotes; } if(dependencies[m].pkg[selectedOS][selectedOSv].notes !== \"\") { if(pkginfo !== \"\") { pkginfo += \"<P>\"; } pkginfo += dependencies[m].pkg[selectedOS][selectedOSv].notes; } } } if(document.getElementById(\"withVirt\").checked) { sudoLine += \" \" + dependencies[\"qemu\"].pkg[selectedOS][selectedOSv].pkg; } if(pkginfo !== \"\") { notes.innerHTML = \"<h3>Notes:</h3>\" + pkginfo; } if(selectedOS == \"Ubuntu\" && (document.getElementById(\"offload_vio.device_tx\").checked || document.getElementById(\"offload_vio.device_rx\").checked || document.getElementById(\"offload_vio.server_tx\").checked || document.getElementById(\"offload_vio.server_rx\").checked)) { pkgnotes += \"<P><br>For the offload_vio plugins it is strongly recommended to install DeepStream. Please see the installation instructions <a href=\\\"https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_Quickstart.html#remove-all-previous-deepstream-installations\\\">here</a>.\"; } depinstall.innerHTML = pkgnotes; document.getElementById(\"output\").innerHTML = sudoLine; cmakeLine = \"cd ILLIXR\\nmkdir build\\ncd build\\ncmake .. -DCMAKE_INSTALL_PREFIX=&lt;LOCATION&gt;\"; let profile_check = false; for(let g of profiles) { if(document.getElementById(\"profile_\" + g).checked) { cmakeLine += \" -DYAML_FILE=profiles/\" + g.toLowerCase() + \".yaml\"; profile_check = true; break; } } if(!profile_check) { for(let p of plugins) { if(document.getElementById(p).checked) { cmakeLine += \" -D\" + plugs[p]; } } } cmakeLine += \"\\ncmake --build . -j4\\ncmake --build . -t docs # if you want to build the documentation\\ncmake --install .\"; document.getElementById(\"cmake\").innerHTML = makeCopyable(cmakeLine, \"cmakeC\"); $('.code-box-copy').codeBoxCopy(); } function updateOS(os_str) { const items = os_str.split(\".\"); selectedOS = items[0]; selectedOSv = items[1]; updateSudo(); } function checkAll() { for(let p of plugins) { document.getElementById(p).checked = document.getElementById(\"ALL_plugins\").checked; } updateSudo(); } function checkProfile(profile_name) { for(let p of plugins) { let setChecked = false; for(let pl of profiles[profile_name]) { if(p == pl) { setChecked = true; break; } } document.getElementById(p).checked = setChecked; } updateSudo(); } function updateChecked() { document.getElementById(\"None_plugins\").checked = true; updateSudo(); } async function setUpPage() { loadModules(); let osref = document.getElementById(\"operating_system\"); let osrow = osref.insertRow(-1); for(let x in operatingSystems) { let txt = x + \":\"; for(let ver of operatingSystems[x]) { txt += \"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type='radio' id='\" + x + \".\" + ver + \"' name='os_choice' value='\" + x + \".\" + ver + \"' onclick='updateOS(this.value);'>\" + ver; } let cell = osrow.insertCell(-1); cell.style.verticalAlign = \"top\"; cell.innerHTML = txt; } selectedOS = \"Ubuntu\"; selectedOSv = \"22\"; document.getElementById(selectedOS + \".\" + selectedOSv).checked = true; let tabRef = document.getElementById(\"profile_table\"); let count = 0; let currentRow = tabRef.insertRow(-1); let profilecell = currentRow.insertCell(-1); profilecell.innerHTML = \"<b>Profiles:</b>\"; profilecell.setAttribute(\"colspan\", profiles.length + 2); currentRow = tabRef.insertRow(-1); for(let g of profiles) { if(count >= 4) { currentRow = tabRef.insertRow(-1); count = 0; } let cell = currentRow.insertCell(-1); let radio = document.createElement(\"INPUT\"); radio.setAttribute(\"type\", \"radio\"); radio.setAttribute(\"onclick\", \"checkProfile('\" + g + \"');\"); radio.setAttribute(\"id\", \"profile_\" + g); radio.setAttribute(\"value\", \"profile_\" + g); radio.setAttribute(\"name\", \"profile_selection\"); let label = document.createElement(\"LABEL\"); label.setAttribute(\"for\", \"profile_\" + g); label.appendChild(document.createTextNode(g)); cell.appendChild(radio); cell.appendChild(label); count++; } count = 0; let none_cell = currentRow.insertCell(-1); let none_check = document.createElement(\"INPUT\"); none_check.setAttribute(\"type\", \"radio\"); none_check.setAttribute(\"onclick\", \"updateSudo();\"); none_check.setAttribute(\"id\", \"None_plugins\"); none_check.setAttribute(\"value\", \"None_plugins\"); none_check.setAttribute(\"name\", \"profile_selection\"); none_check.checked = true; let none_label = document.createElement(\"LABEL\"); none_label.setAttribute(\"for\", \"None_plugins\"); none_label.appendChild(document.createTextNode(\"None\")); none_cell.appendChild(none_check); none_cell.appendChild(none_label); tabRef = document.getElementById(\"listing_table\"); currentRow = tabRef.insertRow(-1); for(const dep of plugins) { if(count >= 4) { currentRow = tabRef.insertRow(-1); count = 0; } let cell = currentRow.insertCell(-1); let x = document.createElement(\"INPUT\"); x.setAttribute(\"type\", \"checkbox\"); x.setAttribute(\"onclick\", \"updateChecked();\"); x.setAttribute(\"id\", dep); let y = document.createElement(\"LABEL\"); y.setAttribute(\"for\", dep); y.appendChild(document.createTextNode(dep)); cell.appendChild(x); cell.appendChild(y); count += 1; } updateSudo(); } window.onload = setUpPage();","title":"Next Steps"},{"location":"glossary/","text":"Glossary of ILLIXR Terminology A collection of ILLIXR and ILLIXR-adjacent terms and their definitions can be found on this page your reference. General Asynchronous Reprojection The processing of rendered video for motion interpolation. Asynchronous reprojection improves the perception of the rendered video to the HMD when rendering misses it target frame rate . Asynchronous reprojection is implemented in the timewarpgl ILLIXR plugin . See the Wikipedia article . Chromatic Abberation Correction The processing of visual anomalies in images where colors are diffracted due to imperfect optics or other perturbing factors. For more information, see the Wikipedia article . Compositor A window manager that establishes a framebuffer for each window of a graphical system. A compositor merges information across its windows to construct a unified framebuffer. For more information, see the Wikipedia article . Distortion Correction The processing of visual anomalies in images where rectilinear features have been warped. For more information, see the Wikipedia artice . Eye Tracking The process of measuring the eye movement of a user (who is possibly also wearing a HMD ). For more information, see the Wikipedia article . Event Stream A communication interface supporting writes, sychronous reads, and asynchronous reads. For synchronous reads, every value written to the stream is visible to consumers. For asynchronous reads, only the latest values written are guaranteed to be visible to consumers. Framebuffer A region of memory used to hold graphical information to be output to a display or graphics device. Depth Buffer : A framebuffer representing the depth information of a 3D scene. Depth information is useful for applications such as graphics and SLAM . Eye Buffer : A framebuffer dedicated for display through a HMD lens to be perceived by a user's eye. Frame : A single frame (image) to be output to a display at a certain instant of time based on the system's frame rate . Frame Rate : The interval period between complete (as defined by the output resolution) frame updates and refreshes. In many systems, the target frame rate is determined by a fixed vertical sync ( VSYNC ) period. For more information, see the Wikipedia article . Ground Truth The most accurate source of measurement available for a data set. Typically, ground truth measurements are provided for the evaluation of sensor data where the sensor or other data source is not as accurate or reliable as the source for the ground truth. Ground Truth Poses : A collection of poses used to evaluate the accuracy of pose generation and prediction algorithms. Ground Truth Images : A collection of images used to evaluate the accuracy of visual processing algorithms, like SLAM and VIO . See the ILLIXR Plugins page for information about sensors implemented in ILLIXR. Head-mounted Display A display device worn on the head and face for use with VR and XR applications. Also known as a HMD . For more information, see the Wikipedia article . Inertial Measurement Unit A device that reports its orientation in space and any forces applied it. Also known as an IMU . An IMU is implemented in the offline_imu ILLIXR plugin . For more information, see the Wikipedia article . Plugin A modular component that can be detected and enabled for use by an ILLIXR application. A plugin can be internal or external to the ILLIXR project . Each plugin is compiled and launched dynamically at runtime based on the command line options given or ILLIXR profile file being used. ILLIXR also implements a Monado runtime translation Plugin . For a list of supported plugins and their details, see the ILLIXR Plugins page. For instructions for how to modify or write your own plugins, see the Modifying a Plugin and Writing Your Plugin pages. See the Plugin API documentation . Profile A profile describes the environment to be used for the build system and running ILLIXR. Profiles are defined in YAML files. There are several provided in the profiles directory in the repository. A profile file defines what plugins are to be used, as well as additional information specific to where it is being used. As input to CMake : If a profile file is given to cmake via the -DYAML_FILE= directive then the listed plugins will be built. As input to the ILLIXR binary If a profile file is given on the ILLIXR binary via the --yaml= command line option, then any listed plugins will be loaded and any other command line options given in the profile file will be used. See Running ILLIXR for details. The same profile file can be given to both cmake and the ILLIXR binary (you may need to change the data: entry), as any unrecognized options are ignored by both systems. See Profile file format for details on the profile file format. Pose The combination of orientation and position of an object, used for computer vision and robotics applications. ILLIXR applications make use of poses to track the user's HMD within the virtual environment. Internally, ILLIXR has multiple classifications of poses which are used for various purposes. Slow Pose : A slow pose is a ... TODO Fast Pose : A fast pose is a ... TODO True Pose : A true pose is a ... TODO Depracated starting ILLIXR release v2.X.X . Pose Prediction : To improve the user's perception latency experience the time between, pose prediction uses history and current system information to pre-compute the user's next pose Pre-computing the next pose allows for components downstream from the pose output in the event stream dataflow graph to begin computation. Pose Prediction is implemented in the pose_prediction ILLIXR plugin . For more information, see the Wikipedia article . Runtime The ILLIXR system runtime is responsible for the dynamic orchestration of ILLIXR device resources, system resources, and client applications. The runtime implementation is located in <ILLIXR_INSTALL_DIR>/bin . See the Getting Started and Monado Overiew pages for details about the ILLIXR runtime. Swap Chain A set of virtual framebuffers to be output to a display. Only one framebuffer in a swap chain is displayed at a time, enabling the other virtual framebuffers to be concurrently modified in memory. For more information, see the Wikipedia article . Simultaneous Localization and Mapping The computational process of creating a map of an unknown environment, and finding one's location within that space. Also known as SLAM . For more information, see the Wikipedia article . Visual Interial Odometry The process of computing a pose estimate from incoming visual information and measurements from the IMU . Also known as VIO . Often used in combination with SLAM techniques. See the Wikipedia article . Components Phonebook An ILLIXR service directory used to introspectively interface plugins and their data. The implementation resides in ILLIXR/runtime/ . See the Phonebook API documentation . Spindle An ILLIXR component responsible for launching and managing plugin threads. The implementation resides in ILLIXR/runtime/ . See the Spindle API documentation . Switchboard An ILLIXR event stream manager that maintains data pipelines between plugins. The implementation resides in ILLIXR/runtime/ . See the Switchboard API documentation . Technologies Docker A platform and containerization framework for deploying applications under virtualization. ILLIXR uses Docker to deploy and test code in a continuous integration and deployment pipeline. For more information, see the Docker overview and getting started page . Godot An open source game development engine. ILLIXR applications targeting the OpenXR use Godot to access the engine's integration with the OpenXR standard via Monado . For more information, visit the official Godot site . Monado An open source, modular implementation of the OpenXR standard for GNU/Linux . See the ILLIXR Monado Overview and Monado Dataflow pages for details about our runtime integration using Monado. For more information, visit the official Monado development site . OpenGL A cross-platform graphics API that allows developers to create graphics applications easily and portably. Also known as GL . GL Context : A data structure storing the state of an OpenGL application instance. Within a GL context resides framebuffer data. It is not thread safe to share contexts without appropriate synchronization. GLFW : An open source implementation of OpenGL. Supports Windows, MacOS and, Linux ( X11 and Wayland). See the GLFW development site . For more information, see the official OpenGL page from the Khronos Group . OpenXR An open standard for Augmented and Virtual Reality. ILLIXR components target the OpenXR standard and interact with the ILLIXR device via the Application Interface. For more information, visit the official site from the Khronos Group . QEMU-KVM An open source virtulization tool and machine emulator. See the instructions for running ILLIXR under Virtualization . For more information, see the official QEMU page . SQLite A SQL database engine implementation in C designed to be lightweight and easy to use. The ILLIXR project allows user to records application statistics to a local database for efficient processing. See the Logging and Metrics page for usage details. For more information, see the SQLite development site . Ubuntu An open source GNU/Linux operating system and distribution. ILLIXR currently supports the Long Term Support (LTS) versions of Ubuntu: 20.04 LTS (Focal) and 11.04 (Jammy) For more information, visit the official Ubuntu site . Vulkan A cross-platform graphics API that allows developers to efficiently target low-level hardware features. For more information, see the official Vulkan page from the Khronos Group . Xvfb A virtual framebuffer for the X11 Window Sytem . ILLIXR uses Xvfb to enable running the graphical ILLIXR application without requiring the user to have a graphical environment configured at application launch. For more information, see the Xfvb man page . YAML A markup language and data serialization standard designed to be user-friendly. We make use of the yaml-cpp libraries to read our profile files. For more information, visit the official YAML page .","title":"ILLIXR Glossary"},{"location":"glossary/#glossary-of-illixr-terminology","text":"A collection of ILLIXR and ILLIXR-adjacent terms and their definitions can be found on this page your reference.","title":"Glossary of ILLIXR Terminology"},{"location":"glossary/#general","text":"","title":"General"},{"location":"glossary/#asynchronous-reprojection","text":"The processing of rendered video for motion interpolation. Asynchronous reprojection improves the perception of the rendered video to the HMD when rendering misses it target frame rate . Asynchronous reprojection is implemented in the timewarpgl ILLIXR plugin . See the Wikipedia article .","title":"Asynchronous Reprojection"},{"location":"glossary/#chromatic-abberation-correction","text":"The processing of visual anomalies in images where colors are diffracted due to imperfect optics or other perturbing factors. For more information, see the Wikipedia article .","title":"Chromatic Abberation Correction"},{"location":"glossary/#compositor","text":"A window manager that establishes a framebuffer for each window of a graphical system. A compositor merges information across its windows to construct a unified framebuffer. For more information, see the Wikipedia article .","title":"Compositor"},{"location":"glossary/#distortion-correction","text":"The processing of visual anomalies in images where rectilinear features have been warped. For more information, see the Wikipedia artice .","title":"Distortion Correction"},{"location":"glossary/#eye-tracking","text":"The process of measuring the eye movement of a user (who is possibly also wearing a HMD ). For more information, see the Wikipedia article .","title":"Eye Tracking"},{"location":"glossary/#event-stream","text":"A communication interface supporting writes, sychronous reads, and asynchronous reads. For synchronous reads, every value written to the stream is visible to consumers. For asynchronous reads, only the latest values written are guaranteed to be visible to consumers.","title":"Event Stream"},{"location":"glossary/#framebuffer","text":"A region of memory used to hold graphical information to be output to a display or graphics device. Depth Buffer : A framebuffer representing the depth information of a 3D scene. Depth information is useful for applications such as graphics and SLAM . Eye Buffer : A framebuffer dedicated for display through a HMD lens to be perceived by a user's eye. Frame : A single frame (image) to be output to a display at a certain instant of time based on the system's frame rate . Frame Rate : The interval period between complete (as defined by the output resolution) frame updates and refreshes. In many systems, the target frame rate is determined by a fixed vertical sync ( VSYNC ) period. For more information, see the Wikipedia article .","title":"Framebuffer"},{"location":"glossary/#ground-truth","text":"The most accurate source of measurement available for a data set. Typically, ground truth measurements are provided for the evaluation of sensor data where the sensor or other data source is not as accurate or reliable as the source for the ground truth. Ground Truth Poses : A collection of poses used to evaluate the accuracy of pose generation and prediction algorithms. Ground Truth Images : A collection of images used to evaluate the accuracy of visual processing algorithms, like SLAM and VIO . See the ILLIXR Plugins page for information about sensors implemented in ILLIXR.","title":"Ground Truth"},{"location":"glossary/#head-mounted-display","text":"A display device worn on the head and face for use with VR and XR applications. Also known as a HMD . For more information, see the Wikipedia article .","title":"Head-mounted Display"},{"location":"glossary/#inertial-measurement-unit","text":"A device that reports its orientation in space and any forces applied it. Also known as an IMU . An IMU is implemented in the offline_imu ILLIXR plugin . For more information, see the Wikipedia article .","title":"Inertial Measurement Unit"},{"location":"glossary/#plugin","text":"A modular component that can be detected and enabled for use by an ILLIXR application. A plugin can be internal or external to the ILLIXR project . Each plugin is compiled and launched dynamically at runtime based on the command line options given or ILLIXR profile file being used. ILLIXR also implements a Monado runtime translation Plugin . For a list of supported plugins and their details, see the ILLIXR Plugins page. For instructions for how to modify or write your own plugins, see the Modifying a Plugin and Writing Your Plugin pages. See the Plugin API documentation .","title":"Plugin"},{"location":"glossary/#profile","text":"A profile describes the environment to be used for the build system and running ILLIXR. Profiles are defined in YAML files. There are several provided in the profiles directory in the repository. A profile file defines what plugins are to be used, as well as additional information specific to where it is being used. As input to CMake : If a profile file is given to cmake via the -DYAML_FILE= directive then the listed plugins will be built. As input to the ILLIXR binary If a profile file is given on the ILLIXR binary via the --yaml= command line option, then any listed plugins will be loaded and any other command line options given in the profile file will be used. See Running ILLIXR for details. The same profile file can be given to both cmake and the ILLIXR binary (you may need to change the data: entry), as any unrecognized options are ignored by both systems. See Profile file format for details on the profile file format.","title":"Profile"},{"location":"glossary/#pose","text":"The combination of orientation and position of an object, used for computer vision and robotics applications. ILLIXR applications make use of poses to track the user's HMD within the virtual environment. Internally, ILLIXR has multiple classifications of poses which are used for various purposes. Slow Pose : A slow pose is a ... TODO Fast Pose : A fast pose is a ... TODO True Pose : A true pose is a ... TODO Depracated starting ILLIXR release v2.X.X . Pose Prediction : To improve the user's perception latency experience the time between, pose prediction uses history and current system information to pre-compute the user's next pose Pre-computing the next pose allows for components downstream from the pose output in the event stream dataflow graph to begin computation. Pose Prediction is implemented in the pose_prediction ILLIXR plugin . For more information, see the Wikipedia article .","title":"Pose"},{"location":"glossary/#runtime","text":"The ILLIXR system runtime is responsible for the dynamic orchestration of ILLIXR device resources, system resources, and client applications. The runtime implementation is located in <ILLIXR_INSTALL_DIR>/bin . See the Getting Started and Monado Overiew pages for details about the ILLIXR runtime.","title":"Runtime"},{"location":"glossary/#swap-chain","text":"A set of virtual framebuffers to be output to a display. Only one framebuffer in a swap chain is displayed at a time, enabling the other virtual framebuffers to be concurrently modified in memory. For more information, see the Wikipedia article .","title":"Swap Chain"},{"location":"glossary/#simultaneous-localization-and-mapping","text":"The computational process of creating a map of an unknown environment, and finding one's location within that space. Also known as SLAM . For more information, see the Wikipedia article .","title":"Simultaneous Localization and Mapping"},{"location":"glossary/#visual-interial-odometry","text":"The process of computing a pose estimate from incoming visual information and measurements from the IMU . Also known as VIO . Often used in combination with SLAM techniques. See the Wikipedia article .","title":"Visual Interial Odometry"},{"location":"glossary/#components","text":"","title":"Components"},{"location":"glossary/#phonebook","text":"An ILLIXR service directory used to introspectively interface plugins and their data. The implementation resides in ILLIXR/runtime/ . See the Phonebook API documentation .","title":"Phonebook"},{"location":"glossary/#spindle","text":"An ILLIXR component responsible for launching and managing plugin threads. The implementation resides in ILLIXR/runtime/ . See the Spindle API documentation .","title":"Spindle"},{"location":"glossary/#switchboard","text":"An ILLIXR event stream manager that maintains data pipelines between plugins. The implementation resides in ILLIXR/runtime/ . See the Switchboard API documentation .","title":"Switchboard"},{"location":"glossary/#technologies","text":"","title":"Technologies"},{"location":"glossary/#docker","text":"A platform and containerization framework for deploying applications under virtualization. ILLIXR uses Docker to deploy and test code in a continuous integration and deployment pipeline. For more information, see the Docker overview and getting started page .","title":"Docker"},{"location":"glossary/#godot","text":"An open source game development engine. ILLIXR applications targeting the OpenXR use Godot to access the engine's integration with the OpenXR standard via Monado . For more information, visit the official Godot site .","title":"Godot"},{"location":"glossary/#monado","text":"An open source, modular implementation of the OpenXR standard for GNU/Linux . See the ILLIXR Monado Overview and Monado Dataflow pages for details about our runtime integration using Monado. For more information, visit the official Monado development site .","title":"Monado"},{"location":"glossary/#opengl","text":"A cross-platform graphics API that allows developers to create graphics applications easily and portably. Also known as GL . GL Context : A data structure storing the state of an OpenGL application instance. Within a GL context resides framebuffer data. It is not thread safe to share contexts without appropriate synchronization. GLFW : An open source implementation of OpenGL. Supports Windows, MacOS and, Linux ( X11 and Wayland). See the GLFW development site . For more information, see the official OpenGL page from the Khronos Group .","title":"OpenGL"},{"location":"glossary/#openxr","text":"An open standard for Augmented and Virtual Reality. ILLIXR components target the OpenXR standard and interact with the ILLIXR device via the Application Interface. For more information, visit the official site from the Khronos Group .","title":"OpenXR"},{"location":"glossary/#qemu-kvm","text":"An open source virtulization tool and machine emulator. See the instructions for running ILLIXR under Virtualization . For more information, see the official QEMU page .","title":"QEMU-KVM"},{"location":"glossary/#sqlite","text":"A SQL database engine implementation in C designed to be lightweight and easy to use. The ILLIXR project allows user to records application statistics to a local database for efficient processing. See the Logging and Metrics page for usage details. For more information, see the SQLite development site .","title":"SQLite"},{"location":"glossary/#ubuntu","text":"An open source GNU/Linux operating system and distribution. ILLIXR currently supports the Long Term Support (LTS) versions of Ubuntu: 20.04 LTS (Focal) and 11.04 (Jammy) For more information, visit the official Ubuntu site .","title":"Ubuntu"},{"location":"glossary/#vulkan","text":"A cross-platform graphics API that allows developers to efficiently target low-level hardware features. For more information, see the official Vulkan page from the Khronos Group .","title":"Vulkan"},{"location":"glossary/#xvfb","text":"A virtual framebuffer for the X11 Window Sytem . ILLIXR uses Xvfb to enable running the graphical ILLIXR application without requiring the user to have a graphical environment configured at application launch. For more information, see the Xfvb man page .","title":"Xvfb"},{"location":"glossary/#yaml","text":"A markup language and data serialization standard designed to be user-friendly. We make use of the yaml-cpp libraries to read our profile files. For more information, visit the official YAML page .","title":"YAML"},{"location":"illixr_plugins/","text":"ILLIXR plugins This page details the structure of ILLIXR's plugins and how they interact with each other. Default Plugins audio_pipeline : Launches a thread for binaural recording and one for binaural playback. Audio output is not yet routed to the system's speakers or microphone, but the plugin's compute workload is still representative of a real system. By default this plugin is enabled (see native configuration ). Topic details: Calls pose_prediction . debugview : Renders incoming frames from the graphics pipeline for debugging live executions of the application. Topic details: Calls pose_prediction . Asynchronously reads fast_pose on imu_raw topic. ( IMU biases are unused). Asynchronously reads slow_pose on slow_pose topic. Synchronously reads imu on imu topic. Asynchronously reads buffered cam_type on cam topic. gldemo : Renders a static scene (into left and right eye buffers ) given the pose from pose_prediction . Topic details: Calls pose_prediction . Publishes rendered_frame on eyebuffer topic. Asynchronously reads time_type on vsync_estimate topic. ground_truth_slam : Reads the ground truth from the same dataset as the offline_imu plugin. Ground truth data can be compared against the measurements from offline_imu for accuracy. Timing information is taken from the offline_imu measurements/data. Topic details: Publishes pose_type on true_pose topic. Asynchronously reads imu_type on imu topic. gtsam_integrator : Integrates over all IMU samples since the last published SLAM pose to provide a fast pose every time a new IMU sample arrives using the GTSAM library ( upstream ). Topic details: Publishes imu_raw_type on imu_raw topic. Synchronously reads/subscribes to imu_type on imu topic. Asynchronously reads imu_integrator_input on imu_integrator_input topic. offline_imu : Reads IMU data files on disk, emulating a real sensor on the headset (feeds the application input measurements with timing similar to an actual IMU). Topic details: Publishes imu_type on imu topic. offline_cam : Reads camera images from files on disk, emulating real cameras on the headset (feeds the application input measurements with timing similar to an actual camera). Topic details: Publishes cam_type on cam topic. pose_prediction : Uses the latest IMU value to predict a pose for a future point in time. Implements the pose_prediction service (defined in common ), so poses can be served directly to other plugins. Topic details: Asynchronously reads pose_type on slow_pose topic, but it is only used as a fallback. Asynchronously reads imu_raw on imu_raw topic. Asynchronously reads pose_type on true_pose topic, but it is only used if the client asks for the true pose. Asynchronously reads time_type on vsync_estimate topic. This tells pose_predict what time to estimate for. timewarp_gl : Asynchronous reprojection of the eye buffers . The timewarp ends just after vsync , so it can deduce when the next vsync will be. Topic details: Calls pose_prediction . Asynchronously reads rendered_frame on eyebuffer topic. Publishes time_type on vsync_estimate topic. Publishes hologram_input on hologram_in topic. Publishes texture_pose on texture_pose topic if ILLIXR_OFFLOAD_ENABLE is set in the env. Below this point, we will use Switchboard terminology. Read the API documentation on Switchboard for more information. In the above figure, ovals are plugins. Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. Some action is taken for every event which gets published on the topic. Dashed arrows from topics to plugins represent asynchronous reading. Plugin readers only need the latest event on their topic. Imagine the topic as a trough filling with events from its publisher. Synchronous readers (AKA subscribers) drain the trough, while asynchronous readers just skim fresh events off the top of the trough. See Writing Your Plugin to extend ILLIXR. Other Supported Plugins ILLIXR supports additional plugins to replace some of the default plugins. fauxpose : An alternate tracking implementation that simply generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking. Topic details: - Publishes pose_position on fast_pose topic. hologram : Adapts the eyebuffer for use on a holographic display. By default, this plugin is disabled, since an NVIDIA GPU is currently required. Topic details: Asynchronously reads hologram_input on hologram_in topic. Hologram is too slow to run for every input, so the plugin implements an asynchronous reader which can drop inputs. offload_data : Writes frames and poses output from the asynchronous reprojection plugin to disk for analysis. Topic details: Synchronously reads texture_pose on texture_pose topic. open_vins : An alternate SLAM ( upstream ) implementation that uses a MSCKF (Multi-State Constrained Kalman Filter) to determine poses via camera/ IMU . Topic details: Publishes pose_type on slow_pose topic. Publishes imu_integrator_input on imu_integrator_input topic. Synchronously reads / subscribes to imu_type on imu topic. pose_lookup : Implements the pose_predict service, but uses ground truth from the dataset. The plugin peeks \"into the future\" to determine what the exact pose will be at a certain time. Topic details: Asynchronously reads time_type on vsync_estimate topic. This tells pose_lookup what time to lookup. realsense : Reads images and IMU measurements from the Intel Realsense . Topic details: Same interface as zed . rk4_integrator : Integrates over all IMU samples since the last published SLAM pose to provide a fast pose every time a new IMU sample arrives using RK4 integration. Topic details: Same interface as gtsam_integrator . zed : Reads images and IMU measurements from the ZED Mini . Unlike offline_imu , zed additionally has RGB and depth data. Note that this plugin implements two threads: one for the camera, and one for the IMU. Topic details: Publishes imu_type on imu topic. Publishes rgb_depth_type on rgb_depth topic. See Getting Started for more information on adding plugins to a profile file.","title":"ILLIXR Plugin Overview"},{"location":"illixr_plugins/#illixr-plugins","text":"This page details the structure of ILLIXR's plugins and how they interact with each other.","title":"ILLIXR plugins"},{"location":"illixr_plugins/#default-plugins","text":"audio_pipeline : Launches a thread for binaural recording and one for binaural playback. Audio output is not yet routed to the system's speakers or microphone, but the plugin's compute workload is still representative of a real system. By default this plugin is enabled (see native configuration ). Topic details: Calls pose_prediction . debugview : Renders incoming frames from the graphics pipeline for debugging live executions of the application. Topic details: Calls pose_prediction . Asynchronously reads fast_pose on imu_raw topic. ( IMU biases are unused). Asynchronously reads slow_pose on slow_pose topic. Synchronously reads imu on imu topic. Asynchronously reads buffered cam_type on cam topic. gldemo : Renders a static scene (into left and right eye buffers ) given the pose from pose_prediction . Topic details: Calls pose_prediction . Publishes rendered_frame on eyebuffer topic. Asynchronously reads time_type on vsync_estimate topic. ground_truth_slam : Reads the ground truth from the same dataset as the offline_imu plugin. Ground truth data can be compared against the measurements from offline_imu for accuracy. Timing information is taken from the offline_imu measurements/data. Topic details: Publishes pose_type on true_pose topic. Asynchronously reads imu_type on imu topic. gtsam_integrator : Integrates over all IMU samples since the last published SLAM pose to provide a fast pose every time a new IMU sample arrives using the GTSAM library ( upstream ). Topic details: Publishes imu_raw_type on imu_raw topic. Synchronously reads/subscribes to imu_type on imu topic. Asynchronously reads imu_integrator_input on imu_integrator_input topic. offline_imu : Reads IMU data files on disk, emulating a real sensor on the headset (feeds the application input measurements with timing similar to an actual IMU). Topic details: Publishes imu_type on imu topic. offline_cam : Reads camera images from files on disk, emulating real cameras on the headset (feeds the application input measurements with timing similar to an actual camera). Topic details: Publishes cam_type on cam topic. pose_prediction : Uses the latest IMU value to predict a pose for a future point in time. Implements the pose_prediction service (defined in common ), so poses can be served directly to other plugins. Topic details: Asynchronously reads pose_type on slow_pose topic, but it is only used as a fallback. Asynchronously reads imu_raw on imu_raw topic. Asynchronously reads pose_type on true_pose topic, but it is only used if the client asks for the true pose. Asynchronously reads time_type on vsync_estimate topic. This tells pose_predict what time to estimate for. timewarp_gl : Asynchronous reprojection of the eye buffers . The timewarp ends just after vsync , so it can deduce when the next vsync will be. Topic details: Calls pose_prediction . Asynchronously reads rendered_frame on eyebuffer topic. Publishes time_type on vsync_estimate topic. Publishes hologram_input on hologram_in topic. Publishes texture_pose on texture_pose topic if ILLIXR_OFFLOAD_ENABLE is set in the env. Below this point, we will use Switchboard terminology. Read the API documentation on Switchboard for more information. In the above figure, ovals are plugins. Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. Some action is taken for every event which gets published on the topic. Dashed arrows from topics to plugins represent asynchronous reading. Plugin readers only need the latest event on their topic. Imagine the topic as a trough filling with events from its publisher. Synchronous readers (AKA subscribers) drain the trough, while asynchronous readers just skim fresh events off the top of the trough. See Writing Your Plugin to extend ILLIXR.","title":"Default Plugins"},{"location":"illixr_plugins/#other-supported-plugins","text":"ILLIXR supports additional plugins to replace some of the default plugins. fauxpose : An alternate tracking implementation that simply generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking. Topic details: - Publishes pose_position on fast_pose topic. hologram : Adapts the eyebuffer for use on a holographic display. By default, this plugin is disabled, since an NVIDIA GPU is currently required. Topic details: Asynchronously reads hologram_input on hologram_in topic. Hologram is too slow to run for every input, so the plugin implements an asynchronous reader which can drop inputs. offload_data : Writes frames and poses output from the asynchronous reprojection plugin to disk for analysis. Topic details: Synchronously reads texture_pose on texture_pose topic. open_vins : An alternate SLAM ( upstream ) implementation that uses a MSCKF (Multi-State Constrained Kalman Filter) to determine poses via camera/ IMU . Topic details: Publishes pose_type on slow_pose topic. Publishes imu_integrator_input on imu_integrator_input topic. Synchronously reads / subscribes to imu_type on imu topic. pose_lookup : Implements the pose_predict service, but uses ground truth from the dataset. The plugin peeks \"into the future\" to determine what the exact pose will be at a certain time. Topic details: Asynchronously reads time_type on vsync_estimate topic. This tells pose_lookup what time to lookup. realsense : Reads images and IMU measurements from the Intel Realsense . Topic details: Same interface as zed . rk4_integrator : Integrates over all IMU samples since the last published SLAM pose to provide a fast pose every time a new IMU sample arrives using RK4 integration. Topic details: Same interface as gtsam_integrator . zed : Reads images and IMU measurements from the ZED Mini . Unlike offline_imu , zed additionally has RGB and depth data. Note that this plugin implements two threads: one for the camera, and one for the IMU. Topic details: Publishes imu_type on imu topic. Publishes rgb_depth_type on rgb_depth topic. See Getting Started for more information on adding plugins to a profile file.","title":"Other Supported Plugins"},{"location":"logging_and_metrics/","text":"Logging and Metrics The ILLIXR project supports several ways for an ILLIXR application to log and report details about its execution. Logging ILLIXR uses the spdlog library for logging. Logging goes to both STDOUT and one or more log files in $ILLIXR_ROOT/logs/ Available levels, from low to high are: trace , debug , info , warn , error , critical , off . If NDEBUG is not defined, then the default logging level is warn , otherwise it is debug . Logging is activated by exporting environment variables to a particular level before running ILLIXR. These take the form of <PLUGIN_NAME>_LOG_LEVEL , e.g., # Activate logging for both the ground_truth_slam plugin and the ILLIXR app # Each will log to the console, with color (actual colors dependent on the terminal settings) # Each log will write to $ILLIXR_ROOT/logs/<plugin_name>.log # Each log can have a different level. export GROUND_TRUTH_SLAM_LOG_LEVEL=debug export ILLIXR_LOG_LEVEL=warn main.dbg.exe -yaml=profiles/native_gl.yaml When writing a new plugin, the plugin.spdlogger(std::string log_level) method should be called, e.g., using std::getenv(\"<PLUGIN_NAME>_LOG_LEVEL\") This creates a logger with two sinks (console and file). This logger is then registered in the global spdlog registry. To log inside of a plugin method, use the plugin's name attribute to get the particular logger from the registry and call the desired log level method, e.g. spdlog::get(name)->info(\"informative message\"); Outside of the plugin class hierarchy, one can use the global ILLIXR logger which is registered under \"illixr\", e.g., spdlog::get(\"illixr\") . It will look for $ILLIXR_LOG_LEVEL in the environment or use warn by default. This usage requires explicitly adding the name of the component or file to the output message, if desired. Log files are appended. To merge to a single log do $ cat *log | sort > combined.log This will sort correctly because the entries start with an ISO-8601 timestamp. For this reason, if a plugin uses spdlog::set_pattern() to create a custom log pattern, it is highly recommended that the custom pattern start with an ISO-8601 timestamp and it is required to reset to the default log message pattern after use. Note about #ifndef NDEBUG/#endif blocks Many of the plugins contain their logging statements inside of blocks which are only active when doing a debug build. This is a historical artifact. New plugins should carefully consider the difference between logging a debug message and conditionally compiling blocks of code based on build type. Metrics ILLIXR allows users to generate higher order statistics from logged results called Metrics . TODO","title":"Logging and Metrics"},{"location":"logging_and_metrics/#logging-and-metrics","text":"The ILLIXR project supports several ways for an ILLIXR application to log and report details about its execution.","title":"Logging and Metrics"},{"location":"logging_and_metrics/#logging","text":"ILLIXR uses the spdlog library for logging. Logging goes to both STDOUT and one or more log files in $ILLIXR_ROOT/logs/ Available levels, from low to high are: trace , debug , info , warn , error , critical , off . If NDEBUG is not defined, then the default logging level is warn , otherwise it is debug . Logging is activated by exporting environment variables to a particular level before running ILLIXR. These take the form of <PLUGIN_NAME>_LOG_LEVEL , e.g., # Activate logging for both the ground_truth_slam plugin and the ILLIXR app # Each will log to the console, with color (actual colors dependent on the terminal settings) # Each log will write to $ILLIXR_ROOT/logs/<plugin_name>.log # Each log can have a different level. export GROUND_TRUTH_SLAM_LOG_LEVEL=debug export ILLIXR_LOG_LEVEL=warn main.dbg.exe -yaml=profiles/native_gl.yaml When writing a new plugin, the plugin.spdlogger(std::string log_level) method should be called, e.g., using std::getenv(\"<PLUGIN_NAME>_LOG_LEVEL\") This creates a logger with two sinks (console and file). This logger is then registered in the global spdlog registry. To log inside of a plugin method, use the plugin's name attribute to get the particular logger from the registry and call the desired log level method, e.g. spdlog::get(name)->info(\"informative message\"); Outside of the plugin class hierarchy, one can use the global ILLIXR logger which is registered under \"illixr\", e.g., spdlog::get(\"illixr\") . It will look for $ILLIXR_LOG_LEVEL in the environment or use warn by default. This usage requires explicitly adding the name of the component or file to the output message, if desired. Log files are appended. To merge to a single log do $ cat *log | sort > combined.log This will sort correctly because the entries start with an ISO-8601 timestamp. For this reason, if a plugin uses spdlog::set_pattern() to create a custom log pattern, it is highly recommended that the custom pattern start with an ISO-8601 timestamp and it is required to reset to the default log message pattern after use.","title":"Logging"},{"location":"logging_and_metrics/#note-about-ifndef-ndebugendif-blocks","text":"Many of the plugins contain their logging statements inside of blocks which are only active when doing a debug build. This is a historical artifact. New plugins should carefully consider the difference between logging a debug message and conditionally compiling blocks of code based on build type.","title":"Note about #ifndef NDEBUG/#endif blocks"},{"location":"logging_and_metrics/#metrics","text":"ILLIXR allows users to generate higher order statistics from logged results called Metrics . TODO","title":"Metrics"},{"location":"modifying_a_plugin/","text":"Modifying a plugin Tutorial This is how you can modify an existing ILLIXR plugin. This example uses the Audio Pipeline plugin, but the steps can be applied to any plugin. Fork the repository for the component you want to modify into your own repo using the github web interface, then pull your repo to your computer. For example, using the Audio Pipeline plugin: bash git clone https://github.com/<YOUR_USER_NAME>/audio_pipeline.git Modify the associated cmake/GetAudioPipeline.cmake original ```cmake get_external(PortAudio) get_external(SpatialAudio) set(AUDIO_PIPELINE_CMAKE_ARGS \"\") if(HAVE_CENTOS) set(AUDIO_PIPELINE_CMAKE_ARGS \"-DINTERNAL_OPENCV=${OpenCV_DIR}\") endif() ExternalProject_Add(Audio_Pipeline GIT_REPOSITORY https://github.com/ILLIXR/audio_pipeline.git GIT_TAG 714c3541378ece7b481804e4a504e23b49c2bdbe PREFIX ${CMAKE_BINARY_DIR}/_deps/audio_pipeline DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR} ${OpenCV_DEP_STR} CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS} ) which becomes `cmake/GetMyAudioPipeline.cmake` cmake get_external(PortAudio) get_external(SpatialAudio) set(AUDIO_PIPELINE_CMAKE_ARGS \"\") if(HAVE_CENTOS) set(AUDIO_PIPELINE_CMAKE_ARGS \"-DINTERNAL_OPENCV=${OpenCV_DIR}\") endif() ExternalProject_Add(Audio_Pipeline GIT_REPOSITORY https://github.com/ /audio_pipeline.git PREFIX ${CMAKE_BINARY_DIR}/_deps/myaudio_pipeline DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR} ${OpenCV_DEP_STR} CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS} ) ``` Make whatever changes to the plugin code you want and be sure to push them to your forked repo. See the instructions on Getting Started to learn how to build and run ILLIXR. To push the modification to upstream ILLIXR, create a PR to the original repository.","title":"Modifying a Plugin"},{"location":"modifying_a_plugin/#modifying-a-plugin","text":"","title":"Modifying a plugin"},{"location":"modifying_a_plugin/#tutorial","text":"This is how you can modify an existing ILLIXR plugin. This example uses the Audio Pipeline plugin, but the steps can be applied to any plugin. Fork the repository for the component you want to modify into your own repo using the github web interface, then pull your repo to your computer. For example, using the Audio Pipeline plugin: bash git clone https://github.com/<YOUR_USER_NAME>/audio_pipeline.git Modify the associated cmake/GetAudioPipeline.cmake original ```cmake get_external(PortAudio) get_external(SpatialAudio) set(AUDIO_PIPELINE_CMAKE_ARGS \"\") if(HAVE_CENTOS) set(AUDIO_PIPELINE_CMAKE_ARGS \"-DINTERNAL_OPENCV=${OpenCV_DIR}\") endif() ExternalProject_Add(Audio_Pipeline GIT_REPOSITORY https://github.com/ILLIXR/audio_pipeline.git GIT_TAG 714c3541378ece7b481804e4a504e23b49c2bdbe PREFIX ${CMAKE_BINARY_DIR}/_deps/audio_pipeline DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR} ${OpenCV_DEP_STR} CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS} ) which becomes `cmake/GetMyAudioPipeline.cmake` cmake get_external(PortAudio) get_external(SpatialAudio) set(AUDIO_PIPELINE_CMAKE_ARGS \"\") if(HAVE_CENTOS) set(AUDIO_PIPELINE_CMAKE_ARGS \"-DINTERNAL_OPENCV=${OpenCV_DIR}\") endif() ExternalProject_Add(Audio_Pipeline GIT_REPOSITORY https://github.com/ /audio_pipeline.git PREFIX ${CMAKE_BINARY_DIR}/_deps/myaudio_pipeline DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR} ${OpenCV_DEP_STR} CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS} ) ``` Make whatever changes to the plugin code you want and be sure to push them to your forked repo. See the instructions on Getting Started to learn how to build and run ILLIXR. To push the modification to upstream ILLIXR, create a PR to the original repository.","title":"Tutorial"},{"location":"updating_tags_and_docs/","text":"Updating Tags and Documentation Updating Tags For releases, perform these steps from master once the desired features have been merged in. Get latest tags: git pull --tags -f Tag your branch. Please use semantic versioning to name the tag; i.e., v<major>.<minor>.<patch> : git tag -f <tag-name> ## `-f` is required if updating an existing tag Push your tag upstream: git push origin --tags Updating Documentation Perform these steps from the root directory of the project. Create the directory where the generated files will be placed: mkdir -p site/api Run doxygen to generate API documentation: doxygen doxygen.conf Run mkdocs to deploy new documentation: mkdocs gh-deploy","title":"Updating Tags and Documentation"},{"location":"updating_tags_and_docs/#updating-tags-and-documentation","text":"","title":"Updating Tags and Documentation"},{"location":"updating_tags_and_docs/#updating-tags","text":"For releases, perform these steps from master once the desired features have been merged in. Get latest tags: git pull --tags -f Tag your branch. Please use semantic versioning to name the tag; i.e., v<major>.<minor>.<patch> : git tag -f <tag-name> ## `-f` is required if updating an existing tag Push your tag upstream: git push origin --tags","title":"Updating Tags"},{"location":"updating_tags_and_docs/#updating-documentation","text":"Perform these steps from the root directory of the project. Create the directory where the generated files will be placed: mkdir -p site/api Run doxygen to generate API documentation: doxygen doxygen.conf Run mkdocs to deploy new documentation: mkdocs gh-deploy","title":"Updating Documentation"},{"location":"using_cameras/","text":"Using Cameras with ILLIXR ILLIXR supports a wide range of cameras, most of which are for the purpose of feeding images and IMU measurements to the system. To learn more about how it works, checkout Getting Started . If you are interested in what topics these cameras feed into, checkout ILLIXR plugins . Important Note : Before running any of these plugins below, it is important to comment out offline_cam and offline_imu in configs\\native.yaml . Add Calibration Parameters In order to add your camera's calibration extrinsics, you need to modify your choice of SLAM/VIO plugin. Follow these instructions to modify a plugin . OpenVINS : Navigate to ov_msckf/src . Uncomment this line out in slam2.cpp in order to use ZED's calibration parameter for OpenVins. You can add your own calibration parameters in the same file. ZED Mini Install ZED SDK Install the latest version of the ZED SDK on stereolabs.com . For more information, checkout the ZED API documentation . Get ZED's calibration parameters Both OpenVINS have a decent calibration parameters for ZED. But if you wish to add your own: /usr/local/zed/tools/ZED_Calibration Your original factory calibration file is stored here /usr/local/zed/settings/ Or download it from calib.stereolabs.com . Enable ZED in OpenVINS plugin This step is only required if using OpenVINS. Uncomment this line in the OpenVINS plugin. Run ILLIXR with ZED: Uncomment zed in configs/rt_slam_plugins.yaml and run ILLIXR normally. Intel Realsense ILLIXR has been tested with Inteal RealSense D455, but it should work with any D or T series RealSense Camera. Install librealsense (if you haven't already): Instruction on how to install can be found here . Get RealSense calibration parameters: Navigate to enumerate-devices ./PATH/TO/LIBREALSENSE/build/tools/enumerate-devices Run this command to obtain the calibration parameters ./rs-enumerate-devices -c Run ILLIXR with RealSense: Uncomment realsense in configs/rt_slam_plugins.yaml and run ILLIXR normally. Note: We will release the corresponding #define realsense soon for OpenVINS + Realsense","title":"Using ILLIXR with Cameras"},{"location":"using_cameras/#using-cameras-with-illixr","text":"ILLIXR supports a wide range of cameras, most of which are for the purpose of feeding images and IMU measurements to the system. To learn more about how it works, checkout Getting Started . If you are interested in what topics these cameras feed into, checkout ILLIXR plugins . Important Note : Before running any of these plugins below, it is important to comment out offline_cam and offline_imu in configs\\native.yaml .","title":"Using Cameras with ILLIXR"},{"location":"using_cameras/#add-calibration-parameters","text":"In order to add your camera's calibration extrinsics, you need to modify your choice of SLAM/VIO plugin. Follow these instructions to modify a plugin . OpenVINS : Navigate to ov_msckf/src . Uncomment this line out in slam2.cpp in order to use ZED's calibration parameter for OpenVins. You can add your own calibration parameters in the same file.","title":"Add Calibration Parameters"},{"location":"using_cameras/#zed-mini","text":"Install ZED SDK Install the latest version of the ZED SDK on stereolabs.com . For more information, checkout the ZED API documentation . Get ZED's calibration parameters Both OpenVINS have a decent calibration parameters for ZED. But if you wish to add your own: /usr/local/zed/tools/ZED_Calibration Your original factory calibration file is stored here /usr/local/zed/settings/ Or download it from calib.stereolabs.com . Enable ZED in OpenVINS plugin This step is only required if using OpenVINS. Uncomment this line in the OpenVINS plugin. Run ILLIXR with ZED: Uncomment zed in configs/rt_slam_plugins.yaml and run ILLIXR normally.","title":"ZED Mini"},{"location":"using_cameras/#intel-realsense","text":"ILLIXR has been tested with Inteal RealSense D455, but it should work with any D or T series RealSense Camera. Install librealsense (if you haven't already): Instruction on how to install can be found here . Get RealSense calibration parameters: Navigate to enumerate-devices ./PATH/TO/LIBREALSENSE/build/tools/enumerate-devices Run this command to obtain the calibration parameters ./rs-enumerate-devices -c Run ILLIXR with RealSense: Uncomment realsense in configs/rt_slam_plugins.yaml and run ILLIXR normally. Note: We will release the corresponding #define realsense soon for OpenVINS + Realsense","title":"Intel Realsense"},{"location":"virtualization/","text":"Setting up ILLIXR in QEMU Install QEMU See the Install dependencies section for details on installing QEMU. Setup Ubuntu in the VM Run ILLIXR/qemu/qemu.sh to download Ubuntu 22.04 , create a virtual hard drive ( illixr.qcow2 ), and launch qemu . Your VM image will be created at ILLIXR/qemu/illixr.qcow2 . Ubuntu will be downloaded and saved at ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso . You will be prompted to install Ubuntu; follow the instructions and install Ubuntu to the virtual hard drive. Choose the \"erase all\" option and confirm: Pick any account name and password you like. Once Ubuntu is installed you will be asked to reboot. Close qemu and then run ILLIXR/qemu/qeum.sh again to boot into your brand-new Ubuntu install! Booting the VM To launch the VM from now on, just use ILLIXR/qemu/qemu.sh . This will boot from the Ubuntu image we created earlier ( illixr.qcow2 ). Once Ubuntu is installed, it is safe to delete ubuntu-22.04.2-desktop-amd64.iso . Setting up the VM Once inside the VM, set up and run ILLIXR as found on the Getting Started page . Uninstalling To delete your local VM, just delete ILLIXR/qemu/illixr.qcow2 . ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso can be deleted anytime you want after Ubuntu is installed to your VM. If you've deleted illixr.qcow2 , you can run ILLIXR/qemu/qemu.sh to recreate it and reinstall everything.","title":"ILLIXR Under Virtualization"},{"location":"virtualization/#setting-up-illixr-in-qemu","text":"","title":"Setting up ILLIXR in QEMU"},{"location":"virtualization/#install-qemu","text":"See the Install dependencies section for details on installing QEMU.","title":"Install QEMU"},{"location":"virtualization/#setup-ubuntu-in-the-vm","text":"Run ILLIXR/qemu/qemu.sh to download Ubuntu 22.04 , create a virtual hard drive ( illixr.qcow2 ), and launch qemu . Your VM image will be created at ILLIXR/qemu/illixr.qcow2 . Ubuntu will be downloaded and saved at ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso . You will be prompted to install Ubuntu; follow the instructions and install Ubuntu to the virtual hard drive. Choose the \"erase all\" option and confirm: Pick any account name and password you like. Once Ubuntu is installed you will be asked to reboot. Close qemu and then run ILLIXR/qemu/qeum.sh again to boot into your brand-new Ubuntu install!","title":"Setup Ubuntu in the VM"},{"location":"virtualization/#booting-the-vm","text":"To launch the VM from now on, just use ILLIXR/qemu/qemu.sh . This will boot from the Ubuntu image we created earlier ( illixr.qcow2 ). Once Ubuntu is installed, it is safe to delete ubuntu-22.04.2-desktop-amd64.iso .","title":"Booting the VM"},{"location":"virtualization/#setting-up-the-vm","text":"Once inside the VM, set up and run ILLIXR as found on the Getting Started page .","title":"Setting up the VM"},{"location":"virtualization/#uninstalling","text":"To delete your local VM, just delete ILLIXR/qemu/illixr.qcow2 . ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso can be deleted anytime you want after Ubuntu is installed to your VM. If you've deleted illixr.qcow2 , you can run ILLIXR/qemu/qemu.sh to recreate it and reinstall everything.","title":"Uninstalling"},{"location":"writing_your_plugin/","text":"Writing Your Plugin Adding a New Plugin To add a new plugin create a new subdirectory in the plugins directory named for your plugin (no spaces) put your code in this new subdirectory (additional subdirectories containing parts of your code are allowed) create a CMakeLists.txt file in this new subdirectory. See the template below add the plugin to the profiles/plugins.yaml file, the name must match the subdirectory you created; it should go in the internal_plugins entry For the examples below is for a plugin called tracker, so just replace any instance of tracker with the name of your plugin. Simple Example 1 set(TRACKER_SOURCES plugin.cpp 2 src/tracker.cpp 3 src/tracker.hpp) 4 5 set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX}) 6 7 add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES}) 8 9 target_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include) 10 11 target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17) 12 13 install(TARGETS ${PLUGIN_NAME} DESTINATION lib) Line # Notes 1-3 Specify the source code files individually, we discourage using GLOB or GLOB_RECURSE to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Tell the system we are building a shared library with the name PLUGIN_NAME from the specified source files. 9 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include ILLIXR_SOURCE_DIR/include in this, as this is where plugin.hpp and other ILLIXR common headers are. 11 Any compile options specific to this plugin. Usually this will be left as is. 13 Add the install directive. This should not need to change. More Complex Example In this example the plugin has external dependencies provided by OS repos, specifically glfw3, x11, glew, glu, opencv, and eigen3. 1 set(TRACKER_SOURCES plugin.cpp 2 src/tracker.cpp 3 src/tracker.hpp) 4 5 set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX}) 6 7 find_package(glfw3 REQUIRED) 8 9 add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES}) 10 11 if(BUILD_OPENCV) 12 add_dependencies(${PLUGIN_NAME} OpenCV_Viz) 13 endif() 14 15 target_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS}) 16 target_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} dl pthread) 17 target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17) 18 19 install(TARGETS ${PLUGIN_NAME} DESTINATION lib) Line# Notes 1-3 Specify the source code files individually, we discourage using GLOB or GLOB_RECURSE to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the find_package directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. find_package assumes that there is an appropriate .cmake config file for the dependency on your system. If not the pkg_check_module function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name PLUGIN_NAME from the specified source files. 11-13 OpenCV is a special case for a dependency. If your plugin requires OpenCV add these lines to your CMakeLists.txt file and do not use find_package(OpenCV) . 15 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include ILLIXR _SOURCE_DIR in this, as this is where plugin.hpp and other ILLIXR common headers are. 16 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 17 Any compile options specific to this plugin. Usually this will be left as is. 19 Add the install directive. This should not need to change. Note: Not all the dependencies were searched for by find_package in this example. This is because there is a set of dependencies which are very common to many plugins and their find_package calls are in the main ILLIXR CMakeLists.txt file and do not need to be searched for again. These packages are Glew Glu SQLite3 X11 Eigen3 Very Complex Example In this example the plugin has dependencies provided by OS repos, and a third party dependency provided by a git repo. 1 set(TRACKER_SOURCES plugin.cpp 2 src/tracker.cpp 3 src/tracker.hpp) 4 5 set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX}) 6 7 find_package(glfw3 REQUIRED) 8 9 add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES}) 10 11 get_external(Plotter) 12 13 add_dependencies(${PLUGIN_NAME} Plotter) 14 15 if(BUILD_OPENCV) 16 add_dependencies(${PLUGIN_NAME} OpenCV_Viz) 17 endif() 18 19 target_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS} ${Plotter_INCLUDE_DIRS}) 20 target_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} ${Plotter_LIBRARIES} dl pthread) 21 target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17) 22 23 install(TARGETS ${PLUGIN_NAME} DESTINATION lib) Line# Notes 1-3 Specify the source code files individually, we discourage using GLOB or GLOB_RECURSE to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the find_package directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. find_package assumes that there is an appropriate .cmake config file for the dependency on your system. If not the pkg_check_module function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name PLUGIN_NAME from the specified source files. 11 Get the external project called Plotter. 13 Add the external package as a build dependency, this ensures that this plugin won't be built until after the dependency is. 15-17 OpenCV is a special case for a dependency. If your plugin requires OpenCV add these lines to your CMakeLists.txt file and do not use find_package(OpenCV) . 19 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include ILLIXR _SOURCE_DIR in this, as this is where plugin.hpp and other ILLIXR common headers are. 20 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 21 Any compile options specific to this plugin. Usually this will be left as is. 23 Add the install directive. This should not need to change. Additionally, to build and install the Plotter dependency you will need to create a cmake file in the cmake directory named GetPlotter.cmake (case matters, it must match the call to get_external ) with the following content. 1 find_package(Plotter QUIET) 2 3 if(Plotter_FOUND) 4 set(Plotter_VERSION \"${Plotter_VERSION_MAJOR}\") 5 else() 6 EXTERNALPROJECT_ADD(Plotter 7 GIT_REPOSITORY https://github.com/mygit/Plotter.git 8 GIT_TAG 4ff860838726a5e8ac0cbe59128c58a8f6143c6c 9 PREFIX ${CMAKE_BINARY_DIR}/_deps/plotter 10 CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=Release 11 ) 12 set(Plotter_EXTERNAL Yes) 13 set(Plotter_INCLUDE_DIRS ${CMAKE_INSTALL_PREFIX}/include) 14 set(Plotter_LIBRARIES plotter;alt_plotter) 15endif() Line # Notes 1 See if the package has been previously installed, quietly fail if not. 4 If it was found, just record the installed version for reporting. 6-11 Add the Plotter package as a project called Plotter (also case sensitive) 7 The git repo where the Plotter package is located. 8 The git tag to use (can be a tag name or sha5 from a commit). 9 The build directory for the package. 10 Any camke arguments to pass to the Plotter build. The ones specified here are required, but any others can be added. 12 Denote that this is an external package (this is used for internal tracking). 13 Set where the Plotter include files will land. Usually this will not need to change. 14 Set which libraries are built by the Plotter package. In this example libplotter.so and libalt_plotter.so are being built. External Plugins For plugins that are external packages (e.g. Audio_Pipeline) you need only create a GetX.cmake file as above and add the plugin name to the external_plugins list in profiles/plugins.yaml . External plugins with external dependencies are a bit more work, but are straight forward. See how Audio Pipeline is handled. Tutorial You can extend ILLIXR for your own purposes. To add your own functionality via the plugin interface: Create a new directory for your plugin in one of these ways in the plugins directory of the main ILLIXR tree, then follow these instructions anywhere for your new plugin so it can be pushed as a git repository, the follow these instructions focussing on external plugins You must decide if your plugin should inherit the standardized threadloop or plugin . If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . Your code goes in _p_one_iteration , which gets called in a hot loop. threadloop inherits from plugin, but adds threading functionality. If you don't use _p_one_iteration , inheriting from threadloop is superfluous; Inherit from plugin directly instead. If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Your code goes in the start method. If you want to schedule data-driven work in either case, call sb->schedule(...) . If you spin your own threads, they must wait for pb->lookup_impl<Stoplight>()->wait_for_ready() the first time they run. This allows the start of all threads in ILLIXR to be synchronized. They must be joined-or-disowned at-or-before plugin::stop() . This allows ILLIXR to shutdown cleanly. Write a file called plugin.cpp with this body, replacing every instance of plugin_name : /// A minimal/no-op ILLIXR plugin #include \"illixr/phonebook.hpp\" #include \"illixr/plugin.hpp\" #include \"illixr/threadloop.hpp\" #include <chrono> #include <thread> using namespace ILLIXR; /// Inherit from plugin if you don't need the threadloop /// Inherit from threadloop to provide a new thread to perform the task class basic_plugin : public threadloop { public: basic_plugin(std::string name_, phonebook* pb_) : threadloop{name_, pb_} { std::cout << \"Constructing basic_plugin.\" << std::endl; } /// Note the virtual. virtual ~basic_plugin() override { std::cout << \"Deconstructing basic_plugin.\" << std::endl; } /// For `threadloop` style plugins, do not override the start() method unless you know what you're doing! /// _p_one_iteration() is called in a thread created by threadloop::start() void _p_one_iteration() override { std::cout << \"This goes to the log when `log` is set in the config.\" << std::endl; std::cerr << \"This goes to the console.\" << std::endl; std::this_thread::sleep_for(std::chrono::milliseconds{100}); } }; /// This line makes the plugin importable by Spindle PLUGIN_MAIN(basic_plugin); At this point, you should be able to build your plugin with ILLIXR using -DUSE =ON as a command line argument to cmake. See Getting Started for more details. Finally, run ILLIXR with your new plugin following the instructions in Getting Started : This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard is optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"illixr/phonebook.hpp\" #include \"illixr/plugin.hpp\" #include \"illixr/threadloop.hpp\" /* When datatypes have to be common across plugins * (e.g. a phonebook service or switchboard topic), * they are defined in this header, * which is accessible to all plugins. */ #include \"common/data_format.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. * We use uniform initialization (curly-braces) [1] instead of parens to * avoid ambiguity [2]. * We put the comma at the start of the line, so that lines can be copied around * or deleted freely (except for the first). * * [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization * [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(std::string name_, phonebook* pb_) : threadloop{name_, pb_} /// Find the switchboard in phonebook , sb{pb->lookup_impl<switchboard>()} /// Create a handle to a topic in switchboard for subscribing , topic1{sb->get_reader<topic1_type>(\"topic1\")} /// Create a handle to a topic in switchboard for publishing , topic2{sb->get_writer<topic2_type>(\"topic2\")} { /// Read topic 1 switchboard::ptr<const topic1_type> event1 = topic1.get_ro(); /// Write to topic 2 topic2.put( topic2.allocate<topic2_type>( arg_1, // topic2_type::topic2_type() arg_type_1 ..., // ... arg_k // topic2_type::topic2_type() arg_type_k ) ); /// Read topic 3 synchronously sb->schedule<topic3_type>( get_name(), \"topic3\", [&](switchboard::ptr<const topic3_type> event3, std::size_t) { /* This is a [lambda expression][1] * * [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; callback(event3); } ); } virtual void _p_one_iteration override() { std::cout << \"Running\" << std::endl; auto target = std::chrono::system_clock::now() + std::chrono::milliseconds{10}; reliable_sleep(target); } private: const std::shared_ptr<switchboard> sb; switchboard::reader<topic1_type> topic1; switchboard::writer<topic2> topic2; }; /// This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name);","title":"Writing Your Plugin"},{"location":"writing_your_plugin/#writing-your-plugin","text":"","title":"Writing Your Plugin"},{"location":"writing_your_plugin/#adding-a-new-plugin","text":"To add a new plugin create a new subdirectory in the plugins directory named for your plugin (no spaces) put your code in this new subdirectory (additional subdirectories containing parts of your code are allowed) create a CMakeLists.txt file in this new subdirectory. See the template below add the plugin to the profiles/plugins.yaml file, the name must match the subdirectory you created; it should go in the internal_plugins entry For the examples below is for a plugin called tracker, so just replace any instance of tracker with the name of your plugin.","title":"Adding a New Plugin"},{"location":"writing_your_plugin/#simple-example","text":"1 set(TRACKER_SOURCES plugin.cpp 2 src/tracker.cpp 3 src/tracker.hpp) 4 5 set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX}) 6 7 add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES}) 8 9 target_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include) 10 11 target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17) 12 13 install(TARGETS ${PLUGIN_NAME} DESTINATION lib) Line # Notes 1-3 Specify the source code files individually, we discourage using GLOB or GLOB_RECURSE to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Tell the system we are building a shared library with the name PLUGIN_NAME from the specified source files. 9 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include ILLIXR_SOURCE_DIR/include in this, as this is where plugin.hpp and other ILLIXR common headers are. 11 Any compile options specific to this plugin. Usually this will be left as is. 13 Add the install directive. This should not need to change.","title":"Simple Example"},{"location":"writing_your_plugin/#more-complex-example","text":"In this example the plugin has external dependencies provided by OS repos, specifically glfw3, x11, glew, glu, opencv, and eigen3. 1 set(TRACKER_SOURCES plugin.cpp 2 src/tracker.cpp 3 src/tracker.hpp) 4 5 set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX}) 6 7 find_package(glfw3 REQUIRED) 8 9 add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES}) 10 11 if(BUILD_OPENCV) 12 add_dependencies(${PLUGIN_NAME} OpenCV_Viz) 13 endif() 14 15 target_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS}) 16 target_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} dl pthread) 17 target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17) 18 19 install(TARGETS ${PLUGIN_NAME} DESTINATION lib) Line# Notes 1-3 Specify the source code files individually, we discourage using GLOB or GLOB_RECURSE to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the find_package directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. find_package assumes that there is an appropriate .cmake config file for the dependency on your system. If not the pkg_check_module function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name PLUGIN_NAME from the specified source files. 11-13 OpenCV is a special case for a dependency. If your plugin requires OpenCV add these lines to your CMakeLists.txt file and do not use find_package(OpenCV) . 15 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include ILLIXR _SOURCE_DIR in this, as this is where plugin.hpp and other ILLIXR common headers are. 16 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 17 Any compile options specific to this plugin. Usually this will be left as is. 19 Add the install directive. This should not need to change. Note: Not all the dependencies were searched for by find_package in this example. This is because there is a set of dependencies which are very common to many plugins and their find_package calls are in the main ILLIXR CMakeLists.txt file and do not need to be searched for again. These packages are Glew Glu SQLite3 X11 Eigen3","title":"More Complex Example"},{"location":"writing_your_plugin/#very-complex-example","text":"In this example the plugin has dependencies provided by OS repos, and a third party dependency provided by a git repo. 1 set(TRACKER_SOURCES plugin.cpp 2 src/tracker.cpp 3 src/tracker.hpp) 4 5 set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX}) 6 7 find_package(glfw3 REQUIRED) 8 9 add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES}) 10 11 get_external(Plotter) 12 13 add_dependencies(${PLUGIN_NAME} Plotter) 14 15 if(BUILD_OPENCV) 16 add_dependencies(${PLUGIN_NAME} OpenCV_Viz) 17 endif() 18 19 target_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS} ${Plotter_INCLUDE_DIRS}) 20 target_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} ${Plotter_LIBRARIES} dl pthread) 21 target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17) 22 23 install(TARGETS ${PLUGIN_NAME} DESTINATION lib) Line# Notes 1-3 Specify the source code files individually, we discourage using GLOB or GLOB_RECURSE to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the find_package directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. find_package assumes that there is an appropriate .cmake config file for the dependency on your system. If not the pkg_check_module function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name PLUGIN_NAME from the specified source files. 11 Get the external project called Plotter. 13 Add the external package as a build dependency, this ensures that this plugin won't be built until after the dependency is. 15-17 OpenCV is a special case for a dependency. If your plugin requires OpenCV add these lines to your CMakeLists.txt file and do not use find_package(OpenCV) . 19 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include ILLIXR _SOURCE_DIR in this, as this is where plugin.hpp and other ILLIXR common headers are. 20 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 21 Any compile options specific to this plugin. Usually this will be left as is. 23 Add the install directive. This should not need to change. Additionally, to build and install the Plotter dependency you will need to create a cmake file in the cmake directory named GetPlotter.cmake (case matters, it must match the call to get_external ) with the following content. 1 find_package(Plotter QUIET) 2 3 if(Plotter_FOUND) 4 set(Plotter_VERSION \"${Plotter_VERSION_MAJOR}\") 5 else() 6 EXTERNALPROJECT_ADD(Plotter 7 GIT_REPOSITORY https://github.com/mygit/Plotter.git 8 GIT_TAG 4ff860838726a5e8ac0cbe59128c58a8f6143c6c 9 PREFIX ${CMAKE_BINARY_DIR}/_deps/plotter 10 CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=Release 11 ) 12 set(Plotter_EXTERNAL Yes) 13 set(Plotter_INCLUDE_DIRS ${CMAKE_INSTALL_PREFIX}/include) 14 set(Plotter_LIBRARIES plotter;alt_plotter) 15endif() Line # Notes 1 See if the package has been previously installed, quietly fail if not. 4 If it was found, just record the installed version for reporting. 6-11 Add the Plotter package as a project called Plotter (also case sensitive) 7 The git repo where the Plotter package is located. 8 The git tag to use (can be a tag name or sha5 from a commit). 9 The build directory for the package. 10 Any camke arguments to pass to the Plotter build. The ones specified here are required, but any others can be added. 12 Denote that this is an external package (this is used for internal tracking). 13 Set where the Plotter include files will land. Usually this will not need to change. 14 Set which libraries are built by the Plotter package. In this example libplotter.so and libalt_plotter.so are being built.","title":"Very Complex Example"},{"location":"writing_your_plugin/#external-plugins","text":"For plugins that are external packages (e.g. Audio_Pipeline) you need only create a GetX.cmake file as above and add the plugin name to the external_plugins list in profiles/plugins.yaml . External plugins with external dependencies are a bit more work, but are straight forward. See how Audio Pipeline is handled.","title":"External Plugins"},{"location":"writing_your_plugin/#tutorial","text":"You can extend ILLIXR for your own purposes. To add your own functionality via the plugin interface: Create a new directory for your plugin in one of these ways in the plugins directory of the main ILLIXR tree, then follow these instructions anywhere for your new plugin so it can be pushed as a git repository, the follow these instructions focussing on external plugins You must decide if your plugin should inherit the standardized threadloop or plugin . If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . Your code goes in _p_one_iteration , which gets called in a hot loop. threadloop inherits from plugin, but adds threading functionality. If you don't use _p_one_iteration , inheriting from threadloop is superfluous; Inherit from plugin directly instead. If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Your code goes in the start method. If you want to schedule data-driven work in either case, call sb->schedule(...) . If you spin your own threads, they must wait for pb->lookup_impl<Stoplight>()->wait_for_ready() the first time they run. This allows the start of all threads in ILLIXR to be synchronized. They must be joined-or-disowned at-or-before plugin::stop() . This allows ILLIXR to shutdown cleanly. Write a file called plugin.cpp with this body, replacing every instance of plugin_name : /// A minimal/no-op ILLIXR plugin #include \"illixr/phonebook.hpp\" #include \"illixr/plugin.hpp\" #include \"illixr/threadloop.hpp\" #include <chrono> #include <thread> using namespace ILLIXR; /// Inherit from plugin if you don't need the threadloop /// Inherit from threadloop to provide a new thread to perform the task class basic_plugin : public threadloop { public: basic_plugin(std::string name_, phonebook* pb_) : threadloop{name_, pb_} { std::cout << \"Constructing basic_plugin.\" << std::endl; } /// Note the virtual. virtual ~basic_plugin() override { std::cout << \"Deconstructing basic_plugin.\" << std::endl; } /// For `threadloop` style plugins, do not override the start() method unless you know what you're doing! /// _p_one_iteration() is called in a thread created by threadloop::start() void _p_one_iteration() override { std::cout << \"This goes to the log when `log` is set in the config.\" << std::endl; std::cerr << \"This goes to the console.\" << std::endl; std::this_thread::sleep_for(std::chrono::milliseconds{100}); } }; /// This line makes the plugin importable by Spindle PLUGIN_MAIN(basic_plugin); At this point, you should be able to build your plugin with ILLIXR using -DUSE =ON as a command line argument to cmake. See Getting Started for more details. Finally, run ILLIXR with your new plugin following the instructions in Getting Started : This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard is optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"illixr/phonebook.hpp\" #include \"illixr/plugin.hpp\" #include \"illixr/threadloop.hpp\" /* When datatypes have to be common across plugins * (e.g. a phonebook service or switchboard topic), * they are defined in this header, * which is accessible to all plugins. */ #include \"common/data_format.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. * We use uniform initialization (curly-braces) [1] instead of parens to * avoid ambiguity [2]. * We put the comma at the start of the line, so that lines can be copied around * or deleted freely (except for the first). * * [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization * [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(std::string name_, phonebook* pb_) : threadloop{name_, pb_} /// Find the switchboard in phonebook , sb{pb->lookup_impl<switchboard>()} /// Create a handle to a topic in switchboard for subscribing , topic1{sb->get_reader<topic1_type>(\"topic1\")} /// Create a handle to a topic in switchboard for publishing , topic2{sb->get_writer<topic2_type>(\"topic2\")} { /// Read topic 1 switchboard::ptr<const topic1_type> event1 = topic1.get_ro(); /// Write to topic 2 topic2.put( topic2.allocate<topic2_type>( arg_1, // topic2_type::topic2_type() arg_type_1 ..., // ... arg_k // topic2_type::topic2_type() arg_type_k ) ); /// Read topic 3 synchronously sb->schedule<topic3_type>( get_name(), \"topic3\", [&](switchboard::ptr<const topic3_type> event3, std::size_t) { /* This is a [lambda expression][1] * * [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; callback(event3); } ); } virtual void _p_one_iteration override() { std::cout << \"Running\" << std::endl; auto target = std::chrono::system_clock::now() + std::chrono::milliseconds{10}; reliable_sleep(target); } private: const std::shared_ptr<switchboard> sb; switchboard::reader<topic1_type> topic1; switchboard::writer<topic2> topic2; }; /// This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name);","title":"Tutorial"},{"location":"plugin_README/README_debugview/","text":"debugview Summary debugview is a simple debugging view for the ILLIXR system. By subscribing to several Switchboard endpoints, many important datapoints can be observed to help debug issues with the runtime. The debug view shows the current calculated SLAM pose and the (optional) ground truth pose read from the ground truth dataset as 3D headset models drawn on a backdrop scene. In addition, camera and IMU data is also visible, with the stereoscopic onboard camera views shown in one of the windows. Various offsets can be applied to the generated poses to aid in viewing. Dear ImGUI is used for displaying data and providing an interactive interface. Switchboard connection debugview subscribes to the slow-pose, which represents the latest pose published by the SLAM/IMU system. In the future, debugview will also query for the most up-to-date predicted pose through an RPC-like query system. This is not currently in our release version; but is in development and will be added soon. The \"fast pose\" referenced in this plugin just samples the slow_pose instead. debugview also is synchronously dependent on the imu_cam topic, as the stereoscopic camera views are displayed in the debug window. In ILLIXR, \"synchronous dependencies\" are implemented as scheduled \"handlers\" that are executed from a shared thread pool; this handler is executed every time a fresh \"packet\" is available from the imu_cam topic. Given that this is a separate thread from the main graphics thread, this imu_cam packet must be saved/cached for later, when the grahpics thread renders the next frame. This is a good example to follow when writing your own multithreaded components that use both synchronous and asynchronous dependencies, and need to share information across dependency boundaries. Notes debugview will be under heavy development in the near-term. Pull requests may or may not be accepted, due to the frequency of rapid internal changes. Known Issues Currently, the poses returned from the SLAM system have an incorrect initial rotation, as the poses are returned in an incorrect frame of reference. Thus, the headsets may appear to be tilted incorrectly; the button \"calculate new orientation offset\" will reset the orientation, such that the current orientation is considered the \"neutral\" orientation. In a future update, the correct frame of reference/transform matrix will be applied and the pose will accurately reflect the actual head position. Contributions Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.","title":"Debugview"},{"location":"plugin_README/README_debugview/#debugview","text":"","title":"debugview"},{"location":"plugin_README/README_debugview/#summary","text":"debugview is a simple debugging view for the ILLIXR system. By subscribing to several Switchboard endpoints, many important datapoints can be observed to help debug issues with the runtime. The debug view shows the current calculated SLAM pose and the (optional) ground truth pose read from the ground truth dataset as 3D headset models drawn on a backdrop scene. In addition, camera and IMU data is also visible, with the stereoscopic onboard camera views shown in one of the windows. Various offsets can be applied to the generated poses to aid in viewing. Dear ImGUI is used for displaying data and providing an interactive interface.","title":"Summary"},{"location":"plugin_README/README_debugview/#switchboard-connection","text":"debugview subscribes to the slow-pose, which represents the latest pose published by the SLAM/IMU system. In the future, debugview will also query for the most up-to-date predicted pose through an RPC-like query system. This is not currently in our release version; but is in development and will be added soon. The \"fast pose\" referenced in this plugin just samples the slow_pose instead. debugview also is synchronously dependent on the imu_cam topic, as the stereoscopic camera views are displayed in the debug window. In ILLIXR, \"synchronous dependencies\" are implemented as scheduled \"handlers\" that are executed from a shared thread pool; this handler is executed every time a fresh \"packet\" is available from the imu_cam topic. Given that this is a separate thread from the main graphics thread, this imu_cam packet must be saved/cached for later, when the grahpics thread renders the next frame. This is a good example to follow when writing your own multithreaded components that use both synchronous and asynchronous dependencies, and need to share information across dependency boundaries.","title":"Switchboard connection"},{"location":"plugin_README/README_debugview/#notes","text":"debugview will be under heavy development in the near-term. Pull requests may or may not be accepted, due to the frequency of rapid internal changes.","title":"Notes"},{"location":"plugin_README/README_debugview/#known-issues","text":"Currently, the poses returned from the SLAM system have an incorrect initial rotation, as the poses are returned in an incorrect frame of reference. Thus, the headsets may appear to be tilted incorrectly; the button \"calculate new orientation offset\" will reset the orientation, such that the current orientation is considered the \"neutral\" orientation. In a future update, the correct frame of reference/transform matrix will be applied and the pose will accurately reflect the actual head position.","title":"Known Issues"},{"location":"plugin_README/README_debugview/#contributions","text":"Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.","title":"Contributions"},{"location":"plugin_README/README_display_vk/","text":"display_vk Summary display_vk implements the service interface display_sink , which sets up a windowing backend (using GLFW in this case), initializes Vulkan, and creates a swapchain. If available, Vulkan validation layers are enabled. This plugin is only required when running the native target. For Monado, the display_sink service is provided by the Monado compositor.","title":"Display_VK"},{"location":"plugin_README/README_display_vk/#display_vk","text":"","title":"display_vk"},{"location":"plugin_README/README_display_vk/#summary","text":"display_vk implements the service interface display_sink , which sets up a windowing backend (using GLFW in this case), initializes Vulkan, and creates a swapchain. If available, Vulkan validation layers are enabled. This plugin is only required when running the native target. For Monado, the display_sink service is provided by the Monado compositor.","title":"Summary"},{"location":"plugin_README/README_fauxpose/","text":"FauxPose ILLIXR plugin Summary The FauxPose ILLIXR plugin generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking. The movement is hard-coded to be on the Y=center.y plane, with the X and Z values set to rotate in a circle. The period and amplitude of the movement are have default values (0.5, and 2.0 respectively) that can be changed through environment variables. Topic details: - *Publishes* `pose_position` on `fast_pose` topic. Usage The \"FauxPose\" plugin must be included in the YAML configuration file prior to any rendering plugin (such as \"debugview\" or \"gldemo\"). Also no other pose-generating plugin should be included. (In the standard configuration this requires removing the \"rt_slam_plugins\" -- usually by commenting out the line: #- !include \"rt_slam_plugins.yaml\" And then adding FauxPose as a plugin: - path: fauxpose/ An example \"faux.yaml\" configuration file is included as an example. By default, the \"orbit\" of the tracked position will be about the point (0.0, 1.5, 0.0), with a default amplitude of \"2.0\", and period of \"0.5\" seconds, with the orientation facing the negative-X direction. The first three of these values can be overridden through environment variables: * FAUXPOSE_PERIOD= * FAUXPOSE_AMPLITUDE= * FAUXPOSE_CENTER=","title":"Fauxpose"},{"location":"plugin_README/README_fauxpose/#fauxpose-illixr-plugin","text":"","title":"FauxPose ILLIXR plugin"},{"location":"plugin_README/README_fauxpose/#summary","text":"The FauxPose ILLIXR plugin generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking. The movement is hard-coded to be on the Y=center.y plane, with the X and Z values set to rotate in a circle. The period and amplitude of the movement are have default values (0.5, and 2.0 respectively) that can be changed through environment variables. Topic details: - *Publishes* `pose_position` on `fast_pose` topic.","title":"Summary"},{"location":"plugin_README/README_fauxpose/#usage","text":"The \"FauxPose\" plugin must be included in the YAML configuration file prior to any rendering plugin (such as \"debugview\" or \"gldemo\"). Also no other pose-generating plugin should be included. (In the standard configuration this requires removing the \"rt_slam_plugins\" -- usually by commenting out the line: #- !include \"rt_slam_plugins.yaml\" And then adding FauxPose as a plugin: - path: fauxpose/ An example \"faux.yaml\" configuration file is included as an example. By default, the \"orbit\" of the tracked position will be about the point (0.0, 1.5, 0.0), with a default amplitude of \"2.0\", and period of \"0.5\" seconds, with the orientation facing the negative-X direction. The first three of these values can be overridden through environment variables: * FAUXPOSE_PERIOD= * FAUXPOSE_AMPLITUDE= * FAUXPOSE_CENTER=","title":"Usage"},{"location":"plugin_README/README_gldemo/","text":"gldemo Summary The gldemo plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. gldemo will subscribe to several Switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the debugview plugin) and publish the results to the Switchboard API. gldemo is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; gldemo fills this requirement. As an important note, gldemo does not render stereoscopically; the two eye renders are rendered from the same position. This may be updated to render stereoscopically in the future, but is not seen as a critical feature as this is generally intended as a debugging tool. Switchboard connection gldemo subscribes to and publishes to several Switchboard plugs. Most notably, gldemo subscribes to the fast_pose plug, which (ideally) represents the most recent extrapolated pose. This connection represents an area of active development in ILLIXR, as we are replacing the pose subscription with an RPC-like proper pose prediction system. As of the time of writing, fast_pose is functionally identical to the slow_pose published by the SLAM system, but this will change when proper pose extrapolation is implemented. gldemo also pulls the correct graphics context from Phonebook. gldemo publishes the rendered eyebuffers to the Switchboard system as well, using whichever eyebuffer format has been selected with the USE_ALT_EYE_FORMAT compile-time macro. The alternative eye format is more similar to the format used by Monado/OpenXR, and is more fully explained by the code comments. Notes gldemo does not pretend to be an OpenXR application; it does not use the OpenXR API, nor does it follow typical OpenXR patterns. It hooks directly into the Switchboard system and is intended as a debug/visualization tool. For more accurate and representative testing, consider running ILLIXR with an actual OpenXR application. Known Issues As noted above, gldemo does not actually render stereoscopically, and the two eye buffers are rendered from the same eye location. (This is not to say that the two eye buffers are not rendered separately; they are actually two separate drawcalls.) In addition, the quality of the pose used by gldemo is dependent on the upstream pose, which is currently not extrapolated/predicted and is subject to change. Contributions Contributions are welcome; please raise an issue first, though, as many issues are known and are a part of our existing internal backlog.","title":"Gldemo"},{"location":"plugin_README/README_gldemo/#gldemo","text":"","title":"gldemo"},{"location":"plugin_README/README_gldemo/#summary","text":"The gldemo plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. gldemo will subscribe to several Switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the debugview plugin) and publish the results to the Switchboard API. gldemo is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; gldemo fills this requirement. As an important note, gldemo does not render stereoscopically; the two eye renders are rendered from the same position. This may be updated to render stereoscopically in the future, but is not seen as a critical feature as this is generally intended as a debugging tool.","title":"Summary"},{"location":"plugin_README/README_gldemo/#switchboard-connection","text":"gldemo subscribes to and publishes to several Switchboard plugs. Most notably, gldemo subscribes to the fast_pose plug, which (ideally) represents the most recent extrapolated pose. This connection represents an area of active development in ILLIXR, as we are replacing the pose subscription with an RPC-like proper pose prediction system. As of the time of writing, fast_pose is functionally identical to the slow_pose published by the SLAM system, but this will change when proper pose extrapolation is implemented. gldemo also pulls the correct graphics context from Phonebook. gldemo publishes the rendered eyebuffers to the Switchboard system as well, using whichever eyebuffer format has been selected with the USE_ALT_EYE_FORMAT compile-time macro. The alternative eye format is more similar to the format used by Monado/OpenXR, and is more fully explained by the code comments.","title":"Switchboard connection"},{"location":"plugin_README/README_gldemo/#notes","text":"gldemo does not pretend to be an OpenXR application; it does not use the OpenXR API, nor does it follow typical OpenXR patterns. It hooks directly into the Switchboard system and is intended as a debug/visualization tool. For more accurate and representative testing, consider running ILLIXR with an actual OpenXR application.","title":"Notes"},{"location":"plugin_README/README_gldemo/#known-issues","text":"As noted above, gldemo does not actually render stereoscopically, and the two eye buffers are rendered from the same eye location. (This is not to say that the two eye buffers are not rendered separately; they are actually two separate drawcalls.) In addition, the quality of the pose used by gldemo is dependent on the upstream pose, which is currently not extrapolated/predicted and is subject to change.","title":"Known Issues"},{"location":"plugin_README/README_gldemo/#contributions","text":"Contributions are welcome; please raise an issue first, though, as many issues are known and are a part of our existing internal backlog.","title":"Contributions"},{"location":"plugin_README/README_native_renderer/","text":"native_renderer Summary native_renderer utilizes vkdemo and timewarp_vk to construct a full rendering pipeline. vkdemo is used to render the scene, and timewarp_vk is used to perform rotational reprojection. This plugin creates the necessary Vulkan resoruces and targets for vkdemo and timewarp_vk to render to, and then composites the results into a single image. The resulting image is presented using the Vulkan swapchain provided by display_vk .","title":"Native Renderer"},{"location":"plugin_README/README_native_renderer/#native_renderer","text":"","title":"native_renderer"},{"location":"plugin_README/README_native_renderer/#summary","text":"native_renderer utilizes vkdemo and timewarp_vk to construct a full rendering pipeline. vkdemo is used to render the scene, and timewarp_vk is used to perform rotational reprojection. This plugin creates the necessary Vulkan resoruces and targets for vkdemo and timewarp_vk to render to, and then composites the results into a single image. The resulting image is presented using the Vulkan swapchain provided by display_vk .","title":"Summary"},{"location":"plugin_README/README_openni/","text":"OpenNI Set Camera Mode If you wish to switch up the video modes of OpenNI, update these two macros in openni/plugin.cpp accordingly: #define RGB_MODE 0 #define DEPTH_MODE 0 You can see the list of available modes once you run ILLIXR the first time. Debugging Device open failed: DeviceOpen using default: no devices found Solution : No OpenNI compatible device is plugged in. So plug one in Device open failed: Could not open \"1d27/0601@3/2\": USB transfer timeout! Solution : This is usually fixed by unplug and plug back in. Device open failed: Could not open \"1d27/0601@3/2\": Failed to open the USB device! Solution : Fix by running with sudo","title":"OpenNI"},{"location":"plugin_README/README_openni/#openni","text":"","title":"OpenNI"},{"location":"plugin_README/README_openni/#set-camera-mode","text":"If you wish to switch up the video modes of OpenNI, update these two macros in openni/plugin.cpp accordingly: #define RGB_MODE 0 #define DEPTH_MODE 0 You can see the list of available modes once you run ILLIXR the first time.","title":"Set Camera Mode"},{"location":"plugin_README/README_openni/#debugging","text":"Device open failed: DeviceOpen using default: no devices found Solution : No OpenNI compatible device is plugged in. So plug one in Device open failed: Could not open \"1d27/0601@3/2\": USB transfer timeout! Solution : This is usually fixed by unplug and plug back in. Device open failed: Could not open \"1d27/0601@3/2\": Failed to open the USB device! Solution : Fix by running with sudo","title":"Debugging"},{"location":"plugin_README/README_record_imu_cam/","text":"Record IMU Cam The purpose of this plugin is to record a dataset, similar to the EuRoC MAV dataset that includes the IMU data and Cam images. How to record a dataset In configs/rt_slam_plugins.yaml , uncomment this line: - path: record_imu_cam/ After recording, the dataset will be stored in the ILLIXR project directory, with the following structure: ILLIXR/data_record \\_ cam0/ \\_ data/ \\_ timestamp.png \\_ ... \\_ data.csv \\_ cam1/ \\_ data/ \\_ timestamp.png \\_ ... \\_ data.csv \\_ imu0 \\_ data.csv Format cam0/data.csv and cam1/data.csv are both formatted as timestamp [ns], timestamp.png imu0/data.csv is formatted as timestamp [ns],w_x [rad s^-1],w_y [rad s^-1],w_z [rad s^-1],a_x [m s^-2],a_y [m s^-2],a_z [m s^-2] How to rerun recorded dataset (IMPORTANT) In configs/rt_slam_plugins.yaml , comment this line: # - path: record_imu_cam/ In configs/native.yaml (or whatever mode you're running ILLIXR with), add the path of the recorded dataset like so: data: data_record # subpath: mav0 # relative_to: # archive_path: # download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip' Make sure to comment the default EuRoC dataset In runner/runner/main.py , head toward the function corresponding to the mode with which you want to run ILLIXR, and change the data_path line like so (if run natively, it is this line ): data_path = pathify(config[\"data\"], root_dir, root_dir / \"data_record\", True, True) Make sure other plugins that feed images and IMU are commented, such as offline_cam , offline_imu , zed , and realsense .","title":"Record_imu_cam"},{"location":"plugin_README/README_record_imu_cam/#record-imu-cam","text":"The purpose of this plugin is to record a dataset, similar to the EuRoC MAV dataset that includes the IMU data and Cam images.","title":"Record IMU Cam"},{"location":"plugin_README/README_record_imu_cam/#how-to-record-a-dataset","text":"In configs/rt_slam_plugins.yaml , uncomment this line: - path: record_imu_cam/ After recording, the dataset will be stored in the ILLIXR project directory, with the following structure: ILLIXR/data_record \\_ cam0/ \\_ data/ \\_ timestamp.png \\_ ... \\_ data.csv \\_ cam1/ \\_ data/ \\_ timestamp.png \\_ ... \\_ data.csv \\_ imu0 \\_ data.csv","title":"How to record a dataset"},{"location":"plugin_README/README_record_imu_cam/#format","text":"cam0/data.csv and cam1/data.csv are both formatted as timestamp [ns], timestamp.png imu0/data.csv is formatted as timestamp [ns],w_x [rad s^-1],w_y [rad s^-1],w_z [rad s^-1],a_x [m s^-2],a_y [m s^-2],a_z [m s^-2]","title":"Format"},{"location":"plugin_README/README_record_imu_cam/#how-to-rerun-recorded-dataset","text":"(IMPORTANT) In configs/rt_slam_plugins.yaml , comment this line: # - path: record_imu_cam/ In configs/native.yaml (or whatever mode you're running ILLIXR with), add the path of the recorded dataset like so: data: data_record # subpath: mav0 # relative_to: # archive_path: # download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip' Make sure to comment the default EuRoC dataset In runner/runner/main.py , head toward the function corresponding to the mode with which you want to run ILLIXR, and change the data_path line like so (if run natively, it is this line ): data_path = pathify(config[\"data\"], root_dir, root_dir / \"data_record\", True, True) Make sure other plugins that feed images and IMU are commented, such as offline_cam , offline_imu , zed , and realsense .","title":"How to rerun recorded dataset"},{"location":"plugin_README/README_timewarp_gl/","text":"timewarp_gl Summary timewarp_gl is an OpenGL-based asynchronous rotational reprojection plugin intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation). Switchboard connection timewarp_gl subscribes to and publishes to several Switchboard plugs and Phonebook resources. The plugin grabs the GL context from Phonebook. This is necessary to share the eyebuffers with the rendering application (or gldemo ). As this is an OpenGL-based reprojection plugin, it relies on OpenGL resources for the eyebuffers. timewarp_gl subscribes to the most recent pose published by the system. Currently, as our pose-prediction system is still under development, this is not technically accurate; the final, intended functionality is that the timewarp plugin will sample a pose prediction algorithm through an RPC-like mechanism. As we complete our work on our pose prediction system, this plugin will be modified to use this mechanism. timewarp_gl also subscribes to the most recent frame published by the system. This frame data also includes the pose that was used to render the frame; this is how the timewarp algorithm calcuates the \"diff\" to be used to reproject the frame. Notes The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here. Known Issues As noted above, this plugin currently samples slow_pose . This will be changed to sample a fast_pose topic through an RPC mechanism. In addition, JMP Van Waveren's algorithm includes a method for warping between two reprojection matrices based on the actual progress of the display controller's \"scanline\"; this is simply commented out in our code, but can be re-enabled when our pose prediction system comes online. Contributions Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.","title":"Timewarp_gl"},{"location":"plugin_README/README_timewarp_gl/#timewarp_gl","text":"","title":"timewarp_gl"},{"location":"plugin_README/README_timewarp_gl/#summary","text":"timewarp_gl is an OpenGL-based asynchronous rotational reprojection plugin intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).","title":"Summary"},{"location":"plugin_README/README_timewarp_gl/#switchboard-connection","text":"timewarp_gl subscribes to and publishes to several Switchboard plugs and Phonebook resources. The plugin grabs the GL context from Phonebook. This is necessary to share the eyebuffers with the rendering application (or gldemo ). As this is an OpenGL-based reprojection plugin, it relies on OpenGL resources for the eyebuffers. timewarp_gl subscribes to the most recent pose published by the system. Currently, as our pose-prediction system is still under development, this is not technically accurate; the final, intended functionality is that the timewarp plugin will sample a pose prediction algorithm through an RPC-like mechanism. As we complete our work on our pose prediction system, this plugin will be modified to use this mechanism. timewarp_gl also subscribes to the most recent frame published by the system. This frame data also includes the pose that was used to render the frame; this is how the timewarp algorithm calcuates the \"diff\" to be used to reproject the frame.","title":"Switchboard connection"},{"location":"plugin_README/README_timewarp_gl/#notes","text":"The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.","title":"Notes"},{"location":"plugin_README/README_timewarp_gl/#known-issues","text":"As noted above, this plugin currently samples slow_pose . This will be changed to sample a fast_pose topic through an RPC mechanism. In addition, JMP Van Waveren's algorithm includes a method for warping between two reprojection matrices based on the actual progress of the display controller's \"scanline\"; this is simply commented out in our code, but can be re-enabled when our pose prediction system comes online.","title":"Known Issues"},{"location":"plugin_README/README_timewarp_gl/#contributions","text":"Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.","title":"Contributions"},{"location":"plugin_README/README_timewarp_vk/","text":"timewarp_vk Summary timewarp_vk is an Vulkan-based rotational reprojection service intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation). Phonebook Service timewarp_vk is registered as a service in phonebook, conforming to the timewarp render pass interface. Three functions are exposed: setup(VkRenderPass render_pass, uint32_t subpass) initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which timewarp_vk binds to update_uniforms(const pose_type render_pose) calculates the reprojection matrix given the current pose and the pose used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before record_command_buffer is called record_command_buffer(VkCommandBuffer commandBuffer, int left) records the commands into a given command buffer that would perform the reprojection for one eye, for which 1 is left and 0 is right Notes The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.","title":"Timewarp_VK"},{"location":"plugin_README/README_timewarp_vk/#timewarp_vk","text":"","title":"timewarp_vk"},{"location":"plugin_README/README_timewarp_vk/#summary","text":"timewarp_vk is an Vulkan-based rotational reprojection service intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).","title":"Summary"},{"location":"plugin_README/README_timewarp_vk/#phonebook-service","text":"timewarp_vk is registered as a service in phonebook, conforming to the timewarp render pass interface. Three functions are exposed: setup(VkRenderPass render_pass, uint32_t subpass) initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which timewarp_vk binds to update_uniforms(const pose_type render_pose) calculates the reprojection matrix given the current pose and the pose used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before record_command_buffer is called record_command_buffer(VkCommandBuffer commandBuffer, int left) records the commands into a given command buffer that would perform the reprojection for one eye, for which 1 is left and 0 is right","title":"Phonebook Service"},{"location":"plugin_README/README_timewarp_vk/#notes","text":"The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.","title":"Notes"},{"location":"plugin_README/README_vkdemo/","text":"vkdemo Summary The vkdemo plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. vkdemo will subscribe to several Switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the debugview plugin) and publish the results to the Switchboard API. vkdemo is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; vkdemo fills this requirement. Phonebook Service vkdemo is registered as a service in phonebook, conforming to the app render pass interface. Three functions are exposed: * setup(VkRenderPass render_pass, uint32_t subpass) initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which vkdemo binds to * update_uniforms(const pose_type render_pose) updates the uniform buffer with the given pose, which is used to render the scene. This must be called before record_command_buffer is called. * record_command_buffer(VkCommandBuffer commandBuffer, int eye) records the commands into a given command buffer that would perform the rendering for one eye, for which 0 is left and 1 is right. To achieve stereoscopic rendering, the function is called twice, once for each eye. * virtual void destroy() cleans up the resources allocated by vkdemo . Currently, this part is not yet implemented.","title":"Vkdemo"},{"location":"plugin_README/README_vkdemo/#vkdemo","text":"","title":"vkdemo"},{"location":"plugin_README/README_vkdemo/#summary","text":"The vkdemo plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. vkdemo will subscribe to several Switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the debugview plugin) and publish the results to the Switchboard API. vkdemo is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; vkdemo fills this requirement.","title":"Summary"},{"location":"plugin_README/README_vkdemo/#phonebook-service","text":"vkdemo is registered as a service in phonebook, conforming to the app render pass interface. Three functions are exposed: * setup(VkRenderPass render_pass, uint32_t subpass) initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which vkdemo binds to * update_uniforms(const pose_type render_pose) updates the uniform buffer with the given pose, which is used to render the scene. This must be called before record_command_buffer is called. * record_command_buffer(VkCommandBuffer commandBuffer, int eye) records the commands into a given command buffer that would perform the rendering for one eye, for which 0 is left and 1 is right. To achieve stereoscopic rendering, the function is called twice, once for each eye. * virtual void destroy() cleans up the resources allocated by vkdemo . Currently, this part is not yet implemented.","title":"Phonebook Service"},{"location":"plugin_README/README_zed/","text":"ZED Mini Getting started First, download the latest version of the ZED SDK on stereolabs.com . For more information, read the ZED API documentation . Prerequisites Ubuntu 20.04 or 22.04 CUDA ZED SDK OpenCV 4","title":"Zed"},{"location":"plugin_README/README_zed/#zed-mini","text":"","title":"ZED Mini"},{"location":"plugin_README/README_zed/#getting-started","text":"First, download the latest version of the ZED SDK on stereolabs.com . For more information, read the ZED API documentation .","title":"Getting started"},{"location":"plugin_README/README_zed/#prerequisites","text":"Ubuntu 20.04 or 22.04 CUDA ZED SDK OpenCV 4","title":"Prerequisites"},{"location":"plugin_README/monado_illixr_runtime_overview/","text":"Monado Integration Overview ILLIXR's Plugins provide XR services, and the Runtime ties them together. However, we don't want to force developers to write their whole application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR , so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado , an existing, open-source implementation of the standard. When running ILLIXR without Monado, the ILLIXR runtime is the entry-point. Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app. When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a result, the ILLIXR runtime system is loaded at a later point as a shared library. This page documents the changes to the ILLIXR runtime when an OpenXR application is used. OpenXR Application Launch As specified by OpenXR , the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronos Group for more details. Monado Device Probe and ILLIXR Initialization During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as xdev s. Our ILLIXR driver will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The driver obtains the path to the ILLIXR runtime .so file and a list of plugins from environment variables. After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the ILLIXR driver. At this moment, all necessary data is ready and ILLIXR will be launched. ILLIXR Runtime Launch When used with Monado , the ILLIXR Runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing Switchboard and Phonebook , and loading Plugins . The driver starts to load the runtime by loading the shared library into the current (application's) address space and calls the Switchboard and Phonebook initialization. Then, it calls the plugin loading for each ILLIXR plugin (except gldemo , which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a Translation Plugin into ILLIXR as the application. If the plugin implements a long-running computation, it may block the main ILLIXR thread which drives the entire application. To remedy this, a plugin should implement long-running processing in its own thread. This way, the driver will be able to reacquire control and return to Monado and the application efficiently. Translation Plugin When the application and all ILLIXR plugins are up and running, the translation plugin handles the connection between Monado and ILLIXR. It might be confusing to see that this plugin is part of the ILLIXR driver which is part of Monado while at the same time also part of ILLIXR as a plugin. However, Monado and ILLIXR are running in different threads in the same address space. The translation plugin is the interface of these two parallel systems. The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, the translation plugin is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of ILLIXR, the translation plugin behaves the same as the gldemo application : reading pose and submitting frames. For implementation details regarding the representation of poses and frames in Monado and in ILLIXR, please see ILLIXR's Monado Integration Dataflow .","title":"Monado Overview"},{"location":"plugin_README/monado_illixr_runtime_overview/#monado-integration-overview","text":"ILLIXR's Plugins provide XR services, and the Runtime ties them together. However, we don't want to force developers to write their whole application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR , so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado , an existing, open-source implementation of the standard. When running ILLIXR without Monado, the ILLIXR runtime is the entry-point. Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app. When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a result, the ILLIXR runtime system is loaded at a later point as a shared library. This page documents the changes to the ILLIXR runtime when an OpenXR application is used.","title":"Monado Integration Overview"},{"location":"plugin_README/monado_illixr_runtime_overview/#openxr-application-launch","text":"As specified by OpenXR , the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronos Group for more details.","title":"OpenXR Application Launch"},{"location":"plugin_README/monado_illixr_runtime_overview/#monado-device-probe-and-illixr-initialization","text":"During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as xdev s. Our ILLIXR driver will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The driver obtains the path to the ILLIXR runtime .so file and a list of plugins from environment variables. After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the ILLIXR driver. At this moment, all necessary data is ready and ILLIXR will be launched.","title":"Monado Device Probe and ILLIXR Initialization"},{"location":"plugin_README/monado_illixr_runtime_overview/#illixr-runtime-launch","text":"When used with Monado , the ILLIXR Runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing Switchboard and Phonebook , and loading Plugins . The driver starts to load the runtime by loading the shared library into the current (application's) address space and calls the Switchboard and Phonebook initialization. Then, it calls the plugin loading for each ILLIXR plugin (except gldemo , which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a Translation Plugin into ILLIXR as the application. If the plugin implements a long-running computation, it may block the main ILLIXR thread which drives the entire application. To remedy this, a plugin should implement long-running processing in its own thread. This way, the driver will be able to reacquire control and return to Monado and the application efficiently.","title":"ILLIXR Runtime Launch"},{"location":"plugin_README/monado_illixr_runtime_overview/#translation-plugin","text":"When the application and all ILLIXR plugins are up and running, the translation plugin handles the connection between Monado and ILLIXR. It might be confusing to see that this plugin is part of the ILLIXR driver which is part of Monado while at the same time also part of ILLIXR as a plugin. However, Monado and ILLIXR are running in different threads in the same address space. The translation plugin is the interface of these two parallel systems. The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, the translation plugin is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of ILLIXR, the translation plugin behaves the same as the gldemo application : reading pose and submitting frames. For implementation details regarding the representation of poses and frames in Monado and in ILLIXR, please see ILLIXR's Monado Integration Dataflow .","title":"Translation Plugin"},{"location":"plugin_README/monado_integration_dataflow/","text":"Monado Integration Dataflow The dataflow for the ILLIXR Monado integration comprises two steps: 1. getting pose data from ILLIXR, and 1. sending a user rendered frame back to ILLIXR. In Monado, ILLIXR is recognized as an HMD for Monado, while in ILLIXR, Monado looks like a user application (such as gldemo ). After ILLIXR is initialized from Monado, and Monado is registered as a plugin for ILLIXR, the most recent pose information can be easily obtained via Switchboard . The compositor side of Monado integration with ILLIXR is implemented more subtly. The original Monado compositor primarily performs distortion correction and aberration correction in a Vulkan back-end compositor. The compositor also has two client compositors (one for OpenGL applications and another for Vulkan applications) which pass frame data to the back-end compositor. ILLIXR integration intercepts the frame at GL client compositor and sends it to Switchboard of ILLIXR, which is then used by timewarp_gl component . To get an OpenGL frame and use it without copying pixels, ILLIXR needs to get the user application GL context. This is done at OpenXR session creation time, where ILLIXR is initialized. Note that, logically, ILLIXR is initialized during OpenXR instance creation, or is otherwise running in the background all the time. Currently, ILLIXR is initialized at session creation time, since ILLIXR only supports single OpenXR session, and requires a user application GL context upon initialization, The current ILLIXR integration for Monado is a temporary solution and has some drawbacks caused by the concurrent and continued development from both the Monado and ILLIXR projects. The integration: Does not use the pose that user application declares to use at rendering (using the OpenXR specification). This is due to incongruencies with Monado's internal interfaces and representations. The pose difference used by timewarp is computed using the most recent query for a pose update. Cannot submit frame data with a depth buffer. Cannot have poses that make use of OpenXR Spaces . Raw pose data is instead retrieved from the application's SLAM algorithms. Does not support controller action. Only supports GL user-space applications. User-space applications cannot acquire more than one swap chain buffer for each eye during the the processing of a frame. Must initialize ILLIXR during the session initialization.","title":"Monado Dataflow"},{"location":"plugin_README/monado_integration_dataflow/#monado-integration-dataflow","text":"The dataflow for the ILLIXR Monado integration comprises two steps: 1. getting pose data from ILLIXR, and 1. sending a user rendered frame back to ILLIXR. In Monado, ILLIXR is recognized as an HMD for Monado, while in ILLIXR, Monado looks like a user application (such as gldemo ). After ILLIXR is initialized from Monado, and Monado is registered as a plugin for ILLIXR, the most recent pose information can be easily obtained via Switchboard . The compositor side of Monado integration with ILLIXR is implemented more subtly. The original Monado compositor primarily performs distortion correction and aberration correction in a Vulkan back-end compositor. The compositor also has two client compositors (one for OpenGL applications and another for Vulkan applications) which pass frame data to the back-end compositor. ILLIXR integration intercepts the frame at GL client compositor and sends it to Switchboard of ILLIXR, which is then used by timewarp_gl component . To get an OpenGL frame and use it without copying pixels, ILLIXR needs to get the user application GL context. This is done at OpenXR session creation time, where ILLIXR is initialized. Note that, logically, ILLIXR is initialized during OpenXR instance creation, or is otherwise running in the background all the time. Currently, ILLIXR is initialized at session creation time, since ILLIXR only supports single OpenXR session, and requires a user application GL context upon initialization, The current ILLIXR integration for Monado is a temporary solution and has some drawbacks caused by the concurrent and continued development from both the Monado and ILLIXR projects. The integration: Does not use the pose that user application declares to use at rendering (using the OpenXR specification). This is due to incongruencies with Monado's internal interfaces and representations. The pose difference used by timewarp is computed using the most recent query for a pose update. Cannot submit frame data with a depth buffer. Cannot have poses that make use of OpenXR Spaces . Raw pose data is instead retrieved from the application's SLAM algorithms. Does not support controller action. Only supports GL user-space applications. User-space applications cannot acquire more than one swap chain buffer for each eye during the the processing of a frame. Must initialize ILLIXR during the session initialization.","title":"Monado Integration Dataflow"},{"location":"plugin_README/offload_vio/","text":"Running ILLIXR With VIO Offloaded In order to run the offloading plugins you need the following extra dependecies sudo add-apt-repository ppa:ecal/ecal-latest sudo apt-get update sudo apt-get install ecal sudo apt-get install libprotobuf-dev protobuf-compiler The most simple example is running the offloaded setup on one machine with the server in one terminal and the device running in a different terminal. Each terminal must be running from separate ILLIXR repositories (clone ILLIXR twice to different locations; running both the server and device from the same ILLIR repository will cause lock issues). Start ILLIXR using main.opt.exe --yaml=profiles/offload-server.yaml --data=<> --demo_data=<> for one terminal and main.opt.exe --yaml=profiles/offload-device.yaml --data=<> --demo_data=<> on the other terminal. This will run OpenVINS on the server and will feed it with the EuRoC dataset from the device. To run more complicated experiment setups where the device and server are not on the same machine, you will need to establish TCP communication between machines, you'll need to configure both the server and client settings. The IP address and port number can be set in the configuration file: include/illixr/network/net_config.hpp This file contains variables where you can enter the respective IP addresses and port numbers for the server and client. Edit these fields to suit your network setup. Compression H.264 codec is supported for compressing the camera images to save bandwidth. To enable compression, define USE_COMPRESSION in device_tx/plugin.cpp and server_rx/plugin.cpp . In device_tx/video_encoder.cpp and server_rx/video_decoder.cpp , define appropriate image dimensions and desired target bitrate (defaults to 5Mbps). The codec library is implemented based on GStreamer and DeepStream. Please follow the instructions here to install GStreamer and DeepStream SDK. You don't have to reinstall CUDA and NVIDIA Driver if you have a relatively new version. TensorRT and librdkafka are not required either.","title":"Offload VIO"},{"location":"plugin_README/offload_vio/#running-illixr-with-vio-offloaded","text":"In order to run the offloading plugins you need the following extra dependecies sudo add-apt-repository ppa:ecal/ecal-latest sudo apt-get update sudo apt-get install ecal sudo apt-get install libprotobuf-dev protobuf-compiler The most simple example is running the offloaded setup on one machine with the server in one terminal and the device running in a different terminal. Each terminal must be running from separate ILLIXR repositories (clone ILLIXR twice to different locations; running both the server and device from the same ILLIR repository will cause lock issues). Start ILLIXR using main.opt.exe --yaml=profiles/offload-server.yaml --data=<> --demo_data=<> for one terminal and main.opt.exe --yaml=profiles/offload-device.yaml --data=<> --demo_data=<> on the other terminal. This will run OpenVINS on the server and will feed it with the EuRoC dataset from the device. To run more complicated experiment setups where the device and server are not on the same machine, you will need to establish TCP communication between machines, you'll need to configure both the server and client settings. The IP address and port number can be set in the configuration file: include/illixr/network/net_config.hpp This file contains variables where you can enter the respective IP addresses and port numbers for the server and client. Edit these fields to suit your network setup.","title":"Running ILLIXR With VIO Offloaded"},{"location":"plugin_README/offload_vio/#compression","text":"H.264 codec is supported for compressing the camera images to save bandwidth. To enable compression, define USE_COMPRESSION in device_tx/plugin.cpp and server_rx/plugin.cpp . In device_tx/video_encoder.cpp and server_rx/video_decoder.cpp , define appropriate image dimensions and desired target bitrate (defaults to 5Mbps). The codec library is implemented based on GStreamer and DeepStream. Please follow the instructions here to install GStreamer and DeepStream SDK. You don't have to reinstall CUDA and NVIDIA Driver if you have a relatively new version. TensorRT and librdkafka are not required either.","title":"Compression"}]}