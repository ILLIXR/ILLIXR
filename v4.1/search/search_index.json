{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ILLIXR","text":""},{"location":"#overview","title":"Overview","text":"<p>Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is a fully open-source Extended Reality (XR) system and testbed. The modular, extensible, and OpenXR-compatible ILLIXR runtime integrates state-of-the-art XR components into a complete XR system.</p> <p>The current ILLIXR release is v4.0. Source code is available from our GitHub repository, which also contains instructions for building fully contained Docker images.</p> <p>ILLIXR provides its components in standalone configurations to enable architects and system designers to research each component in isolation. The standalone components are packaged together as of the v3.1.0 release of ILLIXR.</p> <p>ILLIXR's modular and extensible runtime allows adding new components and swapping different implementations of a given component. ILLIXR currently contains the following plugins and services:</p>"},{"location":"#current-plugins-and-services","title":"Current Plugins and Services","text":""},{"location":"#perception","title":"Perception","text":"<ul> <li>Filter-based visual-inertial estimator<ul> <li>OpenVINS<sup>1</sup></li> </ul> </li> <li>Tracking<ul> <li>Head tracking: ORB_SLAM3<sup>1</sup> and lighthouse</li> <li>Hand tracking<sup>1</sup></li> <li>openni</li> <li>depthai</li> </ul> </li> <li>IMU integrators<ul> <li>gtsam_integrator</li> <li>passthrough_integrator</li> <li>rk4_integrator</li> </ul> </li> <li>Pose Related Service<ul> <li>fauxpose</li> <li>pose_prediction</li> <li>pose_lookup</li> </ul> </li> <li>Cameras<ul> <li>zed supporting ZED Mini</li> <li>realsense supporting Intel RealSense</li> <li>webcam</li> </ul> </li> </ul>"},{"location":"#visual","title":"Visual","text":"<ul> <li>Asynchronous reprojection:<ul> <li>timewarp_gl, OpenGL based</li> <li>timewarp_vk, Vulkan based</li> </ul> </li> <li>Asynchronous 6-degree reprojection openwarp</li> <li>vkdemo - toy application, with native ILLIXR rendering interface gldemo</li> <li>native_renderer - render management</li> <li>gldemo - stand-in application when ILLIXR is run as a standalone application without an actual OpenXR application</li> </ul>"},{"location":"#aural","title":"Aural","text":"<ul> <li>spatial audio encoding/playback<sup>1</sup></li> </ul>"},{"location":"#data-recording","title":"Data Recording","text":"<ul> <li>offload_data</li> <li>record_imu_cam</li> <li>record_rgb_depth</li> <li>zed_capture (standalone executable)</li> </ul>"},{"location":"#data-readinginjection","title":"Data Reading/Injection","text":"<ul> <li>offline_cam</li> <li>offline_imu</li> <li>zed.data_injection</li> <li>ground_truth_slam</li> </ul>"},{"location":"#visualization","title":"Visualization","text":"<ul> <li>debugview</li> <li>hand_tracking.viewer</li> </ul>"},{"location":"#offloadingremote-work","title":"Offloading/Remote Work","text":"<ul> <li>offload_vio</li> <li>offload_rendering_client</li> <li>offload_rendering_client_jetson</li> <li>offload_rendering_server</li> <li>tcp_network_backend</li> <li>ada</li> </ul> <p>Some components, such as eye tracking and reconstruction are available as standalone components and are in the process of being integrated.</p> <p>We continue to refine and add new components and implementations. Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked GitHub repository for proper attribution to its authors.</p>"},{"location":"#papers-talks-demos-consortium","title":"Papers, talks, demos, consortium","text":"<p>A paper with details on ILLIXR, including its components, runtime, telemetry support, and a comprehensive analysis of performance, power, and quality on desktop and embedded systems.</p> <p>A talk presented at NVIDIA GTC'21 describing ILLIXR and announcing the ILLIXR consortium: Video. Slides.</p> <p>A demo of an OpenXR application running with ILLIXR.</p> <p>The ILLIXR consortium is an industry-supported community effort to democratize XR systems research, development, and benchmarking. Visit our website for more information. For news and papers go to illixr.org, for talks see our YouTube channel, and join our Discord for announcements.</p>"},{"location":"#demo-videos","title":"Demo Videos","text":"<p>All of our demo videos can be seen on our YouTube channel.  Here are some highlights:</p> Running Locally Head Tracking (VIO) Offloaded Rendering Offloaded"},{"location":"#citation","title":"Citation","text":"<p>We request that you cite our following paper when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.</p> <pre><code>@inproceedings{huzaifa2021illixr,\n  title={ILLIXR: Enabling end-to-end extended reality research},\n  author={Huzaifa, Muhammad and Desai, Rishi and Grayson, Samuel and Jiang, Xutao and Jing, Ying and Lee, Jae and Lu, Fang and Pang, Yihan and Ravichandran, Joseph and Sinclair, Finn and Tian, Boyuan and Yuan, Hengzhi and Zhang, Jeffrey and Adve, Sarita V.},\n  booktitle={2021 IEEE International Symposium on Workload Characterization (IISWC)},\n  pages={24--38},\n  year={2021},\n  organization={IEEE}\n}\n</code></pre> <p>Once your work is published, please send the citation to us at illixr@cs.illinois.edu.</p>"},{"location":"#contributing-and-documentation","title":"Contributing and Documentation","text":"<p>We welcome anyone to contribute to ILLIXR. If you wish to contribute, please see out contribution guide. Full documentation, including API specifications, can be found at our Getting Started page.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The ILLIXR project started in Sarita Adve\u2019s research group, co-led by PhD candidate Muhammad Huzaifa, at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Douglas Friedel, Steven Gao, Samuel Grayson, Qinjun Jiang, Xutao Jiang, Ying Jing, Jae Lee, Jeffrey Liu, Fang Lu, Yihan Pang, Joseph Ravichandran, Giordano Salvador, Rahul Singh, Finn Sinclair, Boyuan Tian, Henghzhi Yuan, and Jeffrey Zhang.</p> <p>ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.</p> <p>Our OpenXR implementation is derived from Monado. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.</p> <p>The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center (a JUMP Center co-sponsored by SRC and DARPA), the Center for Future Architectures Research (C-FAR, a STARnet research center), a Semiconductor Research Corporation program sponsored by MARCO and DARPA, National Science Foundation grants 2120464 and 2217144 and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset.</p> <p>Wesley Darvin came up with the name for ILLIXR.</p>"},{"location":"#licensing-structure","title":"Licensing Structure","text":"<p>ILLIXR is available as open-source software under the permissive University of Illinois/NCSA Open Source License. As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software. The external libraries and software included in ILLIXR each have their own licenses and must be used according to those licenses:</p> Package License<sup>2</sup> abseil-cpp Apache v2 ARM NEON 2 x86 SSE BSD-2 clause<sup>3</sup> concurrentqueue BSD-2 clause cxxopts MIT Depthai Core MIT draco Apache v2 EGL-Registry None given farmhash MIT FFmpeg GNU General Public License v3.0<sup>4</sup> filter MIT flatbuffers Apache v2 gemmlowp Apache v2 glslang BSD-3 clause<sup>5</sup> Gtsam BSD-2 clause<sup>3</sup> imgui MIT InfiniTAM Oxford University Innovation Academic License mediapipe Apache v2 Monado MIT Monado integration Boost v1 Monado Vulkan Integration Boost v1 moodycamel::ConcurrentQueue BSD-2 clause<sup>3</sup> OouraFFT MIT-like Open-VINS GNU General Public License v3.0 OpenXR Boost v1 ORB_SLAM3 GNU General Public License v3.0 protobuf BSD-3 clause pthreadpool BSD-2 clause<sup>3</sup> robin-hood-hashing MIT ruy Apache v2 SPIRV Headers MIT SPIRV Tools Apache v2 SqliteCPP MIT stb MIT tensorflow-lite Apache v2 tinyobjloader MIT Vulkan Headers Apache v2 Vulkan Loader Apache v2 Vulkan Utility Libraries Apache v2 Vulkan Validation Layers Apache v2 VulkanMemoryAllocator MIT XNNPACK BSD-3 clause yaml-cpp MIT zed_opencv (Sterolabs) MIT <p>Any LGPL or GPL licensed code are contained in optional components. ILLIXR's extensibility allows the source to be configured and compiled using only permissively licensed software, if desired. See out Getting Started page for instructions.</p>"},{"location":"#get-in-touch","title":"Get in Touch","text":"<p>Whether you are a computer architect, a compiler writer, a systems person, work on XR related algorithms or applications, or just anyone interested in XR research, development, or products, we would love to hear from you and hope you will contribute! You can join our Discord, mailing list, email us, or just send a pull request!</p> <ol> <li> <p>Source is hosted in an external repository under the ILLIXR project.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Current as of March 5, 2025.\u00a0\u21a9</p> </li> <li> <p>Also known as the Simplified BSD License.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>ILLIXR uses a customized version of FFmpeg, compiled with x264 and x265 encoding support, thus it is licensed under GPL v3.0\u00a0\u21a9</p> </li> <li> <p>This software is covered by multiple open source licenses, see the link for details.\u00a0\u21a9</p> </li> </ol>"},{"location":"CHANGELOG/","title":"ILLIXR v4.1 (2025-10-06)","text":"<ul> <li>Release Notes:     This release of ILLIXR introduces a set of nine plugins for our Ada system, a distributed, power-aware, real-time scene provider for XR.</li> <li>Plugins<ul> <li>This is the first open-source release of Ada, implemented on top of the ILLIXR testbed. Ada provides a reproducible implementation of our ISMAR/TVCG 2025 paper results. Its features include:<ul> <li>Full implementation of Ada\u2019s distributed scene provisioning pipeline:<ul> <li>Efficient depth encoding with MSB (lossless) + LSB (tunable bitrate)</li> <li>Decoupled volumetric fusion and scene extraction</li> <li>Extraction-aware scene management</li> <li>Real-time mesh compression with parallel encoding</li> </ul> </li> <li>Device-side and server-side plugin set for ILLIXR</li> <li>Support for ScanNet dataset and InfiniTAM-based reconstruction</li> <li>Example prepared ScanNet sequence for quick testing   By @jianxiapyh in PR #462</li> </ul> </li> </ul> </li> <li>Infrastructure<ul> <li>Some of the new plugins have dependencies which require the Clang compiler in order to be built. To avoid library conflicts, we recommend using the Clang compiler to build the entire project.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#illixr-v40-2025-03-28","title":"ILLIXR v4.0 (2025-03-28)","text":"<ul> <li>Release Notes:     This release of ILLIXR brings many new features and capabilities. A good potion of the code base has been refactored/reorganized to both standardize the code and group similar parts together. There were a total of 16 pull requests merged which introduced 10 new plugins, overhauled several others, and addressed 13 issues. The new plugins include remote rendering, hand tracking, and ORB_SLAM. Vulkan is now the default display back-end, and due to this, some of the OpenGL based plugins may not work on every system. See below for more detailed notes on the changes.</li> <li>Plugins<ul> <li>Introduces a new ORB_SLAM3 based plugin. By @hungdche in PR #407</li> <li>Deployed four new plugins: hand_tracking, webcam, hand_tracking.viewer, and zed.data_injection, reworked the zed plugin, and a zed_capture executable.<ul> <li>hand_tracking: detects and reports the positions of joints and fingertips; if depth information is available, or distances can be calculated by parallax, the reported coordinates are real-world in millimeters, otherwise they are in pixel coordinates</li> <li>webcam: captures images from a webcam and publishes them to the <code>webcam</code> topic</li> <li>hand_tracking.viewer: gui based interface for visualizing the output of the hand_tracker in real time</li> <li>zed.data_injection: reads in data from disk and publishes it as if it were the zed plugin, good for debugging and testing</li> <li>zed: now publishes information about the camera (pixels, field of view, etc.) which is required for some modes of depth sensing; also now publishes the pose corresponding to the current images; these are in addition to the images and IMU information it has always published</li> <li>zed_capture: a standalone executable used to capture the images and poses from the zed camera and write them to disk (currently does not capture depth information); the products of this executable are intended to be used by the zed.data_injection plugin   By @astro-friedel in PR #428</li> </ul> </li> <li>The hand tracking plugin now can be used as an OpenXR API Layer, where it will intercept calls to get hand tracking data. It has been tested with Monado, but should be generally compatible. Adheres to OpenXR-1.0 standards. By @astro-friedel in PR #436</li> <li>Deployed the following plugins:<ul> <li>tcp_network_backend: a backend for Switchboard using TCP to transmit topics between two connected ILLIXR instances</li> <li>offload_rendering_server: encodes OpenXR frames with FFMPEG and transmits them across the Switchboard network backend</li> <li>offload_rendering_client: decodes frames transmitted from an offload_rendering_server instance and adds decoded frames to a buffer pool</li> <li>openwarp_vk: an implementation of OpenWarp, 6-DoF asynchronous reprojection, in ILLIXR</li> <li>lighthouse: uses libsurvive to connect with Valve Index lighthouses for head tracking native_renderer has been reworked so that external applications can run asynchronously with reprojection.   By @qinjunj, @Jebbly, @shg8 in PR #437</li> </ul> </li> </ul> </li> <li>Infrastructure<ul> <li>File loading is used by several plugins, each with their own code. The file loading code has been centralized into <code>data_loading.hpp</code>. By @astro-friedel in PR #416</li> <li>Fixed an issue where plugins needed to be specified in the correct order, or they would throw an exception. By @astro-friedel in PR #417</li> <li>Fixed an issue when changing a profile name and re-running CMake. By @astro-friedel in PR #418</li> <li>The Runge-Kutta code was replicated several times in the code base. This code has now been centralized and rewritten to make it compatible with the current ILLIXR license. By @astro-friedel in PR #421</li> <li>Updated the tcp socket code so that it can be distributed under the current ILLIXR license. By @williamsentosa95 in PR #424</li> <li>The hand tracking plugin introduced a large number of breaking and non-breaking changes to the base structures used by ILLIXR.<ul> <li>breaking: the <code>cam_type</code> structures have been completely overhauled<ul> <li>all now inherit from a <code>cam_base_type</code> base struct, allowing for the <code>cam_base_type</code> to be used as a function argument type, letting a single function handle several different types of image input</li> <li>all <code>cam_base_type</code> based structs are now defined in the common headers (under include/illixr) rather than in some plugins</li> <li>there are now the following types: <code>binocular_cam_type</code>, <code>monocular_cam_type</code>, <code>rgb_depth_type</code>, <code>depth_type</code>, and <code>cam_type_zed</code></li> </ul> </li> <li>breaking: the header <code>data_format.hpp</code> was getting too large and complex; it has been broken up into multiple headers under the <code>data_format</code> directory, with all struts and functions inside the <code>ILLIXR::data_format</code> namespace<ul> <li>camera_data.hpp: structures used to describe the physical characteristics of a camera (# pixels, field of view, etc.)</li> <li>coordinate.hpp: enums for labelling the coordinate reference axes (e.g. LEFT_HANDED_Y_UP, RIGHT_HANDED_Y_UP, RIGHT_HANDED_Z_UP_X_FWD)</li> <li>frame.hpp: the <code>rendered_frame</code> struct</li> <li>hand_tracking_data: structs for holding positional information of points of a hand</li> <li>imu.hpp: all imu related structs</li> <li>misc.hpp: definitions that didn't fit with anything else</li> <li>opencv_data_types.hpp: most <code>cam_base_type</code> structs</li> <li>point.hpp: various structs for holding information about a point in 3D space</li> <li>pose.hpp: all pose related structs</li> <li>shape.hpp: structs related to shapes (e.g. rectangle)</li> <li>template.hpp: common templated functions</li> <li>unit.hpp: enums and functions related to units of measure</li> <li>zed_cam.hpp: the <code>cam_type_zed</code> struct; this is kept separate from the other <code>cam_base_type</code> due to potential dependencies on ZED headers, which not all systems have</li> </ul> </li> <li>The pose structures were expanded to hold additional information used by the hand_tracking code, these additions do not affect current uses of these structures   By @astro-friedel in PR #428, #440</li> </ul> </li> <li>Environment variable handling has been introduced to the <code>switchboard</code>. Calls to <code>std::getenv</code> have been replaced with calls to <code>swithchboard-&gt;get_env</code>, <code>switchbaord-&gt;get_env_char</code>, or <code>switchbaord-&gt;get_env_bool</code> and calls to <code>std::setenv</code> have been replaced with calls to <code>switchboard-&gt;set_env</code>. This change allows the switchboard to act as a broker for all environment variables. Additionally, environment variables can now be specified on the command line or in a yaml file, and will be made available to all plugins via the switchboard. By @astro-friedel in PR #430</li> </ul> </li> <li>Misc<ul> <li>Breaking: Policies for contributing to the ILLIXR code base, as well as a general coding style guide have been introduced. The entire code base was overhauled to bring it into compliance with the style guide. By @astro-friedel in PR #419</li> <li>General documentation updates for ILLIXR. By @astro-friedel in PR #422</li> <li>Updated CMakeLists.txt to cleanly handle newer FindBoost capabilities, updated tags on some external packages, cleaned up CMake output, added some <code>include</code> lines required by newer gcc compiler versions, and added <code>all.yaml</code> profile for testing that the code fully builds. By @astro-friedel in PR #431</li> <li>Updated several external packages ILLIXR builds from source to newer versions. Official support for CentOS, Fedora, and Ubuntu 20 and below has been dropped, support for Ubuntu 24 has been added. By    @astro-friedel in PR #439</li> <li>Added automated release note generation by @astro-friedel in PR #441</li> <li>Major documentation updates, including up-to-date plugin listing and descriptions and more internal links to data types. By @astro-friedel in PR #447</li> </ul> </li> <li>Issues   The following issues have been addressed and closed by this release:<ul> <li>#151 Openwarp by PR #437</li> <li>#245 Automate changelog generation by PR #441</li> <li>#368 Integrate TCP implementation for offloading VIO by PR #437</li> <li>#371 Bringing Configurable Parameters to Current iteration of ILLIXR by PR #430</li> <li>#401 Reduce or remove the use of environment variables to pass information between main and plugins by PR #430</li> <li>#408 Dependency handling for plugin loader by PR #417</li> <li>#410 Re-running CMake with different profile file results in old profile file being used by PR #418</li> <li>#412 Enable Headless Rendering in Vulkan by PR #437</li> <li>#415 Generate Guidelines and Procedures by PR #419</li> <li>#427 Broken Fedora 38 (only?) build by PR #439</li> <li>#443 Add CMake to the dependencies by PR #422</li> <li>#89 Integrate ORB-SLAM3 by PR #407</li> <li>#96 Push mkdocs and doxygen on merge to master by PR #441</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#illixr-v320-sept-19-2023","title":"ILLIXR v3.2.0 (Sept 19, 2023)","text":""},{"location":"CHANGELOG/#release-notes","title":"Release Notes","text":"<ul> <li>The biggest change is the complete rewriting of the build system. It now runs via CMake, making plugin management and dependency checking much more streamlined.</li> <li>ILLIXR added a new graphics pipeline using the Vulkan API, implemented in the new plugins vkdemo, timewarp_vk, dislpay_vk, and nativer_renderer. For details, see PR #396 by @shg8.</li> <li>ILLIXR has updated integration to support Monado's out-of-process compositor, which now allows users to run more OpenXR apps (Unreal Engine, Vulkan-based apps, etc) with direct mode.</li> <li>There are numerous updates to plugins as well as a few new ones (see details below)</li> <li>OpenVINS is now the default SLAM plugin.</li> <li>Kimera-VIO is no longer available for use with ILLIXR</li> </ul>"},{"location":"CHANGELOG/#whats-changed","title":"What's Changed","text":"<ul> <li>The offload_vio plugins were updated to a TCP implementation with separate IMU and Camera types; and the H264 codec was added by @qinjunj in #409 and #363</li> <li>The timewarp_gl plugin was modified to render into two textures/framebuffers and a Vulkan-OpenGL interop was introduced by @Jebbly in #404</li> <li>A new openni plugin was written by @hungdche in #370</li> <li>A new fauxpose plugin was written by @wsherman64 in #389</li> <li>A shaking issue with the zed plugin was fixed by @qinjunj in #394</li> <li>The logging infrastructure was overhauled to use spdlog by @mvanmoer in #391</li> <li>The documentation was overhauled to make it more clear and descriptive as well as provide an interactive tool to select plugins and get their dependencies and customized build commands by @hungdche and @astro-friedel in #361 and #384</li> <li>The ILLIXR codebase was converted to a more modular build system (CMake) by @astro-friedel in #384</li> </ul>"},{"location":"CHANGELOG/#issues","title":"Issues","text":"<p>The following issues have been addressed and closed by this release</p> <ul> <li>#42   Evaluate Ninja/CMake/Bazel for plugin build system</li> <li>#44   Add human-readable logging infrastructure</li> <li>#50   Separate IMU/camera Switchboard topics</li> <li>#181  Fix plugin documentation</li> <li>#188  Separate out Qemu setup from main setup</li> <li>#205  Switch languages for the runner's config's schema</li> <li>#213  Preserve partial progress in our Makefile</li> <li>#231  Refactor configurations to reduce redundancy</li> <li>#313  Add libgtsam.so symlink in gtsam install script</li> <li>#358  Update Documentations</li> <li>#360  Memory leak in offline_imu_cam plugin</li> <li>#367  Installation issue on Ubuntu 22.04</li> <li>#398  Required GPU specifications</li> <li>#399  Reduce dependency on OpenCV</li> <li>#400  Header/include cleanup is needed</li> </ul> <p>Full Changelog: https://github.com/ILLIXR/ILLIXR/compare/v3.1.0...v3.2.0</p>"},{"location":"CHANGELOG/#illixr-v310-may-8-2022","title":"ILLIXR v3.1.0 (May 8 2022)","text":""},{"location":"CHANGELOG/#release-notes_1","title":"Release Notes","text":"<ul> <li>Added a new core runtime service called <code>RelativeClock</code> to standardize timestamping and duration calculation in the system</li> <li>Added a set of new plugins under <code>offload_vio/</code> that enable the offloading of VIO from the device to a remote server</li> <li>Added a new plugin <code>record_imu_cam</code> that enables data collection with a real camera for later offline use</li> <li>Bug fixes to <code>realsense</code></li> </ul>"},{"location":"CHANGELOG/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Add IMU and Cam Recorder by @hungdche in #327</li> <li>Add Offloading VIO Plugins to ILLIXR by @JeffreyZh4ng in #331</li> <li>Fix RealSense plugin by @mhuzai in #337</li> <li>Standardize time in ILLIXR by @charmoniumQ in #250</li> </ul> <p>Full Changelog: https://github.com/ILLIXR/ILLIXR/compare/v3.0.0...v3.1.0</p>"},{"location":"CHANGELOG/#illixr-v300-apr-8-2022","title":"ILLIXR v3.0.0 (Apr 8, 2022)","text":""},{"location":"CHANGELOG/#release-notes_2","title":"Release Notes","text":"<ul> <li>Bug fixes to install script, <code>pose_lookup</code>, and <code>dynamic_lib</code></li> <li>Documentation updates</li> <li>New documentation for using Switchboard standalone</li> </ul> <p>While this is technically a patch, we are bumping the version to 3.0.0 because Switchboard had an API change in v2.1.11 and we forgot to bump up the major version then.</p>"},{"location":"CHANGELOG/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Don't use sudo by @charmoniumQ in #322</li> <li>Revert boost install script by @mhuzai in #323</li> <li>Fix docs by @charmoniumQ in #319</li> <li>Fixed <code>pose_lookup</code> and <code>dynamic_lib</code> by @e3m3 in #304</li> <li>Added documentation for using Switchboard and Phonebook externally by @charmoniumQ in #320</li> <li>Fix and add documentation by @mhuzai in #330</li> </ul> <p>Full Changelog: https://github.com/ILLIXR/ILLIXR/compare/v2.1.11...v3.0.0</p> <p>ILLIXR v2.1.11 (Dec 27, 2021)</p>"},{"location":"CHANGELOG/#updated-plugins","title":"Updated plugins","text":"<ul> <li>realsense:</li> <li>Expanded supported cameras to include D4XX and T26X.</li> <li>qemu:</li> <li>Updated script to pull and run Ubuntu 18.04.6.</li> <li>timewarp_gl:</li> <li>Fixed memory leak by moving the destructor to \u2018xlib_gl_extended_window\u2019.</li> <li>Added option to disable timewarping without disabling the plugin.</li> <li>Suppressed per frame prints.</li> <li>ground_truth_slam:</li> <li>Promoted instance-member to local variable.</li> <li>gtsam_integrator:</li> <li>Fixed to dump all sqlite files once ILLIXR shuts down.</li> <li>gldemo:</li> <li>Suppressed per frame prints.</li> </ul>"},{"location":"CHANGELOG/#new-plugins","title":"New plugins","text":"<ul> <li>depthai:</li> <li>Added support for DepthAI and OAK-D cameras.</li> <li>offload_data:</li> <li>Added support to synchronously collect rendered images and poses on-the-fly.</li> </ul>"},{"location":"CHANGELOG/#build-and-ci-infrastructure","title":"Build and CI infrastructure","text":"<ul> <li>Updated dependency install scripts</li> <li>Fixed gtsam,and opengv install script.</li> <li>Enabled libboost in deps.sh.</li> <li>Updated dependencies for Ubuntu 21.</li> <li>Updated build and dependency installation script with DepthAI.</li> <li>Canonicalized install script structure (fetch -&gt; build -&gt; install).</li> <li>Added Eigen install script.</li> <li>Added package dependencies install support for IntelRealSense for Ubuntu 18 LTS.</li> <li>Fixed libgtsam symlink.</li> <li>Fixed ZED compilation.</li> <li>Fixed compilation with OpenVINS.</li> <li>Migrated to tag-based checkouts for out-of-repo plugins.</li> <li>Other minor modifications.</li> </ul>"},{"location":"CHANGELOG/#documentation-and-guidelines","title":"Documentation and guidelines","text":"<ul> <li>README.md</li> <li>Fixed internal links.</li> <li>Other minor modifications.</li> <li>Documentation</li> <li>Fixed a number of outdated information, broken links,typos, and unclear descriptions.</li> <li>Fixed documentation figures and topic descriptions.</li> <li>Fixed description of OpenXR Spaces for Monado Integration.</li> <li>Updated contributing guidelines with step-by-step instructions.</li> <li>Updated instructions on writing customized plugins.</li> <li>Added explicit definitions for adding cmd and environment variables.</li> <li>Removed unused code and documentation.</li> <li>License</li> <li>Addressed missing licence information for GTSAM, Kimera-VIO and moodycamel::ConqurrentQueue.</li> </ul>"},{"location":"CHANGELOG/#improved-runtime","title":"Improved runtime","text":"<ul> <li>Added  errno checking.</li> <li>Added verbose errors flag.</li> <li>Added additional debugging info/support.</li> <li>Added a lock-based queue for the debugging process.</li> <li>Added KIMERA_ROOT to default monado config.</li> <li>Added git tags for mondao_integration launch configuration.</li> <li>Added stoplight to synchronize thread starts/stops.</li> <li>Added explicit definitions for adding cmd and environment variables.</li> <li>Enabled non-ILLIXR specific files to be potentially reused.</li> <li>Cleared errno in XOpenDisplay.</li> <li>Updated ILLIXR runtime for new Monado integration.</li> <li>Changed Switchboard to use ref-counting to patch memory leak.</li> <li>Changed the tqdm bar to show units (bytes/kbytes/\u2026).</li> <li>Fixed \u2018clean\u2019 configuration (clean.yaml).</li> <li>Fixed \u2018headless\u2019 configuration command argument.</li> <li>Fixed the issue that running ILLIXR on dbg mode cannot exit cleanly.</li> <li>Fixed GL performance warning to be no longer fatal.</li> <li>Inlined global helper function.</li> </ul> <p>ILLIXR v2.1.10 (Mar 16, 2021)</p> <ul> <li>Updated plugins<ul> <li>New: <code>pose_prediction</code>, <code>pose_lookup</code>, <code>kimera-vio</code>, <code>realsense</code>, <code>gtsam_integrator</code>, audio decoding</li> <li>Removed (Git) submodules</li> <li>Fixed ground truth for plugins</li> <li>Fixed OpenVins Motion-to-Photon</li> <li>New global camera shutter</li> <li>New object and interpupilary distance (IPD) rendering</li> <li>Improved hologram performance</li> <li>Using Euroc dataset</li> </ul> </li> <li>New build and CI infrastructure<ul> <li>Fixed GTSAM build</li> <li>Fixed Kimera-VIO build</li> <li>New parallel building for Runner</li> <li>New source (Git) and dataset fetching for Runner</li> <li>New headless support (<code>xvfb</code>)</li> <li>New virtualization support (<code>qemu</code>)</li> <li>New CI workflows for master branch and pull requests</li> <li>Updated dependency installations for Docker</li> <li>Updated configurations (e.g., <code>native-lookup</code>, <code>ci</code>)</li> <li>Fixed Monado integration</li> <li>New instrumented OpenCV</li> </ul> </li> <li>New documentation and guidelines<ul> <li>New plugins documentation</li> <li>New Runner documentation</li> <li>New contributing guidelines</li> </ul> </li> <li>Improved runtime<ul> <li>New Switchboard API</li> <li>Updated synchronization for readers and writers</li> <li>New threaded plugins</li> <li>New timing instrumentation</li> <li>New logging infrastructure (SQLite support)</li> </ul> </li> </ul> <p>ILLIXR v2.1.0 (Sept. 4, 2020)</p> <ul> <li>Added support for ZED Mini</li> <li>Improved build system</li> <li>Streamlined Monado integration</li> <li>Added logging interface (implementation pending)</li> <li>Improved core runtime (switchboard, phonebook, and sleeping mechanism)</li> <li>Updated documentation</li> </ul> <p>ILLIXR v2.0.1 (May 19, 2020)</p> <p>Tweaked documentation.</p> <p>ILLIXR v2.0.0</p> <ul> <li>Added runtime framework (spindle, switchboard, phonebook, logger)</li> <li>Added OpenXR support</li> <li>Integrated components into runtime framework</li> <li>Enabled end-to-end system</li> <li>Added docs</li> </ul> <p>ILLIXR v1.2.0</p> <ul> <li>Added eye tracking</li> <li>Improved audio pipeline build process</li> <li>Removed legacy code from hologram</li> <li>Updated README.md</li> <li>Updated CONTRIBUTORS</li> </ul> <p>ILLIXR v1.0.0</p> <p>v1 of ILLIXR contains only standalone components. See the v2 release for the runtime and component integration.</p> <p>Initial release of ILLIXR with SLAM, scene reconstruction, audio recording and playback, lens distortion correction, chromatic aberration correction, timewarp, and computational holography.</p>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright (c) 2019 The Board of Trustees of the University of Illinois.  All rights reserved.</p> <p>Developed by: Professor Sarita Adve's research group               University of Illinois at Urbana-Champaign               http://rsim.cs.illinois.edu</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: * Redistributions of source code must retain the above copyright notice,   this list of conditions and the following disclaimers. * Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimers in the documentation   and/or other materials provided with the distribution. * Neither the names of Professor Sarita Adve's research group, University of   Illinois at Urbana-Champaign, nor the names of its contributors may be used   to endorse or promote products derived from this Software without specific   prior written permission.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.</p>"},{"location":"adding_mediapipe/","title":"Adding mediapipe","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/adding_mediapipe</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"dataflow/","title":"Dataflow","text":"<p> Current dataflow between all plugins and services. Dark blue boxes represent plugins and cyan  component boxes represent services. Data types are represented with cylinders and labelled as <code>topic &lt;data_type&gt;</code>. Service data types are represented by octagons. Solid lines point from the plugin/service which publishes them to the data type. Dashed lines point from data types to the plugin/service which reads them synchronously. Dotted lines point from data types to the plugin/service which reads them asynchronously.</p>"},{"location":"debugging_illixr/","title":"Debugging illixr","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/debugging_illixr</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"display_backend/","title":"Display backend","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/display_backend</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"external_switchboard_and_phonebook/","title":"External switchboard and phonebook","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/external_switchboard_and_phonebook</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>ILLIXR is configured and built via CMake. The CMake system checks for required dependencies, builds each requested plugin, builds the main ILLIXR binary, and (optionally) installs these components.</p> <p>ILLIXR currently only builds on Linux systems, and has been tested on the following configurations:</p> <ul> <li>Ubuntu<ul> <li>22.04</li> <li>24.04</li> </ul> </li> <li>Fedora<sup>1</sup><ul> <li>38+</li> </ul> </li> </ul> <p>Other versions of these operating systems may work, but will likely require some manual installation of dependencies. For other Linux distributions (e.g. RHEL) it will require significant manual installation of dependencies as many are not available in the distribution repos. The instructions below are a generalized version.</p>"},{"location":"getting_started/#building-illixr","title":"Building ILLIXR","text":""},{"location":"getting_started/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/ILLIXR/ILLIXR --single-branch\n</code></pre> <p>This will clone only the default branch, if you want all branches then remove the <code>--single-branch</code> flag.</p>"},{"location":"getting_started/#install-dependencies","title":"Install dependencies","text":"<p>There are two levels of dependencies in ILLIXR: those that are required for any type of build, and those that are required only for specific plugins.</p>"},{"location":"getting_started/#select-your-operating-system-and-version","title":"Select your operating system and version","text":"<p>ILLIXR may compile with other versions of the above operating systems, but some of the necessary prerequisite packages are not supplied by the OS repos and will need to be compiled by hand. You should be able to use the package and cmake commands for other versions of the same OS (other than the missing packages) to compile ILLIXR. RHEL is not supported at this time as many of the prerequisite packages are not natively available. You will also need to have a C++ compiler installed as well as a generator (make, ninja, etc.) and CMake 3.24 or newer (installation is os dependent). We recommend the clang compiler, as some plugin dependencies require it to build.</p>"},{"location":"getting_started/#pick-the-illixr-plugins-you-want-to-use","title":"Pick the ILLIXR plugins you want to use","text":"Include virtualization support: See ILLIXR Under Virtualization for details. <p>Use the following to install the dependencies for the selected plugins:</p> <p></p>"},{"location":"getting_started/#build-command","title":"Build command","text":"<p>Use the following to build and install ILLIXR. You can specify the install location by giving the path to <code>CMAKE_INSTALL_PREFIX</code>. If you want the default install path then do not add the option to the command line.</p> <p>Warning</p> <p>If your install prefix requires sudo privileges then you will need to run both the build and install under sudo (this is due to the way cmake builds and installs some of the pre-packaged dependencies during the build phase).</p> <p>Some ILLIXR plugins rely on code that falls under the GNU General Public License (GPL) v3.0 or GNU Lesser General Public License (LGPL) v2.1. If you do not wish to build these codes you can select to exclude them below (or add <code>-DNO_GPL=ON</code> or <code>-DNO_LGPL=ON</code> to your cmake command line, NO_LGPL=ON implies the same for NO_GPL).</p> <p>No GPL code No LGPL code</p> <p>Common CMake command line arguments (always prepend with a <code>-D</code>):</p> <ul> <li>CMAKE_INSTALL_PREFIX    The root path to install the libraries and binary to. This defaults to <code>/usr/local</code>.</li> <li>CMAKE_BUILD_TYPE    The build type to do: Debug, Release, RelWithDebInfo</li> <li>YAML_FILE    The profile file of plugins to build and install. The default is None, meaning plugins should be specified individually on the command line.</li> <li>USE_&lt;PLUGIN_NAME&gt;=ON    Build the specifically named plugin (e.g <code>-DUSE_TIMEWARP_VK=ON</code> to build the timewarp_vk plugin). Any number of plugins can be specified on the command line in this fashion.</li> <li>BUILD_DOCS    Set to <code>ON</code> to enable building the documentation.</li> </ul> <p>Documentation Prerequisites</p> <p>Building the documentation requires Doxygen and mkdocs(&gt;= v1.5) to be installed, both of which are typically available from OS packages. Additionally, we utilize the material, mkdocs-material-extensions, mkdocs-get-deps, mkdocs-include-markdown-plugin, PyMdown, Pygments, mkdoxy, and mkdocs-glightbox python packages, which can be installed via pip using <code>docs/requirements.txt</code>.</p> <p>An alternate to specifying the plugins as command line arguments is to create a YAML file which specifies the plugins to build. Using <code>-DYAML_FILE=&amp;lt;FILE_NAME&amp;gt;</code> as the command line argument specifying the YAML file to use.</p> <p>You may need to specify the full path to the YAML_FILE</p> <p>See profile for the format.</p> <p>The current list of plugins is: </p> <ul> <li>ada.device_rx</li> <li>ada.device_tx</li> <li>ada.infinitam</li> <li>ada.mesh_compression</li> <li>ada.mesh_decompression_grey</li> <li>ada.offline_scannet</li> <li>ada.scene_management</li> <li>ada.server_rx</li> <li>ada.server_tx</li> <li>audio_pipeline</li> <li>debugview</li> <li>depthai</li> <li>fauxpose</li> <li>gldemo</li> <li>ground_truth_slam</li> <li>gtsam_integrator</li> <li>hand_tracking</li> <li>hand_tracking.viewer</li> <li>hand_tracking_gpu</li> <li>lighthouse</li> <li>native_renderer</li> <li>offline_cam</li> <li>offline_imu</li> <li>offload_data</li> <li>offload_rendering_client</li> <li>offload_rendering_server</li> <li>offload_vio.device_rx</li> <li>offload_vio.device_tx</li> <li>offload_vio.server_rx</li> <li>offload_vio.server_tx</li> <li>openni</li> <li>openvins</li> <li>openwarp_vk</li> <li>openwarp_vk.monado</li> <li>orb_slam3</li> <li>passthrough_integrator</li> <li>pose_lookup</li> <li>pose_prediction</li> <li>realsense</li> <li>record_imu_cam</li> <li>record_rgb_depth</li> <li>rk4_integrator</li> <li>tcp_network_backend</li> <li>timewarp_gl</li> <li>timewarp_gl.monado</li> <li>timewarp_vk</li> <li>timewarp_vk.monado</li> <li>vkdemo</li> <li>webcam</li> <li>zed</li> <li>zed.data_injection</li> </ul> <p>The CMake process will also create a YAML file call <code>illixr.yaml</code> which can be used as input to the binary.</p>"},{"location":"getting_started/#running-illixr","title":"Running ILLIXR","text":"<p>To run the ILLIXR binary just call <code>main.&lt;&gt;.exe</code> with any of the following command line arguments. (the <code>&lt;&gt;</code> indicate an infix specifying the build type, for <code>Debug</code> use <code>dbg</code>, for <code>Release</code> use <code>opt</code>, for <code>RelWithDebInfo</code> use <code>optdbg</code>)</p> <ul> <li>-p,--plugins=&lt;&gt;, comma separated list of plugins to use (case sensitive, all lowercase, no spaces)</li> <li>-y,--yaml=&lt;&gt;, the profile file to use which specifies some or all of the above arguments (e.g. the generated <code>illixr.yaml</code>)</li> <li>--, you can specify any variable the ILLIXR uses on the command line. Common ones are: <li>--duration=&lt;&gt;, the duration to run for in seconds (default is 60)</li> <li>--data=&lt;&gt;, the data file to use</li> <li>--demo_data=&lt;&gt;, the demo data to use</li> <li>--enable_offload</li> <li>--enable_alignment</li> <li>--enable_verbose_errors, give more information about errors</li> <li>--enable_pre_sleep, force ILLIXR to sleep for the given number of seconds before starting the plugins (this is useful for attaching a debugger)</li> <p>Regarding parameters for the binary, the following priority will be used: 1. If the parameter is specified on the command line it will have the highest priority 2. If the parameter has a value in the yaml file this value will only be used if it is not specified on the command line (second priority) 3. If the parameter has a value as an environment variable this value will only be used if it is not specified on the command line nor yaml file</p> <p>Please refer to the display backend for instructions on setting display-related environment variables.</p> <p>For specific usage instructions, refer to the README files of the respective plugins.</p>"},{"location":"getting_started/#profile-file-format","title":"Profile file format","text":"<p>An example of a YAML profile file is <pre><code>plugins: pose_lookup,timewarp_vk,vkdemo,native_renderer\nbuild_type: Debug\ninstall_prefix: /home/user/illixr\nenv_vars:\n  ILLIXR_RUN_DURATION: 5\n  DATA: data/mav0\n  DEMO_DATA: demo_data\n  ENABLE_OFFLOAD: false\n  ENABLE_ALIGNMENT: false\n  ENABLE_VERBOSE_ERRORS: false\n  ENABLE_PRE_SLEEP: false\n</code></pre></p> <p>Where the entries are defined as (* indicates required field):</p> <ul> <li> <p>plugins * : Comma separated list of plugins (case-sensitive) to build or load at runtime.</p> </li> <li> <p>build_type : The type of build to perform (Debug, Release, or RelWithDebInfo). Ignored at run time.</p> </li> <li> <p>install_prefix : The root path to where the compiled libraries and binaries should be installed. (e.g. specifying /home/user will install libraries in /home/user/lib and binaries in /home/user/bin).</p> </li> </ul> <p>!!! note</p> <pre><code>  The prefix is also used for installing any packages that were downloaded and build from external repositories (e.g. DBoW2, GTSAM, etc). At runtime this path is added to *LD_LIBRARY_PATH* to aid in finding the plugin libraries.\n</code></pre> <ul> <li>env_vars : environment variables to use, any environment variable ILLIXR uses can be set here and will be valid during program execution.</li> </ul> <p>In general, you should not edit a profile file directly. The exception to this is when you are testing things on your own machine. Profile files are generated automatically from the master <code>profiles/plugins.yaml</code> during the cmake configuration stage. This is done so that any changes to a profile or the addition or removal of a plugin can be managed from a single file. The build system will generate an illixr.yaml file which contains entries from the command line and any input profile file and can be freely edited (it is generated every time <code>cmake</code> is called).</p>"},{"location":"getting_started/#environment-variables","title":"Environment Variables","text":"<p>ILLIXR and several of its dependencies use environment variables to steer processing and define quasi-constant values. Traditionally, one would use std::getenv and std::setenv to get and set these items. However, in ILLIXR the switchboard acts as an interface to these functions with <code>get_env</code> (returns std::string), <code>get_env_bool</code> (returns bool), <code>get_env_char</code> (returns char*), and <code>set_env</code>. Using the switchboard interfaces allows for environment variables to be set from the command line and/or yaml file. It is strongly encouraged to the switchboard interface wherever possible. Any items given on the command line which do not match expected command line arguments are considered to be environment variables. For example:</p> <pre><code>main.dbg.exe --yaml=my.yaml --DATA_SOURCE=/home/my/data --PROCESS_DATA\n</code></pre> <p>This will set env environment variables <code>DATA_SOURCE</code> to <code>/home/my/data</code> and <code>PROCESS_DATA</code> to <code>True</code>. For yaml files, any items not in the expected set will be considered to be environment variables. For example:</p> <pre><code>plugins: fauxpose,timewarp_vk,vkdemo,debugview,audio_pipeline\nenable_offload: false\nenv_vars:\n  DATA_SOURCE: /home/my/data\n  PROCESS_DATA: true\n</code></pre> <p>Here, the keywords <code>plugins</code> and <code>enable_offload</code> are ignored, as they are expected options. The <code>DATA_SOURCE</code> and <code>PROCESS_DATA</code> entries will cause environment variables to be set to the respective values.</p> <p>Note</p> <p>The names and values of the environment variables are case-sensitive.</p> <p>Note</p> <p>The <code>get_env_bool</code> considers any of 'y', 'yes', 'true', 'on' (case-insensitive), and \"1\" to be <code>true</code>.</p>"},{"location":"getting_started/#common-environment-variables","title":"Common Environment Variables","text":"<ul> <li> <p>illixr_run_duration : The duration to run ILLIXR for in seconds.</p> </li> <li> <p>data : Path to the data file to download (build step) or use at runtime. If a URL is given (must start with http or https) the file will be downloaded and extracted; the path to the extracted data will be put in the illixr.yaml file.</p> </li> <li> <p>demo_data : The path to the demonstration data to use at runtime (ignored by build steps)</p> </li> <li> <p>enable_offload : ? Default is false</p> </li> <li> <p>enable_alignment : ? Default is false</p> </li> <li> <p>enable_verbose_errors : Controls the verbosity of error messages. Default is false</p> </li> <li> <p>enable_pre_sleep : Force ILLIXR to sleep for the given number of seconds before starting the plugins (this is useful for attaching a debugger), Default is 0, indicating no sleeping.</p> </li> </ul> <p>Each plugin can define environment variables to use. See the documentation of each plugin for details.</p>"},{"location":"getting_started/#illixr-graphics-backends","title":"ILLIXR Graphics Backends","text":"<p>ILLIXR currently supports both OpenGL and Vulkan backends (indicated as <code>gl</code> and <code>vk</code> in the config suffixes). Since some plugins should behave differently (and compile differently) based on what backend is being used, it's important to run <code>make clean</code> if you want to try swapping between the two backends.</p> <p>Warning</p> <p>The use of the OpenGL back end is in the process of being deprecated. Thus <code>gl</code> based plugins are not guaranteed to work in every instance.</p>"},{"location":"getting_started/#rationale","title":"Rationale","text":"<ul> <li>The current system can use profile files to control everything from the build to running ILLIXR, in keeping with the DRY principle.    However, for maximum flexibility control can also be done at the command line level as well.</li> </ul>"},{"location":"getting_started/#philosophy","title":"Philosophy","text":"<ul> <li> <p>Each plugin should not have to know or care how the others are compiled.     In the future, they may even be distributed separately, just as SOs.     Therefore, each plugin needs its own build system.</p> </li> <li> <p>Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins     should be extremely easy.</p> </li> <li> <p>It should be easy to build in parallel.</p> </li> <li> <p>Re-running <code>make</code> (and optionally <code>cmake</code> first) will only rebuild those parts of the code with have changed.</p> </li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Try browsing the source for the runtime and provided plugins. The source code is divided into components in the following directories:</p> <ul> <li> <p><code>ILLIXR/src/</code>:     A directory holding the implementation for loading and interfacing plugins.     This directory contains Spindle.</p> </li> <li> <p><code>ILLIXR/include/illixr/</code>:     A directory holding resources and utilities available globally to all plugins.     This directory contains the interfaces for Switchboard and Phonebook.</p> </li> <li> <p><code>ILLIXR/plugins/&lt;plugin_dir&gt;/</code>:     A unique directory for each plugin.     Most of the core XR functionality is implemented via plugins.     See Default Components for more details.</p> </li> </ul> <p>If you edit any of the source files, the CMake system will detect and rebuild the respective binary the next time it runs. If you want to add your own plugin, see Writing Your Plugin.</p> <ol> <li> <p>Primary development is aimed at Ubuntu systems, full support for Fedora may require extra work on the users part.\u00a0\u21a9</p> </li> </ol>"},{"location":"glossary/","title":"Glossary of ILLIXR Terminology","text":"<p>A collection of ILLIXR and ILLIXR-adjacent terms and their definitions can be found on this page your reference.</p>"},{"location":"glossary/#general","title":"General","text":""},{"location":"glossary/#asynchronous-reprojection","title":"Asynchronous Reprojection","text":"<p>The processing of rendered video for motion interpolation. Asynchronous reprojection improves the perception of the rendered video to the HMD when rendering misses it target frame rate.</p> <p>Asynchronous reprojection is implemented in the <code>timewarpgl</code>.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#chromatic-aberration-correction","title":"Chromatic Aberration Correction","text":"<p>The processing of visual anomalies in images where colors are diffracted due to imperfect optics or other perturbing factors.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#compositor","title":"Compositor","text":"<p>A window manager that establishes a framebuffer for each window of a graphical system. A compositor merges information across its windows to construct a unified framebuffer.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#distortion-correction","title":"Distortion Correction","text":"<p>The processing of visual anomalies in images where rectilinear features have been warped.</p> <p>For more information, see the Wikipedia artice.</p>"},{"location":"glossary/#eye-tracking","title":"Eye Tracking","text":"<p>The process of measuring the eye movement of a user (who is possibly also wearing an HMD).</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#event-stream","title":"Event Stream","text":"<p>A communication interface supporting writes, synchronous reads, and asynchronous reads. For synchronous reads, every value written to the stream is visible to consumers. For asynchronous reads, only the latest values written are guaranteed to be visible to consumers.</p>"},{"location":"glossary/#framebuffer","title":"Framebuffer","text":"<p>A region of memory used to hold graphical information to be output to a display or graphics device.</p> <ul> <li> <p>Depth Buffer:   A framebuffer representing the depth information of a 3D scene.   Depth information is useful for applications such as graphics and SLAM.</p> </li> <li> <p>Eye Buffer:   A framebuffer dedicated for display through an HMD lens to be perceived by a user's eye.</p> </li> <li> <p>Frame:   A single frame (image) to be output to a display at a certain instant of time based on the   system's frame rate.</p> </li> <li> <p>Frame Rate:   The interval period between complete (as defined by the output resolution) frame updates   and refreshes.   In many systems, the target frame rate is determined by a fixed vertical sync (VSYNC) period.</p> </li> </ul> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#ground-truth","title":"Ground Truth","text":"<p>The most accurate source of measurement available for a data set. Typically, ground truth measurements are provided for the evaluation of sensor data where the sensor or other data source is not as accurate or reliable as the source for the ground truth.</p> <ul> <li> <p>Ground Truth Poses:   A collection of poses used to evaluate the accuracy of pose generation and prediction algorithms.</p> </li> <li> <p>Ground Truth Images:   A collection of images used to evaluate the accuracy of visual processing algorithms,   like SLAM and VIO.</p> </li> </ul> <p>See the ILLIXR Plugins page for information about sensors implemented in ILLIXR.</p>"},{"location":"glossary/#head-mounted-display","title":"Head-mounted Display","text":"<p>A display device worn on the head and face for use with VR and XR applications. Also known as an HMD.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#inertial-measurement-unit","title":"Inertial Measurement Unit","text":"<p>A device that reports its orientation in space and any forces applied it. Also known as an IMU.</p> <p>An IMU is implemented in the <code>offline_imu</code>.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#plugin","title":"Plugin","text":"<p>A modular component that can be detected and enabled for use by an ILLIXR application. A plugin can be internal or external to the ILLIXR project. Each plugin is compiled and launched dynamically at runtime based on the command line options given or ILLIXR profile file being used. ILLIXR also implements a Monado runtime translation Plugin.</p> <p>For a list of supported plugins and their details, see the ILLIXR Plugins page. For instructions for how to modify or write your own plugins, see the Modifying a Plugin and Writing Your Plugin pages.</p> <p>See the Plugin API documentation.</p>"},{"location":"glossary/#profile","title":"Profile","text":"<p>A profile describes the environment to be used for the build system and running ILLIXR. Profiles are defined in YAML files. There are several provided in the <code>profiles</code> directory in the repository. A profile file defines what plugins are to be used, as well as additional information specific to where it is being used.</p> <ul> <li>As input to CMake:   If a profile file is given to cmake via the <code>-DYAML_FILE=</code> directive then the listed plugins will be built.</li> <li>As input to the ILLIXR binary   If a profile file is given on the ILLIXR binary via the <code>--yaml=</code> command line option, then any   listed plugins   will be loaded and any other command line options given in the profile file will be used. See Running ILLIXR   for details.</li> </ul> <p>The same profile file can be given to both cmake and the ILLIXR binary (you may need to change the <code>data:</code> entry), as any unrecognized options are ignored by both systems. See Profile file format for details on the profile file format.</p>"},{"location":"glossary/#pose","title":"Pose","text":"<p>The combination of orientation and position of an object, used for computer vision and robotics applications. ILLIXR applications make use of poses to track the user's HMD within the virtual environment. Internally, ILLIXR has multiple classifications of poses which are used for various purposes.</p> <ul> <li> <p>Slow Pose:   A slow pose is a visual-inertial based pose estimate at low frequency (e.g. 30 Hz). It can be from OpenVINS or ORB_SLAM3.</p> </li> <li> <p>Fast Pose:   A fast pose is a pose estimate from IMU integration at high frequency (e.g. hundreds of Hz), but with limited accuracy.</p> </li> <li> <p>True Pose:   A true pose is a ground truth pose, usually from datasets.</p> </li> <li> <p>Pose Prediction:   To improve the user's perceived latency, pose prediction leverages historical and current system information such as poses and sensor inputs to pre-compute the user's future pose.   This pre-computation enables downstream components to begin processing earlier, reducing end-to-end latency.</p> </li> </ul> <p>Pose Prediction is implemented in <code>pose_prediction</code>.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#runtime","title":"Runtime","text":"<p>The ILLIXR system runtime is responsible for the dynamic orchestration of ILLIXR device resources, system resources, and client applications.</p> <p>The runtime implementation is located in <code>&lt;ILLIXR_INSTALL_DIR&gt;/bin</code>. See the Getting Started and Monado Overview pages for details about the ILLIXR runtime.</p>"},{"location":"glossary/#service","title":"Service","text":"<p>These are modular components that are initialized like a plugin, but provide callable functions. Services are not directly triggered by ILLIXR's main loop, or by publication to a topic.</p>"},{"location":"glossary/#simultaneous-localization-and-mapping","title":"Simultaneous Localization and Mapping","text":"<p>The computational process of creating a map of an unknown environment, and finding one's location within that space. Also known as SLAM.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#swap-chain","title":"Swap Chain","text":"<p>A set of virtual framebuffers to be output to a display. Only one framebuffer in a swap chain is displayed at a time, enabling the other virtual framebuffers to be concurrently modified in memory.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#visual-inertial-odometry","title":"Visual Inertial Odometry","text":"<p>The process of computing a pose estimate from incoming visual information and measurements from the IMU. Also known as VIO. Often used in combination with SLAM techniques.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#components","title":"Components","text":""},{"location":"glossary/#phonebook","title":"Phonebook","text":"<p>An ILLIXR service directory used to introspectively interface plugins and their data. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Phonebook API documentation.</p>"},{"location":"glossary/#spindle","title":"Spindle","text":"<p>An ILLIXR component responsible for launching and managing plugin threads. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Spindle API documentation.</p>"},{"location":"glossary/#switchboard","title":"Switchboard","text":"<p>An ILLIXR event stream manager that maintains data pipelines between plugins. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Switchboard API documentation.</p>"},{"location":"glossary/#technologies","title":"Technologies","text":""},{"location":"glossary/#docker","title":"Docker","text":"<p>A platform and containerization framework for deploying applications under virtualization. ILLIXR uses Docker to deploy and test code in a continuous integration and deployment pipeline.</p> <p>For more information, see the Docker overview and getting started page.</p>"},{"location":"glossary/#godot","title":"Godot","text":"<p>An open source game development engine. ILLIXR applications targeting the OpenXR use Godot to access the engine's integration with the OpenXR standard via Monado.</p> <p>For more information, visit the official Godot site.</p>"},{"location":"glossary/#monado","title":"Monado","text":"<p>An open source, modular implementation of the OpenXR standard for GNU/Linux.</p> <p>See the ILLIXR Monado Overview and Monado Dataflow pages for details about our runtime integration using Monado.</p> <p>For more information, visit the official Monado development site.</p>"},{"location":"glossary/#opencv","title":"OpenCV","text":"<p>An open source computer vision library. Many of ILLIXR's components utilize these powerful algorithms and the cv::Mat class serves as the basis format for images inside ILLIXR.</p> <p>For more information, visit the official OpenCV site.</p>"},{"location":"glossary/#opengl","title":"OpenGL","text":"<p>A cross-platform graphics API that allows developers to create portable graphics applications easily. Also known as GL.</p> <ul> <li> <p>GL Context:   A data structure storing the state of an OpenGL application instance.   Within a GL context resides framebuffer data.   It is not thread safe to share contexts without appropriate synchronization.</p> </li> <li> <p>GLFW:   An open source implementation of OpenGL.   Supports Windows, macOS and, Linux (X11 and Wayland).   See the GLFW development site.</p> </li> </ul> <p>For more information, see the official OpenGL page from the Khronos Group.</p>"},{"location":"glossary/#openxr","title":"OpenXR","text":"<p>An open standard for Augmented and Virtual Reality. ILLIXR components target the OpenXR standard and interact with the ILLIXR device via the Application Interface.</p> <p>For more information, visit the official site from the Khronos Group.</p>"},{"location":"glossary/#qemu-kvm","title":"QEMU-KVM","text":"<p>An open source virtualization tool and machine emulator. See the instructions for running ILLIXR under Virtualization.</p> <p>For more information, see the official QEMU page.</p>"},{"location":"glossary/#sqlite","title":"SQLite","text":"<p>A SQL database engine implementation in C designed to be lightweight and easy to use. The ILLIXR project allows user to record application statistics to a local database for efficient processing. See the Logging and Metrics page for usage details.</p> <p>For more information, see the SQLite development site.</p>"},{"location":"glossary/#ubuntu","title":"Ubuntu","text":"<p>An open source GNU/Linux operating system and distribution. ILLIXR currently supports the Long Term Support (LTS) versions of Ubuntu: 20.04 LTS (Focal) and 11.04 (Jammy)</p> <p>For more information, visit the official Ubuntu site.</p>"},{"location":"glossary/#vulkan","title":"Vulkan","text":"<p>A cross-platform graphics API that allows developers to efficiently target low-level hardware features.</p> <p>For more information, see the official Vulkan page from the Khronos Group.</p>"},{"location":"glossary/#xvfb","title":"Xvfb","text":"<p>A virtual framebuffer for the X11 Window System. ILLIXR uses Xvfb to enable running the graphical ILLIXR application without requiring the user to have a graphical environment configured at application launch.</p> <p>For more information, see the Xfvb man page.</p>"},{"location":"glossary/#yaml","title":"YAML","text":"<p>A markup language and data serialization standard designed to be user-friendly. We make use of the yaml-cpp libraries to read our profile files.</p> <p>For more information, visit the official YAML page.</p>"},{"location":"illixr_plugins/","title":"ILLIXR plugins","text":"<p>This page details the structure of ILLIXR's plugins and how they interact with each other.</p>"},{"location":"illixr_plugins/#ada","title":"ada","text":"<p>Ada\u2019s distributed design relies on four communication plugins that coordinate data transfer between the device and server for remote scene provisioning.</p> <ul> <li><code>ada.device_rx</code>: Receives processed data from the server to the device. <ul> <li>Asynchronously reads a string from the topic <code>ada_processed</code>, which contains protobuf packets sent by the server.  </li> <li>Publishes <code>mesh_type</code> to <code>compressed_scene</code> topic.  forwards compressed mesh chunks to <code>ada.mesh_decompression_grey</code> </li> <li>Publishes <code>vb_type</code> to <code>VB_update_lists</code> topic. forwards the unique voxel block list (UVBL) to <code>ada.scene_management</code></li> </ul> </li> <li><code>ada.device_tx</code>: Sends encoded depth images (MSB and LSB) along with non-encoded pose information from the device to the server. The LSB encoding bitrate is configurable for bandwidth\u2013reconstruction accuracy trade-offs. <ul> <li>Synchronously reads <code>scene_recon_type</code> from <code>ScanNet_Data</code> topic, which provides dataset input (via <code>ada.offline_scannet</code>).  </li> <li>Publishes encoded depth data as a string to the <code>ada_data</code> topic.</li> </ul> </li> <li><code>ada.server_rx</code>: Receives encoded depth images and poses (not encoded) from the device, decodes them, and feeds them to the reconstruction module (<code>ada.infiniTAM</code>).  <ul> <li>Asynchronously reads a string from topic <code>ada_data</code></li> <li>Publishes <code>scene_recon_type</code> to <code>ScanNet_Data</code> topic. provides decoded depth frames and corresponding pose inforamtion to downstream reconstruction.</li> </ul> </li> <li><code>ada.server_tx</code>: Sends processed scene data (meshes and Unique Voxel Block Lists(UVBL)) from the server back to the device. <ul> <li>Synchronously reads <code>vb_type</code> from <code>unique_VB_list</code> topic (output of <code>ada.infiniTAM</code>). </li> <li>Synchronously reads <code>mesh_type</code> from <code>compressed_scene</code> topic (output of <code>ada.infiniTAM</code>).</li> <li>Publishes a string to <code>ada_processed</code> topic, each string is either a protobuf for <code>vb_type</code> topic or a protobuf for <code>mesh_type</code> topic.</li> </ul> </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#adainfinitam","title":"ada.infinitam","text":"<p>Performs scene reconstruction using incoming depth and pose data from the device, followed by on-demand or proactive scene extraction. During extraction, it generates both the updated partial mesh and the Unique Voxel Block List (UVBL), which are sent downstream for compression and scene management. Extraction frequency is configurable to balance latency and compute cost.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>scene_recon_type</code> from <code>ScanNet_Data</code> topic.</li> <li>Publishes <code>mesh_type</code> to <code>requested_scene</code> topic. Extracted mesh chunks for compression</li> <li>Publishes <code>vb_type</code> to <code>unique_VB_list</code> topic. This is the metadata for identifying updated voxel regions</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#adamesh_compression","title":"ada.mesh_compression","text":"<p>Compresses mesh chunks from <code>ada.infinitam</code> using a customized version of Google Draco. Compression parallelism can be tuned for different latency\u2013power trade-offs.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>mesh_type</code> from <code>requested_scene</code> topic.</li> <li>Publishes <code>mesh_type</code> to <code>compressed_scene</code> topic. compressed mesh chunks ready for transmission to the device. Voxel block information has been attached to each encoded face. </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#adamesh_decompression_grey","title":"ada.mesh_decompression_grey","text":"<p>Decompresses the mesh chunks received from the server and performs a portion of scene management that can be parallelized. Decompression parallelism can be tuned for different latency\u2013power trade-offs.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>mesh_type</code> from <code>compressed_scene</code> topic.</li> <li>Publishes <code>draco_type</code> to <code>decoded_inactive_scene</code> topic. decoded mesh data sent to <code>ada.scene_management</code>.  </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#adaoffline_scannet","title":"ada.offline_scannet","text":"<p>Loads the ScanNet dataset for offline or reproducible experiments.</p> <p>Topic details:</p> <ul> <li>Publishes <code>scene_recon_type</code> to <code>ScanNet_Data</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#adascene_management","title":"ada.scene_management","text":"<p>Integrates incremental scene updates into a maintained global mesh, merging new geometry and removing outdated regions for consistency.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>draco_type</code> from <code>decoded_inactive_scene</code> topic.</li> <li>Synchronously reads <code>vb_type</code> from <code>VB_update_lists</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#audio_pipeline","title":"audio_pipeline","text":"<p>Launches a thread for binaural: recording and one for binaural playback. Audio output is not yet routed to the system's speakers or microphone, but the plugin's compute workload is still representative of a real system. By default, this plugin is enabled (see <code>native</code> configuration).</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#debugview","title":"debugview","text":"<p>Renders incoming frames from the graphics pipeline for debugging live executions of the application.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Asynchronously reads <code>fast_pose_type</code> from <code>imu_raw</code> topic. (IMU biases are unused).</li> <li>Asynchronously reads <code>pose_type</code> from <code>slow_pose</code> topic.</li> <li>Asynchronously reads <code>rgb_depth_type</code> from <code>rgb_depth</code> topic.</li> <li>Asynchronously reads buffered <code>binocular_cam_type</code> from <code>cam</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#depthai","title":"depthai","text":"<p>Enables access to the DepthAI library.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic`</li> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#gldemo","title":"gldemo <sup>1</sup>","text":"<p>Renders a static scene (into left and right eye buffers) given the pose from <code>pose_prediction</code>.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Publishes <code>rendered_frame</code> to <code>eyebuffer</code> topic.</li> <li>Publishes <code>image_handle</code> to <code>image_handle</code> topic.</li> <li>Asynchronously reads <code>time_point</code> from <code>vsync_estimate</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#ground_truth_slam","title":"ground_truth_slam","text":"<p>Reads the ground truth from the same dataset as the <code>offline_imu</code> plugin. Ground truth data can be compared against the head tracking results (e.g. from VIO, IMU integrator, or pose predictor) for accuracy. Timing information is taken from the <code>offline_imu</code> measurements/data.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> to <code>true_pose</code> topic.</li> <li>Publishes <code>Eigen::Vector3f</code> to <code>ground_truth_offset</code> topic.</li> <li>Asynchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#gtsam_integrator","title":"gtsam_integrator","text":"<p>Integrates over all IMU samples since the last published visual-inertial pose to provide a fast pose every time a new IMU sample arrives using the GTSAM library (upstream).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_raw_type</code> to <code>imu_raw</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> <li>Asynchronously reads <code>imu_integrator_input</code> to <code>imu_integrator_input</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#hand_tracking","title":"hand_tracking","text":"<p>Detects and identifies hands in an image, CPU based calculations. The output from this plugin can be used to track hand movements and recognize hand gestures.</p> <p>Topic details:</p> <ul> <li>Synchronously reads one of <code>monocular_cam_type</code> from <code>webcam</code> topic, <code>binocular_cam_type</code> from <code>cam</code> topic, or <code>cam_type_zed</code> from <code>cam_zed</code> topic. This is selectable at run time via an environment variable.</li> <li>Asynchronously reads <code>camera_data</code> from <code>cam_data</code> topic, only once as values are static</li> <li>If reading from <code>webcam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, depending on which is available</li> </ul> </li> <li>If reading from <code>cam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, if either is available, but not required</li> </ul> </li> <li>If reading from <code>cam_zed</code>, no additional data are required.</li> <li>Publishes <code>ht_frame</code> to <code>ht</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#hand_tracking_gpu","title":"hand_tracking_gpu","text":"<p>Detects and identifies hands in an image, GPU based calculations. The output from this plugin can be used to track hand movements and recognize hand gestures. This plugin is currently experimental.</p> <p>Topic details:</p> <ul> <li>Synchronously reads one of <code>monocular_cam_type</code> from <code>webcam</code> topic, <code>binocular_cam_type</code> from <code>cam</code> topic, or <code>cam_type_zed</code> from <code>cam_zed</code> topic. This is selectable at run time via an environment variable.</li> <li>Asynchronously reads <code>camera_data</code> from <code>cam_data</code> topic, only once as values are static</li> <li>If reading from <code>webcam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, depending on which is available</li> </ul> </li> <li>If reading from <code>cam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, if either is available, but not required</li> </ul> </li> <li>If reading from <code>cam_zed</code>, no additional data are required.</li> <li>Publishes <code>ht_frame</code> to <code>ht</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#hand_trackingviewer","title":"hand_tracking.viewer","text":"<p>Reads the output of the <code>hand_tracking</code> plugin and displays the results on the screen. This is most useful for debugging. The capabilities of this plugin will be merged into the <code>debugview</code> plugin in the future.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>ht_frame</code> from <code>ht</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#lighthouse","title":"lighthouse","text":"<p>Enables lighthouse tracking using the libsurvive library</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> to <code>slow_pose</code> topic.</li> <li>Publishes <code>fast_pose_type</code> to <code>fast_pose</code> topic. </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#native_renderer","title":"native_renderer","text":"<p>Constructs a full rendering pipeline utilizing several ILLIXR components.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Calls <code>vulkan::display_provider</code></li> <li>Calls <code>vulkan::timewarp</code></li> <li>Calls <code>vulkan::app</code></li> <li>Synchronously reads <code>time_point</code> from <code>vsync_estimate</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offline_cam","title":"offline_cam","text":"<p>Reads camera images from files on disk, emulating real cameras on the headset (feeds the application input measurements with timing similar to an actual camera).</p> <p>Topic details:</p> <ul> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offline_imu","title":"offline_imu","text":"<p>Reads IMU data files on disk, emulating a real sensor on the headset (feeds the application input measurements with timing similar to an actual IMU).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_data","title":"offload_data","text":"<p>Writes frames and poses output from the asynchronous reprojection plugin to disk for analysis.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>texture_pose</code> to <code>texture_pose</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_rendering_client","title":"offload_rendering_client","text":"<p>Receives encoded frames from the network, sent by offload_rendering_server</p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::display_provider</code></li> <li>Calls <code>pose_prediction</code></li> <li>Asynchronously reads <code>compressed_frame</code> from <code>compressed_frames</code> topic.</li> <li>Publishes <code>fast_pose_type</code> to <code>render_pose</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_rendering_server","title":"offload_rendering_server","text":"<p>Encodes and transmits frames to one of the offload_rendering_clients. </p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::display_provider</code></li> <li>Asynchronously reads <code>fast_pose_type</code> from <code>render_pose_</code> topic.</li> <li>Publishes <code>compressed_frame</code> to <code>compressed_frames</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_vio","title":"offload_vio","text":"<p>Four plugins which work in unison to allow head tracking (VIO) to be rendered remotely. </p> <p>Topic details:</p> <ul> <li><code>offload_vio.device_rx</code><ul> <li>Asynchronously reads a string from topic <code>vio_pose</code>.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic</li> <li>Publishes <code>pose_type</code> to <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> to <code>imu_integrator_input</code> topic.</li> </ul> </li> <li><code>offload_vio.device_tx</code><ul> <li>Asynchronously reads <code>binocular_cam_type</code> from <code>cam topic</code></li> <li>Publishes a string to <code>compressed_imu_cam</code> topic</li> </ul> </li> <li><code>offload_vio.server_rx</code><ul> <li>Asynchronously reads a string from <code>compressed_imu_cam</code> topic</li> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> </ul> </li> <li><code>offload_vio.server_tx</code><ul> <li>Asynchronously reads <code>imu_integrator_input</code> from <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads <code>pose_type</code> from <code>slow_pose</code> topic from <code>open_vins</code></li> <li>Publishes a string to <code>vio_pose</code> topic.</li> </ul> </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#openni","title":"openni","text":"<p>Enables an interface to the Openni algorithms.</p> <p>Topic details:</p> <ul> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic. </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#open_vins","title":"open_vins","text":"<p>An alternate head tracking (upstream) implementation that uses a MSCKF (Multi-State Constrained Kalman Filter) to determine poses via camera/IMU.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> on <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> on <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_type</code> on <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#openwarp_vk","title":"openwarp_vk","text":"<p>Provides a Vulkan-based reprojection service.</p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::timewarp</code></li> <li>Calls <code>pose_prediction</code></li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#orb_slam3","title":"orb_slam3","text":"<p>Utilizes the ORB_SLAM3 library to enable real-time head tracking.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>binocular_cam_type</code> from <code>cam</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_type</code> on <code>imu</code> topic.</li> <li>Publishes <code>pose_type</code> to <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> to <code>imu_integrator_input</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#passthrough_integrator","title":"passthrough_integrator","text":"<p>Provides IMU integration.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>imu_integrator_input</code> from <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> <li>Publishes <code>imu_raw_type</code> to <code>imu_raw</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#realsense","title":"realsense","text":"<p>Reads images and IMU measurements from the Intel Realsense.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#record_imu_cam","title":"record_imu_cam","text":"<p>Writes <code>imu_type</code> and <code>binocular_cam_type</code> data to disk.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>binocular_cam_type</code> from <code>cam</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#record_rgb_depth","title":"record_rgb_depth","text":"<p>Writes <code>rgb_depth_type</code> data to disk.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>rgb_depth_type</code> from <code>rgb_depth</code> topic.</li> </ul> <p>Details Code</p>"},{"location":"illixr_plugins/#rk4_integrator","title":"rk4_integrator","text":"<p>Integrates over all IMU samples since the last published visual-inertial pose to provide a fast pose every time a new IMU sample arrives using RK4 integration.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>imu_integrator_input</code> from <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> <li>Publishes <code>imu_raw_type</code> to <code>imu_raw</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#tcp_network_backend","title":"tcp_network_backend","text":"<p>Provides network communications over TCP.</p> <p>Details Code</p>"},{"location":"illixr_plugins/#timewarp_gl","title":"timewarp_gl <sup>1</sup>","text":"<p>Asynchronous reprojection of the eye buffers. The timewarp ends right before vsync, so it can deduce when the next vsync will be.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Publishes <code>hologram_input</code> to <code>hologram_in</code> topic.</li> <li>If using Monado<ul> <li>Asynchronously reads <code>rendered_frame</code> on <code>eyebuffer</code> topic, if using Monado.</li> <li>Publishes <code>time_point</code> to <code>vsync_estimate</code> topic.</li> <li>Publishes <code>texture_pose</code> to <code>texture_pose</code> topic if <code>ILLIXR_OFFLOAD_ENABLE</code> is set in the env.</li> </ul> </li> <li>If not using Monado<ul> <li>Publishes <code>signal_to_quad</code> to <code>signal_quad</code> topic.</li> </ul> </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#timewarp_vk","title":"timewarp_vk","text":"<p>Asynchronous reprojection of the eye buffers. The timewarp ends right before vsync, so it can deduce when the next vsync will be.</p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::timewarp</code></li> <li>Calls <code>pose_prediction</code></li> <li>Asynchronously reads <code>time_point</code> from <code>vsync_estimate</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#webcam","title":"webcam","text":"<p>Uses a webcam to capture images for input into the <code>hand_tracking</code> plugin. This plugin is useful for debugging and is not meant to be used in a production pipeline.</p> <p>Topic details:</p> <ul> <li>Publishes <code>monocular_cam_type</code> to <code>webcam</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#zed","title":"zed","text":"<p>Reads images and IMU measurements from the ZED Mini. Unlike <code>offline_imu</code>, <code>zed</code> additionally has RGB and depth data.</p> <p>Note</p> <p>This plugin implements two threads: one for the camera, and one for the IMU.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic.</li> <li>Publishes <code>camera_data</code> to <code>cam_data</code> topic.</li> <li>Publishes <code>cam_type_zed</code> on <code>cam_zed</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#zeddata_injection","title":"zed.data_injection","text":"<p>Reads images and pose information from disk and publishes them to ILLIXR.</p> <p>Topic details:</p> <ul> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic</li> <li>Publishes <code>pose_type</code> to <code>pose</code> topic.</li> <li>Publishes <code>camera_data</code> to <code>cam_data</code> topic.</li> </ul> <p> Details Code</p> <p>Below this point, we will use Switchboard terminology. Read the API documentation on Switchboard for more information.</p> <p> Current dataflow between all plugins and services. Dark blue boxes represent plugins and cyan  component boxes represent services. Data types are represented with cylinders and labelled as <code>topic &lt;data_type&gt;</code>. Service data types are represented by octagons. Solid lines point from the plugin/service which publishes them to the data type. Dashed lines point from data types to the plugin/service which reads them synchronously. Dotted lines point from data types to the plugin/service which reads them asynchronously.</p> <p>See Writing Your Plugin to extend ILLIXR.</p>"},{"location":"illixr_plugins/#plugin-interdependencies","title":"Plugin Interdependencies","text":"<p>Some plugins require other plugins to be loaded in order to work. The table below gives a listing of the plugin interdependencies.</p> Plugin Requires Provided by plugin debugview pose_prediction fauxpose, pose_lookup, pose_prediction gldemo pose_prediction fauxpose, pose_lookup, pose_prediction native_renderer app vkdemo display_sink display_vk pose_prediction fauxpose, pose_lookup, pose_prediction timewarp timewarp_vk timewarp_gl pose_prediction fauxpose, pose_lookup, pose_prediction timewarp_vk display_sink display_vk pose_prediction fauxpose, pose_lookup, pose_prediction vkdemo display_sink display_vk <p>See Getting Started for more information on adding plugins to a profile file.</p> <ol> <li> <p>ILLIXR has switched to a Vulkan back end, thus OpenGL based plugins may not work on every system.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"illixr_services/","title":"ILLIXR Services","text":"<p>This page details the structure of ILLIXR's services and how they interact with each other.</p>"},{"location":"illixr_services/#fauxpose","title":"fauxpose","text":"<p>An alternate tracking implementation that simply generates \"fast_pose\" data from a simple mathematical algorithm (circular movement).  The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking.</p> <p>Topic details: -   Provides <code>fast_pose_type</code> -   Asynchronously reads <code>time_type</code> from <code>vsync_estimate</code> topic.</p> <p> Details Code</p>"},{"location":"illixr_services/#pose_prediction","title":"pose_prediction","text":"<p>Uses the latest IMU value to predict a pose for a future point in time. Implements the <code>pose_prediction</code> service, so poses can be served directly to other plugins.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>pose_type</code> on <code>slow_pose</code> topic, but it is only used as a fallback.</li> <li>Asynchronously reads <code>imu_raw</code> on <code>imu_raw</code> topic.</li> <li>Asynchronously reads <code>pose_type</code> on <code>true_pose</code> topic, but it is only used if the client asks for the true pose.</li> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic. This tells <code>pose_predict</code> what time to estimate for.</li> </ul> <p> Details Code</p>"},{"location":"illixr_services/#pose_lookup","title":"pose_lookup","text":"<p>Implements the <code>pose_predict</code> service, but uses ground truth from the dataset. The plugin peeks \"into the future\" to determine what the exact pose will be at a certain time.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>time_point</code> on <code>vsync_estimate</code> topic. This tells <code>pose_lookup</code> what time to lookup.</li> </ul> <p> Details Code</p>"},{"location":"illixr_services/#vkdemo","title":"vkdemo","text":"<p>INFO NEEDED</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Calls <code>vulkan::display_provider</code></li> </ul> <p> Details Code</p> <p> Current dataflow between all plugins and services. Dark blue boxes represent plugins and cyan  component boxes represent services. Data types are represented with cylinders and labelled as <code>topic &lt;data_type&gt;</code>. Service data types are represented by octagons. Solid lines point from the plugin/service which publishes them to the data type. Dashed lines point from data types to the plugin/service which reads them synchronously. Dotted lines point from data types to the plugin/service which reads them asynchronously.</p>"},{"location":"logging_and_metrics/","title":"Logging and metrics","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/logging_and_metrics</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"modifying_a_plugin/","title":"Modifying a plugin","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/modifying_a_plugin</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"modules/","title":"Modules","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/modules</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"updating_tags_and_docs/","title":"Updating tags and docs","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/updating_tags_and_docs</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"using_cameras/","title":"Using cameras","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/using_cameras</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"virtualization/","title":"Virtualization","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/virtualization</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"writing_your_plugin/","title":"Writing your plugin","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/writing_your_plugin</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"contributing/","title":"How to contribute to ILLIXR","text":"<p>We welcome contributions to ILLIXR! This document outlines the process for contributing to ILLIXR.</p>"},{"location":"contributing/#contents","title":"Contents","text":"<ul> <li>Code of Conduct</li> <li>Asking Questions</li> <li>Reporting Bugs</li> <li>Suggesting a Feature/Improvement</li> <li>Programming Style Guide</li> <li>Using 3rd Party Code/Libraries</li> <li>Licenses</li> <li>Creating a Pull Request</li> <li>Code Review Guidelines</li> </ul>"},{"location":"contributing/asking_questions/","title":"Asking Questions and Getting Help","text":"<p>There are several ways to get help with ILLIXR.</p> <ul> <li>Read through the documentation and see if you can find the answer you need.</li> <li>Search through issues and see if anyone has had the same issue before.</li> <li>Join our Discord server and ask questions there</li> </ul> <p>Please do not contact contributors/authors directly, use one of the public forums above.</p>"},{"location":"contributing/code_of_conduct/","title":"ILLIXR Code of Conduct","text":""},{"location":"contributing/code_of_conduct/#purpose","title":"Purpose","text":"<p>Our contributors come from all around the world with diverse skill sets, personalities, experiences, and points of view. All of these differences work together to make ILLIXR a success, and continue to grow. When working with members of this community the code of conduct will help guide your interactions and make this a positive experience for all.</p>"},{"location":"contributing/code_of_conduct/#pledge","title":"Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"contributing/code_of_conduct/#standards","title":"Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Attempting collaboration before conflict</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>Violence, threats of violence, or inciting others to commit self-harm</li> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, intentionally spreading misinformation, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Abuse of the reporting process to intentionally harass or exclude others</li> <li>Advocating for, or encouraging, any of the above behavior</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within ILLIXR project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting us anonymously through this form. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p> <p>If you are unsure whether an incident is a violation, or whether the space where the incident took place is covered by our Code of Conduct, we encourage you to still report it. We would prefer to have a few extra reports where we decide to take no action, rather than to leave an incident go unnoticed and unresolved that may result in an individual or group to feel like they can no longer participate in the community. Reports deemed as not a violation will also allow us to improve our Code of Conduct and processes surrounding it. If you witness a dangerous situation or someone in distress, we encourage you to report even if you are only an observer.</p>"},{"location":"contributing/code_of_conduct/#acknowledgements","title":"Acknowledgements","text":"<p>This code is adapted from the open source template of auth0.</p>"},{"location":"contributing/code_review/","title":"Code Review Guidelines","text":"<p>The point of code reviews is to make sure changes to ILLIXR are compatible with the vision of the project, are well coded</p> <p>If you are asked to review code for a pull request please:</p> <ul> <li>Review the code not the author</li> <li>Critique the code in a constructive format</li> <li>If possible offer suggestions/examples for changes or specific points, do not just say <code>this doesn't work</code></li> <li>If any questions are asked, be specific, feel free to ask several questions</li> <li>If critiques/questions deal with a specific section of code, start a conversation in that part of the code by clicking   on the <code>+</code> for the line of code in question</li> </ul> <p></p> <p>If your code is being reviewed:</p> <ul> <li>Every pull request must have reviews done by two people who are not the author of the pull request</li> <li>Don't take criticisms personally</li> <li>Please respond to any conversations, don't just close them</li> <li>Remember the review process is to improve your code</li> </ul>"},{"location":"contributing/feature_request/","title":"Making a Feature Request","text":"<p>Do you have a new feature or improvement in mind for ILLIXR? We'd love to hear about it! Please follow the steps below to submit a feature request.</p> <ul> <li>Ensure the feature, or something very similar, was not already requested by searching on GitHub under Issues.</li> <li>If an issue request for the feature/improvement already exists, feel free to add a comment to the existing issue with   any additional ideas or insights you think are relevant.</li> <li>If you're unable to find one that covers your idea, open a new one. Be sure to include a title, clear   description, and as much relevant information as possible. Please be descriptive as possible so that the developers   can fully understand what you are requesting.</li> <li>Once the issue is created a team member will review it, and it will be discussed for inclusion in the future as   resources allow.</li> <li>If you already have a solution in mind, consider submitting a pull request with the new feature or improvement. See   the Creating a Pull Request documentation for more information.</li> </ul>"},{"location":"contributing/licenses/","title":"Licenses","text":"<p>ILLIXR is licensed under the MIT License. This means that you are free to use, modify, and distribute the software as long as you include the original license and copyright notice in any copy of the software or substantial portion of the software.</p>"},{"location":"contributing/licenses/#third-party-licenses","title":"Third Party Licenses","text":"<p>ILLIXR uses many third-party libraries and codes, each with their own licenses. In order to be included in the core ILLIXR repository, each of these licenses must be compatible with the main ILLIXR license. Most open source licenses are compatible, however copy-left licenses such as the GNU General Public License(GPL) are not compatible. The Lesser General Public License (LGPL), however, is compatible with the MIT license. Other acceptable licenses include, but are not limited to:</p> <ul> <li>Apache License 2.0</li> <li>BSD 2-Clause License</li> <li>BSD 3-Clause License</li> <li>Boost Software License 1.0</li> <li>Most Creative Commons licenses</li> <li>Simplified BSD License</li> <li>Zlib License</li> </ul>"},{"location":"contributing/opening_an_issue/","title":"Reporting a Bug/Issue","text":"<p>If you have come across a bug, or have an issue building or running ILLIXR, please try the following:</p> <ul> <li>Ensure the bug was not already reported by searching on GitHub under Issues.</li> <li>If you're unable to find an open issue addressing the problem, open a new one. Be sure to include a title, clear description, and as much relevant information as possible. This may include:</li> <li>Steps to reproduce the bug.</li> <li>Command line arguments.</li> <li>Any data sets being used.</li> <li>Expected behavior.</li> <li>Actual behavior.</li> <li>Which plugins are being used.</li> <li>The contents of any configuration files.</li> <li>Any relevant environment variables.</li> <li>Build commands and arguments.</li> <li>Screenshots or error messages.</li> <li>System information (OS, hardware, etc.).</li> <li>Any other relevant information.</li> <li>If the issue regards running ILLIXR, please try doing a <code>Debug</code> build, if you have not already. This build will output more information and may help narrow down where the problem is arising from.</li> <li>Once the issue is created a team member will review it and work to resolve the issue.</li> </ul>"},{"location":"contributing/pull_request/","title":"Pull Requests","text":"<p>Please follow these steps when making pull requests (PRs):</p> <ol> <li> <p>First, create an issue describing the problem that needs to be fixed. If an issue already exists, skip this step. If    you are looking for an issue to fix, see the \"good first issue\" label.</p> </li> <li> <p>Assign the issue to yourself and add appropriate labels. If you are an external contributor, comment on the issue so    one of the ILLIXR team members can assign the issue to you.</p> </li> <li> <p>Before you start making changes, make a new branch. The branch MUST be named    <code>issue-&lt;issue number&gt;-&lt;some descriptive name&gt;</code>. For instance, <code>issue-32-fix-mem-leak</code> addresses the memory leak    described in Issue #32.</p> </li> <li> <p>Fix the issue.</p> </li> <li> <p>Add your name to <code>ILLIXR/CONTRIBUTORS</code>.</p> </li> <li> <p>Push commits up to GitHub.</p> </li> <li> <p>Open a PR, and link it to the issue that the PR aims to resolve. Please give the PR a descriptive name.</p> </li> <li> <p>Once you have your PR number, create a PR documentation file. See here for instructions.</p> </li> <li> <p>As you make progress on your PR, keep your branch up-to-date with the <code>master</code> branch which may have been updated    after starting your PR. Your PR MUST be updated to reflect changes to <code>master</code> in order to be merged. Use the    following procedure for updating your branch and when you are ready to commit your changes:</p> <pre><code>## While on your PR branch  hosted at  repository:\ngit commit # or git stash                                  ## Line A\ngit checkout master\n\ngit pull  master --rebase &amp;&amp; git fetch    ## Line B\n\ngit checkout \ngit rebase master                                          ## Line C\n\n## If you stashed your changes on 'Line A':\ngit stash apply  &amp;&amp; git commit\n\ngit push   --force-with-lease   ## Line D\n\n<p>For ILLIXR team members (others jump here):</p>\n<ul>\n<li>\n<p>In the example above, <code>&lt;illixr-remote&gt;</code> and <code>&lt;your-remote&gt;</code> are the same.</p>\n</li>\n<li>\n<p>When collaborating on branches in our repository, <code>Line B</code> may pull in changes that overwrite the git commit\n  history when performing <code>Line C</code>. Subsequently, performing <code>Line D</code> will rewrite the history in the public branch.\n  To preserve branch commit histories in the case that a rollback is needed, we will employ a checkpointing process\n  for force updated branches. This process will be manually performed, but may be automated in the future.</p>\n</li>\n</ul>\n<p>If <code>Line B</code> shows an update to master, the following example illustrates your local repository just after\nperforming <code>Line B</code>:</p>\n<pre><code>A -- B -- C -- P -- Q -- R       ## master\n           \\\n            D -- E -- F          ## issue-123-fixing-bug\n</code></pre>\n<p>In this example, commits <code>P</code>, <code>Q</code>, and <code>R</code> have been merged to <code>master</code>\n(from feature branches not shown) after feature branch <code>issue-123-fixing-bug</code> was\nforked from <code>master</code>.</p>\n<p>To checkpoint the <code>issue-123-fixing-bug</code> branch while it is checked out:</p>\n<pre><code>git branch issue-123.0-fixing-bug                                   ## Make alias for old issue-123-fixing-bug\ngit checkout -b issue-123.1-fixing-bug                              ## Make new branch to rebase with master\ngit rebase master                                                   ## Replay issue-123-fixing-bug onto master\ngit branch -D issue-123-fixing-bug                                  ## Remove old issue-123-fixing-bug\ngit branch issue-123-fixing-bug                                     ## Make issue-123-fixing-bug an alias of new branch\ngit push  issue-123.{0,1}-fixing-bug                 ## Push new checkpointed branches to remote\ngit push  issue-123-fixing-bug --force-with-lease    ## Force update issue-123-fixing-bug\n\n\n<p>Note</p>\n<p>The term alias here is used to refer to branches which point to the same commit. This usage is different from standard Git Aliases used for git command shortcuts.</p>\n\n<p>After checkpointing, your local repository should look as follows:</p>\n<pre><code>                           D' -- E' -- F'   ## issue-123.1-fixing-bug, issue-123-fixing-bug\n                          /\nA -- B -- C -- P -- Q -- R                  ## master\n           \\\n            D -- E -- F                     ## issue-123.0-fixing-bug\n</code></pre>\n<p>Commits <code>D</code>, <code>E</code>, and <code>F</code> have been added to a new branch starting from <code>R</code>, but now have been given new hashes.\nThis new branch is our up-to-date copy of the feature branch <code>issue-123-fixing-bug</code>.</p>\n<p>While working on a checkpointed branch, keep aliases up-to-date using <code>git rebase</code>:</p>\n<pre><code>git commit                               ## Add changes to issue-123.1-fixing-bug\ngit checkout issue-123-fixing-bug        ## Switch to main issue-123-fixing-bug branch\ngit rebase issue-123.1-fixing-bug        ## Fast-forward issue-123-fixing-bug to issue-123.1-fixing-bug\n</code></pre>\n<p>Conflicts are possible when two or more collaborators push changes concurrently to the same branch. As long as\neach collaborator ensures that the branch update process starts at <code>Line A</code>, conflicts can be detected and handled\nlocally. In other words, every call to <code>git-push</code> should be preceded by a call to <code>git-pull</code>, following the\nprocess from <code>Line A</code> to <code>Line D</code> (or equivalent; git's CLI allows many ways to achieve the same results).</p>\n\n<p>Note</p>\n<p><code>Line B</code> rebases the <code>master</code> branch assuming that we have checked out <code>master</code>. Forgetting to specify <code>master</code> in\n<code>Line B</code> may result in a lossy forced update in the example below. Forgetting to checkout <code>master</code> will\nimmediately apply your checked out feature branch's changes, possibly also resulting in a lossy forced update.</p>\n\n<p>The output of <code>Line B</code> for a collaborator after the checkpointing process may contain something like this:</p>\n<pre><code>From github.com:ILLIXR/ILLIXR\n  A..R          master                  -&gt; /master\n+ A..F'         issue-123-fixing-bug    -&gt; /issue-123-fixing-bug  (forced update)\n* [new branch]  issue-123.0-fixing-bug  -&gt; /issue-123.0-fixing-bug\n* [new branch]  issue-123.1-fixing-bug  -&gt; /issue-123.1-fixing-bug\n\n<p>Conflicts which do not involve updates to the <code>master</code> branch can be resolved simply by rebasing the current\nfeature branch with the updated feature branch, applying new changes on top of the updated feature branch:</p>\n<pre><code>## For the latest checkpoint X (local) and Y (remote), let Z := Y + 1 in\ngit checkout issue-123.X-fixing-bug -b issue-123.Z-fixing-bug       ## Make new branch issue-123.Z-fixing-bug\ngit rebase /issue-123.Y-fixing-bug                   ## Replay updates from issue-123.X-fixing-bug\ngit push  issue-123.Z-fixing-bug                     ## Make sure to update issue-123-fixing-bug after\n\n<p>The <code>--force-with-lease</code> argument in <code>Line D</code> is not required for our new checkpoint branch, since a new branch\nshould not conflict with a non-existing remote branch. We expect the subversion number for a new branch\nresulting from our checkpoint conflict resolution to be new and unique. If the push fails, another conflict has\noccurred, and checkpoint conflict resolution should be repeated. <code>Line D</code> should be safe to perform for the main\nfeature branch now that we have replayed our commits on top of the updated feature branch.</p>\n\n<p>Note</p>\n<p>In the above example, the <code>git-rebase</code> is performed using the remote copy of the checkpointed branch.\nWe do this because <code>Line B</code> will not fast-forward or force update our local branches\n(with the same subversion number as a conflicting remote branch, if any).</p>\n\n<p>In the case of a conflict with updates to <code>master</code>, <code>Line A</code> should show updates to both the <code>master</code> branch and\nthe feature branch to be pushed in <code>Line D</code>. A checkpointed version of the feature branch may also appear. This is\nbecause a feature branch should only be checkpointed in the presence of a change to the <code>master</code> branch. Forced\npushes should generally not be used for any other purpose. If multiple updates to <code>master</code> and the feature\nbranch have occurred, additional checkpointed versions of the feature branch may also appear. In this scenario, we\nneed to rebase our latest version of the feature branch with the latest version of the feature branch pulled from\n<code>&lt;illixr-remote&gt;</code>.</p>"},{"location":"contributing/pull_request/#pr-documentation","title":"PR Documentation","text":"<p>Each PR should create one or more documentation files. These files are used to automatically generate the bulk of the\nrelease notes for each release. The documentation files should go in the directories below <code>changes</code>.</p>\n<ul>\n<li>infrastructure: this directory is for PRs which deal with changes to base classes (plugin, switchboard, etc.),\n  changes to the locations of header files, or other similar system-level changes</li>\n<li>plugins: this directory is for major updates to, or creation of, plugins</li>\n<li>misc: this directory is for any PR that does not fit into the above two</li>\n<li>The issues and notes directories are reserved for work at release time and should not be generally used.</li>\n</ul>\n<p>The files should be named <code>pr.XYZ.md</code> where <code>XYZ</code> is replaced by your PR number. For example, <code>pr.400.md</code> would refer to\nPR #400. The style of the files is markdown. The top of the file has a special format</p>\n\n\n<pre><code>---\n- author.\n---\n\n<p>Where <code>&lt;your_github_name&gt;</code> should be your GitHub username. This will ensure proper attribution of your work in the\nrelease notes. If there are multiple authors, just add them one, after another, on separate lines.</p>\n\n\n<pre><code>---\n- author.author1\n- author.author2\n---\n</code></pre>\n<p>Giving each GitHub username. The rest of the file should be a short description of the PR, generally one or two\nsentences at most. If the changes are breaking changes (e.g. restructuring of headers) please start the text with</p>\n\n\n<pre><code>**Breaking**\n</code></pre>"},{"location":"contributing/pull_request/#philosophy","title":"Philosophy","text":"<p>Why are the above steps necessary?</p>\n<ol>\n<li>\n<p>Assigning the issue to yourself ensures that multiple people don't work on the same thing in parallel.</p>\n</li>\n<li>\n<p>The branch naming scheme organizes things a bit for us, and also makes it easy to find branches.</p>\n</li>\n<li>\n<p>Linking the issue to the PR ensures that we know which issue is being resolved, and also automatically closes the\n   issue when the PR gets merged.</p>\n</li>\n<li>\n<p>Using rebases keeps the <code>master</code> and feature branch histories streamlined (minimizing branching), thus making it\n   easier to compose feature branches for integration testing. See this article on rebasing public branches for\n   more information.</p>\n</li>\n</ol>\n<p>If your PR has not seen activity from the ILLIXR team after a long period of time (e.g., 2 weeks), feel free to contact\nthe team directly on the GitHub Issue Conversation tab or at the Gitter forum linked below.</p>"},{"location":"contributing/style_guide/","title":"Programming Style Guide","text":"<p>Consistency is the most important. Following the existing style, formatting, and naming conventions of the file you are modifying and of the overall ILLIXR project. Failure to do so will result in a prolonged review process that has to focus on updating the superficial aspects of your code, rather than improving its functionality and performance. Below are some general guidelines to follow. We also use a pre-commit bot that runs after pushes to GitHub. It enforces some general formatting rules, so don't be surprised if you see minor updates to your code. In general ILLIXR uses the Google C++ Style Guide with a few minor changes.</p>"},{"location":"contributing/style_guide/#directory-structure","title":"Directory Structure","text":"<p>Here is the basic directory structure used by ILLIXR (some files/directories have been omitted for brevity)</p> <pre><code>\u251c\u2500\u2500 cmake\n\u2502   \u251c\u2500\u2500 ConfigurationSummary.cmake    # functions to generate a summary after a cmake configuration run\n\u2502   \u251c\u2500\u2500 *.patch                       # patch files for any 3rd party code\n\u2502   \u251c\u2500\u2500 do_patch.sh                   # script for applying the patches\n\u2502   \u251c\u2500\u2500 Find*.cmake                   # cmake files for locating packages that do not have one installed by a repo\n\u2502   \u251c\u2500\u2500 Get*.cmake                    # cmake files used to build 3rd party packages\n\u2502   \u2514\u2500\u2500 HelperFunctions.cmake         # general helper functions\n\u251c\u2500\u2500 CMakeLists.txt                    # main cmake file for ILLIXR, edit with caution\n\u251c\u2500\u2500 CONTRIBUTORS                      # list of contributors to ILLIXR\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 docs\n\u2502   \u2502   \u251c\u2500\u2500 contributing\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.md                  # markdown files containing documentation on how to contribute to ILLIXR\n\u2502   \u2502   \u251c\u2500\u2500 css\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.css                 # css files used in the generated HTML documentation\n\u2502   \u2502   \u251c\u2500\u2500 images\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 *.png                 # images used in the generated documentation\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.svg\n\u2502   \u2502   \u251c\u2500\u2500 js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.js                  # javascript files used in the generated HTML documentation\n\u2502   \u2502   \u251c\u2500\u2500 plugin_README\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.md                  # readme files for individual plugins\n\u2502   \u2502   \u251c\u2500\u2500 policies\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.md                  # general policy documents\n\u2502   \u2502   \u251c\u2500\u2500 getting_started.md.in     # processed into markdown during cmake documentation build\n\u2502   \u2502   \u251c\u2500\u2500 modules.json              # json style file listing plugins and any 3rd party dependencies\n\u2502   \u2502   \u2514\u2500\u2500 *.md                      # general documentation\n\u2502   \u251c\u2500\u2500 doxygen\n\u2502   \u2502   \u2514\u2500\u2500 Doxyfile.in               # file to control doxygen, processed during cmake configuration\n\u2502   \u2514\u2500\u2500 mkdocs\n\u2502       \u2514\u2500\u2500 mkdocs.yaml.in            # file to control mkdocs, processed during cmake configuration\n\u251c\u2500\u2500 include\n\u2502   \u2514\u2500\u2500 illixr\n\u2502       \u251c\u2500\u2500 data_format               # header files for commonly used data structures \n\u2502       \u2514\u2500\u2500 *                         # header files used my multiple plugins or the main binary\n\u251c\u2500\u2500 plugins\n\u2502   \u251c\u2500\u2500                  # each plugin has its own subdirectory\n\u2502   \u2502   \u2514\u2500\u2500 CMakeLists.txt            # if the plugin is from another repository, then only this file is needed\n\u2502   \u251c\u2500\u2500 \n\u2502   \u2502   \u251c\u2500\u2500 CMakeLists.txt            # cmake file which configures the build for this plugin\n\u2502   \u2502   \u251c\u2500\u2500 plugin.hpp                # header file for the plugin, defining the class\n\u2502   \u2502   \u251c\u2500\u2500 *.hpp                     # additional header files, if any, for the plugin\n\u2502   \u2502   \u251c\u2500\u2500 *.cpp                     # additional source files, if any, for the plugin\n\u2502   \u2502   \u2514\u2500\u2500 plugin.cpp                # every plugin must have this file which contains the code for the plugin\n\u2502   \u2514\u2500\u2500 plugins.yaml                  # yaml style file listing configurations, plugins, and services\n\u251c\u2500\u2500 profiles\n\u2502   \u2514\u2500\u2500 *.yaml                        # yaml style files for each profile, these are auto-generated\n\u251c\u2500\u2500 services\n\u2502   \u251c\u2500\u2500 \n\u2502   \u2502   \u251c\u2500\u2500 CMakeLists.txt            # cmake file which configures the build for this plugin\n\u2502   \u2502   \u251c\u2500\u2500 service.hpp               # header file for the plugin, defining the class\n\u2502   \u2502   \u251c\u2500\u2500 *.hpp                     # additional header files, if any, for the service\n\u2502   \u2502   \u251c\u2500\u2500 *.cpp                     # additional source files, if any, for the service\n\u2502   \u2502   \u2514\u2500\u2500 service.cpp               # every plugin must have this file which contains the code for the plugin\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 display\n\u2502   \u2502   \u251c\u2500\u2500 *.hpp                     # header files for display back ends\n\u2502   \u2502   \u2514\u2500\u2500 *.cpp                     # source files for display back ends\n\u2502   \u251c\u2500\u2500 sqlite3pp\n\u2502   \u2502   \u2514\u2500\u2500 *.hpp                     # header files for the sqlite interface\n\u2502   \u251c\u2500\u2500 CMakeLists.txt                # cmake file for configuring the build of the main binary\n\u2502   \u251c\u2500\u2500 *.hpp                         # header files for the main binary\n\u2502   \u2514\u2500\u2500 *.cpp                         # source files for the main binary\n\u2514\u2500\u2500 utils\n    \u251c\u2500\u2500 imgui\n    \u2502   \u2514\u2500\u2500 *                         # header and source files for the ImGui library\n    \u251c\u2500\u2500 CMakeLists.txt                # cmake file for configuring the build of the utility static libraries\n    \u251c\u2500\u2500 *.hpp                         # header files for the utility libraries\n    \u2514\u2500\u2500 *.cpp                         # source files for the utility libraries\n\n<p>In addition to the above, if any individual plugin relies on third party code, this code should be placed in a directory named <code>third_party</code> inside the plugin directory. Files inside the <code>third_party</code> directory can be organized in any fashion. For example:</p>\n<pre><code>plugins\n\u2514\u2500\u2500 myplugin\n    \u251c\u2500\u2500 third_party\n    \u2502   \u251c\u2500\u2500 vk_mapper.c        # third party code\n    \u2502   \u2514\u2500\u2500 vk_mapper.h\n    \u251c\u2500\u2500 plugin.hpp             # plugin header\n    \u251c\u2500\u2500 plugin.cpp             # plugin code\n    \u2514\u2500\u2500 CMakeLists.txt         # plugin CMake file\n</code></pre>"},{"location":"contributing/style_guide/#file-naming","title":"File Naming","text":"<p>Illixr has adopted the following file naming conventions:</p>\n<ul>\n<li>files and directories are all lower case</li>\n<li>the <code>_</code> should be used as a word seperator</li>\n<li>header files should have the <code>.hpp</code> suffix</li>\n<li>code files should have the <code>.cpp</code> suffix</li>\n<li>documentation files should have the <code>.md</code> suffix</li>\n<li>each plugin must have its own header file called <code>plugin.hpp</code> which defines the class, this is to make it easier to see all the variables, etc. which could become buried in code otherwise </li>\n<li>each service must have its own header file called <code>service.hpp</code> which defines the class, this is to make it easier to see all the variables, etc. which could become buried in code otherwise</li>\n<li>any third party code used in ILLIXR is not subject to the above rules and can keep their original naming conventions</li>\n</ul>\n\n<p>Exceptions</p>\n<p>Files which must have a specific naming convention that is expected by outside code (e.g. CMakeLists.txt, Doxyfile, etc.), can use any case needed.</p>"},{"location":"contributing/style_guide/#header-files","title":"Header Files","text":"<p>ILLIXR has adopted the <code>#pragma once</code> include guard for all header files.</p>"},{"location":"contributing/style_guide/#includes","title":"Includes","text":"<p>Header files used via the <code>#include</code> pre-processor directive should be at the top of the code and header files, and ordered in the following fashion:</p>\n<ul>\n<li>any <code>plugin.hpp</code> or <code>service.hpp</code> associated with the plugin/service</li>\n<li>any headers from inside the ILLIXR codebase</li>\n<li>blank line</li>\n<li>system headers (those in angle brackets, e.g. <code>&lt;stdlib.h&gt;</code> <code>&lt;string&gt;</code>)</li>\n</ul>\n<p>Not every file will have includes from each group. Any missing group can just be skipped.\nHeader files in each group should be listed in alphabetical order. Some headers will only be included under certain conditions, by using <code>#ifdef</code> statements. These headers, and their conditionals, should be added below all other header files. This is an example:</p>\n<pre><code>#include \"illixr/data_format.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n\n#include \n#include \n#include \n#include \n\n#ifdef ZED\n#include \"zed.h\"\n#endif\n\n<p>Comments may be added between the groups as long as there is a blank line after each grouping. <code>#define</code> and <code>#undef</code> directives can be used at any place inside, before, or after any header grouping as needed.</p>"},{"location":"contributing/style_guide/#namespace","title":"Namespace","text":"<p>All ILLIXR code is inside the ILLIXR namespace. The use of additional namespaces below ILLIXR (e.g. <code>ILLIXR::data_format</code>)</p>"},{"location":"contributing/style_guide/#classes","title":"Classes","text":"<p>We have adopted the Google style for <code>class</code> declaration order:</p>\n<pre><code>class XYZ {\npublic:\n    # types and aliases (including enums)\n    # static constants\n    # factory functions (not widely used in ILLIXR)\n    # constructor(s) and assignment operators (if any)\n    # destructor\n    # all other functions\n    # data members\nprotected:\n    # types and aliases\n    # static constants\n    # factory functions (not widely used in ILLIXR)\n    # all other functions\n    # data members\nprivate:\n    # types and aliases\n    # static constants\n    # factory functions (not widely used in ILLIXR)\n    # all other functions\n    # data members\n};\n</code></pre>\n<p>For <code>struct</code>s, the order should be:</p>\n<pre><code>struct XYZ {\n    # all data members\n    # constructor(s)\n    # all other functions\n};\n</code></pre>\n<p>If a class constructor and/or destructor has no functionality it should be defined with <code>= default</code> rather than <code>{}</code>. For example</p>\n<pre><code>class XYZ {\npublic:\n    XYZ() {}\n    ~XYZ() {}\n};\n</code></pre>\n<p>should be</p>\n<pre><code>class XYZ{\npublic:\n    XYZ() = default;\n    ~XYZ() = default;\n};\n</code></pre>\n<p>Single argument constructors should be marked <code>explicit</code> in order to avoid unintentional implicit conversions.</p>"},{"location":"contributing/style_guide/#naming","title":"Naming","text":"<p>Names (file, variable, class, arguments, etc.) should be readable and clear, even to those unfamiliar to the project. Names should be descriptive of the purpose of the item. Shorter names (e.g. <code>n</code>, <code>i</code>) are acceptable for iterators, indexes, etc. Common abbreviations are also acceptable (e.g. <code>no</code> or <code>num</code> for number; <code>attr</code> or <code>attrib</code> for attribute; <code>l</code> or <code>L</code> for left, etc.).\nILLIXR has adopted the snake case naming convention. Names (variables, class names, files, etc.) start with a lower\ncase letter and use the underscore <code>_</code> in place of spaces. Additionally, there should be no prefixes like <code>_</code>, <code>m_</code>, or <code>_M_</code> on any class member variable names. All class data members should be suffixed with a single underscore <code>_</code>. </p>"},{"location":"contributing/style_guide/#templates","title":"Templates","text":"<p>In order to make reading the code clearer, template parameters should either be a single capital letter (<code>T</code>, <code>H</code>, etc.) or be a descriptive name that starts with a capital letter.</p>"},{"location":"contributing/style_guide/#cmake","title":"CMake","text":"<p>We currently require a minimum version of 3.22 for CMake. If you use any CMake features that have changed their default behavior over timeE17, we request you use CMake's <code>POLICY</code> directives to quiet any spurious warning messages. For example:</p>\n<p><pre><code>if (POLICY CMP0135)\n    cmake_policy(SET CMP0135 NEW)\nendif()\n</code></pre>\nwill quiet warnings about download timestamps when using ExternalProject_Add or FetchContent_Declare calls. ILLIXR also prefers the use of ExternalProject_Add over FetchContent_Declare to bring in external projects, as prefer this work to be carries out at compilation, rather than configuration, time.</p>"},{"location":"contributing/third_party/","title":"Using Third Party Code","text":"<p>ILLIXR is an open-source project that uses third-party code and libraries. This document outlines the process and licensing constraints for using these inside ILLIXR.</p>"},{"location":"contributing/third_party/#precompiled-libraries","title":"Precompiled Libraries","text":""},{"location":"contributing/third_party/#provided-by-os-package-managers","title":"Provided by OS Package Managers","text":"<p>If the third party library being used is provided by a package manager (yum, dnf, apt, etc.) then there are no licensing issues, as it is not being provided by ILLIXR. Any library that is used this way needs to be added to the <code>docs/docs/modules.json</code> file. See the documentation for more information on how to do this.</p> <p>To include the library in the build, add the library to the appropriate <code>CMakeLists.txt</code> file. If the package (or CMake itself) provides a <code>Find&lt;package&gt;.cmake</code> or <code>&lt;package&gt;Config.cmake</code> file, then use</p> <pre><code>find_package( REQUIRED)\n\n<p>to ensure the library exists on the build system. If the <code>*.cmake</code> file is in a non-standard location you may need to\nupdate the <code>CMAKE_PREFIX_PATH</code> variable to include the directory containing the <code>*.cmake</code> file.</p>\n<pre><code>set(CMAKE_PREFIX_PATH \"/path/to/file ${CMAKE_PREFIX_PATH}\")\n</code></pre>\n<p>If the package does not have a <code>Find&lt;package&gt;.cmake</code> file, but provides a <code>pkg-config</code> (.pc) file, then use\n<pre><code>find_package(PkgConfig REQUIRED)\npkg_check_modules( REQUIRED )\n\n<p>to ensure the library exists on the build system. If the <code>*.pc</code> file is in a non-standard location you may need to\nupdate the <code>PKG_CONFIG_PATH</code> environment variable to include the directory containing the <code>*.pc</code> file.</p>\n<pre><code>set(ENV{PKG_CONFIG_PATH} \"/path/to/file:$ENV{PKG_CONFIG_PATH}\")\n</code></pre>\n<p>If neither of these are provided you may need to use the <code>find_library</code> command to locate the library on the\nbuild system.</p>"},{"location":"contributing/third_party/#provided-by-third-party","title":"Provided by Third Party","text":"<p>If the precompiled library is provided as a download or via a third-party installer, then the library must be licensed\nunder a compatible license. See the license documentation for more information. To use a third-party installer in\nILLIXR, you will need to add directives in the appropriate <code>CMakeLists.txt</code> file to download and install the library.\nCommands such as <code>file(DOWNLOAD ...)</code>, <code>execute_process(COMMAND ...)</code>, and <code>add_custom_command</code> can\nbe used to accomplish this. You will need to be aware that CMake will not automatically associate the installation of\nthe library with its use in your code. You will likely need to add targets to the <code>DEPENDS</code> list of your code's CMake\ntarget.</p>"},{"location":"contributing/third_party/#built-from-source","title":"Built From Source","text":"<p>Any third-party code that is built from source must be licensed under a compatible license. See the license\ndocumentation for more information. To use this code in ILLIXR it is recommended to create a <code>cmake/Get&lt;package&gt;.cmake</code>\nfile that will download and build the library. See files in the <code>cmake</code> directory for examples. Then, in the appropriate\n<code>CMakeLists.txt</code> file for the code that depends on the library, use either the <code>get_external_for_plugin</code> (if your code\nis a plugin) or <code>get_external</code> macros to include the library in the build. Also, be sure to add the library to the\n<code>DEPENDS</code> list of your code's CMake target.</p>"},{"location":"contributing/third_party/#linking-to-the-library","title":"Linking to the Library","text":"<p>Once the library has been made available to the build system (see the above sections), you will need to ensure that the\nsystem can find any relevant headers and link to and locate the library at build and runtime. This is accomplished with\nthe <code>target_include_directories</code> and <code>target_link_libraries</code> commands in the appropriate <code>CMakeLists.txt</code>\nfile. See any of the existing <code>CMakeLists.txt</code> files in <code>plugins/*</code> for examples.</p>"},{"location":"contributing/third_party/#helpful-cmake-links","title":"Helpful CMake Links","text":"<ul>\n<li>CMAKE_PREFIX_PATH The path that CMake will search for <code>Find&lt;package&gt;.cmake</code> files.</li>\n<li>find_package The CMake command to search the system for the given package and populate variables with the\n  results.</li>\n<li>find_library The CMake command to search for a library on the system.</li>\n<li>Using pkg-config with CMake</li>\n<li>file The CMake command for numerous file operations.</li>\n<li>execute_process The CMake command to execute a process.</li>\n<li>add_custom_command The CMake command to add a custom command to the build system.</li>\n<li>target_include_directories The CMake command to add include directories to a target.</li>\n<li>target_link_libraries The CMake command to add libraries to link to, to a target.</li>\n</ul>"},{"location":"plugin_README/README_ada/","title":"Ada Setup and Run Guide","text":"<p>Thank you for your interest in Ada : Ada: A Distributed, Power-Aware, Real-Time Scene Provider for XR.</p> <p>This guide provides step-by-step instructions to set up and run the Ada system within the ILLIXR testbed, using the ScanNet dataset.</p>"},{"location":"plugin_README/README_ada/#1-installation","title":"1) Installation","text":"<p>Before building Ada, make sure the following dependencies are installed: - ILLIXR: latest <code>main</code> branch - Jetson Orin (device):   - JetPack \u2265 5.1.3   - DeepStream \u2265 6.3   - CUDA \u2265 11.4 - Server:   - Clang \u2265 10.0.0   - CUDA \u2265 11.4   - DeepStream = 6.3</p>"},{"location":"plugin_README/README_ada/#11-build-and-install-ada-components-in-illixr","title":"1.1 Build and Install Ada Components in ILLIXR","text":""},{"location":"plugin_README/README_ada/#step-1-clone-illixr","title":"Step 1: Clone ILLIXR","text":"<pre><code>git clone git@github.com:ILLIXR/ILLIXR.git\ncd ILLIXR\n</code></pre>"},{"location":"plugin_README/README_ada/#step-2-configure-the-build","title":"Step 2 Configure the Build","text":"<p>Create a build directory and run cmake with Ada components enabled.</p> <p>Replace /path/to/install with the installation directory of your choice.</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake .. \\\n  -DCMAKE_INSTALL_PREFIX=/path/to/install \\\n  -DBUILD_SHARED_LIBS=ON \\\n  -DUSE_ADA.OFFLINE_SCANNET=ON \\\n  -DUSE_TCP_NETWORK_BACKEND=ON \\\n  -DUSE_ADA.DEVICE_TX=ON \\\n  -DUSE_ADA.DEVICE_RX=ON \\\n  -DUSE_ADA.SERVER_RX=ON \\\n  -DUSE_ADA.SERVER_TX=ON \\\n  -DUSE_ADA.INFINITAM=ON \\\n  -DUSE_ADA.MESH_COMPRESSION=ON \\\n  -DUSE_ADA.MESH_DECOMPRESSION_GREY=ON \\\n  -DUSE_ADA.SCENE_MANAGEMENT=ON \\\n  -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"plugin_README/README_ada/#step-3-build","title":"Step 3: Build","text":"<p><pre><code>cmake --build . -j8\n</code></pre> (Adjust -j8 based on the number of cores on your machine.)</p>"},{"location":"plugin_README/README_ada/#step-4-install","title":"Step 4: Install","text":"<pre><code>cmake --install .\n</code></pre>"},{"location":"plugin_README/README_ada/#step-5-update-environment-variables","title":"Step 5: Update Environment Variables","text":"<p>Add the install folder\u2019s lib directory to your LD_LIBRARY_PATH: <pre><code>export LD_LIBRARY_PATH=/path/to/install/lib:$LD_LIBRARY_PATH\n</code></pre> (Add the above line to your .bashrc or .zshrc for persistence across sessions.)</p>"},{"location":"plugin_README/README_ada/#2-setting-up-ada","title":"2) Setting up Ada","text":"<p>To run Ada, you\u2019ll need a device with Jetson-class hardware and a server with an NVIDIA GPU. Below are the configurations we used for reproducibility in the Ada paper.</p> <p>Hardware - Device (required): NVIDIA Jetson Orin AGX   (Ada relies on Jetson\u2019s NVENC/NVDEC capabilities for depth encoding.) - Server (flexible): Any machine with an NVIDIA GPU   (we used an RTX 3080 Ti for our experiments, but other GPUs also work).</p>"},{"location":"plugin_README/README_ada/#3-illixr-configuration","title":"3) ILLIXR Configuration","text":"<p>Ada runs as a set of ILLIXR plugins. To launch it, you need to provide configuration files that specify which plugins to load, where to find the dataset, and Ada specific tuning parameters.</p>"},{"location":"plugin_README/README_ada/#example-device-configuration-file","title":"Example Device Configuration File","text":"<pre><code>plugins: ada.offline_scannet,tcp_network_backend,ada.device_tx,ada.device_rx,ada.mesh_decompression_grey,ada.scene_management\nenv_vars:\n  ILLIXR_RUN_DURATION: 1200\n  ILLIXR_DATA: /home/illixr/Downloads/scannet_0005\n  FRAME_COUNT: 1158\n  FPS: 15\n  PARTIAL_MESH_COUNT: 8\n  MESH_COMPRESS_PARALLELISM: 8\n  ILLIXR_TCP_SERVER_IP:  127.0.0.1\n  ILLIXR_TCP_SERVER_PORT: 9000\n  ILLIXR_TCP_CLIENT_IP: 127.0.0.1\n  ILLIXR_TCP_CLIENT_PORT: 9001\n  ILLIXR_IS_CLIENT: 1\n  ENABLE_OFFLOAD: false\n  ENABLE_ALIGNMENT: false\n  ENABLE_VERBOSE_ERRORS: false\n  ENABLE_PRE_SLEEP: false\n</code></pre>"},{"location":"plugin_README/README_ada/#example-server-configuration-file","title":"Example Server Configuration File","text":"<p><pre><code>plugins: tcp_network_backend,ada.server_rx,ada.server_tx,ada.infinitam,ada.mesh_compression\nenv_vars:\n  ILLIXR_RUN_DURATION: 1200\n  ILLIXR_DATA: /home/illixr/Downloads/scannet_0005\n  FRAME_COUNT: 1158\n  FPS: 15\n  PARTIAL_MESH_COUNT: 8\n  MESH_COMPRESS_PARALLELISM: 8\n  ILLIXR_TCP_SERVER_IP:  127.0.0.1\n  ILLIXR_TCP_SERVER_PORT: 9000\n  ILLIXR_TCP_CLIENT_IP: 127.0.0.1\n  ILLIXR_TCP_CLIENT_PORT: 9001\n  ILLIXR_IS_CLIENT: 0\n  ENABLE_OFFLOAD: false\n  ENABLE_ALIGNMENT: false\n  ENABLE_VERBOSE_ERRORS: false\n  ENABLE_PRE_SLEEP: false\n</code></pre> The above examples set the following environment variables:  - ILLIXR_RUN_DURATION: how long you want to run ILLIXR (in seconds)  - ILLIXR_DATA: the location of the data set  - FRAME_COUNT: the number of frames in your dataset  - FPS: how often you want to trigger proactive scene extraction (Sec 4.2 in the paper)  - PARTIAL_MESH_COUNT: number of parallel compression and decompression of mesh happening (Sec 4.4 in the paper)  - MESH_COMPRESS_PARALLELISM: should match PARTIAL_MESH_COUNT  - ILLIXR_TCP_SERVER_IP: the IP address of the server (can be localhost if testing on one machine)  - ILLIXR_TCP_SERVER_PORT: the port the server should use (your choice)  - ILLIXR_TCP_CLIENT_IP: the IP address of the device (can be localhost if testing on one machine)  - ILLIXR_TCP_CLIENT_PORT: the port the device should use (your choice, must be different from the server port)  - ILLIXR_IS_CLIENT: 1 for device, 0 for server</p>"},{"location":"plugin_README/README_ada/#what-differs-between-device-and-server","title":"What differs between device and server?","text":"<p>The plugin set (device loads offline_scannet, rx/tx, decompression, scene management; server loads rx/tx, InfiniTAM, compression).</p> <p>The role flag: ILLIXR_IS_CLIENT = 1 (device) vs 0 (server).</p>"},{"location":"plugin_README/README_ada/#how-to-understand-ada-specific-parameters-in-yaml","title":"How to Understand Ada-Specific Parameters in YAML","text":"<p>FPS   - Controls the proactive scene extraction rate.   - In our paper\u2019s evaluation, proactive extraction was triggered every N frames (we used every 15 frames).</p> <p>!!!\ufe0f note</p> <pre><code>this name may be confusing since it overlaps with dataset playback rate; we plan to update it in a future release.\n</code></pre> <p>MESH_COMPRESS_PARALLELISM and PARTIAL_MESH_COUNT   - <code>MESH_COMPRESS_PARALLELISM</code>: number of worker threads launched to compress/decompress mesh chunks in parallel.   - <code>PARTIAL_MESH_COUNT</code>: number of chunks the mesh is divided into; the scene management plugin expects this value.   - In the current version, these must match.   - Future support will allow mismatch \u2014 e.g., splitting into 8 chunks but only using 4 compression threads.</p>"},{"location":"plugin_README/README_ada/#4-running-ada","title":"4) Running Ada","text":"<p>To run Ada, open two terminals (one for the server, one for the device). Make sure both shells have <code>LD_LIBRARY_PATH</code> set to include your ILLIXR build directory:</p>"},{"location":"plugin_README/README_ada/#step-1-start-the-server","title":"Step 1: Start the Server:","text":"<pre><code>./main.opt.exe -y your_server_config.yaml\n</code></pre>"},{"location":"plugin_README/README_ada/#step-2-start-the-device","title":"Step 2: Start the Device:","text":"<pre><code>./main.opt.exe -y your_device.config.yaml\n</code></pre>"},{"location":"plugin_README/README_ada/#output","title":"Output:","text":"<ul> <li>If you enable the <code>VERIFY</code> flag in <code>plugins/ada/scene_management/plugin.cpp</code>, Ada will write out a reconstructed mesh at the last update as <code>x.obj</code> (<code>x = FRAME_COUNT/FPS - 1</code>)</li> <li>A <code>recorded_data</code> folder will be created inside your build directory. This folder contains diagnostic and intermediate data collected during the run</li> </ul>"},{"location":"plugin_README/README_ada/#faq","title":"FAQ:","text":""},{"location":"plugin_README/README_ada/#q1-can-i-use-ada-on-a-different-device-than-jetson-orin","title":"Q1: Can I use Ada on a different device than Jetson Orin?","text":"<p>Ada relies on GStreamer with NVIDIA\u2019s DeepStream (NVENC/NVDEC) for efficient depth encoding. In particular, Ada requires the <code>enable-lossless</code> flag for the <code>nvv4l2h265enc</code> / <code>nvv4l2h264enc</code> GStreamer elements. This flag may be missing in some driver + device combinations.</p> <ul> <li>In theory, any NVIDIA GPU with Ampere or newer architecture (30xx series or Jetson Orin and above) supports this capability.</li> <li>However, software support is inconsistent across platforms.</li> <li>For devices that do not support this, we plan to release an alternative version using a prior method (16-bit depth \u2192 HSV color model \u2192 8-bit RGB), which offers the next-best depth preservation.</li> </ul>"},{"location":"plugin_README/README_ada/#q2-how-to-change-the-scene-fidelity","title":"Q2: How to Change the Scene Fidelity","text":"<p>To adjust scene fidelity in Ada: 1. Go to <code>ILLIXR/build/_deps/infinitam_ext-src/ITMLib/Utils/ITMLibSettings.cpp</code> 2. Find line 55: <code>sceneParams(0.1f, 100, 0.02f, 0.2f, 4.0f, false), // 2cm //pyh Ada used config</code>     - The third parameter (0.02f in this example) controls the voxel size.     - Smaller values \u2192 higher fidelity (e.g., 0.02f = 2 cm).     - Larger values \u2192 lower fidelity (e.g., 0.04f = 4 cm, 0.06f = 6 cm). 3. Predefined configurations are available:     - Line 53 \u2192 6 cm voxel size     - Line 54 \u2192 4 cm voxel size     - Line 55 \u2192 2 cm voxel size (default in Ada) 4. After editing, rebuild ILLIXR:   <pre><code>cmake --build . -j8\ncmake --install .\n</code></pre></p>"},{"location":"plugin_README/README_ada/#q3-how-do-i-adjust-the-bitrate-of-lsb","title":"Q3. How do I adjust the bitrate of LSB?","text":"<p>To modify the bitrate used by the LSB encoder, open <code>ILLIXR/utils/video_encoder.hpp</code> and locate line 11 under the <code>#if defined(ADA)</code> block:</p> <pre><code>#define ILLIXR_BITRATE X\n</code></pre> <p>Replace <code>X</code> with your desired bitrate value (in bits per second).</p> <p>Currently, it is set to 0.5 Mbps. Here are some common examples for reference:</p> Target Bitrate Value (bits per second) 50 Mbps 52428800 20 Mbps 20971520 10 Mbps 10485760 5 Mbps 5242880 2 Mbps 2097152 0.5 Mbps 524288"},{"location":"plugin_README/README_ada/#q4-my-extracted-mesh-looks-weird-what-went-wrong","title":"Q4. My extracted mesh looks weird \u2014 what went wrong?","text":"<p>The reconstruction algorithm used in Ada (InfinITAM) is generally robust. If your extracted mesh appears corrupted, distorted, or missing, it usually indicates that depth or pose information was not passed correctly.</p> <p>A missing mesh (nothing is getting updated) often causes a segmentation fault, since the compression stage expects non-empty submesh chunks. If you encounter a segfault, you can verify whether the mesh is missing by printing out the <code>face_number</code> variable in the InfiniTAM plugin located at: <code>build/_deps/infinitam_ext-src/plugin.cpp</code></p> <p><code>face_number</code> is assigned around line 184 \u2014 simply add a <code>printf</code> to check its value. If it prints <code>0</code>, that means the mesh is missing.</p> <p>The most common culprit\u2014based on the author\u2019s experience\u2014is a version mismatch in NVENC support across different GStreamer and NVIDIA DeepStream releases. Even if the pipeline is set up correctly, internal changes in GStreamer or DeepStream may alter the encoding behavior, leading to inconsistent depth reconstruction.</p>"},{"location":"plugin_README/README_ada/#quick-diagnostic-test","title":"Quick diagnostic test","text":"<p>Use the provided helper function in <code>server_rx</code>: <pre><code>write_16_bit_to_pgm()\n</code></pre></p>"},{"location":"plugin_README/README_ada/#q5-anything-changed-since-the-paper","title":"Q5. Anything changed since the paper?","text":"<p>Yes. During the open-sourcing process, the author revisited and refined parts of the implementation.  </p> <p>One key change concerns how depth images are handled in the Most Significant Byte (MSB) and Least Significant Byte (LSB) encoding paths.</p> <p>In the original design, both MSB and LSB components of the depth image were converted to YUV444 format before encoding. However, upon further investigation, the author realized that this is unnecessary for the LSB path \u2014 it can safely use YUV420 instead. Because the depth information is stored entirely in the Y channel, the UV downsampling in YUV420 has no impact on accuracy.</p> <p>As a result, in the open-source version: - LSB encoding has been simplified to use YUV420. - MSB encoding remains in YUV444, since the <code>enable-lossless</code> flag only works with that format.</p> <p>This change makes the LSB pipeline more efficient without affecting reconstruction quality.</p> <p>In short: less code, better results, fewer regrets.</p>"},{"location":"plugin_README/README_ada/#q6-how-do-i-prepare-a-dataset","title":"Q6. How do I prepare a dataset?","text":"<p>If you\u2019d like to try Ada with your own data, the process is similar to the provided ScanNet sequences. You can start by checking out the author\u2019s example datasets here: \ud83d\udc49 Google Drive link</p> <p>Below is a step-by-step guide to prepare a ScanNet sequence for Ada. You can follow the same procedure for other datasets \u2014 as long as you end up with depth, color, and pose files in the same format, you\u2019re good to go.</p>"},{"location":"plugin_README/README_ada/#step-1-download-scannet","title":"Step 1: Download ScanNet","text":"<p>Follow the official instructions here: \ud83d\udd17 ScanNet download</p>"},{"location":"plugin_README/README_ada/#step-2-clone-illixrs-scannet-fork","title":"Step 2: Clone ILLIXR\u2019s ScanNet Fork","text":"<p>Ada uses a modified ScanNet reader compatible with InfiniTAM. Run the following commands: <pre><code>git clone git@github.com:ILLIXR/ScanNet.git\ncd ScanNet\ngit checkout infinitam\ncd SensReader/c++\nmake\n</code></pre></p>"},{"location":"plugin_README/README_ada/#step-3-create-a-sequence-directory","title":"Step 3: Create a Sequence Directory","text":"<p>Create your final dataset directory (outside the repo). It should look like this: <pre><code>scene/\n\u251c\u2500 images/   # depth and color images\n\u2514\u2500 poses/    # associated pose files"},{"location":"plugin_README/README_ada/#step-4-convert-sens-files","title":"Step 4: Convert <code>.sens</code> Files","text":"<p>Use SensReader to extract calibration, pose, color, and depth images.\nSee the instructions here:\nScanNet SensReader C++</p>\n<p>Example:\n<pre><code>./sens /path/to/scannet/scans/scene0000_00/scene0000_00.sens        /path/to/scenes/scene0000/images\n</code></pre></p>"},{"location":"plugin_README/README_ada/#step-5-convert-to-infinitam-format","title":"Step 5: Convert to InfiniTAM Format","text":"<p>Finally, convert the extracted data into the InfiniTAM-compatible format:\n<pre><code>cd ILLIXR/plugins/ada\npython3.8 convert_scannet.py --source-dir /path/to/scenes/scene/images"},{"location":"plugin_README/README_ada/#q7-how-do-i-ensure-the-timing-is-relatively-accurate","title":"Q7. How do I ensure the timing is relatively accurate?","text":"<p>Unfortunately, getting accurate scene update timing requires synchronized clocks across server and device.\nIn this project, the author used NTP (Network Time Protocol) to keep the clocks of two Linux devices in sync.</p>\n<p>Before starting your experiment, pick one device as the reference and run the following on the other device:</p>\n<p><pre><code>sudo apt install ntpdate -y\n\n# Stop Ubuntu's default time sync service\nsudo systemctl stop systemd-timesyncd.service\n\n# (Optional) Stop ntpd if it's running\nsudo systemctl stop ntp.service\n\n# Make sure on the server side edit your /etc/ntp.conf and add\nallow ip_of_your_other_device\n\n#enable your ntp service\nsudo systemctl enable --now ntp\n\n# Sync clock with the reference device\nsudo ntpdate \n\nIt\u2019s best to perform this synchronization before every trial to minimize drift. Even after NTP synchronization, there can still be small timing offsets \u2014 typically on the order of a few milliseconds \u2014 due to network latency and OS scheduling.\nThis isn\u2019t perfect, but it\u2019s usually accurate enough for most Ada experiments.\nIf you need tighter timing guarantees, you\u2019d need hardware-level synchronization (e.g., PTP or GPS-based time sources), which is a different level of pain."},{"location":"plugin_README/README_ada/#q8-why-name-your-system-ada-any-meaning-behind-it","title":"Q8. Why name your system Ada? Any meaning behind it?","text":"<p>Because my first cat, Ada, has been faithfully supervising the development of this system \u2014 usually from the comfort of my \"server\" case. \ud83d\udc08\u200d\u2b1b\nIt only felt right to acknowledge her invaluable contributions (moral support, occasional bug introductions, and mandatory break reminders).</p>\n<p>\n  \n  Ada\n</p>\n\n<p>Unfortunately, I cannot list Ada as a co-author,\nso naming the system Ada was the next best way to give her the credit she deserves.</p>"},{"location":"plugin_README/README_ada/#questions","title":"Questions?","text":"<p>If you have any other questions, issues, or general confusion regarding Ada,\nfeel free to reach out to the author at \ud83d\udce7 yihanp2@illinois.edu.\nHe might even reply faster than your compile finishes (except in the mornings).</p>"},{"location":"plugin_README/README_ada/#acknowledgments","title":"Acknowledgments","text":"<p>This work is part of our ISMAR/TVCG 2025 paper. See the paper for full technical details.\nThanks to the ILLIXR community for support and integration.</p>\n<p>Lastly, the author would like to thank Doug Friedel and Qinjun Jiang for their invaluable help with the Ada integration and testing process.</p>"},{"location":"plugin_README/README_debugview/","title":"debugview","text":""},{"location":"plugin_README/README_debugview/#summary","title":"Summary","text":"<p><code>debugview</code> is a simple debugging view for the ILLIXR system. By subscribing to several Switchboard endpoints, many important datapoints can be observed to help debug issues with the runtime. The debug view shows the current calculated SLAM pose and the (optional) ground truth pose read from the ground truth dataset as 3D headset models drawn on a backdrop scene. In addition, camera and IMU data is also visible, with the stereoscopic onboard camera views shown in one of the windows. Various offsets can be applied to the generated poses to aid in viewing. Dear ImGUI is used for displaying data and providing an interactive interface.</p>"},{"location":"plugin_README/README_debugview/#switchboard-connection","title":"Switchboard connection","text":"<ul> <li><code>debugview</code> subscribes to the slow-pose, which represents the latest pose published by the SLAM/IMU system.</li> <li>In the future, <code>debugview</code> will also query for the most up-to-date predicted pose through an RPC-like query system.   This is not currently in our release version; but is in development and will be added soon. The \"fast pose\" referenced   in this plugin just samples the <code>slow_pose</code> instead.</li> <li><code>debugview</code> also is synchronously dependent on the <code>imu_cam</code> topic, as the stereoscopic camera views are displayed in   the debug window. In ILLIXR, \"synchronous dependencies\" are implemented as scheduled \"handlers\" that are executed from   a shared thread pool; this handler is executed every time a fresh \"packet\" is available from the <code>imu_cam</code> topic.   Given that this is a separate thread from the main graphics thread, this <code>imu_cam</code> packet must be saved/cached for   later, when the graphics thread renders the next frame. This is a good example to follow when writing your own   multithreaded components that use both synchronous and asynchronous dependencies, and need to share information across   dependency boundaries.</li> </ul>"},{"location":"plugin_README/README_debugview/#environment-variables","title":"Environment Variables","text":"<p>DEBUGVIEW_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p>"},{"location":"plugin_README/README_debugview/#notes","title":"Notes","text":"<p><code>debugview</code> will be under heavy development in the near-term. Pull requests may or may not be accepted, due to the frequency of rapid internal changes.</p>"},{"location":"plugin_README/README_debugview/#known-issues","title":"Known Issues","text":"<p>Currently, the poses returned from the SLAM system have an incorrect initial rotation, as the poses are returned in an incorrect frame of reference. Thus, the headsets may appear to be tilted incorrectly; the button \"calculate new orientation offset\" will reset the orientation, such that the current orientation is considered the \"neutral\" orientation. In a future update, the correct frame of reference/transform matrix will be applied and the pose will accurately reflect the actual head position.</p>"},{"location":"plugin_README/README_debugview/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_fauxpose/","title":"FauxPose ILLIXR plugin","text":""},{"location":"plugin_README/README_fauxpose/#summary","title":"Summary","text":"<p>The <code>FauxPose</code> ILLIXR plugin generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking.</p> <p>The movement is hard-coded to be on the Y=center.y plane, with the X and Z values set to rotate in a circle. The period and amplitude of the movement are have default values (0.5, and 2.0 respectively) that can be changed through environment variables.</p> <pre><code>Topic details:\n-   *Publishes* `pose_position` on `fast_pose` topic.\n</code></pre>"},{"location":"plugin_README/README_fauxpose/#usage","title":"Usage","text":"<p>The \"FauxPose\" plugin must be included in the YAML configuration file prior to any rendering plugin (such as  <code>debugview</code> or <code>gldemo</code>). Also, no other pose-generating plugin should be included.</p> <p>An example <code>profiles/fauxpose.yaml</code> configuration file is included as an example.</p> <p>By default, the \"orbit\" of the tracked position will be about the point (0.0, 1.5, 0.0), with a default amplitude of \" 2.0\", and period of \"0.5\" seconds, with the orientation facing the negative-X direction. The first three of these values can be overridden through environment variables:</p> <pre><code>- FAUXPOSE_PERIOD=\n- FAUXPOSE_AMPLITUDE=\n- FAUXPOSE_CENTER="},{"location":"plugin_README/README_gldemo/","title":"gldemo","text":""},{"location":"plugin_README/README_gldemo/#summary","title":"Summary","text":"<p>The <code>gldemo</code> plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>gldemo</code> will subscribe to several switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the Switchboard API. <code>gldemo</code> is intended to be as lightweight as possible, serving as a baseline debug \" dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; <code>gldemo</code> fills this requirement. As an important note, <code>gldemo</code> does not render stereoscopically; the two eye renders are rendered from the same position. This may be updated to render stereoscopically in the future, but is not seen as a critical feature as this is generally intended as a debugging tool.</p>"},{"location":"plugin_README/README_gldemo/#switchboard-connection","title":"Switchboard connection","text":"<p><code>gldemo</code> subscribes to and publishes to several switchboard plugs. Most notably, <code>gldemo</code> subscribes to the <code>fast_pose</code> plug, which (ideally) represents the most recent extrapolated pose. This connection represents an area of active development in ILLIXR, as we are replacing the pose subscription with an RPC-like proper pose prediction system. As of the time of writing, <code>fast_pose</code> is functionally identical to the <code>slow_pose</code> published by the SLAM system, but this will change when proper pose extrapolation is implemented. <code>gldemo</code> also pulls the correct graphics context from Phonebook.</p> <p><code>gldemo</code> publishes the rendered eyebuffers to the Switchboard system as well, using whichever eyebuffer format has been selected with the <code>USE_ALT_EYE_FORMAT</code> compile-time macro. The alternative eye format is more similar to the format used by Monado/OpenXR, and is more fully explained by the code comments.</p>"},{"location":"plugin_README/README_gldemo/#environment-variables","title":"Environment Variables","text":"<p>GLDEMO_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p>"},{"location":"plugin_README/README_gldemo/#notes","title":"Notes","text":"<p><code>gldemo</code> does not pretend to be an OpenXR application; it does not use the OpenXR API, nor does it follow typical OpenXR patterns. It hooks directly into the Switchboard system and is intended as a debug/visualization tool. For more accurate and representative testing, consider running ILLIXR with an actual OpenXR application.</p>"},{"location":"plugin_README/README_gldemo/#known-issues","title":"Known Issues","text":"<p>As noted above, <code>gldemo</code> does not actually render stereoscopically, and the two eye buffers are rendered from the same eye location. (This is not to say that the two eye buffers are not rendered separately; they are actually two separate draw calls.) In addition, the quality of the pose used by <code>gldemo</code> is dependent on the upstream pose, which is currently not extrapolated/predicted and is subject to change.</p>"},{"location":"plugin_README/README_gldemo/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and are a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_hand_tracking/","title":"Hand Tracking","text":""},{"location":"plugin_README/README_hand_tracking/#summary","title":"Summary","text":"<p><code>hand_tracking</code> and <code>hand_tracking_gpu</code> are plugins which detects hands in an image. The plugins integrate the Mediapipe hand landmark detectionE11 algorithm into the ILLIXR framework. The only difference between <code>hand_tracking</code> and <code>hand_tracking_gpu</code> are where the data are processed: CPU vs GPU. Their operation and interface are identical. ( Currently the GPU version is a work in progress.)</p>"},{"location":"plugin_README/README_hand_tracking/#switchboard-connection","title":"Switchboard connection","text":"<p>The <code>hand_tracking</code> plugin subscribes to the webcam to get the input images to process. Future development will allow this plugin to subscribe to other input types dynamically, depending on the users' needs. The plugin utilizes the following data structures</p> <ul> <li>rect: representation of a rectangle<ul> <li>x_center: x-coordinate of the rectangle center</li> <li>y_center: y-coordinate of the rectangle center</li> <li>width: width of the rectangle</li> <li>height: height of the rectangle</li> <li>rotation: rotation angle of the rectangle in radians</li> <li>normalized: boolean indicating the units; <code>true</code> indicates normalized units [0..1] of the input image, <code>false</code>   indicates pixel units</li> <li>valid: boolean indicating whther the object is valid</li> </ul> </li> <li>point: representation of a 3D point<ul> <li>x: x-coordinate</li> <li>y: y-coordinate</li> <li>z: z-coordinate (not an absolute distance, but a measure of the point's depth relative to other points)</li> <li>normalized: boolean indicating the units; <code>true</code> indicates normalized units [0..1] of the input image, <code>false</code>   indicates pixel units</li> <li>valid: boolean indicating whther the object is valid</li> </ul> </li> </ul> <p>Note</p> <p>All coordinates in these data are normalized to the input image size</p> <p>The plugin published an <code>ht_frame</code> which contains the following data</p> <ul> <li>detections: the raw information produced by the mediapipe code, x and y coordinates are normalized to the input   image size, and z has no meaning<ul> <li>left_palm: rect which encloses the left palm, if detected</li> <li>right_palm: rect which encloses the right palm, if detected</li> <li>left_hand: rect which encloses the entire left hand, if detected</li> <li>right_hand: rect which encloses the entire right hand, if detected</li> <li>left_confidence: float indicating the detection confidence of the left hand [0..1]</li> <li>right_confidence: float indicating the detection confidence of the right hand [0..1]</li> <li>left_hand_points: vector of the 21 point objects, one for each hand landmark, from the left hand, if detected</li> <li>right_hand_points: vector of the 21 point objects, one for each hand landmark, from the right hand, if detected</li> <li>img: cv::Mat in <code>CV_8UC4</code> format (RGBA), representing the detection results</li> </ul> </li> <li>hand_positions: map of detected points for each hand, if depth cannot be determined then the value for that axis   will have no meaning (axis will depend on the coordinate reference frame), coordinate origin is defined by the user at   startup</li> <li>hand_velocities: map of velocities for each detected point for each hand, requires that depth is known or   calculated, and the last iteration of the code produced valid results, the units unit per second</li> <li>offset_pose: a pose, that when removed from each point, will give coordinates relative to the camera</li> <li>reference: the coordinate reference space (e.g. left hand y up)</li> <li>unit: the units of the coordinate system</li> </ul> <p>Info</p> <p>The detections may be removed or re-worked in future releases </p> <p>Each vector of hand points contains 21 items which reference the following ( from https://ai.google.dev/edge/mediapipe/solutions/vision/hand_landmarker)</p> <p></p> <p>The <code>landmark_points</code> <code>enum</code> can be used to reference the individual points in each vector</p> <pre><code>ht.left_hand_points[THUMB_TIP]\n</code></pre> <p>will get the <code>point</code> for the tip of the left thumb.</p>"},{"location":"plugin_README/README_hand_tracking/#environment-variables","title":"Environment Variables","text":"<p>The hand tracking utilizes the following environment/yaml file variables to control its processing:</p> <ul> <li>HT_INPUT: the type of images to be fed to the plugin. Values are<ul> <li>zed</li> <li>cam (for typical cam_type/binocular images)</li> <li>webcam (single image)</li> </ul> </li> <li>HT_INPUT_TYPE: descriptor of what image(s) to use. Values are<ul> <li>LEFT - only use the left eye image from an input pair</li> <li>SINGLE - same as LEFT</li> <li>RIGHT - only use the right eye image from an input pair</li> <li>MULTI - use both input images</li> <li>BOTH - same as MULTI</li> <li>RGB - only a single input image</li> </ul> </li> <li>WCF_ORIGIN: the origin pose of the world coordinate system as a string of three, four, or seven numbers. The   numbers should be comma separated with no spaces.<ul> <li>x,y,z - three coordinate version, representing the position of the origin pose (quaternion will be 1,0,0,0)</li> <li>w,wx,wy,wz - four coordinate version, representing the quaternion of the origin pose (position will be 0,0,0)</li> <li>x,y,z,w,wx,wy,wz - seven coordinate version, representing the full origin pose</li> </ul> </li> </ul>"},{"location":"plugin_README/README_hand_tracking/#helper-plugins","title":"Helper plugins","text":"<p>There are two additional plugins which are designed to aid in debugging the <code>hand_tracking</code> plugin.</p>"},{"location":"plugin_README/README_hand_tracking/#viewer","title":"Viewer","text":"<p>The <code>hand_tracking.viewer</code> plugin subscribes to the output of the <code>hand_tracking</code> plugin and displays the results, both graphically and in tabular format.</p>"},{"location":"plugin_README/README_hand_tracking/#webcam","title":"Webcam","text":"<p>The <code>webcam</code> plugin can feed single frame images to the hand tracking plugin.</p>"},{"location":"plugin_README/README_hand_tracking/#openxr","title":"OpenXR","text":"<p>The hand tracking plugin can be built with an OpenXR interface. To build the interface add <code>-DBUILD_OXR_INTERFACE=ON</code> to your cmake command line. The interface itself is in libopenxr_illixr_ht.so and is designed to be an API Layer. It installs a json file in the user's <code>.local</code> directory and is automatically detected by libopenxr_loader.so To use the layer you will need both an OpenXR application and runtime. This code is known to be compatible with the Monado runtime, and should be compatible with others. Currently, the hand tracking must receive that data from ILLIXR, but as an API Layer the resulting calculations can be retrieved via OpenXR API calls.</p>"},{"location":"plugin_README/README_hand_tracking/#api","title":"API","text":"<p>The hand tracking API can be found here.</p>"},{"location":"plugin_README/README_lighthouse/","title":"Lighthouse","text":""},{"location":"plugin_README/README_lighthouse/#summary","title":"Summary","text":"<p>The <code>lighthouse</code> plugin supports lighthouse tracking using the libsurvive library. To use this plugin, libsurvive should first be built, installed, and calibrated according to their documentation. Running ILLIXR's CMake to build the <code>lighthouse</code> plugin should automatically build and install <code>libsurvive</code>, but the steps to calibrate the lighthouses should still be followed.</p>"},{"location":"plugin_README/README_lighthouse/#note","title":"Note","text":"<p>If the <code>lighthouse</code> plugin is being used, make sure to set the environment variable <code>ILLIXR_LIGHTHOUSE</code> to true, as the <code>pose_prediction</code> relies on it.</p>"},{"location":"plugin_README/README_native_renderer/","title":"native_renderer","text":""},{"location":"plugin_README/README_native_renderer/#summary","title":"Summary","text":"<p><code>native_renderer</code> utilizes <code>vkdemo</code> and <code>timewarp_vk</code> to construct a full rendering pipeline.  <code>vkdemo</code> is used to render the scene, and <code>timewarp_vk</code> is used to perform rotational reprojection. This plugin creates the necessary Vulkan resources and targets for <code>vkdemo</code> and <code>timewarp_vk</code> to render to, and then composites the results into a single image. The resulting image is presented using the Vulkan swapchain provided by <code>display_vk</code>.</p>"},{"location":"plugin_README/README_native_renderer/#environment-variables","title":"Environment Variables","text":"<p>NATIVE_RENDERER_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \" error\", \"critical\", or \"off\"</p>"},{"location":"plugin_README/README_offload_rendering_client/","title":"offload_rendering_client","text":""},{"location":"plugin_README/README_offload_rendering_client/#summary","title":"Summary","text":"<p><code>offload_rendering_client</code> receives encoded frames from the network, and uses a mix of NPPI and FFMPEG to decode the frames before updating the buffer pool. Setting the environment variable <code>ILLIXR_USE_DEPTH_IMAGES</code> to a non-zero value indicates that depth images are being received, and should thus also be decoded.</p> <p>Note that there is a known color shift issue (to be fixed), where the decoded frame's colors are slightly different from the original frame (likely due to the many conversions between YUV and RGBA).</p> <p>Please refer to the README in <code>tcp_network_backend</code> for setting the server and client IP address and port number.</p>"},{"location":"plugin_README/README_offload_rendering_server/","title":"offload_rendering_server","text":""},{"location":"plugin_README/README_offload_rendering_server/#summary","title":"Summary","text":"<p><code>offload_rendering_server</code> encodes frames using FFMPEG and transmits them to the client with the network_backend from switchboard. In addition to the frame, some additional information is also transmitted, e.g., the pose used for the rendered frame so that the client can reprojected the decoded frame accordingly.</p> <p>Relevant environment variables include:   - <code>ILLIXR_USE_DEPTH_IMAGES</code> set to non-zero will encode/transmit depth images.   - <code>ILLIXR_OFFLOAD_RENDERING_BITRATE</code> sets the encoding bitrate.   - <code>ILLIXR_OFFLOAD_RENDERING_FRAMERATE</code> sets the encoding framerate.   - <code>ILLIXR_OFFLOAD_RENDERING_NALU_ONLY</code> set to non-zero indicates a Jetson client.</p> <p>Please refer to the README in <code>tcp_network_backend</code> for setting the server and client IP address and port number.</p> <p>Note</p> <p>Note that at the moment, the <code>offload_rendering_server</code> only supports Monado + OpenXR apps, and does not offload the native demos.</p>"},{"location":"plugin_README/README_offload_vio/","title":"Offload VIO","text":""},{"location":"plugin_README/README_offload_vio/#summary","title":"Summary","text":"<p><code>offload_vio</code> implements the functionality of moving VIO (Visual Inertial Odometry) to some server. There are four plugins that handle transmission (<code>_tx</code>) and reception (<code>_rx</code>) of data on the client (<code>device</code>) and server (<code>server</code>) respectively.</p>"},{"location":"plugin_README/README_offload_vio/#usage","title":"Usage","text":"<p>In order to run offloading vio, you need the following extra dependecies</p> <pre><code>sudo add-apt-repository ppa:ecal/ecal-latest\nsudo apt-get update\nsudo apt-get install ecal\nsudo apt-get install libprotobuf-dev protobuf-compiler\n</code></pre> <p>Please refer to the README in <code>tcp_network_backend</code> for setting the server and client IP address and port number.</p> <p>The most simple example is running the offloaded setup on one machine with the server running in one terminal and the device running in a different terminal. Each terminal must be running from separate ILLIXR repositories (clone ILLIXR twice to different locations; running both the server and device from the same ILLIR repository will cause lock issues).</p> <p>Start the server using</p> <pre><code>main.opt.exe --yaml=profiles/offload_vio_server.yaml --data=&lt;&gt; --demo_data=&lt;&gt;\n</code></pre> <p>in one terminal and</p> <pre><code>main.opt.exe --yaml=profiles/offload_vio_device.yaml --data=&lt;&gt; --demo_data=&lt;&gt;\n</code></pre> <p>in the other terminal for the client. This will run OpenVINS on the server and will feed it with the EuRoC dataset ( replace &lt;&gt; in --data with <code>data</code>) from the device.</p> <p>To run the client and server on different machines, please again refer to the README in <code>tcp_network_backend</code> for setting appropriate server IP address and port number.</p>"},{"location":"plugin_README/README_offload_vio/#compression","title":"Compression","text":"<p>H.264 codec is supported for compressing the camera images to save bandwidth. To enable compression, define <code>USE_COMPRESSION</code> and <code>VIO</code> in <code>device_tx/plugin.cpp</code> and <code>server_rx/plugin.cpp</code> (defaulted to not enabled). In <code>include/illixr/video_encoder.hpp</code> and <code>include/illixr/video_decoder.hpp</code>, define appropriate image dimensions and desired target bitrate (defaults to 5Mbps). The codec library is implemented based on GStreamer and DeepStream. Please follow the instructions here to install GStreamer and DeepStream SDK. You don't have to reinstall CUDA and NVIDIA Driver if you have a relatively new version. TensorRT and librdkafka are not required either.</p>"},{"location":"plugin_README/README_openni/","title":"OpenNI","text":""},{"location":"plugin_README/README_openni/#set-camera-mode","title":"Set Camera Mode","text":"<p>If you wish to switch up the video modes of OpenNI, update these two macros in <code>openni/plugin.cpp</code> accordingly: <pre><code>#define RGB_MODE 0\n#define DEPTH_MODE 0\n</code></pre></p> <p>You can see the list of available modes once you run ILLIXR the first time. </p>"},{"location":"plugin_README/README_openni/#debugging","title":"Debugging","text":"<p><pre><code>Device open failed:     DeviceOpen using default: no devices found\n</code></pre> Solution: No OpenNI compatible device is plugged in. So plug one in</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": USB transfer timeout!\n</code></pre> Solution: This is usually fixed by unplug and plug back in.</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": Failed to open the USB device!\n</code></pre> Solution: Fix by running with sudo </p>"},{"location":"plugin_README/README_openni/#environment-variables","title":"Environment Variables","text":"<p>OPENNI_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"critical\", or \"off\"</p>"},{"location":"plugin_README/README_openwarp_vk/","title":"openwarp_vk","text":""},{"location":"plugin_README/README_openwarp_vk/#summary","title":"Summary","text":"<p><code>openwarp_vk</code> is a Vulkan-based translational reprojection service intended for use in the ILLIXR architecture.</p>"},{"location":"plugin_README/README_openwarp_vk/#phonebook-service","title":"Phonebook Service","text":"<p><code>openwarp_vk</code> is registered as a service in phonebook, conforming to the <code>timewarp</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a   specific render pass and subpass, to which <code>openwarp_vk</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> calculates the reprojection matrix given the current pose and the pose   used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before   <code>record_command_buffer</code> is called</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int left)</code> records the commands into a given command buffer that   would perform the reprojection for one eye, for which 1 is left and 0 is right</li> </ul> <p>Note</p> <p>Note that at the moment, OpenWarp assumes that a reverse depth buffer is being used (as in Unreal Engine, Godot, and our native demo). If you're using an application that uses forward depth, the projection matrices and Vulkan pipeline configuration should be updated accordingly.</p>"},{"location":"plugin_README/README_orb_slam3/","title":"ORB-SLAM","text":"<p>This plugin uses the ORB-SLAM3 library for real-time VIO.</p>"},{"location":"plugin_README/README_record_imu_cam/","title":"Record IMU Cam","text":"<p>The purpose of this plugin is to record a dataset, similar to the EuRoC MAV dataset that includes the IMU data and Cam images.</p>"},{"location":"plugin_README/README_record_imu_cam/#how-to-record-a-dataset","title":"How to record a dataset","text":"<p>Add <code>record_imu_cam</code> to either your input yaml file or to your <code>--plugins</code> argument when invoking the ILLIXR executable.</p> <p>After recording, the dataset will be stored in the ILLIXR project directory, with the following structure:</p> <pre><code>ILLIXR/data_record\n    \\_ cam0/\n        \\_ data/ \n            \\_ timestamp.png\n            \\_ ...\n        \\_ data.csv\n    \\_ cam1/\n        \\_ data/\n            \\_ timestamp.png\n            \\_ ...\n        \\_ data.csv\n    \\_ imu0\n        \\_ data.csv\n</code></pre>"},{"location":"plugin_README/README_record_imu_cam/#format","title":"Format","text":"<ol> <li><code>cam0/data.csv</code> and <code>cam1/data.csv</code> are both formatted as<pre><code>timestamp [ns], timestamp.png\n</code></pre> <ol> <li> <p><code>imu0/data.csv</code> is formatted as</p> <p>timestamp [ns],w_x [rad s^-1],w_y [rad s^-1],w_z [rad s^-1],a_x [m s^-2],a_y [m s^-2],a_z [m s^-2]</p> </li> </ol> </li> </ol>"},{"location":"plugin_README/README_record_imu_cam/#how-to-rerun-recorded-dataset","title":"How to rerun recorded dataset","text":"<ol> <li> <p>(IMPORTANT) Do not specify <code>record_imu_cam</code> in either your input yaml file or to your <code>--plugins</code> argument when    invoking the ILLIXR executable.</p> </li> <li> <p>When running the ILLIXR executable do one of the following:</p> <ul> <li>In the input yaml file add a line to the <code>env_vars</code> section: <code>data: &lt;PATH_TO_ILLIXR&gt;/data_record</code></li> <li>Add <code>--data=&lt;PATH_TO_ILLIXR&gt;/data_record</code> to the command line arguments</li> <li>Set the environment variable <code>ILLIXR_DATA</code> to <code>&lt;PATH_TO_ILLIXR&gt;/data_record</code></li> </ul> </li> <li> <p>Make sure other plugins that feed images and IMU are not being used, such as <code>offline_cam</code>,     <code>offline_imu</code>, <code>zed</code>, and <code>realsense</code>.</p> </li> </ol>"},{"location":"plugin_README/README_timewarp_gl/","title":"timewarp_gl","text":""},{"location":"plugin_README/README_timewarp_gl/#summary","title":"Summary","text":"<p><code>timewarp_gl</code> is an OpenGL-based asynchronous rotational reprojection plugin intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).</p>"},{"location":"plugin_README/README_timewarp_gl/#switchboard-connection","title":"Switchboard connection","text":"<p><code>timewarp_gl</code> subscribes to and publishes to several Switchboard plugs and Phonebook resources.</p> <ul> <li>The plugin grabs the GL context from Phonebook. This is necessary to share the eyebuffers with the rendering   application (or <code>gldemo</code>). As this is an OpenGL-based reprojection plugin, it relies on OpenGL   resources for the eyebuffers.</li> <li><code>timewarp_gl</code> subscribes to the most recent pose published by the system. Currently, as our pose-prediction system is   still under development, this is not technically accurate; the final, intended functionality is that the timewarp   plugin will sample a pose prediction algorithm through an RPC-like mechanism. As we complete our work on our pose   prediction system, this plugin will be modified to use this mechanism.</li> <li><code>timewarp_gl</code> also subscribes to the most recent frame published by the system. This frame data also includes the pose   that was used to render the frame; this is how the timewarp algorithm calculates the \"diff\" to be used to reproject   the frame.</li> </ul>"},{"location":"plugin_README/README_timewarp_gl/#environment-variables","title":"Environment Variables","text":"<p>TIMEWARP_GL_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p> <p>ILLIXR_TIMEWARP_DISABLE: whether to disable warping, values can be \"True\" or \"False\" (default)</p> <p>ILLIXR_OFFLOAD_ENABLE: whether to enable offloading, values can be \"True\" or \"False\" (default)</p>"},{"location":"plugin_README/README_timewarp_gl/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.</p>"},{"location":"plugin_README/README_timewarp_gl/#known-issues","title":"Known Issues","text":"<p>As noted above, this plugin currently samples <code>slow_pose</code>. This will be changed to sample a <code>fast_pose</code> topic through an RPC mechanism. In addition, JMP Van Waveren's algorithm includes a method for warping between two reprojection matrices based on the actual progress of the display controller's \"scanline\"; this is simply commented out in our code, but can be re-enabled when our pose prediction system comes online.</p>"},{"location":"plugin_README/README_timewarp_gl/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_timewarp_vk/","title":"timewarp_vk","text":""},{"location":"plugin_README/README_timewarp_vk/#summary","title":"Summary","text":"<p><code>timewarp_vk</code> is a Vulkan-based rotational reprojection service intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).</p>"},{"location":"plugin_README/README_timewarp_vk/#phonebook-service","title":"Phonebook Service","text":"<p><code>timewarp_vk</code> is registered as a service in phonebook, conforming to the <code>timewarp</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a   specific render pass and subpass, to which <code>timewarp_vk</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> calculates the reprojection matrix given the current pose and the pose   used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before   <code>record_command_buffer</code> is called</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int left)</code> records the commands into a given command buffer that   would perform the reprojection for one eye, for which 1 is left and 0 is right</li> </ul>"},{"location":"plugin_README/README_timewarp_vk/#environment-variables","title":"Environment Variables","text":"<p>ILLIXR_TIMEWARP_DISABLE: whether to disable the warping, values can be \"True\" or \"False\"(default)</p>"},{"location":"plugin_README/README_timewarp_vk/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.</p>"},{"location":"plugin_README/README_vkdemo/","title":"vkdemo","text":""},{"location":"plugin_README/README_vkdemo/#summary","title":"Summary","text":"<p>The <code>vkdemo</code> service serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>vkdemo</code> will subscribe to several switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the switchboard API. <code>vkdemo</code> is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the  HMD display without needing to use the full OpenXR interface; <code>vkdemo</code> fills this requirement.</p>"},{"location":"plugin_README/README_vkdemo/#phonebook-service","title":"Phonebook Service","text":"<p><code>vkdemo</code> is registered as a service in phonebook, conforming to the <code>app</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a   specific render pass and subpass, to which <code>vkdemo</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> updates the uniform buffer with the given pose, which is used to render   the scene. This must be called before <code>record_command_buffer</code> is called.</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int eye)</code> records the commands into a given command buffer that   would perform the rendering for one eye, for which 0 is left and 1 is right. To achieve stereoscopic rendering, the   function is called twice, once for each eye.</li> <li><code>virtual void destroy()</code> cleans up the resources allocated by <code>vkdemo</code>. Currently, this part is not yet implemented.</li> </ul>"},{"location":"plugin_README/README_webcam/","title":"Webcam","text":""},{"location":"plugin_README/README_webcam/#webcam","title":"Webcam","text":"<p>The <code>webcam</code> plugin opens the attached webcam, captures images at 30 frames per second, and publishes them on the <code>webcam</code> topic as <code>monocular_cam_type</code>. The images are in cv::Mat format with color order RGB. Depending on your needs, you may  need to flip the images over the vertical axis. This plugin is intended mostly for testing and debugging other plugins.</p> <pre><code>    cv::flip(image, image, 1);\n</code></pre>"},{"location":"plugin_README/README_zed/","title":"ZED Mini","text":""},{"location":"plugin_README/README_zed/#getting-started","title":"Getting started","text":"<ul> <li>First, download the latest version of the ZED SDK on stereolabs.com.</li> <li>For more information, read the ZED API documentation.</li> </ul>"},{"location":"plugin_README/README_zed/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ubuntu 22.04 or 24.04</li> <li>CUDA</li> <li>ZED SDK</li> <li>OpenCV 4</li> </ul>"},{"location":"plugin_README/README_zed_data_injection/","title":"ZED Data Injection","text":"<p>This plugin reads in binocular images and pose information from files on disk and publishes them to ILLIXR. It is designed to feed data recorded by the zed_capture binary into the ILLIXR system. The root directory of the data must be specified in the <code>ILLIXR_TEST_DATA</code> environment variable.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/","title":"Monado Integration Overview","text":"<p>ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to force developers to write their whole application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR, so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado, an existing, open-source implementation of the standard.</p> <ul> <li> <p>When running ILLIXR without Monado, the ILLIXR runtime is the entry-point.     Phonebook and switchboard are initialized and plugins are loaded, among which is the vkdemo app.</p> </li> <li> <p>When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a   result, the ILLIXR runtime system is loaded at a later point as a shared library. This page documents the changes to   the ILLIXR runtime when an OpenXR application is used.</p> </li> </ul>"},{"location":"plugin_README/monado_illixr_runtime_overview/#openxr-application-launch","title":"OpenXR Application Launch","text":"<p>As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronos Group for more details.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#monado-device-probe-and-illixr-initialization","title":"Monado Device Probe and ILLIXR Initialization","text":"<p>During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as <code>xdev</code>s. Our ILLIXR driver will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The driver obtains the path to the ILLIXR runtime <code>.so</code> file and a list of plugins from environment variables.</p> <p>After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the ILLIXR driver. At this moment, all necessary data is ready and ILLIXR will be launched.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#illixr-runtime-launch","title":"ILLIXR Runtime Launch","text":"<p>When used with Monado, the ILLIXR Runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing the switchboard and phonebook, and loading plugins.</p> <p>The driver starts to load the runtime by loading the shared library into the current     (application's) address space and calls the Switchboard and Phonebook initialization. Then, it calls the plugin loading for each ILLIXR plugin     (except [<code>vkdemo</code>][28], which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path     to load a Translation Plugin into ILLIXR as the application. If the plugin implements a long-running computation, it may block the main ILLIXR thread     which drives the entire application. To remedy this, a plugin should implement long-running processing in its own thread. This way, the driver will be able to reacquire control and return to Monado     and the application efficiently.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#translation-plugin","title":"Translation Plugin","text":"<p>When the application and all ILLIXR plugins are up and running, the translation plugin handles the connection between Monado and ILLIXR. It might be confusing to see that this plugin is part of the ILLIXR driver which is part of Monado while at the same time also part of ILLIXR as a plugin. However, Monado and ILLIXR are running in different threads in the same address space. The translation plugin is the interface of these two parallel systems.</p> <p>The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, the translation plugin is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of ILLIXR, the translation plugin behaves the same as the <code>vkdemo</code> application: reading pose and submitting frames.</p> <p>For implementation details regarding the representation of poses and frames in Monado and in ILLIXR, please see ILLIXR's Monado Integration Dataflow.</p>"},{"location":"plugin_README/monado_integration_dataflow/","title":"Monado Integration Dataflow","text":"<p>The dataflow for the ILLIXR Monado integration comprises two steps:</p> <ol> <li>getting pose data from ILLIXR,</li> <li>sending a user rendered frame back to ILLIXR.</li> </ol> <p>In Monado, ILLIXR is recognized as an HMD for Monado, while in ILLIXR, Monado looks like a user application ( such as <code>vkdemo</code>). After ILLIXR is initialized from Monado, and Monado is registered as a plugin for ILLIXR, the most recent pose information can be easily obtained via the switchboard.</p> <p>The compositor side of Monado integration with ILLIXR is implemented more subtly. The original Monado compositor primarily performs distortion correction and aberration correction in a Vulkan back-end compositor. The compositor also has one, Vulkan based,  client compositor which passes frame data to the back-end compositor.</p> <p>The current ILLIXR integration for Monado is a temporary solution and has some drawbacks caused by the concurrent and continued development from both the Monado and ILLIXR projects. The integration:</p> <ol> <li> <p>Does not use the pose that user application declares to use at rendering (using the OpenXR specification). This is    due to incongruence with Monado's internal interfaces and representations. The pose difference used by     <code>timewarp_vk</code> is computed using the most recent query for a pose update.</p> </li> <li> <p>Cannot submit frame data with a depth buffer.</p> </li> <li> <p>Cannot have poses that make use of OpenXR Spaces. Raw pose data is instead retrieved from the application's     SLAM algorithms.</p> </li> <li> <p>Does not support controller action.</p> </li> <li> <p>User-space applications cannot acquire more than one swap chain buffer for each eye         during the processing of a frame.</p> </li> <li> <p>Must initialize ILLIXR during the session initialization.</p> </li> </ol>"},{"location":"plugin_README/zed_capture/","title":"zed_capture","text":"<p>The <code>zed_capture</code> binary is used to generate test data for injection into ILLIXR. The binary is a stand-alone feature and does not interact with the rest of ILLIXR. It takes the following command line arguments.</p> Argument Description Default -d, --duration The duration to run for in seconds 10 -f, --fps Frames per second 30 --wc The origin of the world coordinate system in relation to the camera. Must be 7 comma separated values x, y, z, w, wx, wy, wz. 0., 0., 0., 1., 0., 0., 0. -p --path The root path to write the data to. Current working directory <p><code>zed_capture</code> will write out the left and right camera images and the current pose at each frame. Note that it may not work at the requested fps due to overheads of writing files. This will be addressed in future updates. Note that the depth information is also not captured currently as OpenCV does not properly write out cv::Mat objects with float formats. This will also be addressed in future updates.</p> <p>Data are written to /'fps' +  + 'dur' +  (e.g. /fps30_dur10 will contain data  taken at 30 frames per second with a total run time of 10 seconds, or 300 frames, it will always contain 300 frames regardless of any slow down due to overheads). This format is compatible with the zed.data_injection plugin."},{"location":"policies/branch_retention/","title":"Branch Retention","text":"GitHub Branch Retention Policy   Version 1.0<p>  March 1, 2024"},{"location":"policies/branch_retention/#history","title":"History","text":"Version Date Who Notes 1.0 03/01/2024 ILLIXR Team Initial version"},{"location":"policies/branch_retention/#introduction","title":"Introduction","text":"<p>The purpose of this document is to outline the policy for retaining, combining, and pruning (deleting) branches in the ILLIXR GitHub repository.</p>"},{"location":"policies/branch_retention/#definitions","title":"Definitions","text":"<ul> <li> <p>stale: GitHub\u2019s definition is a branch that has not had any commits in at least 3 months. Since this is an active   research project that includes students who may not be active for several months at a time (breaks, internships,   etc.), we will take a looser time definition of 12 months. Note: the master branch can never be considered stale.</p> </li> <li> <p>active: The inverse of \u2018stale\u2019. We will consider a branch to be active if it has had any commits within the last   12 months.</p> </li> </ul>"},{"location":"policies/branch_retention/#policy","title":"Policy","text":"<p>To keep the repository manageable , we will occasionally prune stale branches according to the following:</p> <ul> <li>Any branch that has been stale for at least 24 months is subject to pruning at any time</li> <li>Any branch that is part of an open pull request will be retained, regardless of age/status</li> <li>Any branch that is part of an open issue will be retained, regardless of age/status</li> <li>Any branch that is part of an official release will be retained until at least the next release</li> <li>After an official release, any branches from previous releases should be discussed for pruning</li> </ul> <p>Exceptions</p> <p>There are instances where someone may want to retain a stale branch indefinitely for research, reference, or other purposes. In these instances, it will be our policy to tag the branch as an archived branch, and then delete the stale branch. The tagged branch will be available indefinitely, but will no longer appear on a listing of branches, thus satisfying the desire to keep a manageable repository and the availability of the code from the branch. The following commands (or their equivalent on the GitHub web interface) will be used:  <pre><code>git tag archive/ \ngit branch -D \n\n To checkout the archived branch:\n <pre><code>git checkout -b  archive/\n\n\n<p>Note</p>\n<p>The branch name for the tag does not have to match the actual branch name, but should be descriptive of what the branch is for.</p>\n\n\n<p>In addition to pruning old branches, an active effort should be made to minimize the number of branches used for a\nspecific development project/plugin (e.g. adding a new capability, handling updates to a 3rd party library, etc.). As a\nrule of thumb, each research project and issue should only have a single branch associated with it. Additional branches\ncan be added for testing/implementing specific details of the project/issue, but should not last more than a few weeks\nbefore being merged back into the primary branch for the project/issue.</p>\n<p>Divergent branches will be pruned/merged at release time.</p>"},{"location":"working_with/adding_mediapipe/","title":"Adding Mediapipe Based Plugins","text":"<p>There are several tools from Mediapipe which a may be of use to the ILLIXR project as a plugin. This page documents the process for converting these tools to plugins, following the experience of converting the hand landmark detection tool.</p>"},{"location":"working_with/adding_mediapipe/#steps","title":"Steps","text":"<ol> <li>Clone the repo</li> <li>Find the root file</li> <li>Understanding bazel BUILD files<ul> <li>Select Statements</li> <li>Descriptors<ul> <li>Binary</li> <li>Library</li> <li>Protobuf</li> <li>Pbtxt</li> <li>External Libraries</li> <li>Data Files</li> </ul> </li> <li>Parsing Dependencies<ul> <li>Local</li> <li>In another file</li> <li>External</li> </ul> </li> </ul> </li> <li>Find the necessary code files<ul> <li>C++</li> <li>Protobuf</li> <li>Pbtxt</li> <li>Data</li> <li>Move the Files</li> </ul> </li> <li>Package Dependencies<ul> <li>Common</li> <li>Custom</li> </ul> </li> <li>Plugin CMakeLists.txt<ul> <li>Header</li> <li>Command Line Options</li> <li>CMAKE_MODULE_PATH</li> <li>Dependencies</li> <li>Protobuf Helpers</li> <li>Special Operations</li> <li>The Plugin Itself</li> </ul> </li> <li>Adapting the Tool for ILLIXR<ul> <li>protobuf.cmake Files</li> <li>build.cmake Files</li> <li>Handling pbtxt Files</li> </ul> </li> <li>Writing Your Plugin<ul> <li>Understanding Graph Files</li> <li>Sending Data to the Tool</li> <li>Getting Data From the Tool</li> <li>Adding a Calculator<ul> <li>Changing Graph Files</li> <li>Data Structures</li> <li>Calculator Code<ul> <li>Common Function Calls</li> <li>GetContract</li> <li>Open</li> <li>Process</li> </ul> </li> </ul> </li> <li>plugin.hpp</li> <li>plugin.cpp<ul> <li>Input</li> <li>Publisher</li> </ul> </li> <li>CMakeLists.txt</li> </ul> </li> </ol>"},{"location":"working_with/adding_mediapipe/#clone-the-repo","title":"Clone the repo","text":"<p>These tools are provided by Mediapipe in a single git repo (https://github.com/google-ai-edge/mediapipe.git). So clone the repo to your workspace. Since these tools share a number of dependencies and components in some cases it is best for all the wrapped tool to come from the same version of the Mediapipe codebase (currently v0.10.14).</p> <pre><code>git clone https://github.com/google-ai-edge/mediapipe.git\ngit checkout v0.10.14\n</code></pre> <p>or</p> <pre><code>wget https://github.com/google-ai-edge/mediapipe/archive/refs/tags/v0.10.14.tar.gz\ntar xf v0.10.14.tar.gz\n</code></pre> <p>For purposes of this tutorial the term <code>file root</code> will refer to the root directory of the clone or unpacked tarball.</p>"},{"location":"working_with/adding_mediapipe/#find-the-root-file","title":"Find the root file","text":"<p>Mediapipe tools use the bazel build system which is not compatible with the CMake build system ILLIXR uses. The bazel build system relies on files named BUILD and WORKSPACE as the primary building blocks to define what is to be built. You will need to locate the BUILD file associated with the tool you want to work with. These are located in mediapipe/example/desktop/. For example the hand tracking BUILD file is mediapipe/examples/desktop/hand_tracking/BUILD"},{"location":"working_with/adding_mediapipe/#understanding-bazel-build-files","title":"Understanding bazel BUILD files","text":"<p>Bazel BUILD (and WORKSPACE) files are written in a dialect of Python called Starlark. Most of the content of these files describe libraries and binaries which can be built, similar to a TARGET in Cmake. Unlike CMake where most TARGETS are complete libraries or binaries with numerous source files, libraries and binaries in bazel typically have a few, or only one source file. Each of these items also has a list of other items that it depends on. Thus, starting with the main binary descriptor, you can walk your way through each of the dependencies to find all source files that are needed. A bazel project may consist of hundreds, or even thousands, of individual libraries, described in dozens of files scattered around the source tree.</p> <p>There are only a few object types we need to concern ourselves with for wrapping a tool.</p> <ul> <li>cc_binary: describes what is needed to build an executable</li> <li>cc_library: describes what is needed to build a library component (usually produces a single object file)</li> <li>cc_library_with_tflite: specialized version of cc_library which links to tensorflow lite components</li> <li>mediapipe_proto_library: describes what is needed to build a library component from a protobuf file</li> <li>http_archive: describes where to find and build an external library, similar to CMake's ExternalProject or   Fetchcontent functionality</li> <li>mediapipe_simple_subgraph: describes a workflow, or sub-workflow, for a tool</li> <li>http_file: describes where to find a single file on the web, typically a precompiled data file</li> </ul>"},{"location":"working_with/adding_mediapipe/#select-statements","title":"Select Statements","text":"<p>In the bazel build system the keyword <code>select</code> is used to denote an if/then/else syntax when constructing a list of source files or dependencies. The syntax is similar to a python dictionary where each key is a condition to test, and the value is a list of descriptors to include in whatever list the select statement is attached to. The <code>//conditions:default</code> is used to indicate what to use if none of the other options are true. For example</p> <pre><code>deps = [\n   \"inference_calculator_cpu\"\n] + select({\n   \"//conditions:default\": [\"infer_calc_gl\", \"infer_shader\"],\n   \":platform_apple\": [\"infer_calc_metal\"],\n})\n</code></pre> <p>This statement would add the infer_calc_metal descriptor to the deps list if the build platform is apple, otherwise the infer_calc_gl and infer_shader are added. When these statements are encountered you will need to decide which descriptors need to be added to the appropriate list. In some instances you may need to set up similar logic in CMake syntax (e.g. include certain files if OpenCV is detected).</p>"},{"location":"working_with/adding_mediapipe/#example-descriptors","title":"Example Descriptors","text":""},{"location":"working_with/adding_mediapipe/#binary-executable","title":"Binary (executable)","text":"<pre><code>cc_binary(\n    name = \"hand_tracking_cpu\",\n    data = [\n        \"//mediapipe/modules/hand_landmark:hand_landmark_full.tflite\",\n        \"//mediapipe/modules/palm_detection:palm_detection_full.tflite\",\n    ],\n    deps = [\n        \"//mediapipe/examples/desktop:demo_run_graph_main\",\n        \"//mediapipe/graphs/hand_tracking:desktop_tflite_calculators\",\n    ],\n)\n</code></pre> <ul> <li>name: the name of the executable to be built</li> <li>data: data files which are used by the executable; these files can be downloaded from the web, and in CMake we   treat them like a source file</li> <li>deps: dependencies that this binary has</li> </ul> <p>!!!! note</p> <pre><code> The cc_binary descriptor does not give any source files, all source files come from the dependency listings.\n</code></pre>"},{"location":"working_with/adding_mediapipe/#library-component","title":"Library component","text":"<pre><code>cc_library(\n   name = \"landmarks_to_render_data_calculator\",\n   srcs = [\"landmarks_to_render_data_calculator.cc\"],\n   hdrs = [\"landmarks_to_render_data_calculator.h\"],\n   deps = [\n      \":landmarks_to_render_data_calculator_cc_proto\",\n      \"//mediapipe/framework:calculator_framework\",\n      \"//mediapipe/framework:calculator_options_cc_proto\",\n      \"//mediapipe/framework/formats:landmark_cc_proto\",\n      \"//mediapipe/framework/formats:location_data_cc_proto\",\n      \"//mediapipe/framework/port:ret_check\",\n      \"//mediapipe/util:color_cc_proto\",\n      \"//mediapipe/util:render_data_cc_proto\",\n      \"@com_google_absl//absl/memory\",\n      \"@com_google_absl//absl/strings\",\n   ],\n   alwayslink = 1,\n)\n</code></pre> <ul> <li>name: name of the library component (think of it like a TARGET in CMake)</li> <li>srcs: list of source files for this component</li> <li>hdrs: list of header files for this component</li> <li>deps: list of dependencies for this component (think of them as libraries to link against)</li> </ul> <p>Both the src and hdrs are optional, and often only one is present in a descriptor. The <code>alwayslink</code> and <code>visibility</code> items can be safely ignored.</p>"},{"location":"working_with/adding_mediapipe/#protobuf-library-component","title":"Protobuf library component","text":"<pre><code>mediapipe_proto_library(\n    name = \"annotation_overlay_calculator_proto\",\n    srcs = [\"annotation_overlay_calculator.proto\"],\n    deps = [\n        \"//mediapipe/framework:calculator_options_proto\",\n        \"//mediapipe/framework:calculator_proto\",\n        \"//mediapipe/util:color_proto\",\n    ],\n)\n</code></pre> <ul> <li>name: name of the library component (think of it like a TARGET in CMake)</li> <li>srcs: list of protobuf source files for this component</li> <li>deps: list of dependencies for this component (think of them a libraries to link against)</li> </ul>"},{"location":"working_with/adding_mediapipe/#pbtxt-files","title":"Pbtxt Files","text":"<p>There are two signatures for this type of file.</p> <pre><code>mediapipe_simple_subgraph(\n    name = \"hand_landmark_model_loader\",\n    graph = \"hand_landmark_model_loader.pbtxt\",\n    register_as = \"HandLandmarkModelLoader\",\n    deps = [\n        \"//mediapipe/calculators/core:constant_side_packet_calculator\",\n        \"//mediapipe/calculators/tflite:tflite_model_calculator\",\n        \"//mediapipe/calculators/util:local_file_contents_calculator\",\n        \"//mediapipe/framework/tool:switch_container\",\n    ],\n)\n</code></pre> <ul> <li>name: name of the component</li> <li>graph: the name of the file that describes the graph</li> <li>register_as: alias for the component name</li> <li>deps: list of dependencies for this component</li> </ul> <pre><code>mediapipe_binary_graph(\n    name = \"hand_tracking_desktop_live_binary_graph\",\n    graph = \"hand_tracking_desktop_live.pbtxt\",\n    output_name = \"hand_tracking_desktop_live.binarypb\",\n    deps = [\":desktop_tflite_calculators\"],\n)\n</code></pre> <ul> <li>name: name of the component</li> <li>graph: the name of the file that describes the graph</li> <li>output_name: name of the output files after processing</li> <li>deps: list of dependencies for this component</li> </ul>"},{"location":"working_with/adding_mediapipe/#external-library","title":"External library","text":"<pre><code># Load Zlib before initializing TensorFlow and the iOS build rules to guarantee\n# that the target @zlib//:mini_zlib is available\nhttp_archive(\n    name = \"zlib\",\n    build_file = \"@//third_party:zlib.BUILD\",\n    sha256 = \"b3a24de97a8fdbc835b9833169501030b8977031bcb54b3b3ac13740f846ab30\",\n    strip_prefix = \"zlib-1.2.13\",\n    url = \"http://zlib.net/fossils/zlib-1.2.13.tar.gz\",\n    patches = [\n        \"@//third_party:zlib.diff\",\n    ],\n    patch_args = [\n        \"-p1\",\n    ],\n)\n</code></pre> <ul> <li>name: name of the external package</li> <li>build_file: the location of the build file for the package</li> <li>sha256: hash to check the integrity of the downloaded file</li> <li>url: the full url of the package sources</li> <li>patches: any patch files to be applied</li> <li>patch_args: any additional command line arguments to send to the patch command</li> </ul>"},{"location":"working_with/adding_mediapipe/#individual-file","title":"Individual file","text":"<pre><code>http_file(\n    name = \"com_google_mediapipe_hand_landmark_full_tflite\",\n    sha256 = \"11c272b891e1a99ab034208e23937a8008388cf11ed2a9d776ed3d01d0ba00e3\",\n    urls = [\"https://storage.googleapis.com/mediapipe-assets/hand_landmark_full.tflite?generation=1661875760968579\"],\n)\n</code></pre> <ul> <li>name: name of the file description (for internal reference, is not necessarily the name of the actual file)</li> <li>sha256: hash to check the integrity of the downloaded file</li> <li>urls: list of urls where the file can be downloaded from</li> </ul>"},{"location":"working_with/adding_mediapipe/#parsing-the-dependencies","title":"Parsing the dependencies","text":"<p>As you may have noted, there are numerous formats that a dep entry can take. Let's take a look at them, so we can understand what they are saying.</p>"},{"location":"working_with/adding_mediapipe/#local","title":"Local","text":"<p>Local dependencies are those which are described in the same BUILD file in which they are referenced. For example, in the <code>cc_library</code> descriptor above, the first dep is local. It starts with a <code>:</code>, followed by a name</p> <pre><code>:landmarks_to_render_data_calculator_cc_proto\n</code></pre> <p>This means that there is a descriptor in this file with the name <code>landmarks_to_render_data_calculator_cc_proto</code>, and it is a dependency of <code>landmarks_to_render_data_calculator</code>.</p>"},{"location":"working_with/adding_mediapipe/#in-another-file","title":"In another file","text":"<p>Most of the dependencies in the <code>cc_library</code> example are described in other BUILD files. These entries start with <code>//</code> and have the following format</p> <pre><code>//:\n\n<p>So in the second dependency in the <code>cc_library</code> example (<code>//mediapipe/framework:calculator_framework</code>), the descriptor\nis named <code>calculator_framework</code> and can be found in <code>mediapipe/framework/BUILD</code> (relative to the file root). The\nLocal dependency format is really a specialized version of this format, where the path to the build file is\nabsent, indicating the current file.</p>"},{"location":"working_with/adding_mediapipe/#external","title":"External","text":"<p>The remaining dependencies come from external libraries, this is really a list of libraries to link against, but which\nare also built along with this code. The entries start with <code>@</code> followed by the name of the external package, followed\nby the library path and name. So, <code>@com_google_absl//absl/memory</code> refers to the absl memory library described by an\n<code>http_archive</code> object with the name <code>com_google_absl</code>. As we refactor the code, and the build structure these types of\nreferences will be converted to something like</p>\n<pre><code>target_link_library(landmarks_to_render_data_calculator PUBLIC absl::memory)\n</code></pre>"},{"location":"working_with/adding_mediapipe/#find-the-necessary-code-files","title":"Find the necessary code files","text":"<p>Now that we have a handle on the basic structure of the files we will be going through, we can start to construct a list\nof the files we actually need to build our tool. Starting with the dependencies in the <code>cc_binary</code> descriptor we will\nneed to locate each dependency, then find all of their dependencies, and so on until the only descriptors left have\nno internal dependencies (external ones are ok, as these libraries will be built beforehand and do not contribute source\nfiles).</p>\n\n<p>Note</p>\n<p>Some objects will be the dependency of many other objects.</p>"},{"location":"working_with/adding_mediapipe/#c","title":"C++","text":"<p>Create a list of every src and hdr file found in each descriptor.</p>\n\n<p>Note</p>\n<p>The descriptors only give the file name, you will need to add the path to each of these items, so we can keep track of them. </p>"},{"location":"working_with/adding_mediapipe/#protobuf","title":"Protobuf","text":"<p>Create a separate list of the source files of the <code>mediapipe_proto_library</code> items you need.</p>"},{"location":"working_with/adding_mediapipe/#pbtxt","title":"Pbtxt","text":"<p>Create a list of all files listed in graph elements of <code>mediapipe_simple_subgraph</code> items you need. Additionally, keep a\nlist of all the dependencies for each of these, including the dependencies of those dependencies.</p>"},{"location":"working_with/adding_mediapipe/#data","title":"Data","text":"<p>Create a list of all data files that are listed in any descriptors. These are mainly tflite files.</p>"},{"location":"working_with/adding_mediapipe/#move-the-files","title":"Move the Files","text":"<p>Now that you have a list of the necessary file to build the tool you should create a separate GitHub repository for your\nplugin. Once that is done, create files and directories in the repo as follows:</p>\n<pre><code> directory&gt;\n\u251c\u2500\u2500 CMakeLists.txt      # Main cmake file\n\u251c\u2500\u2500 cmake               # empty directory for cmake helper files\n\u251c\u2500\u2500 mediapipe           # empty directory to hold all the mediapipe files\n\u251c\u2500\u2500 plugin.cpp          # main plugin code file\n\u2514\u2500\u2500 plugin.hpp          # plugion header file\n\n<p>Copy/move all the needed files from your src, hdr, protobuf, pbtxt, and data file lists into the\n<code>mediapipe</code> directory, maintaining their relative paths.\nYou should also create CMakeLists.txt and protobuf.cmake files in the mediapipe directory. Additionally, you should\ncopy encoder.cmake, make_pb_binary.cmake, and protoc_generate_obj.cmake from the ILLIXR hand tracking\nrepository. These files contain helper functions for processing the protobuf files and should go in a directory called\n<code>cmake</code>. Now you should have a directory structure something like this:</p>\n<pre><code> directory&gt;\n\u251c\u2500\u2500 CMakeLists.txt      # Main cmake file\n\u251c\u2500\u2500 cmake\n\u2502   \u251c\u2500\u2500 encoder.cmake\n\u2502   \u251c\u2500\u2500 make_pb_binary.cmake\n\u2502   \u2514\u2500\u2500 protoc_generate_obj.cmake\n\u251c\u2500\u2500 mediapipe           \n\u2502   \u251c\u2500\u2500 calculators\n\u2502   \u251c\u2500\u2500 example\n\u2502   \u251c\u2500\u2500 framework\n\u2502   \u251c\u2500\u2500 gpu\n\u2502   \u251c\u2500\u2500 graphs\n\u2502   \u251c\u2500\u2500 module\n\u2502   \u2514\u2500\u2500 utils\n\u251c\u2500\u2500 plugin.cpp          # main plugin code file\n\u2514\u2500\u2500 plugin.hpp          # plugion header file"},{"location":"working_with/adding_mediapipe/#package-dependencies","title":"Package Dependencies","text":""},{"location":"working_with/adding_mediapipe/#common","title":"Common","text":"<p>Common dependencies are those that can be via OS package managers, like boost. There is generally no need to install\nthese directly. We will just add them as <code>find_package</code> commands in the CMakeLists.txt file. There are however,\nexceptions to this rule. An example of this is the Protobuf package. The Mediapipe package requires a Protobuf version\nof at least 3.19, which may not be directly available on all OS versions. In this case, the dependency should be treated\nlike a Custom dependency.</p>"},{"location":"working_with/adding_mediapipe/#custom","title":"Custom","text":"<p>Custom dependencies are those which are not readily available via OS package managers, or a specific version which\ncannot be installed this way. In these cases will add some code to the CMakeLists.txt file to make sure the dependency\nis met. The CMakeLists.txt should first do a version check (in case the needed version already exists on the system),\nand then download and install the needed version if required. Below is an example for the Protobuf package</p>\n<pre><code>find_package(protobuf 3.19 QUIET CONFIG)\nif(protobuf_FOUND)\n   report_found(protobuf \"${protobuf_VERSION}\")\nelse()\n   ExternalProject_Add(\n           protobuf\n           GIT_REPOSITORY https://github.com/protocolbuffers/protobuf.git\n           GIT_TAG v3.19.1\n           GIT_PROGRESS TRUE\n           PREFIX \"${CMAKE_BINARY_DIR}/protobuf\"\n           DOWNLOAD_EXTRACT_TIMESTAMP TRUE\n           CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=\"-fPIC\"\n           SOURCE_SUBDIR cmake\n           GIT_SUBMODULES_RECURSE TRUE\n   )\nendif()\n</code></pre>\n<p>As with the Hand Tracking plugin, there will likely be a good number of external package dependencies. So that all of\nthe <code>find_package</code> calls in the plugin work as expected, a separate repo was created. This allows for the\ndependencies to be built and installed before the plugin tries to find its dependencies. You may need a similar\nmechanism for your tool (or even just use the hand tracking one)</p>"},{"location":"working_with/adding_mediapipe/#plugin-cmakeliststxt","title":"Plugin CMakeLists.txt","text":"<p>In this section we will use the adaption of the Hand Tracking tool as an example. This file will be presented in\nsections below.</p>"},{"location":"working_with/adding_mediapipe/#header","title":"Header","text":"<pre><code>cmake_minimum_required(VERSION 3.22)\nproject(ILLIXR_hand_tracking)\nset(CMAKE_VERBOSE_MAKEFILE True)\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\nset(CMAKE_PREFIX_PATH \"${CMAKE_INSTALL_PREFIX}/lib/cmake\")\nset(ENV{PKG_CONFIG_PATH} \"${CMAKE_INSTALL_PREFIX}/lib/pkgconfig\")\n</code></pre>\n<p>Here the name of the plugin/project is declared along with some global variables.</p>"},{"location":"working_with/adding_mediapipe/#command-line-options","title":"Command Line Options","text":"<pre><code>include(CMakeDependentOption)\n\noption(HT_ENABLE_GPU \"Whether to enable GPU based codes vs CPU based\" OFF)\noption(HT_ENABLE_GRAPH_PROFILER \"Whether to enable the graph profiler\" OFF)\ncmake_dependent_option(HT_ENABLE_WEB_PROFILING \"Whether to enable web profiling\" ON HT_ENABLE_GRAPH_PROFILER OFF)\n\nif(HT_ENABLE_GPU)\n    add_definitions(-DMEDIAPIPE_DISABLE_GPU=0)\nelse()\n    add_definitions(-DMEDIAPIPE_DISABLE_GPU=1)\nendif()\nadd_compile_options(-Wno-deprecated-declarations)\nif(HT_ENABLE_GRAPH_PROFILER)\n    add_definitions(-DMEDIAPIPE_PROFILER_AVAILABLE=1)\n    if(HT_ENABLE_WEB_PROFILING)\n        add_definitions(-DMEDIAPIPE_WEB_PROFILING_ENABLED=1)\n    endif()\nendif()\n</code></pre>\n<p>Here any command line options/flags are declared, and if needed, compile definitions are set.</p>"},{"location":"working_with/adding_mediapipe/#cmake_module_path","title":"CMAKE_MODULE_PATH","text":"<pre><code>set(CMAKE_MODULE_PATH\n    ${CMAKE_SOURCE_DIR}/cmake\n    ${CMAKE_MODULE_PATH}\n    ${CMAKE_INSTALL_PREFIX}/lib/cmake\n)\n</code></pre>\n<p>This section tells CMake where to look first for cmake files for external packages.</p>"},{"location":"working_with/adding_mediapipe/#dependencies","title":"Dependencies","text":"<pre><code>find_package(PkgConfig)\n\nif(ILLIXR_ROOT)\n    set(ILLIXR_HDR_PATH ${ILLIXR_ROOT} CACHE PATH \"Location of ILLIXR headers\")\n    #add_definitions(-DBUILD_ILLIXR)\nelse()\n    message(FATAL_ERROR \"ILLIXR_ROOT must be specified\")\nendif()\n\nset(protobuf_MODULE_COMPATIBLE ON)\nfind_package(ZLIB REQUIRED)\nfind_package(Protobuf 3.19 REQUIRED CONFIG)\npkg_check_modules(glog REQUIRED libglog)\npkg_check_modules(egl REQUIRED egl)\npkg_check_modules(glesv2 REQUIRED glesv2)\nfind_package(Eigen3 REQUIRED)\nfind_package(OpenCV 4 REQUIRED)\nset(ENABLE_OPENCV ON)\n\nset(PROTOBUF_DESCRIPTORS \"\" CACHE INTERNAL \"\")\npkg_check_modules(cpuinfo REQUIRED libcpuinfo)\n\nfind_package(tfl-XNNPACK REQUIRED CONFIG)\nfind_package(pthreadpool REQUIRED CONFIG)\nfind_package(tensorflow-lite REQUIRED CONFIG)\n\nif(tfl-XNNPACK_BINARY_DIR)\n    add_link_options(-L${tfl-XNNPACK_BINARY_DIR})\nendif()\n</code></pre>\n<p>Here we search for any dependencies.</p>"},{"location":"working_with/adding_mediapipe/#protobuf-helpers","title":"Protobuf Helpers","text":"<pre><code>include(mediapipe/protobuf.cmake)\ninclude(cmake/encoder.cmake)\n</code></pre>\n<p>The protobuf files from Mediapipe need some special processing. These files define functions which properly handle this.</p>"},{"location":"working_with/adding_mediapipe/#special-operations","title":"Special Operations","text":"<pre><code>file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor)\nforeach(ITEM ${PROTOBUF_DESCRIPTORS})\n    get_filename_component(_FILE ${ITEM} NAME_WE)\n    add_custom_target(${_FILE}_desc\n                      ALL\n                      COMMAND cat ${ITEM} &gt;&gt; ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin_temp\n                      DEPENDS encode_as_c_string ${ITEM}\n    )\n    list(APPEND FILE_DEPS ${_FILE}_desc)\nendforeach()\nadd_custom_target(move_temp_bin ALL\n                  COMMAND mv ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin_temp ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin\n                  DEPENDS ${FILE_DEPS}\n                  BYPRODUCTS ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin\n)\n\nadd_custom_target(encode_descriptor_sets ALL\n                  COMMAND ${CMAKE_COMMAND} -E env \"LD_LIBRARY_PATH=${CMAKE_INSTALL_PREFIX}/lib\" ${CMAKE_BINARY_DIR}/encode_as_c_string\n                  ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin &gt; ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_proto_descriptors.inc\n                  DEPENDS encode_as_c_string move_temp_bin\n                  BYPRODUCTS ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_proto_descriptors.inc\n)\n\ninclude(cmake/message_util.cmake)\nadd_custom_target(make_message_type\n                  COMMAND message_type_util\n                  --input_path=${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin --root_type_macro_output_path=${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_options_lib_type_name.h\n                  DEPENDS message_type_util\n                  BYPRODUCTS ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_options_lib_type_name.h\n)\n</code></pre>\n<p>One of the steps required files to be concatenated together. This code replicates that functionality. See the\nprotobuf.cmake section for more details.</p>"},{"location":"working_with/adding_mediapipe/#the-plugin-itself","title":"The Plugin Itself","text":"<pre><code>set(PLUGIN_NAME plugin.hand_tracking${ILLIXR_BUILD_SUFFIX})\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp)\n\nadd_subdirectory(mediapipe)\n\ntarget_link_libraries(${PLUGIN_NAME} PUBLIC\n                      ${OpenCV_LIBRARIES}\n                      absl::base\n                      absl::flags_parse\n                      fmt\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE\n                           ${ILLIXR_HDR_PATH}\n                           ${OpenCV_INCLUDE_DIRS}\n                           ${CMAKE_BINARY_DIR}\n                           ${CMAKE_SOURCE_DIR}\n)\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>\n<p>The plugin itself is declared as a library. All the hand tracking code is inside the mediapipe subdirectory.</p>"},{"location":"working_with/adding_mediapipe/#adapting-the-tool-for-illixr","title":"Adapting the Tool for ILLIXR","text":"<p>Now that you have the code in place we will put together the build files needed.</p>\n<ol>\n<li>In the mediapipe directory create files called <code>CMakeLists.txt</code> and <code>protobuf.cmake</code></li>\n<li>In each subdirectory that contains source or header files (or whose subdirectories contain such files) create a\n   <code>build.cmake</code> file</li>\n<li>In each subdirectory that contains a protobuf file (or whose subdirectories contain such files) create a\n   <code>protobuf.cmake</code> file</li>\n</ol>\n<p>The <code>build.cmake</code> files will list all source files needed to build the tool, while the <code>protobuf.cmake</code> files will be\nused to process the protobuf files.</p>"},{"location":"working_with/adding_mediapipe/#protobufcmake-files","title":"protobuf.cmake Files","text":"<p>There are three types of <code>protobuf.cmake</code> files. The first are those in directories which contain protobuf files, while\nthe second are those whose subdirectories contain protobuf files, and the third is a combination of the previous two\ntypes. For the second type, all the lines in the file will be including <code>protobuf.cmake</code> files from subdirectories. For\nexample</p>\n<pre><code>include(${CMAKE_CURRENT_LIST_DIR}/core/protobuf.cmake)\n</code></pre>\n<p>For the first type, they will have an include file at the top, and then a function call for each protobuf file in the\ndirectory.</p>\n<pre><code>include(${CMAKE_SOURCE_DIR}/cmake/protoc_generate_obj.cmake)\n\nprotobuf_generate_obj(PROTO_PATH calculators/util OBJ_NAME annotation_overlay_calculator)\n</code></pre>\n<p>The <code>protobuf_generate_obj</code> function generates a CMake TARGET which can be used to link against when compiling the code.\nThe signature for the function is:</p>\n<ul>\n<li>PROTO_PATH - the path to the protobuf file (not including the file name), relative to the mediapipe directory</li>\n<li>OBJ_NAME - the name of the protobuf file (without the extension)</li>\n<li>DESCRIPTORS - A flag that will append descriptor files to the master list in CACHE</li>\n</ul>\n<p>In the above example the CMake TARGET will be named calculators.util.annotation_overlay_calculator_proto. At the current\ntime,\nthere is no easy way to determine which protos need to have the DESCRIPTORS flag set. The easiest way may be to\nbuild the mediapipe tool with bazel and then search the build tree for files that end in <code>.proto.bin</code>. This will\nindicate which protos need to have the DESCRIPTORS flag set. These files will be treated specially in the main\n<code>CMakeLists.txt</code> for combining and processing.</p>"},{"location":"working_with/adding_mediapipe/#buildcmake-files","title":"build.cmake Files","text":"<p>Like the <code>protobuf.cmake</code> files, the <code>build.cmake</code> files also have three types, one for directories that only contain\nsource/header files, one that contains only other directories, and one that is a combination of the previous two. For\nthe second type, each of the lines of the file will be including other <code>build.cmake</code> files from subdirectories. For\nexample</p>\n<pre><code>include(${CMAKE_CURRENT_LIST_DIR}/core/build.cmake)\n</code></pre>\n<p>For the first type the file will add all the source files in the directory to the main target.</p>\n<pre><code>set(UTIL_SOURCES\n    ${CMAKE_CURRENT_LIST_DIR}/annotation_overlay_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/association_norm_rect_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/collection_has_min_size_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/detection_letterbox_removal_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/detections_to_rects_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/detections_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/filter_collection_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/illixr_output_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/labels_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/landmark_letterbox_removal_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/landmark_projection_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/landmarks_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/local_file_contents_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/non_max_suppression_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/rect_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/rect_transformation_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/thresholding_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/world_landmark_projection_calculator.cc\n)\n\nset(UTIL_HEADERS\n    ${CMAKE_CURRENT_LIST_DIR}/association_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/collection_has_min_size_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/detections_to_rects_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/filter_collection_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/landmarks_to_render_data_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/illixr_output_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/illixr_data.h\n)\n\ntarget_sources(${PLUGIN_NAME} PRIVATE\n               ${UTIL_SOURCES}\n               ${UTIL_HEADERS}\n)\n</code></pre>"},{"location":"working_with/adding_mediapipe/#handling-pbtxt-files","title":"Handling pbtxt Files","text":"<p>In the <code>graph</code> and <code>modules</code> directories the <code>build.cmake</code> files will call functions to compile the subgraph files into\na binary format. The main input pbtxt file will need to be installed as a text file, it will be labeled\n<code>mediapipe_binary_graph</code> in the <code>BUILD</code> file. Some pbtxt files carry information about where tflite files are installed.\nThese will need to be modified to contain the proper installed location, via <code>configure_file</code> calls in cmake.</p>\n<p><code>Pbtxt</code> files which have been labeled <code>mediapipe_simple_subgraph</code> in their respective <code>BUILD</code> files will need to be\nspecially compiled. There is a function <code>make_proto_binary</code> in <code>cmake/make_pb_binary.cmake</code>. For each of these pbtxt\nfiles you should have a list of dependencies. The only ones we need now are the protobuf ones, as they need to be\nhandled like libraries. Here is a sample code snippet from a <code>build.cmake</code> file.</p>\n<pre><code>include(${CMAKE_SOURCE_DIR}/cmake/make_pb_binary.cmake)\n\n# make a list of all protobuf dependencies for this pbtxt file \nset(HLLR_LIBRARIES\n    $&lt;TARGET_OBJECTS:calculators.internal.callback_packet_calculator_proto&gt;\n    $&lt;TARGET_OBJECTS:calculators.util.rect_transformation_calculator_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.calculator_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.calculator_options_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.calculator_profile_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.mediapipe_options_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.packet_factory_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.packet_generator_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.status_handler_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.stream_handler_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.thread_pool_executor_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.deps.proto_descriptor_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.formats.landmark_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.formats.rect_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.stream_handler.default_input_stream_handler_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.tool.calculator_graph_template_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.tool.field_data_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.tool.packet_generator_wrapper_calculator_proto&gt;\n)\n\n# compile the pbtxt file\nmake_proto_binary(BINARY_NAME hand_landmark_landmarks_to_roi_graph_text_to_binary_graph\n                  FILE_ROOT modules/hand_landmark\n                  FILE_BASE_NAME hand_landmark_landmarks_to_roi\n                  CLASS_NAME HandLandmarkLandmarksToRoi\n                  PROTO_LIBRARIES ${HLLR_LIBRARIES}\n)\n</code></pre>\n<p>The inputs to <code>make_proto_binary</code> are</p>\n<ul>\n<li>BINARY_NAME: name of the binary to create</li>\n<li>FILE_ROOT: the path to the pbtxt file (relative to root directory)</li>\n<li>FILE_BASE_NAME: the name of the pbtxt file (no path, no suffix)</li>\n<li>CLASS_NAME: the name to register this as, this will be what is specified by the <code>register_as</code> key in the <code>BUILD</code>\n  file</li>\n<li>PROTO_LIBRARIES: the protobuf libraries to link against</li>\n</ul>"},{"location":"working_with/adding_mediapipe/#writing-your-plugin","title":"Writing Your Plugin","text":"<p>In this guide we will refer to the entire mediapipe code as the tool. The workflow of the tool is defined by graph\nfiles. The individual calculators communicate with each other via packets.</p>"},{"location":"working_with/adding_mediapipe/#understanding-graph-files","title":"Understanding Graph Files","text":"<p>The graph files (those with a pbtxt suffix) are the real drivers of the tool's workflow. They define what calculators\nare run in what order, and what their inputs and outputs are. In mediapipe, calculators are roughly equivalent to ILLIXR\nplugins. There are several levels of these graph files. The topmost one will be read as a text file by the tool's\ninitializing code, and lives in mediapipe/graph/ and are usually small compared to others. They also will link to\nother graph files (also called calculators in this context). All the other pbtxt files will be compiled into the tool\nlibrary.\n<p>Let's look at the hand tracking main graph file (hand_tracking_desktop_live.pbtxt) in snippets.</p>\n<pre><code># CPU image. (ImageFrame)\ninput_stream: \"input_video\"\ninput_stream: \"image_data\"\n# CPU image. (ImageFrame)\noutput_stream: \"illixr_data\"\n</code></pre>\n<p>The <code>input_stream</code> keyword defines what data will be sent to the tool as input. The <code>output_stream</code> keyword defines what\ndata will be sent out of the tool. As far as I know, there is no limit on the number of each. The value of both of these\nkeywords is a string value which names the stream, these streams will be referred to by these names in the C++ code. At\nthis level, there is no typing of the data, just labelling the streams.</p>\n<pre><code>node {\n  calculator: \"HandLandmarkTrackingCpu\"\n  input_stream: \"IMAGE:input_video\"\n  input_side_packet: \"NUM_HANDS:num_hands\"\n  output_stream: \"LANDMARKS:landmarks\"\n  output_stream: \"HANDEDNESS:handedness\"\n  output_stream: \"PALM_DETECTIONS:multi_palm_detections\"\n  output_stream: \"HAND_ROIS_FROM_LANDMARKS:multi_hand_rects\"\n  output_stream: \"HAND_ROIS_FROM_PALM_DETECTIONS:multi_palm_rects\"\n}\n</code></pre>\n<p>The <code>node</code> defines a single calculator/subgraph. The name of the calculator/subgraph is defined in the <code>calculator</code>\nentry. This will match a class which has already bee compiled in the code (case-sensitive).</p>\n<p>As above, the <code>input_stream</code> and <code>output_stream</code> define the inputs and outputs to/from the calculator.</p>\n\n<p>Note</p>\n<p>The names of the streams are different from above. They have a format of <code>NAME:stream_name</code>. </p>\n\n<p>The first, all caps, name acts\nas a reference to the second name. When the streams are referenced in the C++ code, the name used will be the first (or\nas above, only name). Thus using the two name scheme allows you to change the actual stream (second name) in the graph\nfiles, without having to change the C++ code, which uses the first name reference.</p>\n<p>For a more complete guide on the graph file format see this guide. You can also visualize and error check graphs\nwith this useful online tool</p>"},{"location":"working_with/adding_mediapipe/#sending-data-to-the-tool","title":"Sending Data To the Tool","text":"<p>Sending data to the tool is straight forward. Take the following code snippet as an example</p>\n<pre><code>auto img_ptr = absl::make_unique&lt;mediapipe::ImageData&gt;(image_data);\nauto img_status = _graph.AddPacketToInputStream(kImageDataTag,\n                                                mediapipe::Adopt(img_ptr.release()).At(\n                                                       mediapipe::Timestamp(frame_timestamp_us)));\n\nif (!img_status.ok())\n    throw std::runtime_error(std::string(img_status.message()));\n</code></pre>\n<p>The first line creates a unique pointer which wraps the data we want to send to the tool. The second line stages the\npacket to the graph with a call to <code>AddPacketToInputStream</code>. The first argument is the name of the stream to add the\npacket to (will be one of the names from the graph file), the second argument is the data being sent (it is fully\nadopted by the stream) along with the current timestamp.\nThe last two lines check that there was no error in adding the packet, and throw an exception if there was.</p>\n\n<p>Note</p>\n<p>The timestamp values do not have to match any specific timing convention, but must increase with each call to add a packet to a specific stream. </p>"},{"location":"working_with/adding_mediapipe/#getting-data-from-the-tool","title":"Getting Data From the Tool","text":"<p>Getting the data from the tool is also straight forward. Take the following code snippet as an example</p>\n<pre><code>if (_poller-&gt;Next(&amp;_packet))\n    auto &amp;output_frame = _packet.Get&lt;mediapipe::ILLIXR::illixr_ht_frame&gt;();\n    ...\nelse\n    ...\n</code></pre>\n<p>The if statement checks to see if there is a packet available. The <code>Next</code> function returns a boolean (true if a packet\nis available), and puts the packet, if any, in the <code>_packet</code> variable. The following line extracts and casts the packet\nto the appropriate type. The following lines can use the data <code>output_frame</code> in this example, as needed.</p>"},{"location":"working_with/adding_mediapipe/#adding-a-calculator","title":"Adding a Calculator","text":"<p>In some instances you may want to manipulate the output stream from a tool to better suit your needs. The original\nversion of the hand tracking tool only returned an image with the hand tracking results visually represented. For\nILLIXR, we wanted to have the actual hand tracking data available (points on each hand, what hand(s) were detected,\netc.). So a calculator was added to the end of the tool which gathered the relevant data together into a single\nstructure. On of the other calculators was also modified so that the output image was transparent, so that the visual\nrepresentation could be used as an overlay. Here we will look at how to create a new calculator from scratch.</p>"},{"location":"working_with/adding_mediapipe/#changing-graph-files","title":"Changing Graph Files","text":"<p>The first thing to do is to add a new <code>node</code> to the appropriate graph file. The name you give your calculator is\ncase-sensitive and must match the calculator class name in your code. Be sure to add whatever input and output streams\nyou will need.</p>"},{"location":"working_with/adding_mediapipe/#data-structures","title":"Data Structures","text":"<p>Since whatever data the tool originally produced did not meet your needs, you will need to create a new data type which\nencapsulates all that you want. This data structure will be the packet you get from the graph at the end, and does not\nneed to be the same data that your plugin publishes to ILLIXR. The file for this should be put in\n<code>mediapipe/calculators/util</code>. The following file is for the hand tracking tool, in <code>illixr_data.h</code>.</p>\n<pre><code>#pragma once\n#include \n\n#include \"mediapipe/framework/port/opencv_core_inc.h\"\n#include \"illixr/hand_tracking_data.hpp\"\n\nnamespace mediapipe::ILLIXR {\nstruct illixr_ht_frame {\n    cv::Mat* image = nullptr;\n\n    size_t image_id;\n    ::ILLIXR::image::image_type type;\n    ::ILLIXR::rect* left_palm = nullptr;\n    ::ILLIXR::rect* right_palm = nullptr;\n    ::ILLIXR::rect* left_hand = nullptr;\n    ::ILLIXR::rect* right_hand = nullptr;\n\n    float left_confidence = 0.;\n    float right_confidence = 0.;\n    ::ILLIXR::hand_points* left_hand_points = nullptr;\n    ::ILLIXR::hand_points* right_hand_points = nullptr;\n\n    ~illixr_ht_frame() {\n        delete image;\n        delete left_palm;\n        delete right_palm;\n        delete left_hand;\n        delete right_hand;\n        delete left_hand_points;\n        delete right_hand_points;\n    }\n};\n}\n\n<p>It is just a <code>struct</code> that holds the needed data.</p>\n<p>If this struct will be different from what your plugin will publish to ILLIXR, you should also add a header to\n<code>include/illixr</code> in your ILLIXR code base which defines that data structure. One main reason for having two different\ndata structures is if the one for the tool has members whose data type is only defined in the mediapipe code. We don't\nwant any other part of ILLIXR to need to depend on these external data types, so defining one inside ILLIXR (even if it\nis nearly identical), will alleviate this issue.</p>\n<p>You will also need to add a protobuf file for defining the options used by your calculator. This guide won't go into the\ndetails of this, as it is likely that you will just need a basic one.</p>\n<pre><code>syntax = \"proto2\";\n\npackage mediapipe;\n\nimport \"mediapipe/framework/calculator.proto\";\n\nmessage MyCalculatorOptions {\n   extend CalculatorOptions {\n      optional MyCalculatorOptions ext = 123456789;\n   }\n}\n</code></pre>\n<p>The number after ext must be unique withing the tool. Just grep for <code>ext</code> in the proto files and look for the largest\none and add something like 10 to get your number. This file will also go in <code>mediapipe/calculators/util</code>.</p>"},{"location":"working_with/adding_mediapipe/#calculator-code","title":"Calculator Code","text":"<p>Mediapipe calculators are class based objects that inherit from <code>CalculatorBase</code>. You should name your calculator\nsomething useful and put the header and code files in <code>mediapipe/calculators/util</code>. The code below is a minimum outline\nof what you will need.</p>\n<pre><code>#include \"mediapipe/framework/calculator_base.h\"\n\nclass MyCalulator : public CalculatorBase {\npublic:\n    MyCalculator() = default;\n    ~MyCalculator() override;\n\n    MyCalculator(const MyCalculator&amp;) = delete;\n    MyCalculator&amp; operator=(const MyCalculator&amp;) = delete;\n\n    static absl::Status GetContract(CalculatorContract* cc);\n    absl::Status Open(CalculatorContext* cc) override;\n    absl::Status Process(CalculatorContext* cc) override;\nprotected:\n    ::mediapipe::MyCalculatorOptions options_;\n};\n</code></pre>\n<p>You can add any additional functions and data members you need. The sections below will cover the three required\nfunctions.</p>"},{"location":"working_with/adding_mediapipe/#common-function-calls","title":"Common Function Calls","text":"<p>There are several functions that are used multiple times throughout a calculator. These deal with checking inputs and\noutputs, getting input streams, publishing to output streams, and setting data types for these streams. In each of the\nsnippets below <code>cc</code> refers to either a <code>CalculatorContract</code> or <code>CalculatorContext</code>, which for these functions we can\ntreat as identical.</p>\n<pre><code>constexpr char kInputTag[] = \"INPUT_TAG\";\n\ncc-&gt;Inputs().HasTag(kInputTag);\n\n\ncc-&gt;Outputs().HasTag(kInputTag);\n</code></pre>\n<p>This code checks that the input stream named \"INPUT_TAG\" (in the graph), is being supplied by the graph. This allows for\na calculator to be fed different input streams. The function <code>HasTag</code> returns a boolean, and is often used in <code>if</code>\nstatements. There is also a similar call for checking output streams.</p>\n\n<pre><code>cc-&gt;Inputs().Tag(kInputTag).Set&lt;std::vector&lt;Points&gt; &gt;();\n\n\ncc-&gt;Ouputs().Tag(kInputTag).Set&lt;std::vector&lt;Points&gt; &gt;();\n</code></pre>\n<p>This code sets the expected data type for the given tag. This call should be after a <code>HasTag</code> call to ensure that the\ninput stream is available first.</p>\n\n<pre><code>img_data_ = cc-&gt;Inputs().Tag(kInputTag).Get&lt;std::vector&lt;Points&gt; &gt;();\n</code></pre>\n<p>This code will retrieve the current data from the specified stream. This code also specifies the data type, and should\nonly be made after a call to <code>Set</code>.</p>\n\n<pre><code>cc-&gt;Outputs().Tag(kInputTag).Add(frame_data.release(), cc-&gt;InputTimestamp());\n</code></pre>\n<p>This code adds the given data to the specified stream, along with the timestamp. This should only be called after a call\nto <code>Set</code>.</p>\n\n<p>Many mediapipe functions return an object of type <code>absl::Status</code>. This type of object encapsulates the status of the\nfunction call, along with any error information.</p>\n<pre><code>absl::Status stat = myfunc();\n\nif(!stat.ok())   // returns a boolean: true = success\n    throw std::runtime_error(std::string(stat.message()));  // throws an exception with the contents of any error messages\n</code></pre>"},{"location":"working_with/adding_mediapipe/#getcontract","title":"GetContract","text":"<p>Calculator authors can specify the expected types of inputs and outputs of a calculator in GetContract(). When a graph\nis initialized, the framework calls a static method to verify if the packet types of the connected inputs and outputs\nmatch the information in this specification. source</p>\n\n<p>Function calls like the following are common here.</p>\n<pre><code>// See which input stream is being supplied by the graph\nif (cc-&gt;Inputs().HasTag(kImageFrameTag)) {\n    cc-&gt;Inputs().Tag(kImageFrameTag).Set&lt;ImageFrame&gt;();\n} else if (cc-&gt;Inputs().HasTag(kImageTag)) {\n    cc-&gt;Inputs().Tag(kImageTag).Set&lt;mediapipe::Image&gt;();\n}\n\n\n// Ensure that only one of these streams is available\nRET_CHECK(cc-&gt;Inputs().HasTag(kNormPalmRectTag) +\n          cc-&gt;Inputs().HasTag(kRectPalmTag) +\n          cc-&gt;Inputs().HasTag(kNormPalmRectsTag) +\n          cc-&gt;Inputs().HasTag(kRectsPalmTag) &lt;=\n          1);\n</code></pre>"},{"location":"working_with/adding_mediapipe/#open","title":"Open","text":"<p>After a graph starts, the framework calls Open(). The input side packets are available to the calculator at this\npoint.\nOpen() interprets the node configuration operations (see Graphs) and prepares the calculator's per-graph-run\nstate. This\nfunction may also write packets to calculator outputs. An error during Open() can terminate the graph\nrun. source</p>"},{"location":"working_with/adding_mediapipe/#process","title":"Process","text":"<p>For a calculator with inputs, the framework calls Process() repeatedly whenever at least one input stream has a packet\navailable. The framework by default guarantees that all inputs have the same timestamp (see Synchronization for\nmore information). Multiple Process() calls can be invoked simultaneously when parallel execution is enabled. If an\nerror occurs during Process(), the framework calls Close() and the graph run terminates. source</p>\n\n<p>This is where the bulk of the calculator's work is done. Inputs are read, calculations are done, and the results are\nadded to the output streams.</p>"},{"location":"working_with/adding_mediapipe/#close","title":"Close","text":"<p>After all calls to Process() finish or when all input streams close, the framework calls Close(). This function is\nalways called if Open() was called and succeeded and even if the graph run terminated because of an error. No inputs\nare available via any input streams during Close(), but it still has access to input side packets and therefore may\nwrite outputs. After Close() returns, the calculator should be considered a dead node. The calculator object is\ndestroyed as soon as the graph finishes running. source</p>\n\n<p>In general, the default version of this function will suffice, and there is little need to implement an overloaded\nversion.</p>"},{"location":"working_with/adding_mediapipe/#pluginhpp","title":"plugin.hpp","text":"<p>The actual plugin should be split into two files, to aid in readability, a header and the code itself. The plugin should\nfollow the general guidelines. Due to the way the mediapipe graphs work you may find it necessary to create two\nplugins: one for sending the input to the graph, and one to get the results once the graph has run. To aid in\nunderstanding, we will refer to the plugin that sends the input to the graph as Input and the other as Publish.\nIn this instance both plugins can be defined in the same header and code files. There are other plugins that use this\nstyle as well, which you can use for reference (zed, and hand_tracking).</p>\n<p>In the two plugin case Input can inherit from plugin or threadloop, depending on your needs. However,\nPublish should inherit from threadloop. Below is some stub code for the headers.</p>\n<pre><code>class MyPublisher : public threadloop {\npublic:\n    MyPublisher(const std::string&amp; name_, phonebook* pb_);\n    ~MyPublisher() override;\n\n    void set_poller(mediapipe::OutputStreamPoller* plr) {_poller = plr;}\n    void stop() override;\nprotected:\n    skip_option _p_should_skip() override;\n    void _p_one_iterarion() override;\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; _switchboard;\n    switchboard::writer&lt;my_data&gt;       _my_publisher;\n    mediapipe::OutputStreamPoller*     _poller = nullptr;\n    mediapipe::Packet                  _packet;\n};\n\nclass MyInput : public plugin {\npublic:\n    MyInput(const std::string&amp; name_, phonebook* pb_);\n    ~MyInput() override;\n\n    void start() override;\n    void process(const switchboard::ptr&lt;data_type&gt;&amp; frame);  // this is the function that is called when an result from the graph is available \n    void stop() override;\nprivate:\n    const std::shared_ptr&lt;switchbaord&gt; _switchboard;\n    mediapipe::CalculatorGraph _graph;\n    MyPublisher _publisher;    // this plugin will control the publisher\n};\n</code></pre>"},{"location":"working_with/adding_mediapipe/#plugincpp","title":"plugin.cpp","text":"<p>Here we will go through the basic code needed to interface with the graph, based on the header code from above. At the\ntop you should define the streams that the plugin will send and receive from. These names must match those in the graph\nfile.</p>\n<pre><code>constexpr char kInputStream[] = \"input_video\";     // stream the Input will write to\nconstexpr char kImageDataTag[] = \"image_data\";     // stream the Input will write to\nconstexpr char kOutputStream[] = \"illixr_data\";    // stream the Publish will read from\n</code></pre>"},{"location":"working_with/adding_mediapipe/#input","title":"Input","text":"<p>The constructor should initialize the normal plugin stuff as well as the graph and Publish class.</p>\n<pre><code>MyInput::MyInput(const std::string&amp; name_, phonebook* pb_) \n        : plugin{name_, pb_}\n        , _switchbaord{pb_-&gt;lookup_impl&lt;switchboard&gt;()}\n        , _graph{mediapipe::CalculatorGraph()}\n        , _publisher{\"my_publisher\", pb_} {\n    &lt;any other code you need&gt;\n}\n</code></pre>\n<p>The <code>start</code> function should configure the graph, and start the PUBLISH plugin.</p>\n<pre><code>void MyInput::start() {\n    // start the plugin\n    plugin::start();\n    // read the environment variable which holds the graph configuration file name\n    const std::string calculator_graph_config_contents =\n#include \"mediapipe/hand_tracking_desktop_live.pbtxt\"\n            ;  // NOLINT(whitespace/semicolon)\n    auto config = mediapipe::ParseTextProtoOrDie&lt;mediapipe::CalculatorGraphConfig&gt;(calculator_graph_config_contents);\n    absl::Status status;\n    // initialize the graph\n    status = _graph.Initialize(config);\n    if (!status.ok())\n        throw std::runtime_error(std::string(status.message()));\n\n    // get a poller for the output stream\n    auto status_or_poller = _graph.AddOutputStreamPoller(kOutputStream);\n    if (!status_or_poller.ok())\n        throw std::runtime_error(\"Error with output poller\");\n    // pass the poller to the publisher\n    _publisher.set_poller(new mediapipe::OutputStreamPoller(std::move(status_or_poller).value()));\n\n    // start the graph\n    status = _graph.StartRun({});\n    if (!status.ok())\n        throw std::runtime_error(\"Error starting graph\");}\n\n    // register  the process funtion to be called any time there is input from ILLIXR to be added to the graph stream\n    //  here \"data_type\" is the type of data expected from ILLIXR and \"input_name\" is the registered name of the topic (data source) \n    _switchboard-&gt;schedule&lt;data type&gt;(id, \"input_name\",\n                                      [this](const switchboard::ptr&lt;const&lt;data_type&gt; &amp;inp, std::size_t) {\n                                             this-&gt;process(inp);\n                                      });\n\n    // start the publisher thread\n    _publisher.start();\n</code></pre>\n<p>Note the way <code>calculator_graph_config_contents</code> is constructed. This takes the needed config file, which in mediapipe\nwas specified as an environment variable, and changes it to be hard coded, as the plugin will have a specific purpose,\nit should not need to change. To be sure the included file is properly specified, the following will need to be done.</p>\n<ol>\n<li>edit the original config file to escape all existing quotation marks\n   <pre><code>input_stream: \"image_data\"\n</code></pre></li>\n</ol>\n<p>becomes</p>\n<p><pre><code>input_stream: \\\"image_data\\\"\n</code></pre>\n2. edit the original config file to enclose every line in quotation marks, adding a newline character to the end\n   <pre><code># mediapipe/examples/desktop/hand_tracking:hand_tracking_cpu.\n\n# CPU image. (ImageFrame)\ninput_stream: \\\"input_video\\\"\ninput_stream: \\\"image_data\\\"\n# CPU image. (ImageFrame)\noutput_stream: \\\"illixr_data\\\"\n</code></pre></p>\n<p>becomes</p>\n<p><pre><code>\"# mediapipe/examples/desktop/hand_tracking:hand_tracking_cpu.\\n\"\n\"\\n\"\n\"# CPU image. (ImageFrame)\\n\"\n\"input_stream: \\\"input_video\\\"\\n\"\n\"input_stream: \\\"image_data\\\"\\n\"\n\"# CPU image. (ImageFrame)\\n\"\n\"output_stream: \\\"illixr_data\\\"\\n\"\n\"\\n\"\n</code></pre>\n3. modify the <code>mediapipe/graphs/&lt;pipeline&gt;/build.cmake</code> to copy the file to the build directory\n   <pre><code>file(COPY ${CMAKE_CURRENT_LIST_DIR}/hand_tracking_desktop_live.pbtxt\n     DESTINATION ${CMAKE_BINARY_DIR}/mediapipe\n)\n</code></pre></p>\n\n<p>The <code>stop</code> function should also stop the publisher thread.</p>\n<pre><code>void MyInput::stop() {\n    // Close any open mediapipe::CalculatorGraph instances\n    // with CloseAllPacketSources();\n    // and delete if necessary\n    _publisher.stop();\n    plugin::stop();\n}\n</code></pre>\n\n<p>The <code>process</code> function will be called by the <code>switchboard</code> any time data of the expected type <code>data type</code> from topic\n<code>input_name</code> is available.</p>\n<pre><code>void MyInput::process(const switchboard::ptr&lt;const data_type&gt;&amp; frame) {\n    // read from the input and do whatever is needed to convert it to the input type for the graph\n    // in this example we are assuming that it can be simply converted\n    auto in_data = mediapipe_data_type(frame);\n\n    // generate a timestamp for the mediapipe packet\n    size_t frame_timestamp_us = std::chrono::high_resolution_clock::now().time_since_epoch().count() / 1000;\n    // wrap the data in a unique pointer\n    auto data_ptr = absl::make_unique&lt;mediapipe_data_type&gt;(in_data);\n    // add the data to the input stream of the graph\n    auto stat = _graph.AddPacketToInputStream(kOutputStream,\n                                              mediapipe::Adopt(img_ptr.release()).At(\n                                                  mediapipe::Timestamp(frame_timestamp_us)));\n    // raise an exception if something went wrong\n    if (!stat.ok())\n        throw std::runtime_error(std::string(stat.message()));\n}\n</code></pre>"},{"location":"working_with/adding_mediapipe/#publisher","title":"Publisher","text":"<p>The Publish constructor should initialize the writer which is used to put data into ILLIXR.</p>\n<pre><code>MyPublisher::MyPublisher(const std::string&amp; name_ phonebook* pb_)\n        : threadloop{name_, pb_}\n        , _switchboard{pb_-&gt;lookup_impl&lt;switchboard&gt;()}\n        , _my_publisher{_switchboard-&gt;get_writer&lt;my_data&gt;(\"data\")} {}\n</code></pre>\n<p>Here <code>my_data</code> is the data type being written out and <code>data</code> is the name of the topic doing the writing.</p>\n\n<p>The stop function should clean up any poller instances</p>\n<pre><code>void MyPublisher::stop() {\n    delete _poller;\n    _poller = nullptr;\n}\n</code></pre>\n\n<p>The destructor should at least get rid of the poller.</p>\n<pre><code>MyPublisher::~MyPublisher() {\n    delete _poller;  // ok to delete even if nullptr\n}\n</code></pre>\n\n<p>We use the <code>_p_should_skip</code> to see if there is an output packet from the graph.</p>\n<pre><code>skip_option MyPublisher::_p_should_skip() {\n    // check to see if there is a new packet, and if so put it in the class variable and signal that _p_one_iteration should be run\n    if (_poller-&gt;Next(&amp;_packet))\n        return threadloop::skip_option::run;\n    return threadloop::skip_option::skip_and_spin;   // no new packet\n}\n</code></pre>\n\n<p>The <code>_p_one_iteration</code> function will be called every time <code>_p_should_skip</code> returns <code>run</code>. This function will get the\noutput packet from the graph, manipulate the data if necessary, and write the results to ILLIXR.</p>\n<pre><code>void MyPublisher::_p_one_iterarion() {\n    // get the graph output\n    auto &amp;new_data = _packet.Get&lt;mediapipe_output&gt;();\n\n    // manipulate the data\n    // in this example we are assuming the data can be converted via constructor\n\n    // write the data to ILLIXR\n    _my_publisher.put(_my_publisher.allocate&lt;my_data&gt;(my_data{new_data}));\n}\n</code></pre>\n<p>That is the basic code for what is needed to connect ILLIXR to a mediapipe tool.</p>"},{"location":"working_with/adding_mediapipe/#cmakeliststxt","title":"CMakeLists.txt","text":"<p>Now we will bring it all together in the <code>CMakeLists.txt</code> file in the mediapipe directory. This file will generate a\nlist of all source files and protobuf targets needed to compile the mediapipe part of the plugin. This file is called by\n<code>add_subdirectory</code> from the main <code>CMakeLists.txt</code> file. The first section of this file will list all the protobuf\ntargets we need (those we generated via <code>protobuf_generate_obj</code> in <code>protobuf.cmake</code> files).</p>\n<pre><code>target_sources(${PLUGIN_NAME} PUBLIC\n               # list every protobuf target, one on each line\n               $&lt;TARGET_OBJECTS:calculators.util.annotation_overlay_calculator_proto&gt;\n               .\n               .\n               .\n)\n</code></pre>\n<p>Next we add targets that were generated by turning graph files into binary.</p>\n<pre><code>target_sources(${PLUGIN_NAME} PUBLIC\n               $&lt;TARGET_OBJECTS:hand_renderer_cpu_linked&gt;\n               .\n               .\n               .\n)\n</code></pre>\n<p>Next <code>include</code> each of the subdirectories.</p>\n<pre><code>include(${CMAKE_CURRENT_LIST_DIR}/calculators/build.cmake)\ninclude(${CMAKE_CURRENT_LIST_DIR}/framework/build.cmake)\n.\n.\n.\n</code></pre>\n<p>Next add any include directories. In case there are multiple versions of protobuf on the system, we want to make sure\nthat the correct one is picked up by the compiler, so we prepend it to the includes.</p>\n<pre><code>target_include_directories(${PLUGIN_NAME} BEFORE PUBLIC ${Protobuf_INCLUDE_DIRS})\ntarget_include_directories(${PLUGIN_NAME} PUBLIC\n                           ${CMAKE_BINARY_DIR}  # picks up protobuf generated headers\n                           ${CMAKE_SOURCE_DIR}  # picks up any normal mediapipe headers\n                           .                    # any other includes\n                           .\n                           .\n                           ${CMAKE_INSTALL_PREFIX}/include  # any headers installed by ILLIXR\n)\n</code></pre>\n<p>Lastly, add the libraries to link against.</p>\n<pre><code>target_link_libraries(${PLUGIN_NAME} PUBLIC\n                      protobuf::libprotobuf\n                      absl::base            # there will likely be a lot of absl libraries\n                      .\n                      .\n                      .\n)\n</code></pre>"},{"location":"working_with/debugging_illixr/","title":"ILLIXR Debugging Tips","text":""},{"location":"working_with/debugging_illixr/#debugging-locally","title":"Debugging Locally","text":"<p>The config described in Getting Started supports running the runtime with arbitrary commands like <code>gdb</code>. When debugging locally, we recommend using either <code>gdb</code> or <code>valgrind</code> in this way. You can use the <code>ENABLE_PRE_SLEEP</code> environment variable or <code>enable_pre_sleep</code> command line argument to set a sleep time before ILLIXR fully starts. This gives you time to attach a debugger.</p>"},{"location":"working_with/display_backend/","title":"Display Backends","text":"<p>ILLIXR supports multiple display backends for rendering output. Each backend is designed for different use cases and can be configured through environment variables.</p>"},{"location":"working_with/display_backend/#available-display-backends","title":"Available Display Backends","text":"<p>ILLIXR supports three display backends:</p> <ol> <li> <p>GLFW (Default)</p> <ul> <li>Standard windowed display using GLFW</li> <li>Best for desktop development and debugging</li> <li>Provides a resizable window interface</li> </ul> </li> <li> <p>X11 Direct Mode</p> <ul> <li>Direct display mode using X11</li> <li>Provides lower latency by bypassing the window manager</li> <li>Useful for tethered headsets directly connected to the GPU using DisplayPort or HDMI</li> </ul> </li> <li> <p>Headless</p> <ul> <li>No display output</li> <li>Useful for testing and benchmarking</li> <li>Can be used in environments without display hardware</li> </ul> </li> </ol>"},{"location":"working_with/display_backend/#configuration","title":"Configuration","text":"<p>The display backend and its behavior can be configured using the following environment variables:</p>"},{"location":"working_with/display_backend/#illixr_display_mode","title":"ILLIXR_DISPLAY_MODE","text":"<p>Controls which display backend to use.</p> <p>Possible values:</p> <ul> <li><code>glfw</code> (Default) - Use GLFW windowed mode</li> <li><code>x11_direct</code> - Use X11 direct mode</li> <li><code>headless</code> - Use headless mode</li> </ul> <p>Example:</p> <pre><code>export ILLIXR_DISPLAY_MODE=glfw\n</code></pre>"},{"location":"working_with/display_backend/#illixr_vulkan_select_gpu","title":"ILLIXR_VULKAN_SELECT_GPU","text":"<p>Allows manual selection of the GPU device when multiple are available. By default, the first available GPU is used. No need to set this if you only have one GPU.</p> <ul> <li>Value: Integer index of the GPU for Vulkan to use (0-based)</li> <li>Default: -1 (automatic selection of first suitable device)</li> </ul> <p>The available GPUs and their indices will be printed during startup.</p> <p>Example:</p> <pre><code>export ILLIXR_VULKAN_SELECT_GPU=1 # Select the second GPU\n</code></pre>"},{"location":"working_with/display_backend/#illixr_direct_mode_display","title":"ILLIXR_DIRECT_MODE_DISPLAY","text":"<p>Required when using X11 direct mode (<code>ILLIXR_DISPLAY_MODE=x11_direct</code>). Specifies which display to use. No need to set this if you only have one display output connected to the GPU.</p> <p>Note</p> <p>Currently, this backend is only tested with NVIDIA GPUs.</p> <ul> <li>Value: Integer index of the display to use (0-based)</li> <li>Must be set when using X11 direct mode</li> <li>Available displays and their indices will be printed during startup</li> </ul> <p>Example:</p> <pre><code>export ILLIXR_DIRECT_MODE_DISPLAY=0  # Use the first display\n</code></pre>"},{"location":"working_with/display_backend/#display-selection-process","title":"Display Selection Process","text":"<ol> <li>The system will enumerate available displays and GPUs during startup</li> <li> <p>For GPU selection:</p> <ul> <li>If <code>ILLIXR_VULKAN_SELECT_GPU</code> is not set, the first suitable GPU is selected</li> <li>If set, the specified GPU index is used</li> <li>The system will print available GPUs and their capabilities</li> </ul> </li> <li> <p>For X11 direct mode:</p> <ul> <li>The system will list available displays</li> <li><code>ILLIXR_DIRECT_MODE_DISPLAY</code> must be set to a valid display index</li> <li>The selected display will be acquired for direct mode access</li> <li>The highest refresh rate mode will be automatically selected</li> </ul> </li> </ol>"},{"location":"working_with/external_switchboard_and_phonebook/","title":"Using Switchboard and Phonebook Externally","text":"<p>Switchboard was designed as a self-contained entity from ILLIXR that one can reuse in other projects. The relevant API is here for Switchboard and here for Phonebook.</p> <p>One simply needs to copy these files, maintaining directory structure.</p> <pre><code>illixr/switchboard.hpp\nillixr/phonebook.hpp\nillixr/record_logger.hpp\nillixr/managed_thread.hpp\nillixr/concurrentqueue/blockingconcurrentqueue.hpp\nillixr/concurrentqueue/concurrentqueue.hpp\nillixr/concurrentqueue/lightweightsemaphore.hpp\n</code></pre> <p>This will serve as our <code>main.cpp</code>:</p> <pre><code>#include \n#include \"illixr/switchboard.hpp\"\n\nclass service : public ILLIXR::phonebook::service {\npublic:\n    void act() { std::cout &lt;&lt; \"Hello from service\\n\"; };\n};\n\nclass data : public ILLIXR::switchboard::event {\npublic:\n    data(size_t id_) : id{id_} { }\n    size_t id;\n};\n\nint main() {\n    ILLIXR::phonebook main_pb;\n    main_pb.register_impl&lt;service&gt;(std::make_shared&lt;service&gt;());\n    main_pb.lookup_impl&lt;service&gt;()-&gt;act();\n\n    // From docs of Switchboard: if first arg is null, logging is disabled.\n    // Logging should be disabled if we are running externally.\n    ILLIXR::switchboard main_sb {nullptr};\n    auto writer = main_sb.get_writer&lt;data&gt;(\"topic\");\n    auto reader = main_sb.get_reader&lt;data&gt;(\"topic\");\n    writer.put(writer.allocate&lt;data&gt;(42));\n    std::cout &lt;&lt; \"The answer to life... is \" &lt;&lt; reader.get_ro()-&gt;id &lt;&lt; std::endl;\n\n    return 0;\n}\n\n<p>Switchboard and Phonebook will only work with compilers that support C++17 or better.</p>\n<p>For example:</p>\n<pre><code># Must copy with directory structure\nmkdir -p illixr/concurrentqueue\ncp path/to/ILLIXR/illixr/switchboard.hpp illixr\ncp path/to/ILLIXR/illixr/phonebook.hpp illixr\ncp path/to/ILLIXR/illixr/record_logger.hpp illixr\ncp path/to/ILLIXR/illixr/managed_thread.hpp illixr\ncp path/to/ILLIXR/illixr/concurrentqueue/blockingconcurrentqueue.hpp illixr/concurrentqueue/blockingconcurrentqueue.hpp\ncp path/to/ILLIXR/illixr/concurrentqueue/concurrentqueue.hpp illixr/concurrentqueue/concurrentqueue.hpp\ncp path/to/ILLIXR/illixr/concurrentqueue/lightweightsemaphore.hpp illixr/concurrentqueue/lightweightsemaphore.hpp\nemacs main.cpp # copy and paste from this doc\n\n# This will *probbaly* work with any C++-17 compatible compiler, but I've tested with clang-10.\n# Nix is my preferred package manager, but you can use whichever you like.\n# This command will not affect system packages, just create a temporary environment with the right clang.\nnix-shell -p clang_10\n\n# Compile\nclang++ -Wextra -pthread -std=c++17 main.cpp\n\n# Run\n./a.out\n</code></pre>\n<p>The output is:</p>\n<pre><code>Register 7service\nHello from service\nCreating: topic for 4data\nThe answer to life... is 42\n</code></pre>"},{"location":"working_with/logging_and_metrics/","title":"Logging and Metrics","text":"<p>The ILLIXR project supports several ways for an ILLIXR application to log and report details about its execution.</p>"},{"location":"working_with/logging_and_metrics/#logging","title":"Logging","text":"<p>ILLIXR uses the spdlog library for logging. Logging goes to both <code>STDOUT</code> and one or more log files in <code>$ILLIXR_ROOT/logs/</code></p> <p>Available levels, from low to high are: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>critical</code>, <code>off</code>.</p> <p>If <code>NDEBUG</code> is not defined, then the default logging level is <code>warn</code>, otherwise it is <code>debug</code>.</p> <p>Logging is activated by exporting environment variables to a particular level before running ILLIXR. These take the form of <code>&lt;PLUGIN_NAME&gt;_LOG_LEVEL</code>, e.g.,</p> <pre><code># Activate logging for both the ground_truth_slam plugin and the ILLIXR app\n# Each will log to the console, with color (actual colors dependent on the terminal settings)\n# Each log will write to $ILLIXR_ROOT/logs/.log\n# Each log can have a different level.\n\nexport GROUND_TRUTH_SLAM_LOG_LEVEL=debug\nexport ILLIXR_LOG_LEVEL=warn\n\nmain.dbg.exe -yaml=profiles/native_gl.yaml\n\n<p>When writing a new plugin, the <code>plugin.spdlogger(std::string log_level)</code> method should be called, e.g., using\n<code>switchboard-&gt;get_env(\"&lt;PLUGIN_NAME&gt;_LOG_LEVEL\")</code> This creates a logger with two sinks (console and file). This logger\nis then registered in the global spdlog registry.</p>\n<p>To log inside a plugin method, use the plugin's name attribute to get the particular logger from the registry and call\nthe desired log level method, e.g.</p>\n<pre><code>spdlog::get(name)-&gt;info(\"informative message\");\n</code></pre>\n<p>Outside the plugin class hierarchy, one can use the global ILLIXR logger which is registered under \"illixr\", e.g.,\n<code>spdlog::get(\"illixr\")</code>. It will look for <code>$ILLIXR_LOG_LEVEL</code> in the environment or use <code>warn</code> by default. This usage\nrequires explicitly adding the name of the component or file to the output message, if desired.</p>\n<p>Log files are appended. To merge to a single log do <code>$ cat *log | sort &gt; combined.log</code> This will sort correctly because\nthe entries start with an ISO-8601 timestamp. For this reason, if a plugin uses <code>spdlog::set_pattern()</code> to create a\ncustom log pattern, it is highly recommended that the custom pattern start with an ISO-8601 timestamp and it is required\nto reset to the default log message pattern after use.</p>"},{"location":"working_with/logging_and_metrics/#note-about-ifndef-ndebugendif-blocks","title":"Note about #ifndef NDEBUG/#endif blocks","text":"<p>Many of the plugins contain their logging statements inside of blocks which are only active when doing a debug build.\nThis is a historical artifact. New plugins should carefully consider the difference between logging a debug message and\nconditionally compiling blocks of code based on build type.</p>"},{"location":"working_with/logging_and_metrics/#metrics","title":"Metrics","text":"<p>ILLIXR allows users to generate higher order statistics from logged results called Metrics.</p>"},{"location":"working_with/modifying_a_plugin/","title":"Modifying a plugin","text":""},{"location":"working_with/modifying_a_plugin/#tutorial","title":"Tutorial","text":"<p>This is how you can modify an existing ILLIXR plugin. This example uses the Audio Pipeline plugin, but the steps can be applied to any plugin.</p> <ol> <li> <p>Fork the repository for the component you want to modify into your own repo using the GitHub     web interface, then pull your repo to your computer. For example, using the Audio Pipeline plugin:</p> <pre><code>git clone https://github.com//audio_pipeline.git\n\n\n<li>\n<p>Modify the associated <code>cmake/GetAudioPipeline.cmake</code>\n    original</p>\n<pre><code>get_external(PortAudio)\nget_external(SpatialAudio)\n\nset(AUDIO_PIPELINE_CMAKE_ARGS \"\")\nExternalProject_Add(Audio_Pipeline\n                    GIT_REPOSITORY https://github.com/ILLIXR/audio_pipeline.git\n                    GIT_TAG 714c3541378ece7b481804e4a504e23b49c2bdbe\n                    PREFIX ${CMAKE_BINARY_DIR}/_deps/audio_pipeline\n                    DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR}\n                    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS}\n)\n</code></pre>\n<p>which becomes <code>cmake/GetMyAudioPipeline.cmake</code></p>\n<pre><code>get_external(PortAudio)\nget_external(SpatialAudio)\n\nset(AUDIO_PIPELINE_CMAKE_ARGS \"\")\nExternalProject_Add(Audio_Pipeline\n                    GIT_REPOSITORY https://github.com//audio_pipeline.git\n                    PREFIX ${CMAKE_BINARY_DIR}/_deps/myaudio_pipeline\n                    DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR}\n                    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS}\n)\n\n\n<li>\n<p>Make whatever changes to the plugin code you want and be sure to push them to your forked repo.</p>\n</li>\n<li>\n<p>See the instructions on Getting Started to learn how to build and run ILLIXR.</p>\n</li>\n<li>\n<p>To push the modification to upstream ILLIXR, create a PR to the original repository.</p>\n</li>"},{"location":"working_with/modules/","title":"Modules","text":""},{"location":"working_with/modules/#modulesjson-documentation","title":"modules.json Documentation","text":"<p>The modules.json file contains information necessary to generate lists of 3rd party dependencies for each plugin. This list is used by the getting_started page to produce yum/dnf/apt command lines for the user to cut and paste to install any necessary dependencies.</p> <p>There are three primary entries in the file:</p> <ul> <li>systems - supported operating systems</li> <li>plugins - listing of plugins and their dependencies</li> <li>dependencies - listing of 3rd party dependencies and OS specific install information</li> </ul>"},{"location":"working_with/modules/#systems","title":"Systems","text":"<p>The systems section lists each supported operating system and the supported versions in the following format:</p> <pre><code>{\n  \"name\": \"\",          # the name of the operating system (e.g. Ubuntu, Fedora, etc.)\n  \"versions\": [\"\", \"\"]  # json array containing the supported version(s) (e.g. 22, 9, 37)\n}"},{"location":"working_with/modules/#plugins","title":"Plugins","text":"<p>The plugins section lists each plugin and any 3rd party dependencies (packages) in the following format:</p>\n<pre><code>{\n  \"name\": \"&gt;,               # name of the plugin (same as the name of the plugin subdirectory\n  \"cmake_flag\": \"USE_=ON\",  # name of the plugin in all caps\n  \"dependencies\": [\"\", \"\"]       # json array listing the dependency names, which must match the name in the dependencies section\n}"},{"location":"working_with/modules/#dependencies","title":"Dependencies","text":"<p>The dependencies section lists every possible ILLIXR dependency along with how to install each on the different supported operating systems. The entries are in the following format and assumes the supported operating systems as of March 2025:</p>\n<pre><code>{\n  \"\": {      # the name of the dependency, must match any uses in the plugins section\n    \"pkg\": {\n      \"Ubuntu\": {\n        \"pkg\": \"\",  # the name of the apt package(s) to install to get this dependency, can be a space seperated list, leave as an empty string if this OS does not supply it\n        \"postnotes\": \"\",          # for any post-installation instructions to properly configure things\n        \"notes\": \"\"               # for any installation notes or instructions, specifically if the package needs to be manually installed\n      },\n      \"Fedora\": {\n        \"pkg\": \"\",  # the name of the dnf package(s) to install to get this dependency, can be a space seperated list, leave as an empty string if this OS does not supply it\n        \"postnotes\": \"\",          # for any post-installation instructions to properly configure things\n        \"notes\": \"\"               # for any installation notes or instructions, specifically if the package needs to be manually installed\n      }\n    }\n  }\n}"},{"location":"working_with/updating_tags_and_docs/","title":"Updating Tags and Documentation","text":""},{"location":"working_with/updating_tags_and_docs/#updating-tags","title":"Updating Tags","text":"<p>For releases, perform these steps from <code>master</code> once the desired features have been merged in.</p> <ol> <li> <p>Get latest tags:</p> <pre><code>git pull --tags -f\n</code></pre> </li> <li> <p>Tag your branch. Please use semantic versioning to name the tag; i.e., <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>:</p> <pre><code>git tag -f  ## `-f` is required if updating an existing tag\n\n\n<li>\n<p>Push your tag upstream:</p>\n<p><code>{ .bash .copy }</code>\ngit push origin --tags\n```</p>\n</li>"},{"location":"working_with/updating_tags_and_docs/#updating-documentation","title":"Updating Documentation","text":"<p>To generate the documentation (will pick up any changes) be sure to add <code>-DBUILD_DOCS=ON</code> to your cmake flags. Then from the build directory run:</p>\n<pre><code>```  { .bash .copy }\ncmake --build . -t docs  # this will put the generated documentation in /docs/docs\ncmake --install .        # this will install the generated docs in your install directory under 'share/doc/ILLIXR/docs'\n```"},{"location":"working_with/using_cameras/","title":"Using Cameras with ILLIXR","text":"<p>ILLIXR supports a wide range of cameras, most of which are for the purpose of feeding images and IMU measurements to the system.  To learn more about how it works, checkout Getting Started. If you are interested in what topics these cameras feed into, checkout ILLIXR plugins.</p> <p>Info</p> <p>Before running any of these plugins below, it is important to not have <code>offline_cam</code> and <code>offline_imu</code> in your plugin list for the executable (either via yaml file or command line).</p>"},{"location":"working_with/using_cameras/#add-calibration-parameters","title":"Add Calibration Parameters","text":"<p>In order to add your camera's calibration extrinsics, you need to modify your choice of SLAM/VIO plugin. Follow these instructions to modify a plugin.</p> <ul> <li> <p><code>OpenVINS</code>:</p> <p>Navigate to <code>ov_msckf/src</code>. Uncomment this line out in <code>slam2.cpp</code> in order to use ZED's calibration parameter for OpenVins.  You can add your own calibration parameters in the same file.     </p> </li> </ul>"},{"location":"working_with/using_cameras/#zed-mini","title":"ZED Mini","text":"<ol> <li> <p>Install ZED SDK </p> <p>Install the latest version of the ZED SDK on stereolabs.com. For more information, checkout the ZED API documentation.</p> </li> <li> <p>Get ZED's calibration parameters</p> <p>Both OpenVINS have a decent calibration parameters for ZED. But if you wish to add your own: </p> <pre><code>/usr/local/zed/tools/ZED_Calibration\n</code></pre> <p>Your original factory calibration file is stored here</p> <pre><code>/usr/local/zed/settings/\n</code></pre> <p>Or download it from calib.stereolabs.com.</p> </li> <li> <p>Enable ZED in OpenVINS plugin</p> <p>This step is only required if using OpenVINS. Uncomment this line in the OpenVINS plugin. </p> </li> <li> <p>Run ILLIXR with ZED: </p> <p>Add <code>zed</code> to the plugins list in any yaml profile file and run ILLIXR normally.</p> </li> </ol>"},{"location":"working_with/using_cameras/#intel-realsense","title":"Intel Realsense","text":"<p>ILLIXR has been tested with Intel RealSense D455, but it should work with any D or T series RealSense Camera. </p> <ol> <li> <p>Install librealsense (if you haven't already):</p> <p>Instruction on how to install can be found here.</p> </li> <li> <p>Get RealSense calibration parameters:</p> <p>Navigate to <code>enumerate-devices</code></p> <pre><code>./PATH/TO/LIBREALSENSE/build/tools/enumerate-devices\n</code></pre> <p>Run this command to obtain the calibration parameters</p> <pre><code>./rs-enumerate-devices -c\n</code></pre> </li> <li> <p>Run ILLIXR with RealSense: </p> <p>Add <code>realsense</code> to the plugins list in any yaml profile file and run ILLIXR normally.</p> <p>Note</p> <p>We will release the corresponding <code>#define realsense</code> soon for OpenVINS + Realsense</p> </li> </ol>"},{"location":"working_with/virtualization/","title":"Setting up ILLIXR in QEMU","text":""},{"location":"working_with/virtualization/#install-qemu","title":"Install QEMU","text":"<p>Use you package manager (<code>apt</code> for Ubuntu) to install <code>qemu</code></p>"},{"location":"working_with/virtualization/#setup-ubuntu-in-the-vm","title":"Setup Ubuntu in the VM","text":"<p>Run <code>ILLIXR/qemu/qemu.sh</code> to download Ubuntu 22.04, create a virtual hard drive     (<code>illixr.qcow2</code>), and launch <code>qemu</code>.</p> <p>Your VM image will be created at <code>ILLIXR/qemu/illixr.qcow2</code>. Ubuntu will be downloaded and saved at <code>ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso</code>.</p> <p>You will be prompted to install Ubuntu;     follow the instructions and install Ubuntu to the virtual hard drive.</p> <p></p> <p>Choose the \"erase all\" option and confirm:</p> <p> </p> <p>Pick any account name and password you like.</p> <p></p> <p>Once Ubuntu is installed you will be asked to reboot. Close <code>qemu</code> and then run <code>ILLIXR/qemu/qeum.sh</code> again to boot into your brand-new Ubuntu install!</p>"},{"location":"working_with/virtualization/#booting-the-vm","title":"Booting the VM","text":"<p>To launch the VM from now on, just use <code>ILLIXR/qemu/qemu.sh</code>. This will boot from the Ubuntu image we created earlier (<code>illixr.qcow2</code>). Once Ubuntu is installed, it is safe to delete <code>ubuntu-22.04.2-desktop-amd64.iso</code>.</p>"},{"location":"working_with/virtualization/#setting-up-the-vm","title":"Setting up the VM","text":"<p>Once inside the VM, set up and run ILLIXR as found on the Getting Started page.</p>"},{"location":"working_with/virtualization/#uninstalling","title":"Uninstalling","text":"<p>To delete your local VM, just delete <code>ILLIXR/qemu/illixr.qcow2</code>.</p> <p><code>ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso</code> can be deleted anytime you want after Ubuntu     is installed to your VM.</p> <p>If you've deleted <code>illixr.qcow2</code>, you can run <code>ILLIXR/qemu/qemu.sh</code> to recreate it and reinstall everything.</p>"},{"location":"working_with/writing_your_plugin/","title":"Writing Your Plugin","text":""},{"location":"working_with/writing_your_plugin/#adding-a-new-plugin","title":"Adding a New Plugin","text":"<p>To add a new plugin</p> <ol> <li>create a new subdirectory in the <code>plugins</code> directory named for your plugin (no spaces)</li> <li>put your code in this new subdirectory (additional subdirectories containing parts of your code are allowed)</li> <li>create a CMakeLists.txt file in this new subdirectory. See the template below</li> <li>add the plugin to the <code>profiles/plugins.yaml</code> file, the name must match the subdirectory you created; it should go in    the <code>all_plugins</code> entry</li> </ol> <p>For the examples below is for a plugin called tracker, so just replace any instance of tracker with the name of your plugin.</p>"},{"location":"working_with/writing_your_plugin/#simple-example","title":"Simple Example","text":"<pre><code>set(TRACKER_SOURCES plugin.cpp\n                    plugin.hpp\n                    src/tracker.cpp\n                    src/tracker.hpp)\n\nset(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n\nadd_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include)\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> Line # Notes 1-4 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 6 Put the plugin name into a variable (will also be the name of the library). 8 Tell the system we are building a shared library with the name  <code>PLUGIN_NAME</code> from the specified source files. 10 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR_SOURCE_DIR/include</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 12 Any compile options specific to this plugin. Usually this will be left as is. 14 Add the install directive. This should not need to change."},{"location":"working_with/writing_your_plugin/#more-complex-example","title":"More Complex Example","text":"<p>In this example the plugin has external dependencies provided by OS repos, specifically glfw3, x11, glew, glu, opencv, and eigen3.</p> <pre><code>set(TRACKER_SOURCES plugin.cpp\n                    plugin.hpp\n                    src/tracker.cpp\n                    src/tracker.hpp)\n\nset(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n\nfind_package(glfw3 REQUIRED)\n\nadd_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} dl pthread)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> Line# Notes 1-4 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 6 Put the plugin name into a variable (will also be the name of the library). 8 Use the <code>find_package</code> directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. <code>find_package</code> assumes that there is an appropriate .cmake config file for the dependency on your system. If not the <code>pkg_check_module</code> function will perform the same task, but for dependencies which have associated .pc files on your system. 10 Tell the system we are building a shared library with the name   <code>PLUGIN_NAME</code>  from the specified source files. 12 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR _SOURCE_DIR</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 13 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 14 Any compile options specific to this plugin. Usually this will be left as is. 16 Add the install directive. This should not need to change. <p>Note</p> <p>Not all the dependencies were searched for by <code>find_package</code> in this example. This is because there is a set of dependencies which are very common to many plugins and their <code>find_package</code> calls are in the main ILLIXR CMakeLists.txt file and do not need to be searched for again. These packages are</p> <ul> <li>Glew</li> <li>Glu</li> <li>SQLite3</li> <li>X11</li> <li>Eigen3</li> <li>OpenCV</li> </ul>"},{"location":"working_with/writing_your_plugin/#very-complex-example","title":"Very Complex Example","text":"<p>In this example the plugin has dependencies provided by OS repos, and a third party dependency provided by a git repo.</p> <pre><code>set(TRACKER_SOURCES plugin.cpp\n                    src/tracker.cpp\n                    src/tracker.hpp)\n\nset(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n\nfind_package(glfw3 REQUIRED)\n\nadd_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n\nget_external(Plotter)\n\nadd_dependencies(${PLUGIN_NAME} Plotter)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS} ${Plotter_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} ${Plotter_LIBRARIES} dl pthread)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> Line# Notes 1-3 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the <code>find_package</code> directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. <code>find_package</code> assumes that there is an appropriate .cmake config file for the dependency on your system. If not the <code>pkg_check_module</code> function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name   <code>PLUGIN_NAME</code>  from the specified source files. 11 Get the external project called Plotter. 13 Add the external package as a build dependency, this ensures that this plugin won't be built until after the dependency is. 15 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR _SOURCE_DIR</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 16 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 17 Any compile options specific to this plugin. Usually this will be left as is. 19 Add the install directive. This should not need to change. <p>Additionally, to build and install the Plotter dependency you will need to create a cmake file in the <code>cmake</code> directory named <code>GetPlotter.cmake</code> (case matters, it must match the call to <code>get_external</code>) with the following content.</p> <pre><code>find_package(Plotter QUIET)\n\nif(Plotter_FOUND)\n    set(Plotter_VERSION \"${Plotter_VERSION_MAJOR}\")\nelse()\n    EXTERNALPROJECT_ADD(Plotter\n            GIT_REPOSITORY https://github.com/mygit/Plotter.git\n            GIT_TAG 4ff860838726a5e8ac0cbe59128c58a8f6143c6c\n            PREFIX ${CMAKE_BINARY_DIR}/_deps/plotter\n            CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=Release\n            )\n    set(Plotter_EXTERNAL Yes)\n    set(Plotter_INCLUDE_DIRS ${CMAKE_INSTALL_PREFIX}/include)\n    set(Plotter_LIBRARIES plotter;alt_plotter)\nendif()\n</code></pre> Line # Notes 1 See if the package has been previously installed, quietly fail if not. 4 If it was found, just record the installed version for reporting. 6-11 Add the Plotter package as a project called <code>Plotter</code> (also case sensitive) 7 The git repo where the Plotter package is located. 8 The git tag to use (can be a tag name or sha5 from a commit). 9 The build directory for the package. 10 Any camke arguments to pass to the Plotter build. The ones specified here are required, but any others can be added. 12 Denote that this is an external package (this is used for internal tracking). 13 Set where the Plotter include files will land. Usually this will not need to change. 14 Set which libraries are built by the Plotter package. In this example <code>libplotter.so</code> and <code>libalt_plotter.so</code> are being built."},{"location":"working_with/writing_your_plugin/#external-plugins","title":"External Plugins","text":"<p>For plugins that are external packages (e.g. Audio_Pipeline) you need only create a <code>GetX.cmake</code> file as above and add the plugin name to the <code>all_plugins</code> list in <code>profiles/plugins.yaml</code>.</p> <p>External plugins with external dependencies are a bit more work, but are straight forward. See how Audio Pipeline is handled.</p> <p>For a plugin which uses the mediapipe framework (e.g. hand_tracking) see Mediapipe Based Plugins for additional information.</p>"},{"location":"working_with/writing_your_plugin/#tutorial","title":"Tutorial","text":"<p>You can extend ILLIXR for your own purposes. To add your own functionality via the plugin interface:</p> <ol> <li> <p>Create a new directory for your plugin in one of these ways</p> <ol> <li>in the plugins directory of the main ILLIXR tree, then follow these instructions</li> <li>anywhere for your new plugin so it can be pushed as a git repository, the    follow these instructions focussing on external plugins</li> </ol> </li> <li> <p>You must decide if your plugin should inherit the standardized <code>threadloop</code>    or <code>plugin</code>.</p> <ul> <li> <p>If your plugin just needs to run one computation repeatedly, then your   plugin class should extend <code>threadloop</code>. Your code goes in   <code>_p_one_iteration</code>, which gets called in a hot loop. <code>threadloop</code>   inherits from plugin, but adds threading functionality. If you don't   use <code>_p_one_iteration</code>, inheriting from <code>threadloop</code> is superfluous;   Inherit from plugin directly instead.</p> </li> <li> <p>If you need custom concurrency (more complicated than a loop), triggered   concurrency (by events fired in other plugins), or no concurrency   then your plugin class should extend <code>plugin</code>. Your code goes   in the <code>start</code> method.</p> </li> <li> <p>If you want to schedule data-driven work in either case, call   <code>sb-&gt;schedule(...)</code>.</p> </li> <li> <p>If you spin your own threads, they must wait for   <code>pb-&gt;lookup_impl&lt;stoplight&gt;()-&gt;wait_for_ready()</code> the first time they   run. This allows the start of all threads in ILLIXR to be   synchronized.</p> </li> <li> <p>They must be joined-or-disowned at-or-before   <code>plugin::stop()</code>. This allows ILLIXR to shut down cleanly.</p> </li> </ul> </li> <li> <p>Write a file called <code>plugin.hpp</code> with this body, replacing every instance of <code>basic_plugin</code>:</p> <pre><code>#pragma once\n// A minimal/no-op ILLIXR plugin\n\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nnamespace ILLIXR {\n\n// Inherit from plugin if you don't need the threadloop\n// Inherit from threadloop to provide a new thread to perform the task\nclass basic_plugin : public threadloop {\npublic:\n    basic_plugin(std::string name_, phonebook* pb_);\n\n    ~basic_plugin() override;\nprotected:\n    // For `threadloop` style plugins, do not override the start() method unless you know what you're doing.\n    // _p_one_iteration() is called in a thread created by threadloop::start()\n    void        _p_one_iteration() override;\n    skip_option _p_should_skip() override;\n\n};\n}\n</code></pre> </li> <li> <p>Write a file called <code>plugin.cpp</code> which contains the implementations of which of the above functions.</p> <pre><code>// A minimal/no-op ILLIXR plugin\n\n#include \"plugin.hpp\"\n\n#include \n#include \n#include \n\nusing namespace ILLIXR;\n\n basic_plugin::basic_plugin(std::string name_, phonebook* pb_)\n       : threadloop{name_, pb_} {\n        std::cout &lt;&lt; \"Constructing basic_plugin.\" &lt;&lt; std::endl;\n }\n\n basic_plugin::~basic_plugin() {\n     std::cout &lt;&lt; \"Deconstructing basic_plugin.\" &lt;&lt; std::endl;\n }\n\n void basic_plugin::_p_one_iteration() {\n     std::cout &lt;&lt; \"This goes to the log when `log` is set in the config.\" &lt;&lt; std::endl;\n     std::cerr &lt;&lt; \"This goes to the console.\" &lt;&lt; std::endl;\n     std::this_thread::sleep_for(std::chrono::milliseconds{100});\n }\n\nthreadloop::skip_option _p_should_skip() {\n    if (&lt;CONDITION WHEN _p_one_iteration SHOULD RUN&gt;)\n        return skip_option::run;\n    return skip_option::skip_and_spin;\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(basic_plugin);\n\n\n<li>\n<p>At this point, you should be able to build your plugin with ILLIXR using <code>-DUSE=ON as a command line\n   argument to cmake.\n   See Getting Started for more details.\n\n<li>\n<p>Finally, run ILLIXR with your new plugin following the instructions in Getting Started:</p>\n</li>\n<li>\n<p>This is all that is required to be a plugin which can be loaded by Spindle in\n   the ILLIXR runtime.\n   Reading and writing from Phonebook and Switchboard is optional,\n   but nearly every plugin does it.</p>\n<p>First, we can query the <code>phonebook</code> to get various services\nincluding <code>switchboard</code>.\nThen we query <code>switchboard</code> for event-streams (topics).\nWe will read <code>topic1</code>, write to <code>topic2</code>, and schedule computation on <code>topic 3</code>.\nSee the API documentation for <code>phonebook</code> and <code>switchboard</code> for more details.</p>\n<p>plugin.hpp\n<pre><code>#pragma once\n\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(std::string name_, phonebook* pb_);\n\nprotected:\n    void _p_one_iteration() override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n    switchboard::reader&lt;topic1_type&gt; topic1_;\n    switchboard::writer&lt;topic2&gt; topic2_;\n};\n</code></pre></p>\n<p>plugin.cpp\n<pre><code>#include \"plugin.hpp\"\n\n#include \n\n/* After the constructor, C++ permits a list of member-constructors.\n * We use uniform initialization (curly-braces) [1] instead of parens to\n *     avoid ambiguity [2].\n * We put the comma at the start of the line, so that lines can be copied around\n *     or deleted freely (except for the first).\n *\n * [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n * [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n */\nplugin_name::plugin_name(std::string name_, phonebook* pb_)\n   : threadloop{name_, pb_}\n   , switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}             // Find the switchboard in phonebook\n   , topic1_{switchboard_-&gt;get_reader&lt;topic1_type&gt;(\"topic1\")}  // Create a handle to a topic in switchboard for subscribing\n   , topic2_{switchboard_-&gt;get_writer&lt;topic2_type&gt;(\"topic2\")}  // Create a handle to a topic in switchboard for publishing\n    {\n    // Read topic 1\n    switchboard::ptr&lt;const topic1_type&gt; event1 = topic1_.get_ro();\n\n    // Write to topic 2\n    topic2_.put(\n        topic2_.allocate&lt;topic2_type&gt;(\n            arg_1, // topic2_type::topic2_type() arg_type_1\n            ...,   // ...\n            arg_k  // topic2_type::topic2_type() arg_type_k\n        )\n    );\n\n    /// Read topic 3 synchronously\n    switchboard_-&gt;schedule&lt;topic3_type&gt;(\n        get_name(),\n        \"topic3\",\n        [&amp;](switchboard::ptr&lt;const topic3_type&gt; event3, std::size_t) {\n            /* This is a [lambda expression][1]\n             *\n             * [1]: https://en.cppreference.com/w/cpp/language/lambda\n             */\n            std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n            callback(event3);\n        }\n    );\n}\n\nvoid _p_one_iteration() {\n    std::cout &lt;&lt; \"Running\" &lt;&lt; std::endl;\n    auto target = std::chrono::system_clock::now()\n                + std::chrono::milliseconds{10};\n    reliable_sleep(target);\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);"}]}