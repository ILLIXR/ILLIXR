// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gldemo_input.proto

#ifndef PROTOBUF_INCLUDED_gldemo_5finput_2eproto
#define PROTOBUF_INCLUDED_gldemo_5finput_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_gldemo_5finput_2eproto 

namespace protobuf_gldemo_5finput_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_gldemo_5finput_2eproto
namespace gldemo_input_proto {
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternionf;
class QuaternionfDefaultTypeInternal;
extern QuaternionfDefaultTypeInternal _Quaternionf_default_instance_;
class Vec3f;
class Vec3fDefaultTypeInternal;
extern Vec3fDefaultTypeInternal _Vec3f_default_instance_;
}  // namespace gldemo_input_proto
namespace google {
namespace protobuf {
template<> ::gldemo_input_proto::Pose* Arena::CreateMaybeMessage<::gldemo_input_proto::Pose>(Arena*);
template<> ::gldemo_input_proto::Quaternionf* Arena::CreateMaybeMessage<::gldemo_input_proto::Quaternionf>(Arena*);
template<> ::gldemo_input_proto::Vec3f* Arena::CreateMaybeMessage<::gldemo_input_proto::Vec3f>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace gldemo_input_proto {

// ===================================================================

class Vec3f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gldemo_input_proto.Vec3f) */ {
 public:
  Vec3f();
  virtual ~Vec3f();

  Vec3f(const Vec3f& from);

  inline Vec3f& operator=(const Vec3f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec3f(Vec3f&& from) noexcept
    : Vec3f() {
    *this = ::std::move(from);
  }

  inline Vec3f& operator=(Vec3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3f* internal_default_instance() {
    return reinterpret_cast<const Vec3f*>(
               &_Vec3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Vec3f* other);
  friend void swap(Vec3f& a, Vec3f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec3f* New() const final {
    return CreateMaybeMessage<Vec3f>(NULL);
  }

  Vec3f* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vec3f>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vec3f& from);
  void MergeFrom(const Vec3f& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:gldemo_input_proto.Vec3f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gldemo_5finput_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quaternionf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gldemo_input_proto.Quaternionf) */ {
 public:
  Quaternionf();
  virtual ~Quaternionf();

  Quaternionf(const Quaternionf& from);

  inline Quaternionf& operator=(const Quaternionf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternionf(Quaternionf&& from) noexcept
    : Quaternionf() {
    *this = ::std::move(from);
  }

  inline Quaternionf& operator=(Quaternionf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternionf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternionf* internal_default_instance() {
    return reinterpret_cast<const Quaternionf*>(
               &_Quaternionf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Quaternionf* other);
  friend void swap(Quaternionf& a, Quaternionf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternionf* New() const final {
    return CreateMaybeMessage<Quaternionf>(NULL);
  }

  Quaternionf* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quaternionf>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quaternionf& from);
  void MergeFrom(const Quaternionf& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternionf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gldemo_input_proto.Vec3f vec = 2;
  bool has_vec() const;
  void clear_vec();
  static const int kVecFieldNumber = 2;
  private:
  const ::gldemo_input_proto::Vec3f& _internal_vec() const;
  public:
  const ::gldemo_input_proto::Vec3f& vec() const;
  ::gldemo_input_proto::Vec3f* release_vec();
  ::gldemo_input_proto::Vec3f* mutable_vec();
  void set_allocated_vec(::gldemo_input_proto::Vec3f* vec);

  // float w = 1;
  void clear_w();
  static const int kWFieldNumber = 1;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:gldemo_input_proto.Quaternionf)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gldemo_input_proto::Vec3f* vec_;
  float w_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gldemo_5finput_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gldemo_input_proto.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(NULL);
  }

  Pose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gldemo_input_proto.Vec3f position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  private:
  const ::gldemo_input_proto::Vec3f& _internal_position() const;
  public:
  const ::gldemo_input_proto::Vec3f& position() const;
  ::gldemo_input_proto::Vec3f* release_position();
  ::gldemo_input_proto::Vec3f* mutable_position();
  void set_allocated_position(::gldemo_input_proto::Vec3f* position);

  // .gldemo_input_proto.Quaternionf orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  private:
  const ::gldemo_input_proto::Quaternionf& _internal_orientation() const;
  public:
  const ::gldemo_input_proto::Quaternionf& orientation() const;
  ::gldemo_input_proto::Quaternionf* release_orientation();
  ::gldemo_input_proto::Quaternionf* mutable_orientation();
  void set_allocated_orientation(::gldemo_input_proto::Quaternionf* orientation);

  // fixed64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gldemo_input_proto.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gldemo_input_proto::Vec3f* position_;
  ::gldemo_input_proto::Quaternionf* orientation_;
  ::google::protobuf::uint64 time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gldemo_5finput_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec3f

// float x = 1;
inline void Vec3f::clear_x() {
  x_ = 0;
}
inline float Vec3f::x() const {
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Vec3f.x)
  return x_;
}
inline void Vec3f::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:gldemo_input_proto.Vec3f.x)
}

// float y = 2;
inline void Vec3f::clear_y() {
  y_ = 0;
}
inline float Vec3f::y() const {
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Vec3f.y)
  return y_;
}
inline void Vec3f::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:gldemo_input_proto.Vec3f.y)
}

// float z = 3;
inline void Vec3f::clear_z() {
  z_ = 0;
}
inline float Vec3f::z() const {
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Vec3f.z)
  return z_;
}
inline void Vec3f::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:gldemo_input_proto.Vec3f.z)
}

// -------------------------------------------------------------------

// Quaternionf

// float w = 1;
inline void Quaternionf::clear_w() {
  w_ = 0;
}
inline float Quaternionf::w() const {
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Quaternionf.w)
  return w_;
}
inline void Quaternionf::set_w(float value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:gldemo_input_proto.Quaternionf.w)
}

// .gldemo_input_proto.Vec3f vec = 2;
inline bool Quaternionf::has_vec() const {
  return this != internal_default_instance() && vec_ != NULL;
}
inline void Quaternionf::clear_vec() {
  if (GetArenaNoVirtual() == NULL && vec_ != NULL) {
    delete vec_;
  }
  vec_ = NULL;
}
inline const ::gldemo_input_proto::Vec3f& Quaternionf::_internal_vec() const {
  return *vec_;
}
inline const ::gldemo_input_proto::Vec3f& Quaternionf::vec() const {
  const ::gldemo_input_proto::Vec3f* p = vec_;
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Quaternionf.vec)
  return p != NULL ? *p : *reinterpret_cast<const ::gldemo_input_proto::Vec3f*>(
      &::gldemo_input_proto::_Vec3f_default_instance_);
}
inline ::gldemo_input_proto::Vec3f* Quaternionf::release_vec() {
  // @@protoc_insertion_point(field_release:gldemo_input_proto.Quaternionf.vec)
  
  ::gldemo_input_proto::Vec3f* temp = vec_;
  vec_ = NULL;
  return temp;
}
inline ::gldemo_input_proto::Vec3f* Quaternionf::mutable_vec() {
  
  if (vec_ == NULL) {
    auto* p = CreateMaybeMessage<::gldemo_input_proto::Vec3f>(GetArenaNoVirtual());
    vec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gldemo_input_proto.Quaternionf.vec)
  return vec_;
}
inline void Quaternionf::set_allocated_vec(::gldemo_input_proto::Vec3f* vec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vec_;
  }
  if (vec) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vec, submessage_arena);
    }
    
  } else {
    
  }
  vec_ = vec;
  // @@protoc_insertion_point(field_set_allocated:gldemo_input_proto.Quaternionf.vec)
}

// -------------------------------------------------------------------

// Pose

// fixed64 time = 1;
inline void Pose::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Pose::time() const {
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Pose.time)
  return time_;
}
inline void Pose::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:gldemo_input_proto.Pose.time)
}

// .gldemo_input_proto.Vec3f position = 2;
inline bool Pose::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Pose::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::gldemo_input_proto::Vec3f& Pose::_internal_position() const {
  return *position_;
}
inline const ::gldemo_input_proto::Vec3f& Pose::position() const {
  const ::gldemo_input_proto::Vec3f* p = position_;
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Pose.position)
  return p != NULL ? *p : *reinterpret_cast<const ::gldemo_input_proto::Vec3f*>(
      &::gldemo_input_proto::_Vec3f_default_instance_);
}
inline ::gldemo_input_proto::Vec3f* Pose::release_position() {
  // @@protoc_insertion_point(field_release:gldemo_input_proto.Pose.position)
  
  ::gldemo_input_proto::Vec3f* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::gldemo_input_proto::Vec3f* Pose::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::gldemo_input_proto::Vec3f>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gldemo_input_proto.Pose.position)
  return position_;
}
inline void Pose::set_allocated_position(::gldemo_input_proto::Vec3f* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:gldemo_input_proto.Pose.position)
}

// .gldemo_input_proto.Quaternionf orientation = 3;
inline bool Pose::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void Pose::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) {
    delete orientation_;
  }
  orientation_ = NULL;
}
inline const ::gldemo_input_proto::Quaternionf& Pose::_internal_orientation() const {
  return *orientation_;
}
inline const ::gldemo_input_proto::Quaternionf& Pose::orientation() const {
  const ::gldemo_input_proto::Quaternionf* p = orientation_;
  // @@protoc_insertion_point(field_get:gldemo_input_proto.Pose.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::gldemo_input_proto::Quaternionf*>(
      &::gldemo_input_proto::_Quaternionf_default_instance_);
}
inline ::gldemo_input_proto::Quaternionf* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:gldemo_input_proto.Pose.orientation)
  
  ::gldemo_input_proto::Quaternionf* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::gldemo_input_proto::Quaternionf* Pose::mutable_orientation() {
  
  if (orientation_ == NULL) {
    auto* p = CreateMaybeMessage<::gldemo_input_proto::Quaternionf>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gldemo_input_proto.Pose.orientation)
  return orientation_;
}
inline void Pose::set_allocated_orientation(::gldemo_input_proto::Quaternionf* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:gldemo_input_proto.Pose.orientation)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gldemo_input_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_gldemo_5finput_2eproto
