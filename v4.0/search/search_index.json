{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ILLIXR","text":""},{"location":"#overview","title":"Overview","text":"<p>Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is a fully open-source Extended Reality (XR) system and testbed. The modular, extensible, and OpenXR-compatible ILLIXR runtime integrates state-of-the-art XR components into a complete XR system.</p> <p>The current ILLIXR release is v4.0. Source code is available from our GitHub repository, which also contains instructions for building fully contained Docker images. Docker images can also be downloaded from a hub (see here for instructions.)</p> <p>ILLIXR provides its components in standalone configurations to enable architects and system designers to research each component in isolation. The standalone components are packaged together as of the v3.1.0 release of ILLIXR.</p> <p>ILLIXR's modular and extensible runtime allows adding new components and swapping different implementations of a given component. ILLIXR currently contains the following plugins and services:</p>"},{"location":"#current-plugins-and-services","title":"Current Plugins and Services","text":""},{"location":"#perception","title":"Perception","text":"<ul> <li>Filter-based visual-inertial estimator<ul> <li>OpenVINS<sup>1</sup></li> </ul> </li> <li>Tracking<ul> <li>Head tracking: ORB_SLAM3<sup>1</sup> and lighthouse</li> <li>Hand tracking<sup>1</sup></li> <li>openni</li> <li>depthai</li> </ul> </li> <li>IMU integrators<ul> <li>gtsam_integrator</li> <li>passthrough_integrator</li> <li>rk4_integrator</li> </ul> </li> <li>Pose Related Service<ul> <li>fauxpose</li> <li>pose_prediction</li> <li>pose_lookup</li> </ul> </li> <li>Cameras<ul> <li>zed supporting ZED Mini</li> <li>realsense supporting Intel RealSense</li> <li>webcam</li> </ul> </li> </ul>"},{"location":"#visual","title":"Visual","text":"<ul> <li>Asynchronous reprojection:<ul> <li>timewarp_gl, OpenGL based</li> <li>timewarp_vk, Vulkan based</li> </ul> </li> <li>Asynchronous 6-degree reprojection openwarp</li> <li>vkdemo - toy application, with native ILLIXR rendering interface gldemo</li> <li>native_renderer - render management</li> <li>gldemo - stand-in application when ILLIXR is run as a standalone application without an actual OpenXR application</li> </ul>"},{"location":"#aural","title":"Aural","text":"<ul> <li>spatial audio encoding/playback<sup>1</sup></li> </ul>"},{"location":"#data-recording","title":"Data Recording","text":"<ul> <li>offload_data</li> <li>record_imu_cam</li> <li>record_rgb_depth</li> <li>zed_capture (standalone executable)</li> </ul>"},{"location":"#data-readinginjection","title":"Data Reading/Injection","text":"<ul> <li>offline_cam</li> <li>offline_imu</li> <li>zed.data_injection</li> <li>ground_truth_slam</li> </ul>"},{"location":"#visualization","title":"Visualization","text":"<ul> <li>debugview</li> <li>hand_tracking.viewer</li> </ul>"},{"location":"#offloadingremote-work","title":"Offloading/Remote Work","text":"<ul> <li>offload_vio</li> <li>offload_rendering_client</li> <li>offload_rendering_server</li> <li>tcp_network_backend</li> </ul> <p>Some components, such as eye tracking and reconstruction are available as standalone components and are in the process of being integrated.</p> <p>We continue to refine and add new components and implementations. Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked GitHub repository for proper attribution to its authors.</p>"},{"location":"#papers-talks-demos-consortium","title":"Papers, talks, demos, consortium","text":"<p>A paper with details on ILLIXR, including its components, runtime, telemetry support, and a comprehensive analysis of performance, power, and quality on desktop and embedded systems.</p> <p>A talk presented at NVIDIA GTC'21 describing ILLIXR and announcing the ILLIXR consortium: Video. Slides.</p> <p>A demo of an OpenXR application running with ILLIXR.</p> <p>The ILLIXR consortium is an industry-supported community effort to democratize XR systems research, development, and benchmarking. Visit our website for more information. For news and papers go to illixr.org, for talks see our YouTube channel, and join our Discord for announcements.</p>"},{"location":"#demo-videos","title":"Demo Videos","text":"<p>All of our demo videos can be seen on our YouTube channel. Here are some highlights:</p> Running Locally Head Tracking (VIO) Offloaded Video Link Video Link Video Link Video Link Rendering Offloaded Video Link"},{"location":"#citation","title":"Citation","text":"<p>We request that you cite our following paper when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.</p> <pre><code>@inproceedings{huzaifa2021illixr,\n  title={ILLIXR: Enabling end-to-end extended reality research},\n  author={Huzaifa, Muhammad and Desai, Rishi and Grayson, Samuel and Jiang, Xutao and Jing, Ying and Lee, Jae and Lu, Fang and Pang, Yihan and Ravichandran, Joseph and Sinclair, Finn and Tian, Boyuan and Yuan, Hengzhi and Zhang, Jeffrey and Adve, Sarita V.},\n  booktitle={2021 IEEE International Symposium on Workload Characterization (IISWC)},\n  pages={24--38},\n  year={2021},\n  organization={IEEE}\n}\n</code></pre> <p>Once your work is published, please send the citation to us at illixr@cs.illinois.edu.</p>"},{"location":"#contributing-and-documentation","title":"Contributing and Documentation","text":"<p>We welcome anyone to contribute to ILLIXR. If you wish to contribute, please see out contribution guide. Full documentation, including API specifications, can be found at our Getting Started page.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The ILLIXR project started in Sarita Adve\u2019s research group, co-led by PhD candidate Muhammad Huzaifa, at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Douglas Friedel, Steven Gao, Samuel Grayson, Qinjun Jiang, Xutao Jiang, Ying Jing, Jae Lee, Jeffrey Liu, Fang Lu, Yihan Pang, Joseph Ravichandran, Giordano Salvador, Rahul Singh, Finn Sinclair, Boyuan Tian, Henghzhi Yuan, and Jeffrey Zhang.</p> <p>ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.</p> <p>Our OpenXR implementation is derived from Monado. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.</p> <p>The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center (a JUMP Center co-sponsored by SRC and DARPA), the Center for Future Architectures Research (C-FAR, a STARnet research center), a Semiconductor Research Corporation program sponsored by MARCO and DARPA, National Science Foundation grants 2120464 and 2217144 and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset.</p> <p>Wesley Darvin came up with the name for ILLIXR.</p>"},{"location":"#licensing-structure","title":"Licensing Structure","text":"<p>ILLIXR is available as open-source software under the permissive University of Illinois/NCSA Open Source License. As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software. The external libraries and software included in ILLIXR each have their own licenses and must be used according to those licenses:</p> Package License<sup>2</sup> abseil-cpp Apache v2 ARM NEON 2 x86 SSE BSD-2 clause<sup>3</sup> concurrentqueue BSD-2 clause cxxopts MIT Depthai Core MIT EGL-Registry None given farmhash MIT FFmpeg GNU General Public License v3.0<sup>4</sup> filter MIT flatbuffers Apache v2 gemmlowp Apache v2 glslang BSD-3 clause<sup>5</sup> Gtsam BSD-2 clause<sup>3</sup> imgui MIT mediapipe Apache v2 Monado MIT Monado integration Boost v1 Monado Vulkan Integration Boost v1 moodycamel::ConcurrentQueue BSD-2 clause<sup>3</sup> OouraFFT MIT-like Open-VINS GNU General Public License v3.0 OpenXR Boost v1 ORB_SLAM3 GNU General Public License v3.0 protobuf BSD-3 clause pthreadpool BSD-2 clause<sup>3</sup> robin-hood-hashing MIT ruy Apache v2 SPIRV Headers MIT SPIRV Tools Apache v2 SqliteCPP MIT stb MIT tensorflow-lite Apache v2 tinyobjloader MIT Vulkan Headers Apache v2 Vulkan Loader Apache v2 Vulkan Utility Libraries Apache v2 Vulkan Validation Layers Apache v2 VulkanMemoryAllocator MIT XNNPACK BSD-3 clause yaml-cpp MIT zed_opencv (Sterolabs) MIT <p>Any LGPL or GPL licensed code are contained in optional components. ILLIXR's extensibility allows the source to be configured and compiled using only permissively licensed software, if desired. See out Getting Started page for instructions.</p>"},{"location":"#get-in-touch","title":"Get in Touch","text":"<p>Whether you are a computer architect, a compiler writer, a systems person, work on XR related algorithms or applications, or just anyone interested in XR research, development, or products, we would love to hear from you and hope you will contribute! You can join our Discord, mailing list, email us, or just send a pull request!</p> <ol> <li> <p>Source is hosted in an external repository under the ILLIXR project.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Current as of March 5, 2025.\u00a0\u21a9</p> </li> <li> <p>Also known as the Simplified BSD License.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>ILLIXR uses a customized version of FFmpeg, compiled with x264 and x265 encoding support, thus it is licensed under GPL v3.0\u00a0\u21a9</p> </li> <li> <p>This software is covered by multiple open source licenses, see the link for details.\u00a0\u21a9</p> </li> </ol>"},{"location":"CHANGELOG/","title":"ILLIXR v4.0 (2025-03-28)","text":"<ul> <li>Release Notes   This release of ILLIXR brings many new features and capabilities. A good potion of the code base has been refactored/reorganized to both standardize the code and group similar parts together. There were a total of 16 pull requests merged which introduced 10 new plugins, overhauled several others, and addressed 13 issues. The new plugins include remote rendering, hand tracking, and ORB_SLAM. Vulkan is now the default display back-end, and due to this, some of the OpenGL based plugins may not work on every system. See below for more detailed notes on the changes.</li> <li>Plugins</li> <li>Introduces a new ORB_SLAM3 based plugin. By @hungdche in PR #407</li> <li>Deployed four new plugins: hand_tracking, webcam, hand_tracking.viewer, and zed.data_injection, reworked the zed plugin, and a zed_capture executable.<ul> <li>hand_tracking: detects and reports the positions of joints and fingertips; if depth information is available, or distances can be calculated by parallax, the reported coordinates are real-world in millimeters, otherwise they are in pixel coordinates</li> <li>webcam: captures images from a webcam and publishes them to the <code>webcam</code> topic</li> <li>hand_tracking.viewer: gui based interface for visualizing the output of the hand_tracker in real time</li> <li>zed.data_injection: reads in data from disk and publishes it as if it were the zed plugin, good for debugging and testing</li> <li>zed: now publishes information about the camera (pixels, field of view, etc.) which is required for some modes of depth sensing; also now publishes the pose corresponding to the current images; these are in addition to the images and IMU information it has always published</li> <li>zed_capture: a standalone executable used to capture the images and poses from the zed camera and write them to disk (currently does not capture depth information); the products of this executable are intended to be used by the zed.data_injection plugin   By @astro-friedel in PR #428</li> </ul> </li> <li>The hand tracking plugin now can be used as an OpenXR API Layer, where it will intercept calls to get hand tracking data. It has been tested with Monado, but should be generally compatible. Adheres to OpenXR-1.0 standards. By @astro-friedel in PR #436</li> <li>Deployed the following plugins:<ul> <li>tcp_network_backend: a backend for Switchboard using TCP to transmit topics between two connected ILLIXR instances</li> <li>offload_rendering_server: encodes OpenXR frames with FFMPEG and transmits them across the Switchboard network backend</li> <li>offload_rendering_client: decodes frames transmitted from an offload_rendering_server instance and adds decoded frames to a buffer pool</li> <li>openwarp_vk: an implementation of OpenWarp, 6-DoF asynchronous reprojection, in ILLIXR</li> <li>lighthouse: uses libsurvive to connect with Valve Index lighthouses for head tracking native_renderer has been reworked so that external applications can run asynchronously with reprojection.   By @qinjunj, @Jebbly, @shg8 in PR #437</li> </ul> </li> <li>Infrastructure</li> <li>File loading is used by several plugins, each with their own code. The file loading code has been centralized into <code>data_loading.hpp</code>. By @astro-friedel in PR #416</li> <li>Fixed an issue where plugins needed to be specified in the correct order, or they would throw an exception. By @astro-friedel in PR #417</li> <li>Fixed an issue when changing a profile name and re-running CMake. By @astro-friedel in PR #418</li> <li>The Runge-Kutta code was replicated several times in the code base. This code has now been centralized and rewritten to make it compatible with the current ILLIXR license. By @astro-friedel in PR #421</li> <li>Updated the tcp socket code so that it can be distributed under the current ILLIXR license. By @williamsentosa95 in PR #424</li> <li>The hand tracking plugin introduced a large number of breaking and non-breaking changes to the base structures used by ILLIXR.<ul> <li>breaking: the <code>cam_type</code> structures have been completely overhauled</li> <li>all now inherit from a <code>cam_base_type</code> base struct, allowing for the <code>cam_base_type</code> to be used as a function argument type, letting a single function handle several different types of image input</li> <li>all <code>cam_base_type</code> based structs are now defined in the common headers (under include/illixr) rather than in some plugins</li> <li>there are now the following types: <code>binocular_cam_type</code>, <code>monocular_cam_type</code>, <code>rgb_depth_type</code>, <code>depth_type</code>, and <code>cam_type_zed</code></li> <li>breaking: the header <code>data_format.hpp</code> was getting too large and complex; it has been broken up into multiple headers under the <code>data_format</code> directory, with all struts and functions inside the <code>ILLIXR::data_format</code> namespace</li> <li>camera_data.hpp: structures used to describe the physical characteristics of a camera (# pixels, field of view, etc.)</li> <li>coordinate.hpp: enums for labelling the coordinate reference axes (e.g. LEFT_HANDED_Y_UP, RIGHT_HANDED_Y_UP, RIGHT_HANDED_Z_UP_X_FWD)</li> <li>frame.hpp: the <code>rendered_frame</code> struct</li> <li>hand_tracking_data: structs for holding positional information of points of a hand</li> <li>imu.hpp: all imu related structs</li> <li>misc.hpp: definitions that didn't fit with anything else</li> <li>opencv_data_types.hpp: most <code>cam_base_type</code> structs</li> <li>point.hpp: various structs for holding information about a point in 3D space</li> <li>pose.hpp: all pose related structs</li> <li>shape.hpp: structs related to shapes (e.g. rectangle)</li> <li>template.hpp: common templated functions</li> <li>unit.hpp: enums and functions related to units of measure</li> <li>zed_cam.hpp: the <code>cam_type_zed</code> struct; this is kept separate from the other <code>cam_base_type</code> due to potential dependencies on ZED headers, which not all systems have</li> <li>The pose structures were expanded to hold additional information used by the hand_tracking code, these additions do not affect current uses of these structures   By @astro-friedel in PR #428, #440</li> </ul> </li> <li>Environment variable handling has been introduced to the <code>switchboard</code>. Calls to <code>std::getenv</code> have been replaced with calls to <code>swithchboard-&gt;get_env</code>, <code>switchbaord-&gt;get_env_char</code>, or <code>switchbaord-&gt;get_env_bool</code> and calls to <code>std::setenv</code> have been replaced with calls to <code>switchboard-&gt;set_env</code>. This change allows the switchboard to act as a broker for all environment variables. Additionally, environment variables can now be specified on the command line or in a yaml file, and will be made available to all plugins via the switchboard. By @astro-friedel in PR #430</li> <li>Misc</li> <li>Breaking: Policies for contributing to the ILLIXR code base, as well as a general coding style guide have been introduced. The entire code base was overhauled to bring it into compliance with the style guide. By @astro-friedel in PR #419</li> <li>General documentation updates for ILLIXR. By @astro-friedel in PR #422</li> <li>Updated CMakeLists.txt to cleanly handle newer FindBoost capabilities, updated tags on some external packages, cleaned up CMake output, added some <code>include</code> lines required by newer gcc compiler versions, and added <code>all.yaml</code> profile for testing that the code fully builds. By @astro-friedel in PR #431</li> <li>Updated several external packages ILLIXR builds from source to newer versions. Official support for CentOS, Fedora, and Ubuntu 20 and below has been dropped, support for Ubuntu 24 has been added. By    @astro-friedel in PR #439</li> <li>Added automated release note generation by @astro-friedel in PR #441</li> <li>Major documentation updates, including up-to-date plugin listing and descriptions and more internal links to data types. By @astro-friedel in PR #447</li> <li>Issues   The following issues have been addressed and closed by this release:</li> <li>#151 Openwarp by PR #437</li> <li>#245 Automate changelog generation by PR #441</li> <li>#368 Integrate TCP implementation for offloading VIO by PR #437</li> <li>#371 Bringing Configurable Parameters to Current iteration of ILLIXR by PR #430</li> <li>#401 Reduce or remove the use of environment variables to pass information between main and plugins by PR #430</li> <li>#408 Dependency handling for plugin loader by PR #417</li> <li>#410 Re-running CMake with different profile file results in old profile file being used by PR #418</li> <li>#412 Enable Headless Rendering in Vulkan by PR #437</li> <li>#415 Generate Guidelines and Procedures by PR #419</li> <li>#427 Broken Fedora 38 (only?) build by PR #439</li> <li>#443 Add CMake to the dependencies by PR #422</li> <li>#89 Integrate ORB-SLAM3 by PR #407</li> <li>#96 Push mkdocs and doxygen on merge to master by PR #441</li> </ul>"},{"location":"CHANGELOG/#illixr-v320-sept-19-2023","title":"ILLIXR v3.2.0 (Sept 19, 2023)","text":""},{"location":"CHANGELOG/#release-notes","title":"Release Notes","text":"<ul> <li>The biggest change is the complete rewriting of the build system. It now runs via CMake, making plugin management and dependency checking much more streamlined.</li> <li>ILLIXR added a new graphics pipeline using the Vulkan API, implemented in the new plugins vkdemo, timewarp_vk, dislpay_vk, and nativer_renderer. For details, see PR #396 by @shg8.</li> <li>ILLIXR has updated integration to support Monado's out-of-process compositor, which now allows users to run more OpenXR apps (Unreal Engine, Vulkan-based apps, etc) with direct mode.</li> <li>There are numerous updates to plugins as well as a few new ones (see details below)</li> <li>OpenVINS is now the default SLAM plugin.</li> <li>Kimera-VIO is no longer available for use with ILLIXR</li> </ul>"},{"location":"CHANGELOG/#whats-changed","title":"What's Changed","text":"<ul> <li>The offload_vio plugins were updated to a TCP implementation with separate IMU and Camera types; and the H264 codec was added by @qinjunj in #409 and #363</li> <li>The timewarp_gl plugin was modified to render into two textures/framebuffers and a Vulkan-OpenGL interop was introduced by @Jebbly in #404</li> <li>A new openni plugin was written by @hungdche in #370</li> <li>A new fauxpose plugin was written by @wsherman64 in #389</li> <li>A shaking issue with the zed plugin was fixed by @qinjunj in #394</li> <li>The logging infrastructure was overhauled to use spdlog by @mvanmoer in #391</li> <li>The documentation was overhauled to make it more clear and descriptive as well as provide an interactive tool to select plugins and get their dependencies and customized build commands by @hungdche and @astro-friedel in #361 and #384</li> <li>The ILLIXR codebase was converted to a more modular build system (CMake) by @astro-friedel in #384</li> </ul>"},{"location":"CHANGELOG/#issues","title":"Issues","text":"<p>The following issues have been addressed and closed by this release</p> <ul> <li>#42   Evaluate Ninja/CMake/Bazel for plugin build system</li> <li>#44   Add human-readable logging infrastructure</li> <li>#50   Separate IMU/camera Switchboard topics</li> <li>#181  Fix plugin documentation</li> <li>#188  Separate out Qemu setup from main setup</li> <li>#205  Switch languages for the runner's config's schema</li> <li>#213  Preserve partial progress in our Makefile</li> <li>#231  Refactor configurations to reduce redundancy</li> <li>#313  Add libgtsam.so symlink in gtsam install script</li> <li>#358  Update Documentations</li> <li>#360  Memory leak in offline_imu_cam plugin</li> <li>#367  Installation issue on Ubuntu 22.04</li> <li>#398  Required GPU specifications</li> <li>#399  Reduce dependency on OpenCV</li> <li>#400  Header/include cleanup is needed</li> </ul> <p>Full Changelog: https://github.com/ILLIXR/ILLIXR/compare/v3.1.0...v3.2.0</p>"},{"location":"CHANGELOG/#illixr-v310-may-8-2022","title":"ILLIXR v3.1.0 (May 8 2022)","text":""},{"location":"CHANGELOG/#release-notes_1","title":"Release Notes","text":"<ul> <li>Added a new core runtime service called <code>RelativeClock</code> to standardize timestamping and duration calculation in the system</li> <li>Added a set of new plugins under <code>offload_vio/</code> that enable the offloading of VIO from the device to a remote server</li> <li>Added a new plugin <code>record_imu_cam</code> that enables data collection with a real camera for later offline use</li> <li>Bug fixes to <code>realsense</code></li> </ul>"},{"location":"CHANGELOG/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Add IMU and Cam Recorder by @hungdche in #327</li> <li>Add Offloading VIO Plugins to ILLIXR by @JeffreyZh4ng in #331</li> <li>Fix RealSense plugin by @mhuzai in #337</li> <li>Standardize time in ILLIXR by @charmoniumQ in #250</li> </ul> <p>Full Changelog: https://github.com/ILLIXR/ILLIXR/compare/v3.0.0...v3.1.0</p>"},{"location":"CHANGELOG/#illixr-v300-apr-8-2022","title":"ILLIXR v3.0.0 (Apr 8, 2022)","text":""},{"location":"CHANGELOG/#release-notes_2","title":"Release Notes","text":"<ul> <li>Bug fixes to install script, <code>pose_lookup</code>, and <code>dynamic_lib</code></li> <li>Documentation updates</li> <li>New documentation for using Switchboard standalone</li> </ul> <p>While this is technically a patch, we are bumping the version to 3.0.0 because Switchboard had an API change in v2.1.11 and we forgot to bump up the major version then.</p>"},{"location":"CHANGELOG/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Don't use sudo by @charmoniumQ in #322</li> <li>Revert boost install script by @mhuzai in #323</li> <li>Fix docs by @charmoniumQ in #319</li> <li>Fixed <code>pose_lookup</code> and <code>dynamic_lib</code> by @e3m3 in #304</li> <li>Added documentation for using Switchboard and Phonebook externally by @charmoniumQ in #320</li> <li>Fix and add documentation by @mhuzai in #330</li> </ul> <p>Full Changelog: https://github.com/ILLIXR/ILLIXR/compare/v2.1.11...v3.0.0</p> <p>ILLIXR v2.1.11 (Dec 27, 2021)</p>"},{"location":"CHANGELOG/#updated-plugins","title":"Updated plugins","text":"<ul> <li>realsense:</li> <li>Expanded supported cameras to include D4XX and T26X.</li> <li>qemu:</li> <li>Updated script to pull and run Ubuntu 18.04.6.</li> <li>timewarp_gl:</li> <li>Fixed memory leak by moving the destructor to \u2018xlib_gl_extended_window\u2019.</li> <li>Added option to disable timewarping without disabling the plugin.</li> <li>Suppressed per frame prints.</li> <li>ground_truth_slam:</li> <li>Promoted instance-member to local variable.</li> <li>gtsam_integrator:</li> <li>Fixed to dump all sqlite files once ILLIXR shuts down.</li> <li>gldemo:</li> <li>Suppressed per frame prints.</li> </ul>"},{"location":"CHANGELOG/#new-plugins","title":"New plugins","text":"<ul> <li>depthai:</li> <li>Added support for DepthAI and OAK-D cameras.</li> <li>offload_data:</li> <li>Added support to synchronously collect rendered images and poses on-the-fly.</li> </ul>"},{"location":"CHANGELOG/#build-and-ci-infrastructure","title":"Build and CI infrastructure","text":"<ul> <li>Updated dependency install scripts</li> <li>Fixed gtsam,and opengv install script.</li> <li>Enabled libboost in deps.sh.</li> <li>Updated dependencies for Ubuntu 21.</li> <li>Updated build and dependency installation script with DepthAI.</li> <li>Canonicalized install script structure (fetch -&gt; build -&gt; install).</li> <li>Added Eigen install script.</li> <li>Added package dependencies install support for IntelRealSense for Ubuntu 18 LTS.</li> <li>Fixed libgtsam symlink.</li> <li>Fixed ZED compilation.</li> <li>Fixed compilation with OpenVINS.</li> <li>Migrated to tag-based checkouts for out-of-repo plugins.</li> <li>Other minor modifications.</li> </ul>"},{"location":"CHANGELOG/#documentation-and-guidelines","title":"Documentation and guidelines","text":"<ul> <li>README.md</li> <li>Fixed internal links.</li> <li>Other minor modifications.</li> <li>Documentation</li> <li>Fixed a number of outdated information, broken links,typos, and unclear descriptions.</li> <li>Fixed documentation figures and topic descriptions.</li> <li>Fixed description of OpenXR Spaces for Monado Integration.</li> <li>Updated contributing guidelines with step-by-step instructions.</li> <li>Updated instructions on writing customized plugins.</li> <li>Added explicit definitions for adding cmd and environment variables.</li> <li>Removed unused code and documentation.</li> <li>License</li> <li>Addressed missing licence information for GTSAM, Kimera-VIO and moodycamel::ConqurrentQueue.</li> </ul>"},{"location":"CHANGELOG/#improved-runtime","title":"Improved runtime","text":"<ul> <li>Added  errno checking.</li> <li>Added verbose errors flag.</li> <li>Added additional debugging info/support.</li> <li>Added a lock-based queue for the debugging process.</li> <li>Added KIMERA_ROOT to default monado config.</li> <li>Added git tags for mondao_integration launch configuration.</li> <li>Added stoplight to synchronize thread starts/stops.</li> <li>Added explicit definitions for adding cmd and environment variables.</li> <li>Enabled non-ILLIXR specific files to be potentially reused.</li> <li>Cleared errno in XOpenDisplay.</li> <li>Updated ILLIXR runtime for new Monado integration.</li> <li>Changed Switchboard to use ref-counting to patch memory leak.</li> <li>Changed the tqdm bar to show units (bytes/kbytes/\u2026).</li> <li>Fixed \u2018clean\u2019 configuration (clean.yaml).</li> <li>Fixed \u2018headless\u2019 configuration command argument.</li> <li>Fixed the issue that running ILLIXR on dbg mode cannot exit cleanly.</li> <li>Fixed GL performance warning to be no longer fatal.</li> <li>Inlined global helper function.</li> </ul> <p>ILLIXR v2.1.10 (Mar 16, 2021)</p> <ul> <li>Updated plugins</li> <li>New: <code>pose_prediction</code>, <code>pose_lookup</code>, <code>kimera-vio</code>, <code>realsense</code>, <code>gtsam_integrator</code>, audio decoding</li> <li>Removed (Git) submodules</li> <li>Fixed ground truth for plugins</li> <li>Fixed OpenVins Motion-to-Photon</li> <li>New global camera shutter</li> <li>New object and interpupilary distance (IPD) rendering</li> <li>Improved hologram performance</li> <li>Using Euroc dataset</li> <li>New build and CI infrastructure</li> <li>Fixed GTSAM build</li> <li>Fixed Kimera-VIO build</li> <li>New parallel building for Runner</li> <li>New source (Git) and dataset fetching for Runner</li> <li>New headless support (<code>xvfb</code>)</li> <li>New virtualization support (<code>qemu</code>)</li> <li>New CI workflows for master branch and pull requests</li> <li>Updated dependency installations for Docker</li> <li>Updated configurations (e.g., <code>native-lookup</code>, <code>ci</code>)</li> <li>Fixed Monado integration</li> <li>New instrumented OpenCV</li> <li>New documentation and guidelines</li> <li>New plugins documentation</li> <li>New Runner documentation</li> <li>New contributing guidelines</li> <li>Improved runtime</li> <li>New Switchboard API</li> <li>Updated synchronization for readers and writers</li> <li>New threaded plugins</li> <li>New timing instrumentation</li> <li>New logging infrastructure (SQLite support)</li> </ul> <p>ILLIXR v2.1.0 (Sept. 4, 2020)</p> <ul> <li>Added support for ZED Mini</li> <li>Improved build system</li> <li>Streamlined Monado integration</li> <li>Added logging interface (implementation pending)</li> <li>Improved core runtime (switchboard, phonebook, and sleeping mechanism)</li> <li>Updated documentation</li> </ul> <p>ILLIXR v2.0.1 (May 19, 2020)</p> <p>Tweaked documentation.</p> <p>ILLIXR v2.0.0</p> <ul> <li>Added runtime framework (spindle, switchboard, phonebook, logger)</li> <li>Added OpenXR support</li> <li>Integrated components into runtime framework</li> <li>Enabled end-to-end system</li> <li>Added docs</li> </ul> <p>ILLIXR v1.2.0</p> <ul> <li>Added eye tracking</li> <li>Improved audio pipeline build process</li> <li>Removed legacy code from hologram</li> <li>Updated README.md</li> <li>Updated CONTRIBUTORS</li> </ul> <p>ILLIXR v1.0.0</p> <p>v1 of ILLIXR contains only standalone components. See the v2 release for the runtime and component integration.</p> <p>Initial release of ILLIXR with SLAM, scene reconstruction, audio recording and playback, lens distortion correction, chromatic aberration correction, timewarp, and computational holography.</p>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright (c) 2019 The Board of Trustees of the University of Illinois.  All rights reserved.</p> <p>Developed by: Professor Sarita Adve's research group               University of Illinois at Urbana-Champaign               http://rsim.cs.illinois.edu</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: * Redistributions of source code must retain the above copyright notice,   this list of conditions and the following disclaimers. * Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimers in the documentation   and/or other materials provided with the distribution. * Neither the names of Professor Sarita Adve's research group, University of   Illinois at Urbana-Champaign, nor the names of its contributors may be used   to endorse or promote products derived from this Software without specific   prior written permission.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.</p>"},{"location":"adding_mediapipe/","title":"Adding mediapipe","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/adding_mediapipe</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"dataflow/","title":"Dataflow","text":"<p> Current dataflow between all plugins and services. Dark blue boxes represent plugins and cyan  component boxes represent services. Data types are represented with cylinders and labelled as <code>topic &lt;data_type&gt;</code>. Service data types are represented by octagons. Solid lines point from the plugin/service which publishes them to the data type. Dashed lines point from data types to the plugin/service which reads them synchronously. Dotted lines point from data types to the plugin/service which reads them asynchronously.</p>"},{"location":"debugging_illixr/","title":"Debugging illixr","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/debugging_illixr</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"display_backend/","title":"Display backend","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/display_backend</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"external_switchboard_and_phonebook/","title":"External switchboard and phonebook","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/external_switchboard_and_phonebook</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>The ILLIXR application is configured and built via CMake. The CMake system checks for required dependencies, builds each requested plugin, builds the main ILLIXR binary, and (optionally) installs these components.</p> <p>ILLIXR currently only builds on Linux systems, and has been tested on the following configurations:</p> <ul> <li>Ubuntu<ul> <li>22.04</li> <li>24.04</li> </ul> </li> <li>Fedora<sup>1</sup><ul> <li>38+</li> </ul> </li> </ul> <p>Other versions of these operating systems may work, but will likely require some manual installation of dependencies. For other Linux distributions (e.g. RHEL) it will require significant manual installation of dependencies as many are not available in the distribution repos. The instructions below are a generalized version.</p>"},{"location":"getting_started/#building-illixr","title":"Building ILLIXR","text":""},{"location":"getting_started/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/ILLIXR/ILLIXR --single-branch\n</code></pre> <p>This will clone only the default branch, if you want all branches then remove the <code>--single-branch</code> flag.</p>"},{"location":"getting_started/#install-dependencies","title":"Install dependencies","text":"<p>There are two levels of dependencies in ILLIXR: those that are required for any type of build, and those that are required only for specific plugins.</p>"},{"location":"getting_started/#select-your-operating-system-and-version","title":"Select your operating system and version","text":"<p>ILLIXR may compile with other versions of the above operating systems, but some of the necessary prerequisite packages are not supplied by the OS repos and will need to be compiled by hand. You should be able to use the package and cmake commands for other versions of the same OS (other than the missing packages) to compile ILLIXR. RHEL is not supported at this time as many of the prerequisite packages are not natively available. You will also need to have a C++ compiler installed (gcc, clang, etc.) as well as a generator (make, ninja, etc.) and CMake 3.22 or newer (installation is os dependent).</p>"},{"location":"getting_started/#pick-the-illixr-plugins-you-want-to-use","title":"Pick the ILLIXR plugins you want to use","text":"Include virtualization support: See ILLIXR Under Virtualization for details. <p>Use the following to install the dependencies for the selected plugins:</p> <p></p>"},{"location":"getting_started/#build-command","title":"Build command","text":"<p>Use the following to build and install ILLIXR. You can specify the install location by giving the path to <code>CMAKE_INSTALL_PREFIX</code>. If you want the default install path then do not add the option to the command line.</p> <p>Warning</p> <p>If your install prefix requires sudo privileges then you will need to run both the build and install under sudo (this is due to the way cmake builds and installs some of the pre-packaged dependencies during the build phase).</p> <p>Some ILLIXR plugins rely on code that falls under the GNU General Public License (GPL) v3.0 or GNU Lesser General Public License (LGPL) v2.1. If you do not wish to build these codes you can select to exclude them below (or add <code>-DNO_GPL=ON</code> or <code>-DNO_LGPL=ON</code> to your cmake command line, NO_LGPL=ON implies the same for NO_GPL).</p> <p>No GPL code No LGPL code</p> <p>Common CMake command line arguments (always prepend with a <code>-D</code>):</p> <ul> <li>CMAKE_INSTALL_PREFIX    The root path to install the libraries and binary to. This defaults to <code>/usr/local</code>.</li> <li>CMAKE_BUILD_TYPE    The build type to do: Debug, Release, RelWithDebInfo</li> <li>YAML_FILE    The profile file of plugins to build and install. The default is None, meaning plugins should be specified individually on the command line.</li> <li>USE_&lt;PLUGIN_NAME&gt;=ON    Build the specifically named plugin (e.g <code>-DUSE_TIMEWARP_VK=ON</code> to build the timewarp_vk plugin). Any number of plugins can be specified on the command line in this fashion.</li> <li>BUILD_DOCS    Set to <code>ON</code> to enable building the documentation.</li> </ul> <p>Documentation Prerequisites</p> <p>Building the documentation requires Doxygen and mkdocs(&gt;= v1.5) to be installed, both of which are typically available from OS packages. Additionally, we utilize the material, mkdocs-material-extensions, mkdocs-get-deps, mkdocs-include-markdown-plugin, PyMdown, Pygments, mkdoxy, and mkdocs-glightbox python packages, which can be installed via pip using <code>docs/requirements.txt</code>.</p> <p>An alternate to specifying the plugins as command line arguments is to create a YAML file which specifies the plugins to build. Using <code>-DYAML_FILE=&amp;lt;FILE_NAME&amp;gt;</code> as the command line argument specifying the YAML file to use.</p> <p>You may need to specify the full path to the YAML_FILE</p> <p>See profile for the format.</p> <p>The current list of plugins is: </p> <ul> <li>audio_pipeline</li> <li>debugview</li> <li>depthai</li> <li>fauxpose</li> <li>gldemo</li> <li>ground_truth_slam</li> <li>gtsam_integrator</li> <li>hand_tracking</li> <li>hand_tracking.viewer</li> <li>hand_tracking_gpu</li> <li>lighthouse</li> <li>native_renderer</li> <li>offline_cam</li> <li>offline_imu</li> <li>offload_data</li> <li>offload_rendering_client</li> <li>offload_rendering_server</li> <li>offload_vio.device_rx</li> <li>offload_vio.device_tx</li> <li>offload_vio.server_rx</li> <li>offload_vio.server_tx</li> <li>openni</li> <li>openvins</li> <li>openwarp_vk</li> <li>openwarp_vk.monado</li> <li>orb_slam3</li> <li>passthrough_integrator</li> <li>pose_lookup</li> <li>pose_prediction</li> <li>realsense</li> <li>record_imu_cam</li> <li>record_rgb_depth</li> <li>rk4_integrator</li> <li>tcp_network_backend</li> <li>timewarp_gl</li> <li>timewarp_gl.monado</li> <li>timewarp_vk</li> <li>timewarp_vk.monado</li> <li>vkdemo</li> <li>webcam</li> <li>zed</li> <li>zed.data_injection</li> </ul> <p>The CMake process will also create a YAML file call <code>illixr.yaml</code> which can be used as input to the binary.</p>"},{"location":"getting_started/#running-illixr","title":"Running ILLIXR","text":"<p>To run the ILLIXR binary just call <code>main.&lt;&gt;.exe</code> with any of the following command line arguments. (the <code>&lt;&gt;</code> indicate an infix specifying the build type, for <code>Debug</code> use <code>dbg</code>, for <code>Release</code> use <code>opt</code>, for <code>RelWithDebInfo</code> use <code>optdbg</code>)</p> <ul> <li>-p,--plugins=&lt;&gt;, comma separated list of plugins to use (case sensitive, all lowercase, no spaces)</li> <li>-y,--yaml=&lt;&gt;, the profile file to use which specifies some or all of the above arguments (e.g. the generated <code>illixr.yaml</code>)</li> <li>--, you can specify any variable the ILLIXR uses on the command line. Common ones are: <li>--duration=&lt;&gt;, the duration to run for in seconds (default is 60)</li> <li>--data=&lt;&gt;, the data file to use</li> <li>--demo_data=&lt;&gt;, the demo data to use</li> <li>--enable_offload</li> <li>--enable_alignment</li> <li>--enable_verbose_errors, give more information about errors</li> <li>--enable_pre_sleep, force ILLIXR to sleep for the given number of seconds before starting the plugins (this is useful for attaching a debugger)</li> <p>Regarding parameters for the binary, the following priority will be used: 1. If the parameter is specified on the command line it will have the highest priority 2. If the parameter has a value in the yaml file this value will only be used if it is not specified on the command line (second priority) 3. If the parameter has a value as an environment variable this value will only be used if it is not specified on the command line nor yaml file</p> <p>Please refer to the display backend for instructions on setting display-related environment variables.</p> <p>For specific usage instructions, refer to the README files of the respective plugins.</p>"},{"location":"getting_started/#profile-file-format","title":"Profile file format","text":"<p>An example of a YAML profile file is <pre><code>plugins: pose_lookup,timewarp_vk,vkdemo,native_renderer\nbuild_type: Debug\ninstall_prefix: /home/user/illixr\nenv_vars:\n  ILLIXR_RUN_DURATION: 5\n  DATA: data/mav0\n  DEMO_DATA: demo_data\n  ENABLE_OFFLOAD: false\n  ENABLE_ALIGNMENT: false\n  ENABLE_VERBOSE_ERRORS: false\n  ENABLE_PRE_SLEEP: false\n</code></pre></p> <p>Where the entries are defined as (* indicates required field):</p> <ul> <li> <p>plugins * : Comma separated list of plugins (case-sensitive) to build or load at runtime.</p> </li> <li> <p>build_type : The type of build to perform (Debug, Release, or RelWithDebInfo). Ignored at run time.</p> </li> <li> <p>install_prefix : The root path to where the compiled libraries and binaries should be installed. (e.g. specifying /home/user will install libraries in /home/user/lib and binaries in /home/user/bin).</p> </li> </ul> <p>!!! note</p> <pre><code>  The prefix is also used for installing any packages that were downloaded and build from external repositories (e.g. DBoW2, GTSAM, etc). At runtime this path is added to *LD_LIBRARY_PATH* to aid in finding the plugin libraries.\n</code></pre> <ul> <li>env_vars : environment variables to use, any environment variable ILLIXR uses can be set here and will be valid during program execution.</li> </ul> <p>In general, you should not edit a profile file directly. The exception to this is when you are testing things on your own machine. Profile files are generated automatically from the master <code>profiles/plugins.yaml</code> during the cmake configuration stage. This is done so that any changes to a profile or the addition or removal of a plugin can be managed from a single file. The build system will generate an illixr.yaml file which contains entries from the command line and any input profile file and can be freely edited (it is generated every time <code>cmake</code> is called).</p>"},{"location":"getting_started/#environment-variables","title":"Environment Variables","text":"<p>ILLIXR and several of its dependencies use environment variables to steer processing and define quasi-constant values. Traditionally, one would use std::getenv and std::setenv to get and set these items. However, in ILLIXR the switchboard acts as an interface to these functions with <code>get_env</code> (returns std::string), <code>get_env_bool</code> (returns bool), <code>get_env_char</code> (returns char*), and <code>set_env</code>. Using the switchboard interfaces allows for environment variables to be set from the command line and/or yaml file. It is strongly encouraged to the switchboard interface wherever possible. Any items given on the command line which do not match expected command line arguments are considered to be environment variables. For example:</p> <pre><code>main.dbg.exe --yaml=my.yaml --DATA_SOURCE=/home/my/data --PROCESS_DATA\n</code></pre> <p>This will set env environment variables <code>DATA_SOURCE</code> to <code>/home/my/data</code> and <code>PROCESS_DATA</code> to <code>True</code>. For yaml files, any items not in the expected set will be considered to be environment variables. For example:</p> <pre><code>plugins: fauxpose,timewarp_vk,vkdemo,debugview,audio_pipeline\nenable_offload: false\nenv_vars:\n  DATA_SOURCE: /home/my/data\n  PROCESS_DATA: true\n</code></pre> <p>Here, the keywords <code>plugins</code> and <code>enable_offload</code> are ignored, as they are expected options. The <code>DATA_SOURCE</code> and <code>PROCESS_DATA</code> entries will cause environment variables to be set to the respective values.</p> <p>Note</p> <p>The names and values of the environment variables are case-sensitive.</p> <p>Note</p> <p>The <code>get_env_bool</code> considers any of 'y', 'yes', 'true', 'on' (case-insensitive), and \"1\" to be <code>true</code>.</p>"},{"location":"getting_started/#common-environment-variables","title":"Common Environment Variables","text":"<ul> <li> <p>illixr_run_duration : The duration to run ILLIXR for in seconds.</p> </li> <li> <p>data : Path to the data file to download (build step) or use at runtime. If a URL is given (must start with http or https) the file will be downloaded and extracted; the path to the extracted data will be put in the illixr.yaml file.</p> </li> <li> <p>demo_data : The path to the demonstration data to use at runtime (ignored by build steps)</p> </li> <li> <p>enable_offload : ? Default is false</p> </li> <li> <p>enable_alignment : ? Default is false</p> </li> <li> <p>enable_verbose_errors : Controls the verbosity of error messages. Default is false</p> </li> <li> <p>enable_pre_sleep : Force ILLIXR to sleep for the given number of seconds before starting the plugins (this is useful for attaching a debugger), Default is 0, indicating no sleeping.</p> </li> </ul> <p>Each plugin can define environment variables to use. See the documentation of each plugin for details.</p>"},{"location":"getting_started/#illixr-graphics-backends","title":"ILLIXR Graphics Backends","text":"<p>ILLIXR currently supports both OpenGL and Vulkan backends (indicated as <code>gl</code> and <code>vk</code> in the config suffixes). Since some plugins should behave differently (and compile differently) based on what backend is being used, it's important to run <code>make clean</code> if you want to try swapping between the two backends.</p> <p>Warning</p> <p>The use of the OpenGL back end is in the process of being deprecated. Thus <code>gl</code> based plugins are not guaranteed to work in every instance.</p>"},{"location":"getting_started/#rationale","title":"Rationale","text":"<ul> <li>The current system can use profile files to control everything from the build to running ILLIXR, in keeping with the DRY principle.    However, for maximum flexibility control can also be done at the command line level as well.</li> </ul>"},{"location":"getting_started/#philosophy","title":"Philosophy","text":"<ul> <li> <p>Each plugin should not have to know or care how the others are compiled.     In the future, they may even be distributed separately, just as SOs.     Therefore, each plugin needs its own build system.</p> </li> <li> <p>Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins     should be extremely easy.</p> </li> <li> <p>It should be easy to build in parallel.</p> </li> <li> <p>Re-running <code>make</code> (and optionally <code>cmake</code> first) will only rebuild those parts of the code with have changed.</p> </li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Try browsing the source for the runtime and provided plugins. The source code is divided into components in the following directories:</p> <ul> <li> <p><code>ILLIXR/src/</code>:     A directory holding the implementation for loading and interfacing plugins.     This directory contains Spindle.</p> </li> <li> <p><code>ILLIXR/include/illixr/</code>:     A directory holding resources and utilities available globally to all plugins.     This directory contains the interfaces for Switchboard and Phonebook.</p> </li> <li> <p><code>ILLIXR/plugins/&lt;plugin_dir&gt;/</code>:     A unique directory for each plugin.     Most of the core XR functionality is implemented via plugins.     See Default Components for more details.</p> </li> </ul> <p>If you edit any of the source files, the CMake system will detect and rebuild the respective binary the next time it runs. If you want to add your own plugin, see Writing Your Plugin.</p> <ol> <li> <p>Primary development is aimed at Ubuntu systems, full support for Fedora may require extra work on the users part.\u00a0\u21a9</p> </li> </ol>"},{"location":"glossary/","title":"Glossary of ILLIXR Terminology","text":"<p>A collection of ILLIXR and ILLIXR-adjacent terms and their definitions can be found on this page your reference.</p>"},{"location":"glossary/#general","title":"General","text":""},{"location":"glossary/#asynchronous-reprojection","title":"Asynchronous Reprojection","text":"<p>The processing of rendered video for motion interpolation. Asynchronous reprojection improves the perception of the rendered video to the HMD when rendering misses it target frame rate.</p> <p>Asynchronous reprojection is implemented in the <code>timewarpgl</code>.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#chromatic-aberration-correction","title":"Chromatic Aberration Correction","text":"<p>The processing of visual anomalies in images where colors are diffracted due to imperfect optics or other perturbing factors.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#compositor","title":"Compositor","text":"<p>A window manager that establishes a framebuffer for each window of a graphical system. A compositor merges information across its windows to construct a unified framebuffer.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#distortion-correction","title":"Distortion Correction","text":"<p>The processing of visual anomalies in images where rectilinear features have been warped.</p> <p>For more information, see the Wikipedia artice.</p>"},{"location":"glossary/#eye-tracking","title":"Eye Tracking","text":"<p>The process of measuring the eye movement of a user (who is possibly also wearing an HMD).</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#event-stream","title":"Event Stream","text":"<p>A communication interface supporting writes, synchronous reads, and asynchronous reads. For synchronous reads, every value written to the stream is visible to consumers. For asynchronous reads, only the latest values written are guaranteed to be visible to consumers.</p>"},{"location":"glossary/#framebuffer","title":"Framebuffer","text":"<p>A region of memory used to hold graphical information to be output to a display or graphics device.</p> <ul> <li> <p>Depth Buffer:   A framebuffer representing the depth information of a 3D scene.   Depth information is useful for applications such as graphics and SLAM.</p> </li> <li> <p>Eye Buffer:   A framebuffer dedicated for display through an HMD lens to be perceived by a user's eye.</p> </li> <li> <p>Frame:   A single frame (image) to be output to a display at a certain instant of time based on the   system's frame rate.</p> </li> <li> <p>Frame Rate:   The interval period between complete (as defined by the output resolution) frame updates   and refreshes.   In many systems, the target frame rate is determined by a fixed vertical sync (VSYNC) period.</p> </li> </ul> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#ground-truth","title":"Ground Truth","text":"<p>The most accurate source of measurement available for a data set. Typically, ground truth measurements are provided for the evaluation of sensor data where the sensor or other data source is not as accurate or reliable as the source for the ground truth.</p> <ul> <li> <p>Ground Truth Poses:   A collection of poses used to evaluate the accuracy of pose generation and prediction algorithms.</p> </li> <li> <p>Ground Truth Images:   A collection of images used to evaluate the accuracy of visual processing algorithms,   like SLAM and VIO.</p> </li> </ul> <p>See the ILLIXR Plugins page for information about sensors implemented in ILLIXR.</p>"},{"location":"glossary/#head-mounted-display","title":"Head-mounted Display","text":"<p>A display device worn on the head and face for use with VR and XR applications. Also known as an HMD.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#inertial-measurement-unit","title":"Inertial Measurement Unit","text":"<p>A device that reports its orientation in space and any forces applied it. Also known as an IMU.</p> <p>An IMU is implemented in the <code>offline_imu</code>.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#plugin","title":"Plugin","text":"<p>A modular component that can be detected and enabled for use by an ILLIXR application. A plugin can be internal or external to the ILLIXR project. Each plugin is compiled and launched dynamically at runtime based on the command line options given or ILLIXR profile file being used. ILLIXR also implements a Monado runtime translation Plugin.</p> <p>For a list of supported plugins and their details, see the ILLIXR Plugins page. For instructions for how to modify or write your own plugins, see the Modifying a Plugin and Writing Your Plugin pages.</p> <p>See the Plugin API documentation.</p>"},{"location":"glossary/#profile","title":"Profile","text":"<p>A profile describes the environment to be used for the build system and running ILLIXR. Profiles are defined in YAML files. There are several provided in the <code>profiles</code> directory in the repository. A profile file defines what plugins are to be used, as well as additional information specific to where it is being used.</p> <ul> <li>As input to CMake:   If a profile file is given to cmake via the <code>-DYAML_FILE=</code> directive then the listed plugins will be built.</li> <li>As input to the ILLIXR binary   If a profile file is given on the ILLIXR binary via the <code>--yaml=</code> command line option, then any   listed plugins   will be loaded and any other command line options given in the profile file will be used. See Running ILLIXR   for details.</li> </ul> <p>The same profile file can be given to both cmake and the ILLIXR binary (you may need to change the <code>data:</code> entry), as any unrecognized options are ignored by both systems. See Profile file format for details on the profile file format.</p>"},{"location":"glossary/#pose","title":"Pose","text":"<p>The combination of orientation and position of an object, used for computer vision and robotics applications. ILLIXR applications make use of poses to track the user's HMD within the virtual environment. Internally, ILLIXR has multiple classifications of poses which are used for various purposes.</p> <ul> <li> <p>Slow Pose:   A slow pose is a visual-inertial based pose estimate at low frequency (e.g. 30 Hz). It can be from OpenVINS or ORB_SLAM3.</p> </li> <li> <p>Fast Pose:   A fast pose is a pose estimate from IMU integration at high frequency (e.g. hundreds of Hz), but with limited accuracy.</p> </li> <li> <p>True Pose:   A true pose is a ground truth pose, usually from datasets.</p> </li> <li> <p>Pose Prediction:   To improve the user's perceived latency, pose prediction leverages historical and current system information such as poses and sensor inputs to pre-compute the user's future pose.   This pre-computation enables downstream components to begin processing earlier, reducing end-to-end latency.</p> </li> </ul> <p>Pose Prediction is implemented in <code>pose_prediction</code>.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#runtime","title":"Runtime","text":"<p>The ILLIXR system runtime is responsible for the dynamic orchestration of ILLIXR device resources, system resources, and client applications.</p> <p>The runtime implementation is located in <code>&lt;ILLIXR_INSTALL_DIR&gt;/bin</code>. See the Getting Started and Monado Overview pages for details about the ILLIXR runtime.</p>"},{"location":"glossary/#service","title":"Service","text":"<p>These are modular components that are initialized like a plugin, but provide callable functions. Services are not directly triggered by ILLIXR's main loop, or by publication to a topic.</p>"},{"location":"glossary/#simultaneous-localization-and-mapping","title":"Simultaneous Localization and Mapping","text":"<p>The computational process of creating a map of an unknown environment, and finding one's location within that space. Also known as SLAM.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#swap-chain","title":"Swap Chain","text":"<p>A set of virtual framebuffers to be output to a display. Only one framebuffer in a swap chain is displayed at a time, enabling the other virtual framebuffers to be concurrently modified in memory.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#visual-inertial-odometry","title":"Visual Inertial Odometry","text":"<p>The process of computing a pose estimate from incoming visual information and measurements from the IMU. Also known as VIO. Often used in combination with SLAM techniques.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#components","title":"Components","text":""},{"location":"glossary/#phonebook","title":"Phonebook","text":"<p>An ILLIXR service directory used to introspectively interface plugins and their data. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Phonebook API documentation.</p>"},{"location":"glossary/#spindle","title":"Spindle","text":"<p>An ILLIXR component responsible for launching and managing plugin threads. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Spindle API documentation.</p>"},{"location":"glossary/#switchboard","title":"Switchboard","text":"<p>An ILLIXR event stream manager that maintains data pipelines between plugins. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Switchboard API documentation.</p>"},{"location":"glossary/#technologies","title":"Technologies","text":""},{"location":"glossary/#docker","title":"Docker","text":"<p>A platform and containerization framework for deploying applications under virtualization. ILLIXR uses Docker to deploy and test code in a continuous integration and deployment pipeline.</p> <p>For more information, see the Docker overview and getting started page.</p>"},{"location":"glossary/#godot","title":"Godot","text":"<p>An open source game development engine. ILLIXR applications targeting the OpenXR use Godot to access the engine's integration with the OpenXR standard via Monado.</p> <p>For more information, visit the official Godot site.</p>"},{"location":"glossary/#monado","title":"Monado","text":"<p>An open source, modular implementation of the OpenXR standard for GNU/Linux.</p> <p>See the ILLIXR Monado Overview and Monado Dataflow pages for details about our runtime integration using Monado.</p> <p>For more information, visit the official Monado development site.</p>"},{"location":"glossary/#opencv","title":"OpenCV","text":"<p>An open source computer vision library. Many of ILLIXR's components utilize these powerful algorithms and the cv::Mat class serves as the basis format for images inside ILLIXR.</p> <p>For more information, visit the official OpenCV site.</p>"},{"location":"glossary/#opengl","title":"OpenGL","text":"<p>A cross-platform graphics API that allows developers to create portable graphics applications easily. Also known as GL.</p> <ul> <li> <p>GL Context:   A data structure storing the state of an OpenGL application instance.   Within a GL context resides framebuffer data.   It is not thread safe to share contexts without appropriate synchronization.</p> </li> <li> <p>GLFW:   An open source implementation of OpenGL.   Supports Windows, macOS and, Linux (X11 and Wayland).   See the GLFW development site.</p> </li> </ul> <p>For more information, see the official OpenGL page from the Khronos Group.</p>"},{"location":"glossary/#openxr","title":"OpenXR","text":"<p>An open standard for Augmented and Virtual Reality. ILLIXR components target the OpenXR standard and interact with the ILLIXR device via the Application Interface.</p> <p>For more information, visit the official site from the Khronos Group.</p>"},{"location":"glossary/#qemu-kvm","title":"QEMU-KVM","text":"<p>An open source virtualization tool and machine emulator. See the instructions for running ILLIXR under Virtualization.</p> <p>For more information, see the official QEMU page.</p>"},{"location":"glossary/#sqlite","title":"SQLite","text":"<p>A SQL database engine implementation in C designed to be lightweight and easy to use. The ILLIXR project allows user to record application statistics to a local database for efficient processing. See the Logging and Metrics page for usage details.</p> <p>For more information, see the SQLite development site.</p>"},{"location":"glossary/#ubuntu","title":"Ubuntu","text":"<p>An open source GNU/Linux operating system and distribution. ILLIXR currently supports the Long Term Support (LTS) versions of Ubuntu: 20.04 LTS (Focal) and 11.04 (Jammy)</p> <p>For more information, visit the official Ubuntu site.</p>"},{"location":"glossary/#vulkan","title":"Vulkan","text":"<p>A cross-platform graphics API that allows developers to efficiently target low-level hardware features.</p> <p>For more information, see the official Vulkan page from the Khronos Group.</p>"},{"location":"glossary/#xvfb","title":"Xvfb","text":"<p>A virtual framebuffer for the X11 Window System. ILLIXR uses Xvfb to enable running the graphical ILLIXR application without requiring the user to have a graphical environment configured at application launch.</p> <p>For more information, see the Xfvb man page.</p>"},{"location":"glossary/#yaml","title":"YAML","text":"<p>A markup language and data serialization standard designed to be user-friendly. We make use of the yaml-cpp libraries to read our profile files.</p> <p>For more information, visit the official YAML page.</p>"},{"location":"illixr_plugins/","title":"ILLIXR plugins","text":"<p>This page details the structure of ILLIXR's plugins and how they interact with each other.</p>"},{"location":"illixr_plugins/#audio_pipeline","title":"audio_pipeline","text":"<p>Launches a thread for binaural: recording and one for binaural playback. Audio output is not yet routed to the system's speakers or microphone, but the plugin's compute workload is still representative of a real system. By default, this plugin is enabled (see <code>native</code> configuration).</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#debugview","title":"debugview","text":"<p>Renders incoming frames from the graphics pipeline for debugging live executions of the application.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Asynchronously reads <code>fast_pose_type</code> from <code>imu_raw</code> topic. (IMU biases are unused).</li> <li>Asynchronously reads <code>pose_type</code> from <code>slow_pose</code> topic.</li> <li>Asynchronously reads <code>rgb_depth_type</code> from <code>rgb_depth</code> topic.</li> <li>Asynchronously reads buffered <code>binocular_cam_type</code> from <code>cam</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#depthai","title":"depthai","text":"<p>Enables access to the DepthAI library.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic`</li> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#gldemo","title":"gldemo <sup>1</sup>","text":"<p>Renders a static scene (into left and right eye buffers) given the pose from <code>pose_prediction</code>.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Publishes <code>rendered_frame</code> to <code>eyebuffer</code> topic.</li> <li>Publishes <code>image_handle</code> to <code>image_handle</code> topic.</li> <li>Asynchronously reads <code>time_point</code> from <code>vsync_estimate</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#ground_truth_slam","title":"ground_truth_slam","text":"<p>Reads the ground truth from the same dataset as the <code>offline_imu</code> plugin. Ground truth data can be compared against the head tracking results (e.g. from VIO, IMU integrator, or pose predictor) for accuracy. Timing information is taken from the <code>offline_imu</code> measurements/data.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> to <code>true_pose</code> topic.</li> <li>Publishes <code>Eigen::Vector3f</code> to <code>ground_truth_offset</code> topic.</li> <li>Asynchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#gtsam_integrator","title":"gtsam_integrator","text":"<p>Integrates over all IMU samples since the last published visual-inertial pose to provide a fast pose every time a new IMU sample arrives using the GTSAM library (upstream).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_raw_type</code> to <code>imu_raw</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> <li>Asynchronously reads <code>imu_integrator_input</code> to <code>imu_integrator_input</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#hand_tracking","title":"hand_tracking","text":"<p>Detects and identifies hands in an image, CPU based calculations. The output from this plugin can be used to track hand movements and recognize hand gestures.</p> <p>Topic details:</p> <ul> <li>Synchronously reads one of <code>monocular_cam_type</code> from <code>webcam</code> topic, <code>binocular_cam_type</code> from <code>cam</code> topic, or <code>cam_type_zed</code> from <code>cam_zed</code> topic. This is selectable at run time via an environment variable.</li> <li>Asynchronously reads <code>camera_data</code> from <code>cam_data</code> topic, only once as values are static</li> <li>If reading from <code>webcam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, depending on which is available</li> </ul> </li> <li>If reading from <code>cam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, if either is available, but not required</li> </ul> </li> <li>If reading from <code>cam_zed</code>, no additional data are required.</li> <li>Publishes <code>ht_frame</code> to <code>ht</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#hand_tracking_gpu","title":"hand_tracking_gpu","text":"<p>Detects and identifies hands in an image, GPU based calculations. The output from this plugin can be used to track hand movements and recognize hand gestures. This plugin is currently experimental.</p> <p>Topic details:</p> <ul> <li>Synchronously reads one of <code>monocular_cam_type</code> from <code>webcam</code> topic, <code>binocular_cam_type</code> from <code>cam</code> topic, or <code>cam_type_zed</code> from <code>cam_zed</code> topic. This is selectable at run time via an environment variable.</li> <li>Asynchronously reads <code>camera_data</code> from <code>cam_data</code> topic, only once as values are static</li> <li>If reading from <code>webcam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, depending on which is available</li> </ul> </li> <li>If reading from <code>cam</code><ul> <li>Asynchronously reads <code>pose_type</code> from <code>pose</code> topic</li> <li>Asynchronously reads one of <code>depth_type</code> from <code>depth</code> topic or <code>rgb_depth_type</code> from <code>rgb_depth</code> topic, if either is available, but not required</li> </ul> </li> <li>If reading from <code>cam_zed</code>, no additional data are required.</li> <li>Publishes <code>ht_frame</code> to <code>ht</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#hand_trackingviewer","title":"hand_tracking.viewer","text":"<p>Reads the output of the <code>hand_tracking</code> plugin and displays the results on the screen. This is most useful for debugging. The capabilities of this plugin will be merged into the <code>debugview</code> plugin in the future.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>ht_frame</code> from <code>ht</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#lighthouse","title":"lighthouse","text":"<p>Enables lighthouse tracking using the libsurvive library</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> to <code>slow_pose</code> topic.</li> <li>Publishes <code>fast_pose_type</code> to <code>fast_pose</code> topic. </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#native_renderer","title":"native_renderer","text":"<p>Constructs a full rendering pipeline utilizing several ILLIXR components.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Calls <code>vulkan::display_provider</code></li> <li>Calls <code>vulkan::timewarp</code></li> <li>Calls <code>vulkan::app</code></li> <li>Synchronously reads <code>time_point</code> from <code>vsync_estimate</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offline_cam","title":"offline_cam","text":"<p>Reads camera images from files on disk, emulating real cameras on the headset (feeds the application input measurements with timing similar to an actual camera).</p> <p>Topic details:</p> <ul> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offline_imu","title":"offline_imu","text":"<p>Reads IMU data files on disk, emulating a real sensor on the headset (feeds the application input measurements with timing similar to an actual IMU).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_data","title":"offload_data","text":"<p>Writes frames and poses output from the asynchronous reprojection plugin to disk for analysis.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>texture_pose</code> to <code>texture_pose</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_rendering_client","title":"offload_rendering_client","text":"<p>Receives encoded frames from the network, sent by offload_rendering_server</p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::display_provider</code></li> <li>Calls <code>pose_prediction</code></li> <li>Asynchronously reads <code>compressed_frame</code> from <code>compressed_frames</code> topic.</li> <li>Publishes <code>fast_pose_type</code> to <code>render_pose</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_rendering_server","title":"offload_rendering_server","text":"<p>Encodes and transmits frames to one of the offload_rendering_clients. </p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::display_provider</code></li> <li>Asynchronously reads <code>fast_pose_type</code> from <code>render_pose_</code> topic.</li> <li>Publishes <code>compressed_frame</code> to <code>compressed_frames</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#offload_vio","title":"offload_vio","text":"<p>Four plugins which work in unison to allow head tracking (VIO) to be rendered remotely. </p> <p>Topic details:</p> <ul> <li><code>offload_vio.device_rx</code></li> <li>Asynchronously reads a string from topic <code>vio_pose</code>.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic</li> <li>Publishes <code>pose_type</code> to <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> to <code>imu_integrator_input</code> topic.</li> <li><code>offload_vio.device_tx</code></li> <li>Asynchronously reads <code>binocular_cam_type</code> from <code>cam topic</code></li> <li>Publishes a string to <code>compressed_imu_cam</code> topic</li> <li><code>offload_vio.server_rx</code></li> <li>Asynchronously reads a string from <code>compressed_imu_cam</code> topic</li> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> <li><code>offload_vio.server_tx</code></li> <li>Asynchronously reads <code>imu_integrator_input</code> from <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads <code>pose_type</code> from <code>slow_pose</code> topic from <code>open_vins</code></li> <li>Publishes a string to <code>vio_pose</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#openni","title":"openni","text":"<p>Enables an interface to the Openni algorithms.</p> <p>Topic details:</p> <ul> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic. </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#open_vins","title":"open_vins","text":"<p>An alternate head tracking (upstream) implementation that uses a MSCKF (Multi-State Constrained Kalman Filter) to determine poses via camera/IMU.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> on <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> on <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_type</code> on <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#openwarp_vk","title":"openwarp_vk","text":"<p>Provides a Vulkan-based reprojection service.</p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::timewarp</code></li> <li>Calls <code>pose_prediction</code></li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#orb_slam3","title":"orb_slam3","text":"<p>Utilizes the ORB_SLAM3 library to enable real-time head tracking.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>binocular_cam_type</code> from <code>cam</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_type</code> on <code>imu</code> topic.</li> <li>Publishes <code>pose_type</code> to <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> to <code>imu_integrator_input</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#passthrough_integrator","title":"passthrough_integrator","text":"<p>Provides IMU integration.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>imu_integrator_input</code> from <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> <li>Publishes <code>imu_raw_type</code> to <code>imu_raw</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#realsense","title":"realsense","text":"<p>Reads images and IMU measurements from the Intel Realsense.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#record_imu_cam","title":"record_imu_cam","text":"<p>Writes <code>imu_type</code> and <code>binocular_cam_type</code> data to disk.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>binocular_cam_type</code> from <code>cam</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#record_rgb_depth","title":"record_rgb_depth","text":"<p>Writes <code>rgb_depth_type</code> data to disk.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>rgb_depth_type</code> from <code>rgb_depth</code> topic.</li> </ul> <p>Details Code</p>"},{"location":"illixr_plugins/#rk4_integrator","title":"rk4_integrator","text":"<p>Integrates over all IMU samples since the last published visual-inertial pose to provide a fast pose every time a new IMU sample arrives using RK4 integration.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>imu_integrator_input</code> from <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads <code>imu_type</code> from <code>imu</code> topic.</li> <li>Publishes <code>imu_raw_type</code> to <code>imu_raw</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#tcp_network_backend","title":"tcp_network_backend","text":"<p>Provides network communications over TCP.</p> <p>Details Code</p>"},{"location":"illixr_plugins/#timewarp_gl","title":"timewarp_gl <sup>1</sup>","text":"<p>Asynchronous reprojection of the eye buffers. The timewarp ends right before vsync, so it can deduce when the next vsync will be.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Publishes <code>hologram_input</code> to <code>hologram_in</code> topic.</li> <li>If using Monado<ul> <li>Asynchronously reads <code>rendered_frame</code> on <code>eyebuffer</code> topic, if using Monado.</li> <li>Publishes <code>time_point</code> to <code>vsync_estimate</code> topic.</li> <li>Publishes <code>texture_pose</code> to <code>texture_pose</code> topic if <code>ILLIXR_OFFLOAD_ENABLE</code> is set in the env.</li> </ul> </li> <li>If not using Monado<ul> <li>Publishes <code>signal_to_quad</code> to <code>signal_quad</code> topic.</li> </ul> </li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#timewarp_vk","title":"timewarp_vk","text":"<p>Asynchronous reprojection of the eye buffers. The timewarp ends right before vsync, so it can deduce when the next vsync will be.</p> <p>Topic details:</p> <ul> <li>Calls <code>vulkan::timewarp</code></li> <li>Calls <code>pose_prediction</code></li> <li>Asynchronously reads <code>time_point</code> from <code>vsync_estimate</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#webcam","title":"webcam","text":"<p>Uses a webcam to capture images for input into the <code>hand_tracking</code> plugin. This plugin is useful for debugging and is not meant to be used in a production pipeline.</p> <p>Topic details:</p> <ul> <li>Publishes <code>monocular_cam_type</code> to <code>webcam</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#zed","title":"zed","text":"<p>Reads images and IMU measurements from the ZED Mini. Unlike <code>offline_imu</code>, <code>zed</code> additionally has RGB and depth data.</p> <p>Note</p> <p>This plugin implements two threads: one for the camera, and one for the IMU.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> to <code>imu</code> topic.</li> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic.</li> <li>Publishes <code>rgb_depth_type</code> to <code>rgb_depth</code> topic.</li> <li>Publishes <code>camera_data</code> to <code>cam_data</code> topic.</li> <li>Publishes <code>cam_type_zed</code> on <code>cam_zed</code> topic.</li> </ul> <p> Details Code</p>"},{"location":"illixr_plugins/#zeddata_injection","title":"zed.data_injection","text":"<p>Reads images and pose information from disk and publishes them to ILLIXR.</p> <p>Topic details:</p> <ul> <li>Publishes <code>binocular_cam_type</code> to <code>cam</code> topic</li> <li>Publishes <code>pose_type</code> to <code>pose</code> topic.</li> <li>Publishes <code>camera_data</code> to <code>cam_data</code> topic.</li> </ul> <p> Details Code</p> <p>Below this point, we will use Switchboard terminology. Read the API documentation on Switchboard for more information.</p> <p> Current dataflow between all plugins and services. Dark blue boxes represent plugins and cyan  component boxes represent services. Data types are represented with cylinders and labelled as <code>topic &lt;data_type&gt;</code>. Service data types are represented by octagons. Solid lines point from the plugin/service which publishes them to the data type. Dashed lines point from data types to the plugin/service which reads them synchronously. Dotted lines point from data types to the plugin/service which reads them asynchronously.</p> <p>See Writing Your Plugin to extend ILLIXR.</p>"},{"location":"illixr_plugins/#plugin-interdependencies","title":"Plugin Interdependencies","text":"<p>Some plugins require other plugins to be loaded in order to work. The table below gives a listing of the plugin interdependencies.</p> Plugin Requires Provided by plugin debugview pose_prediction fauxpose, pose_lookup, pose_prediction gldemo pose_prediction fauxpose, pose_lookup, pose_prediction native_renderer app vkdemo display_sink display_vk pose_prediction fauxpose, pose_lookup, pose_prediction timewarp timewarp_vk timewarp_gl pose_prediction fauxpose, pose_lookup, pose_prediction timewarp_vk display_sink display_vk pose_prediction fauxpose, pose_lookup, pose_prediction vkdemo display_sink display_vk <p>See Getting Started for more information on adding plugins to a profile file.</p> <ol> <li> <p>ILLIXR has switched to a Vulkan back end, thus OpenGL based plugins may not work on every system.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"illixr_services/","title":"ILLIXR Services","text":"<p>This page details the structure of ILLIXR's services and how they interact with each other.</p>"},{"location":"illixr_services/#fauxpose","title":"fauxpose","text":"<p>An alternate tracking implementation that simply generates \"fast_pose\" data from a simple mathematical algorithm (circular movement).  The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking.</p> <p>Topic details: -   Provides <code>fast_pose_type</code> -   Asynchronously reads <code>time_type</code> from <code>vsync_estimate</code> topic.</p> <p> Details Code</p>"},{"location":"illixr_services/#pose_prediction","title":"pose_prediction","text":"<p>Uses the latest IMU value to predict a pose for a future point in time. Implements the <code>pose_prediction</code> service, so poses can be served directly to other plugins.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>pose_type</code> on <code>slow_pose</code> topic, but it is only used as a fallback.</li> <li>Asynchronously reads <code>imu_raw</code> on <code>imu_raw</code> topic.</li> <li>Asynchronously reads <code>pose_type</code> on <code>true_pose</code> topic, but it is only used if the client asks for the true pose.</li> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic. This tells <code>pose_predict</code> what time to estimate for.</li> </ul> <p> Details Code</p>"},{"location":"illixr_services/#pose_lookup","title":"pose_lookup","text":"<p>Implements the <code>pose_predict</code> service, but uses ground truth from the dataset. The plugin peeks \"into the future\" to determine what the exact pose will be at a certain time.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>time_point</code> on <code>vsync_estimate</code> topic. This tells <code>pose_lookup</code> what time to lookup.</li> </ul> <p> Details Code</p>"},{"location":"illixr_services/#vkdemo","title":"vkdemo","text":"<p>INFO NEEDED</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code></li> <li>Calls <code>vulkan::display_provider</code></li> </ul> <p> Details Code</p> <p> Current dataflow between all plugins and services. Dark blue boxes represent plugins and cyan  component boxes represent services. Data types are represented with cylinders and labelled as <code>topic &lt;data_type&gt;</code>. Service data types are represented by octagons. Solid lines point from the plugin/service which publishes them to the data type. Dashed lines point from data types to the plugin/service which reads them synchronously. Dotted lines point from data types to the plugin/service which reads them asynchronously.</p>"},{"location":"logging_and_metrics/","title":"Logging and metrics","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/logging_and_metrics</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"modifying_a_plugin/","title":"Modifying a plugin","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/modifying_a_plugin</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"modules/","title":"Modules","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/modules</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"updating_tags_and_docs/","title":"Updating tags and docs","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/updating_tags_and_docs</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"using_cameras/","title":"Using cameras","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/using_cameras</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"virtualization/","title":"Virtualization","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/virtualization</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"writing_your_plugin/","title":"Writing your plugin","text":"<p>This file has moved to https://illixr.github.io/ILLIXR/working_with/writing_your_plugin</p> <p>You should be automatically redirected in 5 seconds.</p>"},{"location":"api/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace Eigen </li> <li>class HMD <ul> <li>struct hmd_info_t </li> <li>struct mesh_coord2d_t </li> <li>struct mesh_coord3d_t </li> <li>struct uv_coord_t </li> </ul> </li> <li>namespace ILLIXR RAC_ERRNO_MSG. <ul> <li>struct Dependency </li> <li>struct DistortionCorrectionVertex </li> <li>struct DistortionMatrix </li> <li>struct OpenWarpVertex </li> <li>struct WarpMatrices </li> <li>class cancellable_sleep </li> <li>namespace data_format <ul> <li>struct binocular_cam_type </li> <li>struct cam_base_type </li> <li>struct cam_type_zed </li> <li>namespace camera </li> <li>struct camera_data Data structure to hold information about the full camera system. This information is mostly constant. </li> <li>struct ccd_data A data structure to hold relevant camera information. This information is constant (per camera) </li> <li>struct compressed_frame </li> <li>struct connection_signal </li> <li>namespace coordinates </li> <li>struct depth_type </li> <li>struct fast_pose_type </li> <li>struct hmd_physical_info </li> <li>struct hologram_input </li> <li>namespace ht <ul> <li>struct hand_points </li> <li>struct ht_detection </li> <li>struct ht_frame </li> <li>struct position </li> <li>struct raw_ht_data </li> <li>struct velocity </li> </ul> </li> <li>namespace image </li> <li>struct image_handle </li> <li>struct imu_integrator_input </li> <li>struct imu_params </li> <li>struct imu_raw_type </li> <li>struct imu_type </li> <li>struct monocular_cam_type </li> <li>struct point </li> <li>struct point_with_units </li> <li>struct point_with_validity </li> <li>struct points_with_units </li> <li>struct pose_data </li> <li>class pose_prediction </li> <li>struct pose_type </li> <li>class proper_quaternion A more complete implementation of the Eigen::Quaternion. </li> <li>struct raw_point </li> <li>struct raw_pose </li> <li>struct rect </li> <li>struct rendered_frame </li> <li>struct rgb_depth_type </li> <li>struct signal_to_quad </li> <li>struct texture_pose </li> <li>namespace units </li> <li>struct vk_image_handle </li> </ul> </li> <li>class data_injection </li> <li>class data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>class debugview </li> <li>class depthai </li> <li>namespace display <ul> <li>class display_backend </li> <li>class glfw_extended </li> <li>class headless </li> <li>class x11_direct </li> </ul> </li> <li>struct display_params Display parameters. </li> <li>class dynamic_lib </li> <li>class event A boolean condition-variable. </li> <li>class fauxpose </li> <li>class fauxpose_impl Create a \"pose_prediction\" type service. </li> <li>class gen_guid This class generates unique IDs. </li> <li>class gldemo </li> <li>class ground_truth_slam </li> <li>class gtsam_integrator </li> <li>struct index_params </li> <li>class lazy_load_image </li> <li>class lighthouse </li> <li>class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. </li> <li>namespace math_util </li> <li>struct model </li> <li>class native_renderer </li> <li>namespace network <ul> <li>class TCPSocket </li> <li>class network_backend </li> <li>struct topic_config </li> </ul> </li> <li>class offline_cam </li> <li>class offline_imu </li> <li>class offload_data </li> <li>class offload_reader </li> <li>class offload_rendering_client </li> <li>class offload_rendering_server Main server implementation for offload rendering. </li> <li>class offload_rendering_server_loader Plugin loader for the offload rendering server. </li> <li>class offload_writer </li> <li>class openni_plugin </li> <li>class openwarp_vk </li> <li>class openwarp_vk_plugin </li> <li>class passthrough_integrator </li> <li>class phonebook A service locator forILLIXR . <ul> <li>class service A 'service' that can be registered in the phonebook. </li> </ul> </li> <li>class plugin A dynamically-loadable plugin for Spindle. </li> <li>class pose_lookup_impl </li> <li>class pose_prediction_impl </li> <li>struct raw_imu_type </li> <li>class realsense </li> <li>class record This class represents a tuple of fields which get logged by <code>record_logger</code> . </li> <li>class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class record_header Schema of each record. </li> <li>class record_imu_cam </li> <li>class record_logger The ILLIXR logging service for structured records. </li> <li>class record_rgb_depth </li> <li>class relative_clock Relative clock for all of ILLIXR . </li> <li>struct rendering_params Rendering parameters. </li> <li>class rk4_integrator </li> <li>class runtime </li> <li>struct sensor_types </li> <li>struct server_params </li> <li>class server_reader </li> <li>class server_writer </li> <li>class sqlite_record_logger </li> <li>class sqlite_thread </li> <li>struct state_plus </li> <li>class stdout_record_logger </li> <li>class stoplight Start/stop synchronization for the whole application. </li> <li>class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). <ul> <li>class buffered_reader </li> <li>class event Virtual class for event types. </li> <li>class event_wrapper Helper class for making event types. </li> <li>class network_writer </li> <li>class reader A handle which can read the latest event on a topic. </li> <li>class writer A handle which can publish events to a topic. </li> </ul> </li> <li>class tcp_network_backend </li> <li>struct texture </li> <li>class threadloop A reusable threadloop for plugins. </li> <li>class time_point </li> <li>class timewarp_gl </li> <li>class timewarp_vk </li> <li>class timewarp_vk_plugin </li> <li>struct vertex </li> <li>class video_decoder </li> <li>class video_encoder </li> <li>class viewer </li> <li>class vkdemo </li> <li>class vkdemo_plugin </li> <li>namespace vulkan <ul> <li>class app </li> <li>struct buffer_pool </li> <li>class display_provider A display sink is a service that can display the rendered images to the screen. </li> <li>namespace ffmpeg_utils <ul> <li>struct ffmpeg_vk_frame </li> </ul> </li> <li>struct queue </li> <li>struct queue_families </li> <li>class render_pass </li> <li>struct swapchain_details </li> <li>class timewarp </li> <li>struct vk_image </li> </ul> </li> <li>class webcam </li> <li>class xlib_gl_extended_window </li> <li>class zed_camera </li> <li>class zed_camera_thread </li> <li>namespace zed_capture <ul> <li>class capture </li> <li>class files </li> </ul> </li> <li>class zed_imu_thread </li> </ul> </li> <li>class pim_object Wrapper object protecting the lifetime of IMU integration inputs and biases. </li> <li>struct accel_type </li> <li>class coordinate_system Base coordinate system. </li> <li>class topic Represents a topic. </li> <li>class topic_buffer </li> <li>class topic_subscription Represents a single topic_subscription (callback and queue) </li> <li>namespace YAML <ul> <li>struct convert&lt; ILLIXR::Dependency &gt; </li> </ul> </li> <li>namespace boost <ul> <li>namespace serialization </li> </ul> </li> <li>class csv_iterator </li> <li>class csv_row </li> <li>namespace cxxopts <ul> <li>struct HelpGroupDetails </li> <li>struct HelpOptionDetails </li> <li>class KeyValue </li> <li>struct Option </li> <li>class OptionAdder </li> <li>class OptionDetails </li> <li>class OptionParser </li> <li>class OptionValue </li> <li>class Options </li> <li>class ParseResult <ul> <li>class Iterator </li> </ul> </li> <li>class Value </li> <li>namespace exceptions <ul> <li>class exception </li> <li>class gratuitous_argument_for_option </li> <li>class incorrect_argument_type </li> <li>class invalid_option_format </li> <li>class invalid_option_syntax </li> <li>class missing_argument </li> <li>class no_such_option </li> <li>class option_already_exists </li> <li>class option_has_no_value </li> <li>class option_requires_argument </li> <li>class parsing </li> <li>class requested_option_not_present </li> <li>class specification </li> </ul> </li> <li>namespace values <ul> <li>class abstract_value </li> <li>namespace detail <ul> <li>struct SignedCheck </li> <li>struct SignedCheck&lt; T, false &gt; </li> <li>struct SignedCheck&lt; T, true &gt; </li> </ul> </li> <li>namespace parser_tool <ul> <li>struct ArguDesc </li> <li>struct IntegerDesc </li> </ul> </li> <li>class standard_value </li> <li>class standard_value&lt; bool &gt; </li> <li>struct type_is_container </li> <li>struct type_is_container&lt; std::vector&lt; T &gt; &gt; </li> </ul> </li> </ul> </li> <li>namespace cxxopts </li> <li>namespace cxxopts </li> <li>namespace parser_tool </li> <li>namespace parser_tool </li> <li>class display_vk </li> <li>struct model_push_constant </li> <li>class offload_rendering_client Main client implementation for offload rendering. </li> <li>class offload_rendering_client_loader Plugin loader for the offload rendering client. </li> <li>namespace parser </li> <li>class pose_lookup_plugin </li> <li>class pose_prediction_plugin </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_in_destructor </li> <li>class runtime_impl </li> <li>class should_profile_class </li> <li>namespace sl </li> <li>namespace std <ul> <li>struct hash&lt; vertex &gt; </li> </ul> </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> <li>struct uniform_buffer_object </li> <li>struct vertex </li> <li>namespace vulkan </li> </ul>"},{"location":"api/camera__data_8hpp/","title":"File camera_data.hpp","text":"<p>FileList &gt; data_format &gt; camera_data.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/unit.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/camera__data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/camera__data_8hpp/#classes","title":"Classes","text":"Type Name struct camera_data Data structure to hold information about the full camera system. This information is mostly constant. struct ccd_data A data structure to hold relevant camera information. This information is constant (per camera)"},{"location":"api/camera__data_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr double T_M_PI   = <code>2 \\* M\\_PI</code>"},{"location":"api/camera__data_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/camera__data_8hpp/#variable-t_m_pi","title":"variable T_M_PI","text":"<pre><code>constexpr double T_M_PI;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/camera_data.hpp</code></p>"},{"location":"api/camera__data_8hpp_source/","title":"File camera_data.hpp","text":"<p>File List &gt; data_format &gt; camera_data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"illixr/data_format/unit.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;cstddef&gt;\n#include &lt;map&gt;\n#include &lt;utility&gt;\n\n/*\n * The structs in this file were created to hold information about the camera which produced the images. This information\n * includes: center pixels, fields of view, number of pixels across images, and units. This information is needed by the hand\n * tracking plugin to determine the actual spatial coordinates of the hands.\n */\n\nconstexpr double T_M_PI = 2 * M_PI;\n\nnamespace ILLIXR::data_format {\n\nstruct ccd_data {\n    const float  center_x;       \n    const float  center_y;       \n    const double vertical_fov;   \n    const double horizontal_fov; \n\n    ccd_data() = delete;\n\n    ccd_data(const float cx, const float cy, const double vf, const double hf)\n        : center_x{cx}\n        , center_y{cy}\n        , vertical_fov{(vf &gt; T_M_PI) ? vf * M_PI / 180. : vf}\n        // assume any value below 2PI is in radians, anything else is degrees\n        , horizontal_fov{(hf &gt; T_M_PI) ? hf * M_PI / 180. : hf} { }\n};\n\ntypedef std::map&lt;units::eyes, ccd_data&gt;\n    ccd_map; \n\nstruct camera_data : switchboard::event {\n    size_t                  width;    \n    size_t                  height;   \n    float                   fps;      \n    float                   baseline; \n    units::measurement_unit units;    \n    ccd_map                 ccds;     \n\n    camera_data()\n        : width{0}\n        , height{0}\n        , fps{0.}\n        , baseline{0.,}\n        , units{units::measurement_unit::UNSET}\n        , ccds{} {}\n\n    camera_data(const size_t width_, const size_t height_, const float fps_, const float baseline_,\n                units::measurement_unit units_, ccd_map ccds_)\n        : width{width_}\n        , height{height_}\n        , fps{fps_}\n        , baseline{baseline_}\n        , units{units_}\n        , ccds{std::move(ccds_)} { }\n\n    ccd_data operator[](const units::eyes idx) const {\n        return ccds.at(idx);\n    }\n};\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/capture_8cpp/","title":"File capture.cpp","text":"<p>FileList &gt; capture &gt; capture.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"capture.hpp\"</code></li> <li><code>#include \"files.hpp\"</code></li> <li><code>#include \"illixr/data_format/unit.hpp\"</code></li> <li><code>#include \"illixr/imgui/backends/imgui_impl_glfw.h\"</code></li> <li><code>#include \"illixr/imgui/backends/imgui_impl_opengl3.h\"</code></li> <li><code>#include \"illixr/shader_util.hpp\"</code></li> <li><code>#include \"zed_opencv.hpp\"</code></li> </ul>"},{"location":"api/capture_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void glfw_error_callback (int error, const char * description)"},{"location":"api/capture_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/capture_8cpp/#function-glfw_error_callback","title":"function glfw_error_callback","text":"<pre><code>static void glfw_error_callback (\n    int error,\n    const char * description\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/capture.cpp</code></p>"},{"location":"api/capture_8cpp_source/","title":"File capture.cpp","text":"<p>File List &gt; capture &gt; capture.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"capture.hpp\"\n\n#include \"files.hpp\"\n#include \"illixr/data_format/unit.hpp\"\n#include \"illixr/imgui/backends/imgui_impl_glfw.h\"\n#include \"illixr/imgui/backends/imgui_impl_opengl3.h\"\n#include \"illixr/shader_util.hpp\"\n#include \"zed_opencv.hpp\"\n\nusing namespace ILLIXR::zed_capture;\n\nstatic void glfw_error_callback(int error, const char* description) {\n    spdlog::get(\"illixr\")-&gt;error(\"|| glfw error_callback: {}\\n|&gt; {}\", error, description);\n    ILLIXR::abort();\n}\n\nvoid capture::get_camera(const data_format::pose_data&amp; wcf) {\n    sl::InitParameters params;\n    params.camera_resolution      = sl::RESOLUTION::HD720;\n    params.coordinate_units       = sl::UNIT::MILLIMETER;\n    params.coordinate_system      = sl::COORDINATE_SYSTEM::RIGHT_HANDED_Z_UP_X_FWD;\n    params.camera_fps             = fps_;\n    params.depth_mode             = sl::DEPTH_MODE::PERFORMANCE;\n    params.depth_stabilization    = true;\n    params.depth_minimum_distance = 100.;\n\n    wcs_xform_.setTranslation(sl::Translation(wcf.position.x(), wcf.position.y(), wcf.position.z()));\n    wcs_xform_.setOrientation(\n        sl::Orientation({wcf.orientation.x(), wcf.orientation.y(), wcf.orientation.z(), wcf.orientation.w()}));\n    sl::PositionalTrackingParameters t_params(wcs_xform_);\n\n    if (camera_-&gt;open(params) != sl::ERROR_CODE::SUCCESS)\n        throw std::runtime_error(\"Open failed\");\n\n    if (camera_-&gt;enablePositionalTracking(t_params) != sl::ERROR_CODE::SUCCESS)\n        throw std::runtime_error(\"tracking failed\");\n    camera_-&gt;setCameraSettings(sl::VIDEO_SETTINGS::EXPOSURE, -1);\n\n    camera_-&gt;updateSelfCalibration();\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    camera_-&gt;grab(runtime_params_);\n}\n\nvoid capture::get_config() {\n    auto                     cam_conf  = camera_-&gt;getCameraInformation().camera_configuration;\n    sl::CameraParameters     left_cam  = cam_conf.calibration_parameters.left_cam;\n    sl::CameraParameters     right_cam = cam_conf.calibration_parameters.right_cam;\n    data_format::camera_data cc{\n        cam_conf.resolution.width,\n        cam_conf.resolution.height,\n        cam_conf.fps,\n        cam_conf.calibration_parameters.getCameraBaseline(),\n        data_format::units::MILLIMETER,\n        {{data_format::units::eyes::LEFT_EYE,\n          {left_cam.cx, left_cam.cy, left_cam.v_fov * (M_PI / 180.), left_cam.h_fov * (M_PI / 180.)}},\n         {data_format::units::eyes::RIGHT_EYE,\n          {right_cam.cx, right_cam.cy, right_cam.v_fov * (M_PI / 180.), right_cam.h_fov * (M_PI / 180.)}}}};\n    img_size_ = cam_conf.resolution;\n    std::ofstream cam_of;\n    cam_of.open(files::cam_file_, std::ofstream::out);\n    cam_of &lt;&lt; \"#width,height,fps_,baseline,Lcenter_x,Lcenter_y,Lvfov,Lhfox,Rcenter_x,Rcenter_y,Rvfov,Lhfov\" &lt;&lt; std::endl;\n    cam_of &lt;&lt; cc &lt;&lt; std::endl;\n    cam_of.close();\n}\n\nvoid capture::make_gui() {\n    glfwMakeContextCurrent(viewport_);\n    glfwPollEvents();\n    int d_width, d_height;\n    glfwGetFramebufferSize(viewport_, &amp;d_width, &amp;d_height);\n    glViewport(0, 0, d_width, d_height);\n    glClearColor(clear_color_.x * clear_color_.w, clear_color_.y * clear_color_.w, clear_color_.z * clear_color_.w,\n                 clear_color_.w);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    ImGui_ImplOpenGL3_NewFrame();\n\n    ImGui_ImplGlfw_NewFrame();\n\n    ImGui::NewFrame();\n    raw_img_[0] = imageL_ocv_.clone();\n    raw_img_[1] = imageR_ocv_.clone();\n    for (int i = 0; i &lt; 2; i++) {\n        cv::cvtColor(raw_img_[i], raw_img_[i], cv::COLOR_BGRA2RGB);\n        glBindTexture(GL_TEXTURE_2D, textures_[i]);\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, raw_img_[i].cols, raw_img_[i].rows, 0, GL_RGB, GL_UNSIGNED_BYTE,\n                     raw_img_[i].ptr());\n    }\n\n    if (ImGui::Begin(\"images\")) {\n        if (ImGui::BeginTable(\"img_table\", 2, ImGuiTableFlags_Borders)) {\n            ImGui::TableNextRow();\n            ImGui::TableSetColumnIndex(0);\n            ImGui::Image((void*) (intptr_t) textures_[0], ImVec2((float) img_size_.width, (float) img_size_.height));\n            ImGui::TableSetColumnIndex(1);\n            ImGui::Image((void*) (intptr_t) textures_[1], ImVec2((float) img_size_.width, (float) img_size_.height));\n            ImGui::EndTable();\n        }\n        ImGui::End();\n    }\n    ImGui::Render();\n    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n    glfwSwapBuffers(viewport_);\n}\n\nint capture::get_data() {\n    if (camera_-&gt;grab(runtime_params_) == sl::ERROR_CODE::SUCCESS) {\n        sl::Pose                      pose;\n        sl::POSITIONAL_TRACKING_STATE state = camera_-&gt;getPosition(pose, sl::REFERENCE_FRAME::WORLD);\n        if (state == sl::POSITIONAL_TRACKING_STATE::OK) {\n            timepoint_ = pose.timestamp.getNanoseconds();\n            data_format::pose_type poseData(\n                time_point(clock_duration_{timepoint_}),\n                {pose.getTranslation().tx, pose.getTranslation().ty, pose.getTranslation().tz},\n                {pose.getOrientation().w, pose.getOrientation().x, pose.getOrientation().y, pose.getOrientation().z});\n            data_of_ &lt;&lt; poseData &lt;&lt; std::endl;\n\n            camera_-&gt;retrieveImage(imageL_zed_, sl::VIEW::LEFT, sl::MEM::CPU, img_size_);\n            camera_-&gt;retrieveImage(imageR_zed_, sl::VIEW::RIGHT, sl::MEM::CPU, img_size_);\n            // camera_-&gt;retrieveMeasure(depth_zed, sl::MEASURE::DEPTH, sl::MEM::CPU, img_size_);\n            //  camera_-&gt;retrieveMeasure(conf_zed, sl::MEASURE::CONFIDENCE);\n\n            std::string c_imgL = files::camL_path_.string() + \"/\" + std::to_string(timepoint_) + \".png\";\n            camL_of_ &lt;&lt; timepoint_ &lt;&lt; \",\" &lt;&lt; timepoint_ &lt;&lt; \".png\" &lt;&lt; std::endl;\n            cv::imwrite(c_imgL, imageL_ocv_);\n            std::string c_imgR = files::camR_path_.string() + \"/\" + std::to_string(timepoint_) + \".png\";\n            camR_of_ &lt;&lt; timepoint_ &lt;&lt; \",\" &lt;&lt; timepoint_ &lt;&lt; \".png\" &lt;&lt; std::endl;\n            cv::imwrite(c_imgR, imageR_ocv_);\n            // std::string c_depth = files::depth_path.string() + \"/\" + std::to_string(timepoint_) + \".png\";\n            // depth_of &lt;&lt; timepoint_ &lt;&lt; \",\" &lt;&lt; timepoint_ &lt;&lt; \".png\" &lt;&lt; std::endl;\n            // writeFloatImage(c_depth, depth_ocv);\n            // std::string c_conf = files::conf_path.string() + \"/\" + std::to_string(timepoint_) + \".png\";\n            // conf_of &lt;&lt; timepoint_ &lt;&lt; \",\" &lt;&lt; timepoint_ &lt;&lt; \".png\" &lt;&lt; std::endl;\n            // writeFloatImage(c_conf, conf_ocv);\n\n            make_gui();\n            return 1;\n        } else {\n            std::cout &lt;&lt; \"Dropping frame\" &lt;&lt; std::endl;\n        }\n    }\n    return 0;\n}\n\ncapture::~capture() {\n    camera_-&gt;close();\n    delete camera_;\n    data_of_.close();\n    camL_of_.close();\n    camR_of_.close();\n    // depth_of.close();\n    // conf_of.close();\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplGlfw_Shutdown();\n    ImGui::DestroyContext();\n\n    glfwDestroyWindow(viewport_);\n\n    glfwTerminate();\n}\n\ncapture::capture(const int fp, const data_format::pose_data&amp; wcf)\n    : timepoint_{0}\n    , fps_{fp} {\n    // runtime_params_ = sl::RuntimeParameters(true,   // enable depth\n    //                                         false,  //enable fill mode\n    //                                         95,     // confidence limit cutoff\n    //                                         100,    // texture confidence cutoff\n    //                                         sl::REFERENCE_FRAME::WORLD,  // reference frame\n    //                                         true);  // remove saturated\n    data_of_.open(files::data_file_, std::ofstream::out);\n    data_of_ &lt;&lt; \"#timestamp[ns],tx,ty,tx,w,x,y,z\" &lt;&lt; std::endl;\n    camL_of_.open(files::camL_file_, std::ofstream ::out);\n    camL_of_ &lt;&lt; \"#timestamp[ns],filename\" &lt;&lt; std::endl;\n    camR_of_.open(files::camR_file_, std::ofstream ::out);\n    camR_of_ &lt;&lt; \"#timestamp[ns],filename\" &lt;&lt; std::endl;\n    // depth_of.open(files::depth_file, std::ofstream ::out);\n    // depth_of &lt;&lt; \"#timestamp[ns],filename\" &lt;&lt; std::endl;\n    // conf_of.open(files::conf_file, std::ofstream ::out);\n    // conf_of &lt;&lt; \"#timestamp[ns],filename\" &lt;&lt; std::endl;\n    camera_ = new sl::Camera();\n    get_camera(wcf);\n\n    get_config();\n\n    imageL_zed_.alloc(img_size_.width, img_size_.height, sl::MAT_TYPE::U8_C4, sl::MEM::CPU);\n    imageR_zed_.alloc(img_size_.width, img_size_.height, sl::MAT_TYPE::U8_C4, sl::MEM::CPU);\n    // depth_zed.alloc(img_size_.width, img_size_.height, sl::MAT_TYPE::F32_C1, sl::MEM::CPU);\n    // conf_zed.alloc(img_size_.width, img_size_.height, sl::MAT_TYPE::F32_C1, sl::MEM::CPU);\n\n    imageL_ocv_ = slMat_to_cvMat(imageL_zed_);\n    imageR_ocv_ = slMat_to_cvMat(imageR_zed_);\n    // depth_ocv = slMat2cvMat(depth_zed);\n    // conf_ocv = slMat2cvMat(conf_zed);\n\n    if (!glfwInit()) {\n        throw std::runtime_error(\"gl init failed\");\n    }\n\n    glfwSetErrorCallback(glfw_error_callback);\n    glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);\n    glfwWindowHint(GLFW_VISIBLE, GL_TRUE);\n\n    constexpr std::string_view glsl_version{\"#version 330 core\"};\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);\n    viewport_ = glfwCreateWindow(img_size_.width * 2 + 20, img_size_.height + 20, \"ILLIXR Debug View\", nullptr, nullptr);\n\n    glfwSetWindowSize(viewport_, img_size_.width * 2 + 20, img_size_.height + 20);\n\n    glfwMakeContextCurrent(viewport_);\n\n    glfwSwapInterval(1);\n\n    const GLenum glew_err = glewInit();\n    if (glew_err != GLEW_OK) {\n        glfwDestroyWindow(viewport_);\n        throw std::runtime_error(\"[debugview] Failed to initialize GLEW\");\n    }\n\n    // Initialize IMGUI context.\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n\n    // Dark theme, of course.\n    ImGui::StyleColorsDark();\n\n    // Init IMGUI for OpenGL\n    ImGui_ImplGlfw_InitForOpenGL(viewport_, true);\n    ImGui_ImplOpenGL3_Init(glsl_version.data());\n\n    glGenTextures(2, &amp;(textures_[0]));\n    for (unsigned int texture : textures_) {\n        glBindTexture(GL_TEXTURE_2D, texture);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    }\n\n    glfwMakeContextCurrent(nullptr);\n}\n</code></pre>"},{"location":"api/capture_8hpp/","title":"File capture.hpp","text":"<p>FileList &gt; capture &gt; capture.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/imgui/imgui.h\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;opencv2/imgcodecs.hpp&gt;</code></li> <li><code>#include &lt;sl/Camera.hpp&gt;</code></li> </ul>"},{"location":"api/capture_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace zed_capture"},{"location":"api/capture_8hpp/#classes","title":"Classes","text":"Type Name class capture <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/capture.hpp</code></p>"},{"location":"api/capture_8hpp_source/","title":"File capture.hpp","text":"<p>File List &gt; capture &gt; capture.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n// clang-format off\n#include &lt;GL/glew.h&gt;    // GLEW has to be loaded before other GL libraries\n#include &lt;GLFW/glfw3.h&gt; // Also loading first, just to be safe\n// clang-format on\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/imgui/imgui.h\"\n\n#include &lt;fstream&gt;\n#include &lt;opencv2/imgcodecs.hpp&gt;\n#include &lt;sl/Camera.hpp&gt;\n\nnamespace ILLIXR::zed_capture {\nclass capture {\npublic:\n    capture() = delete;\n    capture(int fp, const ILLIXR::data_format::pose_data&amp; wcf);\n    ~capture();\n    void get_camera(const ILLIXR::data_format::pose_data&amp; wcf);\n    void get_config();\n    int  get_data();\n    void make_gui();\n\nprivate:\n    std::ofstream data_of_;\n    std::ofstream camL_of_;\n    std::ofstream camR_of_;\n    // std::ofstream depth_of_;\n    // std::ofstream conf_of_;\n\n    sl::Camera* camera_ = nullptr;\n\n    sl::Mat imageL_zed_;\n    sl::Mat imageR_zed_;\n    // sl::Mat depth_zed_;\n    // sl::Mat conf_zed_;\n\n    cv::Mat imageL_ocv_;\n    cv::Mat imageR_ocv_;\n    // cv::Mat  depth_ocv_;\n    // cv::Mat  conf_ocv_;\n    uint64_t timepoint_;\n\n    sl::Resolution img_size_;\n\n    sl::RuntimeParameters runtime_params_;\n    sl::Transform         wcs_xform_;\n\n    GLFWwindow* viewport_{};\n    GLuint      textures_[2];\n    ImVec4      clear_color_ = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n    cv::Mat     raw_img_[2];\n    const int   fps_;\n};\n\n} // namespace ILLIXR::zed_capture\n</code></pre>"},{"location":"api/capture__main_8cpp/","title":"File capture_main.cpp","text":"<p>FileList &gt; capture &gt; capture_main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"capture.hpp\"</code></li> <li><code>#include \"cxxopts.hpp\"</code></li> <li><code>#include \"files.hpp\"</code></li> </ul>"},{"location":"api/capture__main_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool ends_with (const std::string &amp; word, const std::string &amp; end)  int main (int argc, const char * argv)"},{"location":"api/capture__main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/capture__main_8cpp/#function-ends_with","title":"function ends_with","text":"<pre><code>bool ends_with (\n    const std::string &amp; word,\n    const std::string &amp; end\n) \n</code></pre>"},{"location":"api/capture__main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    const char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/capture_main.cpp</code></p>"},{"location":"api/capture__main_8cpp_source/","title":"File capture_main.cpp","text":"<p>File List &gt; capture &gt; capture_main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"capture.hpp\"\n\n#include \"cxxopts.hpp\"\n#include \"files.hpp\"\n\nbool ends_with(const std::string&amp; word, const std::string&amp; end) {\n    auto pos = word.rfind(end);\n    if (pos != std::string::npos &amp;&amp; (word.substr(pos, word.size()) == end))\n        return true;\n    return false;\n}\n\nint main(int argc, const char* argv[]) {\n    cxxopts::Options options(\"zed_capture\", \"main\");\n    options.show_positional_help();\n    options.add_options()(\"d,duration\", \"The duration to run for in seconds\", cxxopts::value&lt;int&gt;()-&gt;default_value(\"10\"))(\n        \"f,fps\", \"Frames per second\",\n        cxxopts::value&lt;int&gt;()-&gt;default_value(\"30\"))(\"wc,world_coordinates\",\n                                                    \"The origin of the world coordinate system in relation to the camera. Must \"\n                                                    \"be 7 comma separated values x, y, z, w, wx, wy, wz.\",\n                                                    cxxopts::value&lt;std::string&gt;()-&gt;default_value(\"0.,0.,0.,1.,0.,0.,0.\"))(\n        \"p,path\", \"The root path to write the data to. Default is current working directory.\",\n        cxxopts::value&lt;std::string&gt;()-&gt;default_value(\".\"))(\"h,help\", \"Produce help message\");\n    auto opts = options.parse(argc, argv);\n    if (opts.count(\"help\")) {\n        std::cout &lt;&lt; options.help() &lt;&lt; std::endl;\n        return EXIT_SUCCESS;\n    }\n    const int         fps      = opts[\"fps\"].as&lt;int&gt;();\n    const int         duration = opts[\"duration\"].as&lt;int&gt;();\n    const std::string wcs      = opts[\"world_coordinates\"].as&lt;std::string&gt;();\n    std::string       root     = opts[\"path\"].as&lt;std::string&gt;();\n    if (!ends_with(root, \"/\"))\n        root += \"/\";\n\n    std::stringstream  iss(wcs);\n    std::string        token;\n    std::vector&lt;float&gt; ip;\n    while (!iss.eof() &amp;&amp; std::getline(iss, token, ',')) {\n        ip.emplace_back(std::stof(token));\n    }\n    ILLIXR::data_format::pose_data wcs_origin({ip[0], ip[1], ip[2]}, {ip[3], ip[4], ip[5], ip[6]});\n    const std::string              sub_path = \"fps\" + std::to_string(fps) + \"_dur\" + std::to_string(duration) + \"/\";\n    ILLIXR::zed_capture::files*    fls      = ILLIXR::zed_capture::files::getInstance(root, sub_path);\n\n    std::shared_ptr&lt;ILLIXR::zed_capture::capture&gt; cap = std::make_shared&lt;ILLIXR::zed_capture::capture&gt;(fps, wcs_origin);\n\n    for (int i = 3; i &gt; 0; i--) {\n        std::cout &lt;&lt; \"Starting capture in \" &lt;&lt; i &lt;&lt; \" seconds\" &lt;&lt; \"\\t\\r\" &lt;&lt; std::flush;\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n    std::cout &lt;&lt; \"Capture starting\" &lt;&lt; std::endl;\n    int current = 0;\n    while (current &lt; fps * duration) {\n        std::cout &lt;&lt; \"\\t\\r\" &lt;&lt; std::flush;\n        std::cout &lt;&lt; \"Capturing frame \" &lt;&lt; current + 1 &lt;&lt; \" / \" &lt;&lt; fps * duration;\n        current += cap-&gt;get_data();\n    }\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Capture complete. Files written to \" &lt;&lt; root &lt;&lt; sub_path &lt;&lt; std::endl;\n    delete fls;\n    return EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"api/classHMD/","title":"Class HMD","text":"<p>ClassList &gt; HMD</p>"},{"location":"api/classHMD/#classes","title":"Classes","text":"Type Name struct hmd_info_t struct mesh_coord2d_t struct mesh_coord3d_t struct uv_coord_t"},{"location":"api/classHMD/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr int NUM_COLOR_CHANNELS   = <code>3</code> constexpr int NUM_EYES   = <code>2</code>"},{"location":"api/classHMD/#public-static-functions","title":"Public Static Functions","text":"Type Name void build_distortion_meshes (std::array&lt; std::array&lt; std::vector&lt; mesh_coord2d_t &gt;, NUM_COLOR_CHANNELS &gt;, NUM_EYES &gt; &amp; distort_coords, hmd_info_t &amp; hmd_info)  void build_distortion_meshes (std::array&lt; std::array&lt; std::vector&lt; mesh_coord2d_t &gt;, NUM_COLOR_CHANNELS &gt;, NUM_EYES &gt; &amp; distort_coords, hmd_info_t &amp; hmd_info)  float evaluate_catmull_rom_spline (float value, const float * K, int num_knots)  float evaluate_catmull_rom_spline (float value, const float * K, int num_knots)  void get_default_hmd_info (const int display_pixels_wide, const int display_pixels_high, const float display_meters_wide, const float display_meters_high, const float lens_separation, const float meters_per_tan_angle, const float aberration, hmd_info_t &amp; hmd_info)  void get_default_hmd_info (const int display_pixels_wide, const int display_pixels_high, const float display_meters_wide, const float display_meters_high, const float lens_separation, const float meters_per_tan_angle, const float aberration, hmd_info_t &amp; hmd_info)  float max_float (float x, float y)  float max_float (float x, float y)  float min_float (float x, float y)  float min_float (float x, float y)"},{"location":"api/classHMD/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classHMD/#variable-num_color_channels","title":"variable NUM_COLOR_CHANNELS","text":"<pre><code>static constexpr int HMD::NUM_COLOR_CHANNELS;\n</code></pre>"},{"location":"api/classHMD/#variable-num_eyes","title":"variable NUM_EYES","text":"<pre><code>static constexpr int HMD::NUM_EYES;\n</code></pre>"},{"location":"api/classHMD/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classHMD/#function-build_distortion_meshes-12","title":"function build_distortion_meshes [1/2]","text":"<pre><code>static void HMD::build_distortion_meshes (\n    std::array&lt; std::array&lt; std::vector&lt; mesh_coord2d_t &gt;, NUM_COLOR_CHANNELS &gt;, NUM_EYES &gt; &amp; distort_coords,\n    hmd_info_t &amp; hmd_info\n) \n</code></pre>"},{"location":"api/classHMD/#function-build_distortion_meshes-22","title":"function build_distortion_meshes [2/2]","text":"<pre><code>static void HMD::build_distortion_meshes (\n    std::array&lt; std::array&lt; std::vector&lt; mesh_coord2d_t &gt;, NUM_COLOR_CHANNELS &gt;, NUM_EYES &gt; &amp; distort_coords,\n    hmd_info_t &amp; hmd_info\n) \n</code></pre>"},{"location":"api/classHMD/#function-evaluate_catmull_rom_spline-12","title":"function evaluate_catmull_rom_spline [1/2]","text":"<pre><code>static float HMD::evaluate_catmull_rom_spline (\n    float value,\n    const float * K,\n    int num_knots\n) \n</code></pre>"},{"location":"api/classHMD/#function-evaluate_catmull_rom_spline-22","title":"function evaluate_catmull_rom_spline [2/2]","text":"<pre><code>static float HMD::evaluate_catmull_rom_spline (\n    float value,\n    const float * K,\n    int num_knots\n) \n</code></pre>"},{"location":"api/classHMD/#function-get_default_hmd_info-12","title":"function get_default_hmd_info [1/2]","text":"<pre><code>static void HMD::get_default_hmd_info (\n    const int display_pixels_wide,\n    const int display_pixels_high,\n    const float display_meters_wide,\n    const float display_meters_high,\n    const float lens_separation,\n    const float meters_per_tan_angle,\n    const float aberration,\n    hmd_info_t &amp; hmd_info\n) \n</code></pre>"},{"location":"api/classHMD/#function-get_default_hmd_info-22","title":"function get_default_hmd_info [2/2]","text":"<pre><code>static void HMD::get_default_hmd_info (\n    const int display_pixels_wide,\n    const int display_pixels_high,\n    const float display_meters_wide,\n    const float display_meters_high,\n    const float lens_separation,\n    const float meters_per_tan_angle,\n    const float aberration,\n    hmd_info_t &amp; hmd_info\n) \n</code></pre>"},{"location":"api/classHMD/#function-max_float-12","title":"function max_float [1/2]","text":"<pre><code>static float HMD::max_float (\n    float x,\n    float y\n) \n</code></pre>"},{"location":"api/classHMD/#function-max_float-22","title":"function max_float [2/2]","text":"<pre><code>static float HMD::max_float (\n    float x,\n    float y\n) \n</code></pre>"},{"location":"api/classHMD/#function-min_float-12","title":"function min_float [1/2]","text":"<pre><code>static float HMD::min_float (\n    float x,\n    float y\n) \n</code></pre>"},{"location":"api/classHMD/#function-min_float-22","title":"function min_float [2/2]","text":"<pre><code>static float HMD::min_float (\n    float x,\n    float y\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/hmd.hpp</code></p>"},{"location":"api/classILLIXR_1_1cancellable__sleep/","title":"Class ILLIXR::cancellable_sleep","text":"<p>ClassList &gt; ILLIXR &gt; cancellable_sleep</p>"},{"location":"api/classILLIXR_1_1cancellable__sleep/#public-functions","title":"Public Functions","text":"Type Name void cancel ()  bool sleep (std::chrono::duration&lt; T, R &gt; duration)"},{"location":"api/classILLIXR_1_1cancellable__sleep/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1cancellable__sleep/#function-cancel","title":"function cancel","text":"<pre><code>inline void ILLIXR::cancellable_sleep::cancel () \n</code></pre>"},{"location":"api/classILLIXR_1_1cancellable__sleep/#function-sleep","title":"function sleep","text":"<pre><code>template&lt;typename T, typename R&gt;\ninline bool ILLIXR::cancellable_sleep::sleep (\n    std::chrono::duration&lt; T, R &gt; duration\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/illixr.hpp</code></p>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/","title":"Class ILLIXR::data_format::pose_prediction","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; pose_prediction</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p> <p>Inherited by the following classes: ILLIXR::fauxpose_impl,  ILLIXR::offload_rendering_server,  ILLIXR::pose_lookup_impl,  ILLIXR::pose_prediction_impl</p>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#public-functions","title":"Public Functions","text":"Type Name virtual pose_type correct_pose (const pose_type &amp; pose) const = 0 virtual bool fast_pose_reliable () const = 0 virtual fast_pose_type get_fast_pose () const = 0 virtual fast_pose_type get_fast_pose (time_point future_time) const = 0 virtual Eigen::Quaternionf get_offset () = 0 virtual pose_type get_true_pose () const = 0 virtual void set_offset (const Eigen::Quaternionf &amp; orientation) = 0 virtual bool true_pose_reliable () const = 0 ~pose_prediction () override"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#protected-functions","title":"Protected Functions","text":"Type Name pose_type _correct_pose (const pose_type &amp; pose) const void _set_offset (const Eigen::Quaternionf &amp; orientation)"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-correct_pose","title":"function correct_pose","text":"<pre><code>virtual pose_type ILLIXR::data_format::pose_prediction::correct_pose (\n    const pose_type &amp; pose\n) const = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<pre><code>virtual bool ILLIXR::data_format::pose_prediction::fast_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-get_fast_pose-12","title":"function get_fast_pose [1/2]","text":"<pre><code>virtual fast_pose_type ILLIXR::data_format::pose_prediction::get_fast_pose () const = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-get_fast_pose-22","title":"function get_fast_pose [2/2]","text":"<pre><code>virtual fast_pose_type ILLIXR::data_format::pose_prediction::get_fast_pose (\n    time_point future_time\n) const = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-get_offset","title":"function get_offset","text":"<pre><code>virtual Eigen::Quaternionf ILLIXR::data_format::pose_prediction::get_offset () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-get_true_pose","title":"function get_true_pose","text":"<pre><code>virtual pose_type ILLIXR::data_format::pose_prediction::get_true_pose () const = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-set_offset","title":"function set_offset","text":"<pre><code>virtual void ILLIXR::data_format::pose_prediction::set_offset (\n    const Eigen::Quaternionf &amp; orientation\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<pre><code>virtual bool ILLIXR::data_format::pose_prediction::true_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-pose_prediction","title":"function ~pose_prediction","text":"<pre><code>ILLIXR::data_format::pose_prediction::~pose_prediction () override\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-_correct_pose","title":"function _correct_pose","text":"<pre><code>inline pose_type ILLIXR::data_format::pose_prediction::_correct_pose (\n    const pose_type &amp; pose\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1pose__prediction/#function-_set_offset","title":"function _set_offset","text":"<pre><code>inline void ILLIXR::data_format::pose_prediction::_set_offset (\n    const Eigen::Quaternionf &amp; orientation\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose_prediction.hpp</code></p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/","title":"Class ILLIXR::data_format::proper_quaternion","text":"<p>template &lt;typename Scalar_, int Options_&gt;</p> <p>ClassList &gt; ILLIXR &gt; data_format &gt; proper_quaternion</p> <p>A more complete implementation of the Eigen::Quaternion. More...</p> <ul> <li><code>#include &lt;proper_quaternion.hpp&gt;</code></li> </ul> <p>Inherits the following classes: Eigen::Quaternion&lt; Scalar_, Eigen::AutoAlign &gt;</p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#public-types","title":"Public Types","text":"Type Name typedef Eigen::Quaternion&lt; Scalar_ &gt;::Base Base"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#public-functions","title":"Public Functions","text":"Type Name Eigen::Matrix&lt; Scalar_, 4, 1 &gt; asVector () constConvert theis object into a 4-element vector, with the order x, y, z, w. proper_quaternion&lt; T &gt; cast () Cast a ProperQuaternion from one type to another. void normalize () Normalize the quaternion, but check w first, as it needs to be positive for our conventions. proper_quaternion operator* (const int a) constInteger multiplication, returning a new instance. proper_quaternion operator* (const float a) constFloat multiplication, returning a new instance. proper_quaternion operator* (const double a) constDouble multiplication, returning a new instance. proper_quaternion&lt; Scalar_ &gt; operator* (const Eigen::Quaternion&lt; Scalar_ &gt; &amp; other) constMultiplication operator with and Eigen::Quaternion. proper_quaternion &amp; operator*= (const Scalar_ &amp; a) Scalar multiplication and assignment operator. proper_quaternion&lt; Scalar_ &gt; operator+ (const proper_quaternion&lt; Scalar_ &gt; &amp; other) constAddition operator with another ProperQuaternion. proper_quaternion&lt; Scalar_ &gt; &amp; operator+= (const proper_quaternion&lt; Scalar_ &gt; &amp; other) In place addition operator with another ProperQuaternion. proper_quaternion &amp; operator= (const proper_quaternion &amp; other) Copy operator. proper_quaternion () = default proper_quaternion (const proper_quaternion &amp; other) = default proper_quaternion (const Eigen::Quaternion&lt; Scalar_, Options_ &gt; &amp; other)  proper_quaternion (const Scalar_ &amp; w, const Scalar_ &amp; x, const Scalar_ &amp; y, const Scalar_ &amp; z)  proper_quaternion (const Scalar_ &amp; w, const Eigen::MatrixBase&lt; Derived &gt; &amp; vec)  proper_quaternion (const Scalar_ * data)  proper_quaternion (const Eigen::Matrix&lt; Scalar_, 4, 1 &gt; &amp; vec)  proper_quaternion (const Eigen::QuaternionBase&lt; Derived &gt; &amp; other)"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#detailed-description","title":"Detailed Description","text":"<p>The base class, Eigen::Quaternion, is missing some arithmetic functionality, like scalar multiplication, this implementation adds this functionality.</p> <p>Template parameters:</p> <ul> <li><code>Scalar_</code> The type of data the Quaternion holds (typically double ot float) </li> <li><code>Options_</code> Data alignment </li> </ul>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#typedef-base","title":"typedef Base","text":"<pre><code>typedef Eigen::Quaternion&lt;Scalar_&gt;::Base ILLIXR::data_format::proper_quaternion&lt; Scalar_, Options_ &gt;::Base;\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-asvector","title":"function asVector","text":"<p>Convert theis object into a 4-element vector, with the order x, y, z, w. <pre><code>inline Eigen::Matrix&lt; Scalar_, 4, 1 &gt; ILLIXR::data_format::proper_quaternion::asVector () const\n</code></pre></p> <p>Returns:</p> <p>The vector representing this instance. </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-cast","title":"function cast","text":"<p>Cast a ProperQuaternion from one type to another. <pre><code>template&lt;typename T&gt;\ninline proper_quaternion &lt; T &gt; ILLIXR::data_format::proper_quaternion::cast () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Returns:</p> <p>The new ProperQuaternion instance of the correct type </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-normalize","title":"function normalize","text":"<p>Normalize the quaternion, but check w first, as it needs to be positive for our conventions. <pre><code>inline void ILLIXR::data_format::proper_quaternion::normalize () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator","title":"function operator*","text":"<p>Integer multiplication, returning a new instance. <pre><code>inline proper_quaternion ILLIXR::data_format::proper_quaternion::operator* (\n    const int a\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> Integer to multiply the quaternion by </li> </ul> <p>Returns:</p> <p>New instance containing the result </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator_1","title":"function operator*","text":"<p>Float multiplication, returning a new instance. <pre><code>inline proper_quaternion ILLIXR::data_format::proper_quaternion::operator* (\n    const float a\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> Float to multiply the quaternion by </li> </ul> <p>Returns:</p> <p>New instance containing the result </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator_2","title":"function operator*","text":"<p>Double multiplication, returning a new instance. <pre><code>inline proper_quaternion ILLIXR::data_format::proper_quaternion::operator* (\n    const double a\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> Double to multiply the quaternion by </li> </ul> <p>Returns:</p> <p>New instance containing the result </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator_3","title":"function operator*","text":"<p>Multiplication operator with and Eigen::Quaternion. <pre><code>inline proper_quaternion &lt; Scalar_ &gt; ILLIXR::data_format::proper_quaternion::operator* (\n    const Eigen::Quaternion&lt; Scalar_ &gt; &amp; other\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> The Eigen::Quaternion to multiply by </li> </ul> <p>Returns:</p> <p>The resulting Quaternion </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator_4","title":"function operator*=","text":"<p>Scalar multiplication and assignment operator. <pre><code>inline proper_quaternion &amp; ILLIXR::data_format::proper_quaternion::operator*= (\n    const Scalar_ &amp; a\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> Scalar to multiply the Quaternion by </li> </ul> <p>Returns:</p> <p>Reference to the updated object </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator_5","title":"function operator+","text":"<p>Addition operator with another ProperQuaternion. <pre><code>inline proper_quaternion &lt; Scalar_ &gt; ILLIXR::data_format::proper_quaternion::operator+ (\n    const proper_quaternion &lt; Scalar_ &gt; &amp; other\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> A ProperQuaternion to add to this one </li> </ul> <p>Returns:</p> <p>The resulting ProperQuaternion as a new instance </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator_6","title":"function operator+=","text":"<p>In place addition operator with another ProperQuaternion. <pre><code>inline proper_quaternion &lt; Scalar_ &gt; &amp; ILLIXR::data_format::proper_quaternion::operator+= (\n    const proper_quaternion &lt; Scalar_ &gt; &amp; other\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> A ProperQuaternion to add to this one </li> </ul> <p>Returns:</p> <p>Reference to the updated instance </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-operator_7","title":"function operator=","text":"<p>Copy operator. <pre><code>inline proper_quaternion &amp; ILLIXR::data_format::proper_quaternion::operator= (\n    const proper_quaternion &amp; other\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> A ProperQuaternion instance </li> </ul> <p>Returns:</p> <p>a copy </p>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-18","title":"function proper_quaternion [1/8]","text":"<pre><code>ILLIXR::data_format::proper_quaternion::proper_quaternion () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-28","title":"function proper_quaternion [2/8]","text":"<pre><code>ILLIXR::data_format::proper_quaternion::proper_quaternion (\n    const proper_quaternion &amp; other\n) = default\n</code></pre>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-38","title":"function proper_quaternion [3/8]","text":"<pre><code>inline explicit ILLIXR::data_format::proper_quaternion::proper_quaternion (\n    const Eigen::Quaternion&lt; Scalar_, Options_ &gt; &amp; other\n) \n</code></pre> <p>Copy constructor from the base class </p> <p>Parameters:</p> <ul> <li><code>other</code> An Eigen::Quaternion instance </li> </ul>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-48","title":"function proper_quaternion [4/8]","text":"<pre><code>inline ILLIXR::data_format::proper_quaternion::proper_quaternion (\n    const Scalar_ &amp; w,\n    const Scalar_ &amp; x,\n    const Scalar_ &amp; y,\n    const Scalar_ &amp; z\n) \n</code></pre> <p>Constructor from individual components </p> <p>Parameters:</p> <ul> <li><code>w</code> The w component </li> <li><code>x</code> The x component </li> <li><code>y</code> The y component </li> <li><code>z</code> The z component </li> </ul>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-58","title":"function proper_quaternion [5/8]","text":"<pre><code>template&lt;typename Derived&gt;\ninline ILLIXR::data_format::proper_quaternion::proper_quaternion (\n    const Scalar_ &amp; w,\n    const Eigen::MatrixBase&lt; Derived &gt; &amp; vec\n) \n</code></pre> <p>Constructor from a scalar and vector </p> <p>Template parameters:</p> <ul> <li><code>Derived</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>w</code> The w component </li> <li><code>vec</code> The x, y, and z components </li> </ul>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-68","title":"function proper_quaternion [6/8]","text":"<pre><code>inline explicit ILLIXR::data_format::proper_quaternion::proper_quaternion (\n    const Scalar_ * data\n) \n</code></pre> <p>Constructor from a pointer array (assumes 4 elements) </p> <p>Parameters:</p> <ul> <li><code>data</code> Pointer to the first element </li> </ul>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-78","title":"function proper_quaternion [7/8]","text":"<pre><code>inline explicit ILLIXR::data_format::proper_quaternion::proper_quaternion (\n    const Eigen::Matrix&lt; Scalar_, 4, 1 &gt; &amp; vec\n) \n</code></pre> <p>Constructor from a vector. Assumes the vector is x, y, z, w order. </p> <p>Parameters:</p> <ul> <li><code>vec</code> The input vector </li> </ul>"},{"location":"api/classILLIXR_1_1data__format_1_1proper__quaternion/#function-proper_quaternion-88","title":"function proper_quaternion [8/8]","text":"<pre><code>template&lt;typename Derived&gt;\ninline explicit ILLIXR::data_format::proper_quaternion::proper_quaternion (\n    const Eigen::QuaternionBase&lt; Derived &gt; &amp; other\n) \n</code></pre> <p>Constructor which casts the data type </p> <p>Template parameters:</p> <ul> <li><code>Derived</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/proper_quaternion.hpp</code></p>"},{"location":"api/classILLIXR_1_1data__injection/","title":"Class ILLIXR::data_injection","text":"<p>ClassList &gt; ILLIXR &gt; data_injection</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1data__injection/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override data_injection (const std::string &amp; name_, phonebook * pb_)  void start () override ~data_injection () override"},{"location":"api/classILLIXR_1_1data__injection/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1data__injection/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1data__injection/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1data__injection/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1data__injection/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1data__injection/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1data__injection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__injection/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::data_injection::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1data__injection/#function-data_injection","title":"function data_injection","text":"<pre><code>ILLIXR::data_injection::data_injection (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1data__injection/#function-start","title":"function start","text":"<pre><code>void ILLIXR::data_injection::start () override\n</code></pre>"},{"location":"api/classILLIXR_1_1data__injection/#function-data_injection_1","title":"function ~data_injection","text":"<pre><code>ILLIXR::data_injection::~data_injection () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/data_injection/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1data__use__indicator/","title":"Class ILLIXR::data_use_indicator","text":"<p>ClassList &gt; ILLIXR &gt; data_use_indicator</p> <p>A helper class that lets one dynamically determine if some data gets used. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions","title":"Public Functions","text":"Type Name data_use_indicator ()  data_use_indicator (const data_use_indicator &amp; other)  bool is_used () const void mark_unused () const void mark_used () const data_use_indicator &amp; operator= (const data_use_indicator &amp; other)"},{"location":"api/classILLIXR_1_1data__use__indicator/#detailed-description","title":"Detailed Description","text":"<p>When a data_use_indicator gets copied, the original is considered used and the new one is considered unused. </p>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-12","title":"function data_use_indicator [1/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator () \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-22","title":"function data_use_indicator [2/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator (\n    const data_use_indicator &amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-is_used","title":"function is_used","text":"<pre><code>inline bool ILLIXR::data_use_indicator::is_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_unused","title":"function mark_unused","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_unused () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-operator","title":"function operator=","text":"<pre><code>inline data_use_indicator &amp; ILLIXR::data_use_indicator::operator= (\n    const data_use_indicator &amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1debugview/","title":"Class ILLIXR::debugview","text":"<p>ClassList &gt; ILLIXR &gt; debugview</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1debugview/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override void _p_thread_setup () override debugview (const std::string &amp; name, phonebook * pb)  void draw_GUI ()  bool load_camera_images ()  bool load_rgb_depth ()  void start () override ~debugview () override"},{"location":"api/classILLIXR_1_1debugview/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1debugview/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1debugview/#public-static-functions","title":"Public Static Functions","text":"Type Name Eigen::Matrix4f generate_headset_transform (const Eigen::Vector3f &amp; position, const Eigen::Quaternionf &amp; rotation, const Eigen::Vector3f &amp; position_offset)"},{"location":"api/classILLIXR_1_1debugview/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1debugview/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1debugview/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1debugview/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1debugview/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1debugview/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::debugview::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<pre><code>void ILLIXR::debugview::_p_thread_setup () override\n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#function-debugview","title":"function debugview","text":"<pre><code>ILLIXR::debugview::debugview (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#function-draw_gui","title":"function draw_GUI","text":"<pre><code>void ILLIXR::debugview::draw_GUI () \n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#function-load_camera_images","title":"function load_camera_images","text":"<pre><code>bool ILLIXR::debugview::load_camera_images () \n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#function-load_rgb_depth","title":"function load_rgb_depth","text":"<pre><code>bool ILLIXR::debugview::load_rgb_depth () \n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#function-start","title":"function start","text":"<pre><code>void ILLIXR::debugview::start () override\n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#function-debugview_1","title":"function ~debugview","text":"<pre><code>ILLIXR::debugview::~debugview () override\n</code></pre>"},{"location":"api/classILLIXR_1_1debugview/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1debugview/#function-generate_headset_transform","title":"function generate_headset_transform","text":"<pre><code>static Eigen::Matrix4f ILLIXR::debugview::generate_headset_transform (\n    const Eigen::Vector3f &amp; position,\n    const Eigen::Quaternionf &amp; rotation,\n    const Eigen::Vector3f &amp; position_offset\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/debugview/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1depthai/","title":"Class ILLIXR::depthai","text":"<p>ClassList &gt; ILLIXR &gt; depthai</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1depthai/#public-functions","title":"Public Functions","text":"Type Name void callback ()  depthai (const std::string &amp; name, phonebook * pb)  ~depthai () override"},{"location":"api/classILLIXR_1_1depthai/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1depthai/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1depthai/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1depthai/#function-callback","title":"function callback","text":"<pre><code>void ILLIXR::depthai::callback () \n</code></pre>"},{"location":"api/classILLIXR_1_1depthai/#function-depthai","title":"function depthai","text":"<pre><code>ILLIXR::depthai::depthai (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1depthai/#function-depthai_1","title":"function ~depthai","text":"<pre><code>ILLIXR::depthai::~depthai () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/depthai/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/","title":"Class ILLIXR::display::display_backend","text":"<p>ClassList &gt; ILLIXR &gt; display &gt; display_backend</p> <p>Inherited by the following classes: ILLIXR::display::glfw_extended,  ILLIXR::display::headless,  ILLIXR::display::x11_direct</p>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#public-types","title":"Public Types","text":"Type Name enum display_backend_type"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#public-functions","title":"Public Functions","text":"Type Name virtual void cleanup () = 0 virtual VkSurfaceKHR create_surface () = 0 virtual std::set&lt; const char * &gt; get_required_device_extensions () = 0 virtual std::set&lt; const char * &gt; get_required_instance_extensions () = 0 virtual display_backend_type get_type () = 0 virtual void setup_display (const std::shared_ptr&lt; switchboard &gt; sb, VkInstance vk_instance, VkPhysicalDevice vk_physical_device) = 0"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#protected-attributes","title":"Protected Attributes","text":"Type Name VkInstance vk_instance_"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1display__backend/#enum-display_backend_type","title":"enum display_backend_type","text":"<pre><code>enum ILLIXR::display::display_backend::display_backend_type {\n    GLFW,\n    X11_DIRECT,\n    HEADLESS\n};\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1display__backend/#function-cleanup","title":"function cleanup","text":"<pre><code>virtual void ILLIXR::display::display_backend::cleanup () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#function-create_surface","title":"function create_surface","text":"<pre><code>virtual VkSurfaceKHR ILLIXR::display::display_backend::create_surface () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#function-get_required_device_extensions","title":"function get_required_device_extensions","text":"<pre><code>virtual std::set&lt; const char * &gt; ILLIXR::display::display_backend::get_required_device_extensions () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#function-get_required_instance_extensions","title":"function get_required_instance_extensions","text":"<pre><code>virtual std::set&lt; const char * &gt; ILLIXR::display::display_backend::get_required_instance_extensions () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#function-get_type","title":"function get_type","text":"<pre><code>virtual display_backend_type ILLIXR::display::display_backend::get_type () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#function-setup_display","title":"function setup_display","text":"<pre><code>virtual void ILLIXR::display::display_backend::setup_display (\n    const std::shared_ptr&lt; switchboard &gt; sb,\n    VkInstance vk_instance,\n    VkPhysicalDevice vk_physical_device\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1display__backend/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1display__backend/#variable-vk_instance_","title":"variable vk_instance_","text":"<pre><code>VkInstance ILLIXR::display::display_backend::vk_instance_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/display_backend.hpp</code></p>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/","title":"Class ILLIXR::display::glfw_extended","text":"<p>ClassList &gt; ILLIXR &gt; display &gt; glfw_extended</p> <p>Inherits the following classes: ILLIXR::display::display_backend</p>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#public-functions","title":"Public Functions","text":"Type Name void cleanup () override std::pair&lt; uint32_t, uint32_t &gt; get_framebuffer_size ()  std::set&lt; const char * &gt; get_required_device_extensions () override std::set&lt; const char * &gt; get_required_instance_extensions () override display_backend_type get_type () override glfw_extended ()  void setup_display (const std::shared_ptr&lt; switchboard &gt; sb, VkInstance vk_instance, VkPhysicalDevice vk_physical_device) overrideSets up the GLFW environment."},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#public-static-functions","title":"Public Static Functions","text":"Type Name void poll_window_events ()"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-cleanup","title":"function cleanup","text":"<pre><code>void ILLIXR::display::glfw_extended::cleanup () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-get_framebuffer_size","title":"function get_framebuffer_size","text":"<pre><code>std::pair&lt; uint32_t, uint32_t &gt; ILLIXR::display::glfw_extended::get_framebuffer_size () \n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-get_required_device_extensions","title":"function get_required_device_extensions","text":"<pre><code>std::set&lt; const char * &gt; ILLIXR::display::glfw_extended::get_required_device_extensions () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-get_required_instance_extensions","title":"function get_required_instance_extensions","text":"<pre><code>std::set&lt; const char * &gt; ILLIXR::display::glfw_extended::get_required_instance_extensions () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-get_type","title":"function get_type","text":"<pre><code>display_backend_type ILLIXR::display::glfw_extended::get_type () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-glfw_extended","title":"function glfw_extended","text":"<pre><code>ILLIXR::display::glfw_extended::glfw_extended () \n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-setup_display","title":"function setup_display","text":"<p>Sets up the GLFW environment. <pre><code>void ILLIXR::display::glfw_extended::setup_display (\n    const std::shared_ptr&lt; switchboard &gt; sb,\n    VkInstance vk_instance,\n    VkPhysicalDevice vk_physical_device\n) override\n</code></pre></p> <p>This function initializes the GLFW library, sets the window hints for the client API and resizability, and creates a GLFW window with the specified width and height.</p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If GLFW initialization fails. </li> </ul>"},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1glfw__extended/#function-poll_window_events","title":"function poll_window_events","text":"<pre><code>static void ILLIXR::display::glfw_extended::poll_window_events () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/glfw_extended.hpp</code></p>"},{"location":"api/classILLIXR_1_1display_1_1headless/","title":"Class ILLIXR::display::headless","text":"<p>ClassList &gt; ILLIXR &gt; display &gt; headless</p> <p>Inherits the following classes: ILLIXR::display::display_backend</p>"},{"location":"api/classILLIXR_1_1display_1_1headless/#public-functions","title":"Public Functions","text":"Type Name void cleanup () override VkSurfaceKHR create_surface () override std::set&lt; const char * &gt; get_required_device_extensions () override std::set&lt; const char * &gt; get_required_instance_extensions () override display_backend_type get_type () override void setup_display (const std::shared_ptr&lt; switchboard &gt; sb, VkInstance vk_instance, VkPhysicalDevice vk_physical_device) override"},{"location":"api/classILLIXR_1_1display_1_1headless/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1headless/#function-cleanup","title":"function cleanup","text":"<pre><code>void ILLIXR::display::headless::cleanup () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1headless/#function-create_surface","title":"function create_surface","text":"<pre><code>VkSurfaceKHR ILLIXR::display::headless::create_surface () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1headless/#function-get_required_device_extensions","title":"function get_required_device_extensions","text":"<pre><code>std::set&lt; const char * &gt; ILLIXR::display::headless::get_required_device_extensions () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1headless/#function-get_required_instance_extensions","title":"function get_required_instance_extensions","text":"<pre><code>std::set&lt; const char * &gt; ILLIXR::display::headless::get_required_instance_extensions () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1headless/#function-get_type","title":"function get_type","text":"<pre><code>display_backend_type ILLIXR::display::headless::get_type () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1headless/#function-setup_display","title":"function setup_display","text":"<pre><code>void ILLIXR::display::headless::setup_display (\n    const std::shared_ptr&lt; switchboard &gt; sb,\n    VkInstance vk_instance,\n    VkPhysicalDevice vk_physical_device\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/headless.hpp</code></p>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/","title":"Class ILLIXR::display::x11_direct","text":"<p>ClassList &gt; ILLIXR &gt; display &gt; x11_direct</p> <p>Inherits the following classes: ILLIXR::display::display_backend</p>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#public-attributes","title":"Public Attributes","text":"Type Name VkDisplayKHR display_ std::atomic&lt; bool &gt; display_timings_event_registered_   = <code>false</code> VkDisplayModePropertiesKHR selected_mode_ VkDevice vk_device_"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#public-functions","title":"Public Functions","text":"Type Name void cleanup () override VkSurfaceKHR create_surface () override std::set&lt; const char * &gt; get_required_device_extensions () override std::set&lt; const char * &gt; get_required_instance_extensions () override display_backend_type get_type () override bool register_display_timings_event (VkDevice vk_device_)  void setup_display (const std::shared_ptr&lt; switchboard &gt; sb, VkInstance vk_instance, VkPhysicalDevice vk_physical_device_) override void tick ()  x11_direct (std::shared_ptr&lt; relative_clock &gt; _rc, switchboard::writer&lt; switchboard::event_wrapper&lt; time_point &gt; &gt; _vsync_topic)"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#public-static-functions","title":"Public Static Functions","text":"Type Name VkDisplayModePropertiesKHR select_display_mode (std::vector&lt; VkDisplayModePropertiesKHR &gt; modes)"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#variable-display_","title":"variable display_","text":"<pre><code>VkDisplayKHR ILLIXR::display::x11_direct::display_;\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#variable-display_timings_event_registered_","title":"variable display_timings_event_registered_","text":"<pre><code>std::atomic&lt;bool&gt; ILLIXR::display::x11_direct::display_timings_event_registered_;\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#variable-selected_mode_","title":"variable selected_mode_","text":"<pre><code>VkDisplayModePropertiesKHR ILLIXR::display::x11_direct::selected_mode_;\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#variable-vk_device_","title":"variable vk_device_","text":"<pre><code>VkDevice ILLIXR::display::x11_direct::vk_device_;\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-cleanup","title":"function cleanup","text":"<pre><code>void ILLIXR::display::x11_direct::cleanup () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-create_surface","title":"function create_surface","text":"<pre><code>VkSurfaceKHR ILLIXR::display::x11_direct::create_surface () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-get_required_device_extensions","title":"function get_required_device_extensions","text":"<pre><code>std::set&lt; const char * &gt; ILLIXR::display::x11_direct::get_required_device_extensions () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-get_required_instance_extensions","title":"function get_required_instance_extensions","text":"<pre><code>std::set&lt; const char * &gt; ILLIXR::display::x11_direct::get_required_instance_extensions () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-get_type","title":"function get_type","text":"<pre><code>display_backend_type ILLIXR::display::x11_direct::get_type () override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-register_display_timings_event","title":"function register_display_timings_event","text":"<pre><code>bool ILLIXR::display::x11_direct::register_display_timings_event (\n    VkDevice vk_device_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-setup_display","title":"function setup_display","text":"<pre><code>void ILLIXR::display::x11_direct::setup_display (\n    const std::shared_ptr&lt; switchboard &gt; sb,\n    VkInstance vk_instance,\n    VkPhysicalDevice vk_physical_device_\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-tick","title":"function tick","text":"<pre><code>void ILLIXR::display::x11_direct::tick () \n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-x11_direct","title":"function x11_direct","text":"<pre><code>inline ILLIXR::display::x11_direct::x11_direct (\n    std::shared_ptr&lt; relative_clock &gt; _rc,\n    switchboard::writer &lt; switchboard::event_wrapper &lt; time_point &gt; &gt; _vsync_topic\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1display_1_1x11__direct/#function-select_display_mode","title":"function select_display_mode","text":"<pre><code>static VkDisplayModePropertiesKHR ILLIXR::display::x11_direct::select_display_mode (\n    std::vector&lt; VkDisplayModePropertiesKHR &gt; modes\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/x11_direct.hpp</code></p>"},{"location":"api/classILLIXR_1_1dynamic__lib/","title":"Class ILLIXR::dynamic_lib","text":"<p>ClassList &gt; ILLIXR &gt; dynamic_lib</p>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions","title":"Public Functions","text":"Type Name dynamic_lib (dynamic_lib &amp;&amp; other) noexcept T get (const std::string &amp; symbol_name) const dynamic_lib &amp; operator= (dynamic_lib &amp;&amp; other) noexcept const void * operator[] (const std::string &amp; symbol_name) const ~dynamic_lib ()"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions","title":"Public Static Functions","text":"Type Name dynamic_lib create (const std::string &amp; path)  dynamic_lib create (const std::string_view &amp; path)"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-dynamic_lib-12","title":"function dynamic_lib [1/2]","text":"<pre><code>inline ILLIXR::dynamic_lib::dynamic_lib (\n    dynamic_lib &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-get","title":"function get","text":"<pre><code>template&lt;typename T&gt;\ninline T ILLIXR::dynamic_lib::get (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator","title":"function operator=","text":"<pre><code>inline dynamic_lib &amp; ILLIXR::dynamic_lib::operator= (\n    dynamic_lib &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const void * ILLIXR::dynamic_lib::operator[] (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-dynamic_lib","title":"function ~dynamic_lib","text":"<pre><code>inline ILLIXR::dynamic_lib::~dynamic_lib () \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-create-12","title":"function create [1/2]","text":"<pre><code>static inline dynamic_lib ILLIXR::dynamic_lib::create (\n    const std::string &amp; path\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-create-22","title":"function create [2/2]","text":"<pre><code>static inline dynamic_lib ILLIXR::dynamic_lib::create (\n    const std::string_view &amp; path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/dynamic_lib.hpp</code></p>"},{"location":"api/classILLIXR_1_1event/","title":"Class ILLIXR::event","text":"<p>ClassList &gt; ILLIXR &gt; event</p> <p>A boolean condition-variable. More...</p> <ul> <li><code>#include &lt;stoplight.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1event/#public-functions","title":"Public Functions","text":"Type Name void clear () Clears the condition-variable. bool is_set () constTest if is set without blocking. void set (bool new_value=true) Sets the condition-variable to new_value. void wait () constWait indefinitely for the event to be set. bool wait_timeout (const std::chrono::duration&lt; Rep, Period &gt; &amp; duration) constWait for the event to be set with a timeout."},{"location":"api/classILLIXR_1_1event/#detailed-description","title":"Detailed Description","text":"<p>Inspired by https://docs.python.org/3/library/threading.html#event-objects </p>"},{"location":"api/classILLIXR_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1event/#function-clear","title":"function clear","text":"<p>Clears the condition-variable. <pre><code>inline void ILLIXR::event::clear () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1event/#function-is_set","title":"function is_set","text":"<p>Test if is set without blocking. <pre><code>inline bool ILLIXR::event::is_set () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1event/#function-set","title":"function set","text":"<p>Sets the condition-variable to new_value. <pre><code>inline void ILLIXR::event::set (\n    bool new_value=true\n) \n</code></pre></p> <p>Defaults to true, so that set() sets the bool. </p>"},{"location":"api/classILLIXR_1_1event/#function-wait","title":"function wait","text":"<p>Wait indefinitely for the event to be set. <pre><code>inline void ILLIXR::event::wait () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1event/#function-wait_timeout","title":"function wait_timeout","text":"<p>Wait for the event to be set with a timeout. <pre><code>template&lt;class Clock, class Rep, class Period&gt;\ninline bool ILLIXR::event::wait_timeout (\n    const std::chrono::duration&lt; Rep, Period &gt; &amp; duration\n) const\n</code></pre></p> <p>Returns whether the event was actually set. </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/stoplight.hpp</code></p>"},{"location":"api/classILLIXR_1_1fauxpose/","title":"Class ILLIXR::fauxpose","text":"<p>ClassList &gt; ILLIXR &gt; fauxpose</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1fauxpose/#public-functions","title":"Public Functions","text":"Type Name fauxpose (const std::string &amp; name, phonebook * pb)  ~fauxpose () override"},{"location":"api/classILLIXR_1_1fauxpose/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1fauxpose/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1fauxpose/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1fauxpose/#function-fauxpose","title":"function fauxpose","text":"<pre><code>ILLIXR::fauxpose::fauxpose (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose/#function-fauxpose_1","title":"function ~fauxpose","text":"<pre><code>ILLIXR::fauxpose::~fauxpose () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/fauxpose/service.hpp</code></p>"},{"location":"api/classILLIXR_1_1fauxpose__impl/","title":"Class ILLIXR::fauxpose_impl","text":"<p>ClassList &gt; ILLIXR &gt; fauxpose_impl</p> <p>Create a \"pose_prediction\" type service. </p> <ul> <li><code>#include &lt;service.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::pose_prediction</p>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#public-functions","title":"Public Functions","text":"Type Name data_format::pose_type correct_pose (const data_format::pose_type &amp; pose) override const bool fast_pose_reliable () override const fauxpose_impl (const phonebook * pb)  data_format::fast_pose_type get_fast_pose () override const data_format::fast_pose_type get_fast_pose (time_point time) override const Eigen::Quaternionf get_offset () override data_format::pose_type get_true_pose () override const void set_offset (const Eigen::Quaternionf &amp; raw_o_times_offset) override bool true_pose_reliable () override const ~fauxpose_impl () override"},{"location":"api/classILLIXR_1_1fauxpose__impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-correct_pose","title":"function correct_pose","text":"<pre><code>data_format::pose_type ILLIXR::fauxpose_impl::correct_pose (\n    const data_format::pose_type &amp; pose\n) override const\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<pre><code>inline bool ILLIXR::fauxpose_impl::fast_pose_reliable () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-fauxpose_impl","title":"function fauxpose_impl","text":"<pre><code>explicit ILLIXR::fauxpose_impl::fauxpose_impl (\n    const phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-get_fast_pose-12","title":"function get_fast_pose [1/2]","text":"<pre><code>data_format::fast_pose_type ILLIXR::fauxpose_impl::get_fast_pose () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-get_fast_pose-22","title":"function get_fast_pose [2/2]","text":"<pre><code>data_format::fast_pose_type ILLIXR::fauxpose_impl::get_fast_pose (\n    time_point time\n) override const\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-get_offset","title":"function get_offset","text":"<pre><code>Eigen::Quaternionf ILLIXR::fauxpose_impl::get_offset () override\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-get_true_pose","title":"function get_true_pose","text":"<pre><code>inline data_format::pose_type ILLIXR::fauxpose_impl::get_true_pose () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-set_offset","title":"function set_offset","text":"<pre><code>void ILLIXR::fauxpose_impl::set_offset (\n    const Eigen::Quaternionf &amp; raw_o_times_offset\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<pre><code>inline bool ILLIXR::fauxpose_impl::true_pose_reliable () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1fauxpose__impl/#function-fauxpose_impl_1","title":"function ~fauxpose_impl","text":"<pre><code>ILLIXR::fauxpose_impl::~fauxpose_impl () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/fauxpose/service.hpp</code></p>"},{"location":"api/classILLIXR_1_1gen__guid/","title":"Class ILLIXR::gen_guid","text":"<p>ClassList &gt; ILLIXR &gt; gen_guid</p> <p>This class generates unique IDs. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions","title":"Public Functions","text":"Type Name std::size_t get (std::size_t namespace_=0, std::size_t sub_namespace=0, std::size_t sub_sub_namespace=0) Generate a number, unique from other calls to the same namespace/sub-namespace/sub-sub-namespace."},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1gen__guid/#detailed-description","title":"Detailed Description","text":"<p>If you need unique IDs (e.g. for each component), have each component call this class through Phonebook. It returns unique IDs.</p> <p>You can use namespaces to express logical containment. The return value will be unique between other <code>get</code> calls to the same namespace. This is useful for components and sub-components. For example, If component with id_ 0 has 3 subcomponents, one might call get(0) to name_ each of them. Then, suppose component with id_ 1 has 2 subcomponents, one might call get(1) twice to name_ those. The subcomponent IDs could be reused (non-unique), but tuple (component id_, subcomponent id_) will still be unique. You can also just use the global namespace for everything, if you do not care about generating small integers for the IDs. </p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1gen__guid/#function-get","title":"function get","text":"<p>Generate a number, unique from other calls to the same namespace/sub-namespace/sub-sub-namespace. <pre><code>inline std::size_t ILLIXR::gen_guid::get (\n    std::size_t namespace_=0,\n    std::size_t sub_namespace=0,\n    std::size_t sub_sub_namespace=0\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1gldemo/","title":"Class ILLIXR::gldemo","text":"<p>ClassList &gt; ILLIXR &gt; gldemo</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1gldemo/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override void _p_thread_setup () override gldemo (const std::string &amp; name, phonebook * pb)  void start () override void wait_vsync ()"},{"location":"api/classILLIXR_1_1gldemo/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1gldemo/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1gldemo/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1gldemo/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1gldemo/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1gldemo/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1gldemo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1gldemo/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::gldemo::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1gldemo/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<pre><code>void ILLIXR::gldemo::_p_thread_setup () override\n</code></pre>"},{"location":"api/classILLIXR_1_1gldemo/#function-gldemo","title":"function gldemo","text":"<pre><code>ILLIXR::gldemo::gldemo (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1gldemo/#function-start","title":"function start","text":"<pre><code>void ILLIXR::gldemo::start () override\n</code></pre>"},{"location":"api/classILLIXR_1_1gldemo/#function-wait_vsync","title":"function wait_vsync","text":"<pre><code>void ILLIXR::gldemo::wait_vsync () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1ground__truth__slam/","title":"Class ILLIXR::ground_truth_slam","text":"<p>ClassList &gt; ILLIXR &gt; ground_truth_slam</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1ground__truth__slam/#public-functions","title":"Public Functions","text":"Type Name void feed_ground_truth (const switchboard::ptr&lt; const data_format::imu_type &gt; &amp; datum)  ground_truth_slam (const std::string &amp; name, phonebook * pb)  void start () override"},{"location":"api/classILLIXR_1_1ground__truth__slam/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1ground__truth__slam/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1ground__truth__slam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1ground__truth__slam/#function-feed_ground_truth","title":"function feed_ground_truth","text":"<pre><code>void ILLIXR::ground_truth_slam::feed_ground_truth (\n    const switchboard::ptr &lt; const data_format::imu_type &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1ground__truth__slam/#function-ground_truth_slam","title":"function ground_truth_slam","text":"<pre><code>ILLIXR::ground_truth_slam::ground_truth_slam (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1ground__truth__slam/#function-start","title":"function start","text":"<pre><code>void ILLIXR::ground_truth_slam::start () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/ground_truth_slam/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1gtsam__integrator/","title":"Class ILLIXR::gtsam_integrator","text":"<p>ClassList &gt; ILLIXR &gt; gtsam_integrator</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1gtsam__integrator/#public-functions","title":"Public Functions","text":"Type Name void callback (const switchboard::ptr&lt; const data_format::imu_type &gt; &amp; datum)  gtsam_integrator (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1gtsam__integrator/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1gtsam__integrator/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1gtsam__integrator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1gtsam__integrator/#function-callback","title":"function callback","text":"<pre><code>void ILLIXR::gtsam_integrator::callback (\n    const switchboard::ptr &lt; const data_format::imu_type &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1gtsam__integrator/#function-gtsam_integrator","title":"function gtsam_integrator","text":"<pre><code>ILLIXR::gtsam_integrator::gtsam_integrator (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gtsam_integrator/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/","title":"Class ILLIXR::gtsam_integrator::pim_object","text":"<p>ClassList &gt; pim_object</p> <p>Wrapper object protecting the lifetime of IMU integration inputs and biases. </p>"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#public-functions","title":"Public Functions","text":"Type Name bias_t bias_hat () noexcept const void integrate_measurement (const imu_t &amp; imu_input, const imu_t &amp; imu_input_next) noexcept pim_object (const imu_int_t &amp; imu_int_input)  nav_t predict () noexcept const void reset_integration_and_set_bias (const imu_int_t &amp; imu_int_input) noexcept ~pim_object ()"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#function-bias_hat","title":"function bias_hat","text":"<pre><code>bias_t pim_object::bias_hat () noexcept const\n</code></pre>"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#function-integrate_measurement","title":"function integrate_measurement","text":"<pre><code>void pim_object::integrate_measurement (\n    const imu_t &amp; imu_input,\n    const imu_t &amp; imu_input_next\n) noexcept\n</code></pre>"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#function-pim_object","title":"function pim_object","text":"<pre><code>explicit pim_object::pim_object (\n    const imu_int_t &amp; imu_int_input\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#function-predict","title":"function predict","text":"<pre><code>nav_t pim_object::predict () noexcept const\n</code></pre>"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#function-reset_integration_and_set_bias","title":"function reset_integration_and_set_bias","text":"<pre><code>void pim_object::reset_integration_and_set_bias (\n    const imu_int_t &amp; imu_int_input\n) noexcept\n</code></pre>"},{"location":"api/classILLIXR_1_1gtsam__integrator_1_1pim__object/#function-pim_object_1","title":"function ~pim_object","text":"<pre><code>pim_object::~pim_object () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gtsam_integrator/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1lazy__load__image/","title":"Class ILLIXR::lazy_load_image","text":"<p>ClassList &gt; ILLIXR &gt; lazy_load_image</p>"},{"location":"api/classILLIXR_1_1lazy__load__image/#public-functions","title":"Public Functions","text":"Type Name lazy_load_image () = default lazy_load_image (std::string path)  cv::Mat load () const"},{"location":"api/classILLIXR_1_1lazy__load__image/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1lazy__load__image/#function-lazy_load_image-12","title":"function lazy_load_image [1/2]","text":"<pre><code>ILLIXR::lazy_load_image::lazy_load_image () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1lazy__load__image/#function-lazy_load_image-22","title":"function lazy_load_image [2/2]","text":"<pre><code>inline explicit ILLIXR::lazy_load_image::lazy_load_image (\n    std::string path\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1lazy__load__image/#function-load","title":"function load","text":"<pre><code>inline cv::Mat ILLIXR::lazy_load_image::load () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_cam/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1lighthouse/","title":"Class ILLIXR::lighthouse","text":"<p>ClassList &gt; ILLIXR &gt; lighthouse</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1lighthouse/#public-functions","title":"Public Functions","text":"Type Name lighthouse (const std::string &amp; name_, phonebook * pb_)  void stop () override ~lighthouse () override"},{"location":"api/classILLIXR_1_1lighthouse/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1lighthouse/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1lighthouse/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1lighthouse/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1lighthouse/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1lighthouse/#protected-functions","title":"Protected Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override void _p_thread_setup () override"},{"location":"api/classILLIXR_1_1lighthouse/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1lighthouse/#protected-static-functions","title":"Protected Static Functions","text":"Type Name void process_slow_pose (SurviveObject * so, survive_long_timecode timecode, const SurvivePose * pose)"},{"location":"api/classILLIXR_1_1lighthouse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1lighthouse/#function-lighthouse","title":"function lighthouse","text":"<pre><code>ILLIXR::lighthouse::lighthouse (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1lighthouse/#function-stop","title":"function stop","text":"<pre><code>void ILLIXR::lighthouse::stop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1lighthouse/#function-lighthouse_1","title":"function ~lighthouse","text":"<pre><code>ILLIXR::lighthouse::~lighthouse () override\n</code></pre>"},{"location":"api/classILLIXR_1_1lighthouse/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1lighthouse/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::lighthouse::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1lighthouse/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>inline skip_option ILLIXR::lighthouse::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1lighthouse/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<pre><code>void ILLIXR::lighthouse::_p_thread_setup () override\n</code></pre>"},{"location":"api/classILLIXR_1_1lighthouse/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1lighthouse/#function-process_slow_pose","title":"function process_slow_pose","text":"<pre><code>static void ILLIXR::lighthouse::process_slow_pose (\n    SurviveObject * so,\n    survive_long_timecode timecode,\n    const SurvivePose * pose\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/lighthouse/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1managed__thread/","title":"Class ILLIXR::managed_thread","text":"<p>ClassList &gt; ILLIXR &gt; managed_thread</p> <p>An object that manages a std::thread; it joins and exits when the object gets destructed. </p> <ul> <li><code>#include &lt;managed_thread.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1managed__thread/#public-types","title":"Public Types","text":"Type Name enum state Possible states for a managed_thread ."},{"location":"api/classILLIXR_1_1managed__thread/#public-functions","title":"Public Functions","text":"Type Name state get_state ()  managed_thread () noexceptConstructs a non-startable thread. managed_thread (std::function&lt; void()&gt; body, std::function&lt; void()&gt; on_start=std::function&lt; void()&gt;{}, std::function&lt; void()&gt; on_stop=std::function&lt; void()&gt;{}) noexceptConstructs a startable thread. void start () Moves a managed_thread from startable to running. void stop () Moves a managed_thread from running to stopped. ~managed_thread () noexceptStops a thread, if necessary."},{"location":"api/classILLIXR_1_1managed__thread/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1managed__thread/#enum-state","title":"enum state","text":"<p>Possible states for a managed_thread . <pre><code>enum ILLIXR::managed_thread::state {\n    nonstartable,\n    startable,\n    running,\n    stopped\n};\n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1managed__thread/#function-get_state","title":"function get_state","text":"<pre><code>inline state ILLIXR::managed_thread::get_state () \n</code></pre>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread-12","title":"function managed_thread [1/2]","text":"<p>Constructs a non-startable thread. <pre><code>ILLIXR::managed_thread::managed_thread () noexcept\n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread-22","title":"function managed_thread [2/2]","text":"<p>Constructs a startable thread. <pre><code>inline explicit ILLIXR::managed_thread::managed_thread (\n    std::function&lt; void()&gt; body,\n    std::function&lt; void()&gt; on_start=std::function&lt; void()&gt;{},\n    std::function&lt; void()&gt; on_stop=std::function&lt; void()&gt;{}\n) noexcept\n</code></pre></p> <p><code>on_stop</code> is called once (if present) <code>on_start</code> is called as the thread is joining <code>body</code> is called in a tight loop </p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-start","title":"function start","text":"<p>Moves a managed_thread from startable to running. <pre><code>inline void ILLIXR::managed_thread::start () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-stop","title":"function stop","text":"<p>Moves a managed_thread from running to stopped. <pre><code>inline void ILLIXR::managed_thread::stop () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread","title":"function ~managed_thread","text":"<p>Stops a thread, if necessary. <pre><code>inline ILLIXR::managed_thread::~managed_thread () noexcept\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/managed_thread.hpp</code></p>"},{"location":"api/classILLIXR_1_1native__renderer/","title":"Class ILLIXR::native_renderer","text":"<p>ClassList &gt; ILLIXR &gt; native_renderer</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1native__renderer/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () overrideExecutes one iteration of the plugin's main loop. void _p_thread_setup () overrideSets up the thread for the plugin. native_renderer (const std::string &amp; name, phonebook * pb)  ~native_renderer () override"},{"location":"api/classILLIXR_1_1native__renderer/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1native__renderer/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1native__renderer/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1native__renderer/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1native__renderer/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1native__renderer/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1native__renderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1native__renderer/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Executes one iteration of the plugin's main loop. <pre><code>void ILLIXR::native_renderer::_p_one_iteration () override\n</code></pre></p> <p>This function handles window events, acquires the next image from the swapchain, updates uniforms, records command buffers, submits commands to the graphics queue, and presents the rendered image. It also handles swapchain recreation if necessary and updates the frames per second (FPS) counter.</p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If any Vulkan operation fails. </li> </ul>"},{"location":"api/classILLIXR_1_1native__renderer/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<p>Sets up the thread for the plugin. <pre><code>void ILLIXR::native_renderer::_p_thread_setup () override\n</code></pre></p> <p>This function initializes depth images, offscreen targets, command buffers, sync objects, application and timewarp passes, offscreen and swapchain framebuffers. Then, it initializes application and timewarp with their respective passes. </p>"},{"location":"api/classILLIXR_1_1native__renderer/#function-native_renderer","title":"function native_renderer","text":"<pre><code>ILLIXR::native_renderer::native_renderer (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1native__renderer/#function-native_renderer_1","title":"function ~native_renderer","text":"<pre><code>ILLIXR::native_renderer::~native_renderer () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/native_renderer/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/","title":"Class ILLIXR::network::TCPSocket","text":"<p>ClassList &gt; ILLIXR &gt; network &gt; TCPSocket</p>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#public-functions","title":"Public Functions","text":"Type Name TCPSocket ()  TCPSocket (int fd)  void enable_no_delay () const string local_address () const string peer_address () const string read_data (const size_t limit=BUFFER_SIZE) const int socket_accept () const void socket_bind (const string &amp; ip, int port) const void socket_connect (const string &amp; ip, int port) const void socket_listen (const int backlog=16) const void socket_set_reuseaddr () const void write_data (const string &amp; buffer)  ~TCPSocket ()"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-tcpsocket-12","title":"function TCPSocket [1/2]","text":"<pre><code>inline ILLIXR::network::TCPSocket::TCPSocket () \n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-tcpsocket-22","title":"function TCPSocket [2/2]","text":"<pre><code>inline explicit ILLIXR::network::TCPSocket::TCPSocket (\n    int fd\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-enable_no_delay","title":"function enable_no_delay","text":"<pre><code>inline void ILLIXR::network::TCPSocket::enable_no_delay () const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-local_address","title":"function local_address","text":"<pre><code>inline string ILLIXR::network::TCPSocket::local_address () const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-peer_address","title":"function peer_address","text":"<pre><code>inline string ILLIXR::network::TCPSocket::peer_address () const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-read_data","title":"function read_data","text":"<pre><code>inline string ILLIXR::network::TCPSocket::read_data (\n    const size_t limit=BUFFER_SIZE\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-socket_accept","title":"function socket_accept","text":"<pre><code>inline int ILLIXR::network::TCPSocket::socket_accept () const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-socket_bind","title":"function socket_bind","text":"<pre><code>inline void ILLIXR::network::TCPSocket::socket_bind (\n    const string &amp; ip,\n    int port\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-socket_connect","title":"function socket_connect","text":"<pre><code>inline void ILLIXR::network::TCPSocket::socket_connect (\n    const string &amp; ip,\n    int port\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-socket_listen","title":"function socket_listen","text":"<pre><code>inline void ILLIXR::network::TCPSocket::socket_listen (\n    const int backlog=16\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-socket_set_reuseaddr","title":"function socket_set_reuseaddr","text":"<pre><code>inline void ILLIXR::network::TCPSocket::socket_set_reuseaddr () const\n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-write_data","title":"function write_data","text":"<pre><code>inline void ILLIXR::network::TCPSocket::write_data (\n    const string &amp; buffer\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1network_1_1TCPSocket/#function-tcpsocket","title":"function ~TCPSocket","text":"<pre><code>inline ILLIXR::network::TCPSocket::~TCPSocket () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/tcpsocket.hpp</code></p>"},{"location":"api/classILLIXR_1_1network_1_1network__backend/","title":"Class ILLIXR::network::network_backend","text":"<p>ClassList &gt; ILLIXR &gt; network &gt; network_backend</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p> <p>Inherited by the following classes: ILLIXR::tcp_network_backend</p>"},{"location":"api/classILLIXR_1_1network_1_1network__backend/#public-functions","title":"Public Functions","text":"Type Name virtual bool is_topic_networked (std::string topic_name) = 0 virtual void topic_create (std::string topic_name, topic_config &amp; config) = 0 virtual void topic_send (std::string topic_name, std::string &amp;&amp; message) = 0"},{"location":"api/classILLIXR_1_1network_1_1network__backend/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1network_1_1network__backend/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1network_1_1network__backend/#function-is_topic_networked","title":"function is_topic_networked","text":"<pre><code>virtual bool ILLIXR::network::network_backend::is_topic_networked (\n    std::string topic_name\n) = 0\n</code></pre> <p>Used to query if a topic is networked.</p> <p>The backend should coordinate with the other endpoints to determine if a topic is networked. There are two cases where this should return true: * topic_create has been called with the same topic_name * topic_create has not been called with the same topic_name, but the topic is networked by another endpoint The backend implementation should coordinate with the other endpoints to determine if a topic is networked. </p> <p>Parameters:</p> <ul> <li><code>topic_name</code> The name of the topic. </li> </ul>"},{"location":"api/classILLIXR_1_1network_1_1network__backend/#function-topic_create","title":"function topic_create","text":"<pre><code>virtual void ILLIXR::network::network_backend::topic_create (\n    std::string topic_name,\n    topic_config &amp; config\n) = 0\n</code></pre> <p>Called when a topic is created.</p> <p>The backend must maintain a list of networked topics. This adds a topic to that list. </p> <p>Parameters:</p> <ul> <li><code>topic_name</code> The name of the topic. </li> <li><code>config</code> The configuration of the topic. </li> </ul>"},{"location":"api/classILLIXR_1_1network_1_1network__backend/#function-topic_send","title":"function topic_send","text":"<pre><code>virtual void ILLIXR::network::network_backend::topic_send (\n    std::string topic_name,\n    std::string &amp;&amp; message\n) = 0\n</code></pre> <p>Called when a message is requested to be sent on a topic by a plugin. </p> <p>Parameters:</p> <ul> <li><code>topic_name</code> The name of the topic. </li> <li><code>message</code> The message to send. </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/network_backend.hpp</code></p>"},{"location":"api/classILLIXR_1_1offline__cam/","title":"Class ILLIXR::offline_cam","text":"<p>ClassList &gt; ILLIXR &gt; offline_cam</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1offline__cam/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override offline_cam (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1offline__cam/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1offline__cam/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offline__cam/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1offline__cam/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1offline__cam/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offline__cam/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1offline__cam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offline__cam/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::offline_cam::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1offline__cam/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::offline_cam::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1offline__cam/#function-offline_cam","title":"function offline_cam","text":"<pre><code>ILLIXR::offline_cam::offline_cam (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_cam/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1offline__imu/","title":"Class ILLIXR::offline_imu","text":"<p>ClassList &gt; ILLIXR &gt; offline_imu</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1offline__imu/#public-functions","title":"Public Functions","text":"Type Name offline_imu (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1offline__imu/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1offline__imu/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offline__imu/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1offline__imu/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1offline__imu/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offline__imu/#protected-functions","title":"Protected Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override"},{"location":"api/classILLIXR_1_1offline__imu/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1offline__imu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offline__imu/#function-offline_imu","title":"function offline_imu","text":"<pre><code>ILLIXR::offline_imu::offline_imu (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1offline__imu/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offline__imu/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::offline_imu::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1offline__imu/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::offline_imu::_p_should_skip () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_imu/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1offload__data/","title":"Class ILLIXR::offload_data","text":"<p>ClassList &gt; ILLIXR &gt; offload_data</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1offload__data/#public-functions","title":"Public Functions","text":"Type Name void callback (const switchboard::ptr&lt; const data_format::texture_pose &gt; &amp; datum)  offload_data (const std::string &amp; name, phonebook * pb)  ~offload_data () override"},{"location":"api/classILLIXR_1_1offload__data/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offload__data/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offload__data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__data/#function-callback","title":"function callback","text":"<pre><code>void ILLIXR::offload_data::callback (\n    const switchboard::ptr &lt; const data_format::texture_pose &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1offload__data/#function-offload_data","title":"function offload_data","text":"<pre><code>ILLIXR::offload_data::offload_data (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1offload__data/#function-offload_data_1","title":"function ~offload_data","text":"<pre><code>ILLIXR::offload_data::~offload_data () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_data/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1offload__reader/","title":"Class ILLIXR::offload_reader","text":"<p>ClassList &gt; ILLIXR &gt; offload_reader</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1offload__reader/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override offload_reader (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1offload__reader/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1offload__reader/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offload__reader/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1offload__reader/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1offload__reader/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offload__reader/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1offload__reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__reader/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::offload_reader::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1offload__reader/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::offload_reader::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1offload__reader/#function-offload_reader","title":"function offload_reader","text":"<pre><code>ILLIXR::offload_reader::offload_reader (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_rx/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/","title":"Class ILLIXR::offload_rendering_client","text":"<p>ClassList &gt; ILLIXR &gt; offload_rendering_client</p> <p>Inherits the following classes: ILLIXR::threadloop,  ILLIXR::vulkan::app</p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#public-functions","title":"Public Functions","text":"Type Name void destroy () overrideClean up resources on destruction. bool is_external () overrideIndicates this is an external renderer. offload_rendering_client (const std::string &amp; name, phonebook * pb) Constructor initializes the client with configuration from environment variables. void record_command_buffer (VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) overrideRecord command buffer (no-op in this implementation) void setup (VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool) overrideSet up Vulkan resources and initialize frame buffers. void start () overrideStart the client thread and initialize FFmpeg/CUDA resources. void update_uniforms (const data_format::pose_type &amp; render_pose) overrideUpdate uniforms (no-op in this implementation)"},{"location":"api/classILLIXR_1_1offload__rendering__client/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1offload__rendering__client/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offload__rendering__client/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1offload__rendering__client/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offload__rendering__client/#protected-functions","title":"Protected Functions","text":"Type Name void _p_one_iteration () overrideMain processing loop for frame decoding and display. skip_option _p_should_skip () overrideDetermines if the current iteration should be skipped. void _p_thread_setup () overrideThread setup (no-op in this implementation) void copy_image_to_cpu_and_save_file (AVFrame * frame)  void save_nv12_img_to_png (AVFrame * cuda_frame) const void transition_layout (VkCommandBuffer cmd_buf, AVFrame * frame, VkImageLayout old_layout, VkImageLayout new_layout)"},{"location":"api/classILLIXR_1_1offload__rendering__client/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1offload__rendering__client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-destroy","title":"function destroy","text":"<p>Clean up resources on destruction. <pre><code>void ILLIXR::offload_rendering_client::destroy () override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-is_external","title":"function is_external","text":"<p>Indicates this is an external renderer. <pre><code>inline bool ILLIXR::offload_rendering_client::is_external () override\n</code></pre></p> <p>Returns:</p> <p>true since this is an external renderer </p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-offload_rendering_client","title":"function offload_rendering_client","text":"<p>Constructor initializes the client with configuration from environment variables. <pre><code>ILLIXR::offload_rendering_client::offload_rendering_client (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Plugin name </li> <li><code>pb</code> Phonebook for component lookup </li> </ul>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-record_command_buffer","title":"function record_command_buffer","text":"<p>Record command buffer (no-op in this implementation) <pre><code>inline void ILLIXR::offload_rendering_client::record_command_buffer (\n    VkCommandBuffer commandBuffer,\n    VkFramebuffer framebuffer,\n    int buffer_ind,\n    bool left\n) override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-setup","title":"function setup","text":"<p>Set up Vulkan resources and initialize frame buffers. <pre><code>void ILLIXR::offload_rendering_client::setup (\n    VkRenderPass render_pass,\n    uint32_t subpass,\n    std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>render_pass</code> The Vulkan render pass to use </li> <li><code>subpass</code> The subpass index </li> <li><code>buffer_pool</code> The buffer pool for frame data </li> </ul>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-start","title":"function start","text":"<p>Start the client thread and initialize FFmpeg/CUDA resources. <pre><code>void ILLIXR::offload_rendering_client::start () override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-update_uniforms","title":"function update_uniforms","text":"<p>Update uniforms (no-op in this implementation) <pre><code>inline void ILLIXR::offload_rendering_client::update_uniforms (\n    const data_format::pose_type &amp; render_pose\n) override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Main processing loop for frame decoding and display. <pre><code>void ILLIXR::offload_rendering_client::_p_one_iteration () override\n</code></pre></p> <p>This method: * Sends the latest pose to the server * Receives and decodes encoded frames * Performs color space conversion * Updates display buffers * Tracks performance metrics </p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-_p_should_skip","title":"function _p_should_skip","text":"<p>Determines if the current iteration should be skipped. <pre><code>inline skip_option ILLIXR::offload_rendering_client::_p_should_skip () override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<p>Thread setup (no-op in this implementation) <pre><code>inline void ILLIXR::offload_rendering_client::_p_thread_setup () override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-copy_image_to_cpu_and_save_file","title":"function copy_image_to_cpu_and_save_file","text":"<pre><code>void ILLIXR::offload_rendering_client::copy_image_to_cpu_and_save_file (\n    AVFrame * frame\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-save_nv12_img_to_png","title":"function save_nv12_img_to_png","text":"<pre><code>void ILLIXR::offload_rendering_client::save_nv12_img_to_png (\n    AVFrame * cuda_frame\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1offload__rendering__client/#function-transition_layout","title":"function transition_layout","text":"<pre><code>void ILLIXR::offload_rendering_client::transition_layout (\n    VkCommandBuffer cmd_buf,\n    AVFrame * frame,\n    VkImageLayout old_layout,\n    VkImageLayout new_layout\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/offload_rendering_client.hpp</code></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/","title":"Class ILLIXR::offload_rendering_server","text":"<p>ClassList &gt; ILLIXR &gt; offload_rendering_server</p> <p>Main server implementation for offload rendering. More...</p> <ul> <li><code>#include &lt;offload_rendering_server.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::threadloop,  ILLIXR::vulkan::timewarp,  ILLIXR::data_format::pose_prediction,  std::enable_shared_from_this&lt; plugin &gt;</p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#public-functions","title":"Public Functions","text":"Type Name virtual void _p_thread_setup () overrideGets called at setup time, from the new thread. data_format::pose_type correct_pose (const data_format::pose_type &amp; pose) override constCorrect pose data (no-op in this implementation) void destroy () overrideCleanup resources on destruction. bool fast_pose_reliable () override constCheck if fast pose data is reliable. data_format::fast_pose_type get_fast_pose () override constGet the latest pose for rendering. data_format::fast_pose_type get_fast_pose (time_point future_time) override constGet predicted pose for a future time point (returns current pose) Eigen::Quaternionf get_offset () overrideGet orientation offset (returns identity in this implementation) data_format::pose_type get_true_pose () override constGet the true pose (same as fast pose in this implementation) bool is_external () overrideIndicates this sink does not make use of the rendering pipeline in order for the access masks of the layout transitions to be set properly. offload_rendering_server (const std::string &amp; name, phonebook * pb) Constructor initializes the server with configuration from environment variables. void record_command_buffer (VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) overrideRecord command buffer (no-op in this implementation) void set_offset (const Eigen::Quaternionf &amp; orientation) overrideSet orientation offset (no-op in this implementation) void setup (VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; _buffer_pool, bool input_texture_vulkan_coordinates) overrideSets up the rendering pipeline and encoding resources. virtual void start () overrideA method which Spindle calls when it starts the component. bool true_pose_reliable () override constCheck if true pose data is reliable (always false in this implementation) void update_uniforms (const data_format::pose_type &amp; r_pose) overrideUpdate uniforms (no-op in this implementation)"},{"location":"api/classILLIXR_1_1offload__rendering__server/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1offload__rendering__server/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offload__rendering__server/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1offload__rendering__server/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offload__rendering__server/#protected-functions","title":"Protected Functions","text":"Type Name virtual void _p_one_iteration () overrideMain processing loop for frame encoding and transmission. virtual skip_option _p_should_skip () overrideDetermines if the current iteration should be skipped."},{"location":"api/classILLIXR_1_1offload__rendering__server/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1offload__rendering__server/#detailed-description","title":"Detailed Description","text":"<p>This class handles: * Frame capture from the rendering pipeline * Hardware-accelerated encoding using FFmpeg/CUDA * Network transmission of encoded frames * Pose synchronization with the client </p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<p>Gets called at setup time, from the new thread. <pre><code>virtual void ILLIXR::offload_rendering_server::_p_thread_setup () override\n</code></pre></p> <p>Implements ILLIXR::threadloop::_p_thread_setup</p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-correct_pose","title":"function correct_pose","text":"<p>Correct pose data (no-op in this implementation) <pre><code>inline data_format::pose_type ILLIXR::offload_rendering_server::correct_pose (\n    const data_format::pose_type &amp; pose\n) override const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-destroy","title":"function destroy","text":"<p>Cleanup resources on destruction. <pre><code>void ILLIXR::offload_rendering_server::destroy () override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<p>Check if fast pose data is reliable. <pre><code>inline bool ILLIXR::offload_rendering_server::fast_pose_reliable () override const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-get_fast_pose-12","title":"function get_fast_pose [1/2]","text":"<p>Get the latest pose for rendering. <pre><code>data_format::fast_pose_type ILLIXR::offload_rendering_server::get_fast_pose () override const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-get_fast_pose-22","title":"function get_fast_pose [2/2]","text":"<p>Get predicted pose for a future time point (returns current pose) <pre><code>inline data_format::fast_pose_type ILLIXR::offload_rendering_server::get_fast_pose (\n    time_point future_time\n) override const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-get_offset","title":"function get_offset","text":"<p>Get orientation offset (returns identity in this implementation) <pre><code>inline Eigen::Quaternionf ILLIXR::offload_rendering_server::get_offset () override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-get_true_pose","title":"function get_true_pose","text":"<p>Get the true pose (same as fast pose in this implementation) <pre><code>inline data_format::pose_type ILLIXR::offload_rendering_server::get_true_pose () override const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-is_external","title":"function is_external","text":"<p>Indicates this sink does not make use of the rendering pipeline in order for the access masks of the layout transitions to be set properly. <pre><code>inline bool ILLIXR::offload_rendering_server::is_external () override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-offload_rendering_server","title":"function offload_rendering_server","text":"<p>Constructor initializes the server with configuration from environment variables. <pre><code>ILLIXR::offload_rendering_server::offload_rendering_server (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Plugin name </li> <li><code>pb</code> Phonebook for component lookup </li> </ul>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-record_command_buffer","title":"function record_command_buffer","text":"<p>Record command buffer (no-op in this implementation) <pre><code>inline void ILLIXR::offload_rendering_server::record_command_buffer (\n    VkCommandBuffer commandBuffer,\n    VkFramebuffer framebuffer,\n    int buffer_ind,\n    bool left\n) override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-set_offset","title":"function set_offset","text":"<p>Set orientation offset (no-op in this implementation) <pre><code>inline void ILLIXR::offload_rendering_server::set_offset (\n    const Eigen::Quaternionf &amp; orientation\n) override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-setup","title":"function setup","text":"<p>Sets up the rendering pipeline and encoding resources. <pre><code>void ILLIXR::offload_rendering_server::setup (\n    VkRenderPass render_pass,\n    uint32_t subpass,\n    std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; _buffer_pool,\n    bool input_texture_vulkan_coordinates\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>render_pass</code> Vulkan render pass handle </li> <li><code>subpass</code> Subpass index </li> <li><code>_buffer_pool</code> Buffer pool for frame management </li> <li><code>input_texture_vulkan_coordinates</code> Whether input textures use Vulkan coordinates </li> </ul>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-start","title":"function start","text":"<p>A method which Spindle calls when it starts the component. <pre><code>virtual void ILLIXR::offload_rendering_server::start () override\n</code></pre></p> <p>This is necessary because a constructor can't call derived virtual methods (due to structure of C++). See <code>threadloop</code> for an example of this use-case. </p> <p>Implements ILLIXR::plugin::start</p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<p>Check if true pose data is reliable (always false in this implementation) <pre><code>inline bool ILLIXR::offload_rendering_server::true_pose_reliable () override const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-update_uniforms","title":"function update_uniforms","text":"<p>Update uniforms (no-op in this implementation) <pre><code>inline void ILLIXR::offload_rendering_server::update_uniforms (\n    const data_format::pose_type &amp; r_pose\n) override\n</code></pre></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Main processing loop for frame encoding and transmission. <pre><code>virtual void ILLIXR::offload_rendering_server::_p_one_iteration () override\n</code></pre></p> <p>This method: * Captures the latest rendered frame * Encodes it using hardware acceleration * Transmits it to the client * Tracks performance metrics </p> <p>Implements ILLIXR::threadloop::_p_one_iteration</p>"},{"location":"api/classILLIXR_1_1offload__rendering__server/#function-_p_should_skip","title":"function _p_should_skip","text":"<p>Determines if the current iteration should be skipped. <pre><code>inline virtual skip_option ILLIXR::offload_rendering_server::_p_should_skip () override\n</code></pre></p> <p>Implements ILLIXR::threadloop::_p_should_skip</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/offload_rendering_server.hpp</code></p>"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/","title":"Class ILLIXR::offload_rendering_server_loader","text":"<p>ClassList &gt; ILLIXR &gt; offload_rendering_server_loader</p> <p>Plugin loader for the offload rendering server. More...</p> <ul> <li><code>#include &lt;plugin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::plugin,  vulkan::vk_extension_request</p>"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; const char * &gt; get_required_devices_extensions () overrideGet required Vulkan device extensions. std::vector&lt; const char * &gt; get_required_instance_extensions () overrideGet required Vulkan instance extensions. offload_rendering_server_loader (const std::string &amp; name, phonebook * pb) Constructor registers the server plugin with the system. virtual void start () overrideA method which Spindle calls when it starts the component. virtual void stop () overrideA method which Spindle calls when it stops the component."},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#detailed-description","title":"Detailed Description","text":"<p>Handles plugin registration and Vulkan extension requirements for the offload rendering server component. </p>"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#function-get_required_devices_extensions","title":"function get_required_devices_extensions","text":"<p>Get required Vulkan device extensions. <pre><code>std::vector&lt; const char * &gt; ILLIXR::offload_rendering_server_loader::get_required_devices_extensions () override\n</code></pre></p> <p>Returns:</p> <p>List of required device extension names </p>"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#function-get_required_instance_extensions","title":"function get_required_instance_extensions","text":"<p>Get required Vulkan instance extensions. <pre><code>std::vector&lt; const char * &gt; ILLIXR::offload_rendering_server_loader::get_required_instance_extensions () override\n</code></pre></p> <p>Returns:</p> <p>List of required instance extension names </p>"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#function-offload_rendering_server_loader","title":"function offload_rendering_server_loader","text":"<p>Constructor registers the server plugin with the system. <pre><code>ILLIXR::offload_rendering_server_loader::offload_rendering_server_loader (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Plugin name </li> <li><code>pb</code> Phonebook for component lookup </li> </ul>"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#function-start","title":"function start","text":"<p>A method which Spindle calls when it starts the component. <pre><code>virtual void ILLIXR::offload_rendering_server_loader::start () override\n</code></pre></p> <p>This is necessary because a constructor can't call derived virtual methods (due to structure of C++). See <code>threadloop</code> for an example of this use-case. </p> <p>Implements ILLIXR::plugin::start</p>"},{"location":"api/classILLIXR_1_1offload__rendering__server__loader/#function-stop","title":"function stop","text":"<p>A method which Spindle calls when it stops the component. <pre><code>virtual void ILLIXR::offload_rendering_server_loader::stop () override\n</code></pre></p> <p>This is necessary because the parent class might define some actions that need to be taken prior to destructing the derived class. For example, threadloop must halt and join the thread before the derived class can be safely destructed. However, the derived class's destructor is called before its parent (threadloop), so threadloop doesn't get a chance to join the thread before the derived class is destroyed, and the thread accesses freed memory. Instead, we call plugin-&gt;stop manually before destroying anything.</p> <p>Concrete plugins are responsible for initializing their specific logger and sinks. </p> <p>Implements ILLIXR::plugin::stop</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1offload__writer/","title":"Class ILLIXR::offload_writer","text":"<p>ClassList &gt; ILLIXR &gt; offload_writer</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1offload__writer/#public-functions","title":"Public Functions","text":"Type Name offload_writer (const std::string &amp; name, phonebook * pb)  void prepare_imu_cam_data (switchboard::ptr&lt; const data_format::imu_type &gt; datum)  void send_imu_cam_data (std::optional&lt; time_point &gt; &amp; cam_time)  void start () override"},{"location":"api/classILLIXR_1_1offload__writer/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1offload__writer/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1offload__writer/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1offload__writer/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1offload__writer/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1offload__writer/#protected-functions","title":"Protected Functions","text":"Type Name void _p_one_iteration () override void _p_thread_setup () override"},{"location":"api/classILLIXR_1_1offload__writer/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1offload__writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__writer/#function-offload_writer","title":"function offload_writer","text":"<pre><code>ILLIXR::offload_writer::offload_writer (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1offload__writer/#function-prepare_imu_cam_data","title":"function prepare_imu_cam_data","text":"<pre><code>void ILLIXR::offload_writer::prepare_imu_cam_data (\n    switchboard::ptr &lt; const data_format::imu_type &gt; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1offload__writer/#function-send_imu_cam_data","title":"function send_imu_cam_data","text":"<pre><code>void ILLIXR::offload_writer::send_imu_cam_data (\n    std::optional&lt; time_point &gt; &amp; cam_time\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1offload__writer/#function-start","title":"function start","text":"<pre><code>void ILLIXR::offload_writer::start () override\n</code></pre>"},{"location":"api/classILLIXR_1_1offload__writer/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1offload__writer/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::offload_writer::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1offload__writer/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<pre><code>inline void ILLIXR::offload_writer::_p_thread_setup () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1openni__plugin/","title":"Class ILLIXR::openni_plugin","text":"<p>ClassList &gt; ILLIXR &gt; openni_plugin</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1openni__plugin/#public-functions","title":"Public Functions","text":"Type Name openni_plugin (const std::string &amp; name, phonebook * pb)  ~openni_plugin () override"},{"location":"api/classILLIXR_1_1openni__plugin/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1openni__plugin/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1openni__plugin/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1openni__plugin/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1openni__plugin/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1openni__plugin/#protected-functions","title":"Protected Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override bool camera_initialize ()"},{"location":"api/classILLIXR_1_1openni__plugin/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1openni__plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1openni__plugin/#function-openni_plugin","title":"function openni_plugin","text":"<pre><code>ILLIXR::openni_plugin::openni_plugin (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1openni__plugin/#function-openni_plugin_1","title":"function ~openni_plugin","text":"<pre><code>ILLIXR::openni_plugin::~openni_plugin () override\n</code></pre>"},{"location":"api/classILLIXR_1_1openni__plugin/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1openni__plugin/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::openni_plugin::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1openni__plugin/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::openni_plugin::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1openni__plugin/#function-camera_initialize","title":"function camera_initialize","text":"<pre><code>bool ILLIXR::openni_plugin::camera_initialize () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openni/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1openwarp__vk/","title":"Class ILLIXR::openwarp_vk","text":"<p>ClassList &gt; ILLIXR &gt; openwarp_vk</p> <p>Inherits the following classes: ILLIXR::vulkan::timewarp</p>"},{"location":"api/classILLIXR_1_1openwarp__vk/#public-functions","title":"Public Functions","text":"Type Name void destroy () override void initialize ()  bool is_external () override openwarp_vk (const phonebook * pb)  void partial_destroy ()  void record_command_buffer (VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) override void setup (VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool_, bool input_texture_external_) override void update_uniforms (const data_format::pose_type &amp; render_pose) override"},{"location":"api/classILLIXR_1_1openwarp__vk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1openwarp__vk/#function-destroy","title":"function destroy","text":"<pre><code>void ILLIXR::openwarp_vk::destroy () override\n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk/#function-initialize","title":"function initialize","text":"<pre><code>void ILLIXR::openwarp_vk::initialize () \n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk/#function-is_external","title":"function is_external","text":"<pre><code>bool ILLIXR::openwarp_vk::is_external () override\n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk/#function-openwarp_vk","title":"function openwarp_vk","text":"<pre><code>explicit ILLIXR::openwarp_vk::openwarp_vk (\n    const phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk/#function-partial_destroy","title":"function partial_destroy","text":"<pre><code>void ILLIXR::openwarp_vk::partial_destroy () \n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk/#function-record_command_buffer","title":"function record_command_buffer","text":"<pre><code>void ILLIXR::openwarp_vk::record_command_buffer (\n    VkCommandBuffer commandBuffer,\n    VkFramebuffer framebuffer,\n    int buffer_ind,\n    bool left\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk/#function-setup","title":"function setup","text":"<pre><code>void ILLIXR::openwarp_vk::setup (\n    VkRenderPass render_pass,\n    uint32_t subpass,\n    std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool_,\n    bool input_texture_external_\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk/#function-update_uniforms","title":"function update_uniforms","text":"<pre><code>void ILLIXR::openwarp_vk::update_uniforms (\n    const data_format::pose_type &amp; render_pose\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/openwarp_vk.hpp</code></p>"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/","title":"Class ILLIXR::openwarp_vk_plugin","text":"<p>ClassList &gt; ILLIXR &gt; openwarp_vk_plugin</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override openwarp_vk_plugin (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::openwarp_vk_plugin::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::openwarp_vk_plugin::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1openwarp__vk__plugin/#function-openwarp_vk_plugin","title":"function openwarp_vk_plugin","text":"<pre><code>ILLIXR::openwarp_vk_plugin::openwarp_vk_plugin (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1passthrough__integrator/","title":"Class ILLIXR::passthrough_integrator","text":"<p>ClassList &gt; ILLIXR &gt; passthrough_integrator</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1passthrough__integrator/#public-functions","title":"Public Functions","text":"Type Name void callback (const switchboard::ptr&lt; const data_format::imu_type &gt; &amp; datum)  passthrough_integrator (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1passthrough__integrator/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1passthrough__integrator/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1passthrough__integrator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1passthrough__integrator/#function-callback","title":"function callback","text":"<pre><code>void ILLIXR::passthrough_integrator::callback (\n    const switchboard::ptr &lt; const data_format::imu_type &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1passthrough__integrator/#function-passthrough_integrator","title":"function passthrough_integrator","text":"<pre><code>ILLIXR::passthrough_integrator::passthrough_integrator (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/passthrough_integrator/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook/","title":"Class ILLIXR::phonebook","text":"<p>ClassList &gt; ILLIXR &gt; phonebook</p> <p>A service locator forILLIXR .More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#classes","title":"Classes","text":"Type Name class service A 'service' that can be registered in the phonebook."},{"location":"api/classILLIXR_1_1phonebook/#public-functions","title":"Public Functions","text":"Type Name bool has_impl () const std::shared_ptr&lt; Specific_service &gt; lookup_impl () constLook up an implementation of <code>Specific_service</code> , which should be registered first. void register_impl (std::shared_ptr&lt; Specific_service &gt; impl) Registers an implementation of <code>baseclass</code> for future calls to lookup."},{"location":"api/classILLIXR_1_1phonebook/#detailed-description","title":"Detailed Description","text":"<p>This will be explained through an example: Suppose one dynamically-loaded plugin, <code>A_plugin</code>, needs a service, <code>B_service</code>, provided by another, <code>B_plugin</code>. <code>A_plugin</code> cannot statically construct a <code>B_service</code>, because the implementation <code>B_plugin</code> is dynamically loaded. However, <code>B_plugin</code> can register an implementation of <code>B_service</code> when it is loaded, and <code>A_plugin</code> can lookup that implementation without knowing it.</p> <p><code>B_service.hpp</code> in <code>common</code>:  <pre><code>class B_service {\npublic:\n    virtual void frobnicate(foo data) = 0;\n};\n</code></pre></p> <p><code>B_plugin.hpp</code>:  <pre><code>class B_impl : public B_service {\npublic:\n    virtual void frobnicate(foo data) {\n        // ...\n    }\n};\nvoid blah_blah(phonebook* pb) {\n    // Expose `this` as the \"official\" implementation of `B_service` for this run.\n    pb-&gt;register_impl&lt;B_service&gt;(std::make_shared&lt;B_impl&gt;());\n}\n</code></pre></p> <p><code>A_plugin.cpp</code>:  <pre><code>#include \"B_service.hpp\"\nvoid blah_blah(phonebook* pb) {\n    B_service* b = pb-&gt;lookup_impl&lt;B_service&gt;();\n    b-&gt;frobnicate(data);\n}\n</code></pre></p> <p>If the implementation of <code>B_service</code> is not known to <code>A_plugin</code> (the usual case), <code>B_service should be an [abstract class][2]. In either case</code>B_service<code>should be in</code>common`, so both plugins can refer to it.</p> <p>One could even selectively return a different implementation of <code>B_service</code> depending on the caller (through the parameters), but we have not encountered the need for that yet. </p>"},{"location":"api/classILLIXR_1_1phonebook/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook/#function-has_impl","title":"function has_impl","text":"<pre><code>template&lt;typename specific_service&gt;\ninline bool ILLIXR::phonebook::has_impl () const\n</code></pre>"},{"location":"api/classILLIXR_1_1phonebook/#function-lookup_impl","title":"function lookup_impl","text":"<p>Look up an implementation of <code>Specific_service</code> , which should be registered first. <pre><code>template&lt;typename Specific_service&gt;\ninline std::shared_ptr&lt; Specific_service &gt; ILLIXR::phonebook::lookup_impl () const\n</code></pre></p> <p>Safe to be called from any thread.</p> <p>Do not call <code>delete</code> on the returned object; it is still managed by phonebook.</p> <p>Exception:</p> <ul> <li><code>if</code> an implementation is not already registered. </li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#function-register_impl","title":"function register_impl","text":"<p>Registers an implementation of <code>baseclass</code> for future calls to lookup. <pre><code>template&lt;typename Specific_service&gt;\ninline void ILLIXR::phonebook::register_impl (\n    std::shared_ptr&lt; Specific_service &gt; impl\n) \n</code></pre></p> <p>Safe to be called from any thread.</p> <p>The implementation will be owned by phonebook (phonebook calls <code>delete</code>). </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/","title":"Class ILLIXR::phonebook::service","text":"<p>ClassList &gt; ILLIXR &gt; phonebook &gt; service</p> <p>A 'service' that can be registered in the phonebook. More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::data_format::pose_prediction,  ILLIXR::gen_guid,  ILLIXR::network::network_backend,  ILLIXR::record_logger,  ILLIXR::relative_clock,  ILLIXR::stoplight,  ILLIXR::switchboard,  ILLIXR::vulkan::display_provider,  ILLIXR::vulkan::render_pass,  ILLIXR::xlib_gl_extended_window</p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions","title":"Public Functions","text":"Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#detailed-description","title":"Detailed Description","text":"<p>These must be 'destructible', have a virtual destructor that phonebook can call in its destructor. </p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook_1_1service/#function-service","title":"function ~service","text":"<pre><code>virtual ILLIXR::phonebook::service::~service () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1plugin/","title":"Class ILLIXR::plugin","text":"<p>ClassList &gt; ILLIXR &gt; plugin</p> <p>A dynamically-loadable plugin for Spindle. </p> <ul> <li><code>#include &lt;plugin.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::depthai,  ILLIXR::fauxpose,  ILLIXR::ground_truth_slam,  ILLIXR::gtsam_integrator,  ILLIXR::offload_data,  ILLIXR::offload_rendering_server_loader,  ILLIXR::passthrough_integrator,  ILLIXR::realsense,  ILLIXR::record_imu_cam,  ILLIXR::record_rgb_depth,  ILLIXR::rk4_integrator,  ILLIXR::server_writer,  ILLIXR::tcp_network_backend,  ILLIXR::threadloop,  ILLIXR::viewer,  ILLIXR::vkdemo_plugin,  offload_rendering_client_loader,  pose_lookup_plugin,  pose_prediction_plugin</p>"},{"location":"api/classILLIXR_1_1plugin/#public-functions","title":"Public Functions","text":"Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes","title":"Protected Attributes","text":"Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#function-get_name","title":"function get_name","text":"<pre><code>inline std::string ILLIXR::plugin::get_name () noexcept const\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin","title":"function plugin","text":"<pre><code>inline ILLIXR::plugin::plugin (\n    std::string name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-spd_add_file_sink","title":"function spd_add_file_sink","text":"<pre><code>inline void ILLIXR::plugin::spd_add_file_sink (\n    const std::string &amp; file_name,\n    const std::string &amp; extension,\n    const std::string &amp; log_level\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-spdlogger","title":"function spdlogger","text":"<pre><code>inline auto ILLIXR::plugin::spdlogger (\n    const char * log_level\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-start","title":"function start","text":"<p>A method which Spindle calls when it starts the component. <pre><code>inline virtual void ILLIXR::plugin::start () \n</code></pre></p> <p>This is necessary because a constructor can't call derived virtual methods (due to structure of C++). See <code>threadloop</code> for an example of this use-case. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-stop","title":"function stop","text":"<p>A method which Spindle calls when it stops the component. <pre><code>inline virtual void ILLIXR::plugin::stop () \n</code></pre></p> <p>This is necessary because the parent class might define some actions that need to be taken prior to destructing the derived class. For example, threadloop must halt and join the thread before the derived class can be safely destructed. However, the derived class's destructor is called before its parent (threadloop), so threadloop doesn't get a chance to join the thread before the derived class is destroyed, and the thread accesses freed memory. Instead, we call plugin-&gt;stop manually before destroying anything.</p> <p>Concrete plugins are responsible for initializing their specific logger and sinks. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin_1","title":"function ~plugin","text":"<pre><code>virtual ILLIXR::plugin::~plugin () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#variable-gen_guid_","title":"variable gen_guid_","text":"<pre><code>const std::shared_ptr&lt;gen_guid&gt; ILLIXR::plugin::gen_guid_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-id_","title":"variable id_","text":"<pre><code>const std::size_t ILLIXR::plugin::id_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-name_","title":"variable name_","text":"<pre><code>std::string ILLIXR::plugin::name_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-phonebook_","title":"variable phonebook_","text":"<pre><code>const phonebook* ILLIXR::plugin::phonebook_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-plugin_logger_","title":"variable plugin_logger_","text":"<pre><code>std::shared_ptr&lt;spdlog::logger&gt; ILLIXR::plugin::plugin_logger_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-record_logger_","title":"variable record_logger_","text":"<pre><code>const std::shared_ptr&lt;record_logger&gt; ILLIXR::plugin::record_logger_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/","title":"Class ILLIXR::pose_lookup_impl","text":"<p>ClassList &gt; ILLIXR &gt; pose_lookup_impl</p> <p>Inherits the following classes: ILLIXR::data_format::pose_prediction</p>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#public-functions","title":"Public Functions","text":"Type Name Eigen::Quaternionf apply_offset (const Eigen::Quaternionf &amp; orientation) const data_format::pose_type correct_pose (const data_format::pose_type &amp; pose) override const bool fast_pose_reliable () override const data_format::fast_pose_type get_fast_pose () override const data_format::fast_pose_type get_fast_pose (time_point time) override const Eigen::Quaternionf get_offset () override data_format::pose_type get_true_pose () override const pose_lookup_impl (const phonebook *const pb)  void set_offset (const Eigen::Quaternionf &amp; raw_o_times_offset) override bool true_pose_reliable () override const"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-apply_offset","title":"function apply_offset","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_lookup_impl::apply_offset (\n    const Eigen::Quaternionf &amp; orientation\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-correct_pose","title":"function correct_pose","text":"<pre><code>data_format::pose_type ILLIXR::pose_lookup_impl::correct_pose (\n    const data_format::pose_type &amp; pose\n) override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<pre><code>bool ILLIXR::pose_lookup_impl::fast_pose_reliable () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-get_fast_pose-12","title":"function get_fast_pose [1/2]","text":"<pre><code>data_format::fast_pose_type ILLIXR::pose_lookup_impl::get_fast_pose () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-get_fast_pose-22","title":"function get_fast_pose [2/2]","text":"<pre><code>data_format::fast_pose_type ILLIXR::pose_lookup_impl::get_fast_pose (\n    time_point time\n) override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-get_offset","title":"function get_offset","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_lookup_impl::get_offset () override\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-get_true_pose","title":"function get_true_pose","text":"<pre><code>data_format::pose_type ILLIXR::pose_lookup_impl::get_true_pose () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-pose_lookup_impl","title":"function pose_lookup_impl","text":"<pre><code>explicit ILLIXR::pose_lookup_impl::pose_lookup_impl (\n    const phonebook *const pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-set_offset","title":"function set_offset","text":"<pre><code>void ILLIXR::pose_lookup_impl::set_offset (\n    const Eigen::Quaternionf &amp; raw_o_times_offset\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__lookup__impl/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<pre><code>bool ILLIXR::pose_lookup_impl::true_pose_reliable () override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_lookup/service.hpp</code></p>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/","title":"Class ILLIXR::pose_prediction_impl","text":"<p>ClassList &gt; ILLIXR &gt; pose_prediction_impl</p> <p>Inherits the following classes: ILLIXR::data_format::pose_prediction</p>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#public-functions","title":"Public Functions","text":"Type Name Eigen::Quaternionf apply_offset (const Eigen::Quaternionf &amp; orientation) const data_format::pose_type correct_pose (const data_format::pose_type &amp; pose) override const bool fast_pose_reliable () override const data_format::fast_pose_type get_fast_pose () override const data_format::fast_pose_type get_fast_pose (time_point future_timestamp) override const Eigen::Quaternionf get_offset () override data_format::pose_type get_true_pose () override const pose_prediction_impl (const phonebook *const pb)  void set_offset (const Eigen::Quaternionf &amp; raw_o_times_offset) override bool true_pose_reliable () override const"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-apply_offset","title":"function apply_offset","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_prediction_impl::apply_offset (\n    const Eigen::Quaternionf &amp; orientation\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-correct_pose","title":"function correct_pose","text":"<pre><code>data_format::pose_type ILLIXR::pose_prediction_impl::correct_pose (\n    const data_format::pose_type &amp; pose\n) override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<pre><code>bool ILLIXR::pose_prediction_impl::fast_pose_reliable () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-get_fast_pose-12","title":"function get_fast_pose [1/2]","text":"<pre><code>data_format::fast_pose_type ILLIXR::pose_prediction_impl::get_fast_pose () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-get_fast_pose-22","title":"function get_fast_pose [2/2]","text":"<pre><code>data_format::fast_pose_type ILLIXR::pose_prediction_impl::get_fast_pose (\n    time_point future_timestamp\n) override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-get_offset","title":"function get_offset","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_prediction_impl::get_offset () override\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-get_true_pose","title":"function get_true_pose","text":"<pre><code>data_format::pose_type ILLIXR::pose_prediction_impl::get_true_pose () override const\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-pose_prediction_impl","title":"function pose_prediction_impl","text":"<pre><code>explicit ILLIXR::pose_prediction_impl::pose_prediction_impl (\n    const phonebook *const pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-set_offset","title":"function set_offset","text":"<pre><code>void ILLIXR::pose_prediction_impl::set_offset (\n    const Eigen::Quaternionf &amp; raw_o_times_offset\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1pose__prediction__impl/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<pre><code>bool ILLIXR::pose_prediction_impl::true_pose_reliable () override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_prediction/service.hpp</code></p>"},{"location":"api/classILLIXR_1_1realsense/","title":"Class ILLIXR::realsense","text":"<p>ClassList &gt; ILLIXR &gt; realsense</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1realsense/#public-functions","title":"Public Functions","text":"Type Name void callback (const rs2::frame &amp; frame)  realsense (const std::string &amp; name, phonebook * pb)  ~realsense () override"},{"location":"api/classILLIXR_1_1realsense/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1realsense/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1realsense/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1realsense/#function-callback","title":"function callback","text":"<pre><code>void ILLIXR::realsense::callback (\n    const rs2::frame &amp; frame\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1realsense/#function-realsense","title":"function realsense","text":"<pre><code>ILLIXR::realsense::realsense (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1realsense/#function-realsense_1","title":"function ~realsense","text":"<pre><code>ILLIXR::realsense::~realsense () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/realsense/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1record/","title":"Class ILLIXR::record","text":"<p>ClassList &gt; ILLIXR &gt; record</p> <p>This class represents a tuple of fields which get logged by <code>record_logger</code> .More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record/#public-functions","title":"Public Functions","text":"Type Name const record_header &amp; get_record_header () const T get_value (unsigned column) const void mark_used () const record (const record_header &amp; rh, std::vector&lt; std::any &gt; values)  record () = default ~record ()"},{"location":"api/classILLIXR_1_1record/#detailed-description","title":"Detailed Description","text":"<p><code>rh</code> is a pointer rather than a reference for historical reasons. It should not be null. </p>"},{"location":"api/classILLIXR_1_1record/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record/#function-get_record_header","title":"function get_record_header","text":"<pre><code>inline const record_header &amp; ILLIXR::record::get_record_header () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-get_value","title":"function get_value","text":"<pre><code>template&lt;typename T&gt;\ninline T ILLIXR::record::get_value (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::record::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record-12","title":"function record [1/2]","text":"<pre><code>inline ILLIXR::record::record (\n    const record_header &amp; rh,\n    std::vector&lt; std::any &gt; values\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record-22","title":"function record [2/2]","text":"<pre><code>ILLIXR::record::record () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record","title":"function ~record","text":"<pre><code>inline ILLIXR::record::~record () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__coalescer/","title":"Class ILLIXR::record_coalescer","text":"<p>ClassList &gt; ILLIXR &gt; record_coalescer</p> <p>Coalesces logs of the same type to be written back as a single-transaction. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions","title":"Public Functions","text":"Type Name void flush () Flush buffer of logs to the underlying logger. void log (const record &amp; r) Appends a log to the buffer, which will eventually be written. void maybe_flush () Use internal decision process, and possibly trigger flush. operator bool () const record_coalescer (std::shared_ptr&lt; record_logger &gt; logger_)  ~record_coalescer ()"},{"location":"api/classILLIXR_1_1record__coalescer/#detailed-description","title":"Detailed Description","text":"<p>Records should all be of the same type. TODO: remove this constraint. Use <code>log&lt;record_type&gt;(Args... args)</code> and <code>std::forward</code>.</p> <p>In some backend-implementations, logging many logs of the same type is more efficient than logging them individually; However, the client often wants to produce one log-record at a time. This class resolves this mismatch by buffering logs from the client. Every time a new log is added, an internal decision process determines whether or not to flush the buffer, or keep accumulating and wait until later.</p> <p>Currently this internal decision process is \"is the oldest log in the buffer more than 1 second old?\". I chose this because this frequency should have very little overhead, even if every component is also coalescing at 1 per second.</p> <p>At destructor time, any remaining logs are flushed.</p> <p>Use like:</p> <pre><code>log_coalescer(logger);\nlc.log(make_my_record(id_, it, skip_it, ...));\n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__coalescer/#function-flush","title":"function flush","text":"<p>Flush buffer of logs to the underlying logger. <pre><code>inline void ILLIXR::record_coalescer::flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-log","title":"function log","text":"<p>Appends a log to the buffer, which will eventually be written. <pre><code>inline void ILLIXR::record_coalescer::log (\n    const record &amp; r\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-maybe_flush","title":"function maybe_flush","text":"<p>Use internal decision process, and possibly trigger flush. <pre><code>inline void ILLIXR::record_coalescer::maybe_flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit ILLIXR::record_coalescer::operator bool () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer","title":"function record_coalescer","text":"<pre><code>inline explicit ILLIXR::record_coalescer::record_coalescer (\n    std::shared_ptr&lt; record_logger &gt; logger_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer_1","title":"function ~record_coalescer","text":"<pre><code>inline ILLIXR::record_coalescer::~record_coalescer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__header/","title":"Class ILLIXR::record_header","text":"<p>ClassList &gt; ILLIXR &gt; record_header</p> <p>Schema of each record. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__header/#public-functions","title":"Public Functions","text":"Type Name const std::string &amp; get_column_name (unsigned column) const const std::type_info &amp; get_column_type (unsigned column) const unsigned get_columns () const std::size_t get_id () const const std::string &amp; get_name () const bool operator!= (const record_header &amp; other) const bool operator== (const record_header &amp; other) constCompares two schemata. record_header (const std::string &amp; name, std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_)  std::string to_string () const"},{"location":"api/classILLIXR_1_1record__header/#detailed-description","title":"Detailed Description","text":"<p>name_ should be globally unique. </p>"},{"location":"api/classILLIXR_1_1record__header/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__header/#function-get_column_name","title":"function get_column_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_column_name (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_column_type","title":"function get_column_type","text":"<pre><code>inline const std::type_info &amp; ILLIXR::record_header::get_column_type (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_columns","title":"function get_columns","text":"<pre><code>inline unsigned ILLIXR::record_header::get_columns () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_id","title":"function get_id","text":"<pre><code>inline std::size_t ILLIXR::record_header::get_id () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_name","title":"function get_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_name () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator","title":"function operator!=","text":"<pre><code>inline bool ILLIXR::record_header::operator!= (\n    const record_header &amp; other\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator_1","title":"function operator==","text":"<p>Compares two schemata. <pre><code>inline bool ILLIXR::record_header::operator== (\n    const record_header &amp; other\n) const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__header/#function-record_header","title":"function record_header","text":"<pre><code>inline ILLIXR::record_header::record_header (\n    const std::string &amp; name,\n    std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string ILLIXR::record_header::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__imu__cam/","title":"Class ILLIXR::record_imu_cam","text":"<p>ClassList &gt; ILLIXR &gt; record_imu_cam</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1record__imu__cam/#public-functions","title":"Public Functions","text":"Type Name void dump_data (const switchboard::ptr&lt; const data_format::imu_type &gt; &amp; datum)  record_imu_cam (const std::string &amp; name, phonebook * pb)  ~record_imu_cam () override"},{"location":"api/classILLIXR_1_1record__imu__cam/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1record__imu__cam/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1record__imu__cam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__imu__cam/#function-dump_data","title":"function dump_data","text":"<pre><code>void ILLIXR::record_imu_cam::dump_data (\n    const switchboard::ptr &lt; const data_format::imu_type &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__imu__cam/#function-record_imu_cam","title":"function record_imu_cam","text":"<pre><code>ILLIXR::record_imu_cam::record_imu_cam (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__imu__cam/#function-record_imu_cam_1","title":"function ~record_imu_cam","text":"<pre><code>ILLIXR::record_imu_cam::~record_imu_cam () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_imu_cam/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__logger/","title":"Class ILLIXR::record_logger","text":"<p>ClassList &gt; ILLIXR &gt; record_logger</p> <p>The ILLIXR logging service for structured records.More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p> <p>Inherited by the following classes: ILLIXR::sqlite_record_logger,  ILLIXR::stdout_record_logger</p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions","title":"Public Functions","text":"Type Name virtual void log (const record &amp; r) = 0Writes one log record. virtual void log (const std::vector&lt; record &gt; &amp; rs) Writes many of the same type of log record. ~record_logger () override"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1record__logger/#detailed-description","title":"Detailed Description","text":"<p>This has two advantages over printf logging. It has lower overhead (because it goes into a database), won't result in spliced messages (no stdout race-conditions), and is used uniformly by ILLIXR components. </p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__logger/#function-log-12","title":"function log [1/2]","text":"<p>Writes one log record. <pre><code>virtual void ILLIXR::record_logger::log (\n    const record &amp; r\n) = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__logger/#function-log-22","title":"function log [2/2]","text":"<p>Writes many of the same type of log record. <pre><code>inline virtual void ILLIXR::record_logger::log (\n    const std::vector&lt; record &gt; &amp; rs\n) \n</code></pre></p> <p>This is more efficient than calling log many times. </p>"},{"location":"api/classILLIXR_1_1record__logger/#function-record_logger","title":"function ~record_logger","text":"<pre><code>ILLIXR::record_logger::~record_logger () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__rgb__depth/","title":"Class ILLIXR::record_rgb_depth","text":"<p>ClassList &gt; ILLIXR &gt; record_rgb_depth</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1record__rgb__depth/#public-functions","title":"Public Functions","text":"Type Name void dump_data (const switchboard::ptr&lt; const data_format::rgb_depth_type &gt; &amp; datum)  record_rgb_depth (const std::string &amp; name, phonebook * pb)  ~record_rgb_depth () override"},{"location":"api/classILLIXR_1_1record__rgb__depth/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1record__rgb__depth/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1record__rgb__depth/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__rgb__depth/#function-dump_data","title":"function dump_data","text":"<pre><code>void ILLIXR::record_rgb_depth::dump_data (\n    const switchboard::ptr &lt; const data_format::rgb_depth_type &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__rgb__depth/#function-record_rgb_depth","title":"function record_rgb_depth","text":"<pre><code>ILLIXR::record_rgb_depth::record_rgb_depth (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__rgb__depth/#function-record_rgb_depth_1","title":"function ~record_rgb_depth","text":"<pre><code>ILLIXR::record_rgb_depth::~record_rgb_depth () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_rgb_depth/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1relative__clock/","title":"Class ILLIXR::relative_clock","text":"<p>ClassList &gt; ILLIXR &gt; relative_clock</p> <p>Relative clock for all of ILLIXR .More...</p> <ul> <li><code>#include &lt;relative_clock.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1relative__clock/#public-types","title":"Public Types","text":"Type Name typedef clock_duration_ duration"},{"location":"api/classILLIXR_1_1relative__clock/#public-functions","title":"Public Functions","text":"Type Name int64_t absolute_ns (time_point relative)  bool is_started () constCheck if the clock is started. time_point now () const void start () Starts the clock. All times are relative to this point. time_point start_time () constGet the start time of the clock."},{"location":"api/classILLIXR_1_1relative__clock/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1relative__clock/#detailed-description","title":"Detailed Description","text":"<p>Please use this instead of std::chrono clocks; this way, you can fake real time without changing your code.</p> <p>It also eliminates the class of bugs relating to using absolute time instead of time-since-start.</p> <p>Unfortunately this can't satisfy Clock because it needs to have data (namely _m_start) shared across link-time boundaries. There's no clean way to do this with static variables, so instead I use instance variables and Phonebook. </p>"},{"location":"api/classILLIXR_1_1relative__clock/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1relative__clock/#typedef-duration","title":"typedef duration","text":"<pre><code>using ILLIXR::relative_clock::duration =  clock_duration_;\n</code></pre>"},{"location":"api/classILLIXR_1_1relative__clock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1relative__clock/#function-absolute_ns","title":"function absolute_ns","text":"<pre><code>inline int64_t ILLIXR::relative_clock::absolute_ns (\n    time_point relative\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1relative__clock/#function-is_started","title":"function is_started","text":"<p>Check if the clock is started. <pre><code>inline bool ILLIXR::relative_clock::is_started () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1relative__clock/#function-now","title":"function now","text":"<pre><code>inline time_point ILLIXR::relative_clock::now () const\n</code></pre>"},{"location":"api/classILLIXR_1_1relative__clock/#function-start","title":"function start","text":"<p>Starts the clock. All times are relative to this point. <pre><code>inline void ILLIXR::relative_clock::start () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1relative__clock/#function-start_time","title":"function start_time","text":"<p>Get the start time of the clock. <pre><code>inline time_point ILLIXR::relative_clock::start_time () const\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/relative_clock.hpp</code></p>"},{"location":"api/classILLIXR_1_1rk4__integrator/","title":"Class ILLIXR::rk4_integrator","text":"<p>ClassList &gt; ILLIXR &gt; rk4_integrator</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1rk4__integrator/#public-functions","title":"Public Functions","text":"Type Name void callback (const switchboard::ptr&lt; const data_format::imu_type &gt; &amp; datum)  rk4_integrator (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1rk4__integrator/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1rk4__integrator/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1rk4__integrator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1rk4__integrator/#function-callback","title":"function callback","text":"<pre><code>void ILLIXR::rk4_integrator::callback (\n    const switchboard::ptr &lt; const data_format::imu_type &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1rk4__integrator/#function-rk4_integrator","title":"function rk4_integrator","text":"<pre><code>ILLIXR::rk4_integrator::rk4_integrator (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/rk4_integrator/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1runtime/","title":"Class ILLIXR::runtime","text":"<p>ClassList &gt; ILLIXR &gt; runtime</p> <p>Inherited by the following classes: runtime_impl</p>"},{"location":"api/classILLIXR_1_1runtime/#public-functions","title":"Public Functions","text":"Type Name virtual void _stop () = 0 std::shared_ptr&lt; switchboard &gt; get_switchboard ()  virtual void load_plugin_factory (plugin_factory plugin) = 0 virtual void load_so (const std::vector&lt; std::string &gt; &amp; so) = 0 virtual void load_so (const std::string_view &amp; so) = 0 void stop ()  virtual void wait () = 0 virtual ~runtime () = default"},{"location":"api/classILLIXR_1_1runtime/#protected-attributes","title":"Protected Attributes","text":"Type Name bool enable_monado_   = <code>false</code> std::shared_ptr&lt; switchboard &gt; switchboard_"},{"location":"api/classILLIXR_1_1runtime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1runtime/#function-_stop","title":"function _stop","text":"<pre><code>virtual void ILLIXR::runtime::_stop () = 0\n</code></pre> <p>Requests that the runtime is completely stopped. Clients must call this before deleting the runtime. </p>"},{"location":"api/classILLIXR_1_1runtime/#function-get_switchboard","title":"function get_switchboard","text":"<pre><code>inline std::shared_ptr&lt; switchboard &gt; ILLIXR::runtime::get_switchboard () \n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_plugin_factory","title":"function load_plugin_factory","text":"<pre><code>virtual void ILLIXR::runtime::load_plugin_factory (\n    plugin_factory plugin\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_so-12","title":"function load_so [1/2]","text":"<pre><code>virtual void ILLIXR::runtime::load_so (\n    const std::vector&lt; std::string &gt; &amp; so\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_so-22","title":"function load_so [2/2]","text":"<pre><code>virtual void ILLIXR::runtime::load_so (\n    const std::string_view &amp; so\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-stop","title":"function stop","text":"<pre><code>inline void ILLIXR::runtime::stop () \n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-wait","title":"function wait","text":"<pre><code>virtual void ILLIXR::runtime::wait () = 0\n</code></pre> <p>Returns when the runtime is completely stopped. </p>"},{"location":"api/classILLIXR_1_1runtime/#function-runtime","title":"function ~runtime","text":"<pre><code>virtual ILLIXR::runtime::~runtime () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1runtime/#variable-enable_monado_","title":"variable enable_monado_","text":"<pre><code>bool ILLIXR::runtime::enable_monado_;\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#variable-switchboard_","title":"variable switchboard_","text":"<pre><code>std::shared_ptr&lt;switchboard&gt; ILLIXR::runtime::switchboard_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/runtime.hpp</code></p>"},{"location":"api/classILLIXR_1_1server__reader/","title":"Class ILLIXR::server_reader","text":"<p>ClassList &gt; ILLIXR &gt; server_reader</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1server__reader/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override server_reader (const std::string &amp; name, phonebook * pb)  void start () override"},{"location":"api/classILLIXR_1_1server__reader/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1server__reader/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1server__reader/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1server__reader/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1server__reader/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1server__reader/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1server__reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1server__reader/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::server_reader::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1server__reader/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::server_reader::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1server__reader/#function-server_reader","title":"function server_reader","text":"<pre><code>ILLIXR::server_reader::server_reader (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1server__reader/#function-start","title":"function start","text":"<pre><code>void ILLIXR::server_reader::start () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1server__writer/","title":"Class ILLIXR::server_writer","text":"<p>ClassList &gt; ILLIXR &gt; server_writer</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1server__writer/#public-functions","title":"Public Functions","text":"Type Name void send_vio_output (const switchboard::ptr&lt; const data_format::pose_type &gt; &amp; datum)  server_writer (const std::string &amp; name, phonebook * pb)  void start () override"},{"location":"api/classILLIXR_1_1server__writer/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1server__writer/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1server__writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1server__writer/#function-send_vio_output","title":"function send_vio_output","text":"<pre><code>void ILLIXR::server_writer::send_vio_output (\n    const switchboard::ptr &lt; const data_format::pose_type &gt; &amp; datum\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1server__writer/#function-server_writer","title":"function server_writer","text":"<pre><code>ILLIXR::server_writer::server_writer (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1server__writer/#function-start","title":"function start","text":"<pre><code>void ILLIXR::server_writer::start () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_tx/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1sqlite__record__logger/","title":"Class ILLIXR::sqlite_record_logger","text":"<p>ClassList &gt; ILLIXR &gt; sqlite_record_logger</p> <p>Inherits the following classes: ILLIXR::record_logger</p>"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#public-functions-inherited-from-illixrrecord_logger","title":"Public Functions inherited from ILLIXR::record_logger","text":"<p>See ILLIXR::record_logger</p> Type Name virtual void log (const record &amp; r) = 0Writes one log record. virtual void log (const std::vector&lt; record &gt; &amp; rs) Writes many of the same type of log record. ~record_logger () override"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#protected-functions","title":"Protected Functions","text":"Type Name void log (const std::vector&lt; record &gt; &amp; r) override void log (const record &amp; r) override"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1sqlite__record__logger/#function-log-12","title":"function log [1/2]","text":"<pre><code>inline void ILLIXR::sqlite_record_logger::log (\n    const std::vector&lt; record &gt; &amp; r\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#function-log-22","title":"function log [2/2]","text":"<pre><code>inline void ILLIXR::sqlite_record_logger::log (\n    const record &amp; r\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/sqlite_record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1sqlite__thread/","title":"Class ILLIXR::sqlite_thread","text":"<p>ClassList &gt; ILLIXR &gt; sqlite_thread</p>"},{"location":"api/classILLIXR_1_1sqlite__thread/#public-functions","title":"Public Functions","text":"Type Name sqlite3pp::database prep_db ()  std::string prep_insert_str ()  void process (const std::vector&lt; record &gt; &amp; record_batch, std::size_t batch_size)  void pull_queue ()  void put_queue (const std::vector&lt; record &gt; &amp; buffer_in)  void put_queue (const record &amp; record_in)  sqlite_thread (const record_header &amp; rh_)  ~sqlite_thread ()"},{"location":"api/classILLIXR_1_1sqlite__thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1sqlite__thread/#function-prep_db","title":"function prep_db","text":"<pre><code>inline sqlite3pp::database ILLIXR::sqlite_thread::prep_db () \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-prep_insert_str","title":"function prep_insert_str","text":"<pre><code>inline std::string ILLIXR::sqlite_thread::prep_insert_str () \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-process","title":"function process","text":"<pre><code>inline void ILLIXR::sqlite_thread::process (\n    const std::vector&lt; record &gt; &amp; record_batch,\n    std::size_t batch_size\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-pull_queue","title":"function pull_queue","text":"<pre><code>inline void ILLIXR::sqlite_thread::pull_queue () \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-put_queue-12","title":"function put_queue [1/2]","text":"<pre><code>inline void ILLIXR::sqlite_thread::put_queue (\n    const std::vector&lt; record &gt; &amp; buffer_in\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-put_queue-22","title":"function put_queue [2/2]","text":"<pre><code>inline void ILLIXR::sqlite_thread::put_queue (\n    const record &amp; record_in\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-sqlite_thread","title":"function sqlite_thread","text":"<pre><code>inline explicit ILLIXR::sqlite_thread::sqlite_thread (\n    const record_header &amp; rh_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-sqlite_thread_1","title":"function ~sqlite_thread","text":"<pre><code>inline ILLIXR::sqlite_thread::~sqlite_thread () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/sqlite_record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1stdout__record__logger/","title":"Class ILLIXR::stdout_record_logger","text":"<p>ClassList &gt; ILLIXR &gt; stdout_record_logger</p> <p>Inherits the following classes: ILLIXR::record_logger</p>"},{"location":"api/classILLIXR_1_1stdout__record__logger/#public-functions-inherited-from-illixrrecord_logger","title":"Public Functions inherited from ILLIXR::record_logger","text":"<p>See ILLIXR::record_logger</p> Type Name virtual void log (const record &amp; r) = 0Writes one log record. virtual void log (const std::vector&lt; record &gt; &amp; rs) Writes many of the same type of log record. ~record_logger () override"},{"location":"api/classILLIXR_1_1stdout__record__logger/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1stdout__record__logger/#protected-functions","title":"Protected Functions","text":"Type Name virtual void log (const record &amp; r) override"},{"location":"api/classILLIXR_1_1stdout__record__logger/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1stdout__record__logger/#function-log","title":"function log","text":"<pre><code>inline virtual void ILLIXR::stdout_record_logger::log (\n    const record &amp; r\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/stdout_record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1stoplight/","title":"Class ILLIXR::stoplight","text":"<p>ClassList &gt; ILLIXR &gt; stoplight</p> <p>Start/stop synchronization for the whole application. More...</p> <ul> <li><code>#include &lt;stoplight.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1stoplight/#public-functions","title":"Public Functions","text":"Type Name bool check_should_stop () const bool check_shutdown_complete () const void signal_ready ()  void signal_should_stop ()  void signal_shutdown_complete ()  void wait_for_ready () const void wait_for_shutdown_complete () const"},{"location":"api/classILLIXR_1_1stoplight/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1stoplight/#detailed-description","title":"Detailed Description","text":"<p>Threads should: * Do initialization actions. * Wait for ready() * Do their main work in a loop until should_stop(). * Do their shutdown actions.</p> <p>The main thread should: * Construct and start all plugins and construct all services. * Set ready(). * Wait for shutdown_complete().</p> <p>The stopping thread should: * Someone should set should_stop(). * stop() and destruct each plugin and destruct each service. * Set shutdown_complete(). </p>"},{"location":"api/classILLIXR_1_1stoplight/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1stoplight/#function-check_should_stop","title":"function check_should_stop","text":"<pre><code>inline bool ILLIXR::stoplight::check_should_stop () const\n</code></pre>"},{"location":"api/classILLIXR_1_1stoplight/#function-check_shutdown_complete","title":"function check_shutdown_complete","text":"<pre><code>inline bool ILLIXR::stoplight::check_shutdown_complete () const\n</code></pre>"},{"location":"api/classILLIXR_1_1stoplight/#function-signal_ready","title":"function signal_ready","text":"<pre><code>inline void ILLIXR::stoplight::signal_ready () \n</code></pre>"},{"location":"api/classILLIXR_1_1stoplight/#function-signal_should_stop","title":"function signal_should_stop","text":"<pre><code>inline void ILLIXR::stoplight::signal_should_stop () \n</code></pre>"},{"location":"api/classILLIXR_1_1stoplight/#function-signal_shutdown_complete","title":"function signal_shutdown_complete","text":"<pre><code>inline void ILLIXR::stoplight::signal_shutdown_complete () \n</code></pre>"},{"location":"api/classILLIXR_1_1stoplight/#function-wait_for_ready","title":"function wait_for_ready","text":"<pre><code>inline void ILLIXR::stoplight::wait_for_ready () const\n</code></pre>"},{"location":"api/classILLIXR_1_1stoplight/#function-wait_for_shutdown_complete","title":"function wait_for_shutdown_complete","text":"<pre><code>inline void ILLIXR::stoplight::wait_for_shutdown_complete () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/stoplight.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard/","title":"Class ILLIXR::switchboard","text":"<p>ClassList &gt; ILLIXR &gt; switchboard</p> <p>A manager for typesafe, threadsafe, named event-streams (called topics). More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1switchboard/#classes","title":"Classes","text":"Type Name class buffered_reader &lt;typename Specific_event&gt; class event Virtual class for event types. class event_wrapper &lt;typename Underlying_type&gt;Helper class for making event types. class network_writer &lt;typename Serializable_event&gt; class reader &lt;typename Specific_event&gt;A handle which can read the latest event on a topic. class writer &lt;typename Specific_event&gt;A handle which can publish events to a topic."},{"location":"api/classILLIXR_1_1switchboard/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; Specific_event &gt; ptr The type of shared pointer returned by switchboard."},{"location":"api/classILLIXR_1_1switchboard/#public-attributes","title":"Public Attributes","text":"Type Name coordinate_system root_coordinates"},{"location":"api/classILLIXR_1_1switchboard/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; std::string &gt; env_names () constGet a vector of the currently known environment variables. buffered_reader&lt; Specific_event &gt; get_buffered_reader (const std::string &amp; topic_name)  std::string get_env (const std::string &amp; var, std::string _default=\"\") Switchboard access point for environment variables. bool get_env_bool (const std::string &amp; var, const std::string &amp; def=\"false\") Get the boolean value of the given environment variable. const char * get_env_char (const std::string &amp; var, const std::string _default=\"\") Get a char* of the given environment variable. network_writer&lt; Specific_event &gt; get_network_writer (const std::string &amp; topic_name, network::topic_config config={})  reader&lt; Specific_event &gt; get_reader (const std::string &amp; topic_name) Gets a handle to read to the latest value from the topic <code>topic_name</code> . topic &amp; get_topic (const std::string &amp; topic_name)  writer&lt; Specific_event &gt; get_writer (const std::string &amp; topic_name) Gets a handle to publish to the topic <code>topic_name</code> . void schedule (plugin_id_t plugin_id, std::string topic_name, std::function&lt; void(ptr&lt; const Specific_event &gt; &amp;&amp;, std::size_t)&gt; fn) Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . void set_env (const std::string &amp; var, const std::string &amp; val) Set the local environment variable to the given value. void stop () Stops calling switchboard callbacks. switchboard (const phonebook * pb)  bool topic_exists (const std::string &amp; topic_name)"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1switchboard/#detailed-description","title":"Detailed Description","text":"<ul> <li>Writing: One can write to a topic (in any thread) through the object returned by <code>get_writer()</code>.</li> <li>There are two ways of reading: asynchronous reading and synchronous reading:</li> <li>Asynchronous reading returns the most-recent event on the topic (idempotently). One can do this through (in any thread) the object returned by <code>get_reader()</code>.</li> <li>Synchronous reading schedules a callback to be executed on every event which gets published. One can schedule computation by <code>schedule()</code>, which will run the computation in a thread managed by switchboard.</li> </ul> <pre><code>// Get a reader on topic1\nswitchboard::reader&lt;topic1_type&gt; topic1 = switchboard.get_reader&lt;topic1_type&gt;(\"topic1\");\n\n// Get a writer on topic2\nswitchboard::writer&lt;topic2_type&gt; topic2 = switchboard.get_writer&lt;topic2_type&gt;(\"topic2\");\n\nwhile (true) {\n    // Read topic 1\n    switchboard::ptr&lt;topic1_type&gt; event1 = topic1.get_rw();\n\n    // Write to topic 2 using topic 1 input\n    topic2.put(topic2.allocate&lt;topic2_type&gt;( do_something(event1-&gt;foo) ));\n}\n\n// Read topic 3 synchronously\nswitchboard.schedule&lt;topic3_type&gt;(plugin_id, \"topic3\", [&amp;](switchboard::ptr&lt;topic3_type&gt; event3, std::size_t it) {\n    // This is a lambda expression\n    // https://en.cppreference.com/w/cpp/language/lambda\n    std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3-&gt;foo &lt;&lt; \" for iteration \" &lt;&lt; it &lt;&lt; std::endl;\n});\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#typedef-ptr","title":"typedef ptr","text":"<p>The type of shared pointer returned by switchboard. <pre><code>using ILLIXR::switchboard::ptr =  std::shared_ptr&lt;Specific_event&gt;;\n</code></pre></p> <p>TODO: Make this agnostic to the type of <code>ptr</code> Currently, it depends on <code>ptr</code> == shared_ptr </p>"},{"location":"api/classILLIXR_1_1switchboard/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#variable-root_coordinates","title":"variable root_coordinates","text":"<pre><code>coordinate_system ILLIXR::switchboard::root_coordinates;\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#function-env_names","title":"function env_names","text":"<p>Get a vector of the currently known environment variables. <pre><code>inline std::vector&lt; std::string &gt; ILLIXR::switchboard::env_names () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_buffered_reader","title":"function get_buffered_reader","text":"<pre><code>template&lt;typename Specific_event&gt;\ninline buffered_reader&lt; Specific_event &gt; ILLIXR::switchboard::get_buffered_reader (\n    const std::string &amp; topic_name\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_env","title":"function get_env","text":"<p>Switchboard access point for environment variables. <pre><code>inline std::string ILLIXR::switchboard::get_env (\n    const std::string &amp; var,\n    std::string _default=\"\"\n) \n</code></pre></p> <p>If the given variable <code>var</code> has a non-empty entry in the map, that value is returned. If the entry is empty then the system getenv is called. If this is non-empty then that value is stored and returned, otherwise the default value is returned (not stored). </p>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_env_bool","title":"function get_env_bool","text":"<p>Get the boolean value of the given environment variable. <pre><code>inline bool ILLIXR::switchboard::get_env_bool (\n    const std::string &amp; var,\n    const std::string &amp; def=\"false\"\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_env_char","title":"function get_env_char","text":"<p>Get a char* of the given environment variable. <pre><code>inline const char * ILLIXR::switchboard::get_env_char (\n    const std::string &amp; var,\n    const std::string _default=\"\"\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_network_writer","title":"function get_network_writer","text":"<pre><code>template&lt;typename Specific_event&gt;\ninline network_writer&lt; Specific_event &gt; ILLIXR::switchboard::get_network_writer (\n    const std::string &amp; topic_name,\n    network::topic_config config={}\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_reader","title":"function get_reader","text":"<p>Gets a handle to read to the latest value from the topic <code>topic_name</code> . <pre><code>template&lt;typename Specific_event&gt;\ninline reader &lt; Specific_event &gt; ILLIXR::switchboard::get_reader (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_topic","title":"function get_topic","text":"<pre><code>inline topic &amp; ILLIXR::switchboard::get_topic (\n    const std::string &amp; topic_name\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_writer","title":"function get_writer","text":"<p>Gets a handle to publish to the topic <code>topic_name</code> . <pre><code>template&lt;typename Specific_event&gt;\ninline writer &lt; Specific_event &gt; ILLIXR::switchboard::get_writer (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-schedule","title":"function schedule","text":"<p>Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . <pre><code>template&lt;typename Specific_event&gt;\ninline void ILLIXR::switchboard::schedule (\n    plugin_id_t plugin_id,\n    std::string topic_name,\n    std::function&lt; void( ptr &lt; const Specific_event &gt; &amp;&amp;, std::size_t)&gt; fn\n) \n</code></pre></p> <p>Switchboard maintains a threadpool to call <code>fn</code>.</p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>if</code> topic already exists and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-set_env","title":"function set_env","text":"<p>Set the local environment variable to the given value. <pre><code>inline void ILLIXR::switchboard::set_env (\n    const std::string &amp; var,\n    const std::string &amp; val\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard/#function-stop","title":"function stop","text":"<p>Stops calling switchboard callbacks. <pre><code>inline void ILLIXR::switchboard::stop () \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Leave topics in place, so existing reader/writer handles will not crash. </p>"},{"location":"api/classILLIXR_1_1switchboard/#function-switchboard","title":"function switchboard","text":"<pre><code>inline explicit ILLIXR::switchboard::switchboard (\n    const phonebook * pb\n) \n</code></pre> <p>If <code>pb</code> is null, then logging is disabled. </p>"},{"location":"api/classILLIXR_1_1switchboard/#function-topic_exists","title":"function topic_exists","text":"<pre><code>inline bool ILLIXR::switchboard::topic_exists (\n    const std::string &amp; topic_name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/","title":"Class ILLIXR::switchboard::buffered_reader","text":"<p>template &lt;typename Specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; buffered_reader</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#public-functions","title":"Public Functions","text":"Type Name buffered_reader (topic &amp; topic)  virtual ptr&lt; const Specific_event &gt; dequeue ()  size_t size () const"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#function-buffered_reader","title":"function buffered_reader","text":"<pre><code>inline explicit ILLIXR::switchboard::buffered_reader::buffered_reader (\n    topic &amp; topic\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#function-dequeue","title":"function dequeue","text":"<pre><code>inline virtual ptr &lt; const Specific_event &gt; ILLIXR::switchboard::buffered_reader::dequeue () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#function-size","title":"function size","text":"<pre><code>inline size_t ILLIXR::switchboard::buffered_reader::size () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1coordinate__system/","title":"Class ILLIXR::switchboard::coordinate_system","text":"<p>ClassList &gt; coordinate_system</p> <p>Base coordinate system. More...</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1coordinate__system/#public-functions","title":"Public Functions","text":"Type Name coordinate_system ()  const Eigen::Quaternionf &amp; orientation () const const Eigen::Vector3f &amp; position () const"},{"location":"api/classILLIXR_1_1switchboard_1_1coordinate__system/#detailed-description","title":"Detailed Description","text":"<p>This class reads in and hold the world coordinate system origin. The origin can be provided by the WCS_ORIGIN environment/yaml variable and can be specified in one of three ways</p> <ul> <li>a set of 3 comma separated values, representing only the origin in x, y, and z coordinates</li> <li>a set of 4 comma separated values, representing only the quaternion of the origin in w, x, y, z</li> <li>a set of 7 comma seperated values, representing both the origin and its quaternion in the form x, y, z, w, wx, wy, wz</li> </ul> <p>Any component which is not given defaults to 0 (except w which is set to 1) </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1coordinate__system/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1coordinate__system/#function-coordinate_system","title":"function coordinate_system","text":"<pre><code>inline coordinate_system::coordinate_system () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1coordinate__system/#function-orientation","title":"function orientation","text":"<pre><code>inline const Eigen::Quaternionf &amp; coordinate_system::orientation () const\n</code></pre> <p>Get the orientation portion of the WCS origin </p> <p>Returns:</p> <p>Eigen::Quaternionf </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1coordinate__system/#function-position","title":"function position","text":"<pre><code>inline const Eigen::Vector3f &amp; coordinate_system::position () const\n</code></pre> <p>Get the position portion of the WCS origin </p> <p>Returns:</p> <p>Eigen::Vector3f </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/","title":"Class ILLIXR::switchboard::event","text":"<p>ClassList &gt; ILLIXR &gt; switchboard &gt; event</p> <p>Virtual class for event types. More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::data_format::cam_base_type,  ILLIXR::data_format::camera_data,  ILLIXR::data_format::compressed_frame,  ILLIXR::data_format::connection_signal,  ILLIXR::data_format::fast_pose_type,  ILLIXR::data_format::hologram_input,  ILLIXR::data_format::image_handle,  ILLIXR::data_format::imu_integrator_input,  ILLIXR::data_format::imu_raw_type,  ILLIXR::data_format::imu_type,  ILLIXR::data_format::pose_type,  ILLIXR::data_format::rendered_frame,  ILLIXR::data_format::signal_to_quad,  ILLIXR::data_format::texture_pose,  ILLIXR::switchboard::event_wrapper</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#public-functions","title":"Public Functions","text":"Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#detailed-description","title":"Detailed Description","text":"<p>Minimum requirement: Events must be destructible. Casting events from various sources to void* (aka type-punning) breaks [strict-aliasing][1] and is undefined behavior in modern C++. Therefore, we require a common supertype for all events. We will cast them to this common supertype, event* instead.</p> <p>[1] https://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1event/#function-serialize","title":"function serialize","text":"<pre><code>template&lt;typename Archive&gt;\ninline void ILLIXR::switchboard::event::serialize (\n    Archive &amp; ar,\n    const unsigned int version\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#function-event","title":"function ~event","text":"<pre><code>virtual ILLIXR::switchboard::event::~event () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/","title":"Class ILLIXR::switchboard::event_wrapper","text":"<p>template &lt;typename Underlying_type&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; event_wrapper</p> <p>Helper class for making event types. More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions","title":"Public Functions","text":"Type Name event_wrapper () = default event_wrapper (Underlying_type underlying_data)  operator Underlying_type () const Underlying_type &amp; operator* ()  const Underlying_type &amp; operator* () const"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#detailed-description","title":"Detailed Description","text":"<p>Since topic has no static type-information on the contained events, this class does not either.</p> <pre><code>event_wrapper&lt;int&gt; int_event = 5;\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-event_wrapper-12","title":"function event_wrapper [1/2]","text":"<pre><code>ILLIXR::switchboard::event_wrapper::event_wrapper () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-event_wrapper-22","title":"function event_wrapper [2/2]","text":"<pre><code>inline explicit ILLIXR::switchboard::event_wrapper::event_wrapper (\n    Underlying_type underlying_data\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator-underlying_type","title":"function operator Underlying_type","text":"<pre><code>inline explicit ILLIXR::switchboard::event_wrapper::operator Underlying_type () const\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator","title":"function operator*","text":"<pre><code>inline Underlying_type &amp; ILLIXR::switchboard::event_wrapper::operator* () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator_1","title":"function operator*","text":"<pre><code>inline const Underlying_type &amp; ILLIXR::switchboard::event_wrapper::operator* () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1network__writer/","title":"Class ILLIXR::switchboard::network_writer","text":"<p>template &lt;typename Serializable_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; network_writer</p> <p>Inherits the following classes: ILLIXR::switchboard::writer</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1network__writer/#public-functions","title":"Public Functions","text":"Type Name network_writer (topic &amp; topic, ptr&lt; network::network_backend &gt; backend=nullptr, const network::topic_config &amp; config={})  void put (ptr&lt; Serializable_event &gt; &amp;&amp; this_specific_event) override"},{"location":"api/classILLIXR_1_1switchboard_1_1network__writer/#public-functions-inherited-from-illixrswitchboardwriter","title":"Public Functions inherited from ILLIXR::switchboard::writer","text":"<p>See ILLIXR::switchboard::writer</p> Type Name ptr&lt; Specific_event &gt; allocate (Args &amp;&amp;... args) Like <code>new</code> /<code>malloc</code> but more efficient for this specific case. virtual void put (ptr&lt; Specific_event &gt; &amp;&amp; this_specific_event) Publish <code>ev</code> to this topic. writer (topic &amp; topic)"},{"location":"api/classILLIXR_1_1switchboard_1_1network__writer/#protected-attributes-inherited-from-illixrswitchboardwriter","title":"Protected Attributes inherited from ILLIXR::switchboard::writer","text":"<p>See ILLIXR::switchboard::writer</p> Type Name topic &amp; topic_"},{"location":"api/classILLIXR_1_1switchboard_1_1network__writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1network__writer/#function-network_writer","title":"function network_writer","text":"<pre><code>inline explicit ILLIXR::switchboard::network_writer::network_writer (\n    topic &amp; topic,\n    ptr &lt; network::network_backend &gt; backend=nullptr,\n    const network::topic_config &amp; config={}\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1network__writer/#function-put","title":"function put","text":"<pre><code>inline void ILLIXR::switchboard::network_writer::put (\n    ptr &lt; Serializable_event &gt; &amp;&amp; this_specific_event\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/","title":"Class ILLIXR::switchboard::reader","text":"<p>template &lt;typename Specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; reader</p> <p>A handle which can read the latest event on a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; const Specific_event &gt; get_ro () constGets a non-null \"read-only\" copy of the latest value. ptr&lt; const Specific_event &gt; get_ro_nullable () noexcept constGets a \"read-only\" copy of the latest value. ptr&lt; Specific_event &gt; get_rw () constGets a non-null mutable copy of the latest value. reader (topic &amp; topic)"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_ro","title":"function get_ro","text":"<p>Gets a non-null \"read-only\" copy of the latest value. <pre><code>inline ptr &lt; const Specific_event &gt; ILLIXR::switchboard::reader::get_ro () const\n</code></pre></p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If no event is on the topic yet. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_ro_nullable","title":"function get_ro_nullable","text":"<p>Gets a \"read-only\" copy of the latest value. <pre><code>inline ptr &lt; const Specific_event &gt; ILLIXR::switchboard::reader::get_ro_nullable () noexcept const\n</code></pre></p> <p>This will return null if no event is on the topic yet. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_rw","title":"function get_rw","text":"<p>Gets a non-null mutable copy of the latest value. <pre><code>inline ptr &lt; Specific_event &gt; ILLIXR::switchboard::reader::get_rw () const\n</code></pre></p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If no event is on the topic yet. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-reader","title":"function reader","text":"<pre><code>inline explicit ILLIXR::switchboard::reader::reader (\n    topic &amp; topic\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/","title":"Class ILLIXR::switchboard::topic","text":"<p>ClassList &gt; topic</p> <p>Represents a topic. More...</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#public-functions","title":"Public Functions","text":"Type Name void deserialize_and_put (std::vector&lt; char &gt; &amp; buffer, network::topic_config &amp; config)  ptr&lt; const event &gt; get () constGets a read-only copy of the most recent event on the topic. topic_buffer &amp; get_buffer ()  const std::string &amp; name ()  void put (ptr&lt; const event &gt; &amp;&amp; this_event) Publishes <code>this_event</code> to the topic. void schedule (plugin_id_t plugin_id, const std::function&lt; void(ptr&lt; const event &gt; &amp;&amp;, std::size_t)&gt; &amp; callback) Schedules <code>callback</code> on the topic (<code>plugin_id</code> is for accounting) void stop () Stop and remove all topic_subscription threads. topic (std::string name, const std::type_info &amp; ty, std::shared_ptr&lt; record_logger &gt; record_logger_)  const std::type_info &amp; ty ()"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#detailed-description","title":"Detailed Description","text":"<p>Note, this class cannot have any static type-information about the contained events because I need to hold all of the topics in a homogeneous container (can't add topic&lt;int&gt; and topic&lt;float&gt; to the same std::vector&lt;topic&lt;WHAT_GOES_HERE&gt;&gt;).</p> <p>Therefore, this class uses type-erasure, and regards all events as type <code>event</code>. I could have used <code>std::any</code> for this, but I think inheriting <code>event</code> will be slightly more efficient because it avoids a heap-allocation.</p> <p>However, this class can have dynamic type-information in ty, that gets set and checked at runtime. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-deserialize_and_put","title":"function deserialize_and_put","text":"<pre><code>inline void topic::deserialize_and_put (\n    std::vector&lt; char &gt; &amp; buffer,\n    network::topic_config &amp; config\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-get","title":"function get","text":"<p>Gets a read-only copy of the most recent event on the topic. <pre><code>inline ptr &lt; const event &gt; topic::get () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-get_buffer","title":"function get_buffer","text":"<pre><code>inline topic_buffer &amp; topic::get_buffer () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-name","title":"function name","text":"<pre><code>inline const std::string &amp; topic::name () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-put","title":"function put","text":"<p>Publishes <code>this_event</code> to the topic. <pre><code>inline void topic::put (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre></p> <p>Thread-safe * Caveat:This (circular) queue based solution may race if &gt;= N write attempts to the N-sized queue interrupt a concurrent reader (using 'get').The reader's critical section is as follows:   * Read the latest serial number   * Compute the serial's modulus   * Dereference and access the position in the queue/array</p> <p>The critical section is extremely small, so a race is unlikely, albeit possible. The probability of a data race decreases geometrically with N. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-schedule","title":"function schedule","text":"<p>Schedules <code>callback</code> on the topic (<code>plugin_id</code> is for accounting) <pre><code>inline void topic::schedule (\n    plugin_id_t plugin_id,\n    const std::function&lt; void( ptr &lt; const event &gt; &amp;&amp;, std::size_t)&gt; &amp; callback\n) \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-stop","title":"function stop","text":"<p>Stop and remove all topic_subscription threads. <pre><code>inline void topic::stop () \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-topic","title":"function topic","text":"<pre><code>inline topic::topic (\n    std::string name,\n    const std::type_info &amp; ty,\n    std::shared_ptr&lt; record_logger &gt; record_logger_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-ty","title":"function ty","text":"<pre><code>inline const std::type_info &amp; topic::ty () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/","title":"Class ILLIXR::switchboard::topic_buffer","text":"<p>ClassList &gt; topic_buffer</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; const event &gt; dequeue ()  void enqueue (ptr&lt; const event &gt; &amp;&amp; this_event)  size_t size () const topic_buffer ()"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-dequeue","title":"function dequeue","text":"<pre><code>inline ptr &lt; const event &gt; topic_buffer::dequeue () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-enqueue","title":"function enqueue","text":"<pre><code>inline void topic_buffer::enqueue (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-size","title":"function size","text":"<pre><code>inline size_t topic_buffer::size () const\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-topic_buffer","title":"function topic_buffer","text":"<pre><code>inline topic_buffer::topic_buffer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/","title":"Class ILLIXR::switchboard::topic_subscription","text":"<p>ClassList &gt; topic_subscription</p> <p>Represents a single topic_subscription (callback and queue) More...</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#public-functions","title":"Public Functions","text":"Type Name void enqueue (ptr&lt; const event &gt; &amp;&amp; this_event) Tells the subscriber about <code>this_event</code> . topic_subscription (const std::string &amp; topic_name, plugin_id_t plugin_id, std::function&lt; void(ptr&lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback, const std::shared_ptr&lt; record_logger &gt; &amp; record_logger_)"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#detailed-description","title":"Detailed Description","text":"<p>This class treats everything as <code>event</code>s (type-erased) because <code>topic</code> treats everything as <code>event</code>s.</p> <p>Each topic can have 0 or more topic_subscriptions. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#function-enqueue","title":"function enqueue","text":"<p>Tells the subscriber about <code>this_event</code> . <pre><code>inline void topic_subscription::enqueue (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#function-topic_subscription","title":"function topic_subscription","text":"<pre><code>inline topic_subscription::topic_subscription (\n    const std::string &amp; topic_name,\n    plugin_id_t plugin_id,\n    std::function&lt; void( ptr &lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback,\n    const std::shared_ptr&lt; record_logger &gt; &amp; record_logger_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/","title":"Class ILLIXR::switchboard::writer","text":"<p>template &lt;typename Specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; writer</p> <p>A handle which can publish events to a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::switchboard::network_writer,  ILLIXR::switchboard::network_writer,  ILLIXR::switchboard::network_writer</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; Specific_event &gt; allocate (Args &amp;&amp;... args) Like <code>new</code> /<code>malloc</code> but more efficient for this specific case. virtual void put (ptr&lt; Specific_event &gt; &amp;&amp; this_specific_event) Publish <code>ev</code> to this topic. writer (topic &amp; topic)"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#protected-attributes","title":"Protected Attributes","text":"Type Name topic &amp; topic_"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-allocate","title":"function allocate","text":"<p>Like <code>new</code> /<code>malloc</code> but more efficient for this specific case. <pre><code>template&lt;class... Args&gt;\ninline ptr &lt; Specific_event &gt; ILLIXR::switchboard::writer::allocate (\n    Args &amp;&amp;... args\n) \n</code></pre></p> <p>There is an optimization available which has not yet been implemented: switchboard can reuse memory from old events, like a slab allocator. Suppose module A publishes data for module B. B's deallocation through the destructor, and A's allocation through this method completes the cycle in a double-buffer (AKA swap-chain). </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-put","title":"function put","text":"<p>Publish <code>ev</code> to this topic. <pre><code>inline virtual void ILLIXR::switchboard::writer::put (\n    ptr &lt; Specific_event &gt; &amp;&amp; this_specific_event\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-writer","title":"function writer","text":"<pre><code>inline explicit ILLIXR::switchboard::writer::writer (\n    topic &amp; topic\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#variable-topic_","title":"variable topic_","text":"<pre><code>topic&amp; ILLIXR::switchboard::writer&lt; Specific_event &gt;::topic_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1tcp__network__backend/","title":"Class ILLIXR::tcp_network_backend","text":"<p>ClassList &gt; ILLIXR &gt; tcp_network_backend</p> <p>Inherits the following classes: ILLIXR::plugin,  ILLIXR::network::network_backend</p>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#public-attributes","title":"Public Attributes","text":"Type Name bool client"},{"location":"api/classILLIXR_1_1tcp__network__backend/#public-functions","title":"Public Functions","text":"Type Name bool is_topic_networked (std::string topic_name) override void read_loop (network::TCPSocket * socket)  void start_client ()  void start_server ()  void stop () override tcp_network_backend (const std::string &amp; name_, phonebook * pb_)  void topic_create (std::string topic_name, network::topic_config &amp; config) override void topic_receive (const std::string &amp; topic_name, std::vector&lt; char &gt; &amp; message)  void topic_send (std::string topic_name, std::string &amp;&amp; message) override"},{"location":"api/classILLIXR_1_1tcp__network__backend/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1tcp__network__backend/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1tcp__network__backend/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1tcp__network__backend/#variable-client","title":"variable client","text":"<pre><code>bool ILLIXR::tcp_network_backend::client;\n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-is_topic_networked","title":"function is_topic_networked","text":"<pre><code>bool ILLIXR::tcp_network_backend::is_topic_networked (\n    std::string topic_name\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-read_loop","title":"function read_loop","text":"<pre><code>void ILLIXR::tcp_network_backend::read_loop (\n    network::TCPSocket * socket\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-start_client","title":"function start_client","text":"<pre><code>void ILLIXR::tcp_network_backend::start_client () \n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-start_server","title":"function start_server","text":"<pre><code>void ILLIXR::tcp_network_backend::start_server () \n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-stop","title":"function stop","text":"<pre><code>void ILLIXR::tcp_network_backend::stop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-tcp_network_backend","title":"function tcp_network_backend","text":"<pre><code>explicit ILLIXR::tcp_network_backend::tcp_network_backend (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-topic_create","title":"function topic_create","text":"<pre><code>void ILLIXR::tcp_network_backend::topic_create (\n    std::string topic_name,\n    network::topic_config &amp; config\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-topic_receive","title":"function topic_receive","text":"<pre><code>void ILLIXR::tcp_network_backend::topic_receive (\n    const std::string &amp; topic_name,\n    std::vector&lt; char &gt; &amp; message\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1tcp__network__backend/#function-topic_send","title":"function topic_send","text":"<pre><code>void ILLIXR::tcp_network_backend::topic_send (\n    std::string topic_name,\n    std::string &amp;&amp; message\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/tcp_network_backend/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1threadloop/","title":"Class ILLIXR::threadloop","text":"<p>ClassList &gt; ILLIXR &gt; threadloop</p> <p>A reusable threadloop for plugins. More...</p> <ul> <li><code>#include &lt;threadloop.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::plugin</p> <p>Inherited by the following classes: ILLIXR::data_injection,  ILLIXR::debugview,  ILLIXR::gldemo,  ILLIXR::lighthouse,  ILLIXR::native_renderer,  ILLIXR::offline_cam,  ILLIXR::offline_imu,  ILLIXR::offload_reader,  ILLIXR::offload_rendering_client,  ILLIXR::offload_rendering_server,  ILLIXR::offload_writer,  ILLIXR::openni_plugin,  ILLIXR::openwarp_vk_plugin,  ILLIXR::server_reader,  ILLIXR::timewarp_gl,  ILLIXR::timewarp_vk_plugin,  ILLIXR::webcam,  ILLIXR::zed_camera_thread,  ILLIXR::zed_imu_thread</p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions","title":"Public Functions","text":"Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1threadloop/#protected-types","title":"Protected Types","text":"Type Name enum skip_option"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes","title":"Protected Attributes","text":"Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions","title":"Protected Functions","text":"Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1threadloop/#detailed-description","title":"Detailed Description","text":"<p>The thread continuously runs <code>_p_one_iteration()</code> and is stoppable by <code>stop()</code>.</p> <p>This factors out the common code I noticed in many different plugins. </p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-internal_stop","title":"function internal_stop","text":"<p>Stops the thread. <pre><code>inline virtual void ILLIXR::threadloop::internal_stop () \n</code></pre></p> <p>A thread should call this if it wants to stop itself (due to out of data for example). </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-start","title":"function start","text":"<p>Starts the thread. <pre><code>inline virtual void ILLIXR::threadloop::start () override\n</code></pre></p> <p>This cannot go into the constructor because it starts a thread which calls <code>_p_one_iteration()</code> which is virtual in the child class.</p> <p>Calling a virtual child method from the parent constructor will not work as expected 1. Instead, the ISO CPP FAQ recommends calling a <code>start()</code> method immediately after construction 2. </p> <p>Implements ILLIXR::plugin::start</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-stop","title":"function stop","text":"<p>Joins the thread. <pre><code>inline virtual void ILLIXR::threadloop::stop () override\n</code></pre></p> <p>Must have already stopped the stoplight. </p> <p>Implements ILLIXR::plugin::stop</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop","title":"function threadloop","text":"<pre><code>inline ILLIXR::threadloop::threadloop (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop_1","title":"function ~threadloop","text":"<pre><code>inline ILLIXR::threadloop::~threadloop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#enum-skip_option","title":"enum skip_option","text":"<pre><code>enum ILLIXR::threadloop::skip_option {\n    run,\n    skip_and_spin,\n    skip_and_yield,\n    stop\n};\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#variable-iteration_no","title":"variable iteration_no","text":"<pre><code>std::size_t ILLIXR::threadloop::iteration_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#variable-skip_no","title":"variable skip_no","text":"<pre><code>std::size_t ILLIXR::threadloop::skip_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Override with the computation the thread does every loop. <pre><code>virtual void ILLIXR::threadloop::_p_one_iteration () = 0\n</code></pre></p> <p>This gets called in rapid succession. </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_should_skip","title":"function _p_should_skip","text":"<p>Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ <pre><code>inline virtual skip_option ILLIXR::threadloop::_p_should_skip () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<p>Gets called at setup time, from the new thread. <pre><code>inline virtual void ILLIXR::threadloop::_p_thread_setup () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-should_terminate","title":"function should_terminate","text":"<p>Whether the thread has been asked to terminate. <pre><code>inline bool ILLIXR::threadloop::should_terminate () \n</code></pre></p> <p>Check this before doing long-running computation; it makes termination more responsive. </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/threadloop.hpp</code></p>"},{"location":"api/classILLIXR_1_1time__point/","title":"Class ILLIXR::time_point","text":"<p>ClassList &gt; ILLIXR &gt; time_point</p>"},{"location":"api/classILLIXR_1_1time__point/#public-types","title":"Public Types","text":"Type Name typedef clock_duration_ duration"},{"location":"api/classILLIXR_1_1time__point/#public-attributes","title":"Public Attributes","text":"Type Name duration time_since_epoch_"},{"location":"api/classILLIXR_1_1time__point/#public-functions","title":"Public Functions","text":"Type Name time_point &amp; operator+= (const duration &amp; d)  time_point &amp; operator-= (const duration &amp; d)  time_point () = default constexpr time_point (const duration &amp; time_since_epoch)  duration time_since_epoch () const"},{"location":"api/classILLIXR_1_1time__point/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1time__point/#typedef-duration","title":"typedef duration","text":"<pre><code>using ILLIXR::time_point::duration =  clock_duration_;\n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1time__point/#variable-time_since_epoch_","title":"variable time_since_epoch_","text":"<pre><code>duration ILLIXR::time_point::time_since_epoch_;\n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1time__point/#function-operator","title":"function operator+=","text":"<pre><code>inline time_point &amp; ILLIXR::time_point::operator+= (\n    const duration &amp; d\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-operator-","title":"function operator-=","text":"<pre><code>inline time_point &amp; ILLIXR::time_point::operator-= (\n    const duration &amp; d\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-time_point-12","title":"function time_point [1/2]","text":"<pre><code>ILLIXR::time_point::time_point () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-time_point-22","title":"function time_point [2/2]","text":"<pre><code>inline explicit constexpr ILLIXR::time_point::time_point (\n    const duration &amp; time_since_epoch\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-time_since_epoch","title":"function time_since_epoch","text":"<pre><code>inline duration ILLIXR::time_point::time_since_epoch () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/relative_clock.hpp</code></p>"},{"location":"api/classILLIXR_1_1timewarp__gl/","title":"Class ILLIXR::timewarp_gl","text":"<p>ClassList &gt; ILLIXR &gt; timewarp_gl</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1timewarp__gl/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override void _p_thread_setup () override void _prepare_rendering ()  void _setup ()  timewarp_gl (const std::string &amp; name, phonebook * pb)  void warp (const switchboard::ptr&lt; const data_format::rendered_frame &gt; &amp; most_recent_frame)"},{"location":"api/classILLIXR_1_1timewarp__gl/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1timewarp__gl/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1timewarp__gl/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1timewarp__gl/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1timewarp__gl/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1timewarp__gl/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1timewarp__gl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1timewarp__gl/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::timewarp_gl::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__gl/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::timewarp_gl::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__gl/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<pre><code>void ILLIXR::timewarp_gl::_p_thread_setup () override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__gl/#function-_prepare_rendering","title":"function _prepare_rendering","text":"<pre><code>void ILLIXR::timewarp_gl::_prepare_rendering () \n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__gl/#function-_setup","title":"function _setup","text":"<pre><code>void ILLIXR::timewarp_gl::_setup () \n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__gl/#function-timewarp_gl","title":"function timewarp_gl","text":"<pre><code>ILLIXR::timewarp_gl::timewarp_gl (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__gl/#function-warp","title":"function warp","text":"<pre><code>void ILLIXR::timewarp_gl::warp (\n    const switchboard::ptr &lt; const data_format::rendered_frame &gt; &amp; most_recent_frame\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1timewarp__vk/","title":"Class ILLIXR::timewarp_vk","text":"<p>ClassList &gt; ILLIXR &gt; timewarp_vk</p> <p>Inherits the following classes: ILLIXR::vulkan::timewarp</p>"},{"location":"api/classILLIXR_1_1timewarp__vk/#public-functions","title":"Public Functions","text":"Type Name void destroy () override void initialize ()  void partial_destroy ()  void record_command_buffer (VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) override void setup (VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool, bool input_texture_vulkan_coordinates_in) override timewarp_vk (const phonebook * pb)  void update_uniforms (const data_format::pose_type &amp; render_pose) override"},{"location":"api/classILLIXR_1_1timewarp__vk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1timewarp__vk/#function-destroy","title":"function destroy","text":"<pre><code>void ILLIXR::timewarp_vk::destroy () override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk/#function-initialize","title":"function initialize","text":"<pre><code>void ILLIXR::timewarp_vk::initialize () \n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk/#function-partial_destroy","title":"function partial_destroy","text":"<pre><code>void ILLIXR::timewarp_vk::partial_destroy () \n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk/#function-record_command_buffer","title":"function record_command_buffer","text":"<pre><code>void ILLIXR::timewarp_vk::record_command_buffer (\n    VkCommandBuffer commandBuffer,\n    VkFramebuffer framebuffer,\n    int buffer_ind,\n    bool left\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk/#function-setup","title":"function setup","text":"<pre><code>void ILLIXR::timewarp_vk::setup (\n    VkRenderPass render_pass,\n    uint32_t subpass,\n    std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool,\n    bool input_texture_vulkan_coordinates_in\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk/#function-timewarp_vk","title":"function timewarp_vk","text":"<pre><code>explicit ILLIXR::timewarp_vk::timewarp_vk (\n    const phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk/#function-update_uniforms","title":"function update_uniforms","text":"<pre><code>void ILLIXR::timewarp_vk::update_uniforms (\n    const data_format::pose_type &amp; render_pose\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/timewarp_vk.hpp</code></p>"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/","title":"Class ILLIXR::timewarp_vk_plugin","text":"<p>ClassList &gt; ILLIXR &gt; timewarp_vk_plugin</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override timewarp_vk_plugin (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::timewarp_vk_plugin::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::timewarp_vk_plugin::_p_should_skip () override\n</code></pre>"},{"location":"api/classILLIXR_1_1timewarp__vk__plugin/#function-timewarp_vk_plugin","title":"function timewarp_vk_plugin","text":"<pre><code>ILLIXR::timewarp_vk_plugin::timewarp_vk_plugin (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1video__decoder/","title":"Class ILLIXR::video_decoder","text":"<p>ClassList &gt; ILLIXR &gt; video_decoder</p>"},{"location":"api/classILLIXR_1_1video__decoder/#public-functions","title":"Public Functions","text":"Type Name GstFlowReturn cb_appsink (GstElement * sink)  void enqueue (std::string &amp; img0, std::string &amp; img1)  void init ()  video_decoder (std::function&lt; void(cv::Mat &amp;&amp;, cv::Mat &amp;&amp;)&gt; callback)"},{"location":"api/classILLIXR_1_1video__decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1video__decoder/#function-cb_appsink","title":"function cb_appsink","text":"<pre><code>GstFlowReturn ILLIXR::video_decoder::cb_appsink (\n    GstElement * sink\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1video__decoder/#function-enqueue","title":"function enqueue","text":"<pre><code>void ILLIXR::video_decoder::enqueue (\n    std::string &amp; img0,\n    std::string &amp; img1\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1video__decoder/#function-init","title":"function init","text":"<pre><code>void ILLIXR::video_decoder::init () \n</code></pre>"},{"location":"api/classILLIXR_1_1video__decoder/#function-video_decoder","title":"function video_decoder","text":"<pre><code>explicit ILLIXR::video_decoder::video_decoder (\n    std::function&lt; void(cv::Mat &amp;&amp;, cv::Mat &amp;&amp;)&gt; callback\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/video_decoder.hpp</code></p>"},{"location":"api/classILLIXR_1_1video__encoder/","title":"Class ILLIXR::video_encoder","text":"<p>ClassList &gt; ILLIXR &gt; video_encoder</p>"},{"location":"api/classILLIXR_1_1video__encoder/#public-functions","title":"Public Functions","text":"Type Name GstFlowReturn cb_appsink (GstElement * sink)  void enqueue (cv::Mat &amp; img0, cv::Mat &amp; img1)  void init ()  video_encoder (std::function&lt; void(const GstMapInfo &amp;, const GstMapInfo &amp;)&gt; callback)"},{"location":"api/classILLIXR_1_1video__encoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1video__encoder/#function-cb_appsink","title":"function cb_appsink","text":"<pre><code>GstFlowReturn ILLIXR::video_encoder::cb_appsink (\n    GstElement * sink\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1video__encoder/#function-enqueue","title":"function enqueue","text":"<pre><code>void ILLIXR::video_encoder::enqueue (\n    cv::Mat &amp; img0,\n    cv::Mat &amp; img1\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1video__encoder/#function-init","title":"function init","text":"<pre><code>void ILLIXR::video_encoder::init () \n</code></pre>"},{"location":"api/classILLIXR_1_1video__encoder/#function-video_encoder","title":"function video_encoder","text":"<pre><code>explicit ILLIXR::video_encoder::video_encoder (\n    std::function&lt; void(const GstMapInfo &amp;, const GstMapInfo &amp;)&gt; callback\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/video_encoder.hpp</code></p>"},{"location":"api/classILLIXR_1_1viewer/","title":"Class ILLIXR::viewer","text":"<p>ClassList &gt; ILLIXR &gt; viewer</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1viewer/#public-functions","title":"Public Functions","text":"Type Name void make_gui (const switchboard::ptr&lt; const data_format::ht::ht_frame &gt; &amp; frame)  void start () override viewer (const std::string &amp; name_, phonebook * pb_)  ~viewer () override"},{"location":"api/classILLIXR_1_1viewer/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1viewer/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1viewer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1viewer/#function-make_gui","title":"function make_gui","text":"<pre><code>void ILLIXR::viewer::make_gui (\n    const switchboard::ptr &lt; const data_format::ht::ht_frame &gt; &amp; frame\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1viewer/#function-start","title":"function start","text":"<pre><code>void ILLIXR::viewer::start () override\n</code></pre>"},{"location":"api/classILLIXR_1_1viewer/#function-viewer","title":"function viewer","text":"<pre><code>ILLIXR::viewer::viewer (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1viewer/#function-viewer_1","title":"function ~viewer","text":"<pre><code>ILLIXR::viewer::~viewer () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking/viewer/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1vkdemo/","title":"Class ILLIXR::vkdemo","text":"<p>ClassList &gt; ILLIXR &gt; vkdemo</p> <p>Inherits the following classes: ILLIXR::vulkan::app</p>"},{"location":"api/classILLIXR_1_1vkdemo/#public-functions","title":"Public Functions","text":"Type Name void destroy () override void initialize ()  bool is_external () override void record_command_buffer (VkCommandBuffer command_buffer, VkFramebuffer frame_buffer, int buffer_ind, bool left) override void setup (VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; _) override void update_uniforms (const data_format::pose_type &amp; fp) override vkdemo (const phonebook *const pb)"},{"location":"api/classILLIXR_1_1vkdemo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1vkdemo/#function-destroy","title":"function destroy","text":"<pre><code>void ILLIXR::vkdemo::destroy () override\n</code></pre>"},{"location":"api/classILLIXR_1_1vkdemo/#function-initialize","title":"function initialize","text":"<pre><code>void ILLIXR::vkdemo::initialize () \n</code></pre>"},{"location":"api/classILLIXR_1_1vkdemo/#function-is_external","title":"function is_external","text":"<pre><code>inline bool ILLIXR::vkdemo::is_external () override\n</code></pre>"},{"location":"api/classILLIXR_1_1vkdemo/#function-record_command_buffer","title":"function record_command_buffer","text":"<pre><code>void ILLIXR::vkdemo::record_command_buffer (\n    VkCommandBuffer command_buffer,\n    VkFramebuffer frame_buffer,\n    int buffer_ind,\n    bool left\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1vkdemo/#function-setup","title":"function setup","text":"<pre><code>void ILLIXR::vkdemo::setup (\n    VkRenderPass render_pass,\n    uint32_t subpass,\n    std::shared_ptr&lt; vulkan::buffer_pool&lt; data_format::fast_pose_type &gt; &gt; _\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1vkdemo/#function-update_uniforms","title":"function update_uniforms","text":"<pre><code>void ILLIXR::vkdemo::update_uniforms (\n    const data_format::pose_type &amp; fp\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1vkdemo/#function-vkdemo","title":"function vkdemo","text":"<pre><code>explicit ILLIXR::vkdemo::vkdemo (\n    const phonebook *const pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.hpp</code></p>"},{"location":"api/classILLIXR_1_1vkdemo__plugin/","title":"Class ILLIXR::vkdemo_plugin","text":"<p>ClassList &gt; ILLIXR &gt; vkdemo_plugin</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1vkdemo__plugin/#public-functions","title":"Public Functions","text":"Type Name void start () override vkdemo_plugin (const std::string &amp; name, phonebook * pb)"},{"location":"api/classILLIXR_1_1vkdemo__plugin/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1vkdemo__plugin/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1vkdemo__plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1vkdemo__plugin/#function-start","title":"function start","text":"<pre><code>void ILLIXR::vkdemo_plugin::start () override\n</code></pre>"},{"location":"api/classILLIXR_1_1vkdemo__plugin/#function-vkdemo_plugin","title":"function vkdemo_plugin","text":"<pre><code>ILLIXR::vkdemo_plugin::vkdemo_plugin (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.hpp</code></p>"},{"location":"api/classILLIXR_1_1vulkan_1_1app/","title":"Class ILLIXR::vulkan::app","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; app</p> <p>Inherits the following classes: ILLIXR::vulkan::render_pass</p> <p>Inherited by the following classes: ILLIXR::offload_rendering_client,  ILLIXR::vkdemo</p>"},{"location":"api/classILLIXR_1_1vulkan_1_1app/#public-functions","title":"Public Functions","text":"Type Name virtual void setup (VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt; buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool) = 0Setup the app render pass and initailize required Vulkan resources."},{"location":"api/classILLIXR_1_1vulkan_1_1app/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1vulkan_1_1app/#function-setup","title":"function setup","text":"<p>Setup the app render pass and initailize required Vulkan resources. <pre><code>virtual void ILLIXR::vulkan::app::setup (\n    VkRenderPass render_pass,\n    uint32_t subpass,\n    std::shared_ptr&lt; buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>render_pass</code> The render pass to use. </li> <li><code>subpass</code> The subpass to use. </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/render_pass.hpp</code></p>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/","title":"Class ILLIXR::vulkan::display_provider","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; display_provider</p> <p>A display sink is a service that can display the rendered images to the screen. More...</p> <ul> <li><code>#include &lt;display_provider.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; const char * &gt; enabled_device_extensions_ std::vector&lt; const char * &gt; enabled_instance_extensions_ VkPhysicalDeviceFeatures2 features_ std::unordered_map&lt; queue::queue_type, queue &gt; queues_ VkExtent2D swapchain_extent_   = <code>{display\\_params::width\\_pixels, display\\_params::height\\_pixels}</code> VkSurfaceFormatKHR swapchain_image_format_ std::vector&lt; VkImageView &gt; swapchain_image_views_ std::vector&lt; VkImage &gt; swapchain_images_ VkDevice vk_device_   = <code>VK\\_NULL\\_HANDLE</code> VkInstance vk_instance_   = <code>VK\\_NULL\\_HANDLE</code> VkPhysicalDevice vk_physical_device_   = <code>VK\\_NULL\\_HANDLE</code> VkSurfaceKHR vk_surface_   = <code>VK\\_NULL\\_HANDLE</code> VkSwapchainKHR vk_swapchain_   = <code>VK\\_NULL\\_HANDLE</code> VmaAllocator vma_allocator_"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#public-functions","title":"Public Functions","text":"Type Name virtual void poll_window_events () Polls window events using whatever the windowing backend is. virtual void recreate_swapchain () Recreates the swapchain when an outdated or nonoptimal swapchain is detected. ~display_provider () override"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#detailed-description","title":"Detailed Description","text":"<p>A display sink is a service created with the necessary Vulkan resources to display the rendered images to the screen. It is created either by display_vk, a plugin that configures the Vulkan resources and swapchain, or by monado_vulkan_integration, which populate the Vulkan resources and swapchain from Monado. Previously with the GL implementation, this was not required since we were using GL and Monado was using Vulkan. </p>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-enabled_device_extensions_","title":"variable enabled_device_extensions_","text":"<pre><code>std::vector&lt;const char*&gt; ILLIXR::vulkan::display_provider::enabled_device_extensions_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-enabled_instance_extensions_","title":"variable enabled_instance_extensions_","text":"<pre><code>std::vector&lt;const char*&gt; ILLIXR::vulkan::display_provider::enabled_instance_extensions_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-features_","title":"variable features_","text":"<pre><code>VkPhysicalDeviceFeatures2 ILLIXR::vulkan::display_provider::features_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-queues_","title":"variable queues_","text":"<pre><code>std::unordered_map&lt;queue::queue_type, queue&gt; ILLIXR::vulkan::display_provider::queues_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-swapchain_extent_","title":"variable swapchain_extent_","text":"<pre><code>VkExtent2D ILLIXR::vulkan::display_provider::swapchain_extent_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-swapchain_image_format_","title":"variable swapchain_image_format_","text":"<pre><code>VkSurfaceFormatKHR ILLIXR::vulkan::display_provider::swapchain_image_format_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-swapchain_image_views_","title":"variable swapchain_image_views_","text":"<pre><code>std::vector&lt;VkImageView&gt; ILLIXR::vulkan::display_provider::swapchain_image_views_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-swapchain_images_","title":"variable swapchain_images_","text":"<pre><code>std::vector&lt;VkImage&gt; ILLIXR::vulkan::display_provider::swapchain_images_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-vk_device_","title":"variable vk_device_","text":"<pre><code>VkDevice ILLIXR::vulkan::display_provider::vk_device_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-vk_instance_","title":"variable vk_instance_","text":"<pre><code>VkInstance ILLIXR::vulkan::display_provider::vk_instance_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-vk_physical_device_","title":"variable vk_physical_device_","text":"<pre><code>VkPhysicalDevice ILLIXR::vulkan::display_provider::vk_physical_device_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-vk_surface_","title":"variable vk_surface_","text":"<pre><code>VkSurfaceKHR ILLIXR::vulkan::display_provider::vk_surface_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-vk_swapchain_","title":"variable vk_swapchain_","text":"<pre><code>VkSwapchainKHR ILLIXR::vulkan::display_provider::vk_swapchain_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#variable-vma_allocator_","title":"variable vma_allocator_","text":"<pre><code>VmaAllocator ILLIXR::vulkan::display_provider::vma_allocator_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#function-poll_window_events","title":"function poll_window_events","text":"<p>Polls window events using whatever the windowing backend is. <pre><code>inline virtual void ILLIXR::vulkan::display_provider::poll_window_events () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#function-recreate_swapchain","title":"function recreate_swapchain","text":"<p>Recreates the swapchain when an outdated or nonoptimal swapchain is detected. <pre><code>inline virtual void ILLIXR::vulkan::display_provider::recreate_swapchain () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1vulkan_1_1display__provider/#function-display_provider","title":"function ~display_provider","text":"<pre><code>ILLIXR::vulkan::display_provider::~display_provider () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/display_provider.hpp</code></p>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/","title":"Class ILLIXR::vulkan::render_pass","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; render_pass</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p> <p>Inherited by the following classes: ILLIXR::vulkan::app,  ILLIXR::vulkan::timewarp</p>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#public-attributes","title":"Public Attributes","text":"Type Name VkPipeline pipeline_   = <code>VK\\_NULL\\_HANDLE</code>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#public-functions","title":"Public Functions","text":"Type Name virtual void destroy () Destroy the render pass and free all Vulkan resources. virtual bool is_external () = 0 virtual void record_command_buffer (VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) = 0Record a command buffer for a given eye. virtual void update_uniforms (const data_format::pose_type &amp; render_pose) Update the uniforms for the render pass. ~render_pass () override"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#variable-pipeline_","title":"variable pipeline_","text":"<pre><code>VkPipeline ILLIXR::vulkan::render_pass::pipeline_;\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#function-destroy","title":"function destroy","text":"<p>Destroy the render pass and free all Vulkan resources. <pre><code>inline virtual void ILLIXR::vulkan::render_pass::destroy () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#function-is_external","title":"function is_external","text":"<pre><code>virtual bool ILLIXR::vulkan::render_pass::is_external () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#function-record_command_buffer","title":"function record_command_buffer","text":"<p>Record a command buffer for a given eye. <pre><code>virtual void ILLIXR::vulkan::render_pass::record_command_buffer (\n    VkCommandBuffer commandBuffer,\n    VkFramebuffer framebuffer,\n    int buffer_ind,\n    bool left\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>commandBuffer</code> The command buffer to record to. </li> <li><code>buffer_ind</code> The index of the buffer to use. </li> <li><code>left</code> 0 for left eye, 1 for right eye. </li> </ul>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#function-update_uniforms","title":"function update_uniforms","text":"<p>Update the uniforms for the render pass. <pre><code>inline virtual void ILLIXR::vulkan::render_pass::update_uniforms (\n    const data_format::pose_type &amp; render_pose\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>render_pose</code> For an app pass, this is the pose to use for rendering. For a timewarp pass, this is the pose previously supplied to the app pass. </li> </ul>"},{"location":"api/classILLIXR_1_1vulkan_1_1render__pass/#function-render_pass","title":"function ~render_pass","text":"<pre><code>ILLIXR::vulkan::render_pass::~render_pass () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/render_pass.hpp</code></p>"},{"location":"api/classILLIXR_1_1vulkan_1_1timewarp/","title":"Class ILLIXR::vulkan::timewarp","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; timewarp</p> <p>Inherits the following classes: ILLIXR::vulkan::render_pass</p> <p>Inherited by the following classes: ILLIXR::offload_rendering_server,  ILLIXR::openwarp_vk,  ILLIXR::timewarp_vk</p>"},{"location":"api/classILLIXR_1_1vulkan_1_1timewarp/#public-functions","title":"Public Functions","text":"Type Name virtual void setup (VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt; buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool, bool input_texture_vulkan_coordinates) = 0Setup the timewarp render pass and initailize required Vulkan resources."},{"location":"api/classILLIXR_1_1vulkan_1_1timewarp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1vulkan_1_1timewarp/#function-setup","title":"function setup","text":"<p>Setup the timewarp render pass and initailize required Vulkan resources. <pre><code>virtual void ILLIXR::vulkan::timewarp::setup (\n    VkRenderPass render_pass,\n    uint32_t subpass,\n    std::shared_ptr&lt; buffer_pool&lt; data_format::fast_pose_type &gt; &gt; buffer_pool,\n    bool input_texture_vulkan_coordinates\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>render_pass</code> The render pass to use. </li> <li><code>subpass</code> The subpass to use. </li> <li><code>buffer_pool</code> The buffer pool to use. </li> <li><code>input_texture_vulkan_coordinates</code> Whether the input texture is in Vulkan coordinates. </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/render_pass.hpp</code></p>"},{"location":"api/classILLIXR_1_1webcam/","title":"Class ILLIXR::webcam","text":"<p>ClassList &gt; ILLIXR &gt; webcam</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1webcam/#public-functions","title":"Public Functions","text":"Type Name void _p_one_iteration () override webcam (const std::string &amp; name_, phonebook * pb_)"},{"location":"api/classILLIXR_1_1webcam/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1webcam/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1webcam/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1webcam/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1webcam/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1webcam/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1webcam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1webcam/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::webcam::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1webcam/#function-webcam","title":"function webcam","text":"<pre><code>ILLIXR::webcam::webcam (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/webcam/plugin.hpp</code></p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/","title":"Class ILLIXR::xlib_gl_extended_window","text":"<p>ClassList &gt; ILLIXR &gt; xlib_gl_extended_window</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes","title":"Public Attributes","text":"Type Name GLXContext context_ Display * display_ int height_ int width_ Window window_"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions","title":"Public Functions","text":"Type Name xlib_gl_extended_window (int width, int height, GLXContext shared_gl_context)  ~xlib_gl_extended_window () override"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-context_","title":"variable context_","text":"<pre><code>GLXContext ILLIXR::xlib_gl_extended_window::context_;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-display_","title":"variable display_","text":"<pre><code>Display* ILLIXR::xlib_gl_extended_window::display_;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-height_","title":"variable height_","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::height_;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-width_","title":"variable width_","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::width_;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-window_","title":"variable window_","text":"<pre><code>Window ILLIXR::xlib_gl_extended_window::window_;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window","title":"function xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::xlib_gl_extended_window (\n    int width,\n    int height,\n    GLXContext shared_gl_context\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window_1","title":"function ~xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::~xlib_gl_extended_window () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/extended_window.hpp</code></p>"},{"location":"api/classILLIXR_1_1zed__camera/","title":"Class ILLIXR::zed_camera","text":"<p>ClassList &gt; ILLIXR &gt; zed_camera</p> <p>Inherits the following classes: sl::Camera</p>"},{"location":"api/classILLIXR_1_1zed__camera/#public-functions","title":"Public Functions","text":"Type Name float getBaseline () const sl::POSITIONAL_TRACKING_STATE getPosition (sl::Pose &amp; pose)  const data_format::camera_data &amp; get_config () const const sl::Transform &amp; get_initial_position () const Eigen::Quaternionf get_orientation () const Eigen::Vector3f get_translation () const sl::ERROR_CODE open (const sl::InitParameters &amp; params)  zed_camera (const std::shared_ptr&lt; switchboard &gt; &amp; sb)"},{"location":"api/classILLIXR_1_1zed__camera/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__camera/#function-getbaseline","title":"function getBaseline","text":"<pre><code>inline float ILLIXR::zed_camera::getBaseline () const\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera/#function-getposition","title":"function getPosition","text":"<pre><code>inline sl::POSITIONAL_TRACKING_STATE ILLIXR::zed_camera::getPosition (\n    sl::Pose &amp; pose\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera/#function-get_config","title":"function get_config","text":"<pre><code>inline const data_format::camera_data &amp; ILLIXR::zed_camera::get_config () const\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera/#function-get_initial_position","title":"function get_initial_position","text":"<pre><code>inline const sl::Transform &amp; ILLIXR::zed_camera::get_initial_position () const\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera/#function-get_orientation","title":"function get_orientation","text":"<pre><code>inline Eigen::Quaternionf ILLIXR::zed_camera::get_orientation () const\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera/#function-get_translation","title":"function get_translation","text":"<pre><code>inline Eigen::Vector3f ILLIXR::zed_camera::get_translation () const\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera/#function-open","title":"function open","text":"<pre><code>sl::ERROR_CODE ILLIXR::zed_camera::open (\n    const sl::InitParameters &amp; params\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera/#function-zed_camera","title":"function zed_camera","text":"<pre><code>inline explicit ILLIXR::zed_camera::zed_camera (\n    const std::shared_ptr&lt; switchboard &gt; &amp; sb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/zed_camera.hpp</code></p>"},{"location":"api/classILLIXR_1_1zed__camera__thread/","title":"Class ILLIXR::zed_camera_thread","text":"<p>ClassList &gt; ILLIXR &gt; zed_camera_thread</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1zed__camera__thread/#public-functions","title":"Public Functions","text":"Type Name void stop () override zed_camera_thread (const std::string &amp; name, phonebook * pb, std::shared_ptr&lt; zed_camera &gt; zed_cam)"},{"location":"api/classILLIXR_1_1zed__camera__thread/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1zed__camera__thread/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1zed__camera__thread/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1zed__camera__thread/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1zed__camera__thread/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1zed__camera__thread/#protected-functions","title":"Protected Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override"},{"location":"api/classILLIXR_1_1zed__camera__thread/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1zed__camera__thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__camera__thread/#function-stop","title":"function stop","text":"<pre><code>void ILLIXR::zed_camera_thread::stop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera__thread/#function-zed_camera_thread","title":"function zed_camera_thread","text":"<pre><code>ILLIXR::zed_camera_thread::zed_camera_thread (\n    const std::string &amp; name,\n    phonebook * pb,\n    std::shared_ptr&lt; zed_camera &gt; zed_cam\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera__thread/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__camera__thread/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::zed_camera_thread::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__camera__thread/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::zed_camera_thread::_p_should_skip () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/zed_camera_thread.hpp</code></p>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/","title":"Class ILLIXR::zed_capture::capture","text":"<p>ClassList &gt; ILLIXR &gt; zed_capture &gt; capture</p>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#public-functions","title":"Public Functions","text":"Type Name capture () = delete capture (int fp, const ILLIXR::data_format::pose_data &amp; wcf)  void get_camera (const ILLIXR::data_format::pose_data &amp; wcf)  void get_config ()  int get_data ()  void make_gui ()  ~capture ()"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#function-capture-12","title":"function capture [1/2]","text":"<pre><code>ILLIXR::zed_capture::capture::capture () = delete\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#function-capture-22","title":"function capture [2/2]","text":"<pre><code>ILLIXR::zed_capture::capture::capture (\n    int fp,\n    const ILLIXR::data_format::pose_data &amp; wcf\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#function-get_camera","title":"function get_camera","text":"<pre><code>void ILLIXR::zed_capture::capture::get_camera (\n    const ILLIXR::data_format::pose_data &amp; wcf\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#function-get_config","title":"function get_config","text":"<pre><code>void ILLIXR::zed_capture::capture::get_config () \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#function-get_data","title":"function get_data","text":"<pre><code>int ILLIXR::zed_capture::capture::get_data () \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#function-make_gui","title":"function make_gui","text":"<pre><code>void ILLIXR::zed_capture::capture::make_gui () \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1capture/#function-capture","title":"function ~capture","text":"<pre><code>ILLIXR::zed_capture::capture::~capture () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/capture.hpp</code></p>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/","title":"Class ILLIXR::zed_capture::files","text":"<p>ClassList &gt; ILLIXR &gt; zed_capture &gt; files</p>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::string camL_file_ boost::filesystem::path camL_path_ std::string camR_file_ boost::filesystem::path camR_path_ std::string cam_file_ std::string data_file_ boost::filesystem::path data_path_ boost::filesystem::path img_path_"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#public-functions","title":"Public Functions","text":"Type Name files (const files &amp;) = delete files () = delete"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#public-static-functions","title":"Public Static Functions","text":"Type Name files * getInstance ()  files * getInstance (const std::string &amp; rt, const std::string &amp; path)"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-caml_file_","title":"variable camL_file_","text":"<pre><code>std::string files::camL_file_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-caml_path_","title":"variable camL_path_","text":"<pre><code>boost::filesystem::path files::camL_path_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-camr_file_","title":"variable camR_file_","text":"<pre><code>std::string files::camR_file_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-camr_path_","title":"variable camR_path_","text":"<pre><code>boost::filesystem::path files::camR_path_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-cam_file_","title":"variable cam_file_","text":"<pre><code>std::string files::cam_file_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-data_file_","title":"variable data_file_","text":"<pre><code>std::string files::data_file_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-data_path_","title":"variable data_path_","text":"<pre><code>boost::filesystem::path files::data_path_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#variable-img_path_","title":"variable img_path_","text":"<pre><code>boost::filesystem::path files::img_path_;\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#function-files-13","title":"function files [1/3]","text":"<pre><code>ILLIXR::zed_capture::files::files (\n    const files &amp;\n) = delete\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#function-files-23","title":"function files [2/3]","text":"<pre><code>ILLIXR::zed_capture::files::files () = delete\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#function-getinstance-12","title":"function getInstance [1/2]","text":"<pre><code>static files * ILLIXR::zed_capture::files::getInstance () \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__capture_1_1files/#function-getinstance-22","title":"function getInstance [2/2]","text":"<pre><code>static files * ILLIXR::zed_capture::files::getInstance (\n    const std::string &amp; rt,\n    const std::string &amp; path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/files.hpp</code></p>"},{"location":"api/classILLIXR_1_1zed__imu__thread/","title":"Class ILLIXR::zed_imu_thread","text":"<p>ClassList &gt; ILLIXR &gt; zed_imu_thread</p> <p>Inherits the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1zed__imu__thread/#public-functions","title":"Public Functions","text":"Type Name void start () override void stop () override zed_imu_thread (const std::string &amp; name, phonebook * pb)  ~zed_imu_thread () override"},{"location":"api/classILLIXR_1_1zed__imu__thread/#public-functions-inherited-from-illixrthreadloop","title":"Public Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name, phonebook * pb)  ~threadloop () override"},{"location":"api/classILLIXR_1_1zed__imu__thread/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1zed__imu__thread/#protected-types-inherited-from-illixrthreadloop","title":"Protected Types inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name enum skip_option"},{"location":"api/classILLIXR_1_1zed__imu__thread/#protected-attributes-inherited-from-illixrthreadloop","title":"Protected Attributes inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1zed__imu__thread/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1zed__imu__thread/#protected-functions","title":"Protected Functions","text":"Type Name void _p_one_iteration () override skip_option _p_should_skip () override"},{"location":"api/classILLIXR_1_1zed__imu__thread/#protected-functions-inherited-from-illixrthreadloop","title":"Protected Functions inherited from ILLIXR::threadloop","text":"<p>See ILLIXR::threadloop</p> Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1zed__imu__thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__imu__thread/#function-start","title":"function start","text":"<pre><code>void ILLIXR::zed_imu_thread::start () override\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__imu__thread/#function-stop","title":"function stop","text":"<pre><code>void ILLIXR::zed_imu_thread::stop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__imu__thread/#function-zed_imu_thread","title":"function zed_imu_thread","text":"<pre><code>ILLIXR::zed_imu_thread::zed_imu_thread (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1zed__imu__thread/#function-zed_imu_thread_1","title":"function ~zed_imu_thread","text":"<pre><code>ILLIXR::zed_imu_thread::~zed_imu_thread () override\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__imu__thread/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1zed__imu__thread/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<pre><code>void ILLIXR::zed_imu_thread::_p_one_iteration () override\n</code></pre>"},{"location":"api/classILLIXR_1_1zed__imu__thread/#function-_p_should_skip","title":"function _p_should_skip","text":"<pre><code>skip_option ILLIXR::zed_imu_thread::_p_should_skip () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/plugin.hpp</code></p>"},{"location":"api/class_member_enums/","title":"Class Member Enums","text":""},{"location":"api/class_member_enums/#c","title":"c","text":"<ul> <li>cam_enum (ILLIXR::realsense)</li> </ul>"},{"location":"api/class_member_enums/#d","title":"d","text":"<ul> <li>display_backend_type (ILLIXR::display::display_backend)</li> </ul>"},{"location":"api/class_member_enums/#i","title":"i","text":"<ul> <li>image_state (ILLIXR::vulkan::buffer_pool)</li> </ul>"},{"location":"api/class_member_enums/#p","title":"p","text":"<ul> <li>packetization_type (ILLIXR::network::topic_config)</li> <li>priority_type (ILLIXR::network::topic_config)</li> </ul>"},{"location":"api/class_member_enums/#q","title":"q","text":"<ul> <li>queue_type (ILLIXR::vulkan::queue)</li> </ul>"},{"location":"api/class_member_enums/#s","title":"s","text":"<ul> <li>state (ILLIXR::managed_thread)</li> <li>SerializationMethod (ILLIXR::network::topic_config)</li> <li>skip_option (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_functions/","title":"Class Member Functions","text":""},{"location":"api/class_member_functions/#a","title":"a","text":"<ul> <li>at (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::points_with_units)</li> <li>asVector (ILLIXR::data_format::proper_quaternion)</li> <li>apply_offset (ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>absolute_ns (ILLIXR::relative_clock)</li> <li>allocate (ILLIXR::switchboard::writer)</li> <li>as (cxxopts::KeyValue, cxxopts::OptionValue)</li> <li>add_to_option (cxxopts::OptionParser)</li> <li>add_one_option (cxxopts::Options)</li> <li>add_option (cxxopts::Options)</li> <li>add_options (cxxopts::Options)</li> <li>allow_unrecognised_options (cxxopts::Options)</li> <li>arguments (cxxopts::ParseResult)</li> <li>arguments_string (cxxopts::ParseResult)</li> <li>abstract_value (cxxopts::values::abstract_value)</li> </ul>"},{"location":"api/class_member_functions/#b","title":"b","text":"<ul> <li>build_distortion_meshes (HMD)</li> <li>binocular_cam_type (ILLIXR::data_format::binocular_cam_type)</li> <li>begin (ILLIXR::data_format::cam_base_type, cxxopts::ParseResult)</li> <li>buffered_reader (ILLIXR::switchboard::buffered_reader)</li> <li>build_timewarp (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>bake_models (ILLIXR::vkdemo)</li> <li>buffer_pool (ILLIXR::vulkan::buffer_pool)</li> <li>bias_hat (ILLIXR::gtsam_integrator::pim_object)</li> </ul>"},{"location":"api/class_member_functions/#c","title":"c","text":"<ul> <li>cancel (ILLIXR::cancellable_sleep)</li> <li>cam_base_type (ILLIXR::data_format::cam_base_type)</li> <li>cam_type_zed (ILLIXR::data_format::cam_type_zed)</li> <li>camera_data (ILLIXR::data_format::camera_data)</li> <li>ccd_data (ILLIXR::data_format::ccd_data)</li> <li>compressed_frame (ILLIXR::data_format::compressed_frame)</li> <li>connection_signal (ILLIXR::data_format::connection_signal)</li> <li>check (ILLIXR::data_format::ht::hand_points)</li> <li>clear (ILLIXR::data_format::ht::hand_points, ILLIXR::event)</li> <li>copy (ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>check_validity (ILLIXR::data_format::points_with_units)</li> <li>correct_pose (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>cast (ILLIXR::data_format::proper_quaternion)</li> <li>callback (ILLIXR::depthai, ILLIXR::gtsam_integrator, ILLIXR::offload_data, ILLIXR::passthrough_integrator, ILLIXR::realsense, ILLIXR::rk4_integrator)</li> <li>create_camera_pipeline (ILLIXR::depthai)</li> <li>cleanup (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct, display_vk)</li> <li>create_surface (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>create (ILLIXR::dynamic_lib)</li> <li>create_FBO (ILLIXR::gldemo)</li> <li>create_shared_eyebuffer (ILLIXR::gldemo)</li> <li>clean_imu_vec (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>create_app_pass (ILLIXR::native_renderer)</li> <li>create_depth_image (ILLIXR::native_renderer)</li> <li>create_offscreen_framebuffers (ILLIXR::native_renderer)</li> <li>create_offscreen_pool (ILLIXR::native_renderer)</li> <li>create_offscreen_target (ILLIXR::native_renderer)</li> <li>create_swapchain_framebuffers (ILLIXR::native_renderer)</li> <li>create_sync_objects (ILLIXR::native_renderer)</li> <li>create_timewarp_pass (ILLIXR::native_renderer)</li> <li>copy_image_to_cpu_and_save_file (ILLIXR::offload_rendering_client)</li> <li>create_cuda_frame_ctx (ILLIXR::offload_rendering_client)</li> <li>camera_initialize (ILLIXR::openni_plugin)</li> <li>calculate_distortion_transform (ILLIXR::openwarp_vk)</li> <li>create_camera_matrix (ILLIXR::openwarp_vk)</li> <li>create_descriptor_pool (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_descriptor_set_layouts (ILLIXR::openwarp_vk)</li> <li>create_descriptor_sets (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>create_distortion_correction_pipeline (ILLIXR::openwarp_vk)</li> <li>create_index_buffers (ILLIXR::openwarp_vk)</li> <li>create_offscreen_images (ILLIXR::openwarp_vk)</li> <li>create_openwarp_pipeline (ILLIXR::openwarp_vk)</li> <li>create_texture_sampler (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>create_uniform_buffers (ILLIXR::openwarp_vk, ILLIXR::vkdemo)</li> <li>create_vertex_buffers (ILLIXR::openwarp_vk)</li> <li>configure_camera (ILLIXR::realsense)</li> <li>check_should_stop (ILLIXR::stoplight)</li> <li>check_shutdown_complete (ILLIXR::stoplight)</li> <li>calculate_time_warp_transform (ILLIXR::timewarp_gl)</li> <li>convert_vk_format_to_GL (ILLIXR::timewarp_gl)</li> <li>calculate_timewarp_transform (ILLIXR::timewarp_vk)</li> <li>create_descriptor_set_layout (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_index_buffer (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_pipeline (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_uniform_buffer (ILLIXR::timewarp_vk)</li> <li>create_vertex_buffer (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>cb_appsink (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>create_pipelines (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>create_descriptor_set (ILLIXR::vkdemo)</li> <li>create_texture_sampler_ (ILLIXR::vkdemo)</li> <li>capture (ILLIXR::zed_capture::capture)</li> <li>coordinate_system (ILLIXR::switchboard::coordinate_system)</li> <li>csv_iterator (csv_iterator)</li> <li>checked_parse_arg (cxxopts::OptionParser)</li> <li>consume_positional (cxxopts::OptionParser)</li> <li>count (cxxopts::OptionValue, cxxopts::ParseResult)</li> <li>custom_help (cxxopts::Options)</li> <li>clone (cxxopts::Value, cxxopts::values::standard_value, cxxopts::values::standard_value&lt; bool &gt;)</li> <li>create_logical_device (display_vk)</li> <li>create_swapchain (display_vk)</li> <li>create_vk_instance (display_vk)</li> </ul>"},{"location":"api/class_member_functions/#d","title":"d","text":"<ul> <li>depth_type (ILLIXR::data_format::depth_type)</li> <li>de_transform (ILLIXR::data_format::raw_point)</li> <li>data_injection (ILLIXR::data_injection)</li> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>debugview (ILLIXR::debugview)</li> <li>draw_GUI (ILLIXR::debugview)</li> <li>depthai (ILLIXR::depthai)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> <li>destroy (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>dump_data (ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth)</li> <li>dequeue (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer)</li> <li>deserialize_and_put (ILLIXR::switchboard::topic)</li> <li>decode (YAML::convert&lt; ILLIXR::Dependency &gt;)</li> <li>description (cxxopts::OptionDetails)</li> <li>defaults (cxxopts::ParseResult)</li> <li>default_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>destroy_swapchain (display_vk)</li> <li>display_vk (display_vk)</li> </ul>"},{"location":"api/class_member_functions/#e","title":"e","text":"<ul> <li>evaluate_catmull_rom_spline (HMD)</li> <li>end (ILLIXR::data_format::cam_base_type, cxxopts::ParseResult)</li> <li>enforce_bounds (ILLIXR::data_format::points_with_units)</li> <li>enable_no_delay (ILLIXR::network::TCPSocket)</li> <li>enqueue_for_network_send (ILLIXR::offload_rendering_server)</li> <li>event_wrapper (ILLIXR::switchboard::event_wrapper)</li> <li>env_names (ILLIXR::switchboard)</li> <li>estimate_time_to_sleep (ILLIXR::timewarp_gl)</li> <li>enqueue (ILLIXR::video_decoder, ILLIXR::video_encoder, ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>encode (YAML::convert&lt; ILLIXR::Dependency &gt;)</li> <li>essential_name (cxxopts::OptionDetails)</li> <li>ensure_value (cxxopts::OptionValue)</li> <li>exception (cxxopts::exceptions::exception)</li> </ul>"},{"location":"api/class_member_functions/#f","title":"f","text":"<ul> <li>find (ILLIXR::data_format::cam_base_type)</li> <li>format (ILLIXR::data_format::cam_base_type)</li> <li>fast_pose_type (ILLIXR::data_format::fast_pose_type)</li> <li>flip_y (ILLIXR::data_format::ht::hand_points, ILLIXR::data_format::rect)</li> <li>fast_pose_reliable (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>fauxpose (ILLIXR::fauxpose)</li> <li>fauxpose_impl (ILLIXR::fauxpose_impl)</li> <li>feed_ground_truth (ILLIXR::ground_truth_slam)</li> <li>ffmpeg_init_buffer_pool (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_cuda_device (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_cuda_frame_ctx (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_decoder (ILLIXR::offload_rendering_client)</li> <li>ffmpeg_init_device (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_frame_ctx (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_encoder (ILLIXR::offload_rendering_server)</li> <li>find_supported_devices (ILLIXR::realsense)</li> <li>flush (ILLIXR::record_coalescer)</li> <li>files (ILLIXR::zed_capture::files)</li> <li>first_long_name (cxxopts::OptionDetails)</li> <li>finalise_aliases (cxxopts::OptionParser)</li> </ul>"},{"location":"api/class_member_functions/#g","title":"g","text":"<ul> <li>get_default_hmd_info (HMD)</li> <li>get_attribute_descriptions (ILLIXR::DistortionCorrectionVertex, ILLIXR::OpenWarpVertex, ILLIXR::vertex, vertex)</li> <li>get_binding_description (ILLIXR::DistortionCorrectionVertex, ILLIXR::OpenWarpVertex, ILLIXR::vertex, vertex)</li> <li>get_fast_pose (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>get_offset (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>get_true_pose (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>generate_headset_transform (ILLIXR::debugview)</li> <li>get_required_device_extensions (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>get_required_instance_extensions (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct, ILLIXR::offload_rendering_server_loader, offload_rendering_client_loader)</li> <li>get_type (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>get_framebuffer_size (ILLIXR::display::glfw_extended)</li> <li>glfw_extended (ILLIXR::display::glfw_extended)</li> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid, ILLIXR::switchboard::topic, cxxopts::values::abstract_value)</li> <li>gldemo (ILLIXR::gldemo)</li> <li>ground_truth_slam (ILLIXR::ground_truth_slam)</li> <li>gtsam_integrator (ILLIXR::gtsam_integrator)</li> <li>get_state (ILLIXR::managed_thread)</li> <li>get_required_devices_extensions (ILLIXR::offload_rendering_server_loader, offload_rendering_client_loader)</li> <li>generate_distortion_data (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>generate_openwarp_mesh (ILLIXR::openwarp_vk)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>get_record_data_path (ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth)</li> <li>get_switchboard (ILLIXR::runtime)</li> <li>get_sqlite_thread (ILLIXR::sqlite_record_logger)</li> <li>get_ro (ILLIXR::switchboard::reader)</li> <li>get_ro_nullable (ILLIXR::switchboard::reader)</li> <li>get_rw (ILLIXR::switchboard::reader)</li> <li>get_buffered_reader (ILLIXR::switchboard)</li> <li>get_env (ILLIXR::switchboard)</li> <li>get_env_bool (ILLIXR::switchboard)</li> <li>get_env_char (ILLIXR::switchboard)</li> <li>get_network_writer (ILLIXR::switchboard)</li> <li>get_reader (ILLIXR::switchboard)</li> <li>get_topic (ILLIXR::switchboard)</li> <li>get_writer (ILLIXR::switchboard)</li> <li>get_next_swap_time_estimate (ILLIXR::timewarp_gl)</li> <li>getBaseline (ILLIXR::zed_camera)</li> <li>getPosition (ILLIXR::zed_camera)</li> <li>get_config (ILLIXR::zed_camera, ILLIXR::zed_capture::capture)</li> <li>get_initial_position (ILLIXR::zed_camera)</li> <li>get_orientation (ILLIXR::zed_camera)</li> <li>get_translation (ILLIXR::zed_camera)</li> <li>get_camera (ILLIXR::zed_capture::capture)</li> <li>get_data (ILLIXR::zed_capture::capture)</li> <li>getInstance (ILLIXR::zed_capture::files)</li> <li>get_buffer (ILLIXR::switchboard::topic)</li> <li>generate_all_groups_help (cxxopts::Options)</li> <li>generate_group_help (cxxopts::Options)</li> <li>group_help (cxxopts::Options)</li> <li>groups (cxxopts::Options)</li> <li>get_default_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>get_implicit_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>gratuitous_argument_for_option (cxxopts::exceptions::gratuitous_argument_for_option)</li> </ul>"},{"location":"api/class_member_functions/#h","title":"h","text":"<ul> <li>hologram_input (ILLIXR::data_format::hologram_input)</li> <li>hand_points (ILLIXR::data_format::ht::hand_points)</li> <li>ht_detection (ILLIXR::data_format::ht::ht_detection)</li> <li>ht_frame (ILLIXR::data_format::ht::ht_frame)</li> <li>has_impl (ILLIXR::phonebook)</li> <li>has_compression (ILLIXR::vulkan::queue_families)</li> <li>has_presentation (ILLIXR::vulkan::queue_families)</li> <li>hash (cxxopts::OptionDetails)</li> <li>has_default (cxxopts::OptionValue, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>help (cxxopts::Options)</li> <li>help_one_group (cxxopts::Options)</li> <li>has_implicit (cxxopts::Value, cxxopts::values::abstract_value)</li> </ul>"},{"location":"api/class_member_functions/#i","title":"i","text":"<ul> <li>image_handle (ILLIXR::data_format::image_handle)</li> <li>imu_integrator_input (ILLIXR::data_format::imu_integrator_input)</li> <li>imu_raw_type (ILLIXR::data_format::imu_raw_type)</li> <li>imu_type (ILLIXR::data_format::imu_type)</li> <li>img (ILLIXR::data_format::monocular_cam_type)</li> <li>is_used (ILLIXR::data_use_indicator)</li> <li>is_set (ILLIXR::event)</li> <li>interpolate_imu (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>is_topic_networked (ILLIXR::network::network_backend, ILLIXR::tcp_network_backend)</li> <li>is_external (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>initialize (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>is_started (ILLIXR::relative_clock)</li> <li>internal_stop (ILLIXR::threadloop)</li> <li>import_vulkan_image (ILLIXR::timewarp_gl)</li> <li>init (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>image_layout_transition (ILLIXR::vkdemo)</li> <li>integrate_measurement (ILLIXR::gtsam_integrator::pim_object)</li> <li>Iterator (cxxopts::ParseResult::Iterator)</li> <li>implicit_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>is_boolean (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>is_container (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>incorrect_argument_type (cxxopts::exceptions::incorrect_argument_type)</li> <li>invalid_option_format (cxxopts::exceptions::invalid_option_format)</li> <li>invalid_option_syntax (cxxopts::exceptions::invalid_option_syntax)</li> <li>is_physical_device_suitable (display_vk)</li> </ul>"},{"location":"api/class_member_functions/#k","title":"k","text":"<ul> <li>KeyValue (cxxopts::KeyValue)</li> <li>key (cxxopts::KeyValue)</li> </ul>"},{"location":"api/class_member_functions/#l","title":"l","text":"<ul> <li>load (ILLIXR::data_format::compressed_frame, ILLIXR::lazy_load_image)</li> <li>load_images_on_the_fly (ILLIXR::data_injection)</li> <li>load_camera_images (ILLIXR::debugview)</li> <li>load_rgb_depth (ILLIXR::debugview)</li> <li>lazy_load_image (ILLIXR::lazy_load_image)</li> <li>lighthouse (ILLIXR::lighthouse)</li> <li>local_address (ILLIXR::network::TCPSocket)</li> <li>lookup_impl (ILLIXR::phonebook)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger, ILLIXR::sqlite_record_logger, ILLIXR::stdout_record_logger)</li> <li>load_plugin_factory (ILLIXR::runtime, runtime_impl)</li> <li>load_so (ILLIXR::runtime, runtime_impl)</li> <li>load_model (ILLIXR::vkdemo)</li> <li>load_texture (ILLIXR::vkdemo)</li> <li>long_names (cxxopts::OptionDetails)</li> </ul>"},{"location":"api/class_member_functions/#m","title":"m","text":"<ul> <li>max_float (HMD)</li> <li>min_float (HMD)</li> <li>monocular_cam_type (ILLIXR::data_format::monocular_cam_type)</li> <li>mult (ILLIXR::data_format::points_with_units, ILLIXR::data_format::raw_point)</li> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>managed_thread (ILLIXR::managed_thread)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> <li>make_detection_table (ILLIXR::viewer)</li> <li>make_gui (ILLIXR::viewer, ILLIXR::zed_capture::capture)</li> <li>make_position_table (ILLIXR::viewer)</li> <li>make_storage (cxxopts::OptionDetails)</li> <li>missing_argument (cxxopts::exceptions::missing_argument)</li> <li>main_loop (display_vk)</li> </ul>"},{"location":"api/class_member_functions/#n","title":"n","text":"<ul> <li>normalize (ILLIXR::data_format::proper_quaternion)</li> <li>native_renderer (ILLIXR::native_renderer)</li> <li>network_receive (ILLIXR::offload_rendering_client)</li> <li>now (ILLIXR::relative_clock)</li> <li>network_writer (ILLIXR::switchboard::network_writer)</li> <li>name (ILLIXR::switchboard::topic)</li> <li>no_implicit_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>no_such_option (cxxopts::exceptions::no_such_option)</li> </ul>"},{"location":"api/class_member_functions/#o","title":"o","text":"<ul> <li>operator== (ILLIXR::Dependency, ILLIXR::record_header, ILLIXR::vertex, csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator[] (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::camera_data, ILLIXR::data_format::points_with_units, ILLIXR::dynamic_lib, csv_iterator, csv_row, cxxopts::ParseResult)</li> <li>operator+= (ILLIXR::data_format::point, ILLIXR::data_format::proper_quaternion, ILLIXR::time_point, csv_iterator)</li> <li>operator-= (ILLIXR::data_format::point, ILLIXR::time_point)</li> <li>operator= (ILLIXR::data_format::point, ILLIXR::data_format::points_with_units, ILLIXR::data_format::proper_quaternion, ILLIXR::data_use_indicator, ILLIXR::dynamic_lib, cxxopts::ParseResult, cxxopts::values::abstract_value)</li> <li>operator* (ILLIXR::data_format::point_with_units, ILLIXR::data_format::proper_quaternion, ILLIXR::switchboard::event_wrapper, csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator+ (ILLIXR::data_format::point_with_units, ILLIXR::data_format::proper_quaternion)</li> <li>operator- (ILLIXR::data_format::point_with_units)</li> <li>operator/ (ILLIXR::data_format::point_with_units)</li> <li>operator*= (ILLIXR::data_format::proper_quaternion)</li> <li>offline_cam (ILLIXR::offline_cam)</li> <li>offline_imu (ILLIXR::offline_imu)</li> <li>offload_data (ILLIXR::offload_data)</li> <li>offload_reader (ILLIXR::offload_reader)</li> <li>offload_rendering_client (ILLIXR::offload_rendering_client)</li> <li>offload_rendering_server (ILLIXR::offload_rendering_server)</li> <li>offload_rendering_server_loader (ILLIXR::offload_rendering_server_loader)</li> <li>offload_writer (ILLIXR::offload_writer)</li> <li>openni_plugin (ILLIXR::openni_plugin)</li> <li>openwarp_vk (ILLIXR::openwarp_vk)</li> <li>openwarp_vk_plugin (ILLIXR::openwarp_vk_plugin)</li> <li>operator bool (ILLIXR::record_coalescer)</li> <li>operator!= (ILLIXR::record_header, csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator Underlying_type (ILLIXR::switchboard::event_wrapper)</li> <li>open (ILLIXR::zed_camera)</li> <li>orientation (ILLIXR::switchboard::coordinate_system)</li> <li>operator++ (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator-&gt; (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>Option (cxxopts::Option)</li> <li>OptionAdder (cxxopts::OptionAdder)</li> <li>operator() (cxxopts::OptionAdder, cxxopts::values::detail::SignedCheck&lt; T, false &gt;, cxxopts::values::detail::SignedCheck&lt; T, true &gt;, should_profile_class, std::hash&lt; vertex &gt;)</li> <li>OptionDetails (cxxopts::OptionDetails)</li> <li>OptionParser (cxxopts::OptionParser)</li> <li>Options (cxxopts::Options)</li> <li>option_already_exists (cxxopts::exceptions::option_already_exists)</li> <li>option_has_no_value (cxxopts::exceptions::option_has_no_value)</li> <li>option_requires_argument (cxxopts::exceptions::option_requires_argument)</li> <li>offload_rendering_client_loader (offload_rendering_client_loader)</li> </ul>"},{"location":"api/class_member_functions/#p","title":"p","text":"<ul> <li>position (ILLIXR::data_format::ht::position, ILLIXR::switchboard::coordinate_system)</li> <li>point (ILLIXR::data_format::point)</li> <li>point_with_units (ILLIXR::data_format::point_with_units)</li> <li>point_with_validity (ILLIXR::data_format::point_with_validity)</li> <li>points_with_units (ILLIXR::data_format::points_with_units)</li> <li>pose_data (ILLIXR::data_format::pose_data)</li> <li>pose_type (ILLIXR::data_format::pose_type)</li> <li>proper_quaternion (ILLIXR::data_format::proper_quaternion)</li> <li>poll_window_events (ILLIXR::display::glfw_extended, ILLIXR::vulkan::display_provider, display_vk)</li> <li>propagate_imu_values (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>process_slow_pose (ILLIXR::lighthouse)</li> <li>peer_address (ILLIXR::network::TCPSocket)</li> <li>push_pose (ILLIXR::offload_rendering_client)</li> <li>prepare_imu_cam_data (ILLIXR::offload_writer)</li> <li>partial_destroy (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>passthrough_integrator (ILLIXR::passthrough_integrator)</li> <li>plugin (ILLIXR::plugin)</li> <li>pose_lookup_impl (ILLIXR::pose_lookup_impl)</li> <li>pose_prediction_impl (ILLIXR::pose_prediction_impl)</li> <li>prep_db (ILLIXR::sqlite_thread)</li> <li>prep_insert_str (ILLIXR::sqlite_thread)</li> <li>process (ILLIXR::sqlite_thread)</li> <li>pull_queue (ILLIXR::sqlite_thread)</li> <li>put_queue (ILLIXR::sqlite_thread)</li> <li>put (ILLIXR::switchboard::network_writer, ILLIXR::switchboard::writer, ILLIXR::switchboard::topic)</li> <li>post_processing_acquire_image (ILLIXR::vulkan::buffer_pool)</li> <li>post_processing_release_image (ILLIXR::vulkan::buffer_pool)</li> <li>pim_object (ILLIXR::gtsam_integrator::pim_object)</li> <li>predict (ILLIXR::gtsam_integrator::pim_object)</li> <li>parse (cxxopts::OptionParser, cxxopts::OptionValue, cxxopts::Options, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>parse_default (cxxopts::OptionParser, cxxopts::OptionValue)</li> <li>parse_no_value (cxxopts::OptionParser, cxxopts::OptionValue)</li> <li>parse_option (cxxopts::OptionParser)</li> <li>parse_positional (cxxopts::Options)</li> <li>positional_help (cxxopts::Options)</li> <li>program (cxxopts::Options)</li> <li>ParseResult (cxxopts::ParseResult)</li> <li>parsing (cxxopts::exceptions::parsing)</li> <li>pose_lookup_plugin (pose_lookup_plugin)</li> <li>pose_prediction_plugin (pose_prediction_plugin)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> </ul>"},{"location":"api/class_member_functions/#r","title":"r","text":"<ul> <li>raw_ht_data (ILLIXR::data_format::ht::raw_ht_data)</li> <li>raw_point (ILLIXR::data_format::raw_point)</li> <li>raw_pose (ILLIXR::data_format::raw_pose)</li> <li>rect (ILLIXR::data_format::rect)</li> <li>rendered_frame (ILLIXR::data_format::rendered_frame)</li> <li>rgb_depth_type (ILLIXR::data_format::rgb_depth_type)</li> <li>read_cam_data (ILLIXR::data_injection)</li> <li>read_poses (ILLIXR::data_injection)</li> <li>register_display_timings_event (ILLIXR::display::x11_direct)</li> <li>record_post_processing_command_buffer (ILLIXR::native_renderer)</li> <li>record_src_command_buffer (ILLIXR::native_renderer)</li> <li>recreate_swapchain (ILLIXR::native_renderer, ILLIXR::vulkan::display_provider, display_vk)</li> <li>read_data (ILLIXR::network::TCPSocket)</li> <li>receive_vio_output (ILLIXR::offload_reader)</li> <li>record_command_buffer (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>register_impl (ILLIXR::phonebook)</li> <li>realsense (ILLIXR::realsense)</li> <li>record (ILLIXR::record)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>record_imu_cam (ILLIXR::record_imu_cam)</li> <li>record_rgb_depth (ILLIXR::record_rgb_depth)</li> <li>rk4_integrator (ILLIXR::rk4_integrator)</li> <li>receive_vio_input (ILLIXR::server_reader)</li> <li>reader (ILLIXR::switchboard::reader)</li> <li>read_loop (ILLIXR::tcp_network_backend)</li> <li>read_texture_image (ILLIXR::timewarp_gl)</li> <li>reset_integration_and_set_bias (ILLIXR::gtsam_integrator::pim_object)</li> <li>read_next_row (csv_row)</li> <li>requested_option_not_present (cxxopts::exceptions::requested_option_not_present)</li> <li>runtime_impl (runtime_impl)</li> </ul>"},{"location":"api/class_member_functions/#s","title":"s","text":"<ul> <li>sleep (ILLIXR::cancellable_sleep)</li> <li>size (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::points_with_units, ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer, csv_row)</li> <li>save (ILLIXR::data_format::compressed_frame)</li> <li>set (ILLIXR::data_format::point, ILLIXR::data_format::point_with_units, ILLIXR::data_format::rect, ILLIXR::event)</li> <li>set_offset (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>signal_to_quad (ILLIXR::data_format::signal_to_quad)</li> <li>start (ILLIXR::data_injection, ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::ground_truth_slam, ILLIXR::managed_thread, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_rendering_server_loader, ILLIXR::offload_writer, ILLIXR::plugin, ILLIXR::relative_clock, ILLIXR::server_reader, ILLIXR::server_writer, ILLIXR::threadloop, ILLIXR::viewer, ILLIXR::vkdemo_plugin, ILLIXR::zed_imu_thread, display_vk, offload_rendering_client_loader)</li> <li>setup_display (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>select_display_mode (ILLIXR::display::x11_direct)</li> <li>select_imu_readings (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>stop (ILLIXR::lighthouse, ILLIXR::managed_thread, ILLIXR::offload_rendering_server_loader, ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::tcp_network_backend, ILLIXR::threadloop, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread, ILLIXR::switchboard::topic, offload_rendering_client_loader)</li> <li>socket_accept (ILLIXR::network::TCPSocket)</li> <li>socket_bind (ILLIXR::network::TCPSocket)</li> <li>socket_connect (ILLIXR::network::TCPSocket)</li> <li>socket_listen (ILLIXR::network::TCPSocket)</li> <li>socket_set_reuseaddr (ILLIXR::network::TCPSocket)</li> <li>save_nv12_img_to_png (ILLIXR::offload_rendering_client)</li> <li>setup (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::app, ILLIXR::vulkan::timewarp, display_vk)</li> <li>submit_command_buffer (ILLIXR::offload_rendering_client)</li> <li>send_imu_cam_data (ILLIXR::offload_writer)</li> <li>spd_add_file_sink (ILLIXR::plugin)</li> <li>spdlogger (ILLIXR::plugin)</li> <li>start_time (ILLIXR::relative_clock)</li> <li>server_reader (ILLIXR::server_reader)</li> <li>send_vio_output (ILLIXR::server_writer)</li> <li>server_writer (ILLIXR::server_writer)</li> <li>sqlite_thread (ILLIXR::sqlite_thread)</li> <li>state_plus (ILLIXR::state_plus)</li> <li>signal_ready (ILLIXR::stoplight)</li> <li>signal_should_stop (ILLIXR::stoplight)</li> <li>signal_shutdown_complete (ILLIXR::stoplight)</li> <li>serialize (ILLIXR::switchboard::event)</li> <li>schedule (ILLIXR::switchboard, ILLIXR::switchboard::topic)</li> <li>set_env (ILLIXR::switchboard)</li> <li>switchboard (ILLIXR::switchboard)</li> <li>send_to_peer (ILLIXR::tcp_network_backend)</li> <li>start_client (ILLIXR::tcp_network_backend)</li> <li>start_server (ILLIXR::tcp_network_backend)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>src_acquire_image (ILLIXR::vulkan::buffer_pool)</li> <li>src_release_image (ILLIXR::vulkan::buffer_pool)</li> <li>start_camera (ILLIXR::zed_imu_thread)</li> <li>short_name (cxxopts::OptionDetails)</li> <li>set_tab_expansion (cxxopts::Options)</li> <li>set_width (cxxopts::Options)</li> <li>show_positional_help (cxxopts::Options)</li> <li>specification (cxxopts::exceptions::specification)</li> <li>set_default_and_implicit (cxxopts::values::standard_value&lt; bool &gt;)</li> <li>standard_value (cxxopts::values::standard_value&lt; bool &gt;)</li> <li>select_physical_device (display_vk)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_member_functions/#t","title":"t","text":"<ul> <li>transform (ILLIXR::data_format::points_with_units, ILLIXR::data_format::raw_point)</li> <li>true_pose_reliable (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>texture_pose (ILLIXR::data_format::texture_pose)</li> <li>tick (ILLIXR::display::x11_direct)</li> <li>thread_main (ILLIXR::managed_thread, ILLIXR::threadloop)</li> <li>TCPSocket (ILLIXR::network::TCPSocket)</li> <li>topic_create (ILLIXR::network::network_backend, ILLIXR::tcp_network_backend)</li> <li>topic_send (ILLIXR::network::network_backend, ILLIXR::tcp_network_backend)</li> <li>transition_layout (ILLIXR::offload_rendering_client)</li> <li>to_string (ILLIXR::record_header)</li> <li>topic_exists (ILLIXR::switchboard)</li> <li>try_register_topic (ILLIXR::switchboard)</li> <li>tcp_network_backend (ILLIXR::tcp_network_backend)</li> <li>topic_receive (ILLIXR::tcp_network_backend)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>time_point (ILLIXR::time_point)</li> <li>time_since_epoch (ILLIXR::time_point)</li> <li>timewarp_gl (ILLIXR::timewarp_gl)</li> <li>timewarp_vk (ILLIXR::timewarp_vk)</li> <li>timewarp_vk_plugin (ILLIXR::timewarp_vk_plugin)</li> <li>topic (ILLIXR::switchboard::topic)</li> <li>ty (ILLIXR::switchboard::topic)</li> <li>topic_buffer (ILLIXR::switchboard::topic_buffer)</li> <li>thread_body (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_start (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_stop (ILLIXR::switchboard::topic_subscription)</li> <li>topic_subscription (ILLIXR::switchboard::topic_subscription)</li> <li>timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#u","title":"u","text":"<ul> <li>update_uniforms (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>update_uniform (ILLIXR::vkdemo)</li> <li>unmatched (cxxopts::ParseResult)</li> </ul>"},{"location":"api/class_member_functions/#v","title":"v","text":"<ul> <li>velocity (ILLIXR::data_format::ht::velocity)</li> <li>vk_image_handle (ILLIXR::data_format::vk_image_handle)</li> <li>video_decoder (ILLIXR::video_decoder)</li> <li>video_encoder (ILLIXR::video_encoder)</li> <li>viewer (ILLIXR::viewer)</li> <li>vkdemo (ILLIXR::vkdemo)</li> <li>vkdemo_plugin (ILLIXR::vkdemo_plugin)</li> <li>value (cxxopts::KeyValue, cxxopts::OptionDetails)</li> </ul>"},{"location":"api/class_member_functions/#w","title":"w","text":"<ul> <li>wait (ILLIXR::event, ILLIXR::runtime, runtime_impl)</li> <li>wait_timeout (ILLIXR::event)</li> <li>wait_vsync (ILLIXR::gldemo)</li> <li>write_data (ILLIXR::network::TCPSocket)</li> <li>write_helper (ILLIXR::network::TCPSocket)</li> <li>write_data_to_disk (ILLIXR::offload_data)</li> <li>write_metadata (ILLIXR::offload_data)</li> <li>wait_for_ready (ILLIXR::stoplight)</li> <li>wait_for_shutdown_complete (ILLIXR::stoplight)</li> <li>writer (ILLIXR::switchboard::writer)</li> <li>warp (ILLIXR::timewarp_gl)</li> <li>webcam (ILLIXR::webcam)</li> <li>what (cxxopts::exceptions::exception)</li> </ul>"},{"location":"api/class_member_functions/#x","title":"x","text":"<ul> <li>x11_direct (ILLIXR::display::x11_direct)</li> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_functions/#z","title":"z","text":"<ul> <li>zed_camera (ILLIXR::zed_camera)</li> <li>zed_camera_thread (ILLIXR::zed_camera_thread)</li> <li>zed_imu_thread (ILLIXR::zed_imu_thread)</li> </ul>"},{"location":"api/class_member_functions/#_1","title":"~","text":"<ul> <li>~compressed_frame (ILLIXR::data_format::compressed_frame)</li> <li>~pose_prediction (ILLIXR::data_format::pose_prediction)</li> <li>~data_injection (ILLIXR::data_injection)</li> <li>~debugview (ILLIXR::debugview)</li> <li>~depthai (ILLIXR::depthai)</li> <li>~dynamic_lib (ILLIXR::dynamic_lib)</li> <li>~fauxpose (ILLIXR::fauxpose)</li> <li>~fauxpose_impl (ILLIXR::fauxpose_impl)</li> <li>~lighthouse (ILLIXR::lighthouse)</li> <li>~managed_thread (ILLIXR::managed_thread)</li> <li>~native_renderer (ILLIXR::native_renderer)</li> <li>~TCPSocket (ILLIXR::network::TCPSocket)</li> <li>~offload_data (ILLIXR::offload_data)</li> <li>~openni_plugin (ILLIXR::openni_plugin)</li> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~realsense (ILLIXR::realsense)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_imu_cam (ILLIXR::record_imu_cam)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~record_rgb_depth (ILLIXR::record_rgb_depth)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~sqlite_thread (ILLIXR::sqlite_thread)</li> <li>~event (ILLIXR::switchboard::event)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~viewer (ILLIXR::viewer)</li> <li>~display_provider (ILLIXR::vulkan::display_provider)</li> <li>~render_pass (ILLIXR::vulkan::render_pass)</li> <li>~xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>~capture (ILLIXR::zed_capture::capture)</li> <li>~zed_imu_thread (ILLIXR::zed_imu_thread)</li> <li>~pim_object (ILLIXR::gtsam_integrator::pim_object)</li> <li>~Value (cxxopts::Value)</li> <li>~abstract_value (cxxopts::values::abstract_value)</li> <li>~standard_value (cxxopts::values::standard_value&lt; bool &gt;)</li> <li>~display_vk (display_vk)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~runtime_impl (runtime_impl)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#_","title":"_","text":"<ul> <li>_correct_pose (ILLIXR::data_format::pose_prediction)</li> <li>_set_offset (ILLIXR::data_format::pose_prediction)</li> <li>_p_one_iteration (ILLIXR::data_injection, ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_writer, ILLIXR::openni_plugin, ILLIXR::openwarp_vk_plugin, ILLIXR::server_reader, ILLIXR::threadloop, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk_plugin, ILLIXR::webcam, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> <li>_p_thread_setup (ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_writer, ILLIXR::threadloop, ILLIXR::timewarp_gl)</li> <li>_p_should_skip (ILLIXR::lighthouse, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openni_plugin, ILLIXR::openwarp_vk_plugin, ILLIXR::server_reader, ILLIXR::threadloop, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk_plugin, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> <li>_stop (ILLIXR::runtime, runtime_impl)</li> <li>_prepare_rendering (ILLIXR::timewarp_gl)</li> <li>_setup (ILLIXR::timewarp_gl)</li> </ul>"},{"location":"api/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"api/class_member_typedefs/#b","title":"b","text":"<ul> <li>Base (ILLIXR::data_format::proper_quaternion)</li> </ul>"},{"location":"api/class_member_typedefs/#d","title":"d","text":"<ul> <li>duration (ILLIXR::relative_clock, ILLIXR::time_point)</li> <li>difference_type (csv_iterator, cxxopts::ParseResult::Iterator)</li> </ul>"},{"location":"api/class_member_typedefs/#i","title":"i","text":"<ul> <li>iterator_category (csv_iterator, cxxopts::ParseResult::Iterator)</li> </ul>"},{"location":"api/class_member_typedefs/#p","title":"p","text":"<ul> <li>ptr (ILLIXR::switchboard)</li> <li>pointer (csv_iterator, cxxopts::ParseResult::Iterator)</li> </ul>"},{"location":"api/class_member_typedefs/#r","title":"r","text":"<ul> <li>reference (csv_iterator, cxxopts::ParseResult::Iterator)</li> </ul>"},{"location":"api/class_member_typedefs/#s","title":"s","text":"<ul> <li>Self (cxxopts::values::abstract_value)</li> </ul>"},{"location":"api/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (csv_iterator, cxxopts::ParseResult::Iterator)</li> </ul>"},{"location":"api/class_member_variables/","title":"Class Member Variables","text":""},{"location":"api/class_member_variables/#a","title":"a","text":"<ul> <li>acc_noise (ILLIXR::data_format::imu_params)</li> <li>acc_walk (ILLIXR::data_format::imu_params)</li> <li>a_hat (ILLIXR::data_format::imu_raw_type)</li> <li>a_hat2 (ILLIXR::data_format::imu_raw_type)</li> <li>angular_v (ILLIXR::data_format::imu_type, ILLIXR::raw_imu_type)</li> <li>allocation_size (ILLIXR::data_format::vk_image_handle)</li> <li>all_count_ (ILLIXR::depthai)</li> <li>aberration (ILLIXR::display_params)</li> <li>amplitude_ (ILLIXR::fauxpose_impl)</li> <li>app_ (ILLIXR::native_renderer)</li> <li>app_command_buffer_ (ILLIXR::native_renderer)</li> <li>app_pass_ (ILLIXR::native_renderer)</li> <li>app_render_finished_semaphore_ (ILLIXR::native_renderer)</li> <li>allow_out_of_order (ILLIXR::network::topic_config)</li> <li>avvk_color_frames_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>avvk_depth_frames_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>align_quat_ (ILLIXR::pose_lookup_impl)</li> <li>align_rot_ (ILLIXR::pose_lookup_impl)</li> <li>align_scale_ (ILLIXR::pose_lookup_impl)</li> <li>align_trans_ (ILLIXR::pose_lookup_impl)</li> <li>accel_data_ (ILLIXR::realsense)</li> <li>appsink_img0_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>appsink_img1_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>appsrc_img0_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>appsrc_img1_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>allocation (ILLIXR::vulkan::vk_image)</li> <li>allocation_info (ILLIXR::vulkan::vk_image)</li> <li>arg_help (cxxopts::HelpOptionDetails)</li> <li>arg_help_ (cxxopts::Option)</li> <li>arg_name (cxxopts::values::parser_tool::ArguDesc)</li> <li>account_name_ (print_timer::print_in_destructor)</li> <li>actually_should_profile_ (should_profile_class)</li> </ul>"},{"location":"api/class_member_variables/#b","title":"b","text":"<ul> <li>baseline (ILLIXR::data_format::camera_data)</li> <li>bias_acc (ILLIXR::data_format::imu_integrator_input)</li> <li>bias_gyro (ILLIXR::data_format::imu_integrator_input)</li> <li>base_time_ (ILLIXR::data_injection)</li> <li>basic_projection_ (ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>being_dragged_ (ILLIXR::debugview)</li> <li>body_ (ILLIXR::managed_thread)</li> <li>buffer_pool_ (ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>BUFFER_SIZE (ILLIXR::network::TCPSocket)</li> <li>bitrate_ (ILLIXR::offload_rendering_server)</li> <li>buffer_ (ILLIXR::record_coalescer)</li> <li>buffer_str_ (ILLIXR::server_reader)</li> <li>backend_ (ILLIXR::switchboard::network_writer, display_vk)</li> <li>base_unit_ (ILLIXR::viewer)</li> <li>basicProjection_ (ILLIXR::viewer)</li> <li>buffers_ (ILLIXR::switchboard::topic)</li> <li>base (cxxopts::values::parser_tool::IntegerDesc)</li> <li>backend_type_ (display_vk)</li> </ul>"},{"location":"api/class_member_variables/#c","title":"c","text":"<ul> <li>chromatic_aberration (HMD::hmd_info_t)</li> <li>ccds (ILLIXR::data_format::camera_data)</li> <li>center_x (ILLIXR::data_format::ccd_data)</li> <li>center_y (ILLIXR::data_format::ccd_data)</li> <li>chromaticAberration (ILLIXR::data_format::hmd_physical_info)</li> <li>confidence (ILLIXR::data_format::ht::ht_detection, ILLIXR::data_format::point_with_validity, ILLIXR::data_format::pose_data)</li> <li>co_frame (ILLIXR::data_format::pose_data)</li> <li>camera_data_ (ILLIXR::data_injection)</li> <li>camera_data_writer_ (ILLIXR::data_injection)</li> <li>counter_ (ILLIXR::data_injection, ILLIXR::rk4_integrator)</li> <li>current_ (ILLIXR::data_injection)</li> <li>cam_ (ILLIXR::debugview, ILLIXR::offload_writer, ILLIXR::realsense, ILLIXR::record_imu_cam, ILLIXR::server_reader, ILLIXR::zed_camera_thread)</li> <li>cam_reader_ (ILLIXR::debugview, ILLIXR::zed_imu_thread)</li> <li>camera_texture_ (ILLIXR::debugview)</li> <li>camera_texture_size_ (ILLIXR::debugview)</li> <li>color_uniform_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>cam_writer_ (ILLIXR::depthai)</li> <li>clock_ (ILLIXR::depthai, ILLIXR::display::x11_direct, ILLIXR::fauxpose_impl, ILLIXR::gldemo, ILLIXR::gtsam_integrator, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_writer, ILLIXR::openni_plugin, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl, ILLIXR::realsense, ILLIXR::server_reader, ILLIXR::timewarp_gl, ILLIXR::viewer, ILLIXR::vkdemo, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread, display_vk)</li> <li>color_queue_ (ILLIXR::depthai)</li> <li>cv_ (ILLIXR::event)</li> <li>center_location_ (ILLIXR::fauxpose_impl)</li> <li>command_pool_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>cam_publisher_ (ILLIXR::offline_cam, ILLIXR::zed_imu_thread)</li> <li>codec_color_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>codec_depth_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>command_pool (ILLIXR::offload_rendering_client)</li> <li>cuda_bgra_frame_ctx_ (ILLIXR::offload_rendering_client)</li> <li>cuda_device_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>cuda_nv12_frame_ctx_ (ILLIXR::offload_rendering_client)</li> <li>cuda_frame_ctx_ (ILLIXR::offload_rendering_server)</li> <li>condition_var_ (ILLIXR::offload_writer)</li> <li>cam_time_ (ILLIXR::openni_plugin)</li> <li>color_ (ILLIXR::openni_plugin)</li> <li>color_frame_ (ILLIXR::openni_plugin)</li> <li>command_buffer_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>cam_select_ (ILLIXR::realsense)</li> <li>config_ (ILLIXR::realsense, ILLIXR::switchboard::network_writer, ILLIXR::zed_camera)</li> <li>columns_ (ILLIXR::record_header)</li> <li>cam0_data_dir_ (ILLIXR::record_imu_cam)</li> <li>cam0_wt_file_ (ILLIXR::record_imu_cam)</li> <li>cam1_data_dir_ (ILLIXR::record_imu_cam)</li> <li>cam1_wt_file_ (ILLIXR::record_imu_cam)</li> <li>cam_count_ (ILLIXR::rk4_integrator)</li> <li>cam0 (ILLIXR::sensor_types)</li> <li>cam1 (ILLIXR::sensor_types)</li> <li>condition_variable_ (ILLIXR::server_reader)</li> <li>client (ILLIXR::tcp_network_backend)</li> <li>client_ip_ (ILLIXR::tcp_network_backend)</li> <li>client_port_ (ILLIXR::tcp_network_backend)</li> <li>client_backend_ (ILLIXR::timewarp_gl)</li> <li>context_ (ILLIXR::timewarp_gl, ILLIXR::xlib_gl_extended_window)</li> <li>clamp_edge_ (ILLIXR::timewarp_vk)</li> <li>callback_ (ILLIXR::video_decoder, ILLIXR::video_encoder, ILLIXR::switchboard::topic_subscription)</li> <li>clear_color_ (ILLIXR::viewer, ILLIXR::zed_capture::capture)</li> <li>combined_size (ILLIXR::viewer)</li> <li>current_frame_ (ILLIXR::viewer)</li> <li>compute_family (ILLIXR::vulkan::queue_families)</li> <li>capabilities (ILLIXR::vulkan::swapchain_details)</li> <li>capture_ (ILLIXR::webcam)</li> <li>color_map_ (ILLIXR::xlib_gl_extended_window)</li> <li>confidence_ocv_ (ILLIXR::zed_camera_thread)</li> <li>confidence_zed_ (ILLIXR::zed_camera_thread)</li> <li>camL_of_ (ILLIXR::zed_capture::capture)</li> <li>camR_of_ (ILLIXR::zed_capture::capture)</li> <li>camera_ (ILLIXR::zed_capture::capture)</li> <li>camL_file_ (ILLIXR::zed_capture::files)</li> <li>camL_path_ (ILLIXR::zed_capture::files)</li> <li>camR_file_ (ILLIXR::zed_capture::files)</li> <li>camR_path_ (ILLIXR::zed_capture::files)</li> <li>cam_file_ (ILLIXR::zed_capture::files)</li> <li>cam_conf_pub_ (ILLIXR::zed_imu_thread)</li> <li>camera_thread_ (ILLIXR::zed_imu_thread)</li> <li>cb_log_ (ILLIXR::switchboard::topic_subscription)</li> <li>cpu_time_start_ (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#d","title":"d","text":"<ul> <li>display_pixels_high (HMD::hmd_info_t)</li> <li>display_pixels_wide (HMD::hmd_info_t)</li> <li>deps (ILLIXR::Dependency)</li> <li>displayPixelsHigh (ILLIXR::data_format::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::data_format::hmd_physical_info)</li> <li>detections (ILLIXR::data_format::ht::ht_frame)</li> <li>data_root_path_ (ILLIXR::data_injection)</li> <li>demo_scene_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>demo_shader_program_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>demo_vao_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>display_backend_manages_glfw_ (ILLIXR::debugview)</li> <li>depth_count_ (ILLIXR::depthai)</li> <li>depth_queue_ (ILLIXR::depthai)</li> <li>device_ (ILLIXR::depthai, ILLIXR::openni_plugin)</li> <li>display_ (ILLIXR::display::x11_direct, ILLIXR::timewarp_gl, ILLIXR::xlib_gl_extended_window)</li> <li>display_event_fence_ (ILLIXR::display::x11_direct)</li> <li>display_timings_event_registered_ (ILLIXR::display::x11_direct)</li> <li>dataset_first_time_ (ILLIXR::ground_truth_slam, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::pose_lookup_impl)</li> <li>deletion_queue_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>depth_attachment_images_ (ILLIXR::native_renderer)</li> <li>depth_images_ (ILLIXR::native_renderer)</li> <li>display_sink_ (ILLIXR::native_renderer)</li> <li>dataset_now_ (ILLIXR::offline_imu)</li> <li>delimiter (ILLIXR::offload_reader)</li> <li>decode_converted_color_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_converted_depth_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_out_color_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_out_depth_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_src_color_packets_ (ILLIXR::offload_rendering_client)</li> <li>decode_src_depth_packets_ (ILLIXR::offload_rendering_client)</li> <li>decoded_frame_pose_ (ILLIXR::offload_rendering_client)</li> <li>device_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>display_provider_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>data_buffer_ (ILLIXR::offload_writer)</li> <li>depth_ (ILLIXR::openni_plugin)</li> <li>depth_frame_ (ILLIXR::openni_plugin)</li> <li>device_status_ (ILLIXR::openni_plugin)</li> <li>dc_index_alloc_ (ILLIXR::openwarp_vk)</li> <li>dc_index_buffer_ (ILLIXR::openwarp_vk)</li> <li>dc_vertex_alloc_ (ILLIXR::openwarp_vk)</li> <li>dc_vertex_buffer_ (ILLIXR::openwarp_vk)</li> <li>descriptor_pool_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>disable_warp_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_correction_render_pass_ (ILLIXR::openwarp_vk)</li> <li>distortion_indices_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_vertices_ (ILLIXR::openwarp_vk)</li> <li>dp_descriptor_set_layout_ (ILLIXR::openwarp_vk)</li> <li>dp_descriptor_sets_ (ILLIXR::openwarp_vk)</li> <li>dp_pipeline_layout_ (ILLIXR::openwarp_vk)</li> <li>dp_uniform_alloc_ (ILLIXR::openwarp_vk)</li> <li>dp_uniform_alloc_info_ (ILLIXR::openwarp_vk)</li> <li>dp_uniform_buffer_ (ILLIXR::openwarp_vk)</li> <li>D4XXI_found_ (ILLIXR::realsense)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>depth_data_dir_ (ILLIXR::record_rgb_depth)</li> <li>depth_wt_file_ (ILLIXR::record_rgb_depth)</li> <li>decoder_ (ILLIXR::server_reader)</li> <li>delimiter_ (ILLIXR::server_reader, ILLIXR::tcp_network_backend)</li> <li>database_ (ILLIXR::sqlite_thread)</li> <li>directory_ (ILLIXR::sqlite_thread)</li> <li>DELAY_FRACTION (ILLIXR::timewarp_gl)</li> <li>distortion_indices_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_pos_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_positions_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_positions_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv0_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_uv0_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv0_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv1_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_uv1_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv1_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv2_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_uv2_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv2_vbo_ (ILLIXR::timewarp_gl)</li> <li>descriptor_set_layout_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>descriptor_sets_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>detections_ (ILLIXR::viewer)</li> <li>depth_image_pool (ILLIXR::vulkan::buffer_pool)</li> <li>decode_family (ILLIXR::vulkan::queue_families)</li> <li>dedicated_transfer (ILLIXR::vulkan::queue_families)</li> <li>depth_ocv_ (ILLIXR::zed_camera_thread)</li> <li>depth_zed_ (ILLIXR::zed_camera_thread)</li> <li>data_of_ (ILLIXR::zed_capture::capture)</li> <li>data_file_ (ILLIXR::zed_capture::files)</li> <li>data_path_ (ILLIXR::zed_capture::files)</li> <li>data_sub_path_ (ILLIXR::zed_capture::files)</li> <li>data (ILLIXR::realsense::accel_type)</li> <li>dequeued_ (ILLIXR::switchboard::topic_subscription)</li> <li>data_ (csv_row)</li> <li>description (cxxopts::HelpGroupDetails)</li> <li>default_value (cxxopts::HelpOptionDetails)</li> <li>desc (cxxopts::HelpOptionDetails)</li> <li>desc_ (cxxopts::Option)</li> <li>direct_mode_ (display_vk)</li> <li>duration_ (print_timer, print_timer::print_in_destructor, timer)</li> </ul>"},{"location":"api/class_member_variables/#e","title":"e","text":"<ul> <li>eye_tiles_high (HMD::hmd_info_t)</li> <li>eye_tiles_wide (HMD::hmd_info_t)</li> <li>ext_window_ (ILLIXR::gldemo)</li> <li>eye_buffer_ (ILLIXR::gldemo)</li> <li>eye_texture_FBO_ (ILLIXR::gldemo)</li> <li>eye_texture_depth_target_ (ILLIXR::gldemo)</li> <li>eye_textures_ (ILLIXR::gldemo)</li> <li>export_dma_ (ILLIXR::native_renderer)</li> <li>enable_offload_ (ILLIXR::offload_data, ILLIXR::timewarp_gl)</li> <li>encode_out_color_packets_ (ILLIXR::offload_rendering_server)</li> <li>encode_out_depth_packets_ (ILLIXR::offload_rendering_server)</li> <li>encode_src_color_frames_ (ILLIXR::offload_rendering_server)</li> <li>encode_src_depth_frames_ (ILLIXR::offload_rendering_server)</li> <li>encoder_ (ILLIXR::offload_writer)</li> <li>enable_alignment_ (ILLIXR::pose_lookup_impl)</li> <li>enable_monado_ (ILLIXR::runtime)</li> <li>env_vars_ (ILLIXR::switchboard)</li> <li>eye_framebuffers_ (ILLIXR::timewarp_gl)</li> <li>eye_image_handles_ (ILLIXR::timewarp_gl)</li> <li>eye_output_textures_ (ILLIXR::timewarp_gl)</li> <li>eye_sampler_0_ (ILLIXR::timewarp_gl)</li> <li>eye_sampler_1_ (ILLIXR::timewarp_gl)</li> <li>eye_swapchains_ (ILLIXR::timewarp_gl)</li> <li>eye_swapchains_size_ (ILLIXR::timewarp_gl)</li> <li>eyebuffer_ (ILLIXR::timewarp_gl)</li> <li>enabled_right_ (ILLIXR::viewer)</li> <li>enabled_device_extensions_ (ILLIXR::vulkan::display_provider)</li> <li>enabled_instance_extensions_ (ILLIXR::vulkan::display_provider)</li> <li>encode_family (ILLIXR::vulkan::queue_families)</li> <li>export_image_info (ILLIXR::vulkan::vk_image)</li> <li>enqueued_ (ILLIXR::switchboard::topic_subscription)</li> </ul>"},{"location":"api/class_member_variables/#f","title":"f","text":"<ul> <li>fps (ILLIXR::data_format::camera_data)</li> <li>frame (ILLIXR::data_format::ht::raw_ht_data, ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame)</li> <li>fixed (ILLIXR::data_format::points_with_units)</li> <li>file_descriptor (ILLIXR::data_format::vk_image_handle)</li> <li>format (ILLIXR::data_format::vk_image_handle)</li> <li>frame_img_writer_ (ILLIXR::data_injection)</li> <li>frame_pose_writer_ (ILLIXR::data_injection)</li> <li>fast_pose_reader_ (ILLIXR::debugview)</li> <li>follow_headset_ (ILLIXR::debugview)</li> <li>first_cam_time_ (ILLIXR::depthai, ILLIXR::realsense)</li> <li>first_imu_time_ (ILLIXR::depthai, ILLIXR::realsense, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> <li>first_packet_time_ (ILLIXR::depthai)</li> <li>first_real_cam_time_ (ILLIXR::depthai)</li> <li>first_real_imu_time_ (ILLIXR::depthai)</li> <li>fov_x (ILLIXR::display_params)</li> <li>fov_y (ILLIXR::display_params)</li> <li>frequency (ILLIXR::display_params)</li> <li>first_time_ (ILLIXR::ground_truth_slam, ILLIXR::openni_plugin, ILLIXR::pose_prediction_impl)</li> <li>filters_ (ILLIXR::gtsam_integrator)</li> <li>fov_down (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fov_left (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fov_right (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fov_up (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fast_pose_ (ILLIXR::lighthouse)</li> <li>fast_pose_count_ (ILLIXR::lighthouse)</li> <li>fps_ (ILLIXR::native_renderer, ILLIXR::zed_capture::capture)</li> <li>frame_fence_ (ILLIXR::native_renderer)</li> <li>fd_ (ILLIXR::network::TCPSocket)</li> <li>fence_ (ILLIXR::offload_rendering_client)</li> <li>fps_counter_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>fps_start_time_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>frame_count_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>frame_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>frames_reader_ (ILLIXR::offload_rendering_client)</li> <li>framerate_ (ILLIXR::offload_rendering_server)</li> <li>frames_topic_ (ILLIXR::offload_rendering_server)</li> <li>frame_id_ (ILLIXR::offload_writer)</li> <li>first_real_time_ (ILLIXR::openni_plugin, ILLIXR::zed_imu_thread)</li> <li>fb_sampler_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>first_real_time_cam_ (ILLIXR::realsense)</li> <li>first_real_time_imu_ (ILLIXR::realsense)</li> <li>far_z (ILLIXR::rendering_params)</li> <li>flip_y_uniform_ (ILLIXR::timewarp_gl)</li> <li>features_ (ILLIXR::vulkan::display_provider)</li> <li>family (ILLIXR::vulkan::queue)</li> <li>formats (ILLIXR::vulkan::swapchain_details)</li> <li>fd (ILLIXR::vulkan::vk_image)</li> <li>frame_pub_ (ILLIXR::webcam)</li> <li>frame_ (ILLIXR::zed_camera)</li> </ul>"},{"location":"api/class_member_variables/#g","title":"g","text":"<ul> <li>gl_handle (ILLIXR::data_format::image_handle)</li> <li>gyro_noise (ILLIXR::data_format::imu_params)</li> <li>gyro_walk (ILLIXR::data_format::imu_params)</li> <li>gui_window_ (ILLIXR::debugview)</li> <li>guid_starts_ (ILLIXR::gen_guid)</li> <li>ground_truth_offset_ (ILLIXR::ground_truth_slam, ILLIXR::pose_prediction_impl)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>graphics_family (ILLIXR::vulkan::queue_families)</li> <li>grouping (cxxopts::values::parser_tool::ArguDesc)</li> </ul>"},{"location":"api/class_member_variables/#h","title":"h","text":"<ul> <li>height (ILLIXR::data_format::camera_data, ILLIXR::data_format::rect, ILLIXR::data_format::vk_image_handle)</li> <li>horizontal_fov (ILLIXR::data_format::ccd_data)</li> <li>hands (ILLIXR::data_format::ht::ht_detection)</li> <li>hand_positions (ILLIXR::data_format::ht::ht_frame)</li> <li>hand_velocities (ILLIXR::data_format::ht::ht_frame)</li> <li>h_points (ILLIXR::data_format::ht::raw_ht_data)</li> <li>h_velocities (ILLIXR::data_format::ht::raw_ht_data)</li> <li>hp_valid (ILLIXR::data_format::ht::raw_ht_data)</li> <li>hv_valid (ILLIXR::data_format::ht::raw_ht_data)</li> <li>headset_ (ILLIXR::debugview)</li> <li>height_meters (ILLIXR::display_params)</li> <li>height_pixels (ILLIXR::display_params)</li> <li>handle_ (ILLIXR::dynamic_lib)</li> <li>has_prev_ (ILLIXR::gtsam_integrator)</li> <li>height_ (ILLIXR::native_renderer, ILLIXR::xlib_gl_extended_window)</li> <li>hmd_info_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>has_last_offset_ (ILLIXR::rk4_integrator)</li> <li>hologram_ (ILLIXR::timewarp_gl)</li> <li>hologram_seq_ (ILLIXR::timewarp_gl)</li> <li>ht_frame_ (ILLIXR::viewer)</li> <li>ht_frames_ (ILLIXR::viewer)</li> <li>has_default (cxxopts::HelpOptionDetails)</li> <li>has_implicit (cxxopts::HelpOptionDetails)</li> </ul>"},{"location":"api/class_member_variables/#i","title":"i","text":"<ul> <li>images (ILLIXR::data_format::cam_base_type)</li> <li>ipd (ILLIXR::data_format::hmd_physical_info, ILLIXR::display_params)</li> <li>image_handle (ILLIXR::data_format::image_handle)</li> <li>imu_integration_sigma (ILLIXR::data_format::imu_params)</li> <li>imu_time (ILLIXR::data_format::imu_raw_type)</li> <li>image (ILLIXR::data_format::texture_pose, ILLIXR::texture, ILLIXR::vulkan::vk_image)</li> <li>images_ (ILLIXR::data_injection)</li> <li>imu_packet_ (ILLIXR::depthai)</li> <li>imu_pub_ (ILLIXR::depthai)</li> <li>imu_queue_ (ILLIXR::depthai)</li> <li>imu_writer_ (ILLIXR::depthai)</li> <li>image_handle_ (ILLIXR::gldemo)</li> <li>imu_integrator_input_ (ILLIXR::gtsam_integrator, ILLIXR::offload_reader, ILLIXR::passthrough_integrator, ILLIXR::rk4_integrator)</li> <li>imu_raw_ (ILLIXR::gtsam_integrator, ILLIXR::passthrough_integrator, ILLIXR::pose_prediction_impl, ILLIXR::rk4_integrator)</li> <li>imu_vector_ (ILLIXR::gtsam_integrator)</li> <li>index_count (ILLIXR::model)</li> <li>index_offset (ILLIXR::model)</li> <li>image_available_semaphore_ (ILLIXR::native_renderer)</li> <li>imu_ (ILLIXR::offline_imu, ILLIXR::realsense, ILLIXR::server_reader, ILLIXR::zed_imu_thread)</li> <li>imu_cam_log_ (ILLIXR::offline_imu)</li> <li>img_idx_ (ILLIXR::offload_data)</li> <li>is_success_ (ILLIXR::offload_data)</li> <li>img0_ (ILLIXR::offload_writer)</li> <li>img1_ (ILLIXR::offload_writer)</li> <li>img_ready_ (ILLIXR::offload_writer, ILLIXR::server_reader)</li> <li>imu_cam_writer_ (ILLIXR::offload_writer)</li> <li>initialized_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>input_texture_external_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>inverse_projection_ (ILLIXR::openwarp_vk)</li> <li>id_ (ILLIXR::plugin, ILLIXR::record_header)</li> <li>init_pos_offset_ (ILLIXR::pose_lookup_impl)</li> <li>iteration_accel_ (ILLIXR::realsense)</li> <li>imu_wt_file_ (ILLIXR::record_imu_cam)</li> <li>imu_vec_ (ILLIXR::rk4_integrator)</li> <li>imu0 (ILLIXR::sensor_types)</li> <li>img0_dst_ (ILLIXR::server_reader)</li> <li>img1_dst_ (ILLIXR::server_reader)</li> <li>imu_cam_reader_ (ILLIXR::server_reader)</li> <li>imu_int_input_ (ILLIXR::server_writer)</li> <li>insert_cmd_ (ILLIXR::sqlite_thread)</li> <li>insert_str_ (ILLIXR::sqlite_thread)</li> <li>is_client_ (ILLIXR::tcp_network_backend)</li> <li>image_memory (ILLIXR::texture)</li> <li>image_view (ILLIXR::texture, ILLIXR::vulkan::vk_image)</li> <li>internal_stop_ (ILLIXR::threadloop)</li> <li>iteration_no (ILLIXR::threadloop)</li> <li>image_handles_ready_ (ILLIXR::timewarp_gl)</li> <li>index_buffer_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>img0_map_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>img0_ready_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>img1_map_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>img1_ready_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>image_infos_ (ILLIXR::vkdemo)</li> <li>indices_ (ILLIXR::vkdemo)</li> <li>image_data (ILLIXR::vulkan::buffer_pool)</li> <li>image_pool (ILLIXR::vulkan::buffer_pool)</li> <li>image_state_mutex (ILLIXR::vulkan::buffer_pool)</li> <li>image_states (ILLIXR::vulkan::buffer_pool)</li> <li>image_info (ILLIXR::vulkan::vk_image)</li> <li>initial_position_ (ILLIXR::zed_camera)</li> <li>imageL_ocv_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>imageL_zed_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>imageR_ocv_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>imageR_zed_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>image_size_ (ILLIXR::zed_camera_thread)</li> <li>img_size_ (ILLIXR::zed_capture::capture)</li> <li>img_path_ (ILLIXR::zed_capture::files)</li> <li>img_sub_path_ (ILLIXR::zed_capture::files)</li> <li>instance_ (ILLIXR::zed_capture::files)</li> <li>it_log_ (ILLIXR::zed_imu_thread)</li> <li>imu_bias_ (ILLIXR::gtsam_integrator::pim_object)</li> <li>iteration (ILLIXR::realsense::accel_type)</li> <li>idle_cycles_ (ILLIXR::switchboard::topic_subscription)</li> <li>implicit_value (cxxopts::HelpOptionDetails)</li> <li>is_boolean (cxxopts::HelpOptionDetails)</li> <li>is_container (cxxopts::HelpOptionDetails)</li> </ul>"},{"location":"api/class_member_variables/#k","title":"k","text":"<ul> <li>K (HMD::hmd_info_t, ILLIXR::data_format::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#l","title":"l","text":"<ul> <li>lens_separation_in_meters (HMD::hmd_info_t)</li> <li>left_color_nalu (ILLIXR::data_format::compressed_frame)</li> <li>left_color_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>left_depth_nalu (ILLIXR::data_format::compressed_frame)</li> <li>left_depth_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>lensSeparationInMeters (ILLIXR::data_format::hmd_physical_info)</li> <li>last_cam_integration_time (ILLIXR::data_format::imu_integrator_input)</li> <li>linear_a (ILLIXR::data_format::imu_type, ILLIXR::raw_imu_type)</li> <li>latest_quaternion (ILLIXR::data_format::texture_pose)</li> <li>last_mouse_position_ (ILLIXR::debugview)</li> <li>left_count_ (ILLIXR::depthai)</li> <li>lens_separation (ILLIXR::display_params)</li> <li>lens_vertical_position (ILLIXR::display_params)</li> <li>library_path_ (ILLIXR::dynamic_lib)</li> <li>last_time_ (ILLIXR::gldemo, ILLIXR::lighthouse)</li> <li>last_cam_time_ (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>last_imu_offset_ (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>log_ (ILLIXR::gtsam_integrator, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_rendering_server_loader, ILLIXR::offload_writer, ILLIXR::server_reader)</li> <li>last_fps_update_ (ILLIXR::native_renderer)</li> <li>latency (ILLIXR::network::topic_config)</li> <li>last_timestamp_ (ILLIXR::offline_cam, ILLIXR::openni_plugin)</li> <li>layout_transition_end_cmd_bufs_ (ILLIXR::offload_rendering_client)</li> <li>layout_transition_start_cmd_bufs_ (ILLIXR::offload_rendering_client)</li> <li>last_frame_ind_ (ILLIXR::offload_rendering_server)</li> <li>latest_cam_time_ (ILLIXR::offload_writer)</li> <li>latest_imu_time_ (ILLIXR::offload_writer)</li> <li>last_print_ (ILLIXR::openwarp_vk_plugin, ILLIXR::timewarp_vk_plugin)</li> <li>last_iteration_accel_ (ILLIXR::realsense)</li> <li>last_log_ (ILLIXR::record_coalescer)</li> <li>logger_ (ILLIXR::record_coalescer)</li> <li>LOG_PERIOD_ (ILLIXR::timewarp_gl)</li> <li>log_count_ (ILLIXR::timewarp_gl)</li> <li>latest_decoded_image (ILLIXR::vulkan::buffer_pool)</li> <li>load_video_ (ILLIXR::webcam)</li> <li>last_imu_ts_ (ILLIXR::zed_imu_thread)</li> <li>last_serial_no_ (ILLIXR::zed_imu_thread)</li> <li>latest_buffer_ (ILLIXR::switchboard::topic)</li> <li>latest_buffer_size_ (ILLIXR::switchboard::topic)</li> <li>latest_index_ (ILLIXR::switchboard::topic)</li> <li>l (cxxopts::HelpOptionDetails)</li> <li>libraries_ (runtime_impl)</li> </ul>"},{"location":"api/class_member_variables/#m","title":"m","text":"<ul> <li>meters_per_tan_angle_at_center (HMD::hmd_info_t)</li> <li>magic (ILLIXR::data_format::compressed_frame)</li> <li>metersPerTanAngleAtCenter (ILLIXR::data_format::hmd_physical_info)</li> <li>model_view_attr_ (ILLIXR::debugview)</li> <li>mouse_velocity_ (ILLIXR::debugview)</li> <li>mutex_ (ILLIXR::depthai, ILLIXR::event, ILLIXR::offload_writer, ILLIXR::phonebook, ILLIXR::realsense, ILLIXR::server_reader)</li> <li>meters_per_tan_angle (ILLIXR::display_params)</li> <li>model_view_ (ILLIXR::gldemo)</li> <li>mat_ (ILLIXR::lazy_load_image)</li> <li>metrics_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>mtp_logger_ (ILLIXR::timewarp_gl)</li> <li>models_ (ILLIXR::vkdemo)</li> <li>mutex (ILLIXR::vulkan::queue)</li> <li>m_key (cxxopts::KeyValue)</li> <li>m_value (cxxopts::KeyValue, cxxopts::OptionDetails, cxxopts::OptionValue)</li> <li>m_group (cxxopts::OptionAdder)</li> <li>m_options (cxxopts::OptionAdder, cxxopts::OptionParser, cxxopts::Options)</li> <li>m_count (cxxopts::OptionDetails, cxxopts::OptionValue)</li> <li>m_desc (cxxopts::OptionDetails)</li> <li>m_hash (cxxopts::OptionDetails)</li> <li>m_long (cxxopts::OptionDetails)</li> <li>m_short (cxxopts::OptionDetails)</li> <li>m_allow_unrecognised (cxxopts::OptionParser, cxxopts::Options)</li> <li>m_defaults (cxxopts::OptionParser, cxxopts::ParseResult)</li> <li>m_keys (cxxopts::OptionParser, cxxopts::ParseResult)</li> <li>m_parsed (cxxopts::OptionParser)</li> <li>m_positional (cxxopts::OptionParser, cxxopts::Options)</li> <li>m_sequential (cxxopts::OptionParser, cxxopts::ParseResult::Iterator, cxxopts::ParseResult)</li> <li>m_default (cxxopts::OptionValue, cxxopts::values::abstract_value)</li> <li>m_long_names (cxxopts::OptionValue)</li> <li>m_custom_help (cxxopts::Options)</li> <li>m_help (cxxopts::Options)</li> <li>m_help_string (cxxopts::Options)</li> <li>m_positional_help (cxxopts::Options)</li> <li>m_positional_set (cxxopts::Options)</li> <li>m_program (cxxopts::Options)</li> <li>m_show_positional (cxxopts::Options)</li> <li>m_tab_expansion (cxxopts::Options)</li> <li>m_width (cxxopts::Options)</li> <li>m_iter (cxxopts::ParseResult::Iterator)</li> <li>m_pr (cxxopts::ParseResult::Iterator)</li> <li>m_unmatched (cxxopts::ParseResult)</li> <li>m_values (cxxopts::ParseResult)</li> <li>m_message (cxxopts::exceptions::exception)</li> <li>m_default_value (cxxopts::values::abstract_value)</li> <li>m_implicit (cxxopts::values::abstract_value)</li> <li>m_implicit_value (cxxopts::values::abstract_value)</li> <li>m_result (cxxopts::values::abstract_value)</li> <li>m_store (cxxopts::values::abstract_value)</li> <li>main_thread_ (display_vk)</li> <li>model_view (uniform_buffer_object)</li> </ul>"},{"location":"api/class_member_variables/#n","title":"n","text":"<ul> <li>num_knots (HMD::hmd_info_t)</li> <li>NUM_COLOR_CHANNELS (HMD)</li> <li>NUM_EYES (HMD)</li> <li>name (ILLIXR::Dependency, cxxopts::HelpGroupDetails)</li> <li>nalu_only (ILLIXR::data_format::compressed_frame)</li> <li>num_images (ILLIXR::data_format::image_handle)</li> <li>n_gravity (ILLIXR::data_format::imu_params)</li> <li>nominal_rate (ILLIXR::data_format::imu_params)</li> <li>next_row_ (ILLIXR::offline_cam)</li> <li>nalu_only_ (ILLIXR::offload_rendering_server)</li> <li>num_distortion_indices_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>num_distortion_vertices_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>num_openwarp_indices_ (ILLIXR::openwarp_vk)</li> <li>num_openwarp_vertices_ (ILLIXR::openwarp_vk)</li> <li>num_record_calls_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>num_update_uniforms_calls_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>name_ (ILLIXR::plugin, ILLIXR::record_header, ILLIXR::switchboard::topic, print_timer2)</li> <li>near_z (ILLIXR::rendering_params)</li> <li>networked_topics_ (ILLIXR::tcp_network_backend)</li> <li>networked_topics_configs_ (ILLIXR::tcp_network_backend)</li> <li>num_samples_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>nav_state_lkf_ (ILLIXR::gtsam_integrator::pim_object)</li> <li>negative (cxxopts::values::parser_tool::IntegerDesc)</li> <li>now_ (timer)</li> </ul>"},{"location":"api/class_member_variables/#o","title":"o","text":"<ul> <li>orientation (ILLIXR::data_format::pose_data, ILLIXR::state_plus)</li> <li>offload_duration (ILLIXR::data_format::texture_pose)</li> <li>offset_ (ILLIXR::data_injection, ILLIXR::fauxpose_impl, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>offset_mutex_ (ILLIXR::fauxpose_impl, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>on_start_ (ILLIXR::managed_thread)</li> <li>on_stop_ (ILLIXR::managed_thread)</li> <li>offscreen_export_mem_alloc_info_ (ILLIXR::native_renderer)</li> <li>offscreen_framebuffers_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk)</li> <li>offscreen_images_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk)</li> <li>offscreen_pool_ (ILLIXR::native_renderer)</li> <li>offscreen_pool_create_info_ (ILLIXR::native_renderer)</li> <li>obj_dir_ (ILLIXR::offload_data)</li> <li>offload_data_container_ (ILLIXR::offload_data)</li> <li>offload_rendering_server_plugin_ (ILLIXR::offload_rendering_server_loader)</li> <li>offloaded_rendering_ (ILLIXR::openwarp_vk)</li> <li>offscreen_depth_allocs_ (ILLIXR::openwarp_vk)</li> <li>offscreen_depth_views_ (ILLIXR::openwarp_vk)</li> <li>offscreen_depths_ (ILLIXR::openwarp_vk)</li> <li>offscreen_image_allocs_ (ILLIXR::openwarp_vk)</li> <li>offscreen_image_views_ (ILLIXR::openwarp_vk)</li> <li>openwarp_height_ (ILLIXR::openwarp_vk)</li> <li>openwarp_indices_ (ILLIXR::openwarp_vk)</li> <li>openwarp_pipeline_ (ILLIXR::openwarp_vk)</li> <li>openwarp_render_pass_ (ILLIXR::openwarp_vk)</li> <li>openwarp_vertices_ (ILLIXR::openwarp_vk)</li> <li>openwarp_width_ (ILLIXR::openwarp_vk)</li> <li>ow_descriptor_set_layout_ (ILLIXR::openwarp_vk)</li> <li>ow_descriptor_sets_ (ILLIXR::openwarp_vk)</li> <li>ow_index_alloc_ (ILLIXR::openwarp_vk)</li> <li>ow_index_buffer_ (ILLIXR::openwarp_vk)</li> <li>ow_matrices_uniform_alloc_ (ILLIXR::openwarp_vk)</li> <li>ow_matrices_uniform_alloc_info_ (ILLIXR::openwarp_vk)</li> <li>ow_matrices_uniform_buffer_ (ILLIXR::openwarp_vk)</li> <li>ow_pipeline_layout_ (ILLIXR::openwarp_vk)</li> <li>ow_vertex_alloc_ (ILLIXR::openwarp_vk)</li> <li>ow_vertex_buffer_ (ILLIXR::openwarp_vk)</li> <li>offload_data_ (ILLIXR::timewarp_gl)</li> <li>offload_duration_ (ILLIXR::timewarp_gl)</li> <li>orientation_ (ILLIXR::switchboard::coordinate_system)</li> <li>options (cxxopts::HelpGroupDetails)</li> <li>opts_ (cxxopts::Option)</li> <li>offload_rendering_client_plugin (offload_rendering_client_loader)</li> </ul>"},{"location":"api/class_member_variables/#p","title":"p","text":"<ul> <li>pos (ILLIXR::DistortionCorrectionVertex, ILLIXR::OpenWarpVertex, ILLIXR::data_format::imu_raw_type, ILLIXR::vertex, vertex)</li> <li>poses (ILLIXR::data_format::cam_type_zed)</li> <li>pose (ILLIXR::data_format::compressed_frame, ILLIXR::data_format::fast_pose_type)</li> <li>predict_computed_time (ILLIXR::data_format::fast_pose_type)</li> <li>predict_target_time (ILLIXR::data_format::fast_pose_type)</li> <li>palms (ILLIXR::data_format::ht::ht_detection)</li> <li>points (ILLIXR::data_format::ht::ht_detection, ILLIXR::data_format::ht::position, ILLIXR::data_format::points_with_units)</li> <li>proc_time (ILLIXR::data_format::ht::ht_detection)</li> <li>params (ILLIXR::data_format::imu_integrator_input)</li> <li>position (ILLIXR::data_format::imu_integrator_input, ILLIXR::data_format::pose_data, ILLIXR::data_format::texture_pose, ILLIXR::state_plus)</li> <li>pose_time (ILLIXR::data_format::texture_pose)</li> <li>poses_ (ILLIXR::data_injection)</li> <li>pose_prediction_ (ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>projection_attr_ (ILLIXR::debugview)</li> <li>period (ILLIXR::display_params)</li> <li>period_ (ILLIXR::fauxpose_impl)</li> <li>projection_ (ILLIXR::gldemo)</li> <li>pim_obj_ (ILLIXR::gtsam_integrator)</li> <li>prev_euler_angles_ (ILLIXR::gtsam_integrator)</li> <li>path_ (ILLIXR::lazy_load_image)</li> <li>packetization (ILLIXR::network::topic_config)</li> <li>priority (ILLIXR::network::topic_config)</li> <li>percent_ (ILLIXR::offload_data)</li> <li>pose_ (ILLIXR::offload_reader, ILLIXR::viewer)</li> <li>pose_writer_ (ILLIXR::offload_rendering_client)</li> <li>phonebook_ (ILLIXR::openwarp_vk, ILLIXR::plugin, ILLIXR::switchboard, ILLIXR::timewarp_vk, runtime_impl)</li> <li>plugin_logger_ (ILLIXR::plugin)</li> <li>pipeline_ (ILLIXR::realsense, ILLIXR::vulkan::render_pass)</li> <li>profiles_ (ILLIXR::realsense)</li> <li>peer_socket_ (ILLIXR::tcp_network_backend)</li> <li>PBO_buffer_ (ILLIXR::timewarp_gl)</li> <li>pipeline_layout_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>pipeline_img0_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>pipeline_img1_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>pipeline_sync_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>pipeline_sync_mutex_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>processed_size (ILLIXR::viewer)</li> <li>present_family (ILLIXR::vulkan::queue_families)</li> <li>present_modes (ILLIXR::vulkan::swapchain_details)</li> <li>pim_ (ILLIXR::gtsam_integrator::pim_object)</li> <li>position_ (ILLIXR::switchboard::coordinate_system)</li> <li>plugin_id_ (ILLIXR::switchboard::topic_subscription)</li> <li>print_in_destructor_ (print_timer)</li> <li>plugins_ (runtime_impl)</li> <li>proj (uniform_buffer_object)</li> </ul>"},{"location":"api/class_member_variables/#q","title":"q","text":"<ul> <li>quat (ILLIXR::data_format::imu_integrator_input, ILLIXR::data_format::imu_raw_type)</li> <li>queue_ (ILLIXR::offload_writer, ILLIXR::server_reader, ILLIXR::sqlite_thread, ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>queues_ (ILLIXR::vulkan::display_provider)</li> <li>queue_size_ (ILLIXR::switchboard::topic_buffer)</li> <li>queue_timeout_ (ILLIXR::switchboard::topic_subscription)</li> </ul>"},{"location":"api/class_member_variables/#r","title":"r","text":"<ul> <li>render_inv_projection (ILLIXR::WarpMatrices)</li> <li>render_inv_view (ILLIXR::WarpMatrices)</li> <li>right_color_nalu (ILLIXR::data_format::compressed_frame)</li> <li>right_color_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>right_depth_nalu (ILLIXR::data_format::compressed_frame)</li> <li>right_depth_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>reference (ILLIXR::data_format::ht::ht_frame, ILLIXR::data_format::ht::raw_ht_data)</li> <li>ref_space (ILLIXR::data_format::pose_data)</li> <li>rotation (ILLIXR::data_format::rect)</li> <li>render_pose (ILLIXR::data_format::rendered_frame)</li> <li>render_time (ILLIXR::data_format::rendered_frame)</li> <li>render_quaternion (ILLIXR::data_format::texture_pose)</li> <li>rgb_depth_ (ILLIXR::debugview, ILLIXR::depthai, ILLIXR::openni_plugin, ILLIXR::realsense, ILLIXR::zed_imu_thread)</li> <li>rgb_depth_reader_ (ILLIXR::debugview)</li> <li>rgb_depth_texture_ (ILLIXR::debugview)</li> <li>rgbd_texture_size_ (ILLIXR::debugview)</li> <li>rectif_left_queue_ (ILLIXR::depthai)</li> <li>rectif_right_queue_ (ILLIXR::depthai)</li> <li>rgb_count_ (ILLIXR::depthai)</li> <li>rgbd_pub_ (ILLIXR::depthai)</li> <li>right_count_ (ILLIXR::depthai)</li> <li>retransmit (ILLIXR::network::topic_config)</li> <li>ready_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::stoplight, ILLIXR::tcp_network_backend, display_vk)</li> <li>render_pose_ (ILLIXR::offload_rendering_server)</li> <li>registry_ (ILLIXR::phonebook, ILLIXR::switchboard)</li> <li>record_logger_ (ILLIXR::plugin, ILLIXR::switchboard, ILLIXR::switchboard::topic, ILLIXR::switchboard::topic_subscription)</li> <li>realsense_cam_ (ILLIXR::realsense)</li> <li>record_header_ (ILLIXR::record, ILLIXR::sqlite_thread)</li> <li>record_data_ (ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth)</li> <li>rgb_data_dir_ (ILLIXR::record_rgb_depth)</li> <li>rgb_wt_file_ (ILLIXR::record_rgb_depth)</li> <li>reverse_z (ILLIXR::rendering_params)</li> <li>registered_tables_ (ILLIXR::sqlite_record_logger)</li> <li>registry_lock_ (ILLIXR::sqlite_record_logger, ILLIXR::switchboard)</li> <li>root_coordinates (ILLIXR::switchboard)</li> <li>running_ (ILLIXR::tcp_network_backend, display_vk)</li> <li>rendering_ready_ (ILLIXR::timewarp_gl)</li> <li>root_window_ (ILLIXR::timewarp_gl)</li> <li>raw_size (ILLIXR::viewer)</li> <li>requested_unit_ (ILLIXR::viewer)</li> <li>rgb_ocv_ (ILLIXR::zed_camera_thread)</li> <li>rgb_zed_ (ILLIXR::zed_camera_thread)</li> <li>runtime_parameters_ (ILLIXR::zed_camera_thread)</li> <li>raw_img_ (ILLIXR::zed_capture::capture)</li> <li>runtime_params_ (ILLIXR::zed_capture::capture)</li> <li>root_ (ILLIXR::zed_capture::files)</li> <li>row_ (csv_iterator)</li> <li>required_device_extensions_ (display_vk)</li> </ul>"},{"location":"api/class_member_variables/#s","title":"s","text":"<ul> <li>serial_no (ILLIXR::data_format::cam_type_zed)</li> <li>sent_time (ILLIXR::data_format::compressed_frame)</li> <li>start (ILLIXR::data_format::connection_signal)</li> <li>seq (ILLIXR::data_format::hologram_input, ILLIXR::data_format::signal_to_quad)</li> <li>sensor_time (ILLIXR::data_format::pose_type)</li> <li>sample_time (ILLIXR::data_format::rendered_frame)</li> <li>swap_indices (ILLIXR::data_format::rendered_frame)</li> <li>swapchain_indices (ILLIXR::data_format::rendered_frame)</li> <li>step_ (ILLIXR::data_injection)</li> <li>switchboard_ (ILLIXR::data_injection, ILLIXR::debugview, ILLIXR::depthai, ILLIXR::fauxpose_impl, ILLIXR::gldemo, ILLIXR::ground_truth_slam, ILLIXR::gtsam_integrator, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_data, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_writer, ILLIXR::openni_plugin, ILLIXR::openwarp_vk, ILLIXR::passthrough_integrator, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl, ILLIXR::realsense, ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth, ILLIXR::rk4_integrator, ILLIXR::runtime, ILLIXR::server_reader, ILLIXR::server_writer, ILLIXR::tcp_network_backend, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk, ILLIXR::viewer, ILLIXR::vkdemo, ILLIXR::webcam, ILLIXR::zed_camera, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread, display_vk)</li> <li>slow_pose_reader_ (ILLIXR::debugview)</li> <li>selected_mode_ (ILLIXR::display::x11_direct)</li> <li>sim_start_time_ (ILLIXR::fauxpose_impl)</li> <li>sensor_data_ (ILLIXR::ground_truth_slam, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::pose_lookup_impl)</li> <li>s_context_ (ILLIXR::lighthouse)</li> <li>slow_pose_ (ILLIXR::lighthouse, ILLIXR::pose_prediction_impl)</li> <li>slow_pose_count_ (ILLIXR::lighthouse)</li> <li>stop_ (ILLIXR::managed_thread)</li> <li>swapchain_framebuffers_ (ILLIXR::native_renderer)</li> <li>swapchain_image_index_ (ILLIXR::native_renderer)</li> <li>serialization_method (ILLIXR::network::topic_config)</li> <li>sensor_data_it_ (ILLIXR::offline_imu, ILLIXR::pose_lookup_impl)</li> <li>server_ip_ (ILLIXR::offload_reader, ILLIXR::offload_writer, ILLIXR::tcp_network_backend)</li> <li>socket_ (ILLIXR::offload_reader, ILLIXR::offload_writer)</li> <li>sizes_ (ILLIXR::offload_writer)</li> <li>stoplight_ (ILLIXR::offload_writer, ILLIXR::threadloop)</li> <li>setup_mutex_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>swapchain_height_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>swapchain_width_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>start_ (ILLIXR::relative_clock, timer)</li> <li>should_stop_ (ILLIXR::stoplight)</li> <li>shutdown_complete_ (ILLIXR::stoplight)</li> <li>serial_no_ (ILLIXR::switchboard::buffered_reader, ILLIXR::zed_camera_thread, print_timer2)</li> <li>server_port_ (ILLIXR::tcp_network_backend)</li> <li>skip_no (ILLIXR::threadloop)</li> <li>signal_quad_seq_ (ILLIXR::timewarp_gl)</li> <li>single_eye_ (ILLIXR::viewer)</li> <li>swapchain_extent_ (ILLIXR::vulkan::display_provider)</li> <li>swapchain_image_format_ (ILLIXR::vulkan::display_provider)</li> <li>swapchain_image_views_ (ILLIXR::vulkan::display_provider)</li> <li>swapchain_images_ (ILLIXR::vulkan::display_provider)</li> <li>sensors_data_ (ILLIXR::zed_imu_thread)</li> <li>subscriptions_ (ILLIXR::switchboard::topic)</li> <li>subscriptions_lock_ (ILLIXR::switchboard::topic)</li> <li>stream_ (csv_iterator)</li> <li>s (cxxopts::HelpOptionDetails)</li> <li>set_value (cxxopts::values::parser_tool::ArguDesc)</li> <li>selected_gpu_ (display_vk)</li> <li>should_poll_ (display_vk)</li> </ul>"},{"location":"api/class_member_variables/#t","title":"t","text":"<ul> <li>tile_pixels_high (HMD::hmd_info_t)</li> <li>tile_pixels_wide (HMD::hmd_info_t)</li> <li>transform (ILLIXR::DistortionMatrix)</li> <li>terminate_ (ILLIXR::cancellable_sleep, ILLIXR::sqlite_thread)</li> <li>time (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::ht::position, ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::imu_type)</li> <li>type (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::image_handle, ILLIXR::vulkan::queue)</li> <li>t_offset (ILLIXR::data_format::imu_integrator_input)</li> <li>timepoints_ (ILLIXR::data_injection)</li> <li>test_pattern_ (ILLIXR::debugview)</li> <li>tracking_position_offset_ (ILLIXR::debugview)</li> <li>test_time_point_ (ILLIXR::depthai)</li> <li>true_pose_ (ILLIXR::ground_truth_slam, ILLIXR::pose_prediction_impl)</li> <li>thread_ (ILLIXR::managed_thread, ILLIXR::sqlite_thread, ILLIXR::threadloop, ILLIXR::switchboard::topic_subscription)</li> <li>texture_index (ILLIXR::model, model_push_constant)</li> <li>timeline_semaphore_value_ (ILLIXR::native_renderer)</li> <li>timewarp_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk_plugin, ILLIXR::timewarp_vk_plugin)</li> <li>timewarp_command_buffer_ (ILLIXR::native_renderer)</li> <li>timewarp_pass_ (ILLIXR::native_renderer)</li> <li>timewarp_render_finished_semaphore_ (ILLIXR::native_renderer)</li> <li>time_seq_ (ILLIXR::offload_data)</li> <li>time_sleep_ (ILLIXR::openni_plugin)</li> <li>T26X_found_ (ILLIXR::realsense)</li> <li>total_imu_ (ILLIXR::rk4_integrator)</li> <li>table_name_ (ILLIXR::sqlite_thread)</li> <li>topic_ (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::reader, ILLIXR::switchboard::writer)</li> <li>topic_buffer_ (ILLIXR::switchboard::buffered_reader)</li> <li>time_since_epoch_ (ILLIXR::time_point)</li> <li>time_last_swap_ (ILLIXR::timewarp_gl)</li> <li>timewarp_gpu_logger_ (ILLIXR::timewarp_gl)</li> <li>timewarp_shader_program_ (ILLIXR::timewarp_gl)</li> <li>tw_end_transform_uniform_ (ILLIXR::timewarp_gl)</li> <li>tw_eye_index_uniform_ (ILLIXR::timewarp_gl)</li> <li>tw_start_transform_uniform_ (ILLIXR::timewarp_gl)</li> <li>tw_vao (ILLIXR::timewarp_gl)</li> <li>timewarp_render_pass_ (ILLIXR::timewarp_vk)</li> <li>tab_label_ (ILLIXR::viewer)</li> <li>textures_ (ILLIXR::viewer, ILLIXR::vkdemo, ILLIXR::zed_capture::capture)</li> <li>texture_map_ (ILLIXR::vkdemo)</li> <li>texture_sampler_ (ILLIXR::vkdemo)</li> <li>timepoint_ (ILLIXR::zed_capture::capture)</li> <li>type_info_ (ILLIXR::switchboard::topic)</li> <li>token_ (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>topic_name_ (ILLIXR::switchboard::topic_subscription)</li> <li>timer_ (print_timer)</li> <li>timewarp_end_transform (uniform_buffer_object)</li> <li>timewarp_start_transform (uniform_buffer_object)</li> </ul>"},{"location":"api/class_member_variables/#u","title":"u","text":"<ul> <li>u (HMD::uv_coord_t)</li> <li>uv0 (ILLIXR::DistortionCorrectionVertex, vertex)</li> <li>uv1 (ILLIXR::DistortionCorrectionVertex, vertex)</li> <li>uv2 (ILLIXR::DistortionCorrectionVertex, vertex)</li> <li>uv (ILLIXR::OpenWarpVertex, ILLIXR::vertex)</li> <li>units (ILLIXR::data_format::camera_data, ILLIXR::data_format::depth_type, ILLIXR::data_format::rgb_depth_type)</li> <li>use_depth (ILLIXR::data_format::compressed_frame)</li> <li>unit (ILLIXR::data_format::ht::ht_frame, ILLIXR::data_format::ht::position, ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::point_with_units, ILLIXR::data_format::points_with_units, ILLIXR::data_format::pose_data, ILLIXR::data_format::rect)</li> <li>usage (ILLIXR::data_format::image_handle)</li> <li>used_ (ILLIXR::data_use_indicator)</li> <li>use_cam_ (ILLIXR::debugview)</li> <li>use_rgb_depth_ (ILLIXR::debugview)</li> <li>use_raw_ (ILLIXR::depthai)</li> <li>u_step_ (ILLIXR::offload_rendering_client)</li> <li>use_depth_ (ILLIXR::offload_rendering_client)</li> <li>use_pass_depth_ (ILLIXR::offload_rendering_server)</li> <li>using_godot_ (ILLIXR::openwarp_vk)</li> <li>using_lighthouse_ (ILLIXR::pose_prediction_impl)</li> <li>underlying_data_ (ILLIXR::switchboard::event_wrapper)</li> <li>uniform_alloc_ (ILLIXR::timewarp_vk)</li> <li>uniform_alloc_info_ (ILLIXR::timewarp_vk)</li> <li>uniform_buffer_ (ILLIXR::timewarp_vk)</li> <li>uniform_buffer_allocation_infos_ (ILLIXR::vkdemo)</li> <li>uniform_buffer_allocations_ (ILLIXR::vkdemo)</li> <li>uniform_buffers_ (ILLIXR::vkdemo)</li> </ul>"},{"location":"api/class_member_variables/#v","title":"v","text":"<ul> <li>visible_meters_high (HMD::hmd_info_t)</li> <li>visible_meters_wide (HMD::hmd_info_t)</li> <li>visible_pixels_high (HMD::hmd_info_t)</li> <li>visible_pixels_wide (HMD::hmd_info_t)</li> <li>v (HMD::uv_coord_t)</li> <li>vertical_fov (ILLIXR::data_format::ccd_data)</li> <li>visibleMetersHigh (ILLIXR::data_format::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::data_format::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::data_format::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::data_format::hmd_physical_info)</li> <li>valid (ILLIXR::data_format::ht::position, ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::point_with_validity, ILLIXR::data_format::points_with_units, ILLIXR::data_format::pose_data, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose, ILLIXR::data_format::rect)</li> <li>vk_handle (ILLIXR::data_format::image_handle)</li> <li>velocity (ILLIXR::data_format::imu_integrator_input, ILLIXR::state_plus)</li> <li>vel (ILLIXR::data_format::imu_raw_type)</li> <li>vertex_normal_attr_ (ILLIXR::debugview)</li> <li>vertex_pos_attr (ILLIXR::debugview)</li> <li>view_distance_ (ILLIXR::debugview)</li> <li>view_euler_ (ILLIXR::debugview)</li> <li>vk_instance_ (ILLIXR::display::display_backend, ILLIXR::vulkan::display_provider)</li> <li>vk_device_ (ILLIXR::display::x11_direct, ILLIXR::vulkan::display_provider)</li> <li>vk_physical_device_ (ILLIXR::display::x11_direct, ILLIXR::vulkan::display_provider)</li> <li>vsync_topic_ (ILLIXR::display::x11_direct)</li> <li>value_ (ILLIXR::event, cxxopts::Option)</li> <li>vsync_estimate_ (ILLIXR::fauxpose_impl, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl, ILLIXR::timewarp_gl)</li> <li>vertex_normal_ (ILLIXR::gldemo)</li> <li>vertex_position_ (ILLIXR::gldemo)</li> <li>vsync_ (ILLIXR::gldemo, ILLIXR::native_renderer, ILLIXR::timewarp_vk)</li> <li>vertex_offset (ILLIXR::model)</li> <li>vio_pose_reader_ (ILLIXR::offload_reader)</li> <li>v_step_ (ILLIXR::offload_rendering_client)</li> <li>vma_allocator_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::display_provider)</li> <li>values_ (ILLIXR::record)</li> <li>vio_pose_writer_ (ILLIXR::server_writer)</li> <li>vertex_buffer_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>viewport_ (ILLIXR::viewer, ILLIXR::zed_capture::capture)</li> <li>vertices_ (ILLIXR::vkdemo)</li> <li>vkd_ (ILLIXR::vkdemo_plugin)</li> <li>vk_surface_ (ILLIXR::vulkan::display_provider)</li> <li>vk_swapchain_ (ILLIXR::vulkan::display_provider)</li> <li>vk_frame (ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame)</li> <li>vk_queue (ILLIXR::vulkan::queue)</li> <li>value (cxxopts::values::parser_tool::ArguDesc, cxxopts::values::parser_tool::IntegerDesc, cxxopts::values::type_is_container, cxxopts::values::type_is_container&lt; std::vector&lt; T &gt; &gt;)</li> </ul>"},{"location":"api/class_member_variables/#w","title":"w","text":"<ul> <li>warp_view_projection (ILLIXR::WarpMatrices)</li> <li>width (ILLIXR::data_format::camera_data, ILLIXR::data_format::rect, ILLIXR::data_format::vk_image_handle)</li> <li>wcs_offset (ILLIXR::data_format::ht::ht_frame)</li> <li>wcs_origin (ILLIXR::data_format::ht::raw_ht_data)</li> <li>w_hat (ILLIXR::data_format::imu_raw_type)</li> <li>w_hat2 (ILLIXR::data_format::imu_raw_type)</li> <li>w (ILLIXR::data_format::raw_pose)</li> <li>wx (ILLIXR::data_format::raw_pose)</li> <li>wy (ILLIXR::data_format::raw_pose)</li> <li>wz (ILLIXR::data_format::raw_pose)</li> <li>window_ (ILLIXR::display::glfw_extended, ILLIXR::xlib_gl_extended_window)</li> <li>width_meters (ILLIXR::display_params)</li> <li>width_pixels (ILLIXR::display_params)</li> <li>which_buffer_ (ILLIXR::gldemo)</li> <li>width_ (ILLIXR::native_renderer, ILLIXR::xlib_gl_extended_window)</li> <li>wcs_xform_ (ILLIXR::zed_capture::capture)</li> <li>wall_time_start_ (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#x","title":"x","text":"<ul> <li>x (HMD::mesh_coord2d_t, HMD::mesh_coord3d_t, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>x_center (ILLIXR::data_format::rect)</li> </ul>"},{"location":"api/class_member_variables/#y","title":"y","text":"<ul> <li>y (HMD::mesh_coord2d_t, HMD::mesh_coord3d_t, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>y_center (ILLIXR::data_format::rect)</li> <li>y_step_ (ILLIXR::offload_rendering_client)</li> <li>yuv420_u_plane_ (ILLIXR::offload_rendering_client)</li> <li>yuv420_v_plane_ (ILLIXR::offload_rendering_client)</li> <li>yuv420_y_plane_ (ILLIXR::offload_rendering_client)</li> </ul>"},{"location":"api/class_member_variables/#z","title":"z","text":"<ul> <li>z (HMD::mesh_coord3d_t, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>zed_cam_ (ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> </ul>"},{"location":"api/class_members/","title":"Class Members","text":""},{"location":"api/class_members/#a","title":"a","text":"<ul> <li>at (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::points_with_units)</li> <li>acc_noise (ILLIXR::data_format::imu_params)</li> <li>acc_walk (ILLIXR::data_format::imu_params)</li> <li>a_hat (ILLIXR::data_format::imu_raw_type)</li> <li>a_hat2 (ILLIXR::data_format::imu_raw_type)</li> <li>angular_v (ILLIXR::data_format::imu_type, ILLIXR::raw_imu_type)</li> <li>asVector (ILLIXR::data_format::proper_quaternion)</li> <li>allocation_size (ILLIXR::data_format::vk_image_handle)</li> <li>all_count_ (ILLIXR::depthai)</li> <li>aberration (ILLIXR::display_params)</li> <li>amplitude_ (ILLIXR::fauxpose_impl)</li> <li>app_ (ILLIXR::native_renderer)</li> <li>app_command_buffer_ (ILLIXR::native_renderer)</li> <li>app_pass_ (ILLIXR::native_renderer)</li> <li>app_render_finished_semaphore_ (ILLIXR::native_renderer)</li> <li>allow_out_of_order (ILLIXR::network::topic_config)</li> <li>avvk_color_frames_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>avvk_depth_frames_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>align_quat_ (ILLIXR::pose_lookup_impl)</li> <li>align_rot_ (ILLIXR::pose_lookup_impl)</li> <li>align_scale_ (ILLIXR::pose_lookup_impl)</li> <li>align_trans_ (ILLIXR::pose_lookup_impl)</li> <li>apply_offset (ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>accel_data_ (ILLIXR::realsense)</li> <li>absolute_ns (ILLIXR::relative_clock)</li> <li>allocate (ILLIXR::switchboard::writer)</li> <li>appsink_img0_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>appsink_img1_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>appsrc_img0_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>appsrc_img1_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>allocation (ILLIXR::vulkan::vk_image)</li> <li>allocation_info (ILLIXR::vulkan::vk_image)</li> <li>arg_help (cxxopts::HelpOptionDetails)</li> <li>as (cxxopts::KeyValue, cxxopts::OptionValue)</li> <li>arg_help_ (cxxopts::Option)</li> <li>add_to_option (cxxopts::OptionParser)</li> <li>add_one_option (cxxopts::Options)</li> <li>add_option (cxxopts::Options)</li> <li>add_options (cxxopts::Options)</li> <li>allow_unrecognised_options (cxxopts::Options)</li> <li>arguments (cxxopts::ParseResult)</li> <li>arguments_string (cxxopts::ParseResult)</li> <li>abstract_value (cxxopts::values::abstract_value)</li> <li>arg_name (cxxopts::values::parser_tool::ArguDesc)</li> <li>account_name_ (print_timer::print_in_destructor)</li> <li>actually_should_profile_ (should_profile_class)</li> </ul>"},{"location":"api/class_members/#b","title":"b","text":"<ul> <li>build_distortion_meshes (HMD)</li> <li>binocular_cam_type (ILLIXR::data_format::binocular_cam_type)</li> <li>begin (ILLIXR::data_format::cam_base_type, cxxopts::ParseResult)</li> <li>baseline (ILLIXR::data_format::camera_data)</li> <li>bias_acc (ILLIXR::data_format::imu_integrator_input)</li> <li>bias_gyro (ILLIXR::data_format::imu_integrator_input)</li> <li>Base (ILLIXR::data_format::proper_quaternion)</li> <li>base_time_ (ILLIXR::data_injection)</li> <li>basic_projection_ (ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>being_dragged_ (ILLIXR::debugview)</li> <li>body_ (ILLIXR::managed_thread)</li> <li>buffer_pool_ (ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>BUFFER_SIZE (ILLIXR::network::TCPSocket)</li> <li>bitrate_ (ILLIXR::offload_rendering_server)</li> <li>buffer_ (ILLIXR::record_coalescer)</li> <li>buffer_str_ (ILLIXR::server_reader)</li> <li>buffered_reader (ILLIXR::switchboard::buffered_reader)</li> <li>backend_ (ILLIXR::switchboard::network_writer, display_vk)</li> <li>build_timewarp (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>base_unit_ (ILLIXR::viewer)</li> <li>basicProjection_ (ILLIXR::viewer)</li> <li>bake_models (ILLIXR::vkdemo)</li> <li>buffer_pool (ILLIXR::vulkan::buffer_pool)</li> <li>bias_hat (ILLIXR::gtsam_integrator::pim_object)</li> <li>buffers_ (ILLIXR::switchboard::topic)</li> <li>base (cxxopts::values::parser_tool::IntegerDesc)</li> <li>backend_type_ (display_vk)</li> </ul>"},{"location":"api/class_members/#c","title":"c","text":"<ul> <li>chromatic_aberration (HMD::hmd_info_t)</li> <li>cancel (ILLIXR::cancellable_sleep)</li> <li>cam_base_type (ILLIXR::data_format::cam_base_type)</li> <li>cam_type_zed (ILLIXR::data_format::cam_type_zed)</li> <li>camera_data (ILLIXR::data_format::camera_data)</li> <li>ccds (ILLIXR::data_format::camera_data)</li> <li>ccd_data (ILLIXR::data_format::ccd_data)</li> <li>center_x (ILLIXR::data_format::ccd_data)</li> <li>center_y (ILLIXR::data_format::ccd_data)</li> <li>compressed_frame (ILLIXR::data_format::compressed_frame)</li> <li>connection_signal (ILLIXR::data_format::connection_signal)</li> <li>chromaticAberration (ILLIXR::data_format::hmd_physical_info)</li> <li>check (ILLIXR::data_format::ht::hand_points)</li> <li>clear (ILLIXR::data_format::ht::hand_points, ILLIXR::event)</li> <li>confidence (ILLIXR::data_format::ht::ht_detection, ILLIXR::data_format::point_with_validity, ILLIXR::data_format::pose_data)</li> <li>copy (ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>check_validity (ILLIXR::data_format::points_with_units)</li> <li>co_frame (ILLIXR::data_format::pose_data)</li> <li>correct_pose (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>cast (ILLIXR::data_format::proper_quaternion)</li> <li>camera_data_ (ILLIXR::data_injection)</li> <li>camera_data_writer_ (ILLIXR::data_injection)</li> <li>counter_ (ILLIXR::data_injection, ILLIXR::rk4_integrator)</li> <li>current_ (ILLIXR::data_injection)</li> <li>cam_ (ILLIXR::debugview, ILLIXR::offload_writer, ILLIXR::realsense, ILLIXR::record_imu_cam, ILLIXR::server_reader, ILLIXR::zed_camera_thread)</li> <li>cam_reader_ (ILLIXR::debugview, ILLIXR::zed_imu_thread)</li> <li>camera_texture_ (ILLIXR::debugview)</li> <li>camera_texture_size_ (ILLIXR::debugview)</li> <li>color_uniform_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>callback (ILLIXR::depthai, ILLIXR::gtsam_integrator, ILLIXR::offload_data, ILLIXR::passthrough_integrator, ILLIXR::realsense, ILLIXR::rk4_integrator)</li> <li>cam_writer_ (ILLIXR::depthai)</li> <li>clock_ (ILLIXR::depthai, ILLIXR::display::x11_direct, ILLIXR::fauxpose_impl, ILLIXR::gldemo, ILLIXR::gtsam_integrator, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_writer, ILLIXR::openni_plugin, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl, ILLIXR::realsense, ILLIXR::server_reader, ILLIXR::timewarp_gl, ILLIXR::viewer, ILLIXR::vkdemo, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread, display_vk)</li> <li>color_queue_ (ILLIXR::depthai)</li> <li>create_camera_pipeline (ILLIXR::depthai)</li> <li>cleanup (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct, display_vk)</li> <li>create_surface (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>create (ILLIXR::dynamic_lib)</li> <li>cv_ (ILLIXR::event)</li> <li>center_location_ (ILLIXR::fauxpose_impl)</li> <li>create_FBO (ILLIXR::gldemo)</li> <li>create_shared_eyebuffer (ILLIXR::gldemo)</li> <li>clean_imu_vec (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>command_pool_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_app_pass (ILLIXR::native_renderer)</li> <li>create_depth_image (ILLIXR::native_renderer)</li> <li>create_offscreen_framebuffers (ILLIXR::native_renderer)</li> <li>create_offscreen_pool (ILLIXR::native_renderer)</li> <li>create_offscreen_target (ILLIXR::native_renderer)</li> <li>create_swapchain_framebuffers (ILLIXR::native_renderer)</li> <li>create_sync_objects (ILLIXR::native_renderer)</li> <li>create_timewarp_pass (ILLIXR::native_renderer)</li> <li>cam_publisher_ (ILLIXR::offline_cam, ILLIXR::zed_imu_thread)</li> <li>codec_color_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>codec_depth_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>command_pool (ILLIXR::offload_rendering_client)</li> <li>copy_image_to_cpu_and_save_file (ILLIXR::offload_rendering_client)</li> <li>create_cuda_frame_ctx (ILLIXR::offload_rendering_client)</li> <li>cuda_bgra_frame_ctx_ (ILLIXR::offload_rendering_client)</li> <li>cuda_device_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>cuda_nv12_frame_ctx_ (ILLIXR::offload_rendering_client)</li> <li>cuda_frame_ctx_ (ILLIXR::offload_rendering_server)</li> <li>condition_var_ (ILLIXR::offload_writer)</li> <li>cam_time_ (ILLIXR::openni_plugin)</li> <li>camera_initialize (ILLIXR::openni_plugin)</li> <li>color_ (ILLIXR::openni_plugin)</li> <li>color_frame_ (ILLIXR::openni_plugin)</li> <li>calculate_distortion_transform (ILLIXR::openwarp_vk)</li> <li>command_buffer_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_camera_matrix (ILLIXR::openwarp_vk)</li> <li>create_descriptor_pool (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_descriptor_set_layouts (ILLIXR::openwarp_vk)</li> <li>create_descriptor_sets (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>create_distortion_correction_pipeline (ILLIXR::openwarp_vk)</li> <li>create_index_buffers (ILLIXR::openwarp_vk)</li> <li>create_offscreen_images (ILLIXR::openwarp_vk)</li> <li>create_openwarp_pipeline (ILLIXR::openwarp_vk)</li> <li>create_texture_sampler (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>create_uniform_buffers (ILLIXR::openwarp_vk, ILLIXR::vkdemo)</li> <li>create_vertex_buffers (ILLIXR::openwarp_vk)</li> <li>cam_enum (ILLIXR::realsense)</li> <li>cam_select_ (ILLIXR::realsense)</li> <li>config_ (ILLIXR::realsense, ILLIXR::switchboard::network_writer, ILLIXR::zed_camera)</li> <li>configure_camera (ILLIXR::realsense)</li> <li>columns_ (ILLIXR::record_header)</li> <li>cam0_data_dir_ (ILLIXR::record_imu_cam)</li> <li>cam0_wt_file_ (ILLIXR::record_imu_cam)</li> <li>cam1_data_dir_ (ILLIXR::record_imu_cam)</li> <li>cam1_wt_file_ (ILLIXR::record_imu_cam)</li> <li>cam_count_ (ILLIXR::rk4_integrator)</li> <li>cam0 (ILLIXR::sensor_types)</li> <li>cam1 (ILLIXR::sensor_types)</li> <li>condition_variable_ (ILLIXR::server_reader)</li> <li>check_should_stop (ILLIXR::stoplight)</li> <li>check_shutdown_complete (ILLIXR::stoplight)</li> <li>client (ILLIXR::tcp_network_backend)</li> <li>client_ip_ (ILLIXR::tcp_network_backend)</li> <li>client_port_ (ILLIXR::tcp_network_backend)</li> <li>calculate_time_warp_transform (ILLIXR::timewarp_gl)</li> <li>client_backend_ (ILLIXR::timewarp_gl)</li> <li>context_ (ILLIXR::timewarp_gl, ILLIXR::xlib_gl_extended_window)</li> <li>convert_vk_format_to_GL (ILLIXR::timewarp_gl)</li> <li>calculate_timewarp_transform (ILLIXR::timewarp_vk)</li> <li>clamp_edge_ (ILLIXR::timewarp_vk)</li> <li>create_descriptor_set_layout (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_index_buffer (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_pipeline (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>create_uniform_buffer (ILLIXR::timewarp_vk)</li> <li>create_vertex_buffer (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>callback_ (ILLIXR::video_decoder, ILLIXR::video_encoder, ILLIXR::switchboard::topic_subscription)</li> <li>cb_appsink (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>create_pipelines (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>clear_color_ (ILLIXR::viewer, ILLIXR::zed_capture::capture)</li> <li>combined_size (ILLIXR::viewer)</li> <li>current_frame_ (ILLIXR::viewer)</li> <li>create_descriptor_set (ILLIXR::vkdemo)</li> <li>create_texture_sampler_ (ILLIXR::vkdemo)</li> <li>compute_family (ILLIXR::vulkan::queue_families)</li> <li>capabilities (ILLIXR::vulkan::swapchain_details)</li> <li>capture_ (ILLIXR::webcam)</li> <li>color_map_ (ILLIXR::xlib_gl_extended_window)</li> <li>confidence_ocv_ (ILLIXR::zed_camera_thread)</li> <li>confidence_zed_ (ILLIXR::zed_camera_thread)</li> <li>camL_of_ (ILLIXR::zed_capture::capture)</li> <li>camR_of_ (ILLIXR::zed_capture::capture)</li> <li>camera_ (ILLIXR::zed_capture::capture)</li> <li>capture (ILLIXR::zed_capture::capture)</li> <li>camL_file_ (ILLIXR::zed_capture::files)</li> <li>camL_path_ (ILLIXR::zed_capture::files)</li> <li>camR_file_ (ILLIXR::zed_capture::files)</li> <li>camR_path_ (ILLIXR::zed_capture::files)</li> <li>cam_file_ (ILLIXR::zed_capture::files)</li> <li>cam_conf_pub_ (ILLIXR::zed_imu_thread)</li> <li>camera_thread_ (ILLIXR::zed_imu_thread)</li> <li>coordinate_system (ILLIXR::switchboard::coordinate_system)</li> <li>cb_log_ (ILLIXR::switchboard::topic_subscription)</li> <li>csv_iterator (csv_iterator)</li> <li>checked_parse_arg (cxxopts::OptionParser)</li> <li>consume_positional (cxxopts::OptionParser)</li> <li>count (cxxopts::OptionValue, cxxopts::ParseResult)</li> <li>custom_help (cxxopts::Options)</li> <li>clone (cxxopts::Value, cxxopts::values::standard_value, cxxopts::values::standard_value&lt; bool &gt;)</li> <li>create_logical_device (display_vk)</li> <li>create_swapchain (display_vk)</li> <li>create_vk_instance (display_vk)</li> <li>cpu_time_start_ (print_timer2)</li> </ul>"},{"location":"api/class_members/#d","title":"d","text":"<ul> <li>display_pixels_high (HMD::hmd_info_t)</li> <li>display_pixels_wide (HMD::hmd_info_t)</li> <li>deps (ILLIXR::Dependency)</li> <li>depth_type (ILLIXR::data_format::depth_type)</li> <li>displayPixelsHigh (ILLIXR::data_format::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::data_format::hmd_physical_info)</li> <li>detections (ILLIXR::data_format::ht::ht_frame)</li> <li>de_transform (ILLIXR::data_format::raw_point)</li> <li>data_injection (ILLIXR::data_injection)</li> <li>data_root_path_ (ILLIXR::data_injection)</li> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>debugview (ILLIXR::debugview)</li> <li>demo_scene_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>demo_shader_program_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>demo_vao_ (ILLIXR::debugview, ILLIXR::gldemo)</li> <li>display_backend_manages_glfw_ (ILLIXR::debugview)</li> <li>draw_GUI (ILLIXR::debugview)</li> <li>depth_count_ (ILLIXR::depthai)</li> <li>depth_queue_ (ILLIXR::depthai)</li> <li>depthai (ILLIXR::depthai)</li> <li>device_ (ILLIXR::depthai, ILLIXR::openni_plugin)</li> <li>display_backend_type (ILLIXR::display::display_backend)</li> <li>display_ (ILLIXR::display::x11_direct, ILLIXR::timewarp_gl, ILLIXR::xlib_gl_extended_window)</li> <li>display_event_fence_ (ILLIXR::display::x11_direct)</li> <li>display_timings_event_registered_ (ILLIXR::display::x11_direct)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> <li>dataset_first_time_ (ILLIXR::ground_truth_slam, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::pose_lookup_impl)</li> <li>deletion_queue_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>depth_attachment_images_ (ILLIXR::native_renderer)</li> <li>depth_images_ (ILLIXR::native_renderer)</li> <li>display_sink_ (ILLIXR::native_renderer)</li> <li>dataset_now_ (ILLIXR::offline_imu)</li> <li>delimiter (ILLIXR::offload_reader)</li> <li>decode_converted_color_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_converted_depth_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_out_color_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_out_depth_frames_ (ILLIXR::offload_rendering_client)</li> <li>decode_src_color_packets_ (ILLIXR::offload_rendering_client)</li> <li>decode_src_depth_packets_ (ILLIXR::offload_rendering_client)</li> <li>decoded_frame_pose_ (ILLIXR::offload_rendering_client)</li> <li>destroy (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>device_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>display_provider_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>data_buffer_ (ILLIXR::offload_writer)</li> <li>depth_ (ILLIXR::openni_plugin)</li> <li>depth_frame_ (ILLIXR::openni_plugin)</li> <li>device_status_ (ILLIXR::openni_plugin)</li> <li>dc_index_alloc_ (ILLIXR::openwarp_vk)</li> <li>dc_index_buffer_ (ILLIXR::openwarp_vk)</li> <li>dc_vertex_alloc_ (ILLIXR::openwarp_vk)</li> <li>dc_vertex_buffer_ (ILLIXR::openwarp_vk)</li> <li>descriptor_pool_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>disable_warp_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_correction_render_pass_ (ILLIXR::openwarp_vk)</li> <li>distortion_indices_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_vertices_ (ILLIXR::openwarp_vk)</li> <li>dp_descriptor_set_layout_ (ILLIXR::openwarp_vk)</li> <li>dp_descriptor_sets_ (ILLIXR::openwarp_vk)</li> <li>dp_pipeline_layout_ (ILLIXR::openwarp_vk)</li> <li>dp_uniform_alloc_ (ILLIXR::openwarp_vk)</li> <li>dp_uniform_alloc_info_ (ILLIXR::openwarp_vk)</li> <li>dp_uniform_buffer_ (ILLIXR::openwarp_vk)</li> <li>D4XXI_found_ (ILLIXR::realsense)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>dump_data (ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth)</li> <li>depth_data_dir_ (ILLIXR::record_rgb_depth)</li> <li>depth_wt_file_ (ILLIXR::record_rgb_depth)</li> <li>duration (ILLIXR::relative_clock, ILLIXR::time_point)</li> <li>decoder_ (ILLIXR::server_reader)</li> <li>delimiter_ (ILLIXR::server_reader, ILLIXR::tcp_network_backend)</li> <li>database_ (ILLIXR::sqlite_thread)</li> <li>directory_ (ILLIXR::sqlite_thread)</li> <li>dequeue (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer)</li> <li>DELAY_FRACTION (ILLIXR::timewarp_gl)</li> <li>distortion_indices_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_pos_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_positions_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_positions_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv0_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_uv0_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv0_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv1_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_uv1_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv1_vbo_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv2_ (ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>distortion_uv2_attr_ (ILLIXR::timewarp_gl)</li> <li>distortion_uv2_vbo_ (ILLIXR::timewarp_gl)</li> <li>descriptor_set_layout_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>descriptor_sets_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>detections_ (ILLIXR::viewer)</li> <li>depth_image_pool (ILLIXR::vulkan::buffer_pool)</li> <li>decode_family (ILLIXR::vulkan::queue_families)</li> <li>dedicated_transfer (ILLIXR::vulkan::queue_families)</li> <li>depth_ocv_ (ILLIXR::zed_camera_thread)</li> <li>depth_zed_ (ILLIXR::zed_camera_thread)</li> <li>data_of_ (ILLIXR::zed_capture::capture)</li> <li>data_file_ (ILLIXR::zed_capture::files)</li> <li>data_path_ (ILLIXR::zed_capture::files)</li> <li>data_sub_path_ (ILLIXR::zed_capture::files)</li> <li>data (ILLIXR::realsense::accel_type)</li> <li>deserialize_and_put (ILLIXR::switchboard::topic)</li> <li>dequeued_ (ILLIXR::switchboard::topic_subscription)</li> <li>decode (YAML::convert&lt; ILLIXR::Dependency &gt;)</li> <li>difference_type (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>data_ (csv_row)</li> <li>description (cxxopts::HelpGroupDetails, cxxopts::OptionDetails)</li> <li>default_value (cxxopts::HelpOptionDetails, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>desc (cxxopts::HelpOptionDetails)</li> <li>desc_ (cxxopts::Option)</li> <li>defaults (cxxopts::ParseResult)</li> <li>destroy_swapchain (display_vk)</li> <li>direct_mode_ (display_vk)</li> <li>display_vk (display_vk)</li> <li>duration_ (print_timer, print_timer::print_in_destructor, timer)</li> </ul>"},{"location":"api/class_members/#e","title":"e","text":"<ul> <li>eye_tiles_high (HMD::hmd_info_t)</li> <li>eye_tiles_wide (HMD::hmd_info_t)</li> <li>evaluate_catmull_rom_spline (HMD)</li> <li>end (ILLIXR::data_format::cam_base_type, cxxopts::ParseResult)</li> <li>enforce_bounds (ILLIXR::data_format::points_with_units)</li> <li>ext_window_ (ILLIXR::gldemo)</li> <li>eye_buffer_ (ILLIXR::gldemo)</li> <li>eye_texture_FBO_ (ILLIXR::gldemo)</li> <li>eye_texture_depth_target_ (ILLIXR::gldemo)</li> <li>eye_textures_ (ILLIXR::gldemo)</li> <li>export_dma_ (ILLIXR::native_renderer)</li> <li>enable_no_delay (ILLIXR::network::TCPSocket)</li> <li>enable_offload_ (ILLIXR::offload_data, ILLIXR::timewarp_gl)</li> <li>encode_out_color_packets_ (ILLIXR::offload_rendering_server)</li> <li>encode_out_depth_packets_ (ILLIXR::offload_rendering_server)</li> <li>encode_src_color_frames_ (ILLIXR::offload_rendering_server)</li> <li>encode_src_depth_frames_ (ILLIXR::offload_rendering_server)</li> <li>enqueue_for_network_send (ILLIXR::offload_rendering_server)</li> <li>encoder_ (ILLIXR::offload_writer)</li> <li>enable_alignment_ (ILLIXR::pose_lookup_impl)</li> <li>enable_monado_ (ILLIXR::runtime)</li> <li>event_wrapper (ILLIXR::switchboard::event_wrapper)</li> <li>env_names (ILLIXR::switchboard)</li> <li>env_vars_ (ILLIXR::switchboard)</li> <li>estimate_time_to_sleep (ILLIXR::timewarp_gl)</li> <li>eye_framebuffers_ (ILLIXR::timewarp_gl)</li> <li>eye_image_handles_ (ILLIXR::timewarp_gl)</li> <li>eye_output_textures_ (ILLIXR::timewarp_gl)</li> <li>eye_sampler_0_ (ILLIXR::timewarp_gl)</li> <li>eye_sampler_1_ (ILLIXR::timewarp_gl)</li> <li>eye_swapchains_ (ILLIXR::timewarp_gl)</li> <li>eye_swapchains_size_ (ILLIXR::timewarp_gl)</li> <li>eyebuffer_ (ILLIXR::timewarp_gl)</li> <li>enqueue (ILLIXR::video_decoder, ILLIXR::video_encoder, ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>enabled_right_ (ILLIXR::viewer)</li> <li>enabled_device_extensions_ (ILLIXR::vulkan::display_provider)</li> <li>enabled_instance_extensions_ (ILLIXR::vulkan::display_provider)</li> <li>encode_family (ILLIXR::vulkan::queue_families)</li> <li>export_image_info (ILLIXR::vulkan::vk_image)</li> <li>enqueued_ (ILLIXR::switchboard::topic_subscription)</li> <li>encode (YAML::convert&lt; ILLIXR::Dependency &gt;)</li> <li>essential_name (cxxopts::OptionDetails)</li> <li>ensure_value (cxxopts::OptionValue)</li> <li>exception (cxxopts::exceptions::exception)</li> </ul>"},{"location":"api/class_members/#f","title":"f","text":"<ul> <li>find (ILLIXR::data_format::cam_base_type)</li> <li>format (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::vk_image_handle)</li> <li>fps (ILLIXR::data_format::camera_data)</li> <li>fast_pose_type (ILLIXR::data_format::fast_pose_type)</li> <li>flip_y (ILLIXR::data_format::ht::hand_points, ILLIXR::data_format::rect)</li> <li>frame (ILLIXR::data_format::ht::raw_ht_data, ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame)</li> <li>fixed (ILLIXR::data_format::points_with_units)</li> <li>fast_pose_reliable (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>file_descriptor (ILLIXR::data_format::vk_image_handle)</li> <li>frame_img_writer_ (ILLIXR::data_injection)</li> <li>frame_pose_writer_ (ILLIXR::data_injection)</li> <li>fast_pose_reader_ (ILLIXR::debugview)</li> <li>follow_headset_ (ILLIXR::debugview)</li> <li>first_cam_time_ (ILLIXR::depthai, ILLIXR::realsense)</li> <li>first_imu_time_ (ILLIXR::depthai, ILLIXR::realsense, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> <li>first_packet_time_ (ILLIXR::depthai)</li> <li>first_real_cam_time_ (ILLIXR::depthai)</li> <li>first_real_imu_time_ (ILLIXR::depthai)</li> <li>fov_x (ILLIXR::display_params)</li> <li>fov_y (ILLIXR::display_params)</li> <li>frequency (ILLIXR::display_params)</li> <li>fauxpose (ILLIXR::fauxpose)</li> <li>fauxpose_impl (ILLIXR::fauxpose_impl)</li> <li>feed_ground_truth (ILLIXR::ground_truth_slam)</li> <li>first_time_ (ILLIXR::ground_truth_slam, ILLIXR::openni_plugin, ILLIXR::pose_prediction_impl)</li> <li>filters_ (ILLIXR::gtsam_integrator)</li> <li>fov_down (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fov_left (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fov_right (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fov_up (ILLIXR::index_params, ILLIXR::server_params)</li> <li>fast_pose_ (ILLIXR::lighthouse)</li> <li>fast_pose_count_ (ILLIXR::lighthouse)</li> <li>fps_ (ILLIXR::native_renderer, ILLIXR::zed_capture::capture)</li> <li>frame_fence_ (ILLIXR::native_renderer)</li> <li>fd_ (ILLIXR::network::TCPSocket)</li> <li>fence_ (ILLIXR::offload_rendering_client)</li> <li>ffmpeg_init_buffer_pool (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_cuda_device (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_cuda_frame_ctx (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_decoder (ILLIXR::offload_rendering_client)</li> <li>ffmpeg_init_device (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>ffmpeg_init_frame_ctx (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>fps_counter_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>fps_start_time_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>frame_count_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>frame_ctx_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>frames_reader_ (ILLIXR::offload_rendering_client)</li> <li>ffmpeg_init_encoder (ILLIXR::offload_rendering_server)</li> <li>framerate_ (ILLIXR::offload_rendering_server)</li> <li>frames_topic_ (ILLIXR::offload_rendering_server)</li> <li>frame_id_ (ILLIXR::offload_writer)</li> <li>first_real_time_ (ILLIXR::openni_plugin, ILLIXR::zed_imu_thread)</li> <li>fb_sampler_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>find_supported_devices (ILLIXR::realsense)</li> <li>first_real_time_cam_ (ILLIXR::realsense)</li> <li>first_real_time_imu_ (ILLIXR::realsense)</li> <li>flush (ILLIXR::record_coalescer)</li> <li>far_z (ILLIXR::rendering_params)</li> <li>flip_y_uniform_ (ILLIXR::timewarp_gl)</li> <li>features_ (ILLIXR::vulkan::display_provider)</li> <li>family (ILLIXR::vulkan::queue)</li> <li>formats (ILLIXR::vulkan::swapchain_details)</li> <li>fd (ILLIXR::vulkan::vk_image)</li> <li>frame_pub_ (ILLIXR::webcam)</li> <li>frame_ (ILLIXR::zed_camera)</li> <li>files (ILLIXR::zed_capture::files)</li> <li>first_long_name (cxxopts::OptionDetails)</li> <li>finalise_aliases (cxxopts::OptionParser)</li> </ul>"},{"location":"api/class_members/#g","title":"g","text":"<ul> <li>get_default_hmd_info (HMD)</li> <li>get_attribute_descriptions (ILLIXR::DistortionCorrectionVertex, ILLIXR::OpenWarpVertex, ILLIXR::vertex, vertex)</li> <li>get_binding_description (ILLIXR::DistortionCorrectionVertex, ILLIXR::OpenWarpVertex, ILLIXR::vertex, vertex)</li> <li>gl_handle (ILLIXR::data_format::image_handle)</li> <li>gyro_noise (ILLIXR::data_format::imu_params)</li> <li>gyro_walk (ILLIXR::data_format::imu_params)</li> <li>get_fast_pose (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>get_offset (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>get_true_pose (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>generate_headset_transform (ILLIXR::debugview)</li> <li>gui_window_ (ILLIXR::debugview)</li> <li>get_required_device_extensions (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>get_required_instance_extensions (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct, ILLIXR::offload_rendering_server_loader, offload_rendering_client_loader)</li> <li>get_type (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>get_framebuffer_size (ILLIXR::display::glfw_extended)</li> <li>glfw_extended (ILLIXR::display::glfw_extended)</li> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid, ILLIXR::switchboard::topic, cxxopts::values::abstract_value)</li> <li>guid_starts_ (ILLIXR::gen_guid)</li> <li>gldemo (ILLIXR::gldemo)</li> <li>ground_truth_offset_ (ILLIXR::ground_truth_slam, ILLIXR::pose_prediction_impl)</li> <li>ground_truth_slam (ILLIXR::ground_truth_slam)</li> <li>gtsam_integrator (ILLIXR::gtsam_integrator)</li> <li>get_state (ILLIXR::managed_thread)</li> <li>get_required_devices_extensions (ILLIXR::offload_rendering_server_loader, offload_rendering_client_loader)</li> <li>generate_distortion_data (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>generate_openwarp_mesh (ILLIXR::openwarp_vk)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>get_record_data_path (ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth)</li> <li>get_switchboard (ILLIXR::runtime)</li> <li>get_sqlite_thread (ILLIXR::sqlite_record_logger)</li> <li>get_ro (ILLIXR::switchboard::reader)</li> <li>get_ro_nullable (ILLIXR::switchboard::reader)</li> <li>get_rw (ILLIXR::switchboard::reader)</li> <li>get_buffered_reader (ILLIXR::switchboard)</li> <li>get_env (ILLIXR::switchboard)</li> <li>get_env_bool (ILLIXR::switchboard)</li> <li>get_env_char (ILLIXR::switchboard)</li> <li>get_network_writer (ILLIXR::switchboard)</li> <li>get_reader (ILLIXR::switchboard)</li> <li>get_topic (ILLIXR::switchboard)</li> <li>get_writer (ILLIXR::switchboard)</li> <li>get_next_swap_time_estimate (ILLIXR::timewarp_gl)</li> <li>graphics_family (ILLIXR::vulkan::queue_families)</li> <li>getBaseline (ILLIXR::zed_camera)</li> <li>getPosition (ILLIXR::zed_camera)</li> <li>get_config (ILLIXR::zed_camera, ILLIXR::zed_capture::capture)</li> <li>get_initial_position (ILLIXR::zed_camera)</li> <li>get_orientation (ILLIXR::zed_camera)</li> <li>get_translation (ILLIXR::zed_camera)</li> <li>get_camera (ILLIXR::zed_capture::capture)</li> <li>get_data (ILLIXR::zed_capture::capture)</li> <li>getInstance (ILLIXR::zed_capture::files)</li> <li>get_buffer (ILLIXR::switchboard::topic)</li> <li>generate_all_groups_help (cxxopts::Options)</li> <li>generate_group_help (cxxopts::Options)</li> <li>group_help (cxxopts::Options)</li> <li>groups (cxxopts::Options)</li> <li>get_default_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>get_implicit_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>gratuitous_argument_for_option (cxxopts::exceptions::gratuitous_argument_for_option)</li> <li>grouping (cxxopts::values::parser_tool::ArguDesc)</li> </ul>"},{"location":"api/class_members/#h","title":"h","text":"<ul> <li>height (ILLIXR::data_format::camera_data, ILLIXR::data_format::rect, ILLIXR::data_format::vk_image_handle)</li> <li>horizontal_fov (ILLIXR::data_format::ccd_data)</li> <li>hologram_input (ILLIXR::data_format::hologram_input)</li> <li>hand_points (ILLIXR::data_format::ht::hand_points)</li> <li>hands (ILLIXR::data_format::ht::ht_detection)</li> <li>ht_detection (ILLIXR::data_format::ht::ht_detection)</li> <li>hand_positions (ILLIXR::data_format::ht::ht_frame)</li> <li>hand_velocities (ILLIXR::data_format::ht::ht_frame)</li> <li>ht_frame (ILLIXR::data_format::ht::ht_frame)</li> <li>h_points (ILLIXR::data_format::ht::raw_ht_data)</li> <li>h_velocities (ILLIXR::data_format::ht::raw_ht_data)</li> <li>hp_valid (ILLIXR::data_format::ht::raw_ht_data)</li> <li>hv_valid (ILLIXR::data_format::ht::raw_ht_data)</li> <li>headset_ (ILLIXR::debugview)</li> <li>height_meters (ILLIXR::display_params)</li> <li>height_pixels (ILLIXR::display_params)</li> <li>handle_ (ILLIXR::dynamic_lib)</li> <li>has_prev_ (ILLIXR::gtsam_integrator)</li> <li>height_ (ILLIXR::native_renderer, ILLIXR::xlib_gl_extended_window)</li> <li>hmd_info_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>has_impl (ILLIXR::phonebook)</li> <li>has_last_offset_ (ILLIXR::rk4_integrator)</li> <li>hologram_ (ILLIXR::timewarp_gl)</li> <li>hologram_seq_ (ILLIXR::timewarp_gl)</li> <li>ht_frame_ (ILLIXR::viewer)</li> <li>ht_frames_ (ILLIXR::viewer)</li> <li>has_compression (ILLIXR::vulkan::queue_families)</li> <li>has_presentation (ILLIXR::vulkan::queue_families)</li> <li>has_default (cxxopts::HelpOptionDetails, cxxopts::OptionValue, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>has_implicit (cxxopts::HelpOptionDetails, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>hash (cxxopts::OptionDetails)</li> <li>help (cxxopts::Options)</li> <li>help_one_group (cxxopts::Options)</li> </ul>"},{"location":"api/class_members/#i","title":"i","text":"<ul> <li>images (ILLIXR::data_format::cam_base_type)</li> <li>ipd (ILLIXR::data_format::hmd_physical_info, ILLIXR::display_params)</li> <li>image_handle (ILLIXR::data_format::image_handle)</li> <li>imu_integrator_input (ILLIXR::data_format::imu_integrator_input)</li> <li>imu_integration_sigma (ILLIXR::data_format::imu_params)</li> <li>imu_raw_type (ILLIXR::data_format::imu_raw_type)</li> <li>imu_time (ILLIXR::data_format::imu_raw_type)</li> <li>imu_type (ILLIXR::data_format::imu_type)</li> <li>img (ILLIXR::data_format::monocular_cam_type)</li> <li>image (ILLIXR::data_format::texture_pose, ILLIXR::texture, ILLIXR::vulkan::vk_image)</li> <li>images_ (ILLIXR::data_injection)</li> <li>is_used (ILLIXR::data_use_indicator)</li> <li>imu_packet_ (ILLIXR::depthai)</li> <li>imu_pub_ (ILLIXR::depthai)</li> <li>imu_queue_ (ILLIXR::depthai)</li> <li>imu_writer_ (ILLIXR::depthai)</li> <li>is_set (ILLIXR::event)</li> <li>image_handle_ (ILLIXR::gldemo)</li> <li>imu_integrator_input_ (ILLIXR::gtsam_integrator, ILLIXR::offload_reader, ILLIXR::passthrough_integrator, ILLIXR::rk4_integrator)</li> <li>imu_raw_ (ILLIXR::gtsam_integrator, ILLIXR::passthrough_integrator, ILLIXR::pose_prediction_impl, ILLIXR::rk4_integrator)</li> <li>imu_vector_ (ILLIXR::gtsam_integrator)</li> <li>interpolate_imu (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>index_count (ILLIXR::model)</li> <li>index_offset (ILLIXR::model)</li> <li>image_available_semaphore_ (ILLIXR::native_renderer)</li> <li>is_topic_networked (ILLIXR::network::network_backend, ILLIXR::tcp_network_backend)</li> <li>imu_ (ILLIXR::offline_imu, ILLIXR::realsense, ILLIXR::server_reader, ILLIXR::zed_imu_thread)</li> <li>imu_cam_log_ (ILLIXR::offline_imu)</li> <li>img_idx_ (ILLIXR::offload_data)</li> <li>is_success_ (ILLIXR::offload_data)</li> <li>is_external (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>img0_ (ILLIXR::offload_writer)</li> <li>img1_ (ILLIXR::offload_writer)</li> <li>img_ready_ (ILLIXR::offload_writer, ILLIXR::server_reader)</li> <li>imu_cam_writer_ (ILLIXR::offload_writer)</li> <li>initialize (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>initialized_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>input_texture_external_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>inverse_projection_ (ILLIXR::openwarp_vk)</li> <li>id_ (ILLIXR::plugin, ILLIXR::record_header)</li> <li>init_pos_offset_ (ILLIXR::pose_lookup_impl)</li> <li>iteration_accel_ (ILLIXR::realsense)</li> <li>imu_wt_file_ (ILLIXR::record_imu_cam)</li> <li>is_started (ILLIXR::relative_clock)</li> <li>imu_vec_ (ILLIXR::rk4_integrator)</li> <li>imu0 (ILLIXR::sensor_types)</li> <li>img0_dst_ (ILLIXR::server_reader)</li> <li>img1_dst_ (ILLIXR::server_reader)</li> <li>imu_cam_reader_ (ILLIXR::server_reader)</li> <li>imu_int_input_ (ILLIXR::server_writer)</li> <li>insert_cmd_ (ILLIXR::sqlite_thread)</li> <li>insert_str_ (ILLIXR::sqlite_thread)</li> <li>is_client_ (ILLIXR::tcp_network_backend)</li> <li>image_memory (ILLIXR::texture)</li> <li>image_view (ILLIXR::texture, ILLIXR::vulkan::vk_image)</li> <li>internal_stop (ILLIXR::threadloop)</li> <li>internal_stop_ (ILLIXR::threadloop)</li> <li>iteration_no (ILLIXR::threadloop)</li> <li>image_handles_ready_ (ILLIXR::timewarp_gl)</li> <li>import_vulkan_image (ILLIXR::timewarp_gl)</li> <li>index_buffer_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>img0_map_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>img0_ready_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>img1_map_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>img1_ready_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>init (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>image_infos_ (ILLIXR::vkdemo)</li> <li>image_layout_transition (ILLIXR::vkdemo)</li> <li>indices_ (ILLIXR::vkdemo)</li> <li>image_data (ILLIXR::vulkan::buffer_pool)</li> <li>image_pool (ILLIXR::vulkan::buffer_pool)</li> <li>image_state (ILLIXR::vulkan::buffer_pool)</li> <li>image_state_mutex (ILLIXR::vulkan::buffer_pool)</li> <li>image_states (ILLIXR::vulkan::buffer_pool)</li> <li>image_info (ILLIXR::vulkan::vk_image)</li> <li>initial_position_ (ILLIXR::zed_camera)</li> <li>imageL_ocv_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>imageL_zed_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>imageR_ocv_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>imageR_zed_ (ILLIXR::zed_camera_thread, ILLIXR::zed_capture::capture)</li> <li>image_size_ (ILLIXR::zed_camera_thread)</li> <li>img_size_ (ILLIXR::zed_capture::capture)</li> <li>img_path_ (ILLIXR::zed_capture::files)</li> <li>img_sub_path_ (ILLIXR::zed_capture::files)</li> <li>instance_ (ILLIXR::zed_capture::files)</li> <li>it_log_ (ILLIXR::zed_imu_thread)</li> <li>imu_bias_ (ILLIXR::gtsam_integrator::pim_object)</li> <li>integrate_measurement (ILLIXR::gtsam_integrator::pim_object)</li> <li>iteration (ILLIXR::realsense::accel_type)</li> <li>idle_cycles_ (ILLIXR::switchboard::topic_subscription)</li> <li>iterator_category (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>implicit_value (cxxopts::HelpOptionDetails, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>is_boolean (cxxopts::HelpOptionDetails, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>is_container (cxxopts::HelpOptionDetails, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>Iterator (cxxopts::ParseResult::Iterator)</li> <li>incorrect_argument_type (cxxopts::exceptions::incorrect_argument_type)</li> <li>invalid_option_format (cxxopts::exceptions::invalid_option_format)</li> <li>invalid_option_syntax (cxxopts::exceptions::invalid_option_syntax)</li> <li>is_physical_device_suitable (display_vk)</li> </ul>"},{"location":"api/class_members/#k","title":"k","text":"<ul> <li>K (HMD::hmd_info_t, ILLIXR::data_format::hmd_physical_info)</li> <li>KeyValue (cxxopts::KeyValue)</li> <li>key (cxxopts::KeyValue)</li> </ul>"},{"location":"api/class_members/#l","title":"l","text":"<ul> <li>lens_separation_in_meters (HMD::hmd_info_t)</li> <li>left_color_nalu (ILLIXR::data_format::compressed_frame)</li> <li>left_color_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>left_depth_nalu (ILLIXR::data_format::compressed_frame)</li> <li>left_depth_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>load (ILLIXR::data_format::compressed_frame, ILLIXR::lazy_load_image)</li> <li>lensSeparationInMeters (ILLIXR::data_format::hmd_physical_info)</li> <li>last_cam_integration_time (ILLIXR::data_format::imu_integrator_input)</li> <li>linear_a (ILLIXR::data_format::imu_type, ILLIXR::raw_imu_type)</li> <li>latest_quaternion (ILLIXR::data_format::texture_pose)</li> <li>load_images_on_the_fly (ILLIXR::data_injection)</li> <li>last_mouse_position_ (ILLIXR::debugview)</li> <li>load_camera_images (ILLIXR::debugview)</li> <li>load_rgb_depth (ILLIXR::debugview)</li> <li>left_count_ (ILLIXR::depthai)</li> <li>lens_separation (ILLIXR::display_params)</li> <li>lens_vertical_position (ILLIXR::display_params)</li> <li>library_path_ (ILLIXR::dynamic_lib)</li> <li>last_time_ (ILLIXR::gldemo, ILLIXR::lighthouse)</li> <li>last_cam_time_ (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>last_imu_offset_ (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>log_ (ILLIXR::gtsam_integrator, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_rendering_server_loader, ILLIXR::offload_writer, ILLIXR::server_reader)</li> <li>lazy_load_image (ILLIXR::lazy_load_image)</li> <li>lighthouse (ILLIXR::lighthouse)</li> <li>last_fps_update_ (ILLIXR::native_renderer)</li> <li>local_address (ILLIXR::network::TCPSocket)</li> <li>latency (ILLIXR::network::topic_config)</li> <li>last_timestamp_ (ILLIXR::offline_cam, ILLIXR::openni_plugin)</li> <li>layout_transition_end_cmd_bufs_ (ILLIXR::offload_rendering_client)</li> <li>layout_transition_start_cmd_bufs_ (ILLIXR::offload_rendering_client)</li> <li>last_frame_ind_ (ILLIXR::offload_rendering_server)</li> <li>latest_cam_time_ (ILLIXR::offload_writer)</li> <li>latest_imu_time_ (ILLIXR::offload_writer)</li> <li>last_print_ (ILLIXR::openwarp_vk_plugin, ILLIXR::timewarp_vk_plugin)</li> <li>lookup_impl (ILLIXR::phonebook)</li> <li>last_iteration_accel_ (ILLIXR::realsense)</li> <li>last_log_ (ILLIXR::record_coalescer)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger, ILLIXR::sqlite_record_logger, ILLIXR::stdout_record_logger)</li> <li>logger_ (ILLIXR::record_coalescer)</li> <li>load_plugin_factory (ILLIXR::runtime, runtime_impl)</li> <li>load_so (ILLIXR::runtime, runtime_impl)</li> <li>LOG_PERIOD_ (ILLIXR::timewarp_gl)</li> <li>log_count_ (ILLIXR::timewarp_gl)</li> <li>load_model (ILLIXR::vkdemo)</li> <li>load_texture (ILLIXR::vkdemo)</li> <li>latest_decoded_image (ILLIXR::vulkan::buffer_pool)</li> <li>load_video_ (ILLIXR::webcam)</li> <li>last_imu_ts_ (ILLIXR::zed_imu_thread)</li> <li>last_serial_no_ (ILLIXR::zed_imu_thread)</li> <li>latest_buffer_ (ILLIXR::switchboard::topic)</li> <li>latest_buffer_size_ (ILLIXR::switchboard::topic)</li> <li>latest_index_ (ILLIXR::switchboard::topic)</li> <li>l (cxxopts::HelpOptionDetails)</li> <li>long_names (cxxopts::OptionDetails)</li> <li>libraries_ (runtime_impl)</li> </ul>"},{"location":"api/class_members/#m","title":"m","text":"<ul> <li>meters_per_tan_angle_at_center (HMD::hmd_info_t)</li> <li>max_float (HMD)</li> <li>min_float (HMD)</li> <li>magic (ILLIXR::data_format::compressed_frame)</li> <li>metersPerTanAngleAtCenter (ILLIXR::data_format::hmd_physical_info)</li> <li>monocular_cam_type (ILLIXR::data_format::monocular_cam_type)</li> <li>mult (ILLIXR::data_format::points_with_units, ILLIXR::data_format::raw_point)</li> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>model_view_attr_ (ILLIXR::debugview)</li> <li>mouse_velocity_ (ILLIXR::debugview)</li> <li>mutex_ (ILLIXR::depthai, ILLIXR::event, ILLIXR::offload_writer, ILLIXR::phonebook, ILLIXR::realsense, ILLIXR::server_reader)</li> <li>meters_per_tan_angle (ILLIXR::display_params)</li> <li>model_view_ (ILLIXR::gldemo)</li> <li>mat_ (ILLIXR::lazy_load_image)</li> <li>managed_thread (ILLIXR::managed_thread)</li> <li>metrics_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> <li>mtp_logger_ (ILLIXR::timewarp_gl)</li> <li>make_detection_table (ILLIXR::viewer)</li> <li>make_gui (ILLIXR::viewer, ILLIXR::zed_capture::capture)</li> <li>make_position_table (ILLIXR::viewer)</li> <li>models_ (ILLIXR::vkdemo)</li> <li>mutex (ILLIXR::vulkan::queue)</li> <li>m_key (cxxopts::KeyValue)</li> <li>m_value (cxxopts::KeyValue, cxxopts::OptionDetails, cxxopts::OptionValue)</li> <li>m_group (cxxopts::OptionAdder)</li> <li>m_options (cxxopts::OptionAdder, cxxopts::OptionParser, cxxopts::Options)</li> <li>m_count (cxxopts::OptionDetails, cxxopts::OptionValue)</li> <li>m_desc (cxxopts::OptionDetails)</li> <li>m_hash (cxxopts::OptionDetails)</li> <li>m_long (cxxopts::OptionDetails)</li> <li>m_short (cxxopts::OptionDetails)</li> <li>make_storage (cxxopts::OptionDetails)</li> <li>m_allow_unrecognised (cxxopts::OptionParser, cxxopts::Options)</li> <li>m_defaults (cxxopts::OptionParser, cxxopts::ParseResult)</li> <li>m_keys (cxxopts::OptionParser, cxxopts::ParseResult)</li> <li>m_parsed (cxxopts::OptionParser)</li> <li>m_positional (cxxopts::OptionParser, cxxopts::Options)</li> <li>m_sequential (cxxopts::OptionParser, cxxopts::ParseResult::Iterator, cxxopts::ParseResult)</li> <li>m_default (cxxopts::OptionValue, cxxopts::values::abstract_value)</li> <li>m_long_names (cxxopts::OptionValue)</li> <li>m_custom_help (cxxopts::Options)</li> <li>m_help (cxxopts::Options)</li> <li>m_help_string (cxxopts::Options)</li> <li>m_positional_help (cxxopts::Options)</li> <li>m_positional_set (cxxopts::Options)</li> <li>m_program (cxxopts::Options)</li> <li>m_show_positional (cxxopts::Options)</li> <li>m_tab_expansion (cxxopts::Options)</li> <li>m_width (cxxopts::Options)</li> <li>m_iter (cxxopts::ParseResult::Iterator)</li> <li>m_pr (cxxopts::ParseResult::Iterator)</li> <li>m_unmatched (cxxopts::ParseResult)</li> <li>m_values (cxxopts::ParseResult)</li> <li>m_message (cxxopts::exceptions::exception)</li> <li>missing_argument (cxxopts::exceptions::missing_argument)</li> <li>m_default_value (cxxopts::values::abstract_value)</li> <li>m_implicit (cxxopts::values::abstract_value)</li> <li>m_implicit_value (cxxopts::values::abstract_value)</li> <li>m_result (cxxopts::values::abstract_value)</li> <li>m_store (cxxopts::values::abstract_value)</li> <li>main_loop (display_vk)</li> <li>main_thread_ (display_vk)</li> <li>model_view (uniform_buffer_object)</li> </ul>"},{"location":"api/class_members/#n","title":"n","text":"<ul> <li>num_knots (HMD::hmd_info_t)</li> <li>NUM_COLOR_CHANNELS (HMD)</li> <li>NUM_EYES (HMD)</li> <li>name (ILLIXR::Dependency, ILLIXR::switchboard::topic, cxxopts::HelpGroupDetails)</li> <li>nalu_only (ILLIXR::data_format::compressed_frame)</li> <li>num_images (ILLIXR::data_format::image_handle)</li> <li>n_gravity (ILLIXR::data_format::imu_params)</li> <li>nominal_rate (ILLIXR::data_format::imu_params)</li> <li>normalize (ILLIXR::data_format::proper_quaternion)</li> <li>native_renderer (ILLIXR::native_renderer)</li> <li>next_row_ (ILLIXR::offline_cam)</li> <li>network_receive (ILLIXR::offload_rendering_client)</li> <li>nalu_only_ (ILLIXR::offload_rendering_server)</li> <li>num_distortion_indices_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>num_distortion_vertices_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk)</li> <li>num_openwarp_indices_ (ILLIXR::openwarp_vk)</li> <li>num_openwarp_vertices_ (ILLIXR::openwarp_vk)</li> <li>num_record_calls_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>num_update_uniforms_calls_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>name_ (ILLIXR::plugin, ILLIXR::record_header, ILLIXR::switchboard::topic, print_timer2)</li> <li>now (ILLIXR::relative_clock)</li> <li>near_z (ILLIXR::rendering_params)</li> <li>network_writer (ILLIXR::switchboard::network_writer)</li> <li>networked_topics_ (ILLIXR::tcp_network_backend)</li> <li>networked_topics_configs_ (ILLIXR::tcp_network_backend)</li> <li>num_samples_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>nav_state_lkf_ (ILLIXR::gtsam_integrator::pim_object)</li> <li>no_implicit_value (cxxopts::Value, cxxopts::values::abstract_value)</li> <li>no_such_option (cxxopts::exceptions::no_such_option)</li> <li>negative (cxxopts::values::parser_tool::IntegerDesc)</li> <li>now_ (timer)</li> </ul>"},{"location":"api/class_members/#o","title":"o","text":"<ul> <li>operator== (ILLIXR::Dependency, ILLIXR::record_header, ILLIXR::vertex, csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator[] (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::camera_data, ILLIXR::data_format::points_with_units, ILLIXR::dynamic_lib, csv_iterator, csv_row, cxxopts::ParseResult)</li> <li>operator+= (ILLIXR::data_format::point, ILLIXR::data_format::proper_quaternion, ILLIXR::time_point, csv_iterator)</li> <li>operator-= (ILLIXR::data_format::point, ILLIXR::time_point)</li> <li>operator= (ILLIXR::data_format::point, ILLIXR::data_format::points_with_units, ILLIXR::data_format::proper_quaternion, ILLIXR::data_use_indicator, ILLIXR::dynamic_lib, cxxopts::ParseResult, cxxopts::values::abstract_value)</li> <li>operator* (ILLIXR::data_format::point_with_units, ILLIXR::data_format::proper_quaternion, ILLIXR::switchboard::event_wrapper, csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator+ (ILLIXR::data_format::point_with_units, ILLIXR::data_format::proper_quaternion)</li> <li>operator- (ILLIXR::data_format::point_with_units)</li> <li>operator/ (ILLIXR::data_format::point_with_units)</li> <li>orientation (ILLIXR::data_format::pose_data, ILLIXR::state_plus, ILLIXR::switchboard::coordinate_system)</li> <li>operator*= (ILLIXR::data_format::proper_quaternion)</li> <li>offload_duration (ILLIXR::data_format::texture_pose)</li> <li>offset_ (ILLIXR::data_injection, ILLIXR::fauxpose_impl, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>offset_mutex_ (ILLIXR::fauxpose_impl, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>on_start_ (ILLIXR::managed_thread)</li> <li>on_stop_ (ILLIXR::managed_thread)</li> <li>offscreen_export_mem_alloc_info_ (ILLIXR::native_renderer)</li> <li>offscreen_framebuffers_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk)</li> <li>offscreen_images_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk)</li> <li>offscreen_pool_ (ILLIXR::native_renderer)</li> <li>offscreen_pool_create_info_ (ILLIXR::native_renderer)</li> <li>offline_cam (ILLIXR::offline_cam)</li> <li>offline_imu (ILLIXR::offline_imu)</li> <li>obj_dir_ (ILLIXR::offload_data)</li> <li>offload_data (ILLIXR::offload_data)</li> <li>offload_data_container_ (ILLIXR::offload_data)</li> <li>offload_reader (ILLIXR::offload_reader)</li> <li>offload_rendering_client (ILLIXR::offload_rendering_client)</li> <li>offload_rendering_server (ILLIXR::offload_rendering_server)</li> <li>offload_rendering_server_loader (ILLIXR::offload_rendering_server_loader)</li> <li>offload_rendering_server_plugin_ (ILLIXR::offload_rendering_server_loader)</li> <li>offload_writer (ILLIXR::offload_writer)</li> <li>openni_plugin (ILLIXR::openni_plugin)</li> <li>offloaded_rendering_ (ILLIXR::openwarp_vk)</li> <li>offscreen_depth_allocs_ (ILLIXR::openwarp_vk)</li> <li>offscreen_depth_views_ (ILLIXR::openwarp_vk)</li> <li>offscreen_depths_ (ILLIXR::openwarp_vk)</li> <li>offscreen_image_allocs_ (ILLIXR::openwarp_vk)</li> <li>offscreen_image_views_ (ILLIXR::openwarp_vk)</li> <li>openwarp_height_ (ILLIXR::openwarp_vk)</li> <li>openwarp_indices_ (ILLIXR::openwarp_vk)</li> <li>openwarp_pipeline_ (ILLIXR::openwarp_vk)</li> <li>openwarp_render_pass_ (ILLIXR::openwarp_vk)</li> <li>openwarp_vertices_ (ILLIXR::openwarp_vk)</li> <li>openwarp_vk (ILLIXR::openwarp_vk)</li> <li>openwarp_width_ (ILLIXR::openwarp_vk)</li> <li>ow_descriptor_set_layout_ (ILLIXR::openwarp_vk)</li> <li>ow_descriptor_sets_ (ILLIXR::openwarp_vk)</li> <li>ow_index_alloc_ (ILLIXR::openwarp_vk)</li> <li>ow_index_buffer_ (ILLIXR::openwarp_vk)</li> <li>ow_matrices_uniform_alloc_ (ILLIXR::openwarp_vk)</li> <li>ow_matrices_uniform_alloc_info_ (ILLIXR::openwarp_vk)</li> <li>ow_matrices_uniform_buffer_ (ILLIXR::openwarp_vk)</li> <li>ow_pipeline_layout_ (ILLIXR::openwarp_vk)</li> <li>ow_vertex_alloc_ (ILLIXR::openwarp_vk)</li> <li>ow_vertex_buffer_ (ILLIXR::openwarp_vk)</li> <li>openwarp_vk_plugin (ILLIXR::openwarp_vk_plugin)</li> <li>operator bool (ILLIXR::record_coalescer)</li> <li>operator!= (ILLIXR::record_header, csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator Underlying_type (ILLIXR::switchboard::event_wrapper)</li> <li>offload_data_ (ILLIXR::timewarp_gl)</li> <li>offload_duration_ (ILLIXR::timewarp_gl)</li> <li>open (ILLIXR::zed_camera)</li> <li>orientation_ (ILLIXR::switchboard::coordinate_system)</li> <li>operator++ (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>operator-&gt; (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>options (cxxopts::HelpGroupDetails)</li> <li>Option (cxxopts::Option)</li> <li>opts_ (cxxopts::Option)</li> <li>OptionAdder (cxxopts::OptionAdder)</li> <li>operator() (cxxopts::OptionAdder, cxxopts::values::detail::SignedCheck&lt; T, false &gt;, cxxopts::values::detail::SignedCheck&lt; T, true &gt;, should_profile_class, std::hash&lt; vertex &gt;)</li> <li>OptionDetails (cxxopts::OptionDetails)</li> <li>OptionParser (cxxopts::OptionParser)</li> <li>Options (cxxopts::Options)</li> <li>option_already_exists (cxxopts::exceptions::option_already_exists)</li> <li>option_has_no_value (cxxopts::exceptions::option_has_no_value)</li> <li>option_requires_argument (cxxopts::exceptions::option_requires_argument)</li> <li>offload_rendering_client_loader (offload_rendering_client_loader)</li> <li>offload_rendering_client_plugin (offload_rendering_client_loader)</li> </ul>"},{"location":"api/class_members/#p","title":"p","text":"<ul> <li>pos (ILLIXR::DistortionCorrectionVertex, ILLIXR::OpenWarpVertex, ILLIXR::data_format::imu_raw_type, ILLIXR::vertex, vertex)</li> <li>poses (ILLIXR::data_format::cam_type_zed)</li> <li>pose (ILLIXR::data_format::compressed_frame, ILLIXR::data_format::fast_pose_type)</li> <li>predict_computed_time (ILLIXR::data_format::fast_pose_type)</li> <li>predict_target_time (ILLIXR::data_format::fast_pose_type)</li> <li>palms (ILLIXR::data_format::ht::ht_detection)</li> <li>points (ILLIXR::data_format::ht::ht_detection, ILLIXR::data_format::ht::position, ILLIXR::data_format::points_with_units)</li> <li>proc_time (ILLIXR::data_format::ht::ht_detection)</li> <li>position (ILLIXR::data_format::ht::position, ILLIXR::data_format::imu_integrator_input, ILLIXR::data_format::pose_data, ILLIXR::data_format::texture_pose, ILLIXR::state_plus, ILLIXR::switchboard::coordinate_system)</li> <li>params (ILLIXR::data_format::imu_integrator_input)</li> <li>point (ILLIXR::data_format::point)</li> <li>point_with_units (ILLIXR::data_format::point_with_units)</li> <li>point_with_validity (ILLIXR::data_format::point_with_validity)</li> <li>points_with_units (ILLIXR::data_format::points_with_units)</li> <li>pose_data (ILLIXR::data_format::pose_data)</li> <li>pose_type (ILLIXR::data_format::pose_type)</li> <li>proper_quaternion (ILLIXR::data_format::proper_quaternion)</li> <li>pose_time (ILLIXR::data_format::texture_pose)</li> <li>poses_ (ILLIXR::data_injection)</li> <li>pose_prediction_ (ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::openwarp_vk, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>projection_attr_ (ILLIXR::debugview)</li> <li>poll_window_events (ILLIXR::display::glfw_extended, ILLIXR::vulkan::display_provider, display_vk)</li> <li>period (ILLIXR::display_params)</li> <li>period_ (ILLIXR::fauxpose_impl)</li> <li>projection_ (ILLIXR::gldemo)</li> <li>pim_obj_ (ILLIXR::gtsam_integrator)</li> <li>prev_euler_angles_ (ILLIXR::gtsam_integrator)</li> <li>propagate_imu_values (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>path_ (ILLIXR::lazy_load_image)</li> <li>process_slow_pose (ILLIXR::lighthouse)</li> <li>peer_address (ILLIXR::network::TCPSocket)</li> <li>packetization (ILLIXR::network::topic_config)</li> <li>packetization_type (ILLIXR::network::topic_config)</li> <li>priority (ILLIXR::network::topic_config)</li> <li>priority_type (ILLIXR::network::topic_config)</li> <li>percent_ (ILLIXR::offload_data)</li> <li>pose_ (ILLIXR::offload_reader, ILLIXR::viewer)</li> <li>pose_writer_ (ILLIXR::offload_rendering_client)</li> <li>push_pose (ILLIXR::offload_rendering_client)</li> <li>prepare_imu_cam_data (ILLIXR::offload_writer)</li> <li>partial_destroy (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>phonebook_ (ILLIXR::openwarp_vk, ILLIXR::plugin, ILLIXR::switchboard, ILLIXR::timewarp_vk, runtime_impl)</li> <li>passthrough_integrator (ILLIXR::passthrough_integrator)</li> <li>plugin (ILLIXR::plugin)</li> <li>plugin_logger_ (ILLIXR::plugin)</li> <li>pose_lookup_impl (ILLIXR::pose_lookup_impl)</li> <li>pose_prediction_impl (ILLIXR::pose_prediction_impl)</li> <li>pipeline_ (ILLIXR::realsense, ILLIXR::vulkan::render_pass)</li> <li>profiles_ (ILLIXR::realsense)</li> <li>prep_db (ILLIXR::sqlite_thread)</li> <li>prep_insert_str (ILLIXR::sqlite_thread)</li> <li>process (ILLIXR::sqlite_thread)</li> <li>pull_queue (ILLIXR::sqlite_thread)</li> <li>put_queue (ILLIXR::sqlite_thread)</li> <li>put (ILLIXR::switchboard::network_writer, ILLIXR::switchboard::writer, ILLIXR::switchboard::topic)</li> <li>ptr (ILLIXR::switchboard)</li> <li>peer_socket_ (ILLIXR::tcp_network_backend)</li> <li>PBO_buffer_ (ILLIXR::timewarp_gl)</li> <li>pipeline_layout_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>pipeline_img0_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>pipeline_img1_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>pipeline_sync_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>pipeline_sync_mutex_ (ILLIXR::video_decoder, ILLIXR::video_encoder)</li> <li>processed_size (ILLIXR::viewer)</li> <li>post_processing_acquire_image (ILLIXR::vulkan::buffer_pool)</li> <li>post_processing_release_image (ILLIXR::vulkan::buffer_pool)</li> <li>present_family (ILLIXR::vulkan::queue_families)</li> <li>present_modes (ILLIXR::vulkan::swapchain_details)</li> <li>pim_ (ILLIXR::gtsam_integrator::pim_object)</li> <li>pim_object (ILLIXR::gtsam_integrator::pim_object)</li> <li>predict (ILLIXR::gtsam_integrator::pim_object)</li> <li>position_ (ILLIXR::switchboard::coordinate_system)</li> <li>plugin_id_ (ILLIXR::switchboard::topic_subscription)</li> <li>pointer (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>parse (cxxopts::OptionParser, cxxopts::OptionValue, cxxopts::Options, cxxopts::Value, cxxopts::values::abstract_value)</li> <li>parse_default (cxxopts::OptionParser, cxxopts::OptionValue)</li> <li>parse_no_value (cxxopts::OptionParser, cxxopts::OptionValue)</li> <li>parse_option (cxxopts::OptionParser)</li> <li>parse_positional (cxxopts::Options)</li> <li>positional_help (cxxopts::Options)</li> <li>program (cxxopts::Options)</li> <li>ParseResult (cxxopts::ParseResult)</li> <li>parsing (cxxopts::exceptions::parsing)</li> <li>pose_lookup_plugin (pose_lookup_plugin)</li> <li>pose_prediction_plugin (pose_prediction_plugin)</li> <li>print_in_destructor_ (print_timer)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> <li>plugins_ (runtime_impl)</li> <li>proj (uniform_buffer_object)</li> </ul>"},{"location":"api/class_members/#q","title":"q","text":"<ul> <li>quat (ILLIXR::data_format::imu_integrator_input, ILLIXR::data_format::imu_raw_type)</li> <li>queue_ (ILLIXR::offload_writer, ILLIXR::server_reader, ILLIXR::sqlite_thread, ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>queues_ (ILLIXR::vulkan::display_provider)</li> <li>queue_type (ILLIXR::vulkan::queue)</li> <li>queue_size_ (ILLIXR::switchboard::topic_buffer)</li> <li>queue_timeout_ (ILLIXR::switchboard::topic_subscription)</li> </ul>"},{"location":"api/class_members/#r","title":"r","text":"<ul> <li>render_inv_projection (ILLIXR::WarpMatrices)</li> <li>render_inv_view (ILLIXR::WarpMatrices)</li> <li>right_color_nalu (ILLIXR::data_format::compressed_frame)</li> <li>right_color_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>right_depth_nalu (ILLIXR::data_format::compressed_frame)</li> <li>right_depth_nalu_size (ILLIXR::data_format::compressed_frame)</li> <li>reference (ILLIXR::data_format::ht::ht_frame, ILLIXR::data_format::ht::raw_ht_data, csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>raw_ht_data (ILLIXR::data_format::ht::raw_ht_data)</li> <li>ref_space (ILLIXR::data_format::pose_data)</li> <li>raw_point (ILLIXR::data_format::raw_point)</li> <li>raw_pose (ILLIXR::data_format::raw_pose)</li> <li>rect (ILLIXR::data_format::rect)</li> <li>rotation (ILLIXR::data_format::rect)</li> <li>render_pose (ILLIXR::data_format::rendered_frame)</li> <li>render_time (ILLIXR::data_format::rendered_frame)</li> <li>rendered_frame (ILLIXR::data_format::rendered_frame)</li> <li>rgb_depth_type (ILLIXR::data_format::rgb_depth_type)</li> <li>render_quaternion (ILLIXR::data_format::texture_pose)</li> <li>read_cam_data (ILLIXR::data_injection)</li> <li>read_poses (ILLIXR::data_injection)</li> <li>rgb_depth_ (ILLIXR::debugview, ILLIXR::depthai, ILLIXR::openni_plugin, ILLIXR::realsense, ILLIXR::zed_imu_thread)</li> <li>rgb_depth_reader_ (ILLIXR::debugview)</li> <li>rgb_depth_texture_ (ILLIXR::debugview)</li> <li>rgbd_texture_size_ (ILLIXR::debugview)</li> <li>rectif_left_queue_ (ILLIXR::depthai)</li> <li>rectif_right_queue_ (ILLIXR::depthai)</li> <li>rgb_count_ (ILLIXR::depthai)</li> <li>rgbd_pub_ (ILLIXR::depthai)</li> <li>right_count_ (ILLIXR::depthai)</li> <li>register_display_timings_event (ILLIXR::display::x11_direct)</li> <li>record_post_processing_command_buffer (ILLIXR::native_renderer)</li> <li>record_src_command_buffer (ILLIXR::native_renderer)</li> <li>recreate_swapchain (ILLIXR::native_renderer, ILLIXR::vulkan::display_provider, display_vk)</li> <li>read_data (ILLIXR::network::TCPSocket)</li> <li>retransmit (ILLIXR::network::topic_config)</li> <li>receive_vio_output (ILLIXR::offload_reader)</li> <li>ready_ (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::stoplight, ILLIXR::tcp_network_backend, display_vk)</li> <li>record_command_buffer (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>render_pose_ (ILLIXR::offload_rendering_server)</li> <li>register_impl (ILLIXR::phonebook)</li> <li>registry_ (ILLIXR::phonebook, ILLIXR::switchboard)</li> <li>record_logger_ (ILLIXR::plugin, ILLIXR::switchboard, ILLIXR::switchboard::topic, ILLIXR::switchboard::topic_subscription)</li> <li>realsense (ILLIXR::realsense)</li> <li>realsense_cam_ (ILLIXR::realsense)</li> <li>record (ILLIXR::record)</li> <li>record_header_ (ILLIXR::record, ILLIXR::sqlite_thread)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>record_data_ (ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth)</li> <li>record_imu_cam (ILLIXR::record_imu_cam)</li> <li>record_rgb_depth (ILLIXR::record_rgb_depth)</li> <li>rgb_data_dir_ (ILLIXR::record_rgb_depth)</li> <li>rgb_wt_file_ (ILLIXR::record_rgb_depth)</li> <li>reverse_z (ILLIXR::rendering_params)</li> <li>rk4_integrator (ILLIXR::rk4_integrator)</li> <li>receive_vio_input (ILLIXR::server_reader)</li> <li>registered_tables_ (ILLIXR::sqlite_record_logger)</li> <li>registry_lock_ (ILLIXR::sqlite_record_logger, ILLIXR::switchboard)</li> <li>reader (ILLIXR::switchboard::reader)</li> <li>root_coordinates (ILLIXR::switchboard)</li> <li>read_loop (ILLIXR::tcp_network_backend)</li> <li>running_ (ILLIXR::tcp_network_backend, display_vk)</li> <li>read_texture_image (ILLIXR::timewarp_gl)</li> <li>rendering_ready_ (ILLIXR::timewarp_gl)</li> <li>root_window_ (ILLIXR::timewarp_gl)</li> <li>raw_size (ILLIXR::viewer)</li> <li>requested_unit_ (ILLIXR::viewer)</li> <li>rgb_ocv_ (ILLIXR::zed_camera_thread)</li> <li>rgb_zed_ (ILLIXR::zed_camera_thread)</li> <li>runtime_parameters_ (ILLIXR::zed_camera_thread)</li> <li>raw_img_ (ILLIXR::zed_capture::capture)</li> <li>runtime_params_ (ILLIXR::zed_capture::capture)</li> <li>root_ (ILLIXR::zed_capture::files)</li> <li>reset_integration_and_set_bias (ILLIXR::gtsam_integrator::pim_object)</li> <li>row_ (csv_iterator)</li> <li>read_next_row (csv_row)</li> <li>requested_option_not_present (cxxopts::exceptions::requested_option_not_present)</li> <li>required_device_extensions_ (display_vk)</li> <li>runtime_impl (runtime_impl)</li> </ul>"},{"location":"api/class_members/#s","title":"s","text":"<ul> <li>sleep (ILLIXR::cancellable_sleep)</li> <li>size (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::points_with_units, ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer, csv_row)</li> <li>serial_no (ILLIXR::data_format::cam_type_zed)</li> <li>save (ILLIXR::data_format::compressed_frame)</li> <li>sent_time (ILLIXR::data_format::compressed_frame)</li> <li>start (ILLIXR::data_format::connection_signal, ILLIXR::data_injection, ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::ground_truth_slam, ILLIXR::managed_thread, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_rendering_server_loader, ILLIXR::offload_writer, ILLIXR::plugin, ILLIXR::relative_clock, ILLIXR::server_reader, ILLIXR::server_writer, ILLIXR::threadloop, ILLIXR::viewer, ILLIXR::vkdemo_plugin, ILLIXR::zed_imu_thread, display_vk, offload_rendering_client_loader)</li> <li>seq (ILLIXR::data_format::hologram_input, ILLIXR::data_format::signal_to_quad)</li> <li>set (ILLIXR::data_format::point, ILLIXR::data_format::point_with_units, ILLIXR::data_format::rect, ILLIXR::event)</li> <li>set_offset (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>sensor_time (ILLIXR::data_format::pose_type)</li> <li>sample_time (ILLIXR::data_format::rendered_frame)</li> <li>swap_indices (ILLIXR::data_format::rendered_frame)</li> <li>swapchain_indices (ILLIXR::data_format::rendered_frame)</li> <li>signal_to_quad (ILLIXR::data_format::signal_to_quad)</li> <li>step_ (ILLIXR::data_injection)</li> <li>switchboard_ (ILLIXR::data_injection, ILLIXR::debugview, ILLIXR::depthai, ILLIXR::fauxpose_impl, ILLIXR::gldemo, ILLIXR::ground_truth_slam, ILLIXR::gtsam_integrator, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_data, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_writer, ILLIXR::openni_plugin, ILLIXR::openwarp_vk, ILLIXR::passthrough_integrator, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl, ILLIXR::realsense, ILLIXR::record_imu_cam, ILLIXR::record_rgb_depth, ILLIXR::rk4_integrator, ILLIXR::runtime, ILLIXR::server_reader, ILLIXR::server_writer, ILLIXR::tcp_network_backend, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk, ILLIXR::viewer, ILLIXR::vkdemo, ILLIXR::webcam, ILLIXR::zed_camera, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread, display_vk)</li> <li>slow_pose_reader_ (ILLIXR::debugview)</li> <li>setup_display (ILLIXR::display::display_backend, ILLIXR::display::glfw_extended, ILLIXR::display::headless, ILLIXR::display::x11_direct)</li> <li>select_display_mode (ILLIXR::display::x11_direct)</li> <li>selected_mode_ (ILLIXR::display::x11_direct)</li> <li>sim_start_time_ (ILLIXR::fauxpose_impl)</li> <li>sensor_data_ (ILLIXR::ground_truth_slam, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::pose_lookup_impl)</li> <li>select_imu_readings (ILLIXR::gtsam_integrator, ILLIXR::rk4_integrator)</li> <li>s_context_ (ILLIXR::lighthouse)</li> <li>slow_pose_ (ILLIXR::lighthouse, ILLIXR::pose_prediction_impl)</li> <li>slow_pose_count_ (ILLIXR::lighthouse)</li> <li>stop (ILLIXR::lighthouse, ILLIXR::managed_thread, ILLIXR::offload_rendering_server_loader, ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::tcp_network_backend, ILLIXR::threadloop, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread, ILLIXR::switchboard::topic, offload_rendering_client_loader)</li> <li>state (ILLIXR::managed_thread)</li> <li>stop_ (ILLIXR::managed_thread)</li> <li>swapchain_framebuffers_ (ILLIXR::native_renderer)</li> <li>swapchain_image_index_ (ILLIXR::native_renderer)</li> <li>socket_accept (ILLIXR::network::TCPSocket)</li> <li>socket_bind (ILLIXR::network::TCPSocket)</li> <li>socket_connect (ILLIXR::network::TCPSocket)</li> <li>socket_listen (ILLIXR::network::TCPSocket)</li> <li>socket_set_reuseaddr (ILLIXR::network::TCPSocket)</li> <li>SerializationMethod (ILLIXR::network::topic_config)</li> <li>serialization_method (ILLIXR::network::topic_config)</li> <li>sensor_data_it_ (ILLIXR::offline_imu, ILLIXR::pose_lookup_impl)</li> <li>server_ip_ (ILLIXR::offload_reader, ILLIXR::offload_writer, ILLIXR::tcp_network_backend)</li> <li>socket_ (ILLIXR::offload_reader, ILLIXR::offload_writer)</li> <li>save_nv12_img_to_png (ILLIXR::offload_rendering_client)</li> <li>setup (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::app, ILLIXR::vulkan::timewarp, display_vk)</li> <li>submit_command_buffer (ILLIXR::offload_rendering_client)</li> <li>send_imu_cam_data (ILLIXR::offload_writer)</li> <li>sizes_ (ILLIXR::offload_writer)</li> <li>stoplight_ (ILLIXR::offload_writer, ILLIXR::threadloop)</li> <li>setup_mutex_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>swapchain_height_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>swapchain_width_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk)</li> <li>spd_add_file_sink (ILLIXR::plugin)</li> <li>spdlogger (ILLIXR::plugin)</li> <li>start_ (ILLIXR::relative_clock, timer)</li> <li>start_time (ILLIXR::relative_clock)</li> <li>server_reader (ILLIXR::server_reader)</li> <li>send_vio_output (ILLIXR::server_writer)</li> <li>server_writer (ILLIXR::server_writer)</li> <li>sqlite_thread (ILLIXR::sqlite_thread)</li> <li>state_plus (ILLIXR::state_plus)</li> <li>should_stop_ (ILLIXR::stoplight)</li> <li>shutdown_complete_ (ILLIXR::stoplight)</li> <li>signal_ready (ILLIXR::stoplight)</li> <li>signal_should_stop (ILLIXR::stoplight)</li> <li>signal_shutdown_complete (ILLIXR::stoplight)</li> <li>serial_no_ (ILLIXR::switchboard::buffered_reader, ILLIXR::zed_camera_thread, print_timer2)</li> <li>serialize (ILLIXR::switchboard::event)</li> <li>schedule (ILLIXR::switchboard, ILLIXR::switchboard::topic)</li> <li>set_env (ILLIXR::switchboard)</li> <li>switchboard (ILLIXR::switchboard)</li> <li>send_to_peer (ILLIXR::tcp_network_backend)</li> <li>server_port_ (ILLIXR::tcp_network_backend)</li> <li>start_client (ILLIXR::tcp_network_backend)</li> <li>start_server (ILLIXR::tcp_network_backend)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>skip_no (ILLIXR::threadloop)</li> <li>skip_option (ILLIXR::threadloop)</li> <li>signal_quad_seq_ (ILLIXR::timewarp_gl)</li> <li>single_eye_ (ILLIXR::viewer)</li> <li>src_acquire_image (ILLIXR::vulkan::buffer_pool)</li> <li>src_release_image (ILLIXR::vulkan::buffer_pool)</li> <li>swapchain_extent_ (ILLIXR::vulkan::display_provider)</li> <li>swapchain_image_format_ (ILLIXR::vulkan::display_provider)</li> <li>swapchain_image_views_ (ILLIXR::vulkan::display_provider)</li> <li>swapchain_images_ (ILLIXR::vulkan::display_provider)</li> <li>sensors_data_ (ILLIXR::zed_imu_thread)</li> <li>start_camera (ILLIXR::zed_imu_thread)</li> <li>subscriptions_ (ILLIXR::switchboard::topic)</li> <li>subscriptions_lock_ (ILLIXR::switchboard::topic)</li> <li>stream_ (csv_iterator)</li> <li>s (cxxopts::HelpOptionDetails)</li> <li>short_name (cxxopts::OptionDetails)</li> <li>set_tab_expansion (cxxopts::Options)</li> <li>set_width (cxxopts::Options)</li> <li>show_positional_help (cxxopts::Options)</li> <li>specification (cxxopts::exceptions::specification)</li> <li>Self (cxxopts::values::abstract_value)</li> <li>set_value (cxxopts::values::parser_tool::ArguDesc)</li> <li>set_default_and_implicit (cxxopts::values::standard_value&lt; bool &gt;)</li> <li>standard_value (cxxopts::values::standard_value&lt; bool &gt;)</li> <li>select_physical_device (display_vk)</li> <li>selected_gpu_ (display_vk)</li> <li>should_poll_ (display_vk)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_members/#t","title":"t","text":"<ul> <li>tile_pixels_high (HMD::hmd_info_t)</li> <li>tile_pixels_wide (HMD::hmd_info_t)</li> <li>transform (ILLIXR::DistortionMatrix, ILLIXR::data_format::points_with_units, ILLIXR::data_format::raw_point)</li> <li>terminate_ (ILLIXR::cancellable_sleep, ILLIXR::sqlite_thread)</li> <li>time (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::ht::position, ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::imu_type)</li> <li>type (ILLIXR::data_format::cam_base_type, ILLIXR::data_format::image_handle, ILLIXR::vulkan::queue)</li> <li>t_offset (ILLIXR::data_format::imu_integrator_input)</li> <li>true_pose_reliable (ILLIXR::data_format::pose_prediction, ILLIXR::fauxpose_impl, ILLIXR::offload_rendering_server, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl)</li> <li>texture_pose (ILLIXR::data_format::texture_pose)</li> <li>timepoints_ (ILLIXR::data_injection)</li> <li>test_pattern_ (ILLIXR::debugview)</li> <li>tracking_position_offset_ (ILLIXR::debugview)</li> <li>test_time_point_ (ILLIXR::depthai)</li> <li>tick (ILLIXR::display::x11_direct)</li> <li>true_pose_ (ILLIXR::ground_truth_slam, ILLIXR::pose_prediction_impl)</li> <li>thread_ (ILLIXR::managed_thread, ILLIXR::sqlite_thread, ILLIXR::threadloop, ILLIXR::switchboard::topic_subscription)</li> <li>thread_main (ILLIXR::managed_thread, ILLIXR::threadloop)</li> <li>texture_index (ILLIXR::model, model_push_constant)</li> <li>timeline_semaphore_value_ (ILLIXR::native_renderer)</li> <li>timewarp_ (ILLIXR::native_renderer, ILLIXR::openwarp_vk_plugin, ILLIXR::timewarp_vk_plugin)</li> <li>timewarp_command_buffer_ (ILLIXR::native_renderer)</li> <li>timewarp_pass_ (ILLIXR::native_renderer)</li> <li>timewarp_render_finished_semaphore_ (ILLIXR::native_renderer)</li> <li>TCPSocket (ILLIXR::network::TCPSocket)</li> <li>topic_create (ILLIXR::network::network_backend, ILLIXR::tcp_network_backend)</li> <li>topic_send (ILLIXR::network::network_backend, ILLIXR::tcp_network_backend)</li> <li>time_seq_ (ILLIXR::offload_data)</li> <li>transition_layout (ILLIXR::offload_rendering_client)</li> <li>time_sleep_ (ILLIXR::openni_plugin)</li> <li>T26X_found_ (ILLIXR::realsense)</li> <li>to_string (ILLIXR::record_header)</li> <li>total_imu_ (ILLIXR::rk4_integrator)</li> <li>table_name_ (ILLIXR::sqlite_thread)</li> <li>topic_ (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::reader, ILLIXR::switchboard::writer)</li> <li>topic_buffer_ (ILLIXR::switchboard::buffered_reader)</li> <li>topic_exists (ILLIXR::switchboard)</li> <li>try_register_topic (ILLIXR::switchboard)</li> <li>tcp_network_backend (ILLIXR::tcp_network_backend)</li> <li>topic_receive (ILLIXR::tcp_network_backend)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>time_point (ILLIXR::time_point)</li> <li>time_since_epoch (ILLIXR::time_point)</li> <li>time_since_epoch_ (ILLIXR::time_point)</li> <li>time_last_swap_ (ILLIXR::timewarp_gl)</li> <li>timewarp_gl (ILLIXR::timewarp_gl)</li> <li>timewarp_gpu_logger_ (ILLIXR::timewarp_gl)</li> <li>timewarp_shader_program_ (ILLIXR::timewarp_gl)</li> <li>tw_end_transform_uniform_ (ILLIXR::timewarp_gl)</li> <li>tw_eye_index_uniform_ (ILLIXR::timewarp_gl)</li> <li>tw_start_transform_uniform_ (ILLIXR::timewarp_gl)</li> <li>tw_vao (ILLIXR::timewarp_gl)</li> <li>timewarp_render_pass_ (ILLIXR::timewarp_vk)</li> <li>timewarp_vk (ILLIXR::timewarp_vk)</li> <li>timewarp_vk_plugin (ILLIXR::timewarp_vk_plugin)</li> <li>tab_label_ (ILLIXR::viewer)</li> <li>textures_ (ILLIXR::viewer, ILLIXR::vkdemo, ILLIXR::zed_capture::capture)</li> <li>texture_map_ (ILLIXR::vkdemo)</li> <li>texture_sampler_ (ILLIXR::vkdemo)</li> <li>timepoint_ (ILLIXR::zed_capture::capture)</li> <li>topic (ILLIXR::switchboard::topic)</li> <li>ty (ILLIXR::switchboard::topic)</li> <li>type_info_ (ILLIXR::switchboard::topic)</li> <li>token_ (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>topic_buffer (ILLIXR::switchboard::topic_buffer)</li> <li>thread_body (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_start (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_stop (ILLIXR::switchboard::topic_subscription)</li> <li>topic_name_ (ILLIXR::switchboard::topic_subscription)</li> <li>topic_subscription (ILLIXR::switchboard::topic_subscription)</li> <li>timer_ (print_timer)</li> <li>timer (timer)</li> <li>timewarp_end_transform (uniform_buffer_object)</li> <li>timewarp_start_transform (uniform_buffer_object)</li> </ul>"},{"location":"api/class_members/#u","title":"u","text":"<ul> <li>u (HMD::uv_coord_t)</li> <li>uv0 (ILLIXR::DistortionCorrectionVertex, vertex)</li> <li>uv1 (ILLIXR::DistortionCorrectionVertex, vertex)</li> <li>uv2 (ILLIXR::DistortionCorrectionVertex, vertex)</li> <li>uv (ILLIXR::OpenWarpVertex, ILLIXR::vertex)</li> <li>units (ILLIXR::data_format::camera_data, ILLIXR::data_format::depth_type, ILLIXR::data_format::rgb_depth_type)</li> <li>use_depth (ILLIXR::data_format::compressed_frame)</li> <li>unit (ILLIXR::data_format::ht::ht_frame, ILLIXR::data_format::ht::position, ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::point_with_units, ILLIXR::data_format::points_with_units, ILLIXR::data_format::pose_data, ILLIXR::data_format::rect)</li> <li>usage (ILLIXR::data_format::image_handle)</li> <li>used_ (ILLIXR::data_use_indicator)</li> <li>use_cam_ (ILLIXR::debugview)</li> <li>use_rgb_depth_ (ILLIXR::debugview)</li> <li>use_raw_ (ILLIXR::depthai)</li> <li>u_step_ (ILLIXR::offload_rendering_client)</li> <li>update_uniforms (ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::render_pass)</li> <li>use_depth_ (ILLIXR::offload_rendering_client)</li> <li>use_pass_depth_ (ILLIXR::offload_rendering_server)</li> <li>using_godot_ (ILLIXR::openwarp_vk)</li> <li>using_lighthouse_ (ILLIXR::pose_prediction_impl)</li> <li>underlying_data_ (ILLIXR::switchboard::event_wrapper)</li> <li>uniform_alloc_ (ILLIXR::timewarp_vk)</li> <li>uniform_alloc_info_ (ILLIXR::timewarp_vk)</li> <li>uniform_buffer_ (ILLIXR::timewarp_vk)</li> <li>uniform_buffer_allocation_infos_ (ILLIXR::vkdemo)</li> <li>uniform_buffer_allocations_ (ILLIXR::vkdemo)</li> <li>uniform_buffers_ (ILLIXR::vkdemo)</li> <li>update_uniform (ILLIXR::vkdemo)</li> <li>unmatched (cxxopts::ParseResult)</li> </ul>"},{"location":"api/class_members/#v","title":"v","text":"<ul> <li>visible_meters_high (HMD::hmd_info_t)</li> <li>visible_meters_wide (HMD::hmd_info_t)</li> <li>visible_pixels_high (HMD::hmd_info_t)</li> <li>visible_pixels_wide (HMD::hmd_info_t)</li> <li>v (HMD::uv_coord_t)</li> <li>vertical_fov (ILLIXR::data_format::ccd_data)</li> <li>visibleMetersHigh (ILLIXR::data_format::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::data_format::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::data_format::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::data_format::hmd_physical_info)</li> <li>valid (ILLIXR::data_format::ht::position, ILLIXR::data_format::ht::raw_ht_data, ILLIXR::data_format::point_with_validity, ILLIXR::data_format::points_with_units, ILLIXR::data_format::pose_data, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose, ILLIXR::data_format::rect)</li> <li>velocity (ILLIXR::data_format::ht::velocity, ILLIXR::data_format::imu_integrator_input, ILLIXR::state_plus)</li> <li>vk_handle (ILLIXR::data_format::image_handle)</li> <li>vel (ILLIXR::data_format::imu_raw_type)</li> <li>vk_image_handle (ILLIXR::data_format::vk_image_handle)</li> <li>vertex_normal_attr_ (ILLIXR::debugview)</li> <li>vertex_pos_attr (ILLIXR::debugview)</li> <li>view_distance_ (ILLIXR::debugview)</li> <li>view_euler_ (ILLIXR::debugview)</li> <li>vk_instance_ (ILLIXR::display::display_backend, ILLIXR::vulkan::display_provider)</li> <li>vk_device_ (ILLIXR::display::x11_direct, ILLIXR::vulkan::display_provider)</li> <li>vk_physical_device_ (ILLIXR::display::x11_direct, ILLIXR::vulkan::display_provider)</li> <li>vsync_topic_ (ILLIXR::display::x11_direct)</li> <li>value_ (ILLIXR::event, cxxopts::Option)</li> <li>vsync_estimate_ (ILLIXR::fauxpose_impl, ILLIXR::pose_lookup_impl, ILLIXR::pose_prediction_impl, ILLIXR::timewarp_gl)</li> <li>vertex_normal_ (ILLIXR::gldemo)</li> <li>vertex_position_ (ILLIXR::gldemo)</li> <li>vsync_ (ILLIXR::gldemo, ILLIXR::native_renderer, ILLIXR::timewarp_vk)</li> <li>vertex_offset (ILLIXR::model)</li> <li>vio_pose_reader_ (ILLIXR::offload_reader)</li> <li>v_step_ (ILLIXR::offload_rendering_client)</li> <li>vma_allocator_ (ILLIXR::openwarp_vk, ILLIXR::timewarp_vk, ILLIXR::vkdemo, ILLIXR::vulkan::display_provider)</li> <li>values_ (ILLIXR::record)</li> <li>vio_pose_writer_ (ILLIXR::server_writer)</li> <li>vertex_buffer_ (ILLIXR::timewarp_vk, ILLIXR::vkdemo)</li> <li>video_decoder (ILLIXR::video_decoder)</li> <li>video_encoder (ILLIXR::video_encoder)</li> <li>viewer (ILLIXR::viewer)</li> <li>viewport_ (ILLIXR::viewer, ILLIXR::zed_capture::capture)</li> <li>vertices_ (ILLIXR::vkdemo)</li> <li>vkdemo (ILLIXR::vkdemo)</li> <li>vkd_ (ILLIXR::vkdemo_plugin)</li> <li>vkdemo_plugin (ILLIXR::vkdemo_plugin)</li> <li>vk_surface_ (ILLIXR::vulkan::display_provider)</li> <li>vk_swapchain_ (ILLIXR::vulkan::display_provider)</li> <li>vk_frame (ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame)</li> <li>vk_queue (ILLIXR::vulkan::queue)</li> <li>value_type (csv_iterator, cxxopts::ParseResult::Iterator)</li> <li>value (cxxopts::KeyValue, cxxopts::OptionDetails, cxxopts::values::parser_tool::ArguDesc, cxxopts::values::parser_tool::IntegerDesc, cxxopts::values::type_is_container, cxxopts::values::type_is_container&lt; std::vector&lt; T &gt; &gt;)</li> </ul>"},{"location":"api/class_members/#w","title":"w","text":"<ul> <li>warp_view_projection (ILLIXR::WarpMatrices)</li> <li>width (ILLIXR::data_format::camera_data, ILLIXR::data_format::rect, ILLIXR::data_format::vk_image_handle)</li> <li>wcs_offset (ILLIXR::data_format::ht::ht_frame)</li> <li>wcs_origin (ILLIXR::data_format::ht::raw_ht_data)</li> <li>w_hat (ILLIXR::data_format::imu_raw_type)</li> <li>w_hat2 (ILLIXR::data_format::imu_raw_type)</li> <li>w (ILLIXR::data_format::raw_pose)</li> <li>wx (ILLIXR::data_format::raw_pose)</li> <li>wy (ILLIXR::data_format::raw_pose)</li> <li>wz (ILLIXR::data_format::raw_pose)</li> <li>window_ (ILLIXR::display::glfw_extended, ILLIXR::xlib_gl_extended_window)</li> <li>width_meters (ILLIXR::display_params)</li> <li>width_pixels (ILLIXR::display_params)</li> <li>wait (ILLIXR::event, ILLIXR::runtime, runtime_impl)</li> <li>wait_timeout (ILLIXR::event)</li> <li>wait_vsync (ILLIXR::gldemo)</li> <li>which_buffer_ (ILLIXR::gldemo)</li> <li>width_ (ILLIXR::native_renderer, ILLIXR::xlib_gl_extended_window)</li> <li>write_data (ILLIXR::network::TCPSocket)</li> <li>write_helper (ILLIXR::network::TCPSocket)</li> <li>write_data_to_disk (ILLIXR::offload_data)</li> <li>write_metadata (ILLIXR::offload_data)</li> <li>wait_for_ready (ILLIXR::stoplight)</li> <li>wait_for_shutdown_complete (ILLIXR::stoplight)</li> <li>writer (ILLIXR::switchboard::writer)</li> <li>warp (ILLIXR::timewarp_gl)</li> <li>webcam (ILLIXR::webcam)</li> <li>wcs_xform_ (ILLIXR::zed_capture::capture)</li> <li>what (cxxopts::exceptions::exception)</li> <li>wall_time_start_ (print_timer2)</li> </ul>"},{"location":"api/class_members/#x","title":"x","text":"<ul> <li>x (HMD::mesh_coord2d_t, HMD::mesh_coord3d_t, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>x_center (ILLIXR::data_format::rect)</li> <li>x11_direct (ILLIXR::display::x11_direct)</li> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#y","title":"y","text":"<ul> <li>y (HMD::mesh_coord2d_t, HMD::mesh_coord3d_t, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>y_center (ILLIXR::data_format::rect)</li> <li>y_step_ (ILLIXR::offload_rendering_client)</li> <li>yuv420_u_plane_ (ILLIXR::offload_rendering_client)</li> <li>yuv420_v_plane_ (ILLIXR::offload_rendering_client)</li> <li>yuv420_y_plane_ (ILLIXR::offload_rendering_client)</li> </ul>"},{"location":"api/class_members/#z","title":"z","text":"<ul> <li>z (HMD::mesh_coord3d_t, ILLIXR::data_format::raw_point, ILLIXR::data_format::raw_pose)</li> <li>zed_camera (ILLIXR::zed_camera)</li> <li>zed_cam_ (ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> <li>zed_camera_thread (ILLIXR::zed_camera_thread)</li> <li>zed_imu_thread (ILLIXR::zed_imu_thread)</li> </ul>"},{"location":"api/class_members/#_1","title":"~","text":"<ul> <li>~compressed_frame (ILLIXR::data_format::compressed_frame)</li> <li>~pose_prediction (ILLIXR::data_format::pose_prediction)</li> <li>~data_injection (ILLIXR::data_injection)</li> <li>~debugview (ILLIXR::debugview)</li> <li>~depthai (ILLIXR::depthai)</li> <li>~dynamic_lib (ILLIXR::dynamic_lib)</li> <li>~fauxpose (ILLIXR::fauxpose)</li> <li>~fauxpose_impl (ILLIXR::fauxpose_impl)</li> <li>~lighthouse (ILLIXR::lighthouse)</li> <li>~managed_thread (ILLIXR::managed_thread)</li> <li>~native_renderer (ILLIXR::native_renderer)</li> <li>~TCPSocket (ILLIXR::network::TCPSocket)</li> <li>~offload_data (ILLIXR::offload_data)</li> <li>~openni_plugin (ILLIXR::openni_plugin)</li> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~realsense (ILLIXR::realsense)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_imu_cam (ILLIXR::record_imu_cam)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~record_rgb_depth (ILLIXR::record_rgb_depth)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~sqlite_thread (ILLIXR::sqlite_thread)</li> <li>~event (ILLIXR::switchboard::event)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~viewer (ILLIXR::viewer)</li> <li>~display_provider (ILLIXR::vulkan::display_provider)</li> <li>~render_pass (ILLIXR::vulkan::render_pass)</li> <li>~xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>~capture (ILLIXR::zed_capture::capture)</li> <li>~zed_imu_thread (ILLIXR::zed_imu_thread)</li> <li>~pim_object (ILLIXR::gtsam_integrator::pim_object)</li> <li>~Value (cxxopts::Value)</li> <li>~abstract_value (cxxopts::values::abstract_value)</li> <li>~standard_value (cxxopts::values::standard_value&lt; bool &gt;)</li> <li>~display_vk (display_vk)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~runtime_impl (runtime_impl)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_members/#_","title":"_","text":"<ul> <li>_correct_pose (ILLIXR::data_format::pose_prediction)</li> <li>_set_offset (ILLIXR::data_format::pose_prediction)</li> <li>_p_one_iteration (ILLIXR::data_injection, ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_writer, ILLIXR::openni_plugin, ILLIXR::openwarp_vk_plugin, ILLIXR::server_reader, ILLIXR::threadloop, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk_plugin, ILLIXR::webcam, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> <li>_p_thread_setup (ILLIXR::debugview, ILLIXR::gldemo, ILLIXR::lighthouse, ILLIXR::native_renderer, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::offload_writer, ILLIXR::threadloop, ILLIXR::timewarp_gl)</li> <li>_p_should_skip (ILLIXR::lighthouse, ILLIXR::offline_cam, ILLIXR::offline_imu, ILLIXR::offload_reader, ILLIXR::offload_rendering_client, ILLIXR::offload_rendering_server, ILLIXR::openni_plugin, ILLIXR::openwarp_vk_plugin, ILLIXR::server_reader, ILLIXR::threadloop, ILLIXR::timewarp_gl, ILLIXR::timewarp_vk_plugin, ILLIXR::zed_camera_thread, ILLIXR::zed_imu_thread)</li> <li>_stop (ILLIXR::runtime, runtime_impl)</li> <li>_prepare_rendering (ILLIXR::timewarp_gl)</li> <li>_setup (ILLIXR::timewarp_gl)</li> </ul>"},{"location":"api/classcsv__iterator/","title":"Class csv_iterator","text":"<p>ClassList &gt; csv_iterator</p>"},{"location":"api/classcsv__iterator/#public-types","title":"Public Types","text":"Type Name typedef std::size_t difference_type typedef std::input_iterator_tag iterator_category typedef csv_row * pointer typedef csv_row &amp; reference typedef csv_row value_type"},{"location":"api/classcsv__iterator/#public-functions","title":"Public Functions","text":"Type Name csv_iterator (std::istream &amp; str, std::size_t skip=0)  csv_iterator ()  bool operator!= (csv_iterator const &amp; rhs)  csv_row const &amp; operator* () const csv_iterator &amp; operator++ ()  csv_iterator operator++ (int)  csv_iterator &amp; operator+= (std::size_t skip)  csv_row const * operator-&gt; () const bool operator== (csv_iterator const &amp; rhs)  const std::string &amp; operator[] (std::size_t idx)"},{"location":"api/classcsv__iterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classcsv__iterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>typedef std::size_t csv_iterator::difference_type;\n</code></pre>"},{"location":"api/classcsv__iterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>typedef std::input_iterator_tag csv_iterator::iterator_category;\n</code></pre>"},{"location":"api/classcsv__iterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>typedef csv_row* csv_iterator::pointer;\n</code></pre>"},{"location":"api/classcsv__iterator/#typedef-reference","title":"typedef reference","text":"<pre><code>typedef csv_row&amp; csv_iterator::reference;\n</code></pre>"},{"location":"api/classcsv__iterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>typedef csv_row csv_iterator::value_type;\n</code></pre>"},{"location":"api/classcsv__iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcsv__iterator/#function-csv_iterator-12","title":"function csv_iterator [1/2]","text":"<pre><code>inline explicit csv_iterator::csv_iterator (\n    std::istream &amp; str,\n    std::size_t skip=0\n) \n</code></pre>"},{"location":"api/classcsv__iterator/#function-csv_iterator-22","title":"function csv_iterator [2/2]","text":"<pre><code>inline csv_iterator::csv_iterator () \n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator","title":"function operator!=","text":"<pre><code>inline bool csv_iterator::operator!= (\n    csv_iterator const &amp; rhs\n) \n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline csv_row const &amp; csv_iterator::operator* () const\n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline csv_iterator &amp; csv_iterator::operator++ () \n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator_3","title":"function operator++","text":"<pre><code>inline csv_iterator csv_iterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator_4","title":"function operator+=","text":"<pre><code>inline csv_iterator &amp; csv_iterator::operator+= (\n    std::size_t skip\n) \n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline csv_row const * csv_iterator::operator-&gt; () const\n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator_5","title":"function operator==","text":"<pre><code>inline bool csv_iterator::operator== (\n    csv_iterator const &amp; rhs\n) \n</code></pre>"},{"location":"api/classcsv__iterator/#function-operator_6","title":"function operator[]","text":"<pre><code>inline const std::string &amp; csv_iterator::operator[] (\n    std::size_t idx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/csv_iterator.hpp</code></p>"},{"location":"api/classcsv__row/","title":"Class csv_row","text":"<p>ClassList &gt; csv_row</p>"},{"location":"api/classcsv__row/#public-functions","title":"Public Functions","text":"Type Name std::string const &amp; operator[] (std::size_t index) const void read_next_row (std::istream &amp; str)  std::size_t size () const"},{"location":"api/classcsv__row/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcsv__row/#function-operator","title":"function operator[]","text":"<pre><code>inline std::string const &amp; csv_row::operator[] (\n    std::size_t index\n) const\n</code></pre>"},{"location":"api/classcsv__row/#function-read_next_row","title":"function read_next_row","text":"<pre><code>inline void csv_row::read_next_row (\n    std::istream &amp; str\n) \n</code></pre>"},{"location":"api/classcsv__row/#function-size","title":"function size","text":"<pre><code>inline std::size_t csv_row::size () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/csv_iterator.hpp</code></p>"},{"location":"api/classcxxopts_1_1KeyValue/","title":"Class cxxopts::KeyValue","text":"<p>ClassList &gt; cxxopts &gt; KeyValue</p>"},{"location":"api/classcxxopts_1_1KeyValue/#public-functions","title":"Public Functions","text":"Type Name KeyValue (std::string key_, std::string value_) noexcept KeyValue (std::string key_, std::string value_) noexcept T as () const T as () const CXXOPTS_NODISCARD const std::string &amp; key () const CXXOPTS_NODISCARD const std::string &amp; key () const CXXOPTS_NODISCARD const std::string &amp; value () const CXXOPTS_NODISCARD const std::string &amp; value () const"},{"location":"api/classcxxopts_1_1KeyValue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1KeyValue/#function-keyvalue-12","title":"function KeyValue [1/2]","text":"<pre><code>inline cxxopts::KeyValue::KeyValue (\n    std::string key_,\n    std::string value_\n) noexcept\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-keyvalue-12_1","title":"function KeyValue [1/2]","text":"<pre><code>inline cxxopts::KeyValue::KeyValue (\n    std::string key_,\n    std::string value_\n) noexcept\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-as-12","title":"function as [1/2]","text":"<pre><code>template&lt;typename T&gt;\ninline T cxxopts::KeyValue::as () const\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-as-12_1","title":"function as [1/2]","text":"<pre><code>template&lt;typename T&gt;\ninline T cxxopts::KeyValue::as () const\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-key-12","title":"function key [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::KeyValue::key () const\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-key-12_1","title":"function key [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::KeyValue::key () const\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-value-12","title":"function value [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::KeyValue::value () const\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-value-12_1","title":"function value [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::KeyValue::value () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionAdder/","title":"Class cxxopts::OptionAdder","text":"<p>ClassList &gt; cxxopts &gt; OptionAdder</p>"},{"location":"api/classcxxopts_1_1OptionAdder/#public-functions","title":"Public Functions","text":"Type Name OptionAdder (Options &amp; options, std::string group)  OptionAdder (Options &amp; options, std::string group)  OptionAdder &amp; operator() (const std::string &amp; opts, const std::string &amp; desc, const std::shared_ptr&lt; const Value &gt; &amp; value=::cxxopts::value&lt; bool &gt;(), std::string arg_help=\"\")  OptionAdder &amp; operator() (const std::string &amp; opts, const std::string &amp; desc, const std::shared_ptr&lt; const Value &gt; &amp; value=::cxxopts::value&lt; bool &gt;(), std::string arg_help=\"\")"},{"location":"api/classcxxopts_1_1OptionAdder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionAdder/#function-optionadder-12","title":"function OptionAdder [1/2]","text":"<pre><code>inline cxxopts::OptionAdder::OptionAdder (\n    Options &amp; options,\n    std::string group\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionAdder/#function-optionadder-12_1","title":"function OptionAdder [1/2]","text":"<pre><code>inline cxxopts::OptionAdder::OptionAdder (\n    Options &amp; options,\n    std::string group\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionAdder/#function-operator-12","title":"function operator() [1/2]","text":"<pre><code>inline OptionAdder &amp; cxxopts::OptionAdder::operator() (\n    const std::string &amp; opts,\n    const std::string &amp; desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value=::cxxopts::value&lt; bool &gt;(),\n    std::string arg_help=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionAdder/#function-operator-12_1","title":"function operator() [1/2]","text":"<pre><code>OptionAdder &amp; cxxopts::OptionAdder::operator() (\n    const std::string &amp; opts,\n    const std::string &amp; desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value=::cxxopts::value&lt; bool &gt;(),\n    std::string arg_help=\"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionDetails/","title":"Class cxxopts::OptionDetails","text":"<p>ClassList &gt; cxxopts &gt; OptionDetails</p>"},{"location":"api/classcxxopts_1_1OptionDetails/#public-functions","title":"Public Functions","text":"Type Name OptionDetails (std::string short_, OptionNames long_, String desc, std::shared_ptr&lt; const Value &gt; val)  OptionDetails (const OptionDetails &amp; rhs)  OptionDetails (OptionDetails &amp;&amp; rhs) = default OptionDetails (std::string short_, OptionNames long_, String desc, std::shared_ptr&lt; const Value &gt; val)  OptionDetails (const OptionDetails &amp; rhs)  OptionDetails (OptionDetails &amp;&amp; rhs) = default CXXOPTS_NODISCARD const String &amp; description () const CXXOPTS_NODISCARD const String &amp; description () const CXXOPTS_NODISCARD const std::string &amp; essential_name () const CXXOPTS_NODISCARD const std::string &amp; essential_name () const CXXOPTS_NODISCARD const std::string &amp; first_long_name () const CXXOPTS_NODISCARD const std::string &amp; first_long_name () const std::size_t hash () const std::size_t hash () const CXXOPTS_NODISCARD const OptionNames &amp; long_names () const CXXOPTS_NODISCARD const OptionNames &amp; long_names () const CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; make_storage () const CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; make_storage () const CXXOPTS_NODISCARD const std::string &amp; short_name () const CXXOPTS_NODISCARD const std::string &amp; short_name () const CXXOPTS_NODISCARD const Value &amp; value () const CXXOPTS_NODISCARD const Value &amp; value () const"},{"location":"api/classcxxopts_1_1OptionDetails/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-16","title":"function OptionDetails [1/6]","text":"<pre><code>inline cxxopts::OptionDetails::OptionDetails (\n    std::string short_,\n    OptionNames long_,\n    String desc,\n    std::shared_ptr&lt; const Value &gt; val\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-26","title":"function OptionDetails [2/6]","text":"<pre><code>inline cxxopts::OptionDetails::OptionDetails (\n    const OptionDetails &amp; rhs\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-36","title":"function OptionDetails [3/6]","text":"<pre><code>cxxopts::OptionDetails::OptionDetails (\n    OptionDetails &amp;&amp; rhs\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-16_1","title":"function OptionDetails [1/6]","text":"<pre><code>inline cxxopts::OptionDetails::OptionDetails (\n    std::string short_,\n    OptionNames long_,\n    String desc,\n    std::shared_ptr&lt; const Value &gt; val\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-26_1","title":"function OptionDetails [2/6]","text":"<pre><code>inline cxxopts::OptionDetails::OptionDetails (\n    const OptionDetails &amp; rhs\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-36_1","title":"function OptionDetails [3/6]","text":"<pre><code>cxxopts::OptionDetails::OptionDetails (\n    OptionDetails &amp;&amp; rhs\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-description-12","title":"function description [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const String &amp; cxxopts::OptionDetails::description () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-description-12_1","title":"function description [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const String &amp; cxxopts::OptionDetails::description () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-essential_name-12","title":"function essential_name [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::essential_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-essential_name-12_1","title":"function essential_name [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::essential_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-first_long_name-12","title":"function first_long_name [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::first_long_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-first_long_name-12_1","title":"function first_long_name [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::first_long_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-hash-12","title":"function hash [1/2]","text":"<pre><code>inline std::size_t cxxopts::OptionDetails::hash () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-hash-12_1","title":"function hash [1/2]","text":"<pre><code>inline std::size_t cxxopts::OptionDetails::hash () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-long_names-12","title":"function long_names [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const OptionNames &amp; cxxopts::OptionDetails::long_names () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-long_names-12_1","title":"function long_names [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const OptionNames &amp; cxxopts::OptionDetails::long_names () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-make_storage-12","title":"function make_storage [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; cxxopts::OptionDetails::make_storage () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-make_storage-12_1","title":"function make_storage [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; cxxopts::OptionDetails::make_storage () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-short_name-12","title":"function short_name [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::short_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-short_name-12_1","title":"function short_name [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::short_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-value-12","title":"function value [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const Value &amp; cxxopts::OptionDetails::value () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-value-12_1","title":"function value [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const Value &amp; cxxopts::OptionDetails::value () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionParser/","title":"Class cxxopts::OptionParser","text":"<p>ClassList &gt; cxxopts &gt; OptionParser</p>"},{"location":"api/classcxxopts_1_1OptionParser/#public-functions","title":"Public Functions","text":"Type Name OptionParser (const OptionMap &amp; options, const PositionalList &amp; positional, bool allow_unrecognised)  OptionParser (const OptionMap &amp; options, const PositionalList &amp; positional, bool allow_unrecognised)  void add_to_option (OptionMap::const_iterator iter, const std::string &amp; option, const std::string &amp; arg)  void add_to_option (OptionMap::const_iterator iter, const std::string &amp; option, const std::string &amp; arg)  void checked_parse_arg (int argc, const char *const * argv, int &amp; current, const std::shared_ptr&lt; OptionDetails &gt; &amp; value, const std::string &amp; name)  void checked_parse_arg (int argc, const char *const * argv, int &amp; current, const std::shared_ptr&lt; OptionDetails &gt; &amp; value, const std::string &amp; name)  bool consume_positional (const std::string &amp; a, PositionalListIterator &amp; next)  bool consume_positional (const std::string &amp; a, PositionalListIterator &amp; next)  ParseResult parse (int argc, const char *const * argv)  ParseResult parse (int argc, const char *const * argv)  void parse_default (const std::shared_ptr&lt; OptionDetails &gt; &amp; details)  void parse_default (const std::shared_ptr&lt; OptionDetails &gt; &amp; details)  void parse_no_value (const std::shared_ptr&lt; OptionDetails &gt; &amp; details)  void parse_no_value (const std::shared_ptr&lt; OptionDetails &gt; &amp; details)  void parse_option (const std::shared_ptr&lt; OptionDetails &gt; &amp; value, const std::string &amp; name, const std::string &amp; arg=\"\")  void parse_option (const std::shared_ptr&lt; OptionDetails &gt; &amp; value, const std::string &amp; name, const std::string &amp; arg=\"\")"},{"location":"api/classcxxopts_1_1OptionParser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionParser/#function-optionparser-12","title":"function OptionParser [1/2]","text":"<pre><code>inline cxxopts::OptionParser::OptionParser (\n    const OptionMap &amp; options,\n    const PositionalList &amp; positional,\n    bool allow_unrecognised\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-optionparser-12_1","title":"function OptionParser [1/2]","text":"<pre><code>inline cxxopts::OptionParser::OptionParser (\n    const OptionMap &amp; options,\n    const PositionalList &amp; positional,\n    bool allow_unrecognised\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-add_to_option-12","title":"function add_to_option [1/2]","text":"<pre><code>inline void cxxopts::OptionParser::add_to_option (\n    OptionMap::const_iterator iter,\n    const std::string &amp; option,\n    const std::string &amp; arg\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-add_to_option-12_1","title":"function add_to_option [1/2]","text":"<pre><code>void cxxopts::OptionParser::add_to_option (\n    OptionMap::const_iterator iter,\n    const std::string &amp; option,\n    const std::string &amp; arg\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-checked_parse_arg-12","title":"function checked_parse_arg [1/2]","text":"<pre><code>inline void cxxopts::OptionParser::checked_parse_arg (\n    int argc,\n    const char *const * argv,\n    int &amp; current,\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; value,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-checked_parse_arg-12_1","title":"function checked_parse_arg [1/2]","text":"<pre><code>void cxxopts::OptionParser::checked_parse_arg (\n    int argc,\n    const char *const * argv,\n    int &amp; current,\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; value,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-consume_positional-12","title":"function consume_positional [1/2]","text":"<pre><code>inline bool cxxopts::OptionParser::consume_positional (\n    const std::string &amp; a,\n    PositionalListIterator &amp; next\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-consume_positional-12_1","title":"function consume_positional [1/2]","text":"<pre><code>bool cxxopts::OptionParser::consume_positional (\n    const std::string &amp; a,\n    PositionalListIterator &amp; next\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse-12","title":"function parse [1/2]","text":"<pre><code>inline ParseResult cxxopts::OptionParser::parse (\n    int argc,\n    const char *const * argv\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse-12_1","title":"function parse [1/2]","text":"<pre><code>ParseResult cxxopts::OptionParser::parse (\n    int argc,\n    const char *const * argv\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_default-12","title":"function parse_default [1/2]","text":"<pre><code>inline void cxxopts::OptionParser::parse_default (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_default-12_1","title":"function parse_default [1/2]","text":"<pre><code>void cxxopts::OptionParser::parse_default (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_no_value-12","title":"function parse_no_value [1/2]","text":"<pre><code>inline void cxxopts::OptionParser::parse_no_value (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_no_value-12_1","title":"function parse_no_value [1/2]","text":"<pre><code>void cxxopts::OptionParser::parse_no_value (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_option-12","title":"function parse_option [1/2]","text":"<pre><code>inline void cxxopts::OptionParser::parse_option (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; value,\n    const std::string &amp; name,\n    const std::string &amp; arg=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_option-12_1","title":"function parse_option [1/2]","text":"<pre><code>void cxxopts::OptionParser::parse_option (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; value,\n    const std::string &amp; name,\n    const std::string &amp; arg=\"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionValue/","title":"Class cxxopts::OptionValue","text":"<p>ClassList &gt; cxxopts &gt; OptionValue</p>"},{"location":"api/classcxxopts_1_1OptionValue/#public-functions","title":"Public Functions","text":"Type Name const T &amp; as () const const T &amp; as () const CXXOPTS_NODISCARD std::size_t count () noexcept const CXXOPTS_NODISCARD std::size_t count () noexcept const CXXOPTS_NODISCARD bool has_default () noexcept const CXXOPTS_NODISCARD bool has_default () noexcept const void parse (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details, const std::string &amp; text)  void parse (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details, const std::string &amp; text)  void parse_default (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details)  void parse_default (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details)  void parse_no_value (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details)  void parse_no_value (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details)"},{"location":"api/classcxxopts_1_1OptionValue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionValue/#function-as-12","title":"function as [1/2]","text":"<pre><code>template&lt;typename T&gt;\ninline const T &amp; cxxopts::OptionValue::as () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-as-12_1","title":"function as [1/2]","text":"<pre><code>template&lt;typename T&gt;\ninline const T &amp; cxxopts::OptionValue::as () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-count-12","title":"function count [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD std::size_t cxxopts::OptionValue::count () noexcept const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-count-12_1","title":"function count [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD std::size_t cxxopts::OptionValue::count () noexcept const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-has_default-12","title":"function has_default [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD bool cxxopts::OptionValue::has_default () noexcept const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-has_default-12_1","title":"function has_default [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD bool cxxopts::OptionValue::has_default () noexcept const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse-12","title":"function parse [1/2]","text":"<pre><code>inline void cxxopts::OptionValue::parse (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details,\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse-12_1","title":"function parse [1/2]","text":"<pre><code>inline void cxxopts::OptionValue::parse (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details,\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse_default-12","title":"function parse_default [1/2]","text":"<pre><code>inline void cxxopts::OptionValue::parse_default (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse_default-12_1","title":"function parse_default [1/2]","text":"<pre><code>inline void cxxopts::OptionValue::parse_default (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse_no_value-12","title":"function parse_no_value [1/2]","text":"<pre><code>inline void cxxopts::OptionValue::parse_no_value (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse_no_value-12_1","title":"function parse_no_value [1/2]","text":"<pre><code>inline void cxxopts::OptionValue::parse_no_value (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1Options/","title":"Class cxxopts::Options","text":"<p>ClassList &gt; cxxopts &gt; Options</p>"},{"location":"api/classcxxopts_1_1Options/#public-functions","title":"Public Functions","text":"Type Name Options (std::string program_name, std::string help_string=\"\")  Options (std::string program_name, std::string help_string=\"\")  void add_option (const std::string &amp; group, const Option &amp; option)  void add_option (const std::string &amp; group, const std::string &amp; s, const OptionNames &amp; l, std::string desc, const std::shared_ptr&lt; const Value &gt; &amp; value, std::string arg_help)  void add_option (const std::string &amp; group, const std::string &amp; short_name, const std::string &amp; single_long_name, std::string desc, const std::shared_ptr&lt; const Value &gt; &amp; value, std::string arg_help)  void add_option (const std::string &amp; group, const Option &amp; option)  void add_option (const std::string &amp; group, const std::string &amp; s, const OptionNames &amp; l, std::string desc, const std::shared_ptr&lt; const Value &gt; &amp; value, std::string arg_help)  void add_option (const std::string &amp; group, const std::string &amp; short_name, const std::string &amp; single_long_name, std::string desc, const std::shared_ptr&lt; const Value &gt; &amp; value, std::string arg_help)  OptionAdder add_options (std::string group=\"\")  void add_options (const std::string &amp; group, std::initializer_list&lt; Option &gt; options)  OptionAdder add_options (std::string group=\"\")  void add_options (const std::string &amp; group, std::initializer_list&lt; Option &gt; options)  Options &amp; allow_unrecognised_options ()  Options &amp; allow_unrecognised_options ()  Options &amp; custom_help (std::string help_text)  Options &amp; custom_help (std::string help_text)  const HelpGroupDetails &amp; group_help (const std::string &amp; group) const const HelpGroupDetails &amp; group_help (const std::string &amp; group) const std::vector&lt; std::string &gt; groups () const std::vector&lt; std::string &gt; groups () const std::string help (const std::vector&lt; std::string &gt; &amp; groups={}, bool print_usage=true) const std::string help (const std::vector&lt; std::string &gt; &amp; groups={}, bool print_usage=true) const ParseResult parse (int argc, const char *const * argv)  ParseResult parse (int argc, const char *const * argv)  void parse_positional (std::string option)  void parse_positional (std::vector&lt; std::string &gt; options)  void parse_positional (std::initializer_list&lt; std::string &gt; options)  void parse_positional (Iterator begin, Iterator end)  void parse_positional (std::string option)  void parse_positional (std::vector&lt; std::string &gt; options)  void parse_positional (std::initializer_list&lt; std::string &gt; options)  void parse_positional (Iterator begin, Iterator end)  Options &amp; positional_help (std::string help_text)  Options &amp; positional_help (std::string help_text)  const std::string &amp; program () const const std::string &amp; program () const Options &amp; set_tab_expansion (bool expansion=true)  Options &amp; set_tab_expansion (bool expansion=true)  Options &amp; set_width (std::size_t width)  Options &amp; set_width (std::size_t width)  Options &amp; show_positional_help ()  Options &amp; show_positional_help ()"},{"location":"api/classcxxopts_1_1Options/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1Options/#function-options-12","title":"function Options [1/2]","text":"<pre><code>inline explicit cxxopts::Options::Options (\n    std::string program_name,\n    std::string help_string=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-options-12_1","title":"function Options [1/2]","text":"<pre><code>inline explicit cxxopts::Options::Options (\n    std::string program_name,\n    std::string help_string=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-16","title":"function add_option [1/6]","text":"<pre><code>inline void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const Option &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-26","title":"function add_option [2/6]","text":"<pre><code>inline void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const std::string &amp; s,\n    const OptionNames &amp; l,\n    std::string desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value,\n    std::string arg_help\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-36","title":"function add_option [3/6]","text":"<pre><code>inline void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const std::string &amp; short_name,\n    const std::string &amp; single_long_name,\n    std::string desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value,\n    std::string arg_help\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-16_1","title":"function add_option [1/6]","text":"<pre><code>void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const Option &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-26_1","title":"function add_option [2/6]","text":"<pre><code>void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const std::string &amp; s,\n    const OptionNames &amp; l,\n    std::string desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value,\n    std::string arg_help\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-36_1","title":"function add_option [3/6]","text":"<pre><code>inline void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const std::string &amp; short_name,\n    const std::string &amp; single_long_name,\n    std::string desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value,\n    std::string arg_help\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_options-14","title":"function add_options [1/4]","text":"<pre><code>inline OptionAdder cxxopts::Options::add_options (\n    std::string group=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_options-24","title":"function add_options [2/4]","text":"<pre><code>inline void cxxopts::Options::add_options (\n    const std::string &amp; group,\n    std::initializer_list&lt; Option &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_options-14_1","title":"function add_options [1/4]","text":"<pre><code>OptionAdder cxxopts::Options::add_options (\n    std::string group=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_options-24_1","title":"function add_options [2/4]","text":"<pre><code>void cxxopts::Options::add_options (\n    const std::string &amp; group,\n    std::initializer_list&lt; Option &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-allow_unrecognised_options-12","title":"function allow_unrecognised_options [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::allow_unrecognised_options () \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-allow_unrecognised_options-12_1","title":"function allow_unrecognised_options [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::allow_unrecognised_options () \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-custom_help-12","title":"function custom_help [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::custom_help (\n    std::string help_text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-custom_help-12_1","title":"function custom_help [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::custom_help (\n    std::string help_text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-group_help-12","title":"function group_help [1/2]","text":"<pre><code>inline const HelpGroupDetails &amp; cxxopts::Options::group_help (\n    const std::string &amp; group\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-group_help-12_1","title":"function group_help [1/2]","text":"<pre><code>const HelpGroupDetails &amp; cxxopts::Options::group_help (\n    const std::string &amp; group\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-groups-12","title":"function groups [1/2]","text":"<pre><code>inline std::vector&lt; std::string &gt; cxxopts::Options::groups () const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-groups-12_1","title":"function groups [1/2]","text":"<pre><code>std::vector&lt; std::string &gt; cxxopts::Options::groups () const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-help-12","title":"function help [1/2]","text":"<pre><code>inline std::string cxxopts::Options::help (\n    const std::vector&lt; std::string &gt; &amp; groups={},\n    bool print_usage=true\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-help-12_1","title":"function help [1/2]","text":"<pre><code>std::string cxxopts::Options::help (\n    const std::vector&lt; std::string &gt; &amp; groups={},\n    bool print_usage=true\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse-12","title":"function parse [1/2]","text":"<pre><code>inline ParseResult cxxopts::Options::parse (\n    int argc,\n    const char *const * argv\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse-12_1","title":"function parse [1/2]","text":"<pre><code>ParseResult cxxopts::Options::parse (\n    int argc,\n    const char *const * argv\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-18","title":"function parse_positional [1/8]","text":"<pre><code>inline void cxxopts::Options::parse_positional (\n    std::string option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-28","title":"function parse_positional [2/8]","text":"<pre><code>inline void cxxopts::Options::parse_positional (\n    std::vector&lt; std::string &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-38","title":"function parse_positional [3/8]","text":"<pre><code>inline void cxxopts::Options::parse_positional (\n    std::initializer_list&lt; std::string &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-48","title":"function parse_positional [4/8]","text":"<pre><code>template&lt;typename Iterator&gt;\ninline void cxxopts::Options::parse_positional (\n    Iterator begin,\n    Iterator end\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-18_1","title":"function parse_positional [1/8]","text":"<pre><code>void cxxopts::Options::parse_positional (\n    std::string option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-28_1","title":"function parse_positional [2/8]","text":"<pre><code>void cxxopts::Options::parse_positional (\n    std::vector&lt; std::string &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-38_1","title":"function parse_positional [3/8]","text":"<pre><code>void cxxopts::Options::parse_positional (\n    std::initializer_list&lt; std::string &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-48_1","title":"function parse_positional [4/8]","text":"<pre><code>template&lt;typename Iterator&gt;\ninline void cxxopts::Options::parse_positional (\n    Iterator begin,\n    Iterator end\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-positional_help-12","title":"function positional_help [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::positional_help (\n    std::string help_text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-positional_help-12_1","title":"function positional_help [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::positional_help (\n    std::string help_text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-program-12","title":"function program [1/2]","text":"<pre><code>inline const std::string &amp; cxxopts::Options::program () const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-program-12_1","title":"function program [1/2]","text":"<pre><code>inline const std::string &amp; cxxopts::Options::program () const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-set_tab_expansion-12","title":"function set_tab_expansion [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::set_tab_expansion (\n    bool expansion=true\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-set_tab_expansion-12_1","title":"function set_tab_expansion [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::set_tab_expansion (\n    bool expansion=true\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-set_width-12","title":"function set_width [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::set_width (\n    std::size_t width\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-set_width-12_1","title":"function set_width [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::set_width (\n    std::size_t width\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-show_positional_help-12","title":"function show_positional_help [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::show_positional_help () \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-show_positional_help-12_1","title":"function show_positional_help [1/2]","text":"<pre><code>inline Options &amp; cxxopts::Options::show_positional_help () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1ParseResult/","title":"Class cxxopts::ParseResult","text":"<p>ClassList &gt; cxxopts &gt; ParseResult</p>"},{"location":"api/classcxxopts_1_1ParseResult/#classes","title":"Classes","text":"Type Name class Iterator"},{"location":"api/classcxxopts_1_1ParseResult/#public-functions","title":"Public Functions","text":"Type Name ParseResult () = default ParseResult (const ParseResult &amp;) = default ParseResult (NameHashMap &amp;&amp; keys, ParsedHashMap &amp;&amp; values, std::vector&lt; KeyValue &gt; sequential, std::vector&lt; KeyValue &gt; default_opts, std::vector&lt; std::string &gt; &amp;&amp; unmatched_args)  ParseResult () = default ParseResult (const ParseResult &amp;) = default ParseResult (NameHashMap &amp;&amp; keys, ParsedHashMap &amp;&amp; values, std::vector&lt; KeyValue &gt; sequential, std::vector&lt; KeyValue &gt; default_opts, std::vector&lt; std::string &gt; &amp;&amp; unmatched_args)  const std::vector&lt; KeyValue &gt; &amp; arguments () const const std::vector&lt; KeyValue &gt; &amp; arguments () const const std::string arguments_string () const const std::string arguments_string () const Iterator begin () const Iterator begin () const std::size_t count (const std::string &amp; o) const std::size_t count (const std::string &amp; o) const const std::vector&lt; KeyValue &gt; &amp; defaults () const const std::vector&lt; KeyValue &gt; &amp; defaults () const Iterator end () const Iterator end () const ParseResult &amp; operator= (ParseResult &amp;&amp;) = default ParseResult &amp; operator= (const ParseResult &amp;) = default ParseResult &amp; operator= (ParseResult &amp;&amp;) = default ParseResult &amp; operator= (const ParseResult &amp;) = default const OptionValue &amp; operator[] (const std::string &amp; option) const const OptionValue &amp; operator[] (const std::string &amp; option) const const std::vector&lt; std::string &gt; &amp; unmatched () const const std::vector&lt; std::string &gt; &amp; unmatched () const"},{"location":"api/classcxxopts_1_1ParseResult/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-16","title":"function ParseResult [1/6]","text":"<pre><code>cxxopts::ParseResult::ParseResult () = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-26","title":"function ParseResult [2/6]","text":"<pre><code>cxxopts::ParseResult::ParseResult (\n    const ParseResult &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-36","title":"function ParseResult [3/6]","text":"<pre><code>inline cxxopts::ParseResult::ParseResult (\n    NameHashMap &amp;&amp; keys,\n    ParsedHashMap &amp;&amp; values,\n    std::vector&lt; KeyValue &gt; sequential,\n    std::vector&lt; KeyValue &gt; default_opts,\n    std::vector&lt; std::string &gt; &amp;&amp; unmatched_args\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-16_1","title":"function ParseResult [1/6]","text":"<pre><code>cxxopts::ParseResult::ParseResult () = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-26_1","title":"function ParseResult [2/6]","text":"<pre><code>cxxopts::ParseResult::ParseResult (\n    const ParseResult &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-36_1","title":"function ParseResult [3/6]","text":"<pre><code>inline cxxopts::ParseResult::ParseResult (\n    NameHashMap &amp;&amp; keys,\n    ParsedHashMap &amp;&amp; values,\n    std::vector&lt; KeyValue &gt; sequential,\n    std::vector&lt; KeyValue &gt; default_opts,\n    std::vector&lt; std::string &gt; &amp;&amp; unmatched_args\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-arguments-12","title":"function arguments [1/2]","text":"<pre><code>inline const std::vector&lt; KeyValue &gt; &amp; cxxopts::ParseResult::arguments () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-arguments-12_1","title":"function arguments [1/2]","text":"<pre><code>inline const std::vector&lt; KeyValue &gt; &amp; cxxopts::ParseResult::arguments () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-arguments_string-12","title":"function arguments_string [1/2]","text":"<pre><code>inline const std::string cxxopts::ParseResult::arguments_string () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-arguments_string-12_1","title":"function arguments_string [1/2]","text":"<pre><code>inline const std::string cxxopts::ParseResult::arguments_string () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>inline Iterator cxxopts::ParseResult::begin () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-begin-12_1","title":"function begin [1/2]","text":"<pre><code>inline Iterator cxxopts::ParseResult::begin () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-count-12","title":"function count [1/2]","text":"<pre><code>inline std::size_t cxxopts::ParseResult::count (\n    const std::string &amp; o\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-count-12_1","title":"function count [1/2]","text":"<pre><code>inline std::size_t cxxopts::ParseResult::count (\n    const std::string &amp; o\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-defaults-12","title":"function defaults [1/2]","text":"<pre><code>inline const std::vector&lt; KeyValue &gt; &amp; cxxopts::ParseResult::defaults () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-defaults-12_1","title":"function defaults [1/2]","text":"<pre><code>inline const std::vector&lt; KeyValue &gt; &amp; cxxopts::ParseResult::defaults () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-end-12","title":"function end [1/2]","text":"<pre><code>inline Iterator cxxopts::ParseResult::end () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-end-12_1","title":"function end [1/2]","text":"<pre><code>inline Iterator cxxopts::ParseResult::end () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator","title":"function operator=","text":"<pre><code>ParseResult &amp; cxxopts::ParseResult::operator= (\n    ParseResult &amp;&amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator_1","title":"function operator=","text":"<pre><code>ParseResult &amp; cxxopts::ParseResult::operator= (\n    const ParseResult &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator_2","title":"function operator=","text":"<pre><code>ParseResult &amp; cxxopts::ParseResult::operator= (\n    ParseResult &amp;&amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator_3","title":"function operator=","text":"<pre><code>ParseResult &amp; cxxopts::ParseResult::operator= (\n    const ParseResult &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator_4","title":"function operator[]","text":"<pre><code>inline const OptionValue &amp; cxxopts::ParseResult::operator[] (\n    const std::string &amp; option\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator_5","title":"function operator[]","text":"<pre><code>inline const OptionValue &amp; cxxopts::ParseResult::operator[] (\n    const std::string &amp; option\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-unmatched-12","title":"function unmatched [1/2]","text":"<pre><code>inline const std::vector&lt; std::string &gt; &amp; cxxopts::ParseResult::unmatched () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-unmatched-12_1","title":"function unmatched [1/2]","text":"<pre><code>inline const std::vector&lt; std::string &gt; &amp; cxxopts::ParseResult::unmatched () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/","title":"Class cxxopts::ParseResult::Iterator","text":"<p>ClassList &gt; cxxopts &gt; ParseResult &gt; Iterator</p>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-types","title":"Public Types","text":"Type Name typedef void difference_type typedef void difference_type typedef std::forward_iterator_tag iterator_category typedef std::forward_iterator_tag iterator_category typedef const KeyValue * pointer typedef const KeyValue * pointer typedef const KeyValue &amp; reference typedef const KeyValue &amp; reference typedef KeyValue value_type typedef KeyValue value_type"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-functions","title":"Public Functions","text":"Type Name Iterator () = default Iterator (const Iterator &amp;) = default CXXOPTS_DIAGNOSTIC_PUSH Iterator (const ParseResult * pr, bool end=false)  Iterator () = default Iterator (const Iterator &amp;) = default CXXOPTS_DIAGNOSTIC_PUSH Iterator (const ParseResult * pr, bool end=false)  bool operator!= (const Iterator &amp; other) const bool operator!= (const Iterator &amp; other) const const KeyValue &amp; operator* ()  const KeyValue &amp; operator* ()  CXXOPTS_DIAGNOSTIC_POP Iterator &amp; operator++ ()  Iterator operator++ (int)  CXXOPTS_DIAGNOSTIC_POP Iterator &amp; operator++ ()  Iterator operator++ (int)  const KeyValue * operator-&gt; ()  const KeyValue * operator-&gt; ()  bool operator== (const Iterator &amp; other) const bool operator== (const Iterator &amp; other) const"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-difference_type-12","title":"typedef difference_type [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::difference_type =  void;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-difference_type-12_1","title":"typedef difference_type [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::difference_type =  void;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-iterator_category-12","title":"typedef iterator_category [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::iterator_category =  std::forward_iterator_tag;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-iterator_category-12_1","title":"typedef iterator_category [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::iterator_category =  std::forward_iterator_tag;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-pointer-12","title":"typedef pointer [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::pointer =  const KeyValue*;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-pointer-12_1","title":"typedef pointer [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::pointer =  const KeyValue*;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-reference-12","title":"typedef reference [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::reference =  const KeyValue&amp;;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-reference-12_1","title":"typedef reference [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::reference =  const KeyValue&amp;;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-value_type-12","title":"typedef value_type [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::value_type =  KeyValue;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-value_type-12_1","title":"typedef value_type [1/2]","text":"<pre><code>using cxxopts::ParseResult::Iterator::value_type =  KeyValue;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-16","title":"function Iterator [1/6]","text":"<pre><code>cxxopts::ParseResult::Iterator::Iterator () = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-26","title":"function Iterator [2/6]","text":"<pre><code>cxxopts::ParseResult::Iterator::Iterator (\n    const Iterator &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-36","title":"function Iterator [3/6]","text":"<pre><code>inline CXXOPTS_DIAGNOSTIC_PUSH cxxopts::ParseResult::Iterator::Iterator (\n    const ParseResult * pr,\n    bool end=false\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-16_1","title":"function Iterator [1/6]","text":"<pre><code>cxxopts::ParseResult::Iterator::Iterator () = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-26_1","title":"function Iterator [2/6]","text":"<pre><code>cxxopts::ParseResult::Iterator::Iterator (\n    const Iterator &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-36_1","title":"function Iterator [3/6]","text":"<pre><code>inline CXXOPTS_DIAGNOSTIC_PUSH cxxopts::ParseResult::Iterator::Iterator (\n    const ParseResult * pr,\n    bool end=false\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator","title":"function operator!=","text":"<pre><code>inline bool cxxopts::ParseResult::Iterator::operator!= (\n    const Iterator &amp; other\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_1","title":"function operator!=","text":"<pre><code>inline bool cxxopts::ParseResult::Iterator::operator!= (\n    const Iterator &amp; other\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_2","title":"function operator*","text":"<pre><code>inline const KeyValue &amp; cxxopts::ParseResult::Iterator::operator* () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_3","title":"function operator*","text":"<pre><code>inline const KeyValue &amp; cxxopts::ParseResult::Iterator::operator* () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_4","title":"function operator++","text":"<pre><code>inline CXXOPTS_DIAGNOSTIC_POP Iterator &amp; cxxopts::ParseResult::Iterator::operator++ () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_5","title":"function operator++","text":"<pre><code>inline Iterator cxxopts::ParseResult::Iterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_6","title":"function operator++","text":"<pre><code>inline CXXOPTS_DIAGNOSTIC_POP Iterator &amp; cxxopts::ParseResult::Iterator::operator++ () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_7","title":"function operator++","text":"<pre><code>inline Iterator cxxopts::ParseResult::Iterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline const KeyValue * cxxopts::ParseResult::Iterator::operator-&gt; () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline const KeyValue * cxxopts::ParseResult::Iterator::operator-&gt; () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_8","title":"function operator==","text":"<pre><code>inline bool cxxopts::ParseResult::Iterator::operator== (\n    const Iterator &amp; other\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_9","title":"function operator==","text":"<pre><code>inline bool cxxopts::ParseResult::Iterator::operator== (\n    const Iterator &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1Value/","title":"Class cxxopts::Value","text":"<p>ClassList &gt; cxxopts &gt; Value</p> <p>Inherits the following classes: std::enable_shared_from_this&lt; Value &gt;,  std::enable_shared_from_this&lt; Value &gt;</p> <p>Inherited by the following classes: cxxopts::values::abstract_value,  cxxopts::values::abstract_value,  cxxopts::values::abstract_value,  cxxopts::values::abstract_value</p>"},{"location":"api/classcxxopts_1_1Value/#public-functions","title":"Public Functions","text":"Type Name virtual std::shared_ptr&lt; Value &gt; clone () const = 0 virtual std::shared_ptr&lt; Value &gt; clone () const = 0 virtual std::shared_ptr&lt; Value &gt; default_value (const std::string &amp; value) = 0 virtual std::shared_ptr&lt; Value &gt; default_value (const std::string &amp; value) = 0 virtual std::string get_default_value () const = 0 virtual std::string get_default_value () const = 0 virtual std::string get_implicit_value () const = 0 virtual std::string get_implicit_value () const = 0 virtual bool has_default () const = 0 virtual bool has_default () const = 0 virtual bool has_implicit () const = 0 virtual bool has_implicit () const = 0 virtual std::shared_ptr&lt; Value &gt; implicit_value (const std::string &amp; value) = 0 virtual std::shared_ptr&lt; Value &gt; implicit_value (const std::string &amp; value) = 0 virtual bool is_boolean () const = 0 virtual bool is_boolean () const = 0 virtual bool is_container () const = 0 virtual bool is_container () const = 0 virtual std::shared_ptr&lt; Value &gt; no_implicit_value () = 0 virtual std::shared_ptr&lt; Value &gt; no_implicit_value () = 0 virtual void parse (const std::string &amp; text) const = 0 virtual void parse () const = 0 virtual void parse (const std::string &amp; text) const = 0 virtual void parse () const = 0 virtual ~Value () = default virtual ~Value () = default"},{"location":"api/classcxxopts_1_1Value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1Value/#function-clone-12","title":"function clone [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::clone () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-clone-12_1","title":"function clone [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::clone () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-default_value-12","title":"function default_value [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::default_value (\n    const std::string &amp; value\n) = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-default_value-12_1","title":"function default_value [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::default_value (\n    const std::string &amp; value\n) = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-get_default_value-12","title":"function get_default_value [1/2]","text":"<pre><code>virtual std::string cxxopts::Value::get_default_value () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-get_default_value-12_1","title":"function get_default_value [1/2]","text":"<pre><code>virtual std::string cxxopts::Value::get_default_value () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-get_implicit_value-12","title":"function get_implicit_value [1/2]","text":"<pre><code>virtual std::string cxxopts::Value::get_implicit_value () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-get_implicit_value-12_1","title":"function get_implicit_value [1/2]","text":"<pre><code>virtual std::string cxxopts::Value::get_implicit_value () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-has_default-12","title":"function has_default [1/2]","text":"<pre><code>virtual bool cxxopts::Value::has_default () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-has_default-12_1","title":"function has_default [1/2]","text":"<pre><code>virtual bool cxxopts::Value::has_default () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-has_implicit-12","title":"function has_implicit [1/2]","text":"<pre><code>virtual bool cxxopts::Value::has_implicit () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-has_implicit-12_1","title":"function has_implicit [1/2]","text":"<pre><code>virtual bool cxxopts::Value::has_implicit () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-implicit_value-12","title":"function implicit_value [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::implicit_value (\n    const std::string &amp; value\n) = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-implicit_value-12_1","title":"function implicit_value [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::implicit_value (\n    const std::string &amp; value\n) = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-is_boolean-12","title":"function is_boolean [1/2]","text":"<pre><code>virtual bool cxxopts::Value::is_boolean () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-is_boolean-12_1","title":"function is_boolean [1/2]","text":"<pre><code>virtual bool cxxopts::Value::is_boolean () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-is_container-12","title":"function is_container [1/2]","text":"<pre><code>virtual bool cxxopts::Value::is_container () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-is_container-12_1","title":"function is_container [1/2]","text":"<pre><code>virtual bool cxxopts::Value::is_container () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-no_implicit_value-12","title":"function no_implicit_value [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::no_implicit_value () = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-no_implicit_value-12_1","title":"function no_implicit_value [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::no_implicit_value () = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-parse-14","title":"function parse [1/4]","text":"<pre><code>virtual void cxxopts::Value::parse (\n    const std::string &amp; text\n) const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-parse-24","title":"function parse [2/4]","text":"<pre><code>virtual void cxxopts::Value::parse () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-parse-14_1","title":"function parse [1/4]","text":"<pre><code>virtual void cxxopts::Value::parse (\n    const std::string &amp; text\n) const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-parse-24_1","title":"function parse [2/4]","text":"<pre><code>virtual void cxxopts::Value::parse () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-value-12","title":"function ~Value [1/2]","text":"<pre><code>virtual cxxopts::Value::~Value () = default\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-value-12_1","title":"function ~Value [1/2]","text":"<pre><code>virtual cxxopts::Value::~Value () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/","title":"Class cxxopts::exceptions::exception","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; exception</p> <p>Inherits the following classes: std::exception,  std::exception</p> <p>Inherited by the following classes: cxxopts::exceptions::option_has_no_value,  cxxopts::exceptions::option_has_no_value,  cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing,  cxxopts::exceptions::specification,  cxxopts::exceptions::specification</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#public-functions","title":"Public Functions","text":"Type Name exception (std::string message)  exception (std::string message)  CXXOPTS_NODISCARD const char * what () noexcept override const CXXOPTS_NODISCARD const char * what () noexcept override const"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#function-exception-12","title":"function exception [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::exception::exception (\n    std::string message\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#function-exception-12_1","title":"function exception [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::exception::exception (\n    std::string message\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#function-what-12","title":"function what [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const char * cxxopts::exceptions::exception::what () noexcept override const\n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#function-what-12_1","title":"function what [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD const char * cxxopts::exceptions::exception::what () noexcept override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/","title":"Class cxxopts::exceptions::gratuitous_argument_for_option","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; gratuitous_argument_for_option</p> <p>Inherits the following classes: cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/#public-functions","title":"Public Functions","text":"Type Name gratuitous_argument_for_option (const std::string &amp; option, const std::string &amp; arg)  gratuitous_argument_for_option (const std::string &amp; option, const std::string &amp; arg)"},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/#function-gratuitous_argument_for_option-12","title":"function gratuitous_argument_for_option [1/2]","text":"<pre><code>inline cxxopts::exceptions::gratuitous_argument_for_option::gratuitous_argument_for_option (\n    const std::string &amp; option,\n    const std::string &amp; arg\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/#function-gratuitous_argument_for_option-12_1","title":"function gratuitous_argument_for_option [1/2]","text":"<pre><code>inline cxxopts::exceptions::gratuitous_argument_for_option::gratuitous_argument_for_option (\n    const std::string &amp; option,\n    const std::string &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/","title":"Class cxxopts::exceptions::incorrect_argument_type","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; incorrect_argument_type</p> <p>Inherits the following classes: cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/#public-functions","title":"Public Functions","text":"Type Name incorrect_argument_type (const std::string &amp; arg)  incorrect_argument_type (const std::string &amp; arg)"},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/#function-incorrect_argument_type-12","title":"function incorrect_argument_type [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::incorrect_argument_type::incorrect_argument_type (\n    const std::string &amp; arg\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/#function-incorrect_argument_type-12_1","title":"function incorrect_argument_type [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::incorrect_argument_type::incorrect_argument_type (\n    const std::string &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/","title":"Class cxxopts::exceptions::invalid_option_format","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; invalid_option_format</p> <p>Inherits the following classes: cxxopts::exceptions::specification,  cxxopts::exceptions::specification</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/#public-functions","title":"Public Functions","text":"Type Name invalid_option_format (const std::string &amp; format)  invalid_option_format (const std::string &amp; format)"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/#function-invalid_option_format-12","title":"function invalid_option_format [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::invalid_option_format::invalid_option_format (\n    const std::string &amp; format\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/#function-invalid_option_format-12_1","title":"function invalid_option_format [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::invalid_option_format::invalid_option_format (\n    const std::string &amp; format\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/","title":"Class cxxopts::exceptions::invalid_option_syntax","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; invalid_option_syntax</p> <p>Inherits the following classes: cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/#public-functions","title":"Public Functions","text":"Type Name invalid_option_syntax (const std::string &amp; text)  invalid_option_syntax (const std::string &amp; text)"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/#function-invalid_option_syntax-12","title":"function invalid_option_syntax [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::invalid_option_syntax::invalid_option_syntax (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/#function-invalid_option_syntax-12_1","title":"function invalid_option_syntax [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::invalid_option_syntax::invalid_option_syntax (\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/","title":"Class cxxopts::exceptions::missing_argument","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; missing_argument</p> <p>Inherits the following classes: cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/#public-functions","title":"Public Functions","text":"Type Name missing_argument (const std::string &amp; option)  missing_argument (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/#function-missing_argument-12","title":"function missing_argument [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::missing_argument::missing_argument (\n    const std::string &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/#function-missing_argument-12_1","title":"function missing_argument [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::missing_argument::missing_argument (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/","title":"Class cxxopts::exceptions::no_such_option","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; no_such_option</p> <p>Inherits the following classes: cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/#public-functions","title":"Public Functions","text":"Type Name no_such_option (const std::string &amp; option)  no_such_option (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/#function-no_such_option-12","title":"function no_such_option [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::no_such_option::no_such_option (\n    const std::string &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/#function-no_such_option-12_1","title":"function no_such_option [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::no_such_option::no_such_option (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/","title":"Class cxxopts::exceptions::option_already_exists","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; option_already_exists</p> <p>Inherits the following classes: cxxopts::exceptions::specification,  cxxopts::exceptions::specification</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/#public-functions","title":"Public Functions","text":"Type Name option_already_exists (const std::string &amp; option)  option_already_exists (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/#function-option_already_exists-12","title":"function option_already_exists [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::option_already_exists::option_already_exists (\n    const std::string &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/#function-option_already_exists-12_1","title":"function option_already_exists [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::option_already_exists::option_already_exists (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/","title":"Class cxxopts::exceptions::option_has_no_value","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; option_has_no_value</p> <p>Inherits the following classes: cxxopts::exceptions::exception,  cxxopts::exceptions::exception</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/#public-functions","title":"Public Functions","text":"Type Name option_has_no_value (const std::string &amp; option)  option_has_no_value (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/#function-option_has_no_value-12","title":"function option_has_no_value [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::option_has_no_value::option_has_no_value (\n    const std::string &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/#function-option_has_no_value-12_1","title":"function option_has_no_value [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::option_has_no_value::option_has_no_value (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/","title":"Class cxxopts::exceptions::option_requires_argument","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; option_requires_argument</p> <p>Inherits the following classes: cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/#public-functions","title":"Public Functions","text":"Type Name option_requires_argument (const std::string &amp; option)  option_requires_argument (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/#function-option_requires_argument-12","title":"function option_requires_argument [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::option_requires_argument::option_requires_argument (\n    const std::string &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/#function-option_requires_argument-12_1","title":"function option_requires_argument [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::option_requires_argument::option_requires_argument (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/","title":"Class cxxopts::exceptions::parsing","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; parsing</p> <p>Inherits the following classes: cxxopts::exceptions::exception,  cxxopts::exceptions::exception</p> <p>Inherited by the following classes: cxxopts::exceptions::gratuitous_argument_for_option,  cxxopts::exceptions::gratuitous_argument_for_option,  cxxopts::exceptions::incorrect_argument_type,  cxxopts::exceptions::incorrect_argument_type,  cxxopts::exceptions::invalid_option_syntax,  cxxopts::exceptions::invalid_option_syntax,  cxxopts::exceptions::missing_argument,  cxxopts::exceptions::missing_argument,  cxxopts::exceptions::no_such_option,  cxxopts::exceptions::no_such_option,  cxxopts::exceptions::option_requires_argument,  cxxopts::exceptions::option_requires_argument,  cxxopts::exceptions::requested_option_not_present,  cxxopts::exceptions::requested_option_not_present</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/#public-functions","title":"Public Functions","text":"Type Name parsing (const std::string &amp; message)  parsing (const std::string &amp; message)"},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/#function-parsing-12","title":"function parsing [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::parsing::parsing (\n    const std::string &amp; message\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/#function-parsing-12_1","title":"function parsing [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::parsing::parsing (\n    const std::string &amp; message\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/","title":"Class cxxopts::exceptions::requested_option_not_present","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; requested_option_not_present</p> <p>Inherits the following classes: cxxopts::exceptions::parsing,  cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/#public-functions","title":"Public Functions","text":"Type Name requested_option_not_present (const std::string &amp; option)  requested_option_not_present (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/#function-requested_option_not_present-12","title":"function requested_option_not_present [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::requested_option_not_present::requested_option_not_present (\n    const std::string &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/#function-requested_option_not_present-12_1","title":"function requested_option_not_present [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::requested_option_not_present::requested_option_not_present (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1specification/","title":"Class cxxopts::exceptions::specification","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; specification</p> <p>Inherits the following classes: cxxopts::exceptions::exception,  cxxopts::exceptions::exception</p> <p>Inherited by the following classes: cxxopts::exceptions::invalid_option_format,  cxxopts::exceptions::invalid_option_format,  cxxopts::exceptions::option_already_exists,  cxxopts::exceptions::option_already_exists</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1specification/#public-functions","title":"Public Functions","text":"Type Name specification (const std::string &amp; message)  specification (const std::string &amp; message)"},{"location":"api/classcxxopts_1_1exceptions_1_1specification/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1specification/#function-specification-12","title":"function specification [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::specification::specification (\n    const std::string &amp; message\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1specification/#function-specification-12_1","title":"function specification [1/2]","text":"<pre><code>inline explicit cxxopts::exceptions::specification::specification (\n    const std::string &amp; message\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/","title":"Class cxxopts::values::abstract_value","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; abstract_value</p> <p>Inherits the following classes: cxxopts::Value,  cxxopts::Value</p> <p>Inherited by the following classes: cxxopts::values::standard_value,  cxxopts::values::standard_value,  cxxopts::values::standard_value&lt; bool &gt;,  cxxopts::values::standard_value&lt; bool &gt;</p>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#public-functions","title":"Public Functions","text":"Type Name abstract_value ()  abstract_value (T * t)  abstract_value (const abstract_value &amp; rhs)  abstract_value ()  abstract_value (T * t)  abstract_value (const abstract_value &amp; rhs)  std::shared_ptr&lt; Value &gt; default_value (const std::string &amp; value) override std::shared_ptr&lt; Value &gt; default_value (const std::string &amp; value) override const T &amp; get () const const T &amp; get () const std::string get_default_value () override const std::string get_default_value () override const std::string get_implicit_value () override const std::string get_implicit_value () override const bool has_default () override const bool has_default () override const bool has_implicit () override const bool has_implicit () override const std::shared_ptr&lt; Value &gt; implicit_value (const std::string &amp; value) override std::shared_ptr&lt; Value &gt; implicit_value (const std::string &amp; value) override bool is_boolean () override const bool is_boolean () override const bool is_container () override const bool is_container () override const std::shared_ptr&lt; Value &gt; no_implicit_value () override std::shared_ptr&lt; Value &gt; no_implicit_value () override abstract_value &amp; operator= (const abstract_value &amp;) = default abstract_value &amp; operator= (const abstract_value &amp;) = default void parse (const std::string &amp; text) override const void parse () override const void parse (const std::string &amp; text) override const void parse () override const ~abstract_value () override ~abstract_value () override"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#protected-attributes","title":"Protected Attributes","text":"Type Name bool m_default   = <code>false</code> std::string m_default_value   = <code>{}</code> bool m_implicit   = <code>false</code> std::string m_implicit_value   = <code>{}</code> std::shared_ptr&lt; T &gt; m_result   = <code>{}</code> T * m_store   = <code>{}</code>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-16","title":"function abstract_value [1/6]","text":"<pre><code>inline cxxopts::values::abstract_value::abstract_value () \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-26","title":"function abstract_value [2/6]","text":"<pre><code>inline explicit cxxopts::values::abstract_value::abstract_value (\n    T * t\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-36","title":"function abstract_value [3/6]","text":"<pre><code>inline cxxopts::values::abstract_value::abstract_value (\n    const abstract_value &amp; rhs\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-16_1","title":"function abstract_value [1/6]","text":"<pre><code>inline cxxopts::values::abstract_value::abstract_value () \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-26_1","title":"function abstract_value [2/6]","text":"<pre><code>inline explicit cxxopts::values::abstract_value::abstract_value (\n    T * t\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-36_1","title":"function abstract_value [3/6]","text":"<pre><code>inline cxxopts::values::abstract_value::abstract_value (\n    const abstract_value &amp; rhs\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-default_value-12","title":"function default_value [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::default_value (\n    const std::string &amp; value\n) override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-default_value-12_1","title":"function default_value [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::default_value (\n    const std::string &amp; value\n) override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get-12","title":"function get [1/2]","text":"<pre><code>inline const T &amp; cxxopts::values::abstract_value::get () const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get-12_1","title":"function get [1/2]","text":"<pre><code>inline const T &amp; cxxopts::values::abstract_value::get () const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get_default_value-12","title":"function get_default_value [1/2]","text":"<pre><code>inline std::string cxxopts::values::abstract_value::get_default_value () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get_default_value-12_1","title":"function get_default_value [1/2]","text":"<pre><code>inline std::string cxxopts::values::abstract_value::get_default_value () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get_implicit_value-12","title":"function get_implicit_value [1/2]","text":"<pre><code>inline std::string cxxopts::values::abstract_value::get_implicit_value () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get_implicit_value-12_1","title":"function get_implicit_value [1/2]","text":"<pre><code>inline std::string cxxopts::values::abstract_value::get_implicit_value () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-has_default-12","title":"function has_default [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::has_default () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-has_default-12_1","title":"function has_default [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::has_default () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-has_implicit-12","title":"function has_implicit [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::has_implicit () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-has_implicit-12_1","title":"function has_implicit [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::has_implicit () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-implicit_value-12","title":"function implicit_value [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::implicit_value (\n    const std::string &amp; value\n) override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-implicit_value-12_1","title":"function implicit_value [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::implicit_value (\n    const std::string &amp; value\n) override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-is_boolean-12","title":"function is_boolean [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::is_boolean () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-is_boolean-12_1","title":"function is_boolean [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::is_boolean () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-is_container-12","title":"function is_container [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::is_container () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-is_container-12_1","title":"function is_container [1/2]","text":"<pre><code>inline bool cxxopts::values::abstract_value::is_container () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-no_implicit_value-12","title":"function no_implicit_value [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::no_implicit_value () override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-no_implicit_value-12_1","title":"function no_implicit_value [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::no_implicit_value () override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-operator","title":"function operator=","text":"<pre><code>abstract_value &amp; cxxopts::values::abstract_value::operator= (\n    const abstract_value &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-operator_1","title":"function operator=","text":"<pre><code>abstract_value &amp; cxxopts::values::abstract_value::operator= (\n    const abstract_value &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-parse-14","title":"function parse [1/4]","text":"<pre><code>inline void cxxopts::values::abstract_value::parse (\n    const std::string &amp; text\n) override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-parse-24","title":"function parse [2/4]","text":"<pre><code>inline void cxxopts::values::abstract_value::parse () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-parse-14_1","title":"function parse [1/4]","text":"<pre><code>inline void cxxopts::values::abstract_value::parse (\n    const std::string &amp; text\n) override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-parse-24_1","title":"function parse [2/4]","text":"<pre><code>inline void cxxopts::values::abstract_value::parse () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-12","title":"function ~abstract_value [1/2]","text":"<pre><code>cxxopts::values::abstract_value::~abstract_value () override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-12_1","title":"function ~abstract_value [1/2]","text":"<pre><code>cxxopts::values::abstract_value::~abstract_value () override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_default","title":"variable m_default","text":"<pre><code>bool cxxopts::values::abstract_value&lt; T &gt;::m_default;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_default_value","title":"variable m_default_value","text":"<pre><code>std::string cxxopts::values::abstract_value&lt; T &gt;::m_default_value;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_implicit","title":"variable m_implicit","text":"<pre><code>bool cxxopts::values::abstract_value&lt; T &gt;::m_implicit;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_implicit_value","title":"variable m_implicit_value","text":"<pre><code>std::string cxxopts::values::abstract_value&lt; T &gt;::m_implicit_value;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_result","title":"variable m_result","text":"<pre><code>std::shared_ptr&lt; T &gt; cxxopts::values::abstract_value&lt; T &gt;::m_result;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_store","title":"variable m_store","text":"<pre><code>T * cxxopts::values::abstract_value&lt; T &gt;::m_store;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value/","title":"Class cxxopts::values::standard_value","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; standard_value</p> <p>Inherits the following classes: cxxopts::values::abstract_value&lt; T &gt;,  cxxopts::values::abstract_value&lt; T &gt;</p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value/#public-functions","title":"Public Functions","text":"Type Name CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; clone () override const CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; clone () override const"},{"location":"api/classcxxopts_1_1values_1_1standard__value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1standard__value/#function-clone-12","title":"function clone [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; cxxopts::values::standard_value::clone () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value/#function-clone-12_1","title":"function clone [1/2]","text":"<pre><code>inline CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; cxxopts::values::standard_value::clone () override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/","title":"Class cxxopts::values::standard_value&lt; bool &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; standard_value&lt; bool &gt;</p> <p>Inherits the following classes: cxxopts::values::abstract_value&lt; bool &gt;,  cxxopts::values::abstract_value&lt; bool &gt;</p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#public-functions","title":"Public Functions","text":"Type Name std::shared_ptr&lt; Value &gt; clone () override const std::shared_ptr&lt; Value &gt; clone () override const standard_value ()  standard_value (bool * b)  standard_value ()  standard_value (bool * b)  ~standard_value () override ~standard_value () override"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-clone-12","title":"function clone [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::standard_value&lt; bool &gt;::clone () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-clone-12_1","title":"function clone [1/2]","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::standard_value&lt; bool &gt;::clone () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-14","title":"function standard_value [1/4]","text":"<pre><code>inline cxxopts::values::standard_value&lt; bool &gt;::standard_value () \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-24","title":"function standard_value [2/4]","text":"<pre><code>inline explicit cxxopts::values::standard_value&lt; bool &gt;::standard_value (\n    bool * b\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-14_1","title":"function standard_value [1/4]","text":"<pre><code>inline cxxopts::values::standard_value&lt; bool &gt;::standard_value () \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-24_1","title":"function standard_value [2/4]","text":"<pre><code>inline explicit cxxopts::values::standard_value&lt; bool &gt;::standard_value (\n    bool * b\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-12","title":"function ~standard_value [1/2]","text":"<pre><code>cxxopts::values::standard_value&lt; bool &gt;::~standard_value () override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-12_1","title":"function ~standard_value [1/2]","text":"<pre><code>cxxopts::values::standard_value&lt; bool &gt;::~standard_value () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/classdisplay__vk/","title":"Class display_vk","text":"<p>ClassList &gt; display_vk</p> <p>Inherits the following classes: vulkan::display_provider</p>"},{"location":"api/classdisplay__vk/#public-functions","title":"Public Functions","text":"Type Name display_vk (const phonebook *const pb)  void poll_window_events () overrideThis function polls GLFW events. See display_provider::poll_window_events(). void recreate_swapchain () overrideThis function recreates the Vulkan swapchain. See display_provider::recreate_swapchain(). void setup (std::set&lt; const char * &gt; instance_extensions, std::set&lt; const char * &gt; device_extensions) This function sets up the GLFW and Vulkan environments. See display_provider::setup(). void start (std::set&lt; const char * &gt; instance_extensions, std::set&lt; const char * &gt; device_extensions)  ~display_vk () override"},{"location":"api/classdisplay__vk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classdisplay__vk/#function-display_vk","title":"function display_vk","text":"<pre><code>inline explicit display_vk::display_vk (\n    const phonebook *const pb\n) \n</code></pre>"},{"location":"api/classdisplay__vk/#function-poll_window_events","title":"function poll_window_events","text":"<p>This function polls GLFW events. See display_provider::poll_window_events(). <pre><code>inline void display_vk::poll_window_events () override\n</code></pre></p>"},{"location":"api/classdisplay__vk/#function-recreate_swapchain","title":"function recreate_swapchain","text":"<p>This function recreates the Vulkan swapchain. See display_provider::recreate_swapchain(). <pre><code>inline void display_vk::recreate_swapchain () override\n</code></pre></p>"},{"location":"api/classdisplay__vk/#function-setup","title":"function setup","text":"<p>This function sets up the GLFW and Vulkan environments. See display_provider::setup(). <pre><code>inline void display_vk::setup (\n    std::set&lt; const char * &gt; instance_extensions,\n    std::set&lt; const char * &gt; device_extensions\n) \n</code></pre></p>"},{"location":"api/classdisplay__vk/#function-start","title":"function start","text":"<pre><code>inline void display_vk::start (\n    std::set&lt; const char * &gt; instance_extensions,\n    std::set&lt; const char * &gt; device_extensions\n) \n</code></pre>"},{"location":"api/classdisplay__vk/#function-display_vk_1","title":"function ~display_vk","text":"<pre><code>inline display_vk::~display_vk () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/vulkan_display.hpp</code></p>"},{"location":"api/classes/","title":"Class Index","text":""},{"location":"api/classes/#a","title":"a","text":"<ul> <li>abstract_value (cxxopts::values)</li> <li>accel_type</li> <li>app (ILLIXR::vulkan)</li> <li>ArguDesc (cxxopts::values::parser_tool)</li> </ul>"},{"location":"api/classes/#b","title":"b","text":"<ul> <li>binocular_cam_type (ILLIXR::data_format)</li> <li>buffer_pool (ILLIXR::vulkan)</li> <li>buffered_reader (ILLIXR::switchboard)</li> </ul>"},{"location":"api/classes/#c","title":"c","text":"<ul> <li>cam_base_type (ILLIXR::data_format)</li> <li>cam_type_zed (ILLIXR::data_format)</li> <li>camera_data (ILLIXR::data_format)</li> <li>cancellable_sleep (ILLIXR)</li> <li>capture (ILLIXR::zed_capture)</li> <li>ccd_data (ILLIXR::data_format)</li> <li>compressed_frame (ILLIXR::data_format)</li> <li>connection_signal (ILLIXR::data_format)</li> <li>convert&lt; ILLIXR::Dependency &gt; (YAML)</li> <li>coordinate_system</li> <li>csv_iterator</li> <li>csv_row</li> </ul>"},{"location":"api/classes/#d","title":"d","text":"<ul> <li>data_injection (ILLIXR)</li> <li>data_use_indicator (ILLIXR)</li> <li>debugview (ILLIXR)</li> <li>Dependency (ILLIXR)</li> <li>depth_type (ILLIXR::data_format)</li> <li>depthai (ILLIXR)</li> <li>display_backend (ILLIXR::display)</li> <li>display_params (ILLIXR)</li> <li>display_provider (ILLIXR::vulkan)</li> <li>display_vk</li> <li>DistortionCorrectionVertex (ILLIXR)</li> <li>DistortionMatrix (ILLIXR)</li> <li>dynamic_lib (ILLIXR)</li> </ul>"},{"location":"api/classes/#e","title":"e","text":"<ul> <li>event (ILLIXR)</li> <li>event (ILLIXR::switchboard)</li> <li>event_wrapper (ILLIXR::switchboard)</li> <li>exception (cxxopts::exceptions)</li> </ul>"},{"location":"api/classes/#f","title":"f","text":"<ul> <li>fast_pose_type (ILLIXR::data_format)</li> <li>fauxpose (ILLIXR)</li> <li>fauxpose_impl (ILLIXR)</li> <li>ffmpeg_vk_frame (ILLIXR::vulkan::ffmpeg_utils)</li> <li>files (ILLIXR::zed_capture)</li> </ul>"},{"location":"api/classes/#g","title":"g","text":"<ul> <li>gen_guid (ILLIXR)</li> <li>gldemo (ILLIXR)</li> <li>glfw_extended (ILLIXR::display)</li> <li>gratuitous_argument_for_option (cxxopts::exceptions)</li> <li>ground_truth_slam (ILLIXR)</li> <li>gtsam_integrator (ILLIXR)</li> </ul>"},{"location":"api/classes/#h","title":"h","text":"<ul> <li>hand_points (ILLIXR::data_format::ht)</li> <li>hash&lt; vertex &gt; (std)</li> <li>headless (ILLIXR::display)</li> <li>HelpGroupDetails (cxxopts)</li> <li>HelpOptionDetails (cxxopts)</li> <li>HMD</li> <li>hmd_info_t (HMD)</li> <li>hmd_physical_info (ILLIXR::data_format)</li> <li>hologram_input (ILLIXR::data_format)</li> <li>ht_detection (ILLIXR::data_format::ht)</li> <li>ht_frame (ILLIXR::data_format::ht)</li> </ul>"},{"location":"api/classes/#i","title":"i","text":"<ul> <li>image_handle (ILLIXR::data_format)</li> <li>imu_integrator_input (ILLIXR::data_format)</li> <li>imu_params (ILLIXR::data_format)</li> <li>imu_raw_type (ILLIXR::data_format)</li> <li>imu_type (ILLIXR::data_format)</li> <li>incorrect_argument_type (cxxopts::exceptions)</li> <li>index_params (ILLIXR)</li> <li>IntegerDesc (cxxopts::values::parser_tool)</li> <li>invalid_option_format (cxxopts::exceptions)</li> <li>invalid_option_syntax (cxxopts::exceptions)</li> <li>Iterator (cxxopts::ParseResult)</li> </ul>"},{"location":"api/classes/#k","title":"k","text":"<ul> <li>KeyValue (cxxopts)</li> </ul>"},{"location":"api/classes/#l","title":"l","text":"<ul> <li>lazy_load_image (ILLIXR)</li> <li>lighthouse (ILLIXR)</li> </ul>"},{"location":"api/classes/#m","title":"m","text":"<ul> <li>managed_thread (ILLIXR)</li> <li>mesh_coord2d_t (HMD)</li> <li>mesh_coord3d_t (HMD)</li> <li>missing_argument (cxxopts::exceptions)</li> <li>model (ILLIXR)</li> <li>model_push_constant</li> <li>monocular_cam_type (ILLIXR::data_format)</li> </ul>"},{"location":"api/classes/#n","title":"n","text":"<ul> <li>native_renderer (ILLIXR)</li> <li>network_backend (ILLIXR::network)</li> <li>network_writer (ILLIXR::switchboard)</li> <li>no_such_option (cxxopts::exceptions)</li> </ul>"},{"location":"api/classes/#o","title":"o","text":"<ul> <li>offline_cam (ILLIXR)</li> <li>offline_imu (ILLIXR)</li> <li>offload_data (ILLIXR)</li> <li>offload_reader (ILLIXR)</li> <li>offload_rendering_client (ILLIXR)</li> <li>offload_rendering_client</li> <li>offload_rendering_client_loader</li> <li>offload_rendering_server (ILLIXR)</li> <li>offload_rendering_server_loader (ILLIXR)</li> <li>offload_writer (ILLIXR)</li> <li>openni_plugin (ILLIXR)</li> <li>openwarp_vk (ILLIXR)</li> <li>openwarp_vk_plugin (ILLIXR)</li> <li>OpenWarpVertex (ILLIXR)</li> <li>Option (cxxopts)</li> <li>option_already_exists (cxxopts::exceptions)</li> <li>option_has_no_value (cxxopts::exceptions)</li> <li>option_requires_argument (cxxopts::exceptions)</li> <li>OptionAdder (cxxopts)</li> <li>OptionDetails (cxxopts)</li> <li>OptionParser (cxxopts)</li> <li>Options (cxxopts)</li> <li>OptionValue (cxxopts)</li> </ul>"},{"location":"api/classes/#p","title":"p","text":"<ul> <li>ParseResult (cxxopts)</li> <li>parsing (cxxopts::exceptions)</li> <li>passthrough_integrator (ILLIXR)</li> <li>phonebook (ILLIXR)</li> <li>pim_object</li> <li>plugin (ILLIXR)</li> <li>point (ILLIXR::data_format)</li> <li>point_with_units (ILLIXR::data_format)</li> <li>point_with_validity (ILLIXR::data_format)</li> <li>points_with_units (ILLIXR::data_format)</li> <li>pose_data (ILLIXR::data_format)</li> <li>pose_lookup_impl (ILLIXR)</li> <li>pose_lookup_plugin</li> <li>pose_prediction (ILLIXR::data_format)</li> <li>pose_prediction_impl (ILLIXR)</li> <li>pose_prediction_plugin</li> <li>pose_type (ILLIXR::data_format)</li> <li>position (ILLIXR::data_format::ht)</li> <li>print_in_destructor</li> <li>print_timer</li> <li>print_timer2</li> <li>proper_quaternion (ILLIXR::data_format)</li> </ul>"},{"location":"api/classes/#q","title":"q","text":"<ul> <li>queue (ILLIXR::vulkan)</li> <li>queue_families (ILLIXR::vulkan)</li> </ul>"},{"location":"api/classes/#r","title":"r","text":"<ul> <li>raw_ht_data (ILLIXR::data_format::ht)</li> <li>raw_imu_type (ILLIXR)</li> <li>raw_point (ILLIXR::data_format)</li> <li>raw_pose (ILLIXR::data_format)</li> <li>reader (ILLIXR::switchboard)</li> <li>realsense (ILLIXR)</li> <li>record (ILLIXR)</li> <li>record_coalescer (ILLIXR)</li> <li>record_header (ILLIXR)</li> <li>record_imu_cam (ILLIXR)</li> <li>record_logger (ILLIXR)</li> <li>record_rgb_depth (ILLIXR)</li> <li>rect (ILLIXR::data_format)</li> <li>relative_clock (ILLIXR)</li> <li>render_pass (ILLIXR::vulkan)</li> <li>rendered_frame (ILLIXR::data_format)</li> <li>rendering_params (ILLIXR)</li> <li>requested_option_not_present (cxxopts::exceptions)</li> <li>rgb_depth_type (ILLIXR::data_format)</li> <li>rk4_integrator (ILLIXR)</li> <li>runtime (ILLIXR)</li> <li>runtime_impl</li> </ul>"},{"location":"api/classes/#s","title":"s","text":"<ul> <li>sensor_types (ILLIXR)</li> <li>server_params (ILLIXR)</li> <li>server_reader (ILLIXR)</li> <li>server_writer (ILLIXR)</li> <li>service (ILLIXR::phonebook)</li> <li>should_profile_class</li> <li>signal_to_quad (ILLIXR::data_format)</li> <li>SignedCheck (cxxopts::values::detail)</li> <li>SignedCheck&lt; T, false &gt; (cxxopts::values::detail)</li> <li>SignedCheck&lt; T, true &gt; (cxxopts::values::detail)</li> <li>specification (cxxopts::exceptions)</li> <li>sqlite_record_logger (ILLIXR)</li> <li>sqlite_thread (ILLIXR)</li> <li>standard_value (cxxopts::values)</li> <li>standard_value&lt; bool &gt; (cxxopts::values)</li> <li>state_plus (ILLIXR)</li> <li>stdout_record_logger (ILLIXR)</li> <li>stoplight (ILLIXR)</li> <li>swapchain_details (ILLIXR::vulkan)</li> <li>switchboard (ILLIXR)</li> </ul>"},{"location":"api/classes/#t","title":"t","text":"<ul> <li>tcp_network_backend (ILLIXR)</li> <li>TCPSocket (ILLIXR::network)</li> <li>texture (ILLIXR)</li> <li>texture_pose (ILLIXR::data_format)</li> <li>threadloop (ILLIXR)</li> <li>time_point (ILLIXR)</li> <li>timer</li> <li>timewarp (ILLIXR::vulkan)</li> <li>timewarp_gl (ILLIXR)</li> <li>timewarp_vk (ILLIXR)</li> <li>timewarp_vk_plugin (ILLIXR)</li> <li>topic</li> <li>topic_buffer</li> <li>topic_config (ILLIXR::network)</li> <li>topic_subscription</li> <li>type_is_container (cxxopts::values)</li> <li>type_is_container&lt; std::vector&lt; T &gt; &gt; (cxxopts::values)</li> </ul>"},{"location":"api/classes/#u","title":"u","text":"<ul> <li>uniform_buffer_object</li> <li>uv_coord_t (HMD)</li> </ul>"},{"location":"api/classes/#v","title":"v","text":"<ul> <li>Value (cxxopts)</li> <li>velocity (ILLIXR::data_format::ht)</li> <li>vertex (ILLIXR)</li> <li>vertex</li> <li>video_decoder (ILLIXR)</li> <li>video_encoder (ILLIXR)</li> <li>viewer (ILLIXR)</li> <li>vk_image (ILLIXR::vulkan)</li> <li>vk_image_handle (ILLIXR::data_format)</li> <li>vkdemo (ILLIXR)</li> <li>vkdemo_plugin (ILLIXR)</li> </ul>"},{"location":"api/classes/#w","title":"w","text":"<ul> <li>WarpMatrices (ILLIXR)</li> <li>webcam (ILLIXR)</li> <li>writer (ILLIXR::switchboard)</li> </ul>"},{"location":"api/classes/#x","title":"x","text":"<ul> <li>x11_direct (ILLIXR::display)</li> <li>xlib_gl_extended_window (ILLIXR)</li> </ul>"},{"location":"api/classes/#z","title":"z","text":"<ul> <li>zed_camera (ILLIXR)</li> <li>zed_camera_thread (ILLIXR)</li> <li>zed_imu_thread (ILLIXR)</li> </ul>"},{"location":"api/classoffload__rendering__client/","title":"Class offload_rendering_client","text":"<p>ClassList &gt; offload_rendering_client</p> <p>Main client implementation for offload rendering. More...</p> <ul> <li><code>#include &lt;offload_rendering_client.hpp&gt;</code></li> </ul>"},{"location":"api/classoffload__rendering__client/#detailed-description","title":"Detailed Description","text":"<p>This class handles: * Reception of encoded frames from the server * Hardware-accelerated HEVC decoding using FFmpeg/CUDA * Color space conversion (NV12 to RGBA) * Vulkan image management and synchronization * Pose synchronization with the server</p> <p>The client supports two modes: * Realtime mode: Receives and displays frames with real-time pose updates * Comparison mode: Uses a fixed pose for image quality comparison</p> <p>Configuration is controlled through environment variables: * ILLIXR_USE_DEPTH_IMAGES: Enable depth frame reception/decoding </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/offload_rendering_client.hpp</code></p>"},{"location":"api/classoffload__rendering__client__loader/","title":"Class offload_rendering_client_loader","text":"<p>ClassList &gt; offload_rendering_client_loader</p> <p>Plugin loader for the offload rendering client. More...</p> <p>Inherits the following classes: ILLIXR::plugin,  vulkan::vk_extension_request</p>"},{"location":"api/classoffload__rendering__client__loader/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; const char * &gt; get_required_devices_extensions () overrideGet required Vulkan device extensions. std::vector&lt; const char * &gt; get_required_instance_extensions () overrideGet required Vulkan instance extensions. offload_rendering_client_loader (const std::string &amp; name, phonebook * pb) Constructor registers the client plugin. void start () overrideStart the client plugin. void stop () overrideStop the client plugin."},{"location":"api/classoffload__rendering__client__loader/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classoffload__rendering__client__loader/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classoffload__rendering__client__loader/#detailed-description","title":"Detailed Description","text":"<p>Handles plugin registration and Vulkan extension requirements. </p>"},{"location":"api/classoffload__rendering__client__loader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classoffload__rendering__client__loader/#function-get_required_devices_extensions","title":"function get_required_devices_extensions","text":"<p>Get required Vulkan device extensions. <pre><code>inline std::vector&lt; const char * &gt; offload_rendering_client_loader::get_required_devices_extensions () override\n</code></pre></p> <p>Returns:</p> <p>Vector of required extension names </p>"},{"location":"api/classoffload__rendering__client__loader/#function-get_required_instance_extensions","title":"function get_required_instance_extensions","text":"<p>Get required Vulkan instance extensions. <pre><code>inline std::vector&lt; const char * &gt; offload_rendering_client_loader::get_required_instance_extensions () override\n</code></pre></p> <p>Returns:</p> <p>Vector of required extension names </p>"},{"location":"api/classoffload__rendering__client__loader/#function-offload_rendering_client_loader","title":"function offload_rendering_client_loader","text":"<p>Constructor registers the client plugin. <pre><code>inline offload_rendering_client_loader::offload_rendering_client_loader (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Plugin name </li> <li><code>pb</code> Phonebook for component lookup </li> </ul>"},{"location":"api/classoffload__rendering__client__loader/#function-start","title":"function start","text":"<p>Start the client plugin. <pre><code>inline void offload_rendering_client_loader::start () override\n</code></pre></p>"},{"location":"api/classoffload__rendering__client__loader/#function-stop","title":"function stop","text":"<p>Stop the client plugin. <pre><code>inline void offload_rendering_client_loader::stop () override\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/plugin.cpp</code></p>"},{"location":"api/classpose__lookup__plugin/","title":"Class pose_lookup_plugin","text":"<p>ClassList &gt; pose_lookup_plugin</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classpose__lookup__plugin/#public-functions","title":"Public Functions","text":"Type Name pose_lookup_plugin (const std::string &amp; name, phonebook * pb)"},{"location":"api/classpose__lookup__plugin/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classpose__lookup__plugin/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classpose__lookup__plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classpose__lookup__plugin/#function-pose_lookup_plugin","title":"function pose_lookup_plugin","text":"<pre><code>inline pose_lookup_plugin::pose_lookup_plugin (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_lookup/service.cpp</code></p>"},{"location":"api/classpose__prediction__plugin/","title":"Class pose_prediction_plugin","text":"<p>ClassList &gt; pose_prediction_plugin</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classpose__prediction__plugin/#public-functions","title":"Public Functions","text":"Type Name pose_prediction_plugin (const std::string &amp; name, phonebook * pb)"},{"location":"api/classpose__prediction__plugin/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name, phonebook * pb)  void spd_add_file_sink (const std::string &amp; file_name, const std::string &amp; extension, const std::string &amp; log_level)  auto spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classpose__prediction__plugin/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id_ std::string name_ const phonebook * phonebook_ std::shared_ptr&lt; spdlog::logger &gt; plugin_logger_ const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classpose__prediction__plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classpose__prediction__plugin/#function-pose_prediction_plugin","title":"function pose_prediction_plugin","text":"<pre><code>inline pose_prediction_plugin::pose_prediction_plugin (\n    const std::string &amp; name,\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_prediction/service.cpp</code></p>"},{"location":"api/classprint__timer/","title":"Class print_timer","text":"<p>template &lt;typename Now_func, typename Time_point, typename Duration&gt;</p> <p>ClassList &gt; print_timer</p> <p>Like timer, but prints the output. More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classprint__timer/#public-functions","title":"Public Functions","text":"Type Name print_timer (const std::string &amp; name, const Now_func &amp; now)"},{"location":"api/classprint__timer/#detailed-description","title":"Detailed Description","text":"<p>See PRINT_CPU_TIME_FOR_THIS_BLOCK(name) </p>"},{"location":"api/classprint__timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer/#function-print_timer","title":"function print_timer","text":"<pre><code>inline print_timer::print_timer (\n    const std::string &amp; name,\n    const Now_func &amp; now\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer2/","title":"Class print_timer2","text":"<p>ClassList &gt; print_timer2</p>"},{"location":"api/classprint__timer2/#public-functions","title":"Public Functions","text":"Type Name print_timer2 (std::string name)  ~print_timer2 ()"},{"location":"api/classprint__timer2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer2/#function-print_timer2","title":"function print_timer2","text":"<pre><code>inline explicit print_timer2::print_timer2 (\n    std::string name\n) \n</code></pre>"},{"location":"api/classprint__timer2/#function-print_timer2_1","title":"function ~print_timer2","text":"<pre><code>inline print_timer2::~print_timer2 () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer_1_1print__in__destructor/","title":"Class print_timer::print_in_destructor","text":"<p>ClassList &gt; print_in_destructor</p>"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions","title":"Public Functions","text":"Type Name print_in_destructor (std::string account_name, const Duration &amp; duration)  ~print_in_destructor ()"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor","title":"function print_in_destructor","text":"<pre><code>inline print_in_destructor::print_in_destructor (\n    std::string account_name,\n    const Duration &amp; duration\n) \n</code></pre>"},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor_1","title":"function ~print_in_destructor","text":"<pre><code>inline print_in_destructor::~print_in_destructor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classruntime__impl/","title":"Class runtime_impl","text":"<p>ClassList &gt; runtime_impl</p> <p>Inherits the following classes: ILLIXR::runtime</p>"},{"location":"api/classruntime__impl/#public-functions","title":"Public Functions","text":"Type Name void _stop () override void load_plugin_factory (plugin_factory plugin_main) override void load_so (const std::vector&lt; std::string &gt; &amp; so_paths) override void load_so (const std::string_view &amp; so) override runtime_impl ()  void wait () override ~runtime_impl () override"},{"location":"api/classruntime__impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classruntime__impl/#function-_stop","title":"function _stop","text":"<pre><code>inline void runtime_impl::_stop () override\n</code></pre>"},{"location":"api/classruntime__impl/#function-load_plugin_factory","title":"function load_plugin_factory","text":"<pre><code>inline void runtime_impl::load_plugin_factory (\n    plugin_factory plugin_main\n) override\n</code></pre>"},{"location":"api/classruntime__impl/#function-load_so-12","title":"function load_so [1/2]","text":"<pre><code>inline void runtime_impl::load_so (\n    const std::vector&lt; std::string &gt; &amp; so_paths\n) override\n</code></pre>"},{"location":"api/classruntime__impl/#function-load_so-22","title":"function load_so [2/2]","text":"<pre><code>inline void runtime_impl::load_so (\n    const std::string_view &amp; so\n) override\n</code></pre>"},{"location":"api/classruntime__impl/#function-runtime_impl","title":"function runtime_impl","text":"<pre><code>inline explicit runtime_impl::runtime_impl () \n</code></pre>"},{"location":"api/classruntime__impl/#function-wait","title":"function wait","text":"<pre><code>inline void runtime_impl::wait () override\n</code></pre>"},{"location":"api/classruntime__impl/#function-runtime_impl_1","title":"function ~runtime_impl","text":"<pre><code>inline runtime_impl::~runtime_impl () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/runtime_impl.cpp</code></p>"},{"location":"api/classshould__profile__class/","title":"Class should_profile_class","text":"<p>ClassList &gt; should_profile_class</p>"},{"location":"api/classshould__profile__class/#public-functions","title":"Public Functions","text":"Type Name bool operator() () const should_profile_class ()"},{"location":"api/classshould__profile__class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classshould__profile__class/#function-operator","title":"function operator()","text":"<pre><code>inline bool should_profile_class::operator() () const\n</code></pre>"},{"location":"api/classshould__profile__class/#function-should_profile_class","title":"function should_profile_class","text":"<pre><code>inline should_profile_class::should_profile_class () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classtimer/","title":"Class timer","text":"<p>template &lt;typename Now_func, typename Time_point, typename Duration&gt;</p> <p>ClassList &gt; timer</p> <p>a timer that times until the end of the code block ([RAII]). More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classtimer/#public-functions","title":"Public Functions","text":"Type Name timer (const Now_func &amp; now, Duration &amp; duration)  ~timer ()"},{"location":"api/classtimer/#detailed-description","title":"Detailed Description","text":"<p>See [2] for how code-blocks are defined in C++.</p> <p><code>now</code> can be any type that takes no arguments and returns a subtractable type.</p> <p>Example usage:</p> <pre><code>{\n    // stuff that won't get timed.\n    std::chrono::nanoseconds ns;\n    timer&lt;decltype((thread_cpu_time))&gt; timer_obj {thread_cpu_time, ns};\n    // stuff that gets timed.\n}\n// stuff that won't get timed.\nstd::cout &lt;&lt; ns.count() &lt;&lt; std::endl;\n</code></pre>"},{"location":"api/classtimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classtimer/#function-timer","title":"function timer","text":"<pre><code>inline timer::timer (\n    const Now_func &amp; now,\n    Duration &amp; duration\n) \n</code></pre>"},{"location":"api/classtimer/#function-timer_1","title":"function ~timer","text":"<pre><code>inline timer::~timer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/coordinate_8hpp/","title":"File coordinate.hpp","text":"<p>FileList &gt; data_format &gt; coordinate.hpp</p> <p>Go to the source code of this file</p>"},{"location":"api/coordinate_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format namespace coordinates <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/coordinate.hpp</code></p>"},{"location":"api/coordinate_8hpp_source/","title":"File coordinate.hpp","text":"<p>File List &gt; data_format &gt; coordinate.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace ILLIXR::data_format::coordinates {\nenum frame {\n    IMAGE,\n    LEFT_HANDED_Y_UP,\n    LEFT_HANDED_Z_UP,\n    RIGHT_HANDED_Y_UP, // XR_REFERENCE_SPACE_TYPE_VIEW\n    RIGHT_HANDED_Z_UP,\n    RIGHT_HANDED_Z_UP_X_FWD\n};\n\nenum reference_space { VIEWER, WORLD, ROOM = WORLD };\n\n} // namespace ILLIXR::data_format::coordinates\n</code></pre>"},{"location":"api/cpu__timer_8hpp/","title":"File cpu_timer.hpp","text":"<p>FileList &gt; illixr &gt; cpu_timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/cpu__timer_8hpp/#classes","title":"Classes","text":"Type Name class print_timer &lt;typename Now_func, typename Time_point, typename Duration&gt;Like timer, but prints the output. class print_timer2 class should_profile_class class timer &lt;typename Now_func, typename Time_point, typename Duration&gt;a timer that times until the end of the code block ([RAII])."},{"location":"api/cpu__timer_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name should_profile_class should_profile"},{"location":"api/cpu__timer_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (Duration t)  std::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (Duration t)  std::thread timed_thread (const std::string &amp; account_name, Function &amp;&amp; f, Args &amp;&amp;... args) Use this in place of std::thread(...) to print times."},{"location":"api/cpu__timer_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::nanoseconds cpp_clock_get_time (clockid_t clock_id) A C++ translation of clock_gettime __ std::size_t gen_serial_no ()  std::chrono::nanoseconds thread_cpu_time () Gets the CPU time for the calling thread."},{"location":"api/cpu__timer_8hpp/#macros","title":"Macros","text":"Type Name define PRINT_CPU_TIME_FOR_THIS_BLOCK (name) <code>[**print\\_timer**](classprint__timer.md)&amp;lt;decltype((thread\\_cpu\\_time))&amp;gt; PRINT\\_CPU\\_TIME\\_FOR\\_THIS\\_BLOCK{name, thread\\_cpu\\_time};</code> define PRINT_RECORD_FOR_THIS_BLOCK (name) <code>print\\_timer2 PRINT\\_RECORD\\_FOR\\_THIS\\_BLOCK\\_timer{name};</code> define PRINT_WALL_TIME_FOR_THIS_BLOCK (name) <code>/* multi line expression */</code>"},{"location":"api/cpu__timer_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/cpu__timer_8hpp/#variable-should_profile","title":"variable should_profile","text":"<pre><code>should_profile_class should_profile;\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-count_duration","title":"function count_duration","text":"<pre><code>template&lt;typename Duration, typename Out&gt;\nstd::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-count_duration_1","title":"function count_duration","text":"<pre><code>template&lt;typename Duration&gt;\nstd::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-timed_thread","title":"function timed_thread","text":"<p>Use this in place of std::thread(...) to print times. <pre><code>template&lt;class Function, class... Args&gt;\nstd::thread timed_thread (\n    const std::string &amp; account_name,\n    Function &amp;&amp; f,\n    Args &amp;&amp;... args\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-cpp_clock_get_time","title":"function cpp_clock_get_time","text":"<p>A C++ translation of clock_gettime __ <pre><code>static inline std::chrono::nanoseconds cpp_clock_get_time (\n    clockid_t clock_id\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#function-gen_serial_no","title":"function gen_serial_no","text":"<pre><code>static std::size_t gen_serial_no () \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-thread_cpu_time","title":"function thread_cpu_time","text":"<p>Gets the CPU time for the calling thread. <pre><code>static inline std::chrono::nanoseconds thread_cpu_time () \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/cpu__timer_8hpp/#define-print_cpu_time_for_this_block","title":"define PRINT_CPU_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_CPU_TIME_FOR_THIS_BLOCK (\n    name\n) `print_timer &lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK{name, thread_cpu_time};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_record_for_this_block","title":"define PRINT_RECORD_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_RECORD_FOR_THIS_BLOCK (\n    name\n) `print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer{name};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_wall_time_for_this_block","title":"define PRINT_WALL_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_WALL_TIME_FOR_THIS_BLOCK (\n    name\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/cpu__timer_8hpp_source/","title":"File cpu_timer.hpp","text":"<p>File List &gt; illixr &gt; cpu_timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n//\n\n#include \"error_util.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;cstring&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nstatic inline std::chrono::nanoseconds cpp_clock_get_time(clockid_t clock_id) {\n    /* This ensures the compiler won't reorder this function call; Pretend like it has memory side effects. */\n    asm volatile(\"\"\n                 : /* OutputOperands */\n                 : /* InputOperands */\n                 : \"memory\" /* Clobbers */);\n\n    struct timespec time_spec{};\n\n    RAC_ERRNO_MSG(\"cpu_timer before clock_get_time\");\n\n    if (clock_gettime(clock_id, &amp;time_spec)) {\n        throw std::runtime_error{std::string{\"clock_get_time returned \"} + strerror(errno)};\n    }\n    RAC_ERRNO_MSG(\"cpu_timer after clock_get_time\");\n\n    asm volatile(\"\"\n                 : /* OutputOperands */\n                 : /* InputOperands */\n                 : \"memory\" /* Clobbers */);\n    return std::chrono::seconds{time_spec.tv_sec} + std::chrono::nanoseconds{time_spec.tv_nsec};\n}\n\nstatic inline std::chrono::nanoseconds thread_cpu_time() {\n    RAC_ERRNO_MSG(\"cpu_timer before cpp_clock_get_time\");\n    return cpp_clock_get_time(CLOCK_THREAD_CPUTIME_ID);\n}\n\ntemplate&lt;typename Now_func, typename Time_point = decltype(std::declval&lt;Now_func&gt;()()),\n         typename Duration = decltype(std::declval&lt;Time_point&gt;() - std::declval&lt;Time_point&gt;())&gt;\nclass timer {\npublic:\n    timer(const Now_func&amp; now, Duration&amp; duration)\n        : now_{now}\n        , duration_{duration} {\n        start_ = now_();\n    }\n\n    ~timer() {\n        duration_ = now_() - start_;\n    }\n\nprivate:\n    const Now_func&amp;            now_;\n    [[maybe_unused]] Duration&amp; duration_;\n    Time_point                 start_;\n};\n\ntemplate&lt;typename Duration, typename Out = decltype(std::declval&lt;Duration&gt;().count())&gt;\n[[maybe_unused]] typename std::enable_if&lt;std::is_integral&lt;Out&gt;::value, Out&gt;::type count_duration(Duration t) {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds, typename Duration::rep, typename Duration::period&gt;(t).count();\n}\n\ntemplate&lt;typename Duration&gt;\n[[maybe_unused]] [[maybe_unused]] typename std::enable_if&lt;std::is_integral&lt;Duration&gt;::value, Duration&gt;::type\ncount_duration(Duration t) {\n    return t;\n}\n\ntemplate&lt;typename Now_func, typename Time_point = decltype(std::declval&lt;Now_func&gt;()()),\n         typename Duration = decltype(std::declval&lt;Time_point&gt;() - std::declval&lt;Time_point&gt;())&gt;\nclass print_timer {\npublic:\n    print_timer(const std::string&amp; name, const Now_func&amp; now)\n        : print_in_destructor_{name, duration_}\n        , timer_{now, duration_} { }\n\nprivate:\n    class print_in_destructor {\n    public:\n        [[maybe_unused]] print_in_destructor(std::string account_name, const Duration&amp; duration)\n            : account_name_{std::move(account_name)}\n            , duration_{duration} { }\n\n        ~print_in_destructor() {\n            // std::ostringstream os;\n            // os &lt;&lt; \"cpu_timer,\" &lt;&lt; account_name_ &lt;&lt; \",\" &lt;&lt; count_duration&lt;duration&gt;(duration_) &lt;&lt; \"\\n\";\n            if (rand() % 100 == 0) {\n#ifndef NDEBUG\n                spdlog::get(\"illixr\")-&gt;info(\"cpu_timer.hpp is DEPRECATED. See logging.hpp.\");\n#endif\n            }\n        }\n\n    private:\n        const std::string                account_name_;\n        [[maybe_unused]] const Duration&amp; duration_;\n    };\n\n    // NOTE that the destructors get called in reverse order!\n    // This is important, because timer_'s destructor records the timing information\n    // Then, print_in_destructor_ prints it\n    // Then, we can destroy duration_.\n    Duration                                    duration_;\n    const print_in_destructor                   print_in_destructor_;\n    const timer&lt;Now_func, Time_point, Duration&gt; timer_;\n};\n\nstatic std::size_t gen_serial_no() {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch())\n        .count();\n}\n\nclass should_profile_class {\npublic:\n    should_profile_class() {\n        const char* ILLIXR_STDOUT_METRICS = getenv(\"ILLIXR_STDOUT_METRICS\"); // can't use switchboard interface here\n        actually_should_profile_          = ILLIXR_STDOUT_METRICS &amp;&amp; (strcmp(ILLIXR_STDOUT_METRICS, \"y\") == 0);\n    }\n\n    bool operator()() const {\n        return actually_should_profile_;\n    }\n\nprivate:\n    bool actually_should_profile_;\n};\n\nstatic should_profile_class should_profile;\n\nclass print_timer2 {\npublic:\n    explicit print_timer2(std::string name)\n        : name_{std::move(name)}\n        , serial_no_{should_profile() ? gen_serial_no() : std::size_t{0}}\n        , wall_time_start_{should_profile() ? std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n                                                  std::chrono::high_resolution_clock::now().time_since_epoch())\n                                                  .count()\n                                            : std::size_t{0}}\n        , cpu_time_start_{should_profile() ? thread_cpu_time().count() : std::size_t{0}} { }\n\n    ~print_timer2() {\n        if (should_profile()) {\n            auto cpu_time_stop  = thread_cpu_time().count();\n            auto wall_time_stop = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n                                      std::chrono::high_resolution_clock::now().time_since_epoch())\n                                      .count();\n\n            spdlog::get(\"illixr\")-&gt;info(\"[cpu_timer]  cpu_timer,{},{},{},{},{},{}\", name_, serial_no_, wall_time_start_,\n                                        wall_time_stop, cpu_time_start_, cpu_time_stop);\n        }\n    }\n\nprivate:\n    const std::string name_;\n    const std::size_t serial_no_;\n    std::size_t       wall_time_start_;\n    std::size_t       cpu_time_start_;\n};\n\n#define PRINT_CPU_TIME_FOR_THIS_BLOCK(name) \\\n    print_timer&lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK{name, thread_cpu_time};\n\n#define PRINT_WALL_TIME_FOR_THIS_BLOCK(name)                                                         \\\n    print_timer&lt;decltype((std::chrono::high_resolution_clock::now))&gt; PRINT_WALL_TIME_FOR_THIS_BLOCK{ \\\n        name, std::chrono::high_resolution_clock::now};\n\n#define PRINT_RECORD_FOR_THIS_BLOCK(name) print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer{name};\n\ntemplate&lt;class Function, class... Args&gt;\n[[maybe_unused]] std::thread timed_thread(const std::string&amp; account_name, Function&amp;&amp; f, Args&amp;&amp;... args) {\n    // Unfortunately we make copies of f and args.\n    // According to StackOverflow, this is unavoidable.\n    // See Sam Varshavchik's comment on https://stackoverflow.com/a/62380971/1078199\n    return std::thread([=] {\n        {\n            PRINT_RECORD_FOR_THIS_BLOCK(account_name)\n            std::invoke(f, args...);\n        }\n    });\n}\n</code></pre>"},{"location":"api/csv__iterator_8hpp/","title":"File csv_iterator.hpp","text":"<p>FileList &gt; illixr &gt; csv_iterator.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/csv__iterator_8hpp/#classes","title":"Classes","text":"Type Name class csv_iterator class csv_row"},{"location":"api/csv__iterator_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::istream &amp; operator&gt;&gt; (std::istream &amp; str, csv_row &amp; data)"},{"location":"api/csv__iterator_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/csv__iterator_8hpp/#function-operator","title":"function operator&gt;&gt;","text":"<pre><code>std::istream &amp; operator&gt;&gt; (\n    std::istream &amp; str,\n    csv_row &amp; data\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/csv_iterator.hpp</code></p>"},{"location":"api/csv__iterator_8hpp_source/","title":"File csv_iterator.hpp","text":"<p>File List &gt; illixr &gt; csv_iterator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iterator&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nclass csv_row {\npublic:\n    std::string const&amp; operator[](std::size_t index) const {\n        return data_[index];\n    }\n\n    [[nodiscard]] std::size_t size() const {\n        return data_.size();\n    }\n\n    void read_next_row(std::istream&amp; str) {\n        std::string line;\n        std::getline(str, line);\n\n        line = line.substr(0, line.find_last_not_of(\"\\r\\n\\t \\v\") + 1);\n\n        std::stringstream line_stream(line);\n        std::string       cell;\n\n        data_.clear();\n        while (std::getline(line_stream, cell, ',')) {\n            data_.push_back(cell);\n        }\n        // This checks for a trailing comma with no data after it.\n        if (!line_stream &amp;&amp; cell.empty()) {\n            // If there was a trailing comma then add an empty element.\n            data_.emplace_back(\"\");\n        }\n    }\n\nprivate:\n    std::vector&lt;std::string&gt; data_;\n};\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; str, csv_row&amp; data) {\n    data.read_next_row(str);\n    return str;\n}\n\nclass csv_iterator {\npublic:\n    typedef std::input_iterator_tag iterator_category;\n    typedef csv_row                 value_type;\n    typedef std::size_t             difference_type;\n    typedef csv_row*                pointer;\n    typedef csv_row&amp;                reference;\n\n    explicit csv_iterator(std::istream&amp; str, std::size_t skip = 0)\n        : stream_(str.good() ? &amp;str : nullptr) {\n        ++(*this);\n        (*this) += skip;\n    }\n\n    csv_iterator()\n        : stream_(nullptr) { }\n\n    csv_iterator&amp; operator+=(std::size_t skip) {\n        for (size_t i = 0; i &lt; skip; ++i) {\n            ++(*this);\n        }\n        return *this;\n    }\n\n    // Pre Increment\n    csv_iterator&amp; operator++() {\n        if (stream_) {\n            if (!((*stream_) &gt;&gt; row_)) {\n                stream_ = nullptr;\n            }\n        }\n        return *this;\n    }\n\n    // Post increment\n    csv_iterator operator++(int) {\n        csv_iterator tmp(*this);\n        ++(*this);\n        return tmp;\n    }\n\n    csv_row const&amp; operator*() const {\n        return row_;\n    }\n\n    csv_row const* operator-&gt;() const {\n        return &amp;row_;\n    }\n\n    bool operator==(csv_iterator const&amp; rhs) {\n        return ((this == &amp;rhs) || ((this-&gt;stream_ == nullptr) &amp;&amp; (rhs.stream_ == nullptr)));\n    }\n\n    bool operator!=(csv_iterator const&amp; rhs) {\n        return !((*this) == rhs);\n    }\n\n    const std::string&amp; operator[](std::size_t idx) {\n        return row_[idx];\n    }\n\nprivate:\n    std::istream* stream_;\n    csv_row       row_;\n};\n</code></pre>"},{"location":"api/data__loading_8hpp/","title":"File data_loading.hpp","text":"<p>FileList &gt; illixr &gt; data_loading.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/csv_iterator.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/data__loading_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::map&lt; ullong, T &gt; load_data (const std::string &amp; spath, const std::string &amp; plugin_name, std::map&lt; ullong, T &gt;(*)(std::ifstream &amp;, const std::string &amp;) func, const std::shared_ptr&lt; switchboard &gt; &amp; sb)"},{"location":"api/data__loading_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/data__loading_8hpp/#function-load_data","title":"function load_data","text":"<pre><code>template&lt;typename T&gt;\nstatic std::map&lt; ullong, T &gt; load_data (\n    const std::string &amp; spath,\n    const std::string &amp; plugin_name,\n    std::map&lt; ullong, T &gt;(*)(std::ifstream &amp;, const std::string &amp;) func,\n    const std::shared_ptr&lt; switchboard &gt; &amp; sb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_loading.hpp</code></p>"},{"location":"api/data__loading_8hpp_source/","title":"File data_loading.hpp","text":"<p>File List &gt; illixr &gt; data_loading.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/csv_iterator.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n\nusing namespace ILLIXR;\n\ntemplate&lt;typename T&gt;\nstatic std::map&lt;ullong, T&gt; load_data(const std::string&amp; spath, const std::string&amp; plugin_name,\n                                     std::map&lt;ullong, T&gt; (*func)(std::ifstream&amp;, const std::string&amp;),\n                                     const std::shared_ptr&lt;switchboard&gt;&amp; sb) {\n    const char* illixr_data_c_str = sb-&gt;get_env_char(\"ILLIXR_DATA\");\n    if (!illixr_data_c_str) {\n        ILLIXR::abort(\"Please define ILLIXR_DATA\");\n    }\n    const std::string subpath     = \"/\" + spath + \"/data.csv\";\n    std::string       illixr_data = std::string{illixr_data_c_str};\n\n    std::ifstream gt_file{illixr_data + subpath};\n\n    if (!gt_file.good()) {\n        spdlog::get(\"illixr\")-&gt;error(\"[{0}] ${ILLIXR_DATA}{1} ({2}{1}) is not a good path\", plugin_name, subpath, illixr_data);\n        ILLIXR::abort();\n    }\n\n    return func(gt_file, illixr_data + subpath);\n}\n</code></pre>"},{"location":"api/dir_056ec8f0377ddc4293192cbc6b19c99c/","title":"Dir /home/friedel/devel/ILLIXR/services","text":"<p>FileList &gt; services</p>"},{"location":"api/dir_056ec8f0377ddc4293192cbc6b19c99c/#directories","title":"Directories","text":"Type Name dir fauxpose dir pose_lookup dir pose_prediction dir vkdemo <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/</code></p>"},{"location":"api/dir_0879f110ae87fbd48213ca4f072ab8de/","title":"Dir /home/friedel/devel/ILLIXR/plugins/zed/capture","text":"<p>FileList &gt; capture</p>"},{"location":"api/dir_0879f110ae87fbd48213ca4f072ab8de/#files","title":"Files","text":"Type Name file capture.cpp file capture.hpp file capture_main.cpp file cxxopts.hpp file files.cpp file files.hpp file zed_opencv.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/</code></p>"},{"location":"api/dir_142c9d3fc91f2fe3dca57bb893ea2245/","title":"Dir /home/friedel/devel/ILLIXR/plugins/realsense","text":"<p>FileList &gt; plugins &gt; realsense</p>"},{"location":"api/dir_142c9d3fc91f2fe3dca57bb893ea2245/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/realsense/</code></p>"},{"location":"api/dir_159e415a4a2e89a8f206009a97cbda42/","title":"Dir /home/friedel/devel/ILLIXR/plugins/openvins","text":"<p>FileList &gt; openvins</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openvins/</code></p>"},{"location":"api/dir_185d96d9710cbe92f149131d80104384/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offline_imu","text":"<p>FileList &gt; offline_imu</p>"},{"location":"api/dir_185d96d9710cbe92f149131d80104384/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_imu/</code></p>"},{"location":"api/dir_1d3c6769330bfebb870e950d8a9389ac/","title":"Dir /home/friedel/devel/ILLIXR/include/illixr/data_format","text":"<p>FileList &gt; data_format</p>"},{"location":"api/dir_1d3c6769330bfebb870e950d8a9389ac/#files","title":"Files","text":"Type Name file camera_data.hpp file coordinate.hpp file frame.hpp file hand_tracking_data.hpp file imu.hpp file misc.hpp file opencv_data_types.hpp file point.hpp file pose.hpp file pose_prediction.hpp file proper_quaternion.hpp file serializable_data.hpp file shape.hpp file template.hpp file unit.hpp file zed_cam.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/</code></p>"},{"location":"api/dir_219ef9b2c04ff5c35436b6168a2a0e71/","title":"Dir /home/friedel/devel/ILLIXR/plugins/gtsam_integrator","text":"<p>FileList &gt; gtsam_integrator</p>"},{"location":"api/dir_219ef9b2c04ff5c35436b6168a2a0e71/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gtsam_integrator/</code></p>"},{"location":"api/dir_25685f9c6d837c57f295dee081495707/","title":"Dir /home/friedel/devel/ILLIXR/src/display","text":"<p>FileList &gt; display</p>"},{"location":"api/dir_25685f9c6d837c57f295dee081495707/#files","title":"Files","text":"Type Name file display_backend.hpp file glfw_extended.cpp file glfw_extended.hpp file headless.cpp file headless.hpp file x11_direct.cpp file x11_direct.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/</code></p>"},{"location":"api/dir_2ce072faf9af05bd4709fec4993cd0af/","title":"Dir /home/friedel/devel/ILLIXR/plugins/openwarp_vk","text":"<p>FileList &gt; openwarp_vk</p>"},{"location":"api/dir_2ce072faf9af05bd4709fec4993cd0af/#files","title":"Files","text":"Type Name file openwarp_vk.cpp file openwarp_vk.hpp file plugin.cpp file plugin.hpp"},{"location":"api/dir_2ce072faf9af05bd4709fec4993cd0af/#directories","title":"Directories","text":"Type Name dir monado <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/</code></p>"},{"location":"api/dir_340cedf6b2ebb3973b960c948e083e2b/","title":"Dir /home/friedel/devel/ILLIXR/plugins/rk4_integrator","text":"<p>FileList &gt; plugins &gt; rk4_integrator</p>"},{"location":"api/dir_340cedf6b2ebb3973b960c948e083e2b/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/rk4_integrator/</code></p>"},{"location":"api/dir_351b403857ee8af48e1dafdd95331fac/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_vio","text":"<p>FileList &gt; offload_vio</p>"},{"location":"api/dir_351b403857ee8af48e1dafdd95331fac/#directories","title":"Directories","text":"Type Name dir device_rx dir device_tx dir server_rx dir server_tx <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/</code></p>"},{"location":"api/dir_3635733b822c1932c068875705e92bad/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx","text":"<p>FileList &gt; offload_vio &gt; server_rx</p>"},{"location":"api/dir_3635733b822c1932c068875705e92bad/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp file video_decoder.cpp file video_decoder.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/</code></p>"},{"location":"api/dir_36dafdab3309b6908e2d08a85cb00753/","title":"Dir /home/friedel/devel/ILLIXR/plugins/record_rgb_depth","text":"<p>FileList &gt; plugins &gt; record_rgb_depth</p>"},{"location":"api/dir_36dafdab3309b6908e2d08a85cb00753/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_rgb_depth/</code></p>"},{"location":"api/dir_3700b388a99a8eff75ef1317140c4d4b/","title":"Dir /home/friedel/devel/ILLIXR/plugins/orb_slam3","text":"<p>FileList &gt; orb_slam3</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/orb_slam3/</code></p>"},{"location":"api/dir_38c8d24aef3972a7f87b834274e76e31/","title":"Dir /home/friedel/devel/ILLIXR/plugins","text":"<p>FileList &gt; plugins</p>"},{"location":"api/dir_38c8d24aef3972a7f87b834274e76e31/#directories","title":"Directories","text":"Type Name dir audio_pipeline dir debugview dir depthai dir gldemo dir ground_truth_slam dir gtsam_integrator dir hand_tracking dir hand_tracking_gpu dir lighthouse dir native_renderer dir offline_cam dir offline_imu dir offload_data dir offload_rendering_client dir offload_rendering_server dir offload_vio dir openni dir openvins dir openwarp_vk dir orb_slam3 dir passthrough_integrator dir realsense dir record_imu_cam dir record_rgb_depth dir rk4_integrator dir tcp_network_backend dir timewarp_gl dir timewarp_vk dir webcam dir zed <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/</code></p>"},{"location":"api/dir_3a475dc3b4300578cec4e2c5cbd36975/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_rendering_client","text":"<p>FileList &gt; offload_rendering_client</p>"},{"location":"api/dir_3a475dc3b4300578cec4e2c5cbd36975/#files","title":"Files","text":"Type Name file offload_rendering_client.cpp file offload_rendering_client.hpp file plugin.cpp Offload Rendering Client Plugin Implementation. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/</code></p>"},{"location":"api/dir_513c1e104d4fed82bb3eedf56c3611bf/","title":"Dir /home/friedel/devel/ILLIXR/services/pose_lookup","text":"<p>FileList &gt; pose_lookup</p>"},{"location":"api/dir_513c1e104d4fed82bb3eedf56c3611bf/#files","title":"Files","text":"Type Name file service.cpp file service.hpp file utils.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_lookup/</code></p>"},{"location":"api/dir_5436d1ada92960bf250a6b19556e4201/","title":"Dir /home/friedel/devel/ILLIXR/services/pose_prediction","text":"<p>FileList &gt; pose_prediction</p>"},{"location":"api/dir_5436d1ada92960bf250a6b19556e4201/#files","title":"Files","text":"Type Name file service.cpp file service.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_prediction/</code></p>"},{"location":"api/dir_5cc4dcc40f5c42212fd4ae0413e70579/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_rendering_server","text":"<p>FileList &gt; offload_rendering_server</p>"},{"location":"api/dir_5cc4dcc40f5c42212fd4ae0413e70579/#files","title":"Files","text":"Type Name file offload_rendering_server.cpp file offload_rendering_server.hpp file plugin.cpp Offload Rendering Server Plugin Implementation. file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/</code></p>"},{"location":"api/dir_5d7a268ec4e75c743404674684e06130/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_vio/device_rx","text":"<p>FileList &gt; device_rx</p>"},{"location":"api/dir_5d7a268ec4e75c743404674684e06130/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_rx/</code></p>"},{"location":"api/dir_5dd632787ca5ba67f14d44d62f2b37af/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx","text":"<p>FileList &gt; device_tx</p>"},{"location":"api/dir_5dd632787ca5ba67f14d44d62f2b37af/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp file video_encoder.cpp file video_encoder.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/</code></p>"},{"location":"api/dir_5e880f41202f0d57f23d4006324c7091/","title":"Dir /home/friedel/devel/ILLIXR/plugins/audio_pipeline","text":"<p>FileList &gt; audio_pipeline</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/audio_pipeline/</code></p>"},{"location":"api/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir /home/friedel/devel/ILLIXR/src","text":"<p>FileList &gt; src</p>"},{"location":"api/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file cxxopts.hpp file illixr.hpp file main.cpp file plugin.cpp file runtime_impl.cpp file sqlite_record_logger.hpp file stdout_record_logger.hpp file vulkan_display.hpp"},{"location":"api/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir display <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/</code></p>"},{"location":"api/dir_6dbeb103bf1f1937458fdcffc34440e3/","title":"Dir /home/friedel/devel/ILLIXR/plugins/passthrough_integrator","text":"<p>FileList &gt; passthrough_integrator</p>"},{"location":"api/dir_6dbeb103bf1f1937458fdcffc34440e3/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/passthrough_integrator/</code></p>"},{"location":"api/dir_78d6dc98d657d6890939866131be596c/","title":"Dir /home/friedel/devel/ILLIXR/plugins/lighthouse","text":"<p>FileList &gt; lighthouse</p>"},{"location":"api/dir_78d6dc98d657d6890939866131be596c/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/lighthouse/</code></p>"},{"location":"api/dir_8441c11760b8420028156f50c2add560/","title":"Dir /home/friedel/devel/ILLIXR/plugins/depthai","text":"<p>FileList &gt; depthai</p>"},{"location":"api/dir_8441c11760b8420028156f50c2add560/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/depthai/</code></p>"},{"location":"api/dir_849887777c8d994370efe5983d8c78f5/","title":"Dir /home/friedel/devel/ILLIXR/plugins/zed","text":"<p>FileList &gt; plugins &gt; zed</p>"},{"location":"api/dir_849887777c8d994370efe5983d8c78f5/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp file zed_camera.cpp file zed_camera.hpp file zed_camera_thread.cpp file zed_camera_thread.hpp"},{"location":"api/dir_849887777c8d994370efe5983d8c78f5/#directories","title":"Directories","text":"Type Name dir capture dir data_injection <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/</code></p>"},{"location":"api/dir_88e523851a209a1f3ded98647e1bab12/","title":"Dir /home/friedel/devel/ILLIXR/plugins/zed/data_injection","text":"<p>FileList &gt; data_injection</p>"},{"location":"api/dir_88e523851a209a1f3ded98647e1bab12/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/data_injection/</code></p>"},{"location":"api/dir_896702a6becdb992133bce403d5f6094/","title":"Dir /home/friedel/devel/ILLIXR/include/illixr","text":"<p>FileList &gt; illixr</p>"},{"location":"api/dir_896702a6becdb992133bce403d5f6094/#files","title":"Files","text":"Type Name file cpu_timer.hpp file csv_iterator.hpp file data_loading.hpp file dynamic_lib.hpp file error_util.hpp file extended_window.hpp file global_module_defs.hpp file hmd.hpp file managed_thread.hpp file math_util.hpp file phonebook.hpp file plugin.hpp file record_logger.hpp file relative_clock.hpp file runge-kutta.hpp file runtime.hpp file shader_util.hpp file stoplight.hpp file switchboard.hpp file threadloop.hpp"},{"location":"api/dir_896702a6becdb992133bce403d5f6094/#directories","title":"Directories","text":"Type Name dir data_format dir network dir vk <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/</code></p>"},{"location":"api/dir_8b1e6505b76594a45c532cfee88c217b/","title":"Dir /home/friedel/devel/ILLIXR/plugins/hand_tracking","text":"<p>FileList &gt; hand_tracking</p>"},{"location":"api/dir_8b1e6505b76594a45c532cfee88c217b/#directories","title":"Directories","text":"Type Name dir viewer <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking/</code></p>"},{"location":"api/dir_8c860899388e805501dff1578cdbc152/","title":"Dir /home/friedel/devel/ILLIXR/plugins/timewarp_vk","text":"<p>FileList &gt; plugins &gt; timewarp_vk</p>"},{"location":"api/dir_8c860899388e805501dff1578cdbc152/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp file timewarp_vk.cpp file timewarp_vk.hpp"},{"location":"api/dir_8c860899388e805501dff1578cdbc152/#directories","title":"Directories","text":"Type Name dir monado <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/</code></p>"},{"location":"api/dir_903e8ecac4b4b370bf5f530960cf6962/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_vio/server_tx","text":"<p>FileList &gt; offload_vio &gt; server_tx</p>"},{"location":"api/dir_903e8ecac4b4b370bf5f530960cf6962/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_tx/</code></p>"},{"location":"api/dir_943771b1ac3f22b90d88ddfd145baa27/","title":"Dir /home/friedel/devel/ILLIXR/include/illixr/vk","text":"<p>FileList &gt; illixr &gt; vk</p>"},{"location":"api/dir_943771b1ac3f22b90d88ddfd145baa27/#files","title":"Files","text":"Type Name file display_provider.hpp file ffmpeg_utils.hpp file render_pass.hpp file vulkan_objects.hpp file vulkan_utils.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/</code></p>"},{"location":"api/dir_95e9b2328c86d5546b3904253917b4ea/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offline_cam","text":"<p>FileList &gt; offline_cam</p>"},{"location":"api/dir_95e9b2328c86d5546b3904253917b4ea/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_cam/</code></p>"},{"location":"api/dir_9629f7b573b56ae0116f56c1f3126994/","title":"Dir /home/friedel/devel/ILLIXR/services/fauxpose","text":"<p>FileList &gt; fauxpose</p>"},{"location":"api/dir_9629f7b573b56ae0116f56c1f3126994/#files","title":"Files","text":"Type Name file service.cpp file service.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/fauxpose/</code></p>"},{"location":"api/dir_a33df5ef31da412ae41caea27ce17a63/","title":"Dir /home/friedel/devel/ILLIXR/plugins/ground_truth_slam","text":"<p>FileList &gt; ground_truth_slam</p>"},{"location":"api/dir_a33df5ef31da412ae41caea27ce17a63/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/ground_truth_slam/</code></p>"},{"location":"api/dir_aa3885580ba75bbb732b131cb0ba4bac/","title":"Dir /home/friedel/devel/ILLIXR/plugins/offload_data","text":"<p>FileList &gt; offload_data</p>"},{"location":"api/dir_aa3885580ba75bbb732b131cb0ba4bac/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_data/</code></p>"},{"location":"api/dir_aa964e48df094658c581f643913bf673/","title":"Dir /home/friedel/devel/ILLIXR/plugins/hand_tracking/viewer","text":"<p>FileList &gt; hand_tracking &gt; viewer</p>"},{"location":"api/dir_aa964e48df094658c581f643913bf673/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking/viewer/</code></p>"},{"location":"api/dir_ac9ed797635fd2e5728bf6c5d114dd73/","title":"Dir /home/friedel/devel/ILLIXR/plugins/webcam","text":"<p>FileList &gt; plugins &gt; webcam</p>"},{"location":"api/dir_ac9ed797635fd2e5728bf6c5d114dd73/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/webcam/</code></p>"},{"location":"api/dir_ae0683f6fe722d9263c55e30effafb44/","title":"Dir /home/friedel/devel/ILLIXR/plugins/record_imu_cam","text":"<p>FileList &gt; plugins &gt; record_imu_cam</p>"},{"location":"api/dir_ae0683f6fe722d9263c55e30effafb44/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_imu_cam/</code></p>"},{"location":"api/dir_afea582717a47693732909439b44aeb5/","title":"Dir /home/friedel/devel/ILLIXR/services/vkdemo","text":"<p>FileList &gt; services &gt; vkdemo</p>"},{"location":"api/dir_afea582717a47693732909439b44aeb5/#files","title":"Files","text":"Type Name file service.cpp file service.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/</code></p>"},{"location":"api/dir_b1a328157d3d3501f841ed2539acb908/","title":"Dir /home/friedel/devel/ILLIXR/plugins/hand_tracking_gpu","text":"<p>FileList &gt; hand_tracking_gpu</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking_gpu/</code></p>"},{"location":"api/dir_b38785036a8908c9ed95832a7c0fb0da/","title":"Dir /home/friedel/devel/ILLIXR/plugins/native_renderer","text":"<p>FileList &gt; native_renderer</p>"},{"location":"api/dir_b38785036a8908c9ed95832a7c0fb0da/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/native_renderer/</code></p>"},{"location":"api/dir_b3ac6694119cf50b8ca895faceb83994/","title":"Dir /home/friedel/devel/ILLIXR/plugins/timewarp_vk/monado","text":"<p>FileList &gt; monado</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/monado/</code></p>"},{"location":"api/dir_b7252df04d22460d0f82530d539e0e9b/","title":"Dir /home/friedel/devel/ILLIXR/plugins/timewarp_gl/monado","text":"<p>FileList &gt; monado</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/monado/</code></p>"},{"location":"api/dir_bd542aaff717ffbfce7f626e07d8e4bb/","title":"Dir /home/friedel/devel/ILLIXR/plugins/openwarp_vk/monado","text":"<p>FileList &gt; monado</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/monado/</code></p>"},{"location":"api/dir_c580989b7f1f02a5cd21e8d9e22322c0/","title":"Dir /home/friedel/devel/ILLIXR/plugins/tcp_network_backend","text":"<p>FileList &gt; plugins &gt; tcp_network_backend</p>"},{"location":"api/dir_c580989b7f1f02a5cd21e8d9e22322c0/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/tcp_network_backend/</code></p>"},{"location":"api/dir_cbdb8362360e11eafe2fa3bc74cf0ffd/","title":"Dir /home/friedel/devel/ILLIXR/utils","text":"<p>FileList &gt; utils</p>"},{"location":"api/dir_cbdb8362360e11eafe2fa3bc74cf0ffd/#files","title":"Files","text":"Type Name file hmd.cpp file hmd.hpp file serializable_data.cpp file serializable_data.hpp file vulkan_utils.cpp file vulkan_utils.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/</code></p>"},{"location":"api/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir /home/friedel/devel/ILLIXR/include","text":"<p>FileList &gt; include</p>"},{"location":"api/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Type Name dir illixr <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/</code></p>"},{"location":"api/dir_e270ea8f557e3efbb4ed59ecd6b01a9d/","title":"Dir /home/friedel/devel/ILLIXR/plugins/openni","text":"<p>FileList &gt; openni</p>"},{"location":"api/dir_e270ea8f557e3efbb4ed59ecd6b01a9d/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openni/</code></p>"},{"location":"api/dir_e2e3cbdd283de30701e2b2b75d0aa9cd/","title":"Dir /home/friedel/devel/ILLIXR/plugins/gldemo","text":"<p>FileList &gt; gldemo</p>"},{"location":"api/dir_e2e3cbdd283de30701e2b2b75d0aa9cd/#files","title":"Files","text":"Type Name file parser.py file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/</code></p>"},{"location":"api/dir_e320451700ad2582419ef6ff302a5fd4/","title":"Dir /home/friedel/devel/ILLIXR/plugins/timewarp_gl","text":"<p>FileList &gt; plugins &gt; timewarp_gl</p>"},{"location":"api/dir_e320451700ad2582419ef6ff302a5fd4/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp"},{"location":"api/dir_e320451700ad2582419ef6ff302a5fd4/#directories","title":"Directories","text":"Type Name dir monado <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/</code></p>"},{"location":"api/dir_ee6e372a240689cc4629d1f07746dd9b/","title":"Dir /home/friedel/devel/ILLIXR/include/illixr/network","text":"<p>FileList &gt; illixr &gt; network</p>"},{"location":"api/dir_ee6e372a240689cc4629d1f07746dd9b/#files","title":"Files","text":"Type Name file net_config.hpp file network_backend.hpp file tcpsocket.hpp file topic_config.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/</code></p>"},{"location":"api/dir_f21bc82bd39e1060bdeb29161c2be605/","title":"Dir /home/friedel/devel/ILLIXR/plugins/debugview","text":"<p>FileList &gt; debugview</p>"},{"location":"api/dir_f21bc82bd39e1060bdeb29161c2be605/#files","title":"Files","text":"Type Name file plugin.cpp file plugin.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/debugview/</code></p>"},{"location":"api/display__backend_8hpp/","title":"File display_backend.hpp","text":"<p>FileList &gt; display &gt; display_backend.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> </ul>"},{"location":"api/display__backend_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace display"},{"location":"api/display__backend_8hpp/#classes","title":"Classes","text":"Type Name class display_backend <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/display_backend.hpp</code></p>"},{"location":"api/display__backend_8hpp_source/","title":"File display_backend.hpp","text":"<p>File List &gt; display &gt; display_backend.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/vk/display_provider.hpp\"\n\nnamespace ILLIXR::display {\n\nclass display_backend {\npublic:\n    enum display_backend_type { GLFW, X11_DIRECT, HEADLESS };\n\n    virtual void         setup_display(const std::shared_ptr&lt;switchboard&gt; sb, VkInstance vk_instance,\n                                       VkPhysicalDevice vk_physical_device) = 0;\n    virtual VkSurfaceKHR create_surface()                                   = 0;\n    virtual void         cleanup()                                          = 0;\n\n    virtual std::set&lt;const char*&gt; get_required_instance_extensions() = 0;\n    virtual std::set&lt;const char*&gt; get_required_device_extensions()   = 0;\n\n    virtual display_backend_type get_type() = 0;\n\nprotected:\n    VkInstance vk_instance_;\n};\n\n} // namespace ILLIXR::display\n</code></pre>"},{"location":"api/display__provider_8hpp/","title":"File display_provider.hpp","text":"<p>FileList &gt; illixr &gt; vk &gt; display_provider.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"vulkan_utils.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"api/display__provider_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace vulkan"},{"location":"api/display__provider_8hpp/#classes","title":"Classes","text":"Type Name class display_provider A display sink is a service that can display the rendered images to the screen. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/display_provider.hpp</code></p>"},{"location":"api/display__provider_8hpp_source/","title":"File display_provider.hpp","text":"<p>File List &gt; illixr &gt; vk &gt; display_provider.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"vulkan_utils.hpp\"\n\n#include &lt;cstdint&gt;\n\nusing namespace ILLIXR;\n\nnamespace ILLIXR::vulkan { \nclass display_provider : public phonebook::service {\npublic:\n    ~display_provider() override = default;\n\n    // required by timewarp_vk as a service\n\n    VkInstance                                   vk_instance_        = VK_NULL_HANDLE;\n    VkPhysicalDevice                             vk_physical_device_ = VK_NULL_HANDLE;\n    VkDevice                                     vk_device_          = VK_NULL_HANDLE;\n    std::unordered_map&lt;queue::queue_type, queue&gt; queues_;\n\n    virtual void poll_window_events() { };\n\n    // addtionally required for native display\n\n    virtual void recreate_swapchain() { };\n\n    VkSurfaceKHR             vk_surface_   = VK_NULL_HANDLE;\n    VkSwapchainKHR           vk_swapchain_ = VK_NULL_HANDLE;\n    VkSurfaceFormatKHR       swapchain_image_format_;\n    std::vector&lt;VkImage&gt;     swapchain_images_;\n    std::vector&lt;VkImageView&gt; swapchain_image_views_;\n    VkExtent2D               swapchain_extent_ = {display_params::width_pixels, display_params::height_pixels};\n\n    // optional\n    VmaAllocator vma_allocator_;\n\n    // for ffmpeg\n    VkPhysicalDeviceFeatures2 features_;\n    std::vector&lt;const char*&gt;  enabled_instance_extensions_;\n    std::vector&lt;const char*&gt;  enabled_device_extensions_;\n};\n} // namespace ILLIXR::vulkan\n</code></pre>"},{"location":"api/dynamic__lib_8hpp/","title":"File dynamic_lib.hpp","text":"<p>FileList &gt; illixr &gt; dynamic_lib.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include &lt;dlfcn.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/dynamic__lib_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/dynamic__lib_8hpp/#classes","title":"Classes","text":"Type Name class dynamic_lib <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/dynamic_lib.hpp</code></p>"},{"location":"api/dynamic__lib_8hpp_source/","title":"File dynamic_lib.hpp","text":"<p>File List &gt; illixr &gt; dynamic_lib.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"error_util.hpp\"\n\n#include &lt;dlfcn.h&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n\nusing void_ptr = std::unique_ptr&lt;void, std::function&lt;void(void*)&gt;&gt;;\n\n/*\nUsage:\n    void* thing;\n    void_ptr wrapped_thing = {thing, [](void* thing) {\n        // destructor goes here.\n    }}\n    // wrapped_thing.get() returns underlying thing.\n */\n\nclass dynamic_lib {\npublic:\n    dynamic_lib(dynamic_lib&amp;&amp; other) noexcept\n        : handle_{std::move(other.handle_)}\n        , library_path_{std::move(other.library_path_)} { }\n\n    dynamic_lib&amp; operator=(dynamic_lib&amp;&amp; other) noexcept {\n        if (this != &amp;other) {\n            handle_       = std::move(other.handle_);\n            library_path_ = std::move(other.library_path_);\n        }\n        return *this;\n    }\n\n    ~dynamic_lib() {\n#ifndef NDEBUG\n        if (!library_path_.empty()) {\n            spdlog::get(\"illixr\")-&gt;debug(\"[dynamic_lib] Destructing library : {}\", library_path_);\n        }\n#endif \n    }\n\n    static dynamic_lib create(const std::string&amp; path) {\n        return dynamic_lib::create(std::string_view{path});\n    }\n\n    static dynamic_lib create(const std::string_view&amp; path) {\n        char* error;\n\n        // dlopen man page says that it can set errno sp\n        RAC_ERRNO_MSG(\"dynamic_lib before dlopen\");\n        void* handle = dlopen(path.data(), RTLD_LAZY | RTLD_LOCAL);\n        RAC_ERRNO_MSG(\"dynamic_lib after dlopen\");\n\n        if ((error = dlerror()) || !handle) {\n            spdlog::get(\"illixr\")-&gt;error(error);\n            throw std::runtime_error{\"dlopen(\\\"\" + std::string{path} +\n                                     \"\\\"): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n        }\n\n        return dynamic_lib{\n            void_ptr{handle,\n                     [](void* handle) {\n                         RAC_ERRNO();\n\n                         char* error;\n                         int   ret = dlclose(handle);\n                         if ((error = dlerror()) || ret) {\n                             const std::string msg_error{\"dlclose(): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n                             spdlog::get(\"illixr\")-&gt;error(\"[dynamic_lib] {}\", msg_error);\n                             throw std::runtime_error{msg_error};\n                         }\n                     }},\n            std::string{path} \n        };\n    }\n\n    const void* operator[](const std::string&amp; symbol_name) const {\n        RAC_ERRNO_MSG(\"dynamic_lib at start of operator[]\");\n\n        char* error;\n        void* symbol = dlsym(handle_.get(), symbol_name.c_str());\n        if ((error = dlerror())) {\n            throw std::runtime_error{\"dlsym(\\\"\" + symbol_name + \"\\\"): \" + std::string{error}};\n        }\n        return symbol;\n    }\n\n    template&lt;typename T&gt;\n    T get(const std::string&amp; symbol_name) const {\n        const void* obj = (*this)[symbol_name];\n        // return reinterpret_cast&lt;const T&gt;((*this)[symbol_name]);\n        return (const T) obj;\n    }\n\nprivate:\n    explicit dynamic_lib(void_ptr&amp;&amp; handle, std::string lib_path = \"\")\n        : handle_{std::move(handle)}\n        , library_path_{std::move(lib_path)} { }\n\n    void_ptr    handle_;\n    std::string library_path_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/error__util_8hpp/","title":"File error_util.hpp","text":"<p>FileList &gt; illixr &gt; error_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"global_module_defs.hpp\"</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/error__util_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/error__util_8hpp/#macros","title":"Macros","text":"Type Name define RAC_ERRNO () <code>[**ILLIXR::report\\_and\\_clear\\_errno**](namespaceILLIXR.md#function-report_and_clear_errno)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_, \\_\\_func\\_\\_)</code>Parameterless macro for report_and_clear_errno. define RAC_ERRNO_MSG (msg) <code>[**ILLIXR::report\\_and\\_clear\\_errno**](namespaceILLIXR.md#function-report_and_clear_errno)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_, \\_\\_func\\_\\_, msg)</code>RAC_ERRNO."},{"location":"api/error__util_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/error__util_8hpp/#define-rac_errno","title":"define RAC_ERRNO","text":"<p>Parameterless macro for report_and_clear_errno. <pre><code>#define RAC_ERRNO (\n\n) `ILLIXR::report_and_clear_errno (__FILE__, __LINE__, __func__)`\n</code></pre></p>"},{"location":"api/error__util_8hpp/#define-rac_errno_msg","title":"define RAC_ERRNO_MSG","text":"<p>RAC_ERRNO. <pre><code>#define RAC_ERRNO_MSG (\n    msg\n) `ILLIXR::report_and_clear_errno (__FILE__, __LINE__, __func__, msg)`\n</code></pre></p> <p>Parameterized macro for report_and_clear_errno.</p> <p>Prints a message from the calling context for additional info. </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/error_util.hpp</code></p>"},{"location":"api/error__util_8hpp_source/","title":"File error_util.hpp","text":"<p>File List &gt; illixr &gt; error_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"global_module_defs.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n\n#ifdef NDEBUG\n    #include &lt;cerrno&gt;\n    #include &lt;cstdlib&gt;\n#endif\n#ifndef RAC_ERRNO\n    #define RAC_ERRNO() ILLIXR::report_and_clear_errno(__FILE__, __LINE__, __func__)\n#endif \n\n#ifndef RAC_ERRNO_MSG\n    #define RAC_ERRNO_MSG(msg) ILLIXR::report_and_clear_errno(__FILE__, __LINE__, __func__, msg)\n#endif \n\nnamespace ILLIXR {\n// can't use switchboard interface here\nstatic const bool ENABLE_VERBOSE_ERRORS{getenv(\"ILLIXR_ENABLE_VERBOSE_ERRORS\") != nullptr &amp;&amp;\n                                        ILLIXR::str_to_bool(getenv(\"ILLIXR_ENABLE_VERBOSE_ERRORS\"))};\n\ninline void report_and_clear_errno([[maybe_unused]] const std::string&amp; file, [[maybe_unused]] const int&amp; line,\n                                   [[maybe_unused]] const std::string&amp; function, [[maybe_unused]] const std::string&amp; msg = \"\") {\n#ifndef NDEBUG\n    if (errno &gt; 0) {\n        if (ILLIXR::ENABLE_VERBOSE_ERRORS) {\n            spdlog::get(\"illixr\")-&gt;error(\"[error_util] || Errno was set: {} @ {}:{} [{}]\", errno, file, line, function);\n            if (!msg.empty()) {\n                spdlog::get(\"illixr\")-&gt;error(\"[error_util]|&gt; Message: {}\", msg);\n            }\n        }\n        errno = 0;\n    }\n#endif \n}\n\ninline void abort(const std::string&amp; msg = \"\", [[maybe_unused]] const int error_val = 1) {\n    spdlog::get(\"illixr\")-&gt;error(\"[error_util] ** ERROR ** {}\", msg);\n#ifndef NDEBUG\n    std::abort();\n#else  \n    std::exit(error_val);\n#endif \n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/extended__window_8hpp/","title":"File extended_window.hpp","text":"<p>FileList &gt; illixr &gt; extended_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include \"global_module_defs.hpp\"</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> </ul>"},{"location":"api/extended__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/extended__window_8hpp/#classes","title":"Classes","text":"Type Name class xlib_gl_extended_window"},{"location":"api/extended__window_8hpp/#public-types","title":"Public Types","text":"Type Name typedef GLXContext(* glXCreateContextAttribsARBProc"},{"location":"api/extended__window_8hpp/#macros","title":"Macros","text":"Type Name define GLX_CONTEXT_MAJOR_VERSION_ARB <code>0x2091</code> define GLX_CONTEXT_MINOR_VERSION_ARB <code>0x2092</code>"},{"location":"api/extended__window_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/extended__window_8hpp/#typedef-glxcreatecontextattribsarbproc","title":"typedef glXCreateContextAttribsARBProc","text":"<pre><code>typedef GLXContext(* glXCreateContextAttribsARBProc) (Display *, GLXFBConfig, GLXContext, Bool, const int *);\n</code></pre>"},{"location":"api/extended__window_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/extended__window_8hpp/#define-glx_context_major_version_arb","title":"define GLX_CONTEXT_MAJOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MAJOR_VERSION_ARB `0x2091`\n</code></pre>"},{"location":"api/extended__window_8hpp/#define-glx_context_minor_version_arb","title":"define GLX_CONTEXT_MINOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MINOR_VERSION_ARB `0x2092`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/extended_window.hpp</code></p>"},{"location":"api/extended__window_8hpp_source/","title":"File extended_window.hpp","text":"<p>File List &gt; illixr &gt; extended_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"error_util.hpp\"\n#include \"global_module_defs.hpp\"\n#include \"phonebook.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;cerrno&gt;\n#include &lt;GL/glx.h&gt;\n#ifndef NDEBUG\n    #include &lt;spdlog/spdlog.h&gt;\n#endif\n\n// GLX context magics\n#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092\ntypedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);\n\nnamespace ILLIXR {\nclass xlib_gl_extended_window : public phonebook::service {\npublic:\n    xlib_gl_extended_window(int width, int height, GLXContext shared_gl_context) {\n        width_  = width;\n        height_ = height;\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Opening display\");\n#endif\n        RAC_ERRNO_MSG(\"extended_window at start of xlib_gl_extended_window constructor\");\n\n        display_ = XOpenDisplay(nullptr);\n        if (display_ == nullptr) {\n            ILLIXR::abort(\"Cannot connect to X server\");\n        } else {\n            // Apparently, XOpenDisplay's _true_ error indication is whether display_ is nullptr.\n            // https://cboard.cprogramming.com/linux-programming/119957-xlib-perversity.html\n            // if (errno != 0) {\n            //  std::cerr &lt;&lt; \"XOpenDisplay succeeded, but errno = \" &lt;&lt; errno &lt;&lt; \"; This is benign, so I'm clearing it now.\\n\";\n            // }\n            errno = 0;\n        }\n\n        Window root = DefaultRootWindow(display_);\n        // Get a matching FB config\n        static int visual_attribs[] = {GLX_X_RENDERABLE,\n                                       True,\n                                       GLX_DRAWABLE_TYPE,\n                                       GLX_WINDOW_BIT,\n                                       GLX_RENDER_TYPE,\n                                       GLX_RGBA_BIT,\n                                       GLX_X_VISUAL_TYPE,\n                                       GLX_TRUE_COLOR,\n                                       GLX_RED_SIZE,\n                                       8,\n                                       GLX_GREEN_SIZE,\n                                       8,\n                                       GLX_BLUE_SIZE,\n                                       8,\n                                       GLX_ALPHA_SIZE,\n                                       8,\n                                       GLX_DEPTH_SIZE,\n                                       24,\n                                       GLX_STENCIL_SIZE,\n                                       8,\n                                       GLX_DOUBLEBUFFER,\n                                       True,\n                                       None};\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Getting matching framebuffer configs\");\n#endif\n        RAC_ERRNO_MSG(\"extended_window before glXChooseFBConfig\");\n\n        int          fb_count  = 0;\n        int          screen    = DefaultScreen(display_);\n        GLXFBConfig* fb_config = glXChooseFBConfig(display_, screen, visual_attribs, &amp;fb_count);\n        if (!fb_config) {\n            ILLIXR::abort(\"Failed to retrieve a framebuffer config\");\n        }\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Found {} matching FB configs\", fb_count);\n\n        // Pick the FB config/visual with the most samples per pixel\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Getting XVisualInfos\");\n#endif\n        int best_fbc = -1, worst_fbc = -1, best_num_samp = -1, worst_num_samp = 999;\n        int i;\n        for (i = 0; i &lt; fb_count; ++i) {\n            XVisualInfo* vis_info = glXGetVisualFromFBConfig(display_, fb_config[i]);\n            if (vis_info) {\n                int samp_buf, samples;\n                glXGetFBConfigAttrib(display_, fb_config[i], GLX_SAMPLE_BUFFERS, &amp;samp_buf);\n                glXGetFBConfigAttrib(display_, fb_config[i], GLX_SAMPLES, &amp;samples);\n#ifndef NDEBUG\n                spdlog::get(\"illixr\")-&gt;debug(\n                    \"[extended_window] Matching fb_config {}, visual ID {:x}: SAMPLE_BUFFERS = {}, SAMPLES = {}\", i,\n                    vis_info-&gt;visualid, samp_buf, samples);\n#endif\n                if (best_fbc &lt; 0 || (samp_buf &amp;&amp; samples &gt; best_num_samp)) {\n                    best_fbc = i, best_num_samp = samples;\n                }\n                if (worst_fbc &lt; 0 || (!samp_buf || samples &lt; worst_num_samp)) {\n                    worst_fbc = i, worst_num_samp = samples;\n                }\n            }\n            XFree(vis_info);\n        }\n\n        assert(0 &lt;= best_fbc &amp;&amp; best_fbc &lt; fb_count);\n        GLXFBConfig g_best_fbc = fb_config[best_fbc];\n\n        // Free the FBConfig list allocated by glXChooseFBConfig()\n        XFree(fb_config);\n\n        // Get a visual\n        XVisualInfo* vis_info = glXGetVisualFromFBConfig(display_, g_best_fbc);\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Chose visual ID = {:x}\", vis_info-&gt;visualid);\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Creating colormap\");\n#endif\n        color_map_ = XCreateColormap(display_, root, vis_info-&gt;visual, AllocNone);\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Creating window\");\n#endif\n        XSetWindowAttributes attributes;\n        attributes.colormap         = color_map_;\n        attributes.background_pixel = 0;\n        attributes.border_pixel     = 0;\n        attributes.event_mask       = ExposureMask | KeyPressMask;\n        window_ = XCreateWindow(display_, root, 0, 0, width_, height_, 0, vis_info-&gt;depth, InputOutput, vis_info-&gt;visual,\n                                CWBackPixel | CWColormap | CWBorderPixel | CWEventMask, &amp;attributes);\n        if (!window_) {\n            ILLIXR::abort(\"Failed to create window\");\n        }\n        XStoreName(display_, window_, \"ILLIXR Extended Window\");\n        XMapWindow(display_, window_);\n\n        // Done with visual info\n        XFree(vis_info);\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Creating context\");\n#endif\n        auto glXCreateContextAttribsARB =\n            (glXCreateContextAttribsARBProc) glXGetProcAddressARB((const GLubyte*) \"glXCreateContextAttribsARB\");\n        int context_attribs[] = {GLX_CONTEXT_MAJOR_VERSION_ARB, 3, GLX_CONTEXT_MINOR_VERSION_ARB, 3, None};\n\n        context_ = glXCreateContextAttribsARB(display_, g_best_fbc, shared_gl_context, True, context_attribs);\n\n        // Sync to process errors\n        RAC_ERRNO_MSG(\"extended_window before XSync\");\n        XSync(display_, false);\n        RAC_ERRNO_MSG(\"extended_window after XSync\");\n\n#ifndef NDEBUG\n        // Doing glXMakeCurrent here makes a third thread, the runtime one, enter the mix, and\n        // then there are three GL threads: runtime, timewarp, and gldemo, and the switching of\n        // contexts without synchronization during the initialization phase causes a data race.\n        // This is why native.yaml sometimes succeeds and sometimes doesn't. Headless succeeds\n        // because this behavior is OpenGL implementation dependent, and apparently mesa\n        // differs from NVIDIA in this regard.\n        // The proper fix is #173. Comment the below back in once #173 is done. In any case,\n        // this is just for debugging and does not affect any functionality.\n\n        /*\n        const bool gl_result_0 = static_cast&lt;bool&gt;(glXMakeCurrent(display_, window_, context_));\n        int major = 0, minor = 0;\n        glGetIntegerv(GL_MAJOR_VERSION, &amp;major);\n        glGetIntegerv(GL_MINOR_VERSION, &amp;minor);\n        std::cout &lt;&lt; \"OpenGL context created\" &lt;&lt; std::endl\n                  &lt;&lt; \"Version \" &lt;&lt; major &lt;&lt; \".\" &lt;&lt; minor &lt;&lt; std::endl\n                  &lt;&lt; \"Vendor \" &lt;&lt; glGetString(GL_VENDOR) &lt;&lt; std::endl\n                  &lt;&lt; \"Renderer \" &lt;&lt; glGetString(GL_RENDERER) &lt;&lt; std::endl;\n        const bool gl_result_1 = static_cast&lt;bool&gt;(glXMakeCurrent(display_, None, nullptr));\n        */\n#endif\n    }\n\n    ~xlib_gl_extended_window() override {\n        RAC_ERRNO_MSG(\"xlib_gl_extended_window at start of destructor\");\n\n        [[maybe_unused]] const bool gl_result = static_cast&lt;bool&gt;(glXMakeCurrent(display_, None, nullptr));\n        assert(gl_result &amp;&amp; \"glXMakeCurrent should not fail\");\n\n        glXDestroyContext(display_, context_);\n        XDestroyWindow(display_, window_);\n        Window root = DefaultRootWindow(display_);\n        XDestroyWindow(display_, root);\n        XFreeColormap(display_, color_map_);\n\n        XCloseDisplay(display_);\n\n        RAC_ERRNO_MSG(\"xlib_gl_extended_window at end of destructor\");\n    }\n\n    int        width_;\n    int        height_;\n    Display*   display_;\n    Window     window_;\n    GLXContext context_;\n\nprivate:\n    Colormap color_map_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/fauxpose_2service_8cpp/","title":"File service.cpp","text":"<p>FileList &gt; fauxpose &gt; service.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"service.hpp\"</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Geometry&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/fauxpose/service.cpp</code></p>"},{"location":"api/fauxpose_2service_8cpp_source/","title":"File service.cpp","text":"<p>File List &gt; fauxpose &gt; service.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*****************************************************************************/\n/* fauxpose/plugin.cpp                                                       */\n/*                                                                           */\n/* Created: 03/03/2022                                                       */\n/* Last Edited: 07/27/2023                                                   */\n/*                                                                           */\n/* An ILLIXR plugin that publishes position tracking data (\"pose\")           */\n/*     from a mathematical operation just to quickly produce some known    */\n/*     tracking path for the purpose of debugging other portions of ILLIXR.*/\n/*                                                                           */\n/* USAGE:                                                                   */\n/*   * Add \"- path: fauxpose/\" as a plugin (and not other trackers)          */\n/*   * Use \"FAUXPOSE_PERIOD\" environment variable to control orbit period    */\n/*   * Use \"FAUXPOSE_AMPLITUDE\" environment variable to control orbit size   */\n/*   * Use \"FAUXPOSE_CENTER\" env-var to control the center point of orbit    */\n/*                                                                           */\n/* TODO:                                                                     */\n/*   * DONE: Need to implement as a \"pose_prediction\" \"impl\" (service?)      */\n/*   * DONE: Fix so that \"gldemo\" (etc.) face forward.                       */\n/*   * DONE: Implement environment variables to control parameters           */\n/*   * Add control of the view direction as a control parameter              */\n/*   * Add control of orbital plane as a control parameter                   */\n/*                                                                           */\n/* NOTES:                                                                    */\n/*   * get_fast_pose() method returns a \"fast_pose_type\"                     */\n/*   * \"fast_pose_type\" is a \"pose_type\" plus computed &amp; target timestamps   */\n/*   * correct_pose() method returns a \"pose_type\"                           */\n/*   * (This version uploaded to ILLIXR GitHub)                              */\n/*                                                                           */\n\n#include \"service.hpp\"\n\n#include &lt;cstdlib&gt;\n#include &lt;eigen3/Eigen/Core&gt;\n#include &lt;eigen3/Eigen/Geometry&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nfauxpose_impl::fauxpose_impl(const phonebook* pb)\n    : switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{pb-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , vsync_estimate_{switchboard_-&gt;get_reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\")} {\n    const char* env_input; /* pointer to environment variable input */\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Starting Service\");\n#endif\n\n    // Store the initial time\n    if (clock_-&gt;is_started()) {\n        sim_start_time_ = clock_-&gt;now();\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Starting Service\");\n#endif\n    } else {\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Warning: the clock isn't started yet\");\n#endif\n    }\n\n    // Set default faux-pose parameters\n    center_location_ = Eigen::Vector3f{0.0, 1.5, 0.0};\n    period_          = 0.5;\n    amplitude_       = 2.0;\n\n    // Adjust parameters based on environment variables\n    if ((env_input = switchboard_-&gt;get_env_char(\"FAUXPOSE_PERIOD\"))) {\n        period_ = std::strtof(env_input, nullptr);\n    }\n    if ((env_input = switchboard_-&gt;get_env_char(\"FAUXPOSE_AMPLITUDE\"))) {\n        amplitude_ = std::strtof(env_input, nullptr);\n    }\n    if ((env_input = switchboard_-&gt;get_env_char(\"FAUXPOSE_CENTER\"))) {\n        center_location_[0] = std::strtof(env_input, nullptr);\n        center_location_[1] = std::strtof(strchrnul(env_input, ',') + 1, nullptr);\n        center_location_[2] = std::strtof(strchrnul(strchrnul(env_input, ',') + 1, ',') + 1, nullptr);\n    }\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Period is {}\", period_);\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Amplitude is {}\", amplitude_);\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Center is {}, {}, {}\", center_location_[0], center_location_[1],\n                                 center_location_[2]);\n#endif\n}\n\nfauxpose_impl::~fauxpose_impl() {\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Ending Service\");\n#endif\n}\n\npose_type fauxpose_impl::correct_pose([[maybe_unused]] const pose_type&amp; pose) const {\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Returning (passthru) pose\");\n#endif\n    return pose;\n}\n\nEigen::Quaternionf fauxpose_impl::get_offset() {\n    return offset_;\n}\n\nvoid fauxpose_impl::set_offset(const Eigen::Quaternionf&amp; raw_o_times_offset) {\n    std::unique_lock   lock{offset_mutex_};\n    Eigen::Quaternionf raw_o = raw_o_times_offset * offset_.inverse();\n    offset_                  = raw_o.inverse();\n}\n\nfast_pose_type fauxpose_impl::get_fast_pose() const {\n    // In actual pose prediction, the semantics are that we return\n    //   the pose for next vsync, not now.\n    switchboard::ptr&lt;const switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_estimate = vsync_estimate_.get_ro_nullable();\n    if (vsync_estimate == nullptr) {\n        return get_fast_pose(clock_-&gt;now());\n    } else {\n        return get_fast_pose(vsync_estimate.get()-&gt;operator time_point());\n    }\n}\n\nfast_pose_type fauxpose_impl::get_fast_pose(time_point time) const {\n    pose_type simulated_pose; /* The algorithmically calculated 6-DOF pose */\n    double    sim_time;       /* sim_time is used to regulate a consistent movement */\n\n    RAC_ERRNO_MSG(\"[fauxpose] at start of _p_one_iteration\");\n\n    // Calculate simulation time from start of execution\n    std::chrono::nanoseconds elapsed_time;\n    elapsed_time = time - sim_start_time_;\n    sim_time     = static_cast&lt;double&gt;(elapsed_time.count()) * 0.000000001;\n\n    // Calculate new pose values\n    //   Pose values are calculated from the passage of time to maintain consistency */\n    simulated_pose.position[0] = static_cast&lt;float&gt;(center_location_[0] + amplitude_ * sin(sim_time * period_)); // X\n    simulated_pose.position[1] = static_cast&lt;float&gt;(center_location_[1]);                                        // Y\n    simulated_pose.position[2] = static_cast&lt;float&gt;(center_location_[2] + amplitude_ * cos(sim_time * period_)); // Z\n    simulated_pose.orientation = Eigen::Quaternionf(0.707, 0.0, 0.707, 0.0); // (W,X,Y,Z) Facing forward (90deg about Y)\n\n    // Return the new pose\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Returning pose\");\n#endif\n    return fast_pose_type{simulated_pose, clock_-&gt;now(), time};\n}\n\n[[maybe_unused]] fauxpose::fauxpose(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb} {\n    // \"pose_prediction\" is a class inheriting from \"phonebook::service\"\n    //   It is described in \"pose_prediction.hpp\"\n    pb-&gt;register_impl&lt;pose_prediction&gt;(std::static_pointer_cast&lt;pose_prediction&gt;(std::make_shared&lt;fauxpose_impl&gt;(pb)));\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Starting Plugin\");\n#endif\n}\n\nfauxpose::~fauxpose() {\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[fauxpose] Ending Plugin\");\n#endif\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(fauxpose)\n</code></pre>"},{"location":"api/fauxpose_2service_8hpp/","title":"File service.hpp","text":"<p>FileList &gt; fauxpose &gt; service.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> </ul>"},{"location":"api/fauxpose_2service_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/fauxpose_2service_8hpp/#classes","title":"Classes","text":"Type Name class fauxpose class fauxpose_impl Create a \"pose_prediction\" type service. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/fauxpose/service.hpp</code></p>"},{"location":"api/fauxpose_2service_8hpp_source/","title":"File service.hpp","text":"<p>File List &gt; fauxpose &gt; service.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n\nnamespace ILLIXR {\nclass fauxpose_impl : public data_format::pose_prediction {\npublic:\n    explicit fauxpose_impl(const phonebook* pb);\n    ~fauxpose_impl() override;\n\n    data_format::pose_type get_true_pose() const override {\n        throw std::logic_error{\"Not Implemented\"};\n    }\n\n    bool fast_pose_reliable() const override {\n        return true;\n    }\n\n    bool true_pose_reliable() const override {\n        return false;\n    }\n\n    data_format::pose_type      correct_pose(const data_format::pose_type&amp; pose) const override;\n    Eigen::Quaternionf          get_offset() override;\n    void                        set_offset(const Eigen::Quaternionf&amp; raw_o_times_offset) override;\n    data_format::fast_pose_type get_fast_pose() const override;\n    // ********************************************************************\n    // get_fast_pose(): returns a \"fast_pose_type\" with the algorithmically\n    //   determined location values.  (Presently moving in a circle, but\n    //   always facing \"front\".)\n    //\n    // NOTE: time_type == std::chrono::system_clock::time_point\n    data_format::fast_pose_type get_fast_pose(time_point time) const override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;                          switchboard_;\n    const std::shared_ptr&lt;const relative_clock&gt;                 clock_;\n    switchboard::reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_estimate_;\n    mutable Eigen::Quaternionf                                  offset_{Eigen::Quaternionf::Identity()};\n    mutable std::shared_mutex                                   offset_mutex_;\n\n    time_point sim_start_time_{}; /* Store the initial time to calculate a known runtime */\n\n    // Parameters\n    double          period_;          /* The period of the circular movement (in seconds) */\n    double          amplitude_;       /* The amplitude of the circular movement (in meters) */\n    Eigen::Vector3f center_location_; /* The location around which the tracking should orbit */\n};\n\nclass fauxpose : public plugin {\npublic:\n    // ********************************************************************\n    /* Constructor: Provide handles to faux_pose */\n    [[maybe_unused]] fauxpose(const std::string&amp; name, phonebook* pb);\n    ~fauxpose() override;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/ffmpeg__utils_8hpp/","title":"File ffmpeg_utils.hpp","text":"<p>FileList &gt; illixr &gt; vk &gt; ffmpeg_utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"vulkan/vulkan.h\"</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"libavcodec_illixr/avcodec.h\"</code></li> <li><code>#include \"libavformat_illixr/avformat.h\"</code></li> <li><code>#include \"libavutil_illixr/hwcontext.h\"</code></li> <li><code>#include \"libavutil_illixr/hwcontext_vulkan.h\"</code></li> <li><code>#include \"libavutil_illixr/opt.h\"</code></li> <li><code>#include \"libavutil_illixr/pixdesc.h\"</code></li> </ul>"},{"location":"api/ffmpeg__utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace vulkan namespace ffmpeg_utils"},{"location":"api/ffmpeg__utils_8hpp/#classes","title":"Classes","text":"Type Name struct ffmpeg_vk_frame"},{"location":"api/ffmpeg__utils_8hpp/#macros","title":"Macros","text":"Type Name define OFFLOAD_RENDERING_BITRATE <code>100000000</code> define OFFLOAD_RENDERING_FFMPEG_ENCODER_NAME <code>\"hevc\\_nvenc\"</code>"},{"location":"api/ffmpeg__utils_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/ffmpeg__utils_8hpp/#define-offload_rendering_bitrate","title":"define OFFLOAD_RENDERING_BITRATE","text":"<pre><code>#define OFFLOAD_RENDERING_BITRATE `100000000`\n</code></pre>"},{"location":"api/ffmpeg__utils_8hpp/#define-offload_rendering_ffmpeg_encoder_name","title":"define OFFLOAD_RENDERING_FFMPEG_ENCODER_NAME","text":"<pre><code>#define OFFLOAD_RENDERING_FFMPEG_ENCODER_NAME `\"hevc_nvenc\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/ffmpeg_utils.hpp</code></p>"},{"location":"api/ffmpeg__utils_8hpp_source/","title":"File ffmpeg_utils.hpp","text":"<p>File List &gt; illixr &gt; vk &gt; ffmpeg_utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"vulkan/vulkan.h\"\n\n#include &lt;optional&gt;\n#include &lt;utility&gt;\nextern \"C\" {\n#include \"libavcodec_illixr/avcodec.h\"\n#include \"libavformat_illixr/avformat.h\"\n#include \"libavutil_illixr/hwcontext.h\"\n#include \"libavutil_illixr/hwcontext_vulkan.h\"\n#include \"libavutil_illixr/opt.h\"\n#include \"libavutil_illixr/pixdesc.h\"\n}\n\n#define OFFLOAD_RENDERING_FFMPEG_ENCODER_NAME \"hevc_nvenc\"\n#define OFFLOAD_RENDERING_BITRATE             100000000\n\nnamespace ILLIXR::vulkan::ffmpeg_utils {\n\nstatic std::weak_ptr&lt;vulkan::display_provider&gt; display_provider_ffmpeg;\n\nstatic void ffmpeg_lock_queue(struct AVHWDeviceContext* ctx, uint32_t queue_family, uint32_t index) {\n    (void) ctx;\n    (void) index;\n    if (auto dp = display_provider_ffmpeg.lock()) {\n        std::optional&lt;vulkan::queue&gt; queue;\n        for (auto&amp; q : dp-&gt;queues_) {\n            if (q.second.family == queue_family) {\n                queue = q.second;\n                break;\n            }\n        }\n        if (!queue) {\n            throw std::runtime_error{\"Failed to find queue with family \" + std::to_string(queue_family)};\n        }\n        queue-&gt;mutex-&gt;lock();\n    } else {\n        throw std::runtime_error{\"Weak pointer to display_provider is expired\"};\n    }\n}\n\nstatic void ffmpeg_unlock_queue(struct AVHWDeviceContext* ctx, uint32_t queue_family, uint32_t index) {\n    (void) ctx;\n    (void) index;\n    if (auto dp = display_provider_ffmpeg.lock()) {\n        std::optional&lt;vulkan::queue&gt; queue;\n        for (auto&amp; q : dp-&gt;queues_) {\n            if (q.second.family == queue_family) {\n                queue = q.second;\n                break;\n            }\n        }\n        if (!queue) {\n            throw std::runtime_error{\"Failed to find queue with family \" + std::to_string(queue_family)};\n        }\n        queue-&gt;mutex-&gt;unlock();\n    } else {\n        throw std::runtime_error{\"Weak pointer to display_provider is expired\"};\n    }\n}\n\nstatic std::optional&lt;AVPixelFormat&gt; get_pix_format_from_vk_format(VkFormat format) {\n    for (int fmt = AV_PIX_FMT_NONE; fmt &lt; AV_PIX_FMT_NB; fmt++) {\n        auto vk_fmt = av_vkfmt_from_pixfmt(static_cast&lt;AVPixelFormat&gt;(fmt));\n        if (vk_fmt &amp;&amp; *vk_fmt == format) {\n            return static_cast&lt;AVPixelFormat&gt;(fmt);\n        }\n    }\n    return std::nullopt;\n}\n\nstatic void AV_ASSERT_SUCCESS(int ret) {\n    if (ret &lt; 0) {\n        char errbuf[AV_ERROR_MAX_STRING_SIZE];\n        av_strerror(ret, errbuf, AV_ERROR_MAX_STRING_SIZE);\n        throw std::runtime_error{std::string{\"FFmpeg error: \"} + errbuf};\n    }\n}\n\nstruct ffmpeg_vk_frame {\n    AVFrame*   frame    = nullptr;\n    AVVkFrame* vk_frame = nullptr;\n};\n} // namespace ILLIXR::vulkan::ffmpeg_utils\n</code></pre>"},{"location":"api/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>dir illixr <ul> <li>dir data_format <ul> <li>file camera_data.hpp </li> <li>file coordinate.hpp </li> <li>file frame.hpp </li> <li>file hand_tracking_data.hpp </li> <li>file imu.hpp </li> <li>file misc.hpp </li> <li>file opencv_data_types.hpp </li> <li>file point.hpp </li> <li>file pose.hpp </li> <li>file pose_prediction.hpp </li> <li>file proper_quaternion.hpp </li> <li>file serializable_data.hpp </li> <li>file shape.hpp </li> <li>file template.hpp </li> <li>file unit.hpp </li> <li>file zed_cam.hpp </li> </ul> </li> <li>dir network <ul> <li>file net_config.hpp </li> <li>file network_backend.hpp </li> <li>file tcpsocket.hpp </li> <li>file topic_config.hpp </li> </ul> </li> <li>dir vk <ul> <li>file display_provider.hpp </li> <li>file ffmpeg_utils.hpp </li> <li>file render_pass.hpp </li> <li>file vulkan_objects.hpp </li> <li>file vulkan_utils.hpp </li> </ul> </li> <li>file cpu_timer.hpp </li> <li>file csv_iterator.hpp </li> <li>file data_loading.hpp </li> <li>file dynamic_lib.hpp </li> <li>file error_util.hpp </li> <li>file extended_window.hpp </li> <li>file global_module_defs.hpp </li> <li>file hmd.hpp </li> <li>file managed_thread.hpp </li> <li>file math_util.hpp </li> <li>file phonebook.hpp </li> <li>file plugin.hpp </li> <li>file record_logger.hpp </li> <li>file relative_clock.hpp </li> <li>file runge-kutta.hpp </li> <li>file runtime.hpp </li> <li>file shader_util.hpp </li> <li>file stoplight.hpp </li> <li>file switchboard.hpp </li> <li>file threadloop.hpp </li> </ul> </li> </ul> </li> <li>dir plugins <ul> <li>dir audio_pipeline </li> <li>dir debugview <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir depthai <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir gldemo <ul> <li>file parser.py </li> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir ground_truth_slam <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir gtsam_integrator <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir hand_tracking <ul> <li>dir viewer <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> </ul> </li> <li>dir hand_tracking_gpu </li> <li>dir lighthouse <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir native_renderer <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir offline_cam <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir offline_imu <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir offload_data <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir offload_rendering_client <ul> <li>file offload_rendering_client.cpp </li> <li>file offload_rendering_client.hpp </li> <li>file plugin.cpp Offload Rendering Client Plugin Implementation. </li> </ul> </li> <li>dir offload_rendering_server <ul> <li>file offload_rendering_server.cpp </li> <li>file offload_rendering_server.hpp </li> <li>file plugin.cpp Offload Rendering Server Plugin Implementation. </li> <li>file plugin.hpp </li> </ul> </li> <li>dir offload_vio <ul> <li>dir device_rx <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir device_tx <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> <li>file video_encoder.cpp </li> <li>file video_encoder.hpp </li> </ul> </li> <li>dir server_rx <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> <li>file video_decoder.cpp </li> <li>file video_decoder.hpp </li> </ul> </li> <li>dir server_tx <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> </ul> </li> <li>dir openni <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir openvins </li> <li>dir openwarp_vk <ul> <li>dir monado </li> <li>file openwarp_vk.cpp </li> <li>file openwarp_vk.hpp </li> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir orb_slam3 </li> <li>dir passthrough_integrator <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir realsense <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir record_imu_cam <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir record_rgb_depth <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir rk4_integrator <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir tcp_network_backend <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir timewarp_gl <ul> <li>dir monado </li> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir timewarp_vk <ul> <li>dir monado </li> <li>file plugin.cpp </li> <li>file plugin.hpp </li> <li>file timewarp_vk.cpp </li> <li>file timewarp_vk.hpp </li> </ul> </li> <li>dir webcam <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>dir zed <ul> <li>dir capture <ul> <li>file capture.cpp </li> <li>file capture.hpp </li> <li>file capture_main.cpp </li> <li>file cxxopts.hpp </li> <li>file files.cpp </li> <li>file files.hpp </li> <li>file zed_opencv.hpp </li> </ul> </li> <li>dir data_injection <ul> <li>file plugin.cpp </li> <li>file plugin.hpp </li> </ul> </li> <li>file plugin.cpp </li> <li>file plugin.hpp </li> <li>file zed_camera.cpp </li> <li>file zed_camera.hpp </li> <li>file zed_camera_thread.cpp </li> <li>file zed_camera_thread.hpp </li> </ul> </li> </ul> </li> <li>dir services <ul> <li>dir fauxpose <ul> <li>file service.cpp </li> <li>file service.hpp </li> </ul> </li> <li>dir pose_lookup <ul> <li>file service.cpp </li> <li>file service.hpp </li> <li>file utils.hpp </li> </ul> </li> <li>dir pose_prediction <ul> <li>file service.cpp </li> <li>file service.hpp </li> </ul> </li> <li>dir vkdemo <ul> <li>file service.cpp </li> <li>file service.hpp </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>dir display <ul> <li>file display_backend.hpp </li> <li>file glfw_extended.cpp </li> <li>file glfw_extended.hpp </li> <li>file headless.cpp </li> <li>file headless.hpp </li> <li>file x11_direct.cpp </li> <li>file x11_direct.hpp </li> </ul> </li> <li>file cxxopts.hpp </li> <li>file illixr.hpp </li> <li>file main.cpp </li> <li>file plugin.cpp </li> <li>file runtime_impl.cpp </li> <li>file sqlite_record_logger.hpp </li> <li>file stdout_record_logger.hpp </li> <li>file vulkan_display.hpp </li> </ul> </li> <li>dir utils <ul> <li>file hmd.cpp </li> <li>file hmd.hpp </li> <li>file serializable_data.cpp </li> <li>file serializable_data.hpp </li> <li>file vulkan_utils.cpp </li> <li>file vulkan_utils.hpp </li> </ul> </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file CMakeLists.txt </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> <li>file README.md </li> </ul>"},{"location":"api/files_8cpp/","title":"File files.cpp","text":"<p>FileList &gt; capture &gt; files.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"files.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include &lt;boost/filesystem.hpp&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"api/files_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name const std::string d_file   = <code>\"/data.csv\"</code>"},{"location":"api/files_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const ILLIXR::data_format::pose_type &amp; dt)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, ILLIXR::data_format::ccd_data const &amp; cd)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, ILLIXR::data_format::camera_data const &amp; cc)"},{"location":"api/files_8cpp/#macros","title":"Macros","text":"Type Name define COMMA <code>\",\"</code>"},{"location":"api/files_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/files_8cpp/#variable-d_file","title":"variable d_file","text":"<pre><code>const std::string d_file;\n</code></pre>"},{"location":"api/files_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/files_8cpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const ILLIXR::data_format::pose_type &amp; dt\n) \n</code></pre>"},{"location":"api/files_8cpp/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    ILLIXR::data_format::ccd_data const &amp; cd\n) \n</code></pre>"},{"location":"api/files_8cpp/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    ILLIXR::data_format::camera_data const &amp; cc\n) \n</code></pre>"},{"location":"api/files_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/files_8cpp/#define-comma","title":"define COMMA","text":"<pre><code>#define COMMA `\",\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/files.cpp</code></p>"},{"location":"api/files_8cpp_source/","title":"File files.cpp","text":"<p>File List &gt; capture &gt; files.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"files.hpp\"\n\n#include \"illixr/data_format/pose.hpp\"\n\n#include &lt;boost/filesystem.hpp&gt;\n#include &lt;sstream&gt;\n// #include &lt;string_view&gt;\n\n#define COMMA \",\"\n\nusing namespace ILLIXR::zed_capture;\nconst std::string d_file = \"/data.csv\";\n\nboost::filesystem::path files::data_path_;\nboost::filesystem::path files::img_path_;\n\nboost::filesystem::path files::camL_path_;\nboost::filesystem::path files::camR_path_;\n// boost::filesystem::path files::depth_path;\n// boost::filesystem::path files::conf_path;\n\nstd::string files::data_file_;\nstd::string files::camL_file_;\nstd::string files::camR_file_;\n// std::string files::depth_file;\n// std::string files::conf_file;\nstd::string files::cam_file_;\n\nfiles* files::instance_ = nullptr;\n\nfiles* files::getInstance() {\n    if (instance_ == nullptr)\n        throw std::runtime_error(\"Must be given a path\");\n    return instance_;\n}\n\nfiles* files::getInstance(const std::string&amp; rt, const std::string&amp; path) {\n    if (instance_ == nullptr) {\n        instance_ = new files(rt, path);\n    }\n    return instance_;\n}\n\nfiles::files(const std::string&amp; rt, const std::string&amp; sub_path) {\n    root_ = rt;\n    std::cout &lt;&lt; root_ &lt;&lt; \"    \" &lt;&lt; sub_path &lt;&lt; std::endl;\n    data_path_ = root_ + sub_path + data_sub_path_;\n    img_path_  = root_ + sub_path + img_sub_path_;\n\n    camL_path_ = img_path_.string() + \"/camL\";\n    camR_path_ = img_path_.string() + \"/camR\";\n    // depth_path = img_path_.string() + \"/depth\";\n    // conf_path = img_path_.string() + \"/conf\";\n\n    data_file_ = data_path_.string() + d_file;\n    camL_file_ = camL_path_.string() + d_file;\n    camR_file_ = camR_path_.string() + d_file;\n    // depth_file = depth_path.string() + d_file;\n    // conf_file = conf_path.string() + d_file;\n    cam_file_ = data_path_.string() + \"/cam.csv\";\n\n    boost::filesystem::create_directories(data_path_);\n    boost::filesystem::create_directories(camL_path_);\n    boost::filesystem::create_directories(camR_path_);\n    // boost::filesystem::create_directories(depth_path);\n    // boost::filesystem::create_directories(conf_path);\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ILLIXR::data_format::pose_type&amp; dt) {\n    os &lt;&lt; dt.sensor_time.time_since_epoch().count() &lt;&lt; COMMA &lt;&lt; dt.position.x() &lt;&lt; COMMA &lt;&lt; dt.position.y() &lt;&lt; COMMA\n       &lt;&lt; dt.position.z() &lt;&lt; COMMA &lt;&lt; dt.orientation.w() &lt;&lt; COMMA &lt;&lt; dt.orientation.x() &lt;&lt; COMMA &lt;&lt; dt.orientation.y() &lt;&lt; COMMA\n       &lt;&lt; dt.orientation.z();\n    return os;\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ILLIXR::data_format::ccd_data const&amp; cd) {\n    os &lt;&lt; cd.center_x &lt;&lt; COMMA &lt;&lt; cd.center_y &lt;&lt; COMMA &lt;&lt; cd.vertical_fov &lt;&lt; COMMA &lt;&lt; cd.horizontal_fov;\n    return os;\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ILLIXR::data_format::camera_data const&amp; cc) {\n    os &lt;&lt; cc.width &lt;&lt; COMMA &lt;&lt; cc.height &lt;&lt; COMMA &lt;&lt; cc.fps &lt;&lt; COMMA &lt;&lt; cc.baseline &lt;&lt; COMMA\n       &lt;&lt; cc.ccds.at(static_cast&lt;const ILLIXR::data_format::units::eyes&gt;(LEFT_EYE)) &lt;&lt; COMMA\n       &lt;&lt; cc.ccds.at(static_cast&lt;const ILLIXR::data_format::units::eyes&gt;(RIGHT_EYE));\n    return os;\n}\n</code></pre>"},{"location":"api/files_8hpp/","title":"File files.hpp","text":"<p>FileList &gt; capture &gt; files.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/zed_cam.hpp\"</code></li> <li><code>#include &lt;boost/filesystem.hpp&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> </ul>"},{"location":"api/files_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace zed_capture"},{"location":"api/files_8hpp/#classes","title":"Classes","text":"Type Name class files"},{"location":"api/files_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr int LEFT_EYE   = <code>0</code> constexpr int RIGHT_EYE   = <code>1</code>"},{"location":"api/files_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, ILLIXR::data_format::pose_type const &amp; dt)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, ILLIXR::data_format::camera_data const &amp; cc)"},{"location":"api/files_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/files_8hpp/#variable-left_eye","title":"variable LEFT_EYE","text":"<pre><code>constexpr int LEFT_EYE;\n</code></pre>"},{"location":"api/files_8hpp/#variable-right_eye","title":"variable RIGHT_EYE","text":"<pre><code>constexpr int RIGHT_EYE;\n</code></pre>"},{"location":"api/files_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/files_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    ILLIXR::data_format::pose_type const &amp; dt\n) \n</code></pre>"},{"location":"api/files_8hpp/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    ILLIXR::data_format::camera_data const &amp; cc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/files.hpp</code></p>"},{"location":"api/files_8hpp_source/","title":"File files.hpp","text":"<p>File List &gt; capture &gt; files.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"illixr/data_format/zed_cam.hpp\"\n\n#include &lt;boost/filesystem.hpp&gt;\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nconstexpr int LEFT_EYE  = 0;\nconstexpr int RIGHT_EYE = 1;\n\nnamespace ILLIXR::zed_capture {\n\ntypedef std::map&lt;ILLIXR::data_format::image::image_type, cv::Mat&gt;     img_map;\ntypedef std::map&lt;ILLIXR::data_format::image::image_type, std::string&gt; str_map;\n\nclass files {\npublic:\n    files(const files&amp;) = delete;\n    files()             = delete;\n    [[maybe_unused]] static files* getInstance();\n    static files*                  getInstance(const std::string&amp; rt, const std::string&amp; path);\n\n    static std::string data_file_;\n    static std::string camL_file_;\n    static std::string camR_file_;\n    // static std::string depth_file;\n    // static std::string conf_file;\n    static std::string cam_file_;\n\n    static boost::filesystem::path data_path_;\n    static boost::filesystem::path img_path_;\n\n    static boost::filesystem::path camL_path_;\n    static boost::filesystem::path camR_path_;\n    // static boost::filesystem::path depth_path;\n    // static boost::filesystem::path conf_path;\n\nprivate:\n    explicit files(const std::string&amp; rt, const std::string&amp; path);\n\n    const std::string data_sub_path_ = \"data\";\n    const std::string img_sub_path_  = \"imgs\";\n    std::string       root_;\n    static files*     instance_;\n};\n} // namespace ILLIXR::zed_capture\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ILLIXR::data_format::pose_type const&amp; dt);\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ILLIXR::data_format::camera_data const&amp; cc);\n</code></pre>"},{"location":"api/frame_8hpp/","title":"File frame.hpp","text":"<p>FileList &gt; data_format &gt; frame.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;boost/serialization/export.hpp&gt;</code></li> <li><code>#include &lt;GL/gl.h&gt;</code></li> </ul>"},{"location":"api/frame_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/frame_8hpp/#classes","title":"Classes","text":"Type Name struct compressed_frame struct rendered_frame <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/frame.hpp</code></p>"},{"location":"api/frame_8hpp_source/","title":"File frame.hpp","text":"<p>File List &gt; data_format &gt; frame.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef Success\n    #undef Success // For 'Success' conflict\n#endif\n\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;array&gt;\n#include &lt;boost/serialization/export.hpp&gt;\n#include &lt;GL/gl.h&gt;\n\n#ifdef ILLIXR_LIBAV\nextern \"C\" {\n    #include \"libavcodec_illixr/avcodec.h\"\n    #include \"libavformat_illixr/avformat.h\"\n    #include \"libavutil_illixr/hwcontext.h\"\n    #include \"libavutil_illixr/opt.h\"\n    #include \"libavutil_illixr/pixdesc.h\"\n}\n#endif\n\nnamespace ILLIXR::data_format {\n// Using arrays as a swapchain\n// Array of left eyes, array of right eyes\n// This more closely matches the format used by Monado\nstruct [[maybe_unused]] rendered_frame : public switchboard::event {\n    std::array&lt;GLuint, 2&gt; swapchain_indices{}; // Does not change between swaps in swapchain\n    std::array&lt;GLuint, 2&gt; swap_indices{};      // Which element of the swapchain\n    fast_pose_type        render_pose;         // The pose used when rendering this frame.\n    time_point            sample_time{};\n    time_point            render_time{};\n\n    rendered_frame() = default;\n\n    rendered_frame(std::array&lt;GLuint, 2&gt;&amp;&amp; swapchain_indices_, std::array&lt;GLuint, 2&gt;&amp;&amp; swap_indices_,\n                   fast_pose_type render_pose_, time_point sample_time_, time_point render_time_)\n        : swapchain_indices{swapchain_indices_}\n        , swap_indices{swap_indices_}\n        , render_pose(std::move(render_pose_))\n        , sample_time(sample_time_)\n        , render_time(render_time_) { }\n};\n\nstruct compressed_frame : public switchboard::event {\n    bool  nalu_only;\n    char* left_color_nalu  = nullptr;\n    char* right_color_nalu = nullptr;\n    char* left_depth_nalu  = nullptr;\n    char* right_depth_nalu = nullptr;\n    int   left_color_nalu_size;\n    int   right_color_nalu_size;\n    int   left_depth_nalu_size;\n    int   right_depth_nalu_size;\n\n    bool use_depth;\n#ifdef ILLIXR_LIBAV\n    AVPacket* left_color;\n    AVPacket* right_color;\n\n    AVPacket* left_depth;\n    AVPacket* right_depth;\n#endif\n\n    fast_pose_type pose;\n    uint64_t       sent_time;\n    long           magic = 0;\n\n    friend class boost::serialization::access;\n\n#ifdef ILLIXR_LIBAV\n    template&lt;class Archive&gt;\n    static void save_packet(Archive&amp; ar, AVPacket* pkt) {\n        ar &lt;&lt; pkt-&gt;size;\n        ar &lt;&lt; boost::serialization::make_array(pkt-&gt;data, pkt-&gt;size);\n        ar &lt;&lt; pkt-&gt;pts;\n        ar &lt;&lt; pkt-&gt;dts;\n        ar &lt;&lt; pkt-&gt;stream_index;\n        ar &lt;&lt; pkt-&gt;flags;\n        ar &lt;&lt; pkt-&gt;duration;\n        ar &lt;&lt; pkt-&gt;pos;\n        ar &lt;&lt; pkt-&gt;time_base.num;\n        ar &lt;&lt; pkt-&gt;time_base.den;\n        ar &lt;&lt; pkt-&gt;side_data_elems;\n        for (int i = 0; i &lt; pkt-&gt;side_data_elems; i++) {\n            ar &lt;&lt; pkt-&gt;side_data[i].type;\n            ar &lt;&lt; pkt-&gt;side_data[i].size;\n            ar &lt;&lt; boost::serialization::make_array(pkt-&gt;side_data[i].data, pkt-&gt;side_data[i].size);\n        }\n    }\n\n    template&lt;class Archive&gt;\n    static void load_packet(Archive&amp; ar, AVPacket* pkt) {\n        ar &gt;&gt; pkt-&gt;size;\n        pkt-&gt;buf  = av_buffer_alloc(pkt-&gt;size);\n        pkt-&gt;data = pkt-&gt;buf-&gt;data;\n        ar &gt;&gt; boost::serialization::make_array(pkt-&gt;data, pkt-&gt;size);\n        ar &gt;&gt; pkt-&gt;pts;\n        ar &gt;&gt; pkt-&gt;dts;\n        ar &gt;&gt; pkt-&gt;stream_index;\n        ar &gt;&gt; pkt-&gt;flags;\n        ar &gt;&gt; pkt-&gt;duration;\n        ar &gt;&gt; pkt-&gt;pos;\n        ar &gt;&gt; pkt-&gt;time_base.num;\n        ar &gt;&gt; pkt-&gt;time_base.den;\n        ar &gt;&gt; pkt-&gt;side_data_elems;\n        pkt-&gt;side_data = (AVPacketSideData*) malloc(sizeof(AVPacketSideData) * pkt-&gt;side_data_elems);\n        for (int i = 0; i &lt; pkt-&gt;side_data_elems; i++) {\n            ar &gt;&gt; pkt-&gt;side_data[i].type;\n            ar &gt;&gt; pkt-&gt;side_data[i].size;\n            pkt-&gt;side_data[i].data = (uint8_t*) malloc(pkt-&gt;side_data[i].size);\n            ar &gt;&gt; boost::serialization::make_array(pkt-&gt;side_data[i].data, pkt-&gt;side_data[i].size);\n        }\n    }\n#endif\n\n    template&lt;class Archive&gt;\n    void save(Archive&amp; ar, const unsigned int version) const {\n        (void) version;\n        ar &lt;&lt; boost::serialization::base_object&lt;switchboard::event&gt;(*this);\n        ar &lt;&lt; nalu_only;\n        ar &lt;&lt; use_depth;\n#ifdef ILLIXR_LIBAV\n        if (nalu_only) {\n            ar &lt;&lt; left_color-&gt;size;\n            ar &lt;&lt; right_color-&gt;size;\n            ar &lt;&lt; boost::serialization::make_array(left_color-&gt;data, left_color-&gt;size);\n            ar &lt;&lt; boost::serialization::make_array(right_color-&gt;data, right_color-&gt;size);\n            if (use_depth) {\n                ar &lt;&lt; left_depth-&gt;size;\n                ar &lt;&lt; right_depth-&gt;size;\n                ar &lt;&lt; boost::serialization::make_array(left_depth-&gt;data, left_depth-&gt;size);\n                ar &lt;&lt; boost::serialization::make_array(right_depth-&gt;data, right_depth-&gt;size);\n            }\n        } else {\n            save_packet(ar, left_color);\n            save_packet(ar, right_color);\n            if (use_depth) {\n                save_packet(ar, left_depth);\n                save_packet(ar, right_depth);\n            }\n        }\n#else\n        assert(false &amp;&amp; \"Not compiled with libav\");\n#endif\n\n        ar &lt;&lt; pose;\n        ar &lt;&lt; sent_time;\n        ar &lt;&lt; magic;\n    }\n\n    template&lt;class Archive&gt;\n    void load(Archive&amp; ar, const unsigned int version) {\n        (void) version;\n        ar &gt;&gt; boost::serialization::base_object&lt;switchboard::event&gt;(*this);\n        ar &gt;&gt; nalu_only;\n        ar &gt;&gt; use_depth;\n        if (nalu_only) {\n            ar &gt;&gt; left_color_nalu_size;\n            ar &gt;&gt; right_color_nalu_size;\n            left_color_nalu  = (char*) malloc(left_color_nalu_size);\n            right_color_nalu = (char*) malloc(right_color_nalu_size);\n            ar &gt;&gt; boost::serialization::make_array(left_color_nalu, left_color_nalu_size);\n            ar &gt;&gt; boost::serialization::make_array(right_color_nalu, right_color_nalu_size);\n            if (use_depth) {\n                ar &gt;&gt; left_depth_nalu_size;\n                ar &gt;&gt; right_depth_nalu_size;\n                left_depth_nalu  = (char*) malloc(left_depth_nalu_size);\n                right_depth_nalu = (char*) malloc(right_depth_nalu_size);\n                ar &gt;&gt; boost::serialization::make_array(left_depth_nalu, left_depth_nalu_size);\n                ar &gt;&gt; boost::serialization::make_array(right_depth_nalu, right_depth_nalu_size);\n            }\n        } else {\n#ifdef ILLIXR_LIBAV\n\n            left_color = av_packet_alloc();\n            load_packet(ar, left_color);\n            right_color = av_packet_alloc();\n            load_packet(ar, right_color);\n            if (use_depth) {\n                left_depth = av_packet_alloc();\n                load_packet(ar, left_depth);\n                right_depth = av_packet_alloc();\n                load_packet(ar, right_depth);\n            }\n#else\n            assert(false &amp;&amp; \"Not compiled with libav\");\n#endif\n        }\n\n        ar &gt;&gt; pose;\n        ar &gt;&gt; sent_time;\n        ar &gt;&gt; magic;\n        if (magic != 0xdeadbeef) {\n            throw std::runtime_error(\"Magic number mismatch\");\n        }\n    }\n\n    BOOST_SERIALIZATION_SPLIT_MEMBER()\n\n    compressed_frame() = default;\n\n#ifdef ILLIXR_LIBAV\n    compressed_frame(AVPacket* left_color, AVPacket* right_color, const fast_pose_type&amp; pose, uint64_t sent_time,\n                     bool nalu_only = false)\n        : nalu_only(nalu_only)\n        , use_depth(false)\n        , left_color(left_color)\n        , right_color(right_color)\n        , left_depth(nullptr)\n        , right_depth(nullptr)\n        , pose(pose)\n        , sent_time(sent_time)\n        , magic(0xdeadbeef) { }\n\n    compressed_frame(AVPacket* left_color, AVPacket* right_color, AVPacket* left_depth, AVPacket* right_depth,\n                     const fast_pose_type&amp; pose, uint64_t sent_time, bool nalu_only = false)\n        : nalu_only(nalu_only)\n        , use_depth(true)\n        , left_color(left_color)\n        , right_color(right_color)\n        , left_depth(left_depth)\n        , right_depth(right_depth)\n        , pose(pose)\n        , sent_time(sent_time)\n        , magic(0xdeadbeef) { }\n#endif\n    ~compressed_frame() {\n        if (nalu_only &amp;&amp; left_color_nalu != nullptr &amp;&amp; right_color_nalu != nullptr) {\n            free(left_color_nalu);\n            free(right_color_nalu);\n            if (use_depth) {\n                free(left_depth_nalu);\n                free(right_depth_nalu);\n            }\n        }\n    }\n};\n\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#a","title":"a","text":"<ul> <li>assign_matrix (utils.hpp)</li> <li>add_library (CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt)</li> </ul>"},{"location":"api/functions/#c","title":"c","text":"<ul> <li>count_duration (cpu_timer.hpp)</li> <li>cpp_clock_get_time (cpu_timer.hpp)</li> <li>check_plugins (plugin.cpp)</li> <li>cmake_minimum_required (CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt)</li> </ul>"},{"location":"api/functions/#e","title":"e","text":"<ul> <li>ends_with (capture_main.cpp)</li> </ul>"},{"location":"api/functions/#f","title":"f","text":"<ul> <li>find_package (CMakeLists.txt, CMakeLists.txt, CMakeLists.txt)</li> </ul>"},{"location":"api/functions/#g","title":"g","text":"<ul> <li>gen_serial_no (cpu_timer.hpp)</li> <li>glfw_error_callback (plugin.cpp, plugin.cpp, capture.cpp)</li> <li>get_home_dir (plugin.cpp)</li> <li>get_external_for_plugin (CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt)</li> </ul>"},{"location":"api/functions/#i","title":"i","text":"<ul> <li>init_and_link (shader_util.hpp)</li> <li>image_type_string (plugin.cpp)</li> <li>if (CMakeLists.txt)</li> </ul>"},{"location":"api/functions/#l","title":"l","text":"<ul> <li>load_data (data_loading.hpp)</li> <li>look_at (plugin.cpp)</li> <li>load_align_parameters (utils.hpp)</li> </ul>"},{"location":"api/functions/#m","title":"m","text":"<ul> <li>message_callback (shader_util.hpp)</li> <li>make_map (plugin.cpp)</li> <li>main (capture_main.cpp, main.cpp)</li> </ul>"},{"location":"api/functions/#n","title":"n","text":"<ul> <li>needs_monado (plugin.hpp)</li> </ul>"},{"location":"api/functions/#o","title":"o","text":"<ul> <li>operator&gt;&gt; (csv_iterator.hpp)</li> <li>operator&lt;&lt; (files.cpp, files.hpp)</li> <li>ori_inv (utils.hpp)</li> <li>ori_multiply (utils.hpp)</li> <li>operator+ (illixr.hpp)</li> </ul>"},{"location":"api/functions/#p","title":"p","text":"<ul> <li>pkg_check_modules (CMakeLists.txt)</li> </ul>"},{"location":"api/functions/#r","title":"r","text":"<ul> <li>read_data (plugin.cpp, plugin.cpp, plugin.cpp, service.cpp)</li> <li>read_line (utils.hpp)</li> <li>runtime_factory (runtime_impl.cpp)</li> </ul>"},{"location":"api/functions/#s","title":"s","text":"<ul> <li>slMat_to_cvMat (zed_opencv.hpp)</li> <li>skew_x (utils.hpp)</li> <li>sigabrt_handler (main.cpp)</li> <li>sigill_handler (main.cpp)</li> <li>sigint_handler (main.cpp)</li> <li>spdlogger (runtime_impl.cpp)</li> <li>set (CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt)</li> </ul>"},{"location":"api/functions/#t","title":"t","text":"<ul> <li>thread_cpu_time (cpu_timer.hpp, switchboard.hpp)</li> <li>timed_thread (cpu_timer.hpp)</li> <li>this_plugin_factory (plugin.cpp)</li> <li>transform_zed_pose (zed_camera_thread.cpp)</li> <li>target_compile_features (CMakeLists.txt, CMakeLists.txt)</li> <li>target_include_directories (CMakeLists.txt, CMakeLists.txt, CMakeLists.txt, CMakeLists.txt)</li> <li>target_compile_definitions (CMakeLists.txt)</li> <li>target_link_libraries (CMakeLists.txt)</li> </ul>"},{"location":"api/glfw__extended_8cpp/","title":"File glfw_extended.cpp","text":"<p>FileList &gt; display &gt; glfw_extended.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"glfw_extended.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> </ul>"},{"location":"api/glfw__extended_8cpp/#macros","title":"Macros","text":"Type Name define GLFW_INCLUDE_VULKAN"},{"location":"api/glfw__extended_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/glfw__extended_8cpp/#define-glfw_include_vulkan","title":"define GLFW_INCLUDE_VULKAN","text":"<pre><code>#define GLFW_INCLUDE_VULKAN \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/glfw_extended.cpp</code></p>"},{"location":"api/glfw__extended_8cpp_source/","title":"File glfw_extended.cpp","text":"<p>File List &gt; display &gt; glfw_extended.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#define GLFW_INCLUDE_VULKAN\n#include \"glfw_extended.hpp\"\n\n#include \"illixr/error_util.hpp\"\n\n#include &lt;GLFW/glfw3.h&gt;\n\nusing namespace ILLIXR::display;\n\nvoid glfw_extended::setup_display(const std::shared_ptr&lt;switchboard&gt; sb, VkInstance vk_instance,\n                                  VkPhysicalDevice vk_physical_device) {\n    (void) sb;\n    (void) vk_physical_device;\n    this-&gt;vk_instance_ = vk_instance;\n}\n\nVkSurfaceKHR glfw_extended::create_surface() {\n    VkSurfaceKHR surface;\n    auto         ret = glfwCreateWindowSurface(vk_instance_, (GLFWwindow*) window_, nullptr, &amp;surface);\n    if (ret != VK_SUCCESS) {\n        // get the error code\n        auto err = glfwGetError(nullptr);\n        // print the error\n        std::cerr &lt;&lt; \"glfw error: \" &lt;&lt; err &lt;&lt; std::endl;\n\n        throw std::runtime_error(\"failed to create window surface!\");\n    }\n    return surface;\n}\n\nvoid glfw_extended::poll_window_events() {\n    glfwPollEvents();\n}\n\nstd::pair&lt;uint32_t, uint32_t&gt; glfw_extended::get_framebuffer_size() {\n    int width, height;\n    while (width == 0 || height == 0) {\n        glfwGetFramebufferSize((GLFWwindow*) window_, &amp;width, &amp;height);\n        glfwWaitEvents();\n    }\n    return {width, height};\n}\n\nvoid glfw_extended::cleanup() {\n    // The display backend is always responsible for terminating GLFW.\n    glfwDestroyWindow((GLFWwindow*) window_);\n    glfwTerminate();\n}\n\nstd::set&lt;const char*&gt; glfw_extended::get_required_instance_extensions() {\n    uint32_t     glfwExtensionCount = 0;\n    const char** glfwExtensions;\n    glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);\n    std::set&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);\n    return extensions;\n}\n\nglfw_extended::glfw_extended() {\n    if (!glfwInit()) {\n        ILLIXR::abort(\"Failed to initialize glfw\");\n    }\n\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);\n\n    window_ = glfwCreateWindow(display_params::width_pixels, display_params::height_pixels, \"ILLIXR Eyebuffer Window (Vulkan)\",\n                               nullptr, nullptr);\n}\n\nstd::set&lt;const char*&gt; glfw_extended::get_required_device_extensions() {\n    return {};\n}\n\ndisplay_backend::display_backend_type glfw_extended::get_type() {\n    return GLFW;\n}\n</code></pre>"},{"location":"api/glfw__extended_8hpp/","title":"File glfw_extended.hpp","text":"<p>FileList &gt; display &gt; glfw_extended.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"display_backend.hpp\"</code></li> </ul>"},{"location":"api/glfw__extended_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace display"},{"location":"api/glfw__extended_8hpp/#classes","title":"Classes","text":"Type Name class glfw_extended <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/glfw_extended.hpp</code></p>"},{"location":"api/glfw__extended_8hpp_source/","title":"File glfw_extended.hpp","text":"<p>File List &gt; display &gt; glfw_extended.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"display_backend.hpp\"\n\nnamespace ILLIXR::display {\n\nclass glfw_extended : public display_backend {\npublic:\n    glfw_extended();\n    void setup_display(const std::shared_ptr&lt;switchboard&gt; sb, VkInstance vk_instance,\n                       VkPhysicalDevice vk_physical_device) override;\n\n    static void poll_window_events();\n\n    std::pair&lt;uint32_t, uint32_t&gt; get_framebuffer_size();\n    void                          cleanup() override;\n    std::set&lt;const char*&gt;         get_required_instance_extensions() override;\n    std::set&lt;const char*&gt;         get_required_device_extensions() override;\n    display_backend_type          get_type() override;\n\nprivate:\n    VkSurfaceKHR create_surface() override;\n\n    void* window_ = nullptr;\n};\n\n} // namespace ILLIXR::display\n</code></pre>"},{"location":"api/global__module__defs_8hpp/","title":"File global_module_defs.hpp","text":"<p>FileList &gt; illixr &gt; global_module_defs.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"relative_clock.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/global__module__defs_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/global__module__defs_8hpp/#classes","title":"Classes","text":"Type Name struct display_params Display parameters. struct index_params struct rendering_params Rendering parameters. struct server_params <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/global__module__defs_8hpp_source/","title":"File global_module_defs.hpp","text":"<p>File List &gt; illixr &gt; global_module_defs.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Common parameters. Ultimately, these need to be moved to a yaml file.\n#pragma once\n\n#include \"relative_clock.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace ILLIXR {\n\nstruct display_params {\n    // Display width in pixels\n    static constexpr unsigned width_pixels = 2880;\n\n    // Display height in pixels\n    static constexpr unsigned height_pixels = 1600;\n\n    // Display width in meters\n    static constexpr float width_meters = 0.11047f;\n\n    // Display height in meters\n    static constexpr float height_meters = 0.06214f;\n\n    // Separation between lens centers in meters\n    static constexpr float lens_separation = 0.05;\n\n    // Vertical position of the lens in meters\n    [[maybe_unused]] static constexpr float lens_vertical_position = height_meters / 2.0f;\n\n    // Display horizontal field-of-view in degrees\n    static constexpr float fov_x = 108.06f;\n\n    // Display vertical field-of-view in degrees\n    static constexpr float fov_y = 109.16f;\n\n    // Meters per tangent angle at the center of the HMD (required by timewarp_gl's distortion correction)\n    static constexpr float meters_per_tan_angle = width_meters / (2 * (fov_x * M_PI / 180.0f));\n\n    // Inter-pupilary distance (ipd) in meters\n    static constexpr float ipd = 0.064f;\n\n    // Display refresh rate in Hz\n    static constexpr float frequency = 144.0f;\n\n    // Display period in nanoseconds\n    static constexpr duration period = freq_to_period(frequency);\n\n    // Chromatic aberration constants\n    static constexpr float aberration[4] = {-0.016f, 0.0f, 0.024f, 0.0f};\n};\n\nstruct rendering_params {\n    // Near plane distance in meters\n    static constexpr float near_z = 0.1f;\n\n    // Far plane distance in meters\n    static constexpr float far_z = 20.0f;\n\n    static constexpr bool reverse_z = true;\n};\n\n// Offloading parameters - this really should be extended to everything though\nconstexpr float server_fov = 0.99;\n\nstruct server_params {\n    // static constexpr float fov_left[2] = {-server_fov, -server_fov};\n    // static constexpr float fov_right[2] = {server_fov, server_fov};\n    // static constexpr float fov_up[2] = {server_fov, server_fov};\n    // static constexpr float fov_down[2] = {-server_fov, -server_fov};\n    //\n    //    // The server can render at an arbitrary resolution\n    //    static constexpr unsigned width_pixels = 2160;\n    //    static constexpr unsigned height_pixels = 2400;\n\n    static constexpr float fov_left[2]  = {-0.907341, -0.897566};\n    static constexpr float fov_right[2] = {0.897500, 0.907700};\n    static constexpr float fov_up[2]    = {0.953644, 0.954293};\n    static constexpr float fov_down[2]  = {-0.953628, -0.952802};\n};\n\nstruct index_params {\n    static constexpr float fov_left[2]  = {-0.907341, -0.897566};\n    static constexpr float fov_right[2] = {0.897500, 0.907700};\n    static constexpr float fov_up[2]    = {0.953644, 0.954293};\n    static constexpr float fov_down[2]  = {-0.953628, -0.952802};\n};\n\n;\n\ninline bool str_to_bool(const std::string&amp; var) {\n    std::string temp = var;\n    std::transform(temp.begin(), temp.end(), temp.begin(), ::toupper);\n    if (temp.empty())\n        return false;\n    return (temp == \"TRUE\" || temp == \"1\") ? true\n        : (temp == \"FALSE\")                ? false\n                                           : throw std::runtime_error(\"Invalid conversion from std::string to bool\");\n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/hand__tracking__data_8hpp/","title":"File hand_tracking_data.hpp","text":"<p>FileList &gt; data_format &gt; hand_tracking_data.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"opencv_data_types.hpp\"</code></li> <li><code>#include \"point.hpp\"</code></li> <li><code>#include \"shape.hpp\"</code></li> <li><code>#include \"template.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;opencv4/opencv2/core/mat.hpp&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/hand__tracking__data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format namespace ht"},{"location":"api/hand__tracking__data_8hpp/#classes","title":"Classes","text":"Type Name struct hand_points struct ht_detection struct ht_frame struct position struct raw_ht_data struct velocity <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/hand__tracking__data_8hpp_source/","title":"File hand_tracking_data.hpp","text":"<p>File List &gt; data_format &gt; hand_tracking_data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/switchboard.hpp\"\n#include \"opencv_data_types.hpp\"\n#include \"point.hpp\"\n#include \"shape.hpp\"\n#include \"template.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;iomanip&gt;\n#include &lt;map&gt;\n#include &lt;opencv4/opencv2/core/mat.hpp&gt;\n#include &lt;sstream&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR::data_format {\nnamespace ht {\n    const int NUM_LANDMARKS = 21;\n\n    /*\n     * Enum for the landmark points on a hand\n     */\n    enum landmark_points : int {\n        WRIST,             // = 0,\n        THUMB_CMC,         // = 1,\n        THUMB_MCP,         // = 2,\n        THUMB_IP,          // = 3,\n        THUMB_TIP,         // = 4,\n        INDEX_FINGER_MCP,  // = 5,\n        INDEX_FINGER_PIP,  // = 6,\n        INDEX_FINGER_DIP,  // = 7,\n        INDEX_FINGER_TIP,  // = 8,\n        MIDDLE_FINGER_MCP, // = 9,\n        MIDDLE_FINGER_PIP, // = 10,\n        MIDDLE_FINGER_DIP, // = 11,\n        MIDDLE_FINGER_TIP, // = 12,\n        RING_FINGER_MCP,   // = 13,\n        RING_FINGER_PIP,   // = 14,\n        RING_FINGER_DIP,   // = 15,\n        RING_FINGER_TIP,   // = 16,\n        PINKY_MCP,         // = 17,\n        PINKY_PIP,         // = 18,\n        PINKY_DIP,         // = 19,\n        PINKY_TIP,         // = 20\n    };\n\n    const std::map&lt;int, std::string&gt; point_str_map{{WRIST, \"Wrist\"},\n                                                   {THUMB_CMC, \"Thumb CMC\"},\n                                                   {THUMB_MCP, \"Thumb MCP\"},\n                                                   {THUMB_IP, \"Thumb IP\"},\n                                                   {THUMB_TIP, \"Thumb Tip\"},\n                                                   {INDEX_FINGER_MCP, \"Index MCP\"},\n                                                   {INDEX_FINGER_PIP, \"Index PIP\"},\n                                                   {INDEX_FINGER_DIP, \"Index DIP\"},\n                                                   {INDEX_FINGER_TIP, \"Index Tip\"},\n                                                   {MIDDLE_FINGER_MCP, \"Middle MCP\"},\n                                                   {MIDDLE_FINGER_PIP, \"Middle PIP\"},\n                                                   {MIDDLE_FINGER_DIP, \"Middle DIP\"},\n                                                   {MIDDLE_FINGER_TIP, \"Middle Tip\"},\n                                                   {RING_FINGER_MCP, \"Ring MCP\"},\n                                                   {RING_FINGER_PIP, \"Ring PIP\"},\n                                                   {RING_FINGER_DIP, \"Ring DIP\"},\n                                                   {RING_FINGER_TIP, \"Ring Tip\"},\n                                                   {PINKY_MCP, \"Pinky MCP\"},\n                                                   {PINKY_PIP, \"Pinky PIP\"},\n                                                   {PINKY_DIP, \"Pinky DIP\"},\n                                                   {PINKY_TIP, \"Pinky Tip\"}};\n\n    enum hand : int { LEFT_HAND = 0, RIGHT_HAND = 1 };\n\n    const std::vector&lt;hand&gt; hand_map{LEFT_HAND, RIGHT_HAND};\n\n    struct hand_points : points_with_units {\n        explicit hand_points(units::measurement_unit unit_ = units::UNSET)\n            : points_with_units(NUM_LANDMARKS, unit_) { }\n\n        explicit hand_points(std::vector&lt;point_with_validity&gt;&amp; pnts, units::measurement_unit unit_ = units::UNSET)\n            : points_with_units(pnts, unit_) {\n            check();\n        }\n\n        explicit hand_points(std::vector&lt;point&gt;&amp; pnts, units::measurement_unit unit_ = units::UNSET, bool valid_ = true)\n            : points_with_units(pnts, unit_, valid_) {\n            check();\n        }\n\n        void check() {\n            if (points.size() &lt; NUM_LANDMARKS) {\n                std::cout &lt;&lt; \"Resizing to \" &lt;&lt; NUM_LANDMARKS &lt;&lt; std::endl;\n                points.resize(NUM_LANDMARKS);\n            } else if (points.size() &gt; NUM_LANDMARKS) {\n                std::cout &lt;&lt; \"Shrinking to \" &lt;&lt; NUM_LANDMARKS &lt;&lt; std::endl;\n                points.resize(NUM_LANDMARKS);\n            }\n        }\n\n        void clear() {\n            points.clear();\n        }\n\n        [[maybe_unused]] void flip_y(const uint im_height = 0) {\n            if (unit == units::PERCENT) {\n                for (auto&amp; pnt : points) {\n                    if (pnt.y() != 0.)\n                        pnt.y() = 1.0f - pnt.y();\n                }\n                return;\n            }\n            if (im_height == 0)\n                throw std::runtime_error(\"Cannot rectify point with non-percent units with no height given.\");\n            for (auto&amp; pnt : points) {\n                if (pnt.y() != 0.)\n                    pnt.y() = (float) im_height - pnt.y();\n            }\n        }\n    };\n\n    struct position {\n        std::map&lt;ht::hand, ht::hand_points&gt; points;        \n        units::measurement_unit             unit;          \n        uint64_t                            time;          \n        bool                                valid = false; \n\n        position()\n            : points{}\n            , unit(units::measurement_unit::UNSET)\n            , time{0}\n            , valid{false} { }\n\n        position(const std::map&lt;ht::hand, ht::hand_points&gt;&amp; pnts, units::measurement_unit unit_, uint64_t time_)\n            : points{pnts}\n            , unit{unit_}\n            , time{time_}\n            , valid{true} { }\n    };\n\n    struct velocity : hand_points {\n        velocity()\n            : hand_points() { }\n\n        explicit velocity(units::measurement_unit unit)\n            : hand_points(unit) { }\n\n        velocity(const hand_points&amp; h1, const hand_points&amp; h2, const float time)\n            : hand_points() {\n            if (h1.unit != h2.unit)\n                throw std::runtime_error(\"Incompatible units in velocity calculation.\");\n\n            if (h1.points.size() != h2.points.size())\n                throw std::runtime_error(\"Differing number of points in velocity calculation\");\n\n            for (int i = WRIST; i != PINKY_TIP; i++) {\n                points[i] = (h2.at(i) - h1.at(i)) / time;\n            }\n            unit = h1.unit;\n        }\n    };\n\n    struct ht_detection {\n        size_t               proc_time; \n        std::map&lt;hand, rect&gt; palms;     \n        std::map&lt;hand, rect&gt; hands;     \n\n        std::map&lt;hand, float&gt; confidence; \n\n        std::map&lt;hand, hand_points&gt; points; \n\n        ht_detection()\n            : proc_time{0}\n            , palms{{LEFT_HAND, rect()}, {RIGHT_HAND, rect()}}\n            , hands{{LEFT_HAND, rect()}, {RIGHT_HAND, rect()}}\n            , confidence{{LEFT_HAND, 0.}, {RIGHT_HAND, 0.}}\n            , points{{LEFT_HAND, hand_points()}, {RIGHT_HAND, hand_points()}} { }\n\n        ht_detection(size_t ptime, rect* lp, rect* rp, rect* lh, rect* rh, float lc, float rc, hand_points* lhp,\n                     hand_points* rhp)\n            : proc_time{ptime}\n            , palms{{LEFT_HAND, (lp) ? *lp : rect()}, {RIGHT_HAND, (rp) ? *rp : rect()}}\n            , hands{{LEFT_HAND, (lh) ? *lh : rect()}, {RIGHT_HAND, (rh) ? *rh : rect()}}\n            , confidence{{LEFT_HAND, lc}, {RIGHT_HAND, rc}}\n            , points{{LEFT_HAND, (lhp) ? *lhp : hand_points()}, {RIGHT_HAND, (rhp) ? *rhp : hand_points()}} { }\n    };\n\n    struct ht_frame : cam_base_type {\n        std::map&lt;units::eyes, ht_detection&gt; detections;      \n        std::map&lt;ht::hand, hand_points&gt;     hand_positions;  \n        std::map&lt;ht::hand, velocity&gt;        hand_velocities; \n        pose_data                           wcs_offset;      \n        coordinates::reference_space        reference;       \n        units::measurement_unit             unit;            \n\n        ht_frame(time_point time, std::map&lt;image::image_type, cv::Mat&gt; images, std::map&lt;units::eyes, ht_detection&gt; _detections,\n                 std::map&lt;ht::hand, hand_points&gt; points, std::map&lt;ht::hand, velocity&gt; velocities = {}, pose_data _pose = {},\n                 coordinates::reference_space ref_sp = coordinates::VIEWER,\n                 units::measurement_unit      _unit  = units::measurement_unit::UNSET)\n            : cam_base_type(time, std::move(images), (images.size() == 2) ? camera::BINOCULAR : camera::MONOCULAR)\n            , detections(std::move(_detections))\n            , hand_positions{std::move(points)}\n            , hand_velocities{std::move(velocities)}\n            , wcs_offset{std::move(_pose)}\n            , reference{ref_sp}\n            , unit{_unit} {\n            if (wcs_offset.valid) {\n                unit = wcs_offset.unit;\n            } else if (hand_positions.count(LEFT_HAND) &gt; 0 &amp;&amp; hand_positions.at(LEFT_HAND).valid) {\n                unit = hand_positions.at(LEFT_HAND).unit;\n            } else if (hand_positions.count(RIGHT_HAND) &gt; 0 &amp;&amp; hand_positions.at(RIGHT_HAND).valid) {\n                unit = hand_positions.at(RIGHT_HAND).unit;\n            } else {\n                unit = units::UNSET;\n            }\n        }\n    };\n\n#ifdef ENABLE_OXR\n    /*\n     * This struct is utilized when working with OpenXR. The internal variables are in a basic form since OpenXR uses\n     * C, rather than C++ (e.g. vectors are replaced with arrays)\n     */\n    struct raw_ht_data {\n        uint64_t                     time;                                         \n        raw_point                    h_points[2][NUM_LANDMARKS];                   \n        raw_point                    h_velocities[2][NUM_LANDMARKS];               \n        raw_pose                     wcs_origin;                                   \n        coordinates::reference_space reference   = coordinates::VIEWER;            \n        units::measurement_unit      unit        = units::measurement_unit::UNSET; \n        coordinates::frame           frame       = coordinates::RIGHT_HANDED_Y_UP; \n        bool                         hp_valid[2] = {false, false};                 \n        bool                         hv_valid[2] = {false, false};                 \n        bool                         valid       = false;                          \n\n        raw_ht_data()\n            : time{0} { }\n\n        raw_ht_data(const time_point time, const std::map&lt;ht::hand, hand_points&gt;&amp; points,\n                    const std::map&lt;ht::hand, velocity&gt;&amp; velocities, const pose_data&amp; pose,\n                    coordinates::reference_space ref_sp = coordinates::VIEWER,\n                    units::measurement_unit      _unit  = units::measurement_unit::UNSET)\n            : time{static_cast&lt;uint64_t&gt;(time.time_since_epoch().count())}\n            , reference{ref_sp}\n            , unit{_unit}\n            , valid{true} {\n            for (auto i = 0; i &lt; NUM_LANDMARKS; i++) {\n                h_points[LEFT_HAND][i].copy(points.at(LEFT_HAND).at(i));\n                hp_valid[LEFT_HAND] |= points.at(LEFT_HAND).at(i).valid;\n                h_points[RIGHT_HAND][i].copy(points.at(RIGHT_HAND).at(i));\n                hp_valid[RIGHT_HAND] |= points.at(RIGHT_HAND).at(i).valid;\n                h_velocities[LEFT_HAND][i].copy(velocities.at(LEFT_HAND).at(i));\n                hv_valid[LEFT_HAND] |= velocities.at(LEFT_HAND).at(i).valid;\n                h_velocities[RIGHT_HAND][i].copy(velocities.at(RIGHT_HAND).at(i));\n                hv_valid[RIGHT_HAND] |= velocities.at(RIGHT_HAND).at(i).valid;\n            }\n\n            wcs_origin.copy(pose);\n\n            if (unit == units::measurement_unit::UNSET) {\n                if (pose.valid) {\n                    unit = pose.unit;\n                } else if (points.count(LEFT_HAND) &gt; 0 &amp;&amp; points.at(LEFT_HAND).valid) {\n                    unit = points.at(LEFT_HAND).unit;\n                } else if (points.count(RIGHT_HAND) &gt; 0 &amp;&amp; points.at(RIGHT_HAND).valid) {\n                    unit = points.at(RIGHT_HAND).unit;\n                }\n            }\n        }\n\n        explicit raw_ht_data(const ht_frame&amp; frame_)\n            : raw_ht_data(frame_.time, frame_.hand_positions, frame_.hand_velocities, frame_.wcs_offset, frame_.reference,\n                          frame_.unit) { }\n\n        void copy(const ht_frame&amp; frame_) {\n            time      = static_cast&lt;uint64_t&gt;(frame_.time.time_since_epoch().count());\n            reference = frame_.reference;\n            unit      = frame_.unit;\n\n            for (auto i = 0; i &lt; NUM_LANDMARKS; i++) {\n                h_points[LEFT_HAND][i].copy(frame_.hand_positions.at(LEFT_HAND).at(i));\n                hp_valid[LEFT_HAND] = hp_valid[LEFT_HAND] || frame_.hand_positions.at(LEFT_HAND).at(i).valid;\n                h_points[RIGHT_HAND][i].copy(frame_.hand_positions.at(RIGHT_HAND).at(i));\n                hp_valid[RIGHT_HAND] = hp_valid[RIGHT_HAND] || frame_.hand_positions.at(RIGHT_HAND).at(i).valid;\n                h_velocities[LEFT_HAND][i].copy(frame_.hand_velocities.at(LEFT_HAND).at(i));\n                hv_valid[LEFT_HAND] = hv_valid[LEFT_HAND] || frame_.hand_velocities.at(LEFT_HAND).at(i).valid;\n                h_velocities[RIGHT_HAND][i].copy(frame_.hand_velocities.at(RIGHT_HAND).at(i));\n                hv_valid[RIGHT_HAND] = hv_valid[RIGHT_HAND] || frame_.hand_velocities.at(RIGHT_HAND).at(i).valid;\n            }\n\n            wcs_origin.copy(frame_.wcs_offset);\n        }\n    };\n\n    inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const raw_ht_data&amp; data) {\n        const auto def_precision{os.precision()};\n\n        os &lt;&lt; std::setprecision(6) &lt;&lt; \"HT Data\" &lt;&lt; std::endl &lt;&lt; \"  Time: \" &lt;&lt; data.time &lt;&lt; std::endl;\n        os &lt;&lt; \"  WCS origin: \";\n        if (data.wcs_origin.valid) {\n            os &lt;&lt; std::endl\n               &lt;&lt; \"    position: \" &lt;&lt; data.wcs_origin.x &lt;&lt; \", \" &lt;&lt; data.wcs_origin.y &lt;&lt; \", \" &lt;&lt; data.wcs_origin.z &lt;&lt; std::endl;\n            os &lt;&lt; \"    orientation: \" &lt;&lt; data.wcs_origin.w &lt;&lt; \", \" &lt;&lt; data.wcs_origin.wx &lt;&lt; \", \" &lt;&lt; data.wcs_origin.wy &lt;&lt; \", \"\n               &lt;&lt; data.wcs_origin.z;\n        } else {\n            os &lt;&lt; \"not valid\";\n        }\n        os &lt;&lt; std::endl &lt;&lt; \"  Ref space: \" &lt;&lt; data.reference &lt;&lt; std::endl;\n        os &lt;&lt; \"  Unit\" &lt;&lt; data.unit &lt;&lt; std::endl;\n        os &lt;&lt; \"  Left Hand:\";\n        if (data.hp_valid[LEFT_HAND]) {\n            for (auto i = 0; i &lt; NUM_LANDMARKS; i++) {\n                os &lt;&lt; std::endl\n                   &lt;&lt; \"    \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; data.h_points[LEFT_HAND][i].x &lt;&lt; \", \" &lt;&lt; data.h_points[LEFT_HAND][i].y &lt;&lt; \", \"\n                   &lt;&lt; data.h_points[LEFT_HAND][i].z &lt;&lt; \"  \" &lt;&lt; ((data.h_points[LEFT_HAND][i].valid) ? \"valid\" : \"not valid\");\n            }\n        } else {\n            os &lt;&lt; \"not valid\";\n        }\n        os &lt;&lt; std::endl &lt;&lt; \"  Right Hand:\";\n        if (data.hp_valid[RIGHT_HAND]) {\n            for (auto i = 0; i &lt; NUM_LANDMARKS; i++) {\n                os &lt;&lt; std::endl\n                   &lt;&lt; \"    \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; data.h_points[RIGHT_HAND][i].x &lt;&lt; \", \" &lt;&lt; data.h_points[RIGHT_HAND][i].y &lt;&lt; \", \"\n                   &lt;&lt; data.h_points[RIGHT_HAND][i].z &lt;&lt; \"  \" &lt;&lt; ((data.h_points[RIGHT_HAND][i].valid) ? \"valid\" : \"not valid\");\n            }\n        } else {\n            os &lt;&lt; \"not valid\";\n        }\n        os &lt;&lt; std::endl &lt;&lt; \"  Left Hand (vel):\";\n        if (data.hv_valid[LEFT_HAND]) {\n            for (auto i = 0; i &lt; NUM_LANDMARKS; i++) {\n                os &lt;&lt; std::endl\n                   &lt;&lt; \"    \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; data.h_velocities[LEFT_HAND][i].x &lt;&lt; \", \" &lt;&lt; data.h_velocities[LEFT_HAND][i].y\n                   &lt;&lt; \", \" &lt;&lt; data.h_velocities[LEFT_HAND][i].z &lt;&lt; \"  \"\n                   &lt;&lt; ((data.h_velocities[LEFT_HAND][i].valid) ? \"valid\" : \"not valid\");\n            }\n        } else {\n            os &lt;&lt; \"not valid\";\n        }\n        os &lt;&lt; std::endl &lt;&lt; \"  Right Hand (vel):\";\n        if (data.hv_valid[RIGHT_HAND]) {\n            for (auto i = 0; i &lt; NUM_LANDMARKS; i++) {\n                os &lt;&lt; std::endl\n                   &lt;&lt; \"    \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; data.h_velocities[RIGHT_HAND][i].x &lt;&lt; \", \" &lt;&lt; data.h_velocities[RIGHT_HAND][i].y\n                   &lt;&lt; \", \" &lt;&lt; data.h_velocities[RIGHT_HAND][i].z &lt;&lt; \"  \"\n                   &lt;&lt; ((data.h_velocities[RIGHT_HAND][i].valid) ? \"valid\" : \"not valid\");\n            }\n        } else {\n            os &lt;&lt; \"not valid\";\n        }\n        os &lt;&lt; std::endl &lt;&lt; std::endl;\n        os &lt;&lt; std::setprecision(def_precision);\n        return os;\n    }\n\n#endif\n\n    [[maybe_unused]] inline void transform_point(point_with_units&amp; pnt, const pose_data&amp; pose) {\n        Eigen::Vector3f new_pnt = pose.orientation * pnt;\n        pnt.set(new_pnt + pose.position);\n    }\n\n    [[maybe_unused]] inline static void transform_points(points_with_units&amp; points, const pose_data&amp; pose,\n                                                         coordinates::reference_space from, coordinates::reference_space to) {\n        if (to == from)\n            return;\n        if (to == coordinates::WORLD) {\n            for (auto&amp; point : points.points) {\n                Eigen::Vector3f newpnt = pose.orientation * point;\n                point.set(newpnt + pose.position);\n            }\n        } else {\n        }\n    }\n\n} // namespace ht\n\ntemplate&lt;&gt;\ninline void normalize&lt;ht::hand_points&gt;(ht::hand_points&amp; obj, const float width, const float height, const float depth) {\n    if (obj.unit == units::PERCENT) {\n        std::cout &lt;&lt; \"Points are already normalized\";\n        return;\n    }\n    for (auto&amp; pnt : obj.points)\n        normalize(pnt, width, height, depth);\n    obj.unit = units::PERCENT;\n}\n\ntemplate&lt;&gt;\ninline void denormalize&lt;ht::hand_points&gt;(ht::hand_points&amp; obj, const float width, const float height, const float depth,\n                                         units::measurement_unit unit_) {\n    for (auto&amp; pnt : obj.points)\n        denormalize(pnt, width, height, depth, unit_);\n    obj.unit = unit_;\n}\n\ntemplate&lt;&gt;\ninline void normalize&lt;ht::velocity&gt;(ht::velocity&amp; obj, const float width, const float height, const float depth) {\n    if (obj.unit == units::PERCENT) {\n        std::cout &lt;&lt; \"Points are already normalized\";\n        return;\n    }\n    for (auto&amp; pnt : obj.points)\n        normalize(pnt, width, height, depth);\n    obj.unit = units::PERCENT;\n}\n\ntemplate&lt;&gt;\ninline void denormalize&lt;ht::velocity&gt;(ht::velocity&amp; obj, const float width, const float height, const float depth,\n                                      units::measurement_unit unit_) {\n    for (auto&amp; pnt : obj.points)\n        denormalize(pnt, width, height, depth, unit_);\n    obj.unit = unit_;\n}\n\ntemplate&lt;&gt;\ninline void normalize&lt;ht::ht_detection&gt;(ht::ht_detection&amp; obj, const float width, const float height, const float depth) {\n    for (auto&amp; palm : obj.palms)\n        normalize(palm.second, width, height, depth);\n    for (auto&amp; hnd : obj.hands)\n        normalize(hnd.second, width, height, depth);\n    for (auto&amp; pnts : obj.points)\n        normalize(pnts.second, width, height, depth);\n}\n\ntemplate&lt;&gt;\n[[maybe_unused]] inline void normalize&lt;ht::ht_frame&gt;(ht::ht_frame&amp; obj, const float width, const float height,\n                                                     const float depth) {\n    for (auto&amp; det : obj.detections)\n        normalize(det.second, width, height, depth);\n    for (auto&amp; hp : obj.hand_positions)\n        normalize(hp.second, width, height, depth);\n    for (auto&amp; hv : obj.hand_velocities)\n        normalize(hv.second, width, height, depth);\n}\n\ntemplate&lt;&gt;\ninline void denormalize&lt;ht::ht_detection&gt;(ht::ht_detection&amp; obj, const float width, const float height, const float depth,\n                                          units::measurement_unit unit) {\n    for (auto&amp; palm : obj.palms)\n        denormalize(palm.second, width, height, depth, unit);\n    for (auto&amp; hnd : obj.hands)\n        denormalize(hnd.second, width, height, depth, unit);\n    for (auto&amp; pnts : obj.points)\n        denormalize(pnts.second, width, height, depth, unit);\n}\n\ntemplate&lt;&gt;\n[[maybe_unused]] inline void denormalize&lt;ht::ht_frame&gt;(ht::ht_frame&amp; obj, const float width, const float height,\n                                                       const float depth, units::measurement_unit unit) {\n    for (auto&amp; det : obj.detections)\n        denormalize(det.second, width, height, depth, unit);\n    for (auto&amp; hp : obj.hand_positions)\n        denormalize(hp.second, width, height, depth, unit);\n    for (auto&amp; hv : obj.hand_velocities)\n        denormalize(hv.second, width, height, depth, unit);\n}\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/headless_8cpp/","title":"File headless.cpp","text":"<p>FileList &gt; display &gt; headless.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"headless.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/headless.cpp</code></p>"},{"location":"api/headless_8cpp_source/","title":"File headless.cpp","text":"<p>File List &gt; display &gt; headless.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"headless.hpp\"\n\nusing namespace ILLIXR::display;\n\nvoid headless::setup_display(const std::shared_ptr&lt;switchboard&gt; sb, VkInstance vk_instance,\n                             VkPhysicalDevice vk_physical_device) {\n    (void) sb;\n    (void) vk_instance;\n    (void) vk_physical_device;\n}\n\nVkSurfaceKHR headless::create_surface() {\n    return VK_NULL_HANDLE;\n}\n\nvoid headless::cleanup() { }\n\nstd::set&lt;const char*&gt; headless::get_required_instance_extensions() {\n    return {};\n}\n\nstd::set&lt;const char*&gt; headless::get_required_device_extensions() {\n    return {};\n}\n\ndisplay_backend::display_backend_type headless::get_type() {\n    return HEADLESS;\n}\n</code></pre>"},{"location":"api/headless_8hpp/","title":"File headless.hpp","text":"<p>FileList &gt; display &gt; headless.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"display_backend.hpp\"</code></li> </ul>"},{"location":"api/headless_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace display"},{"location":"api/headless_8hpp/#classes","title":"Classes","text":"Type Name class headless <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/headless.hpp</code></p>"},{"location":"api/headless_8hpp_source/","title":"File headless.hpp","text":"<p>File List &gt; display &gt; headless.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"display_backend.hpp\"\n\nnamespace ILLIXR::display {\n\nclass headless : public display_backend {\npublic:\n    void                  setup_display(const std::shared_ptr&lt;switchboard&gt; sb, VkInstance vk_instance,\n                                        VkPhysicalDevice vk_physical_device) override;\n    VkSurfaceKHR          create_surface() override;\n    void                  cleanup() override;\n    std::set&lt;const char*&gt; get_required_instance_extensions() override;\n    std::set&lt;const char*&gt; get_required_device_extensions() override;\n    display_backend_type  get_type() override;\n};\n\n} // namespace ILLIXR::display\n</code></pre>"},{"location":"api/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class HMD </li> <li>class ILLIXR::cancellable_sleep </li> <li>class ILLIXR::phonebook::service A 'service' that can be registered in the phonebook. <ul> <li>class ILLIXR::data_format::pose_prediction <ul> <li>class ILLIXR::fauxpose_impl Create a \"pose_prediction\" type service. </li> <li>class ILLIXR::offload_rendering_server Main server implementation for offload rendering. </li> <li>class ILLIXR::pose_lookup_impl </li> <li>class ILLIXR::pose_prediction_impl </li> </ul> </li> <li>class ILLIXR::gen_guid This class generates unique IDs. </li> <li>class ILLIXR::network::network_backend <ul> <li>class ILLIXR::tcp_network_backend </li> </ul> </li> <li>class ILLIXR::record_logger The ILLIXR logging service for structured records. <ul> <li>class ILLIXR::sqlite_record_logger </li> <li>class ILLIXR::stdout_record_logger </li> </ul> </li> <li>class ILLIXR::relative_clock Relative clock for all of ILLIXR .</li> <li>class ILLIXR::stoplight Start/stop synchronization for the whole application. </li> <li>class ILLIXR::switchboard A manager for typesafe, threadsafe, named event-streams (called topics). </li> <li>class ILLIXR::vulkan::display_provider A display sink is a service that can display the rendered images to the screen. </li> <li>class ILLIXR::vulkan::render_pass <ul> <li>class ILLIXR::vulkan::app <ul> <li>class ILLIXR::offload_rendering_client </li> <li>class ILLIXR::vkdemo </li> </ul> </li> <li>class ILLIXR::vulkan::timewarp <ul> <li>class ILLIXR::offload_rendering_server Main server implementation for offload rendering. </li> <li>class ILLIXR::openwarp_vk </li> <li>class ILLIXR::timewarp_vk </li> </ul> </li> </ul> </li> <li>class ILLIXR::xlib_gl_extended_window </li> </ul> </li> <li>class ILLIXR::plugin A dynamically-loadable plugin for Spindle. <ul> <li>class ILLIXR::depthai </li> <li>class ILLIXR::fauxpose </li> <li>class ILLIXR::ground_truth_slam </li> <li>class ILLIXR::gtsam_integrator </li> <li>class ILLIXR::offload_data </li> <li>class ILLIXR::offload_rendering_server_loader Plugin loader for the offload rendering server. </li> <li>class ILLIXR::passthrough_integrator </li> <li>class ILLIXR::realsense </li> <li>class ILLIXR::record_imu_cam </li> <li>class ILLIXR::record_rgb_depth </li> <li>class ILLIXR::rk4_integrator </li> <li>class ILLIXR::server_writer </li> <li>class ILLIXR::tcp_network_backend </li> <li>class ILLIXR::threadloop A reusable threadloop for plugins. <ul> <li>class ILLIXR::data_injection </li> <li>class ILLIXR::debugview </li> <li>class ILLIXR::gldemo </li> <li>class ILLIXR::lighthouse </li> <li>class ILLIXR::native_renderer </li> <li>class ILLIXR::offline_cam </li> <li>class ILLIXR::offline_imu </li> <li>class ILLIXR::offload_reader </li> <li>class ILLIXR::offload_rendering_client </li> <li>class ILLIXR::offload_rendering_server Main server implementation for offload rendering. </li> <li>class ILLIXR::offload_writer </li> <li>class ILLIXR::openni_plugin </li> <li>class ILLIXR::openwarp_vk_plugin </li> <li>class ILLIXR::server_reader </li> <li>class ILLIXR::timewarp_gl </li> <li>class ILLIXR::timewarp_vk_plugin </li> <li>class ILLIXR::webcam </li> <li>class ILLIXR::zed_camera_thread </li> <li>class ILLIXR::zed_imu_thread </li> </ul> </li> <li>class ILLIXR::viewer </li> <li>class ILLIXR::vkdemo_plugin </li> <li>class offload_rendering_client_loader Plugin loader for the offload rendering client. </li> <li>class pose_lookup_plugin </li> <li>class pose_prediction_plugin </li> </ul> </li> <li>class ILLIXR::data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>class ILLIXR::display::display_backend <ul> <li>class ILLIXR::display::glfw_extended </li> <li>class ILLIXR::display::headless </li> <li>class ILLIXR::display::x11_direct </li> </ul> </li> <li>class ILLIXR::dynamic_lib </li> <li>class ILLIXR::event A boolean condition-variable. </li> <li>class ILLIXR::lazy_load_image </li> <li>class ILLIXR::managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. </li> <li>class ILLIXR::network::TCPSocket </li> <li>class ILLIXR::phonebook A service locator forILLIXR .</li> <li>class ILLIXR::record This class represents a tuple of fields which get logged by <code>record_logger</code> .</li> <li>class ILLIXR::record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class ILLIXR::record_header Schema of each record. </li> <li>class ILLIXR::runtime <ul> <li>class runtime_impl </li> </ul> </li> <li>class ILLIXR::sqlite_thread </li> <li>class ILLIXR::switchboard::buffered_reader </li> <li>class ILLIXR::switchboard::event Virtual class for event types. <ul> <li>struct ILLIXR::data_format::cam_base_type <ul> <li>struct ILLIXR::data_format::binocular_cam_type </li> <li>struct ILLIXR::data_format::cam_type_zed </li> <li>struct ILLIXR::data_format::depth_type </li> <li>struct ILLIXR::data_format::ht::ht_frame </li> <li>struct ILLIXR::data_format::monocular_cam_type </li> <li>struct ILLIXR::data_format::rgb_depth_type </li> </ul> </li> <li>struct ILLIXR::data_format::camera_data Data structure to hold information about the full camera system. This information is mostly constant. </li> <li>struct ILLIXR::data_format::compressed_frame </li> <li>struct ILLIXR::data_format::connection_signal </li> <li>struct ILLIXR::data_format::fast_pose_type </li> <li>struct ILLIXR::data_format::hologram_input </li> <li>struct ILLIXR::data_format::image_handle </li> <li>struct ILLIXR::data_format::imu_integrator_input </li> <li>struct ILLIXR::data_format::imu_raw_type </li> <li>struct ILLIXR::data_format::imu_type </li> <li>struct ILLIXR::data_format::pose_type </li> <li>struct ILLIXR::data_format::rendered_frame </li> <li>struct ILLIXR::data_format::signal_to_quad </li> <li>struct ILLIXR::data_format::texture_pose </li> <li>class ILLIXR::switchboard::event_wrapper Helper class for making event types. </li> </ul> </li> <li>class ILLIXR::switchboard::writer A handle which can publish events to a topic. <ul> <li>class ILLIXR::switchboard::network_writer </li> <li>class ILLIXR::switchboard::network_writer </li> <li>class ILLIXR::switchboard::network_writer </li> </ul> </li> <li>class ILLIXR::switchboard::reader A handle which can read the latest event on a topic. </li> <li>class ILLIXR::time_point </li> <li>class ILLIXR::video_decoder </li> <li>class ILLIXR::video_encoder </li> <li>class ILLIXR::zed_capture::capture </li> <li>class ILLIXR::zed_capture::files </li> <li>class ILLIXR::gtsam_integrator::pim_object Wrapper object protecting the lifetime of IMU integration inputs and biases. </li> <li>class ILLIXR::switchboard::coordinate_system Base coordinate system. </li> <li>class ILLIXR::switchboard::topic Represents a topic. </li> <li>class ILLIXR::switchboard::topic_buffer </li> <li>class ILLIXR::switchboard::topic_subscription Represents a single topic_subscription (callback and queue) </li> <li>class csv_iterator </li> <li>class csv_row </li> <li>class cxxopts::KeyValue </li> <li>class cxxopts::OptionAdder </li> <li>class cxxopts::OptionDetails </li> <li>class cxxopts::OptionParser </li> <li>class cxxopts::OptionValue </li> <li>class cxxopts::Options </li> <li>class cxxopts::ParseResult </li> <li>class cxxopts::ParseResult::Iterator </li> <li>class offload_rendering_client Main client implementation for offload rendering. </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_timer::print_in_destructor </li> <li>class should_profile_class </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> <li>struct HMD::hmd_info_t </li> <li>struct HMD::mesh_coord2d_t </li> <li>struct HMD::mesh_coord3d_t </li> <li>struct HMD::uv_coord_t </li> <li>struct ILLIXR::Dependency </li> <li>struct ILLIXR::DistortionCorrectionVertex </li> <li>struct ILLIXR::DistortionMatrix </li> <li>struct ILLIXR::OpenWarpVertex </li> <li>struct ILLIXR::WarpMatrices </li> <li>struct ILLIXR::data_format::ccd_data A data structure to hold relevant camera information. This information is constant (per camera) </li> <li>struct ILLIXR::data_format::hmd_physical_info </li> <li>struct ILLIXR::data_format::ht::ht_detection </li> <li>struct ILLIXR::data_format::ht::position </li> <li>struct ILLIXR::data_format::ht::raw_ht_data </li> <li>struct ILLIXR::data_format::imu_params </li> <li>struct ILLIXR::data_format::points_with_units <ul> <li>struct ILLIXR::data_format::ht::hand_points <ul> <li>struct ILLIXR::data_format::ht::velocity </li> </ul> </li> </ul> </li> <li>struct ILLIXR::data_format::pose_data <ul> <li>struct ILLIXR::data_format::pose_type </li> </ul> </li> <li>struct ILLIXR::data_format::raw_point </li> <li>struct ILLIXR::data_format::raw_pose </li> <li>struct ILLIXR::data_format::rect </li> <li>struct ILLIXR::data_format::vk_image_handle </li> <li>struct ILLIXR::display_params Display parameters. </li> <li>struct ILLIXR::index_params </li> <li>struct ILLIXR::model </li> <li>struct ILLIXR::network::topic_config </li> <li>struct ILLIXR::raw_imu_type </li> <li>struct ILLIXR::rendering_params Rendering parameters. </li> <li>struct ILLIXR::sensor_types </li> <li>struct ILLIXR::server_params </li> <li>struct ILLIXR::state_plus </li> <li>struct ILLIXR::texture </li> <li>struct ILLIXR::vertex </li> <li>struct ILLIXR::vulkan::buffer_pool </li> <li>struct ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame </li> <li>struct ILLIXR::vulkan::queue </li> <li>struct ILLIXR::vulkan::queue_families </li> <li>struct ILLIXR::vulkan::swapchain_details </li> <li>struct ILLIXR::vulkan::vk_image </li> <li>struct ILLIXR::realsense::accel_type </li> <li>struct YAML::convert&lt; ILLIXR::Dependency &gt; </li> <li>struct cxxopts::HelpGroupDetails </li> <li>struct cxxopts::HelpOptionDetails </li> <li>struct cxxopts::Option </li> <li>struct cxxopts::values::detail::SignedCheck </li> <li>struct cxxopts::values::detail::SignedCheck&lt; T, false &gt; </li> <li>struct cxxopts::values::detail::SignedCheck&lt; T, true &gt; </li> <li>struct cxxopts::values::parser_tool::ArguDesc </li> <li>struct cxxopts::values::parser_tool::IntegerDesc </li> <li>struct cxxopts::values::type_is_container </li> <li>struct cxxopts::values::type_is_container&lt; std::vector&lt; T &gt; &gt; </li> <li>struct model_push_constant </li> <li>struct std::hash&lt; vertex &gt; </li> <li>struct uniform_buffer_object </li> <li>struct vertex </li> <li>class Eigen::Quaternion&lt; Scalar_, Eigen::AutoAlign &gt; <ul> <li>class ILLIXR::data_format::proper_quaternion A more complete implementation of the Eigen::Quaternion. </li> </ul> </li> <li>class ILLIXR::display::display_backend <ul> <li>class ILLIXR::display::glfw_extended </li> <li>class ILLIXR::display::headless </li> <li>class ILLIXR::display::x11_direct </li> </ul> </li> <li>class ILLIXR::data_format::pose_prediction <ul> <li>class ILLIXR::fauxpose_impl Create a \"pose_prediction\" type service. </li> <li>class ILLIXR::offload_rendering_server Main server implementation for offload rendering. </li> <li>class ILLIXR::pose_lookup_impl </li> <li>class ILLIXR::pose_prediction_impl </li> </ul> </li> <li>class ILLIXR::vulkan::app <ul> <li>class ILLIXR::offload_rendering_client </li> <li>class ILLIXR::vkdemo </li> </ul> </li> <li>class ILLIXR::vulkan::timewarp <ul> <li>class ILLIXR::offload_rendering_server Main server implementation for offload rendering. </li> <li>class ILLIXR::openwarp_vk </li> <li>class ILLIXR::timewarp_vk </li> </ul> </li> <li>class std::enable_shared_from_this&lt; plugin &gt; <ul> <li>class ILLIXR::offload_rendering_server Main server implementation for offload rendering. </li> </ul> </li> <li>class vulkan::vk_extension_request <ul> <li>class ILLIXR::offload_rendering_server_loader Plugin loader for the offload rendering server. </li> <li>class offload_rendering_client_loader Plugin loader for the offload rendering client. </li> </ul> </li> <li>class ILLIXR::network::network_backend <ul> <li>class ILLIXR::tcp_network_backend </li> </ul> </li> <li>class ILLIXR::vulkan::render_pass <ul> <li>class ILLIXR::vulkan::app <ul> <li>class ILLIXR::offload_rendering_client </li> <li>class ILLIXR::vkdemo </li> </ul> </li> <li>class ILLIXR::vulkan::timewarp <ul> <li>class ILLIXR::offload_rendering_server Main server implementation for offload rendering. </li> <li>class ILLIXR::openwarp_vk </li> <li>class ILLIXR::timewarp_vk </li> </ul> </li> </ul> </li> <li>class sl::Camera <ul> <li>class ILLIXR::zed_camera </li> </ul> </li> <li>class std::enable_shared_from_this&lt; Value &gt; <ul> <li>class cxxopts::Value <ul> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> </ul> </li> <li>class cxxopts::Value <ul> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> </ul> </li> </ul> </li> <li>class std::exception <ul> <li>class cxxopts::exceptions::exception <ul> <li>class cxxopts::exceptions::option_has_no_value </li> <li>class cxxopts::exceptions::option_has_no_value </li> <li>class cxxopts::exceptions::parsing <ul> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::requested_option_not_present </li> <li>class cxxopts::exceptions::requested_option_not_present </li> </ul> </li> <li>class cxxopts::exceptions::parsing <ul> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::requested_option_not_present </li> <li>class cxxopts::exceptions::requested_option_not_present </li> </ul> </li> <li>class cxxopts::exceptions::specification <ul> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::option_already_exists </li> <li>class cxxopts::exceptions::option_already_exists </li> </ul> </li> <li>class cxxopts::exceptions::specification <ul> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::option_already_exists </li> <li>class cxxopts::exceptions::option_already_exists </li> </ul> </li> </ul> </li> <li>class cxxopts::exceptions::exception <ul> <li>class cxxopts::exceptions::option_has_no_value </li> <li>class cxxopts::exceptions::option_has_no_value </li> <li>class cxxopts::exceptions::parsing <ul> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::requested_option_not_present </li> <li>class cxxopts::exceptions::requested_option_not_present </li> </ul> </li> <li>class cxxopts::exceptions::parsing <ul> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::requested_option_not_present </li> <li>class cxxopts::exceptions::requested_option_not_present </li> </ul> </li> <li>class cxxopts::exceptions::specification <ul> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::option_already_exists </li> <li>class cxxopts::exceptions::option_already_exists </li> </ul> </li> <li>class cxxopts::exceptions::specification <ul> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::option_already_exists </li> <li>class cxxopts::exceptions::option_already_exists </li> </ul> </li> </ul> </li> </ul> </li> <li>class cxxopts::exceptions::parsing <ul> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::requested_option_not_present </li> <li>class cxxopts::exceptions::requested_option_not_present </li> </ul> </li> <li>class cxxopts::exceptions::specification <ul> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::option_already_exists </li> <li>class cxxopts::exceptions::option_already_exists </li> </ul> </li> <li>class cxxopts::exceptions::exception <ul> <li>class cxxopts::exceptions::option_has_no_value </li> <li>class cxxopts::exceptions::option_has_no_value </li> <li>class cxxopts::exceptions::parsing <ul> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::requested_option_not_present </li> <li>class cxxopts::exceptions::requested_option_not_present </li> </ul> </li> <li>class cxxopts::exceptions::parsing <ul> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::gratuitous_argument_for_option </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::incorrect_argument_type </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::invalid_option_syntax </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::missing_argument </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::no_such_option </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::option_requires_argument </li> <li>class cxxopts::exceptions::requested_option_not_present </li> <li>class cxxopts::exceptions::requested_option_not_present </li> </ul> </li> <li>class cxxopts::exceptions::specification <ul> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::option_already_exists </li> <li>class cxxopts::exceptions::option_already_exists </li> </ul> </li> <li>class cxxopts::exceptions::specification <ul> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::invalid_option_format </li> <li>class cxxopts::exceptions::option_already_exists </li> <li>class cxxopts::exceptions::option_already_exists </li> </ul> </li> </ul> </li> <li>class cxxopts::Value <ul> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class cxxopts::values::abstract_value <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> </ul> </li> <li>class cxxopts::values::abstract_value&lt; T &gt; <ul> <li>class cxxopts::values::standard_value </li> <li>class cxxopts::values::standard_value </li> </ul> </li> <li>class cxxopts::values::abstract_value&lt; bool &gt; <ul> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> <li>class cxxopts::values::standard_value&lt; bool &gt; </li> </ul> </li> <li>class vulkan::display_provider <ul> <li>class display_vk </li> </ul> </li> <li>class ILLIXR::runtime <ul> <li>class runtime_impl </li> </ul> </li> <li>class ILLIXR::data_format::points_with_units <ul> <li>struct ILLIXR::data_format::ht::hand_points <ul> <li>struct ILLIXR::data_format::ht::velocity </li> </ul> </li> <li>struct ILLIXR::data_format::ht::hand_points <ul> <li>struct ILLIXR::data_format::ht::velocity </li> </ul> </li> </ul> </li> <li>class Eigen::Vector3f <ul> <li>struct ILLIXR::data_format::point <ul> <li>struct ILLIXR::data_format::point_with_validity <ul> <li>struct ILLIXR::data_format::point_with_units </li> </ul> </li> </ul> </li> </ul> </li> <li>class ILLIXR::data_format::point_with_validity <ul> <li>struct ILLIXR::data_format::point_with_units </li> </ul> </li> <li>class ILLIXR::data_format::point <ul> <li>struct ILLIXR::data_format::point_with_validity <ul> <li>struct ILLIXR::data_format::point_with_units </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/hmd_8cpp/","title":"File hmd.cpp","text":"<p>FileList &gt; utils &gt; hmd.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/hmd.hpp\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/hmd.cpp</code></p>"},{"location":"api/hmd_8cpp_source/","title":"File hmd.cpp","text":"<p>File List &gt; utils &gt; hmd.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr/hmd.hpp\"\n\n#include &lt;cmath&gt;\n\nfloat HMD::max_float(const float x, const float y) {\n    return (x &gt; y) ? x : y;\n}\n\nfloat HMD::min_float(const float x, const float y) {\n    return (x &lt; y) ? x : y;\n}\n\n// A Catmull-Rom spline through the values K[0], K[1], K[2] ... K[num_knots-1] evenly spaced from 0.0 to 1.0\nfloat HMD::evaluate_catmull_rom_spline(float value, const float* K, int num_knots) {\n    const float scaled_value       = (float) (num_knots - 1) * value;\n    const float scaled_value_floor = max_float(0.0f, min_float((float) (num_knots - 1), floorf(scaled_value)));\n    const float t                  = scaled_value - scaled_value_floor;\n    const int   k                  = (int) scaled_value_floor;\n\n    float p0 = 0.0f;\n    float p1 = 0.0f;\n    float m0 = 0.0f;\n    float m1 = 0.0f;\n\n    if (k == 0) {\n        p0 = K[0];\n        m0 = K[1] - K[0];\n        p1 = K[1];\n        m1 = 0.5f * (K[2] - K[0]);\n    } else if (k &lt; num_knots - 2) {\n        p0 = K[k];\n        m0 = 0.5f * (K[k + 1] - K[k - 1]);\n        p1 = K[k + 1];\n        m1 = 0.5f * (K[k + 2] - K[k]);\n    } else if (k == num_knots - 2) {\n        p0 = K[k];\n        m0 = 0.5f * (K[k + 1] - K[k - 1]);\n        p1 = K[k + 1];\n        m1 = K[k + 1] - K[k];\n    } else if (k == num_knots - 1) {\n        p0 = K[k];\n        m0 = K[k] - K[k - 1];\n        p1 = p0 + m0;\n        m1 = m0;\n    }\n\n    const float omt = 1.0f - t;\n    const float res = (p0 * (1.0f + 2.0f * t) + m0 * t) * omt * omt + (p1 * (1.0f + 2.0f * omt) - m1 * omt) * t * t;\n    return res;\n}\n\n[[maybe_unused]] void\nHMD::build_distortion_meshes(std::array&lt;std::array&lt;std::vector&lt;mesh_coord2d_t&gt;, NUM_COLOR_CHANNELS&gt;, NUM_EYES&gt;&amp; distort_coords,\n                             hmd_info_t&amp;                                                                        hmd_info) {\n    const float horizontal_shift_meters = (hmd_info.lens_separation_in_meters / 2) - (hmd_info.visible_meters_wide / 4);\n    const float horizontal_shift_view   = horizontal_shift_meters / (hmd_info.visible_meters_wide / 2);\n\n    bool compare_images = std::getenv(\"ILLIXR_COMPARE_IMAGES\") != nullptr &amp;&amp; std::stoi(std::getenv(\"ILLIXR_COMPARE_IMAGES\"));\n\n    for (int eye = 0; eye &lt; NUM_EYES; eye++) {\n        for (int y = 0; y &lt;= hmd_info.eye_tiles_high; y++) {\n            const float yf = 1.0f - (float) y / (float) hmd_info.eye_tiles_high;\n\n            for (int x = 0; x &lt;= hmd_info.eye_tiles_wide; x++) {\n                const float xf = (float) x / (float) hmd_info.eye_tiles_wide;\n\n                const float in[2]               = {(eye ? -horizontal_shift_view : horizontal_shift_view) + xf, yf};\n                const float ndc_to_pixels[2]    = {static_cast&lt;float&gt;(hmd_info.visible_pixels_wide) * 0.25f,\n                                                   static_cast&lt;float&gt;(hmd_info.visible_pixels_high) * 0.5f};\n                const float pixels_to_meters[2] = {\n                    hmd_info.visible_meters_wide / static_cast&lt;float&gt;(hmd_info.visible_pixels_wide),\n                    hmd_info.visible_meters_high / static_cast&lt;float&gt;(hmd_info.visible_pixels_high)};\n\n                float theta[2];\n                for (int i = 0; i &lt; 2; i++) {\n                    const float unit      = in[i];\n                    const float ndc       = 2.0f * unit - 1.0f;\n                    const float pixels    = ndc * ndc_to_pixels[i];\n                    const float meters    = pixels * pixels_to_meters[i];\n                    const float tan_angle = meters / hmd_info.meters_per_tan_angle_at_center;\n                    theta[i]              = tan_angle;\n                }\n\n                const float rsq            = theta[0] * theta[0] + theta[1] * theta[1];\n                const float scale          = HMD::evaluate_catmull_rom_spline(rsq, hmd_info.K, hmd_info.num_knots);\n                const float chroma_scale[] = {\n                    scale * (1.0f + hmd_info.chromatic_aberration[0] + rsq * hmd_info.chromatic_aberration[1]), scale,\n                    scale * (1.0f + hmd_info.chromatic_aberration[2] + rsq * hmd_info.chromatic_aberration[3])};\n\n                const int vert_num = y * (hmd_info.eye_tiles_wide + 1) + x;\n                for (int channel = 0; channel &lt; NUM_COLOR_CHANNELS; channel++) {\n                    if (compare_images) {\n                        distort_coords[eye][channel][vert_num].x = theta[0];\n                        distort_coords[eye][channel][vert_num].y = theta[1];\n                    } else {\n                        distort_coords[eye][channel][vert_num].x = chroma_scale[channel] * theta[0];\n                        distort_coords[eye][channel][vert_num].y = chroma_scale[channel] * theta[1];\n                    }\n                }\n            }\n        }\n    }\n}\n\n[[maybe_unused]] void HMD::get_default_hmd_info(int display_pixels_wide, int display_pixels_high, float display_meters_wide,\n                                                float display_meters_high, float lens_separation, float meters_per_tan_angle,\n                                                const float aberration[4], hmd_info_t&amp; hmd_info) {\n    hmd_info.display_pixels_wide = display_pixels_wide;\n    hmd_info.display_pixels_high = display_pixels_high;\n    hmd_info.tile_pixels_wide    = 32;\n    hmd_info.tile_pixels_high    = 32;\n    hmd_info.eye_tiles_wide      = display_pixels_wide / hmd_info.tile_pixels_wide / NUM_EYES;\n    hmd_info.eye_tiles_high      = display_pixels_high / hmd_info.tile_pixels_high;\n    hmd_info.visible_pixels_wide = hmd_info.eye_tiles_wide * hmd_info.tile_pixels_wide * NUM_EYES;\n    hmd_info.visible_pixels_high = hmd_info.eye_tiles_high * hmd_info.tile_pixels_high;\n    hmd_info.visible_meters_wide = display_meters_wide *\n        static_cast&lt;float&gt;(hmd_info.eye_tiles_wide * hmd_info.tile_pixels_wide * NUM_EYES) /\n        static_cast&lt;float&gt;(display_pixels_wide);\n    hmd_info.visible_meters_high = display_meters_high *\n        static_cast&lt;float&gt;(hmd_info.eye_tiles_high * hmd_info.tile_pixels_high) / static_cast&lt;float&gt;(display_pixels_high);\n    hmd_info.lens_separation_in_meters      = lens_separation;\n    hmd_info.meters_per_tan_angle_at_center = meters_per_tan_angle;\n    hmd_info.num_knots                      = 11;\n    hmd_info.K[0]                           = 1.0f;\n    hmd_info.K[1]                           = 1.021f;\n    hmd_info.K[2]                           = 1.051f;\n    hmd_info.K[3]                           = 1.086f;\n    hmd_info.K[4]                           = 1.128f;\n    hmd_info.K[5]                           = 1.177f;\n    hmd_info.K[6]                           = 1.232f;\n    hmd_info.K[7]                           = 1.295f;\n    hmd_info.K[8]                           = 1.368f;\n    hmd_info.K[9]                           = 1.452f;\n    hmd_info.K[10]                          = 1.560f;\n    hmd_info.chromatic_aberration[0]        = aberration[0];\n    hmd_info.chromatic_aberration[1]        = aberration[1];\n    hmd_info.chromatic_aberration[2]        = aberration[2];\n    hmd_info.chromatic_aberration[3]        = aberration[3];\n}\n</code></pre>"},{"location":"api/illixr_8hpp/","title":"File illixr.hpp","text":"<p>FileList &gt; src &gt; illixr.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cxxopts.hpp\"</code></li> <li><code>#include \"illixr/runtime.hpp\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/illixr_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/illixr_8hpp/#classes","title":"Classes","text":"Type Name class cancellable_sleep"},{"location":"api/illixr_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr unsigned int ILLIXR_PRE_SLEEP_DURATION   = <code>{10}</code> constexpr std::chrono::seconds ILLIXR_RUN_DURATION_DEFAULT   = <code>{60}</code> ILLIXR::runtime * runtime_"},{"location":"api/illixr_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; T &gt; operator+ (const std::vector&lt; T &gt; &amp; a, const std::vector&lt; T &gt; &amp; b)"},{"location":"api/illixr_8hpp/#macros","title":"Macros","text":"Type Name define GET_BOOL (NAME, ENV) <code>/* multi line expression */</code> define GET_STRING (NAME, ENV) <code>/* multi line expression */</code> define STRINGIZE (x) <code>\\_STR(x)</code> define _STR (y) <code>#y</code>"},{"location":"api/illixr_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/illixr_8hpp/#variable-illixr_pre_sleep_duration","title":"variable ILLIXR_PRE_SLEEP_DURATION","text":"<pre><code>constexpr unsigned int ILLIXR_PRE_SLEEP_DURATION;\n</code></pre>"},{"location":"api/illixr_8hpp/#variable-illixr_run_duration_default","title":"variable ILLIXR_RUN_DURATION_DEFAULT","text":"<pre><code>constexpr std::chrono::seconds ILLIXR_RUN_DURATION_DEFAULT;\n</code></pre>"},{"location":"api/illixr_8hpp/#variable-runtime_","title":"variable runtime_","text":"<pre><code>ILLIXR::runtime* runtime_;\n</code></pre>"},{"location":"api/illixr_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/illixr_8hpp/#function-operator","title":"function operator+","text":"<pre><code>template&lt;typename T&gt;\nstd::vector&lt; T &gt; operator+ (\n    const std::vector&lt; T &gt; &amp; a,\n    const std::vector&lt; T &gt; &amp; b\n) \n</code></pre>"},{"location":"api/illixr_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/illixr_8hpp/#define-get_bool","title":"define GET_BOOL","text":"<pre><code>#define GET_BOOL (\n    NAME,\n    ENV\n) `/* multi line expression */`\n</code></pre>"},{"location":"api/illixr_8hpp/#define-get_string","title":"define GET_STRING","text":"<pre><code>#define GET_STRING (\n    NAME,\n    ENV\n) `/* multi line expression */`\n</code></pre>"},{"location":"api/illixr_8hpp/#define-stringize","title":"define STRINGIZE","text":"<pre><code>#define STRINGIZE (\n    x\n) `_STR(x)`\n</code></pre>"},{"location":"api/illixr_8hpp/#define-_str","title":"define _STR","text":"<pre><code>#define _STR (\n    y\n) `#y`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/illixr.hpp</code></p>"},{"location":"api/illixr_8hpp_source/","title":"File illixr.hpp","text":"<p>File List &gt; src &gt; illixr.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"cxxopts.hpp\"\n#include \"illixr/runtime.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\n#define GET_STRING(NAME, ENV)                                                     \\\n    if (options.count(#NAME)) {                                                   \\\n        switchboard_-&gt;set_env(#ENV, options[#NAME].as&lt;std::string&gt;());            \\\n    } else if (config[\"env_vars\"][#NAME]) {                                       \\\n        switchboard_-&gt;set_env(#ENV, config[\"env_vars\"][#NAME].as&lt;std::string&gt;()); \\\n    }\n\n#define GET_BOOL(NAME, ENV)                             \\\n    if (options.count(#NAME) || config[#NAME]) {        \\\n        bool val;                                       \\\n        if (options.count(#NAME)) {                     \\\n            val = options[#NAME].as&lt;bool&gt;();            \\\n        } else {                                        \\\n            val = config[\"env_vars\"][#NAME].as&lt;bool&gt;(); \\\n        }                                               \\\n        if (val) {                                      \\\n            switchboard_-&gt;set_env(#ENV, \"True\");        \\\n        } else {                                        \\\n            switchboard_-&gt;set_env(#ENV, \"False\");       \\\n        }                                               \\\n    }\n#define _STR(y)      #y\n#define STRINGIZE(x) _STR(x)\n\nconstexpr std::chrono::seconds          ILLIXR_RUN_DURATION_DEFAULT{60};\n[[maybe_unused]] constexpr unsigned int ILLIXR_PRE_SLEEP_DURATION{10};\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; operator+(const std::vector&lt;T&gt;&amp; a, const std::vector&lt;T&gt;&amp; b) {\n    std::vector&lt;T&gt; c = a;\n    c.insert(c.end(), b.begin(), b.end());\n    return c;\n}\n\nextern ILLIXR::runtime* runtime_;\n\nnamespace ILLIXR {\nint run(const cxxopts::ParseResult&amp; options);\n\nclass cancellable_sleep {\npublic:\n    template&lt;typename T, typename R&gt;\n    bool sleep(std::chrono::duration&lt;T, R&gt; duration) {\n        auto wake_up_time = std::chrono::system_clock::now() + duration;\n        while (!terminate_.load() &amp;&amp; std::chrono::system_clock::now() &lt; wake_up_time) {\n            std::this_thread::sleep_for(std::chrono::milliseconds{100});\n        }\n        return terminate_.load();\n    }\n\n    void cancel() {\n        terminate_.store(true);\n    }\n\nprivate:\n    std::atomic&lt;bool&gt; terminate_{false};\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/imu_8hpp/","title":"File imu.hpp","text":"<p>FileList &gt; data_format &gt; imu.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> </ul>"},{"location":"api/imu_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/imu_8hpp/#classes","title":"Classes","text":"Type Name struct imu_integrator_input struct imu_params struct imu_raw_type struct imu_type <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/imu.hpp</code></p>"},{"location":"api/imu_8hpp_source/","title":"File imu.hpp","text":"<p>File List &gt; data_format &gt; imu.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n\nnamespace ILLIXR::data_format {\nstruct [[maybe_unused]] imu_type : switchboard::event {\n    time_point      time;\n    Eigen::Vector3d angular_v;\n    Eigen::Vector3d linear_a;\n\n    imu_type(time_point time_, Eigen::Vector3d angular_v_, Eigen::Vector3d linear_a_)\n        : time{time_}\n        , angular_v{std::move(angular_v_)}\n        , linear_a{std::move(linear_a_)} { }\n};\n\n// Values needed to initialize the IMU integrator\ntypedef struct {\n    double                      gyro_noise;\n    double                      acc_noise;\n    double                      gyro_walk;\n    double                      acc_walk;\n    Eigen::Matrix&lt;double, 3, 1&gt; n_gravity;\n    double                      imu_integration_sigma;\n    double                      nominal_rate;\n} imu_params;\n\nstruct [[maybe_unused]] imu_integrator_input : public switchboard::event {\n    time_point last_cam_integration_time;\n    duration   t_offset;\n    imu_params params;\n\n    Eigen::Vector3d             bias_acc;\n    Eigen::Vector3d             bias_gyro;\n    Eigen::Matrix&lt;double, 3, 1&gt; position;\n    Eigen::Matrix&lt;double, 3, 1&gt; velocity;\n    Eigen::Quaterniond          quat;\n\n    imu_integrator_input(time_point last_cam_integration_time_, duration t_offset_, imu_params params_,\n                         Eigen::Vector3d biasAcc_, Eigen::Vector3d biasGyro_, Eigen::Matrix&lt;double, 3, 1&gt; position_,\n                         Eigen::Matrix&lt;double, 3, 1&gt; velocity_, Eigen::Quaterniond quat_)\n        : last_cam_integration_time{last_cam_integration_time_}\n        , t_offset{t_offset_}\n        , params{std::move(params_)}\n        , bias_acc{std::move(biasAcc_)}\n        , bias_gyro{std::move(biasGyro_)}\n        , position{std::move(position_)}\n        , velocity{std::move(velocity_)}\n        , quat{std::move(quat_)} { }\n};\n\nstruct [[maybe_unused]] imu_raw_type : public switchboard::event {\n    // Biases from the last two IMU integration iterations used by RK4 for pose predict\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat2;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat2;\n\n    // Faster pose propagated forwards by the IMU integrator\n    Eigen::Matrix&lt;double, 3, 1&gt; pos;\n    Eigen::Matrix&lt;double, 3, 1&gt; vel;\n    Eigen::Quaterniond          quat;\n    time_point                  imu_time;\n\n    imu_raw_type(Eigen::Matrix&lt;double, 3, 1&gt; w_hat_, Eigen::Matrix&lt;double, 3, 1&gt; a_hat_, Eigen::Matrix&lt;double, 3, 1&gt; w_hat2_,\n                 Eigen::Matrix&lt;double, 3, 1&gt; a_hat2_, Eigen::Matrix&lt;double, 3, 1&gt; pos_, Eigen::Matrix&lt;double, 3, 1&gt; vel_,\n                 Eigen::Quaterniond quat_, time_point imu_time_)\n        : w_hat{std::move(w_hat_)}\n        , a_hat{std::move(a_hat_)}\n        , w_hat2{std::move(w_hat2_)}\n        , a_hat2{std::move(a_hat2_)}\n        , pos{std::move(pos_)}\n        , vel{std::move(vel_)}\n        , quat{std::move(quat_)}\n        , imu_time{imu_time_} { }\n};\n\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/include_2illixr_2data__format_2serializable__data_8hpp/","title":"File serializable_data.hpp","text":"<p>FileList &gt; data_format &gt; serializable_data.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/frame.hpp\"</code></li> <li><code>#include &lt;boost/serialization/binary_object.hpp&gt;</code></li> </ul>"},{"location":"api/include_2illixr_2data__format_2serializable__data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace boost namespace serialization <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/serializable_data.hpp</code></p>"},{"location":"api/include_2illixr_2data__format_2serializable__data_8hpp_source/","title":"File serializable_data.hpp","text":"<p>File List &gt; data_format &gt; serializable_data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/frame.hpp\"\n\n#include &lt;boost/serialization/binary_object.hpp&gt;\n\nnamespace boost::serialization {\ntemplate&lt;class Archive&gt;\n[[maybe_unused]] void serialize(Archive&amp; ar, ILLIXR::time_point&amp; tp, const unsigned int version) {\n    (void) version;\n    ar&amp; boost::serialization::make_binary_object(&amp;tp.time_since_epoch_, sizeof(tp.time_since_epoch_));\n}\n\ntemplate&lt;class Archive&gt;\nvoid serialize(Archive&amp; ar, ILLIXR::data_format::pose_type&amp; pose, const unsigned int version) {\n    (void) version;\n    ar&amp; boost::serialization::base_object&lt;ILLIXR::switchboard::event&gt;(pose);\n    ar &amp; pose.sensor_time;\n    ar&amp; boost::serialization::make_array(pose.position.derived().data(), pose.position.size());\n    ar&amp; boost::serialization::make_array(pose.orientation.coeffs().data(), pose.orientation.coeffs().size());\n}\n\ntemplate&lt;class Archive&gt;\n[[maybe_unused]] void serialize(Archive&amp; ar, ILLIXR::data_format::fast_pose_type&amp; pose, const unsigned int version) {\n    (void) version;\n    ar&amp; boost::serialization::base_object&lt;ILLIXR::switchboard::event&gt;(pose);\n    ar &amp; pose.pose;\n    ar &amp; pose.predict_computed_time;\n    ar &amp; pose.predict_target_time;\n}\n} // namespace boost::serialization\n\nBOOST_CLASS_EXPORT_KEY(ILLIXR::switchboard::event)\nBOOST_CLASS_EXPORT_KEY(ILLIXR::data_format::compressed_frame)\nBOOST_CLASS_EXPORT_KEY(ILLIXR::data_format::pose_type)\nBOOST_CLASS_EXPORT_KEY(ILLIXR::data_format::fast_pose_type)\n</code></pre>"},{"location":"api/include_2illixr_2hmd_8hpp/","title":"File hmd.hpp","text":"<p>FileList &gt; illixr &gt; hmd.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/include_2illixr_2hmd_8hpp/#classes","title":"Classes","text":"Type Name class HMD struct hmd_info_t struct mesh_coord2d_t struct mesh_coord3d_t struct uv_coord_t"},{"location":"api/include_2illixr_2hmd_8hpp/#macros","title":"Macros","text":"Type Name define FLOAT <code>float</code>"},{"location":"api/include_2illixr_2hmd_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/include_2illixr_2hmd_8hpp/#define-float","title":"define FLOAT","text":"<pre><code>#define FLOAT `float`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/hmd.hpp</code></p>"},{"location":"api/include_2illixr_2hmd_8hpp_source/","title":"File hmd.hpp","text":"<p>File List &gt; illixr &gt; hmd.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;array&gt;\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#ifdef USE_GL\n    #include &lt;GL/gl.h&gt;\n    #define FLOAT GLfloat\n#else\n    #define FLOAT float\n#endif\n// HMD utility class for warp mesh structs, spline math, etc\nclass HMD {\npublic:\n    static constexpr int NUM_EYES           = 2;\n    static constexpr int NUM_COLOR_CHANNELS = 3;\n\n    struct mesh_coord2d_t {\n        FLOAT x;\n        FLOAT y;\n    };\n\n    struct [[maybe_unused]] mesh_coord3d_t {\n        FLOAT x;\n        FLOAT y;\n        FLOAT z;\n    };\n\n    struct [[maybe_unused]] uv_coord_t {\n        FLOAT u;\n        FLOAT v;\n    };\n\n    struct hmd_info_t {\n        [[maybe_unused]] int display_pixels_wide;\n        int                  display_pixels_high;\n        int                  tile_pixels_wide;\n        int                  tile_pixels_high;\n        int                  eye_tiles_wide;\n        int                  eye_tiles_high;\n        int                  visible_pixels_wide;\n        int                  visible_pixels_high;\n        float                visible_meters_wide;\n        float                visible_meters_high;\n        float                lens_separation_in_meters;\n        float                meters_per_tan_angle_at_center;\n        int                  num_knots;\n        float                K[11];\n        float                chromatic_aberration[4];\n    };\n\n    static float                 max_float(float x, float y);\n    static float                 min_float(float x, float y);\n    static float                 evaluate_catmull_rom_spline(float value, const float* K, int num_knots);\n    [[maybe_unused]] static void get_default_hmd_info(const int display_pixels_wide, const int display_pixels_high,\n                                                      const float display_meters_wide, const float display_meters_high,\n                                                      const float lens_separation, const float meters_per_tan_angle,\n                                                      const float aberration[4], hmd_info_t&amp; hmd_info);\n    [[maybe_unused]] static void\n    build_distortion_meshes(std::array&lt;std::array&lt;std::vector&lt;mesh_coord2d_t&gt;, NUM_COLOR_CHANNELS&gt;, NUM_EYES&gt;&amp; distort_coords,\n                            hmd_info_t&amp;                                                                        hmd_info);\n};\n</code></pre>"},{"location":"api/include_2illixr_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; illixr &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/common.h&gt;</code></li> <li><code>#include &lt;spdlog/sinks/basic_file_sink.h&gt;</code></li> <li><code>#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;typeinfo&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/include_2illixr_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/include_2illixr_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class plugin A dynamically-loadable plugin for Spindle."},{"location":"api/include_2illixr_2plugin_8hpp/#public-functions","title":"Public Functions","text":"Type Name bool needs_monado ()"},{"location":"api/include_2illixr_2plugin_8hpp/#macros","title":"Macros","text":"Type Name define PLUGIN_MAIN (PLUGIN_CLASS) <code>/* multi line expression */</code>"},{"location":"api/include_2illixr_2plugin_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/include_2illixr_2plugin_8hpp/#function-needs_monado","title":"function needs_monado","text":"<pre><code>bool needs_monado () \n</code></pre>"},{"location":"api/include_2illixr_2plugin_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/include_2illixr_2plugin_8hpp/#define-plugin_main","title":"define PLUGIN_MAIN","text":"<pre><code>#define PLUGIN_MAIN (\n    PLUGIN_CLASS\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/plugin.hpp</code></p>"},{"location":"api/include_2illixr_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; illixr &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n#include \"record_logger.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;spdlog/common.h&gt;\n#include &lt;spdlog/sinks/basic_file_sink.h&gt;\n#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n\n#ifndef DOUBLE_INCLUDE\nextern \"C\" {\nbool needs_monado() {\n    #ifdef MONADO_REQUIRED\n    return true;\n    #else\n    return false;\n    #endif\n}\n}\n#endif\n\nnamespace ILLIXR {\n\nusing plugin_id_t = std::size_t;\n\n/*\n * This gets included, but it is functionally 'private'.\n */\nconst record_header _plugin_start_header{\n    \"plugin_name\",\n    {\n        {\"plugin_id\", typeid(plugin_id_t)},\n        {\"plugin_name\", typeid(std::string)},\n    },\n};\n\nclass plugin {\npublic:\n    plugin(std::string name, phonebook* pb)\n        : name_{std::move(name)}\n        , phonebook_{pb}\n        , record_logger_{phonebook_-&gt;lookup_impl&lt;record_logger&gt;()}\n        , gen_guid_{phonebook_-&gt;lookup_impl&lt;gen_guid&gt;()}\n        , id_{gen_guid_-&gt;get()} { }\n\n    virtual ~plugin() = default;\n\n    virtual void start() {\n        record_logger_-&gt;log(record{_plugin_start_header,\n                                   {\n                                       {id_},\n                                       {name_},\n                                   }});\n    }\n\n    virtual void stop() {\n        if (plugin_logger_)\n            plugin_logger_-&gt;flush();\n    }\n\n    [[maybe_unused]] [[nodiscard]] std::string get_name() const noexcept {\n        return name_;\n    }\n\n    auto spdlogger(const char* log_level) {\n        if (!log_level) {\n#ifdef NDEBUG\n            log_level = \"warn\";\n#else\n            log_level = \"debug\";\n#endif\n        }\n        std::vector&lt;spdlog::sink_ptr&gt; sinks;\n        auto                          file_sink = std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(\"logs/\" + name_ + \".log\");\n        auto                          console_sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;();\n        sinks.push_back(file_sink);\n        sinks.push_back(console_sink);\n        if (spdlog::get(name_) == nullptr) {\n            plugin_logger_ = std::make_shared&lt;spdlog::logger&gt;(name_, begin(sinks), end(sinks));\n            plugin_logger_-&gt;set_level(spdlog::level::from_str(log_level));\n            spdlog::register_logger(plugin_logger_);\n        } else {\n            plugin_logger_ = spdlog::get(name_);\n        }\n        return plugin_logger_;\n    }\n\n    [[maybe_unused]] void spd_add_file_sink(const std::string&amp; file_name, const std::string&amp; extension,\n                                            const std::string&amp; log_level) {\n        if (!plugin_logger_) {\n            throw std::runtime_error(\"Logger not found\");\n        }\n\n        auto file_sink = std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(\"logs/\" + file_name + \".\" + extension, true);\n        file_sink-&gt;set_level(spdlog::level::from_str(log_level));\n        plugin_logger_-&gt;sinks().push_back(file_sink);\n        size_t sink_count = plugin_logger_-&gt;sinks().size();\n        plugin_logger_-&gt;sinks()[sink_count - 1]-&gt;set_pattern(\"%v\");\n    }\n\nprotected:\n    std::string                          name_;\n    const phonebook*                     phonebook_;\n    const std::shared_ptr&lt;record_logger&gt; record_logger_;\n    const std::shared_ptr&lt;gen_guid&gt;      gen_guid_;\n    const std::size_t                    id_;\n    std::shared_ptr&lt;spdlog::logger&gt;      plugin_logger_;\n};\n\n#define PLUGIN_MAIN(PLUGIN_CLASS)                           \\\n    extern \"C\" plugin* this_plugin_factory(phonebook* pb) { \\\n        auto* obj = new PLUGIN_CLASS{#PLUGIN_CLASS, pb};    \\\n        return obj;                                         \\\n    }\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp/","title":"File vulkan_utils.hpp","text":"<p>FileList &gt; illixr &gt; vk &gt; vulkan_utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace vulkan"},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp/#classes","title":"Classes","text":"Type Name struct queue struct queue_families struct swapchain_details"},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp/#macros","title":"Macros","text":"Type Name define VK_ASSERT_SUCCESS (x) <code>/* multi line expression */</code> define VK_GET_PROC_ADDR (instance, name) <code>((PFN\\_##name) vkGetInstanceProcAddr(instance, #name))</code>"},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp/#define-vk_assert_success","title":"define VK_ASSERT_SUCCESS","text":"<pre><code>#define VK_ASSERT_SUCCESS (\n    x\n) `/* multi line expression */`\n</code></pre>"},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp/#define-vk_get_proc_addr","title":"define VK_GET_PROC_ADDR","text":"<pre><code>#define VK_GET_PROC_ADDR (\n    instance,\n    name\n) `((PFN_##name) vkGetInstanceProcAddr(instance, #name))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/vulkan_utils.hpp</code></p>"},{"location":"api/include_2illixr_2vk_2vulkan__utils_8hpp_source/","title":"File vulkan_utils.hpp","text":"<p>File List &gt; illixr &gt; vk &gt; vulkan_utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\n#define VK_ASSERT_SUCCESS(x)                                                                          \\\n    {                                                                                                 \\\n        VkResult result = (x);                                                                        \\\n        if (result != VK_SUCCESS) {                                                                   \\\n            spdlog::get(\"illixr\")-&gt;debug(\"[Vulkan] error: {}\", ILLIXR::vulkan::error_string(result)); \\\n            throw std::runtime_error(\"Vulkan error: \" + ILLIXR::vulkan::error_string(result));        \\\n        }                                                                                             \\\n    }\n\n#define VK_GET_PROC_ADDR(instance, name) ((PFN_##name) vkGetInstanceProcAddr(instance, #name))\nVK_DEFINE_HANDLE(VmaAllocator)\n\nnamespace ILLIXR::vulkan {\nstruct queue_families {\n    std::optional&lt;uint32_t&gt; graphics_family;\n    std::optional&lt;uint32_t&gt; present_family;\n    std::optional&lt;uint32_t&gt; encode_family;\n    std::optional&lt;uint32_t&gt; decode_family;\n    std::optional&lt;uint32_t&gt; dedicated_transfer;\n    std::optional&lt;uint32_t&gt; compute_family;\n\n    [[maybe_unused]] [[nodiscard]] bool has_presentation() const {\n        return graphics_family.has_value() &amp;&amp; present_family.has_value();\n    }\n\n    [[nodiscard]] bool has_compression() const {\n        return graphics_family &amp;&amp; encode_family.has_value() &amp;&amp; decode_family.has_value();\n    }\n};\n\nstruct queue {\n    enum queue_type {\n        GRAPHICS,\n        DEDICATED_TRANSFER,\n        PRESENT,\n        ENCODE,\n        DECODE,\n        COMPUTE,\n    };\n\n    VkQueue                     vk_queue;\n    uint32_t                    family;\n    queue_type                  type;\n    std::shared_ptr&lt;std::mutex&gt; mutex;\n};\n\nstruct swapchain_details {\n    VkSurfaceCapabilitiesKHR        capabilities{};\n    std::vector&lt;VkSurfaceFormatKHR&gt; formats;\n    std::vector&lt;VkPresentModeKHR&gt;   present_modes;\n};\n\nstd::string error_string(VkResult err_code);\n\nVkShaderModule create_shader_module(VkDevice device, std::vector&lt;char&gt;&amp;&amp; code);\n\nVkSemaphore create_timeline_semaphore(VkDevice device, int initial_value = 0,\n                                      VkExportSemaphoreCreateInfo* export_semaphore_create_info = nullptr);\n\n[[maybe_unused]] void wait_timeline_semaphore(VkDevice device, VkSemaphore semaphore, uint64_t value);\n\nvoid wait_timeline_semaphores(VkDevice device, const std::map&lt;VkSemaphore, uint64_t&gt;&amp; semaphores);\n\nVmaAllocator create_vma_allocator(VkInstance vk_instance, VkPhysicalDevice vk_physical_device, VkDevice vk_device);\n\nVkCommandBuffer begin_one_time_command(VkDevice vk_device, VkCommandPool vk_command_pool);\n\nvoid end_one_time_command(VkDevice vk_device, VkCommandPool vk_command_pool, const queue&amp; q, VkCommandBuffer vk_command_buffer);\n\nVkCommandPool create_command_pool(VkDevice device, uint32_t queue_family_index);\n\nVkCommandBuffer create_command_buffer(VkDevice device, VkCommandPool command_pool);\n\nVkResult locked_queue_submit(queue&amp; q, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);\n\nstd::vector&lt;char&gt; read_file(const std::string&amp; path);\n\nvoid copy_buffer_to_image(VkDevice vk_device, queue q, VkCommandPool vk_command_pool, VkBuffer buffer, VkImage image,\n                          uint32_t width, uint32_t height);\n\nswapchain_details query_swapchain_details(VkPhysicalDevice const&amp; physical_device, VkSurfaceKHR const&amp; vk_surface);\n\nqueue_families find_queue_families(VkPhysicalDevice const&amp; physical_device, VkSurfaceKHR const&amp; vk_surface,\n                                   bool no_present = false);\n\nVkImageView create_image_view(VkDevice device, VkImage image, VkFormat format, VkImageAspectFlags aspect_flags);\n} // namespace ILLIXR::vulkan\n</code></pre>"},{"location":"api/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"api/macros/","title":"Macros","text":""},{"location":"api/macros/#b","title":"b","text":"<ul> <li>BOOST_DATE_TIME_NO_LIB (plugin.cpp)</li> </ul>"},{"location":"api/macros/#c","title":"c","text":"<ul> <li>CXXOPTS_DIAGNOSTIC_POP (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS_DIAGNOSTIC_PUSH (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS_IGNORE_WARNING (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS_LINKONCE (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS_LINKONCE_CONST (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS_NODISCARD (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS_RTTI_CAST (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS_VECTOR_DELIMITER (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS__VERSION_MAJOR (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS__VERSION_MINOR (cxxopts.hpp, cxxopts.hpp)</li> <li>CXXOPTS__VERSION_PATCH (cxxopts.hpp, cxxopts.hpp)</li> <li>COMMA (files.cpp)</li> </ul>"},{"location":"api/macros/#d","title":"d","text":"<ul> <li>DOUBLE_INCLUDE (offload_rendering_client.hpp, offload_rendering_server.hpp, zed_camera_thread.hpp)</li> <li>DEPTH_MODE (plugin.cpp)</li> </ul>"},{"location":"api/macros/#f","title":"f","text":"<ul> <li>FLOAT (hmd.hpp, hmd.hpp)</li> </ul>"},{"location":"api/macros/#g","title":"g","text":"<ul> <li>GLFW_INCLUDE_VULKAN (render_pass.hpp, glfw_extended.cpp)</li> <li>GLX_CONTEXT_MAJOR_VERSION_ARB (extended_window.hpp)</li> <li>GLX_CONTEXT_MINOR_VERSION_ARB (extended_window.hpp)</li> <li>GLM_ENABLE_EXPERIMENTAL (openwarp_vk.hpp, timewarp_vk.cpp, service.hpp)</li> <li>GLM_FORCE_DEPTH_ZERO_TO_ONE (openwarp_vk.hpp, timewarp_vk.cpp, service.hpp)</li> <li>GLM_FORCE_RADIANS (openwarp_vk.hpp, timewarp_vk.cpp, service.hpp)</li> <li>GL_GLEXT_PROTOTYPES (plugin.cpp)</li> <li>GET_BOOL (illixr.hpp)</li> <li>GET_STRING (illixr.hpp)</li> </ul>"},{"location":"api/macros/#i","title":"i","text":"<ul> <li>ILLIXR_BITRATE (video_encoder.cpp)</li> <li>IMG_HEIGHT (video_encoder.cpp, video_decoder.cpp)</li> <li>IMG_WIDTH (video_encoder.cpp, video_decoder.cpp)</li> </ul>"},{"location":"api/macros/#n","title":"n","text":"<ul> <li>NATIVE_RENDERER_BUFFER_POOL_SIZE (plugin.cpp)</li> </ul>"},{"location":"api/macros/#o","title":"o","text":"<ul> <li>OFFLOAD_RENDERING_BITRATE (ffmpeg_utils.hpp)</li> <li>OFFLOAD_RENDERING_FFMPEG_ENCODER_NAME (ffmpeg_utils.hpp)</li> <li>OFFLOAD_RENDERING_FFMPEG_DECODER_NAME (offload_rendering_client.cpp)</li> </ul>"},{"location":"api/macros/#p","title":"p","text":"<ul> <li>PRINT_CPU_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_RECORD_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_WALL_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PLUGIN_MAIN (plugin.hpp)</li> </ul>"},{"location":"api/macros/#r","title":"r","text":"<ul> <li>RAC_ERRNO (error_util.hpp)</li> <li>RAC_ERRNO_MSG (error_util.hpp)</li> <li>RGB_MODE (plugin.cpp)</li> </ul>"},{"location":"api/macros/#s","title":"s","text":"<ul> <li>STB_IMAGE_WRITE_IMPLEMENTATION (plugin.cpp)</li> <li>STB_IMAGE_IMPLEMENTATION (service.cpp)</li> <li>STRINGIZE (illixr.hpp)</li> </ul>"},{"location":"api/macros/#t","title":"t","text":"<ul> <li>TINYOBJLOADER_IMPLEMENTATION (plugin.cpp, service.cpp)</li> </ul>"},{"location":"api/macros/#u","title":"u","text":"<ul> <li>USE_ALT_EYE_FORMAT (misc.hpp)</li> <li>UNITS (zed_camera.hpp)</li> </ul>"},{"location":"api/macros/#v","title":"v","text":"<ul> <li>VK_ASSERT_SUCCESS (vulkan_utils.hpp, vulkan_utils.hpp)</li> <li>VK_GET_PROC_ADDR (vulkan_utils.hpp, vulkan_utils.hpp)</li> <li>ViconRoom1Difficult (plugin.hpp)</li> <li>ViconRoom1Easy (plugin.hpp)</li> <li>ViconRoom1Medium (plugin.hpp)</li> <li>ViconRoom2Easy (plugin.hpp)</li> <li>ViconRoom2Hard (plugin.hpp)</li> <li>ViconRoom2Medium (plugin.hpp)</li> <li>VULKAN_REQUIRED (plugin.hpp)</li> <li>VMA_DYNAMIC_VULKAN_FUNCTIONS (vulkan_utils.cpp)</li> <li>VMA_IMPLEMENTATION (vulkan_utils.cpp)</li> <li>VMA_STATIC_VULKAN_FUNCTIONS (vulkan_utils.cpp)</li> </ul>"},{"location":"api/macros/#_","title":"_","text":"<ul> <li>_USE_MATH_DEFINES (math_util.hpp)</li> <li>_STR (illixr.hpp)</li> </ul>"},{"location":"api/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; src &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr.hpp\"</code></li> <li><code>#include &lt;csignal&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"api/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, const char * argv)"},{"location":"api/main_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void sigabrt_handler (int sig) A signal handler for SIGABRT. void sigill_handler (int sig) A signal handler for SIGILL. void sigint_handler (int sig) NDEBUG."},{"location":"api/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    const char * argv\n) \n</code></pre>"},{"location":"api/main_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/main_8cpp/#function-sigabrt_handler","title":"function sigabrt_handler","text":"<p>A signal handler for SIGABRT. <pre><code>static void sigabrt_handler (\n    int sig\n) \n</code></pre></p> <p>Forward SIGABRT from <code>std::abort</code> and <code>assert</code> to catchsegv in <code>ci.yaml</code>. Provides additional debugging information via <code>-rdynamic</code>. </p>"},{"location":"api/main_8cpp/#function-sigill_handler","title":"function sigill_handler","text":"<p>A signal handler for SIGILL. <pre><code>static void sigill_handler (\n    int sig\n) \n</code></pre></p> <p>Forward SIGILL from illegal instructions to catchsegv in <code>ci.yaml</code>. Provides additional debugging information via <code>-rdynamic</code>. </p>"},{"location":"api/main_8cpp/#function-sigint_handler","title":"function sigint_handler","text":"<p>NDEBUG. <pre><code>static void sigint_handler (\n    int sig\n) \n</code></pre></p> <p>A signal handler for SIGINT.</p> <p>Stops the execution of the application via the ILLIXR runtime. </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/main.cpp</code></p>"},{"location":"api/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; src &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr.hpp\"\n\n#include &lt;csignal&gt;\n#include &lt;iostream&gt;\n\n#ifndef NDEBUG\nstatic void sigill_handler(int sig) {\n    assert(sig == SIGILL &amp;&amp; \"sigill_handler is for SIGILL\");\n    std::raise(SIGSEGV);\n}\n\nstatic void sigabrt_handler(int sig) {\n    assert(sig == SIGABRT &amp;&amp; \"sigabrt_handler is for SIGABRT\");\n    std::raise(SIGSEGV);\n}\n#endif \n\nstatic void sigint_handler([[maybe_unused]] int sig) {\n    assert(sig == SIGINT &amp;&amp; \"sigint_handler is for SIGINT\");\n    if (runtime_) {\n        runtime_-&gt;stop();\n    }\n}\n\nint main(int argc, const char* argv[]) {\n    cxxopts::Options options(\"ILLIXR\", \"Main program\");\n    options.show_positional_help();\n    options.allow_unrecognised_options();\n    // std::string illixr_data, illixr_demo_data, realsense_cam;\n    // illixr_data = illixr_demo_data = realsense_cam = \"\";\n    // bool offload_enable, alignment_enable, enable_verbose_errors, enable_pre_sleep;\n    // offload_enable = alignment_enable = enable_verbose_errors = enable_pre_sleep = false;\n    // long run_dur = 0;\n    options.add_options()(\"d,duration\", \"The duration to run for\", cxxopts::value&lt;long&gt;())(\n        \"data\", \"The data\", cxxopts::value&lt;std::string&gt;())(\"demo_data\", \"The demo data\", cxxopts::value&lt;std::string&gt;())(\n        \"enable_offload\", \"\")(\"enable_alignment\", \"\")(\"enable_verbose_errors\", \"\")(\"enable_pre_sleep\", \"\")(\n        \"h,help\", \"Produce help message\")(\"realsense_cam\", \"\", cxxopts::value&lt;std::string&gt;()-&gt;default_value(\"auto\"))(\n        \"p,plugins\", \"The plugins to use\",\n        cxxopts::value&lt;std::vector&lt;std::string&gt;&gt;())(\"y,yaml\", \"Yaml config file\", cxxopts::value&lt;std::string&gt;())(\"openxr\", \"\");\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n        std::cout &lt;&lt; options.help() &lt;&lt; std::endl;\n        return EXIT_SUCCESS;\n    }\n\n#ifndef NDEBUG\n    std::signal(SIGILL, sigill_handler);\n    std::signal(SIGABRT, sigabrt_handler);\n#endif \n\n    std::signal(SIGINT, sigint_handler);\n\n    return ILLIXR::run(result);\n}\n</code></pre>"},{"location":"api/managed__thread_8hpp/","title":"File managed_thread.hpp","text":"<p>FileList &gt; illixr &gt; managed_thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/managed__thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/managed__thread_8hpp/#classes","title":"Classes","text":"Type Name class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/managed_thread.hpp</code></p>"},{"location":"api/managed__thread_8hpp_source/","title":"File managed_thread.hpp","text":"<p>File List &gt; illixr &gt; managed_thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;functional&gt;\n#include &lt;stdexcept&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n\nclass managed_thread {\npublic:\n    enum class state {\n        nonstartable,\n        startable,\n        running,\n        stopped,\n    };\n\n    managed_thread() noexcept = default;\n\n    explicit managed_thread(std::function&lt;void()&gt; body, std::function&lt;void()&gt; on_start = std::function&lt;void()&gt;{},\n                            std::function&lt;void()&gt; on_stop = std::function&lt;void()&gt;{}) noexcept\n        : body_{std::move(body)}\n        , on_start_{std::move(on_start)}\n        , on_stop_{std::move(on_stop)} { }\n\n    ~managed_thread() noexcept {\n        if (get_state() == state::running) {\n            stop();\n        }\n        assert(get_state() == state::stopped || get_state() == state::startable || get_state() == state::nonstartable);\n        // assert(!thread_.joinable());\n    }\n\n    state get_state() {\n        bool stopped = stop_.load();\n        if (!body_) {\n            return state::nonstartable;\n        } else if (!stopped &amp;&amp; !thread_.joinable()) {\n            return state::startable;\n        } else if (!stopped &amp;&amp; thread_.joinable()) {\n            return state::running;\n        } else if (stopped) {\n            return state::stopped;\n        } else {\n            throw std::logic_error{\"Unknown state\"};\n        }\n    }\n\n    void start() {\n        assert(get_state() == state::startable);\n        thread_ = std::thread{&amp;managed_thread::thread_main, this};\n        assert(get_state() == state::running);\n    }\n\n    void stop() {\n        assert(get_state() == state::running);\n        stop_.store(true);\n        thread_.join();\n        assert(get_state() == state::stopped);\n    }\n\nprivate:\n    std::atomic&lt;bool&gt;     stop_{false};\n    std::thread           thread_;\n    std::function&lt;void()&gt; body_;\n    std::function&lt;void()&gt; on_start_;\n    std::function&lt;void()&gt; on_stop_;\n\n    void thread_main() {\n        assert(body_);\n        if (on_start_) {\n            on_start_();\n        }\n        while (!this-&gt;stop_.load()) {\n            body_();\n        }\n        if (on_stop_) {\n            on_stop_();\n        }\n    }\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/math__util_8hpp/","title":"File math_util.hpp","text":"<p>FileList &gt; illixr &gt; math_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"data_format/point.hpp\"</code></li> <li><code>#include \"data_format/pose.hpp\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> </ul>"},{"location":"api/math__util_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace math_util"},{"location":"api/math__util_8hpp/#macros","title":"Macros","text":"Type Name define _USE_MATH_DEFINES"},{"location":"api/math__util_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/math__util_8hpp/#define-_use_math_defines","title":"define _USE_MATH_DEFINES","text":"<pre><code>#define _USE_MATH_DEFINES \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/math_util.hpp</code></p>"},{"location":"api/math__util_8hpp_source/","title":"File math_util.hpp","text":"<p>File List &gt; illixr &gt; math_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#ifndef _USE_MATH_DEFINES\n    #define _USE_MATH_DEFINES\n#endif\n#include \"data_format/point.hpp\"\n#include \"data_format/pose.hpp\"\n\n#include &lt;cmath&gt;\n#include &lt;eigen3/Eigen/Core&gt;\n\nnamespace ILLIXR::math_util {\nvoid projection(Eigen::Matrix4f* result, const float tan_left, const float tan_right, const float tan_up, float const tan_down,\n                const float near_z, const float far_z) {\n    const float tan_width  = tan_right - tan_left;\n    const float tan_height = tan_up - tan_down;\n\n    // https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n    (*result)(0, 0) = 2 / tan_width;\n    (*result)(0, 1) = 0;\n    (*result)(0, 2) = (tan_right + tan_left) / tan_width;\n    (*result)(0, 3) = 0;\n\n    (*result)(1, 0) = 0;\n    (*result)(1, 1) = 2 / tan_height;\n    (*result)(1, 2) = (tan_up + tan_down) / tan_height;\n    (*result)(1, 3) = 0;\n\n    (*result)(2, 0) = 0;\n    (*result)(2, 1) = 0;\n    (*result)(2, 2) = -far_z / (far_z - near_z);\n    (*result)(2, 3) = -(far_z * near_z) / (far_z - near_z);\n\n    (*result)(3, 0) = 0;\n    (*result)(3, 1) = 0;\n    (*result)(3, 2) = -1;\n    (*result)(3, 3) = 0;\n}\n\nvoid projection_reverse_z(Eigen::Matrix4f* result, const float tan_left, const float tan_right, const float tan_up,\n                          float const tan_down, const float near_z, const float far_z) {\n    const float tan_width  = tan_right - tan_left;\n    const float tan_height = tan_up - tan_down;\n\n    // https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n    (*result)(0, 0) = 2 / tan_width;\n    (*result)(0, 1) = 0;\n    (*result)(0, 2) = (tan_right + tan_left) / tan_width;\n    (*result)(0, 3) = 0;\n\n    (*result)(1, 0) = 0;\n    (*result)(1, 1) = 2 / tan_height;\n    (*result)(1, 2) = (tan_up + tan_down) / tan_height;\n    (*result)(1, 3) = 0;\n\n    (*result)(2, 0) = 0;\n    (*result)(2, 1) = 0;\n    (*result)(2, 2) = near_z / (far_z - near_z);\n    (*result)(2, 3) = (far_z * near_z) / (far_z - near_z);\n\n    (*result)(3, 0) = 0;\n    (*result)(3, 1) = 0;\n    (*result)(3, 2) = -1;\n    (*result)(3, 3) = 0;\n}\n\nvoid projection_fov(Eigen::Matrix4f* result, const float fov_left, const float fov_right, const float fov_up,\n                    const float fov_down, const float near_z, const float far_z, bool reverse_z = false) {\n    const float tan_left  = -tanf(static_cast&lt;float&gt;(fov_left * (M_PI / 180.0f)));\n    const float tan_right = tanf(static_cast&lt;float&gt;(fov_right * (M_PI / 180.0f)));\n\n    const float tan_down = -tanf(static_cast&lt;float&gt;(fov_down * (M_PI / 180.0f)));\n    const float tan_up   = tanf(static_cast&lt;float&gt;(fov_up * (M_PI / 180.0f)));\n\n    if (reverse_z) {\n        projection_reverse_z(result, tan_left, tan_right, tan_up, tan_down, near_z, far_z);\n    } else {\n        projection(result, tan_left, tan_right, tan_up, tan_down, near_z, far_z);\n    }\n}\n\n// Expects FoVs in radians\nvoid unreal_projection(Eigen::Matrix4f* result, const float fov_left, const float fov_right, const float fov_up,\n                       const float fov_down) {\n    // Unreal uses a far plane at infinity and a near plane of 10 centimeters (0.1 meters)\n    constexpr float near_z = 0.1;\n\n    const float angle_left  = tanf(static_cast&lt;float&gt;(fov_left));\n    const float angle_right = tanf(static_cast&lt;float&gt;(fov_right));\n    const float angle_up    = tanf(static_cast&lt;float&gt;(fov_up));\n    const float angle_down  = tanf(static_cast&lt;float&gt;(fov_down));\n\n    const float sum_rl = angle_left + angle_right;\n    const float sum_tb = angle_up + angle_down;\n    const float inv_rl = 1.0f / (angle_right - angle_left);\n    const float inv_tb = 1.0f / (angle_up - angle_down);\n\n    (*result)(0, 0) = 2 * inv_rl;\n    (*result)(0, 1) = 0;\n    (*result)(0, 2) = sum_rl * (-inv_rl);\n    (*result)(0, 3) = 0;\n\n    (*result)(1, 0) = 0;\n    (*result)(1, 1) = 2 * inv_tb;\n    (*result)(1, 2) = sum_tb * (-inv_tb);\n    (*result)(1, 3) = 0;\n\n    (*result)(2, 0) = 0;\n    (*result)(2, 1) = 0;\n    (*result)(2, 2) = 0;\n    (*result)(2, 3) = near_z;\n\n    (*result)(3, 0) = 0;\n    (*result)(3, 1) = 0;\n    (*result)(3, 2) = -1;\n    (*result)(3, 3) = 0;\n}\n\n// TODO: this is just a complicated version to achieve reverse Z with a finite far plane.\n[[maybe_unused]] void godot_projection(Eigen::Matrix4f* result, const float fov_left, const float fov_right, const float fov_up,\n                                       const float fov_down) {\n    // Godot's default far and near planes are 4000m and 0.05m respectively.\n    // https://github.com/godotengine/godot/blob/e96ad5af98547df71b50c4c4695ac348638113e0/modules/openxr/openxr_util.cpp#L97\n    // The Vulkan implementation passes in GRAPHICS_OPENGL for some reason.\n    constexpr float near_z   = 0.05;\n    constexpr float far_z    = 4000;\n    constexpr float offset_z = near_z;\n\n    const float angle_left  = tanf(static_cast&lt;float&gt;(fov_left));\n    const float angle_right = tanf(static_cast&lt;float&gt;(fov_right));\n    const float angle_up    = tanf(static_cast&lt;float&gt;(fov_up));\n    const float angle_down  = tanf(static_cast&lt;float&gt;(fov_down));\n\n    const float angle_width  = angle_right - angle_left;\n    const float angle_height = angle_up - angle_down;\n\n    Eigen::Matrix4f openxr_matrix;\n\n    openxr_matrix(0, 0) = 2 / angle_width;\n    openxr_matrix(0, 1) = 0;\n    openxr_matrix(0, 2) = (angle_right + angle_left) / angle_width;\n    openxr_matrix(0, 3) = 0;\n\n    openxr_matrix(1, 0) = 0;\n    openxr_matrix(1, 1) = 2 / angle_height;\n    openxr_matrix(1, 2) = (angle_up + angle_down) / angle_height;\n    openxr_matrix(1, 3) = 0;\n\n    openxr_matrix(2, 0) = 0;\n    openxr_matrix(2, 1) = 0;\n    openxr_matrix(2, 2) = -(far_z + offset_z) / (far_z - near_z);\n    openxr_matrix(2, 3) = -(far_z * (near_z + offset_z)) / (far_z - near_z);\n\n    openxr_matrix(3, 0) = 0;\n    openxr_matrix(3, 1) = 0;\n    openxr_matrix(3, 2) = -1;\n    openxr_matrix(3, 3) = 0;\n\n    // Godot then remaps the matrix...\n    // https://github.com/Khasehemwy/godot/blob/d950f5f83819240771aebb602bfdd4875363edce/core/math/projection.cpp#L722\n    Eigen::Matrix4f remap_z;\n\n    remap_z(0, 0) = 1;\n    remap_z(0, 1) = 0;\n    remap_z(0, 2) = 0;\n    remap_z(0, 3) = 0;\n\n    remap_z(1, 0) = 0;\n    remap_z(1, 1) = 1;\n    remap_z(1, 2) = 0;\n    remap_z(1, 3) = 0;\n\n    remap_z(2, 0) = 0;\n    remap_z(2, 1) = 0;\n    remap_z(2, 2) = -0.5;\n    remap_z(2, 3) = 0.5;\n\n    remap_z(3, 0) = 0;\n    remap_z(3, 1) = 0;\n    remap_z(3, 2) = 0;\n    remap_z(3, 3) = 1;\n\n    (*result) = remap_z * openxr_matrix;\n}\n\n/*\n * Rotation matrix to convert a point from one coordinate system to another, e.g. left hand y up to right hand y up\n *\n */\ninline Eigen::Matrix3f rotation(const float alpha, const float beta, const float gamma) {\n    Eigen::Matrix3f rot;\n    double          ra = alpha * M_PI / 180.;\n    double          rb = beta * M_PI / 180.;\n    double          rg = gamma * M_PI / 180;\n    rot &lt;&lt; static_cast&lt;float&gt;(cos(rg) * cos(rb)), static_cast&lt;float&gt;(cos(rg) * sin(rb) * sin(ra) - sin(rg) * cos(ra)),\n        static_cast&lt;float&gt;(cos(rg) * sin(rb) * cos(ra) + sin(rg) * sin(ra)), static_cast&lt;float&gt;(sin(rg) * cos(rb)),\n        static_cast&lt;float&gt;(sin(rg) * sin(rb) * sin(ra) + cos(rg) * cos(ra)),\n        static_cast&lt;float&gt;(sin(rg) * sin(rb) * cos(ra) - cos(rg) * sin(ra)), static_cast&lt;float&gt;(-sin(rb)),\n        static_cast&lt;float&gt;(cos(rb) * sin(ra)), static_cast&lt;float&gt;(cos(rb) * cos(ra));\n    return rot;\n}\n\nconst Eigen::Matrix3f invert_x = (Eigen::Matrix3f() &lt;&lt; -1., 0., 0., 0., 1., 0., 0., 0., 1.).finished();\nconst Eigen::Matrix3f invert_y = (Eigen::Matrix3f() &lt;&lt; 1., 0., 0., 0., -1., 0., 0., 0., 1.).finished();\nconst Eigen::Matrix3f invert_z = (Eigen::Matrix3f() &lt;&lt; 1., 0., 0., 0., 1., 0., 0., 0., -1.).finished();\nconst Eigen::Matrix3f identity = Eigen::Matrix3f::Identity();\n\n// from:      IM (image)                        LHYU (left hand y up)              RHYU (right hand y up)             RHZU\n// (right hand z up LHZU (left hand z up)               RHZUXF (right hand z up x forward)                 to:\nconst Eigen::Matrix3f conversion[6][6] = {\n    {identity, invert_y, rotation(180., 0., 0.), rotation(-90., 0., 0.), rotation(-90., 0., 90.) * invert_z,\n     rotation(-90., 0., -90.)}, // IM\n    {invert_y, identity, invert_z, rotation(-90., 0., 0.) * invert_y, rotation(90., 0., 90.),\n     rotation(-90., 0., -90.) * invert_y}, // LHYU\n    {rotation(180., 0., 0.), invert_z, identity, rotation(90., 0., 0.), rotation(90., 0., 90.) * invert_z,\n     rotation(-90., 0., 90.) * invert_x* invert_y}, // RHYU\n    {rotation(90., 0., 0.), invert_y* rotation(90., 0., 0.), rotation(-90., 0., 0.), identity, rotation(0., 0., 90.) * invert_y,\n     rotation(0., 0., -90.)}, // RHZU\n    {rotation(90., -90., 0.) * invert_y, rotation(-90., -90., 0.), rotation(0., 90., 90.) * invert_y,\n     invert_x* rotation(0, 0., 90), identity, invert_y}, // LHZU\n    {rotation(90., -90., 0.), rotation(-90., -90., 0.) * invert_y, rotation(0., 90., 90.), rotation(0, 0., 90), invert_y,\n     identity}}; // RHZUXF\n\n} // namespace ILLIXR::math_util\n</code></pre>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2debugview_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2debugview 2README","text":"<p>debugview</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2debugview_2README/#summary","title":"Summary","text":"<p><code>debugview</code> is a simple debugging view for the ILLIXR system. By subscribing to several Switchboard endpoints, many important datapoints can be observed to help debug issues with the runtime. The debug view shows the current calculated SLAM pose and the (optional) ground truth pose read from the ground truth dataset as 3D headset models drawn on a backdrop scene. In addition, camera and IMU data is also visible, with the stereoscopic onboard camera views shown in one of the windows. Various offsets can be applied to the generated poses to aid in viewing. Dear ImGUI is used for displaying data and providing an interactive interface.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2debugview_2README/#switchboard-connection","title":"Switchboard connection","text":"<ul> <li><code>debugview</code> subscribes to the slow-pose, which represents the latest pose published by the SLAM/IMU system.</li> <li>In the future, <code>debugview</code> will also query for the most up-to-date predicted pose through an RPC-like query system. This is not currently in our release version; but is in development and will be added soon. The \"fast pose\" referenced in this plugin just samples the <code>slow_pose</code> instead.</li> <li><code>debugview</code> also is synchronously dependent on the <code>imu_cam</code> topic, as the stereoscopic camera views are displayed in the debug window. In ILLIXR, \"synchronous dependencies\" are implemented as scheduled \"handlers\" that are executed from a shared thread pool; this handler is executed every time a fresh \"packet\" is available from the <code>imu_cam</code> topic. Given that this is a separate thread from the main graphics thread, this <code>imu_cam</code> packet must be saved/cached for later, when the graphics thread renders the next frame. This is a good example to follow when writing your own multithreaded components that use both synchronous and asynchronous dependencies, and need to share information across dependency boundaries.</li> </ul>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2debugview_2README/#environment-variables","title":"Environment Variables","text":"<p>DEBUGVIEW_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2debugview_2README/#notes","title":"Notes","text":"<p><code>debugview</code> will be under heavy development in the near-term. Pull requests may or may not be accepted, due to the frequency of rapid internal changes.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2debugview_2README/#known-issues","title":"Known Issues","text":"<p>Currently, the poses returned from the SLAM system have an incorrect initial rotation, as the poses are returned in an incorrect frame of reference. Thus, the headsets may appear to be tilted incorrectly; the button \"calculate new orientation offset\" will reset the orientation, such that the current orientation is considered the \"neutral\" orientation. In a future update, the correct frame of reference/transform matrix will be applied and the pose will accurately reflect the actual head position.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2debugview_2README/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2gldemo_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2gldemo 2README","text":"<p>gldemo</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2gldemo_2README/#summary","title":"Summary","text":"<p>The <code>gldemo</code> plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>gldemo</code> will subscribe to several switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the Switchboard API. <code>gldemo</code> is intended to be as lightweight as possible, serving as a baseline debug \" dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; <code>gldemo</code> fills this requirement. As an important note, <code>gldemo</code> does not render stereoscopically; the two eye renders are rendered from the same position. This may be updated to render stereoscopically in the future, but is not seen as a critical feature as this is generally intended as a debugging tool.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2gldemo_2README/#switchboard-connection","title":"Switchboard connection","text":"<p><code>gldemo</code> subscribes to and publishes to several switchboard plugs. Most notably, <code>gldemo</code> subscribes to the <code>fast_pose</code> plug, which (ideally) represents the most recent extrapolated pose. This connection represents an area of active development in ILLIXR, as we are replacing the pose subscription with an RPC-like proper pose prediction system. As of the time of writing, <code>fast_pose</code> is functionally identical to the <code>slow_pose</code> published by the SLAM system, but this will change when proper pose extrapolation is implemented. <code>gldemo</code> also pulls the correct graphics context from Phonebook.</p> <p><code>gldemo</code> publishes the rendered eyebuffers to the Switchboard system as well, using whichever eyebuffer format has been selected with the <code>USE_ALT_EYE_FORMAT</code> compile-time macro. The alternative eye format is more similar to the format used by Monado/OpenXR, and is more fully explained by the code comments.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2gldemo_2README/#environment-variables","title":"Environment Variables","text":"<p>GLDEMO_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2gldemo_2README/#notes","title":"Notes","text":"<p><code>gldemo</code> does not pretend to be an OpenXR application; it does not use the OpenXR API, nor does it follow typical OpenXR patterns. It hooks directly into the Switchboard system and is intended as a debug/visualization tool. For more accurate and representative testing, consider running ILLIXR with an actual OpenXR application.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2gldemo_2README/#known-issues","title":"Known Issues","text":"<p>As noted above, <code>gldemo</code> does not actually render stereoscopically, and the two eye buffers are rendered from the same eye location. (This is not to say that the two eye buffers are not rendered separately; they are actually two separate draw calls.) In addition, the quality of the pose used by <code>gldemo</code> is dependent on the upstream pose, which is currently not extrapolated/predicted and is subject to change.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2gldemo_2README/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and are a part of our existing internal backlog. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2lighthouse_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2lighthouse 2README","text":"<p>Lighthouse</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2lighthouse_2README/#summary","title":"Summary","text":"<p>The <code>lighthouse</code> plugin supports lighthouse tracking using the libsurvive library. To use this plugin, libsurvive should first be built, installed, and calibrated according to their documentation. Running ILLIXR's CMake to build the <code>lighthouse</code> plugin should automatically build and install <code>libsurvive</code>, but the steps to calibrate the lighthouses should still be followed.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2lighthouse_2README/#note","title":"Note","text":"<p>If the <code>lighthouse</code> plugin is being used, make sure to set the environment variable <code>ILLIXR_LIGHTHOUSE</code> to true, as the <code>pose_prediction</code> relies on it. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2native__renderer_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2native  renderer 2README","text":"<p>native_renderer</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2native__renderer_2README/#summary","title":"Summary","text":"<p><code>native_renderer</code> utilizes <code>vkdemo</code> and <code>timewarp_vk</code> to construct a full rendering pipeline. <code>vkdemo</code> is used to render the scene, and <code>timewarp_vk</code> is used to perform rotational reprojection. This plugin creates the necessary Vulkan resources and targets for <code>vkdemo</code> and <code>timewarp_vk</code> to render to, and then composites the results into a single image. The resulting image is presented using the Vulkan swapchain provided by <code>display_vk</code>.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2native__renderer_2README/#environment-variables","title":"Environment Variables","text":"<p>NATIVE_RENDERER_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \" error\", \"critical\", or \"off\" </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2offload__rendering__client_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2offload  rendering  client 2README","text":"<p>offload_rendering_client</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2offload__rendering__client_2README/#summary","title":"Summary","text":"<p><code>offload_rendering_client</code> receives encoded frames from the network, and uses a mix of NPPI and FFMPEG to decode the frames before updating the buffer pool. Setting the environment variable <code>ILLIXR_USE_DEPTH_IMAGES</code> to a non-zero value indicates that depth images are being received, and should thus also be decoded.</p> <p>Note that there is a known color shift issue (to be fixed), where the decoded frame's colors are slightly different from the original frame (likely due to the many conversions between YUV and RGBA). </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2offload__rendering__server_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2offload  rendering  server 2README","text":"<p>offload_rendering_server</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2offload__rendering__server_2README/#summary","title":"Summary","text":"<p><code>offload_rendering_server</code> encodes frames using FFMPEG and transmits them to the client with the network_backend from switchboard. In addition to the frame, some additional information is also transmitted, e.g., the pose used for the rendered frame so that the client can reprojected the decoded frame accordingly.</p> <p>Relevant environment variables include: * <code>ILLIXR_USE_DEPTH_IMAGES</code> set to non-zero will encode/transmit depth images. * <code>ILLIXR_OFFLOAD_RENDERING_BITRATE</code> sets the encoding bitrate. * <code>ILLIXR_OFFLOAD_RENDERING_FRAMERATE</code> sets the encoding framerate. * <code>ILLIXR_OFFLOAD_RENDERING_NALU_ONLY</code> set to non-zero indicates a Jetson client.</p> <p>Note</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2openni_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2openni 2README","text":"<p>OpenNI</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2openni_2README/#set-camera-mode","title":"Set Camera Mode","text":"<p>If you wish to switch up the video modes of OpenNI, update these two macros in <code>openni/plugin.cpp</code> accordingly:  <pre><code>#define RGB_MODE 0\n#define DEPTH_MODE 0\n</code></pre></p> <p>You can see the list of available modes once you run ILLIXR the first time.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2openni_2README/#debugging","title":"Debugging","text":"<p><pre><code>Device open failed:     DeviceOpen using default: no devices found\n</code></pre> Solution: No OpenNI compatible device is plugged in. So plug one in</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": USB transfer timeout!\n</code></pre> Solution: This is usually fixed by unplug and plug back in.</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": Failed to open the USB device!\n</code></pre> Solution: Fix by running with sudo</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2openni_2README/#environment-variables","title":"Environment Variables","text":"<p>OPENNI_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"critical\", or \"off\" </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2openwarp__vk_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2openwarp  vk 2README","text":"<p>openwarp_vk</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2openwarp__vk_2README/#summary","title":"Summary","text":"<p><code>openwarp_vk</code> is a Vulkan-based translational reprojection service intended for use in the ILLIXR architecture.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2openwarp__vk_2README/#phonebook-service","title":"Phonebook Service","text":"<p><code>openwarp_vk</code> is registered as a service in phonebook, conforming to the <code>timewarp</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which <code>openwarp_vk</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> calculates the reprojection matrix given the current pose and the pose used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before <code>record_command_buffer</code> is called</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int left)</code> records the commands into a given command buffer that would perform the reprojection for one eye, for which 1 is left and 0 is right</li> </ul> <p>Note</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2orb__slam3_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2orb  slam3 2README","text":"<p>ORB-SLAM</p> <p>This plugin uses the ORB-SLAM3 library for real-time VIO. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2record__imu__cam_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2record  imu  cam 2README","text":"<p>Record IMU Cam</p> <p>The purpose of this plugin is to record a dataset, similar to the EuRoC MAV dataset that includes the IMU data and Cam images.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2record__imu__cam_2README/#how-to-record-a-dataset","title":"How to record a dataset","text":"<p>Add <code>record_imu_cam</code> to either your input yaml file or to your <code>--plugins</code> argument when invoking the ILLIXR executable.</p> <p>After recording, the dataset will be stored in the ILLIXR project directory, with the following structure:  </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2record__imu__cam_2README/#format","title":"Format","text":"<ul> <li><code>cam0/data.csv</code> and <code>cam1/data.csv</code> are both formatted as </li> <li><code>imu0/data.csv</code> is formatted as  </li> </ul>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2record__imu__cam_2README/#how-to-rerun-recorded-dataset","title":"How to rerun recorded dataset","text":"<ul> <li>**(IMPORTANT)** Do not specify <code>record_imu_cam</code> in either your input yaml file or to your <code>--plugins</code> argument when invoking the ILLIXR executable.</li> <li>When running the ILLIXR executable do one of the following:</li> <li>In the input yaml file add a line to the <code>env_vars</code> section: <code>data: &lt;PATH_TO_ILLIXR&gt;/data_record</code></li> <li>Add <code>--data=&lt;PATH_TO_ILLIXR&gt;/data_record</code> to the command line arguments</li> <li> <p>Set the environment variable <code>ILLIXR_DATA</code> to <code>&lt;PATH_TO_ILLIXR&gt;/data_record</code></p> </li> <li> <p>Make sure other plugins that feed images and IMU are not being used, such as <code>offline_cam</code>, <code>offline_imu</code>, <code>zed</code>, and <code>realsense</code>. </p> </li> </ul>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2tcp__network__backend_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2tcp  network  backend 2README","text":"<p>TCP_network_backend</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2tcp__network__backend_2README/#summary","title":"Summary","text":"<p><code>TCP_network_backend</code> manages the transmission and reception of data published on networked topics (created by <code>get_network_writer</code> in Switchboard) through a TCP backend. The users need to specify the IP address and port number of the server and client through setting some environment variables.  <pre><code>ILLIXR_TCP_SERVER_IP: IP address of the server.\nILLIXR_TCP_SERVER_PORT: Port number of the server.\nILLIXR_IS_CLIENT: Set to `1` if this process is acting as a client; otherwise, `0`.\n</code></pre>  The client will initiate connection to the server by specifying the IP and port number, and the server will accept the connection request.</p> <p>Optionally, the client can set its IP address and port number.  <pre><code>ILLIXR_TCP_CLIENT_IP: IP address of the client.\nILLIXR_TCP_CLIENT_PORT: Port number of the client.\n</code></pre></p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__gl_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2timewarp  gl 2README","text":"<p>timewarp_gl</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__gl_2README/#summary","title":"Summary","text":"<p><code>timewarp_gl</code> is an OpenGL-based asynchronous rotational reprojection plugin intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__gl_2README/#switchboard-connection","title":"Switchboard connection","text":"<p><code>timewarp_gl</code> subscribes to and publishes to several Switchboard plugs and Phonebook resources.</p> <ul> <li>The plugin grabs the GL context from Phonebook. This is necessary to share the eyebuffers with the rendering application (or <code>gldemo</code>). As this is an OpenGL-based reprojection plugin, it relies on OpenGL resources for the eyebuffers.</li> <li><code>timewarp_gl</code> subscribes to the most recent pose published by the system. Currently, as our pose-prediction system is still under development, this is not technically accurate; the final, intended functionality is that the timewarp plugin will sample a pose prediction algorithm through an RPC-like mechanism. As we complete our work on our pose prediction system, this plugin will be modified to use this mechanism.</li> <li><code>timewarp_gl</code> also subscribes to the most recent frame published by the system. This frame data also includes the pose that was used to render the frame; this is how the timewarp algorithm calculates the \"diff\" to be used to reproject the frame.</li> </ul>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__gl_2README/#environment-variables","title":"Environment Variables","text":"<p>TIMEWARP_GL_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p> <p>ILLIXR_TIMEWARP_DISABLE: whether to disable warping, values can be \"True\" or \"False\" (default)</p> <p>ILLIXR_OFFLOAD_ENABLE: whether to enable offloading, values can be \"True\" or \"False\" (default)</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__gl_2README/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__gl_2README/#known-issues","title":"Known Issues","text":"<p>As noted above, this plugin currently samples <code>slow_pose</code>. This will be changed to sample a <code>fast_pose</code> topic through an RPC mechanism. In addition, JMP Van Waveren's algorithm includes a method for warping between two reprojection matrices based on the actual progress of the display controller's \"scanline\"; this is simply commented out in our code, but can be re-enabled when our pose prediction system comes online.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__gl_2README/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__vk_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2timewarp  vk 2README","text":"<p>timewarp_vk</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__vk_2README/#summary","title":"Summary","text":"<p><code>timewarp_vk</code> is a Vulkan-based rotational reprojection service intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__vk_2README/#phonebook-service","title":"Phonebook Service","text":"<p><code>timewarp_vk</code> is registered as a service in phonebook, conforming to the <code>timewarp</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which <code>timewarp_vk</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> calculates the reprojection matrix given the current pose and the pose used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before <code>record_command_buffer</code> is called</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int left)</code> records the commands into a given command buffer that would perform the reprojection for one eye, for which 1 is left and 0 is right</li> </ul>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__vk_2README/#environment-variables","title":"Environment Variables","text":"<p>ILLIXR_TIMEWARP_DISABLE: whether to disable the warping, values can be \"True\" or \"False\"(default)</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2timewarp__vk_2README/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2zed_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2zed 2README","text":"<p>ZED Mini</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2zed_2README/#getting-started","title":"Getting started","text":"<ul> <li>First, download the latest version of the ZED SDK on stereolabs.com.</li> <li>For more information, read the ZED API documentation.</li> </ul>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2zed_2README/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ubuntu 22.04 or 24.04</li> <li>CUDA</li> <li>ZED SDK</li> <li>OpenCV 4 </li> </ul>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2zed_2capture_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2zed 2capture 2README","text":"<p>zed_capture</p> <p>The <code>zed_capture</code> binary is used to generate test data for injection into ILLIXR. The binary is a stand-alone feature and does not interact with the rest of ILLIXR. It takes the following command line arguments.</p> Argument Description Default -d, duration The duration to run for in seconds 10 -f, fps Frames per second 30 wc The origin of the world coordinate system in relation to the camera. Must be 7 comma separated values x, y, z, w, wx, wy, wz. 0., 0., 0., 1., 0., 0., 0. -p path The root path to write the data to. Current working directory <p><code>zed_capture</code> will write out the left and right camera images and the current pose at each frame. Note that it may not work at the requested fps due to overheads of writing files. This will be addressed in future updates. Note that the depth information is also not captured currently as OpenCV does not properly write out cv::Mat objects with float formats. This will also be addressed in future updates.</p> <p>Data are written to &lt;path&gt;/'fps' + &lt;fps_value&gt; + 'dur' + &lt;duration_value&gt; (e.g. &lt;path&gt;/fps30_dur10 will contain data taken at 30 frames per second with a total run time of 10 seconds, or 300 frames, it will always contain 300 frames regardless of any slow down due to overheads). This format is compatible with the zed.data_injection plugin. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2plugins_2zed_2data__injection_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2plugins 2zed 2data  injection 2README","text":"<p>ZED Data Injection</p> <p>This plugin reads in binocular images and pose information from files on disk and publishes them to ILLIXR. It is designed to feed data recorded by the zed_capture binary into the ILLIXR system. The root directory of the data must be specified in the <code>ILLIXR_TEST_DATA</code> environment variable. </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2services_2fauxpose_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2services 2fauxpose 2README","text":"<p>FauxPose ILLIXR plugin</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2services_2fauxpose_2README/#summary","title":"Summary","text":"<p>The <code>FauxPose</code> ILLIXR plugin generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking.</p> <p>The movement is hard-coded to be on the Y=center.y plane, with the X and Z values set to rotate in a circle. The period and amplitude of the movement are have default values (0.5, and 2.0 respectively) that can be changed through environment variables.  </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2services_2fauxpose_2README/#usage","title":"Usage","text":"<p>The \"FauxPose\" plugin must be included in the YAML configuration file prior to any rendering plugin (such as <code>debugview</code> or <code>gldemo</code>). Also, no other pose-generating plugin should be included.</p> <p>An example <code>profiles/fauxpose.yaml</code> configuration file is included as an example.</p> <p>By default, the \"orbit\" of the tracked position will be about the point (0.0, 1.5, 0.0), with a default amplitude of \" 2.0\", and period of \"0.5\" seconds, with the orientation facing the negative-X direction. The first three of these values can be overridden through environment variables:  </p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2services_2vkdemo_2README/","title":"md  2home 2friedel 2devel 2ILLIXR 2services 2vkdemo 2README","text":"<p>vkdemo</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2services_2vkdemo_2README/#summary","title":"Summary","text":"<p>The <code>vkdemo</code> service serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>vkdemo</code> will subscribe to several switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the switchboard API. <code>vkdemo</code> is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; <code>vkdemo</code> fills this requirement.</p>"},{"location":"api/md__2home_2friedel_2devel_2ILLIXR_2services_2vkdemo_2README/#phonebook-service","title":"Phonebook Service","text":"<p><code>vkdemo</code> is registered as a service in phonebook, conforming to the <code>app</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which <code>vkdemo</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> updates the uniform buffer with the given pose, which is used to render the scene. This must be called before <code>record_command_buffer</code> is called.</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int eye)</code> records the commands into a given command buffer that would perform the rendering for one eye, for which 0 is left and 1 is right. To achieve stereoscopic rendering, the function is called twice, once for each eye.</li> <li><code>virtual void destroy()</code> cleans up the resources allocated by <code>vkdemo</code>. Currently, this part is not yet implemented. </li> </ul>"},{"location":"api/misc_8hpp/","title":"File misc.hpp","text":"<p>FileList &gt; data_format &gt; misc.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;GL/glu.h&gt;</code></li> </ul>"},{"location":"api/misc_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/misc_8hpp/#classes","title":"Classes","text":"Type Name struct connection_signal struct hmd_physical_info struct hologram_input struct image_handle struct signal_to_quad struct vk_image_handle"},{"location":"api/misc_8hpp/#public-types","title":"Public Types","text":"Type Name typedef unsigned long long ullong"},{"location":"api/misc_8hpp/#macros","title":"Macros","text":"Type Name define USE_ALT_EYE_FORMAT"},{"location":"api/misc_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/misc_8hpp/#typedef-ullong","title":"typedef ullong","text":"<pre><code>using ullong =  unsigned long long;\n</code></pre>"},{"location":"api/misc_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/misc_8hpp/#define-use_alt_eye_format","title":"define USE_ALT_EYE_FORMAT","text":"<pre><code>#define USE_ALT_EYE_FORMAT \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/misc.hpp</code></p>"},{"location":"api/misc_8hpp_source/","title":"File misc.hpp","text":"<p>File List &gt; data_format &gt; misc.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;GL/glu.h&gt;\n\n// Tell gldemo and timewarp_gl to use two texture handle for left and right eye\n#define USE_ALT_EYE_FORMAT\n\nusing ullong = unsigned long long;\n\nnamespace ILLIXR::data_format {\n\nstruct [[maybe_unused]] connection_signal : public switchboard::event {\n    bool start;\n\n    explicit connection_signal(bool start_)\n        : start{start_} { }\n};\n\n// Used to identify which graphics API is being used (for swapchain construction)\nenum class graphics_api { OPENGL, VULKAN, TBD };\n\n// Used to distinguish between different image handles\nenum class swapchain_usage { LEFT_SWAPCHAIN, RIGHT_SWAPCHAIN, LEFT_RENDER, RIGHT_RENDER, NA };\n\ntypedef struct vk_image_handle {\n    int      file_descriptor;\n    int64_t  format;\n    size_t   allocation_size;\n    uint32_t width;\n    uint32_t height;\n\n    vk_image_handle(int fd_, int64_t format_, size_t alloc_size, uint32_t width_, uint32_t height_)\n        : file_descriptor{fd_}\n        , format{format_}\n        , allocation_size{alloc_size}\n        , width{width_}\n        , height{height_} { }\n} vk_image_handle;\n\n// This is used to share swapchain images between ILLIXR and Monado.\n// When Monado uses its GL pipeline, it's enough to just share a context during creation.\n// Otherwise, file descriptors are needed to share the images.\nstruct [[maybe_unused]] image_handle : public switchboard::event {\n    graphics_api type;\n\n    union {\n        GLuint          gl_handle{};\n        vk_image_handle vk_handle;\n    };\n\n    uint32_t        num_images;\n    swapchain_usage usage;\n\n    image_handle()\n        : type{graphics_api::TBD}\n        , gl_handle{0}\n        , num_images{0}\n        , usage{swapchain_usage::NA} { }\n\n    image_handle(GLuint gl_handle_, uint32_t num_images_, swapchain_usage usage_)\n        : type{graphics_api::OPENGL}\n        , gl_handle{gl_handle_}\n        , num_images{num_images_}\n        , usage{usage_} { }\n\n    image_handle(int vk_fd_, int64_t format, size_t alloc_size, uint32_t width_, uint32_t height_, uint32_t num_images_,\n                 swapchain_usage usage_)\n        : type{graphics_api::VULKAN}\n        , vk_handle{vk_fd_, format, alloc_size, width_, height_}\n        , num_images{num_images_}\n        , usage{usage_} { }\n};\n\nstruct [[maybe_unused]] hologram_input : public switchboard::event {\n    uint seq{};\n\n    hologram_input() = default;\n\n    explicit hologram_input(uint seq_)\n        : seq{seq_} { }\n};\n\nstruct [[maybe_unused]] signal_to_quad : public switchboard::event {\n    ullong seq;\n\n    explicit signal_to_quad(ullong seq_)\n        : seq{seq_} { }\n};\n\n// High-level HMD specification, timewarp plugin\n// may/will calculate additional HMD info based on these specifications\nstruct [[maybe_unused]] hmd_physical_info {\n    float ipd;\n    int   displayPixelsWide;\n    int   displayPixelsHigh;\n    float chromaticAberration[4];\n    float K[11];\n    int   visiblePixelsWide;\n    int   visiblePixelsHigh;\n    float visibleMetersWide;\n    float visibleMetersHigh;\n    float lensSeparationInMeters;\n    float metersPerTanAngleAtCenter;\n};\n\ninline bool compare(const std::string&amp; input, const std::string&amp; val) {\n    std::string v1 = input;\n    std::string v2 = val;\n    std::transform(v1.begin(), v1.end(), v1.begin(), ::tolower);\n    std::transform(v2.begin(), v2.end(), v2.begin(), ::tolower);\n    return v1 == v2;\n}\n\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"api/namespaceEigen/","title":"Namespace Eigen","text":"<p>Namespace List &gt; Eigen</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/namespaceILLIXR/","title":"Namespace ILLIXR","text":"<p>Namespace List &gt; ILLIXR</p> <p>RAC_ERRNO_MSG. More...</p>"},{"location":"api/namespaceILLIXR/#namespaces","title":"Namespaces","text":"Type Name namespace data_format namespace display namespace math_util namespace network namespace vulkan namespace zed_capture"},{"location":"api/namespaceILLIXR/#classes","title":"Classes","text":"Type Name struct Dependency struct DistortionCorrectionVertex struct DistortionMatrix struct OpenWarpVertex struct WarpMatrices class cancellable_sleep class data_injection class data_use_indicator A helper class that lets one dynamically determine if some data gets used. class debugview class depthai struct display_params Display parameters. class dynamic_lib class event A boolean condition-variable. class fauxpose class fauxpose_impl Create a \"pose_prediction\" type service. class gen_guid This class generates unique IDs. class gldemo class ground_truth_slam class gtsam_integrator struct index_params class lazy_load_image class lighthouse class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. struct model class native_renderer class offline_cam class offline_imu class offload_data class offload_reader class offload_rendering_client class offload_rendering_server Main server implementation for offload rendering. class offload_rendering_server_loader Plugin loader for the offload rendering server. class offload_writer class openni_plugin class openwarp_vk class openwarp_vk_plugin class passthrough_integrator class phonebook A service locator forILLIXR . class plugin A dynamically-loadable plugin for Spindle. class pose_lookup_impl class pose_prediction_impl struct raw_imu_type class realsense class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_imu_cam class record_logger The ILLIXR logging service for structured records. class record_rgb_depth class relative_clock Relative clock for all of ILLIXR . struct rendering_params Rendering parameters. class rk4_integrator class runtime struct sensor_types struct server_params class server_reader class server_writer class sqlite_record_logger class sqlite_thread struct state_plus class stdout_record_logger class stoplight Start/stop synchronization for the whole application. class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class tcp_network_backend struct texture class threadloop A reusable threadloop for plugins. class time_point class timewarp_gl class timewarp_vk class timewarp_vk_plugin struct vertex class video_decoder class video_encoder class viewer class vkdemo class vkdemo_plugin class webcam class xlib_gl_extended_window class zed_camera class zed_camera_thread class zed_imu_thread"},{"location":"api/namespaceILLIXR/#public-types","title":"Public Types","text":"Type Name typedef std::chrono::duration&lt; clock_rep_, clock_period_ &gt; clock_duration_ typedef std::nano clock_period_ typedef long clock_rep_ typedef relative_clock::duration duration typedef plugin *(* plugin_factory typedef std::size_t plugin_id_t typedef data_format::pose_type sensor_types typedef threadloop timewarp_type typedef std::unique_ptr&lt; void, std::function&lt; void(void *)&gt; &gt; void_ptr"},{"location":"api/namespaceILLIXR/#public-attributes","title":"Public Attributes","text":"Type Name const std::vector&lt; std::string &gt; ENV_VARS   = <code>/* multi line expression */</code> const size_t LOG_PERIOD   = <code>20</code> const record_header _plugin_start_header   = <code>/* multi line expression */</code> const record_header _switchboard_callback_header   = <code>/* multi line expression */</code> const record_header _switchboard_topic_stop_header   = <code>/* multi line expression */</code> const record_header _threadloop_iteration_header   = <code>/* multi line expression */</code> const data_format::proper_quaterniond dq_0 const std::vector&lt; std::string &gt; ignore_vars   = <code>{\"plugins\"}</code> size_t log_count_   = <code>0</code> constexpr float server_fov   = <code>0.99</code>"},{"location":"api/namespaceILLIXR/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const bool ENABLE_VERBOSE_ERRORS   = <code>/* multi line expression */</code> std::chrono::milliseconds LOG_BUFFER_DELAY   = <code>{1000}</code>"},{"location":"api/namespaceILLIXR/#public-functions","title":"Public Functions","text":"Type Name const Eigen::Vector3d Gravity (0. 0, 0. 0, 9. 81)  void abort (const std::string &amp; msg=\"\", const int error_val=1) Exits the application during a fatal error. GstFlowReturn cb_new_sample (GstElement * appsink, gpointer * user_data)  data_format::proper_quaterniond delta_q (const data_format::proper_quaterniond &amp; k_n)  double duration_to_double (duration dur)  constexpr duration freq_to_period (double fps)  Eigen::Matrix4d makeOmega (const Eigen::Vector3d &amp; w) Generate the Omega matrix from the input 3-element vector. bool operator!= (const time_point &amp; lhs, const time_point &amp; rhs)  time_point operator+ (const time_point &amp; pt, const time_point::duration &amp; d)  time_point operator+ (const time_point::duration &amp; d, const time_point &amp; pt)  time_point::duration operator- (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator&lt; (const time_point &amp; lhs, const time_point &amp; rhs)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const state_plus &amp; sp)  bool operator&lt;= (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator== (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator&gt; (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator&gt;= (const time_point &amp; lhs, const time_point &amp; rhs)  Eigen::Vector3d p_dot (const Eigen::Vector3d &amp; iv, const Eigen::Vector3d &amp; k_n) f(x) for the position Calculate the new position based on the initial velocity and change in velocity state_plus predict_mean_rk4 (double dt, const state_plus &amp; sp, const Eigen::Vector3d &amp; ang_vel, const Eigen::Vector3d &amp; linear_acc, const Eigen::Vector3d &amp; ang_vel2, const Eigen::Vector3d &amp; linear_acc2)  data_format::proper_quaterniond q_dot (const Eigen::Vector3d &amp; av, const data_format::proper_quaterniond &amp; dq)  void report_and_clear_errno (const std::string &amp; file, const int &amp; line, const std::string &amp; function, const std::string &amp; msg=\"\") Support function to report errno values when debugging (NDEBUG). int run (const cxxopts::ParseResult &amp; options)  runtime * runtime_factory ()  T solve (const T &amp; yn, const T &amp; k1, const T &amp; k2, const T &amp; k3, const T &amp; k4) Solve for the Runge-Kutta 4th order approximation. bool str_to_bool (const std::string &amp; var) Convert a string containing a (python) boolean to the bool type. Eigen::Matrix3d symmetric_skew (const Eigen::Vector3d &amp; vec) Generates a skew-symmetric matrix from the given 3-element vector. Eigen::Vector3d v_dot (const data_format::proper_quaterniond &amp; dq, const data_format::proper_quaterniond &amp; q, const Eigen::Vector3d &amp; l_acc) f(x) for the velocity Calculate the updated velocity from the acceleration and initial and delta quaternions"},{"location":"api/namespaceILLIXR/#detailed-description","title":"Detailed Description","text":"<p>There are many SQLite3 wrapper libraries. List source TODO: this </p>"},{"location":"api/namespaceILLIXR/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR/#typedef-clock_duration_","title":"typedef clock_duration_","text":"<pre><code>using ILLIXR::clock_duration_ = typedef std::chrono::duration&lt;clock_rep_, clock_period_&gt;;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-clock_period_","title":"typedef clock_period_","text":"<pre><code>using ILLIXR::clock_period_ = typedef std::nano;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-clock_rep_","title":"typedef clock_rep_","text":"<pre><code>using ILLIXR::clock_rep_ = typedef long;\n</code></pre> <p>Mimic of <code>std::chrono::time_point&lt;Clock, Rep&gt;</code> 1.</p> <p>Can't use <code>std::chrono::time_point&lt;Clock, Rep&gt;</code>, because the <code>Clock</code> must satisfy the Clock interface 2, but <code>relative_clock</code> cannot satisfy this interface because <code>relative_clock::now()</code> is a stateful (instance method) not pure (class method). Instead, we will mimic the interface of 1 here. </p>"},{"location":"api/namespaceILLIXR/#typedef-duration","title":"typedef duration","text":"<pre><code>using ILLIXR::duration = typedef relative_clock::duration;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-plugin_factory","title":"typedef plugin_factory","text":"<pre><code>typedef plugin *(* ILLIXR::plugin_factory) (phonebook *);\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-plugin_id_t","title":"typedef plugin_id_t","text":"<pre><code>typedef std::size_t ILLIXR::plugin_id_t;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-sensor_types","title":"typedef sensor_types","text":"<pre><code>typedef data_format::pose_type ILLIXR::sensor_types;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-timewarp_type","title":"typedef timewarp_type","text":"<pre><code>typedef threadloop ILLIXR::timewarp_type;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-void_ptr","title":"typedef void_ptr","text":"<pre><code>using ILLIXR::void_ptr = typedef std::unique_ptr&lt;void, std::function&lt;void(void*)&gt; &gt;;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-env_vars","title":"variable ENV_VARS","text":"<pre><code>const std::vector&lt;std::string&gt; ILLIXR::ENV_VARS;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-log_period","title":"variable LOG_PERIOD","text":"<pre><code>const size_t ILLIXR::LOG_PERIOD;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-_plugin_start_header","title":"variable _plugin_start_header","text":"<pre><code>const record_header ILLIXR::_plugin_start_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-_switchboard_callback_header","title":"variable _switchboard_callback_header","text":"<pre><code>const record_header ILLIXR::_switchboard_callback_header;\n</code></pre> <p>@Should be private to Switchboard. </p>"},{"location":"api/namespaceILLIXR/#variable-_switchboard_topic_stop_header","title":"variable _switchboard_topic_stop_header","text":"<pre><code>const record_header ILLIXR::_switchboard_topic_stop_header;\n</code></pre> <p>@Should be private to Switchboard. </p>"},{"location":"api/namespaceILLIXR/#variable-_threadloop_iteration_header","title":"variable _threadloop_iteration_header","text":"<pre><code>const record_header ILLIXR::_threadloop_iteration_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-dq_0","title":"variable dq_0","text":"<pre><code>const data_format::proper_quaterniond ILLIXR::dq_0(1., 0., 0., 0.);\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-ignore_vars","title":"variable ignore_vars","text":"<pre><code>const std::vector&lt;std::string&gt; ILLIXR::ignore_vars;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-log_count_","title":"variable log_count_","text":"<pre><code>size_t ILLIXR::log_count_;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-server_fov","title":"variable server_fov","text":"<pre><code>constexpr float ILLIXR::server_fov;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-enable_verbose_errors","title":"variable ENABLE_VERBOSE_ERRORS","text":"<pre><code>const bool ILLIXR::ENABLE_VERBOSE_ERRORS;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-log_buffer_delay","title":"variable LOG_BUFFER_DELAY","text":"<pre><code>std::chrono::milliseconds ILLIXR::LOG_BUFFER_DELAY;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR/#function-gravity","title":"function Gravity","text":"<pre><code>const Eigen::Vector3d ILLIXR::Gravity (\n    0. 0,\n    0. 0,\n    9. 81\n) \n</code></pre> <p>Initial quaternion </p>"},{"location":"api/namespaceILLIXR/#function-abort","title":"function abort","text":"<p>Exits the application during a fatal error. <pre><code>inline void ILLIXR::abort (\n    const std::string &amp; msg=\"\",\n    const int error_val=1\n) \n</code></pre></p> <p>Switches to using abort during debugging over std::exit so that we can capture SIGABRT for debugging. </p>"},{"location":"api/namespaceILLIXR/#function-cb_new_sample","title":"function cb_new_sample","text":"<pre><code>GstFlowReturn ILLIXR::cb_new_sample (\n    GstElement * appsink,\n    gpointer * user_data\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-delta_q","title":"function delta_q","text":"<pre><code>inline data_format::proper_quaterniond ILLIXR::delta_q (\n    const data_format::proper_quaterniond &amp; k_n\n) \n</code></pre> <p>Calculate the change in orientation based on the input Quaternion </p> <p>Parameters:</p> <ul> <li><code>k_n</code> The input Quaternion </li> </ul> <p>Returns:</p> <p>The change in orientation </p>"},{"location":"api/namespaceILLIXR/#function-duration_to_double","title":"function duration_to_double","text":"<pre><code>template&lt;typename Unit&gt;\ndouble ILLIXR::duration_to_double (\n    duration dur\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-freq_to_period","title":"function freq_to_period","text":"<pre><code>constexpr duration ILLIXR::freq_to_period (\n    double fps\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-makeomega","title":"function makeOmega","text":"<p>Generate the Omega matrix from the input 3-element vector. <pre><code>inline Eigen::Matrix4d ILLIXR::makeOmega (\n    const Eigen::Vector3d &amp; w\n) \n</code></pre></p> <p>Based on equation 48 of http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf </p>"},{"location":"api/namespaceILLIXR/#function-operator","title":"function operator!=","text":"<pre><code>inline bool ILLIXR::operator!= (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_1","title":"function operator+","text":"<pre><code>inline time_point ILLIXR::operator+ (\n    const time_point &amp; pt,\n    const time_point::duration &amp; d\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_2","title":"function operator+","text":"<pre><code>inline time_point ILLIXR::operator+ (\n    const time_point::duration &amp; d,\n    const time_point &amp; pt\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator-","title":"function operator-","text":"<pre><code>inline time_point::duration ILLIXR::operator- (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_3","title":"function operator&lt;","text":"<pre><code>inline bool ILLIXR::operator&lt; (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; ILLIXR::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const state_plus &amp; sp\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_5","title":"function operator&lt;=","text":"<pre><code>inline bool ILLIXR::operator&lt;= (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_6","title":"function operator==","text":"<pre><code>inline bool ILLIXR::operator== (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_7","title":"function operator&gt;","text":"<pre><code>inline bool ILLIXR::operator&gt; (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_8","title":"function operator&gt;=","text":"<pre><code>inline bool ILLIXR::operator&gt;= (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-p_dot","title":"function p_dot","text":"<p>f(x) for the position Calculate the new position based on the initial velocity and change in velocity <pre><code>inline Eigen::Vector3d ILLIXR::p_dot (\n    const Eigen::Vector3d &amp; iv,\n    const Eigen::Vector3d &amp; k_n\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>iv</code> The initial velocity as a vector </li> <li><code>k_n</code> The change in velocity as a vector </li> </ul> <p>Returns:</p> <p>The updated position </p>"},{"location":"api/namespaceILLIXR/#function-predict_mean_rk4","title":"function predict_mean_rk4","text":"<pre><code>state_plus ILLIXR::predict_mean_rk4 (\n    double dt,\n    const state_plus &amp; sp,\n    const Eigen::Vector3d &amp; ang_vel,\n    const Eigen::Vector3d &amp; linear_acc,\n    const Eigen::Vector3d &amp; ang_vel2,\n    const Eigen::Vector3d &amp; linear_acc2\n) \n</code></pre> <p>Calculate the updated state (orientation, position, and velocity) based on the initial and final velocities and accelerations </p> <p>Parameters:</p> <ul> <li><code>dt</code> The time between initial and final states (time step) </li> <li><code>sp</code> The initial state </li> <li><code>ang_vel</code> The initial angular velocity </li> <li><code>linear_acc</code> The initial linear acceleration </li> <li><code>ang_vel2</code> The final angular velocity </li> <li><code>linear_acc2</code> The final angular acceleration </li> </ul> <p>Returns:</p> <p>The final state </p>"},{"location":"api/namespaceILLIXR/#function-q_dot","title":"function q_dot","text":"<pre><code>inline data_format::proper_quaterniond ILLIXR::q_dot (\n    const Eigen::Vector3d &amp; av,\n    const data_format::proper_quaterniond &amp; dq\n) \n</code></pre> <p>f(x) for the orientation quaternion </p> <p>Parameters:</p> <ul> <li><code>av</code> Vector representing the angular velocity </li> <li><code>dq</code> The current orientation represented by a quaternion </li> </ul> <p>Returns:</p> <p>The updated quaternion as a new instance </p>"},{"location":"api/namespaceILLIXR/#function-report_and_clear_errno","title":"function report_and_clear_errno","text":"<p>Support function to report errno values when debugging (NDEBUG). <pre><code>inline void ILLIXR::report_and_clear_errno (\n    const std::string &amp; file,\n    const int &amp; line,\n    const std::string &amp; function,\n    const std::string &amp; msg=\"\"\n) \n</code></pre></p> <p>If errno is set, this function will report errno's value and the calling context. It will subsequently clear errno (reset value to 0). Otherwise, this function does nothing. </p>"},{"location":"api/namespaceILLIXR/#function-run","title":"function run","text":"<pre><code>int ILLIXR::run (\n    const cxxopts::ParseResult &amp; options\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-runtime_factory","title":"function runtime_factory","text":"<pre><code>runtime * ILLIXR::runtime_factory () \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-solve","title":"function solve","text":"<p>Solve for the Runge-Kutta 4th order approximation. <pre><code>template&lt;typename T&gt;\ninline T ILLIXR::solve (\n    const T &amp; yn,\n    const T &amp; k1,\n    const T &amp; k2,\n    const T &amp; k3,\n    const T &amp; k4\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> The data type </li> </ul> <p>Parameters:</p> <ul> <li><code>yn</code> The value at the last time step </li> <li><code>k1</code> Runge-Kutta first order </li> <li><code>k2</code> Runge-Kutta second order </li> <li><code>k3</code> Runge-Kutta third order </li> <li><code>k4</code> Runge-Kutta fourth order </li> </ul> <p>Returns:</p> <p>The approximated value </p>"},{"location":"api/namespaceILLIXR/#function-str_to_bool","title":"function str_to_bool","text":"<p>Convert a string containing a (python) boolean to the bool type. <pre><code>inline bool ILLIXR::str_to_bool (\n    const std::string &amp; var\n) \n</code></pre></p>"},{"location":"api/namespaceILLIXR/#function-symmetric_skew","title":"function symmetric_skew","text":"<p>Generates a skew-symmetric matrix from the given 3-element vector. <pre><code>inline Eigen::Matrix3d ILLIXR::symmetric_skew (\n    const Eigen::Vector3d &amp; vec\n) \n</code></pre></p> <p>Gravitational acceleration, at sea level, on Earth </p> <p>Based on equation 6 from http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf </p>"},{"location":"api/namespaceILLIXR/#function-v_dot","title":"function v_dot","text":"<p>f(x) for the velocity Calculate the updated velocity from the acceleration and initial and delta quaternions <pre><code>inline Eigen::Vector3d ILLIXR::v_dot (\n    const data_format::proper_quaterniond &amp; dq,\n    const data_format::proper_quaterniond &amp; q,\n    const Eigen::Vector3d &amp; l_acc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dq</code> The delta quaternion (change) </li> <li><code>q</code> The initial quaternion </li> <li><code>l_acc</code> The acceleration as a vector </li> </ul> <p>Returns:</p> <p>The calculated velocity as a vector </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/dynamic_lib.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1data__format/","title":"Namespace ILLIXR::data_format","text":"<p>Namespace List &gt; ILLIXR &gt; data_format</p>"},{"location":"api/namespaceILLIXR_1_1data__format/#namespaces","title":"Namespaces","text":"Type Name namespace camera namespace coordinates namespace ht namespace image namespace units"},{"location":"api/namespaceILLIXR_1_1data__format/#classes","title":"Classes","text":"Type Name struct binocular_cam_type struct cam_base_type struct cam_type_zed struct camera_data Data structure to hold information about the full camera system. This information is mostly constant. struct ccd_data A data structure to hold relevant camera information. This information is constant (per camera) struct compressed_frame struct connection_signal struct depth_type struct fast_pose_type struct hmd_physical_info struct hologram_input struct image_handle struct imu_integrator_input struct imu_params struct imu_raw_type struct imu_type struct monocular_cam_type struct point struct point_with_units struct point_with_validity struct points_with_units struct pose_data class pose_prediction struct pose_type class proper_quaternion &lt;typename Scalar_, Options_&gt;A more complete implementation of the Eigen::Quaternion. struct raw_point struct raw_pose struct rect struct rendered_frame struct rgb_depth_type struct signal_to_quad struct texture_pose struct vk_image_handle"},{"location":"api/namespaceILLIXR_1_1data__format/#public-types","title":"Public Types","text":"Type Name typedef std::map&lt; units::eyes, ccd_data &gt; ccd_map mapping of ccd information to the eye it is associated with, for monocular cameras use <code>units::LEFT_EYE</code> __ enum graphics_api typedef std::map&lt; units::eyes, pose_type &gt; multi_pose_map typedef proper_quaternion&lt; double &gt; proper_quaterniond typedef proper_quaternion&lt; float &gt; proper_quaternionf enum swapchain_usage typedef struct ILLIXR::data_format::vk_image_handle vk_image_handle"},{"location":"api/namespaceILLIXR_1_1data__format/#public-functions","title":"Public Functions","text":"Type Name point abs (const point &amp; pnt)  point_with_validity abs (const point_with_validity &amp; pnt)  point_with_units abs (const point_with_units &amp; pnt)  bool compare (const std::string &amp; input, const std::string &amp; val)  void denormalize (T &amp; obj, const float width, const float height, const float depth, units::measurement_unit unit_=units::PIXEL)  void denormalize (T &amp; obj, const float width, const float height, units::measurement_unit unit_=units::PIXEL)  void denormalize&lt; ht::hand_points &gt; (ht::hand_points &amp; obj, const float width, const float height, const float depth, units::measurement_unit unit_)  void denormalize&lt; ht::ht_detection &gt; (ht::ht_detection &amp; obj, const float width, const float height, const float depth, units::measurement_unit unit)  void denormalize&lt; ht::ht_frame &gt; (ht::ht_frame &amp; obj, const float width, const float height, const float depth, units::measurement_unit unit)  void denormalize&lt; ht::velocity &gt; (ht::velocity &amp; obj, const float width, const float height, const float depth, units::measurement_unit unit_)  void denormalize&lt; points_with_units &gt; (points_with_units &amp; obj, const float width, const float height, const float depth, units::measurement_unit unit_)  void denormalize&lt; rect &gt; (rect &amp; obj, const float width, const float height, const float depth, units::measurement_unit unit)  void normalize (T &amp; obj, const float width, const float height, const float depth)  void normalize (T &amp; obj, const float width, const float height)  void normalize&lt; ht::hand_points &gt; (ht::hand_points &amp; obj, const float width, const float height, const float depth)  void normalize&lt; ht::ht_detection &gt; (ht::ht_detection &amp; obj, const float width, const float height, const float depth)  void normalize&lt; ht::ht_frame &gt; (ht::ht_frame &amp; obj, const float width, const float height, const float depth)  void normalize&lt; ht::velocity &gt; (ht::velocity &amp; obj, const float width, const float height, const float depth)  void normalize&lt; points_with_units &gt; (points_with_units &amp; obj, const float width, const float height, const float depth)  void normalize&lt; rect &gt; (rect &amp; obj, const float width, const float height, const float depth)  proper_quaternion&lt; Scalar_ &gt; operator* (Scalar_ x, const proper_quaternion&lt; Scalar_ &gt; &amp; pq) Multiplication of scalar and ProperQuaternion. proper_quaternion&lt; Scalar_ &gt; operator/ (const proper_quaternion&lt; Scalar_ &gt; &amp; pq, Scalar_ x) Division of a ProperQuaternion by a scalar. std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const proper_quaternion&lt; T &gt; &amp; pq)"},{"location":"api/namespaceILLIXR_1_1data__format/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format/#typedef-ccd_map","title":"typedef ccd_map","text":"<p>mapping of ccd information to the eye it is associated with, for monocular cameras use <code>units::LEFT_EYE</code> __ <pre><code>typedef std::map&lt;units::eyes, ccd_data&gt; ILLIXR::data_format::ccd_map;\n</code></pre></p>"},{"location":"api/namespaceILLIXR_1_1data__format/#enum-graphics_api","title":"enum graphics_api","text":"<pre><code>enum ILLIXR::data_format::graphics_api {\n    OPENGL,\n    VULKAN,\n    TBD\n};\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#typedef-multi_pose_map","title":"typedef multi_pose_map","text":"<pre><code>typedef std::map&lt;units::eyes, pose_type&gt; ILLIXR::data_format::multi_pose_map;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#typedef-proper_quaterniond","title":"typedef proper_quaterniond","text":"<pre><code>typedef proper_quaternion&lt;double&gt; ILLIXR::data_format::proper_quaterniond;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#typedef-proper_quaternionf","title":"typedef proper_quaternionf","text":"<pre><code>typedef proper_quaternion&lt;float&gt; ILLIXR::data_format::proper_quaternionf;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#enum-swapchain_usage","title":"enum swapchain_usage","text":"<pre><code>enum ILLIXR::data_format::swapchain_usage {\n    LEFT_SWAPCHAIN,\n    RIGHT_SWAPCHAIN,\n    LEFT_RENDER,\n    RIGHT_RENDER,\n    NA\n};\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#typedef-vk_image_handle","title":"typedef vk_image_handle","text":"<pre><code>typedef struct ILLIXR::data_format::vk_image_handle ILLIXR::data_format::vk_image_handle;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format/#function-abs","title":"function abs","text":"<pre><code>inline point ILLIXR::data_format::abs (\n    const point &amp; pnt\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-abs_1","title":"function abs","text":"<pre><code>inline point_with_validity ILLIXR::data_format::abs (\n    const point_with_validity &amp; pnt\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-abs_2","title":"function abs","text":"<pre><code>inline point_with_units ILLIXR::data_format::abs (\n    const point_with_units &amp; pnt\n) \n</code></pre> <p>Determine the absolute value of a point (done on each coordinate) </p> <p>Parameters:</p> <ul> <li><code>value</code> The point to take the absolute value of </li> </ul> <p>Returns:</p> <p>A point containing the result </p>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-compare","title":"function compare","text":"<pre><code>inline bool ILLIXR::data_format::compare (\n    const std::string &amp; input,\n    const std::string &amp; val\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize","title":"function denormalize","text":"<pre><code>template&lt;typename T&gt;\ninline void ILLIXR::data_format::denormalize (\n    T &amp; obj,\n    const float width,\n    const float height,\n    const float depth,\n    units::measurement_unit unit_=units::PIXEL\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize_1","title":"function denormalize","text":"<pre><code>template&lt;typename T&gt;\ninline void ILLIXR::data_format::denormalize (\n    T &amp; obj,\n    const float width,\n    const float height,\n    units::measurement_unit unit_=units::PIXEL\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize-hthand_points","title":"function denormalize&lt; ht::hand_points &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::denormalize&lt; ht::hand_points &gt; (\n    ht::hand_points &amp; obj,\n    const float width,\n    const float height,\n    const float depth,\n    units::measurement_unit unit_\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize-htht_detection","title":"function denormalize&lt; ht::ht_detection &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::denormalize&lt; ht::ht_detection &gt; (\n    ht::ht_detection &amp; obj,\n    const float width,\n    const float height,\n    const float depth,\n    units::measurement_unit unit\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize-htht_frame","title":"function denormalize&lt; ht::ht_frame &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::denormalize&lt; ht::ht_frame &gt; (\n    ht::ht_frame &amp; obj,\n    const float width,\n    const float height,\n    const float depth,\n    units::measurement_unit unit\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize-htvelocity","title":"function denormalize&lt; ht::velocity &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::denormalize&lt; ht::velocity &gt; (\n    ht::velocity &amp; obj,\n    const float width,\n    const float height,\n    const float depth,\n    units::measurement_unit unit_\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize-points_with_units","title":"function denormalize&lt; points_with_units &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::denormalize&lt; points_with_units &gt; (\n    points_with_units &amp; obj,\n    const float width,\n    const float height,\n    const float depth,\n    units::measurement_unit unit_\n) \n</code></pre> <p>De-normalize a set of points to coordinates within the given bounds </p> <p>Parameters:</p> <ul> <li><code>obj</code> the points to de-normalize </li> <li><code>width</code> the x bound </li> <li><code>height</code> the y bound </li> <li><code>depth</code> the z bound </li> <li><code>unit_</code> the units for the points </li> </ul>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-denormalize-rect","title":"function denormalize&lt; rect &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::denormalize&lt; rect &gt; (\n    rect &amp; obj,\n    const float width,\n    const float height,\n    const float depth,\n    units::measurement_unit unit\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize","title":"function normalize","text":"<pre><code>template&lt;typename T&gt;\ninline void ILLIXR::data_format::normalize (\n    T &amp; obj,\n    const float width,\n    const float height,\n    const float depth\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize_1","title":"function normalize","text":"<pre><code>template&lt;typename T&gt;\ninline void ILLIXR::data_format::normalize (\n    T &amp; obj,\n    const float width,\n    const float height\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize-hthand_points","title":"function normalize&lt; ht::hand_points &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::normalize&lt; ht::hand_points &gt; (\n    ht::hand_points &amp; obj,\n    const float width,\n    const float height,\n    const float depth\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize-htht_detection","title":"function normalize&lt; ht::ht_detection &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::normalize&lt; ht::ht_detection &gt; (\n    ht::ht_detection &amp; obj,\n    const float width,\n    const float height,\n    const float depth\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize-htht_frame","title":"function normalize&lt; ht::ht_frame &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::normalize&lt; ht::ht_frame &gt; (\n    ht::ht_frame &amp; obj,\n    const float width,\n    const float height,\n    const float depth\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize-htvelocity","title":"function normalize&lt; ht::velocity &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::normalize&lt; ht::velocity &gt; (\n    ht::velocity &amp; obj,\n    const float width,\n    const float height,\n    const float depth\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize-points_with_units","title":"function normalize&lt; points_with_units &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::normalize&lt; points_with_units &gt; (\n    points_with_units &amp; obj,\n    const float width,\n    const float height,\n    const float depth\n) \n</code></pre> <p>Normalize a set of points based on the given bounds (all values will be 0. - 1.) </p> <p>Parameters:</p> <ul> <li><code>obj</code> The points to be normalized </li> <li><code>width</code> The x bound </li> <li><code>height</code> The y bound </li> <li><code>depth</code> The z bound </li> </ul>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-normalize-rect","title":"function normalize&lt; rect &gt;","text":"<pre><code>template&lt;&gt;\ninline void ILLIXR::data_format::normalize&lt; rect &gt; (\n    rect &amp; obj,\n    const float width,\n    const float height,\n    const float depth\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-operator","title":"function operator*","text":"<p>Multiplication of scalar and ProperQuaternion. <pre><code>template&lt;typename Scalar_&gt;\ninline proper_quaternion &lt; Scalar_ &gt; ILLIXR::data_format::operator* (\n    Scalar_ x,\n    const proper_quaternion &lt; Scalar_ &gt; &amp; pq\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Scalar_</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>x</code> The value to multiply the quaternion by </li> <li><code>pq</code> The quaternion to multiply </li> </ul> <p>Returns:</p> <p>The ProperQuaternion containing the result </p>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-operator_1","title":"function operator/","text":"<p>Division of a ProperQuaternion by a scalar. <pre><code>template&lt;typename Scalar_&gt;\ninline proper_quaternion &lt; Scalar_ &gt; ILLIXR::data_format::operator/ (\n    const proper_quaternion &lt; Scalar_ &gt; &amp; pq,\n    Scalar_ x\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Scalar_</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>pq</code> The quaternion to divide </li> <li><code>x</code> The value to divide the Quaternion by </li> </ul> <p>Returns:</p> <p>The ProperQuaternion containing the result </p>"},{"location":"api/namespaceILLIXR_1_1data__format/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\nstd::ostream &amp; ILLIXR::data_format::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const proper_quaternion &lt; T &gt; &amp; pq\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>pq</code> </li> </ul> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/camera_data.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1camera/","title":"Namespace ILLIXR::data_format::camera","text":"<p>Namespace List &gt; ILLIXR &gt; data_format &gt; camera</p> <p>More...</p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1camera/#public-types","title":"Public Types","text":"Type Name enum cam_type"},{"location":"api/namespaceILLIXR_1_1data__format_1_1camera/#detailed-description","title":"Detailed Description","text":"<p>Enumeration of camera types </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1camera/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1camera/#enum-cam_type","title":"enum cam_type","text":"<pre><code>enum ILLIXR::data_format::camera::cam_type {\n    BINOCULAR,\n    MONOCULAR,\n    RGB_DEPTH,\n    DEPTH,\n    ZED\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1coordinates/","title":"Namespace ILLIXR::data_format::coordinates","text":"<p>Namespace List &gt; ILLIXR &gt; data_format &gt; coordinates</p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1coordinates/#public-types","title":"Public Types","text":"Type Name enum frame enum reference_space"},{"location":"api/namespaceILLIXR_1_1data__format_1_1coordinates/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1coordinates/#enum-frame","title":"enum frame","text":"<pre><code>enum ILLIXR::data_format::coordinates::frame {\n    IMAGE,\n    LEFT_HANDED_Y_UP,\n    LEFT_HANDED_Z_UP,\n    RIGHT_HANDED_Y_UP,\n    RIGHT_HANDED_Z_UP,\n    RIGHT_HANDED_Z_UP_X_FWD\n};\n</code></pre> <p>Enumeration of the possible reference frames </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1coordinates/#enum-reference_space","title":"enum reference_space","text":"<pre><code>enum ILLIXR::data_format::coordinates::reference_space {\n    VIEWER,\n    WORLD,\n    ROOM = WORLD\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/coordinate.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/","title":"Namespace ILLIXR::data_format::ht","text":"<p>Namespace List &gt; ILLIXR &gt; data_format &gt; ht</p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#classes","title":"Classes","text":"Type Name struct hand_points struct ht_detection struct ht_frame struct position struct raw_ht_data struct velocity"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-types","title":"Public Types","text":"Type Name enum int hand enum int landmark_points"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-attributes","title":"Public Attributes","text":"Type Name const int NUM_LANDMARKS   = <code>21</code> const std::vector&lt; hand &gt; hand_map   = <code>{LEFT\\_HAND, RIGHT\\_HAND}</code> const std::map&lt; int, std::string &gt; point_str_map   = <code>/* multi line expression */</code>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const raw_ht_data &amp; data)  void transform_point (point_with_units &amp; pnt, const pose_data &amp; pose)"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-static-functions","title":"Public Static Functions","text":"Type Name void transform_points (points_with_units &amp; points, const pose_data &amp; pose, coordinates::reference_space from, coordinates::reference_space to)"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#enum-hand","title":"enum hand","text":"<pre><code>enum ILLIXR::data_format::ht::hand {\n    LEFT_HAND = 0,\n    RIGHT_HAND = 1\n};\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#enum-landmark_points","title":"enum landmark_points","text":"<pre><code>enum ILLIXR::data_format::ht::landmark_points {\n    WRIST,\n    THUMB_CMC,\n    THUMB_MCP,\n    THUMB_IP,\n    THUMB_TIP,\n    INDEX_FINGER_MCP,\n    INDEX_FINGER_PIP,\n    INDEX_FINGER_DIP,\n    INDEX_FINGER_TIP,\n    MIDDLE_FINGER_MCP,\n    MIDDLE_FINGER_PIP,\n    MIDDLE_FINGER_DIP,\n    MIDDLE_FINGER_TIP,\n    RING_FINGER_MCP,\n    RING_FINGER_PIP,\n    RING_FINGER_DIP,\n    RING_FINGER_TIP,\n    PINKY_MCP,\n    PINKY_PIP,\n    PINKY_DIP,\n    PINKY_TIP\n};\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#variable-num_landmarks","title":"variable NUM_LANDMARKS","text":"<pre><code>const int ILLIXR::data_format::ht::NUM_LANDMARKS;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#variable-hand_map","title":"variable hand_map","text":"<pre><code>const std::vector&lt;hand&gt; ILLIXR::data_format::ht::hand_map;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#variable-point_str_map","title":"variable point_str_map","text":"<pre><code>const std::map&lt;int, std::string&gt; ILLIXR::data_format::ht::point_str_map;\n</code></pre> <p>Mapping of the hand landmark points to strings, useful for display purposes </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; ILLIXR::data_format::ht::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const raw_ht_data &amp; data\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#function-transform_point","title":"function transform_point","text":"<pre><code>inline void ILLIXR::data_format::ht::transform_point (\n    point_with_units &amp; pnt,\n    const pose_data &amp; pose\n) \n</code></pre> <p>Transform a point from its current position using the given pose </p> <p>Parameters:</p> <ul> <li><code>pnt</code> Point to transform </li> <li><code>pose</code> Pose to use for the transformation </li> </ul>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1ht/#function-transform_points","title":"function transform_points","text":"<pre><code>static inline void ILLIXR::data_format::ht::transform_points (\n    points_with_units &amp; points,\n    const pose_data &amp; pose,\n    coordinates::reference_space from,\n    coordinates::reference_space to\n) \n</code></pre> <p>transform multiple points from their original position using the given pose </p> <p>Parameters:</p> <ul> <li><code>points</code> The points to transform </li> <li><code>pose</code> Pose to use for the transformation </li> <li><code>from</code> The coordinate frame to convert from </li> <li><code>to</code> The coordinate from to convert to </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1image/","title":"Namespace ILLIXR::data_format::image","text":"<p>Namespace List &gt; ILLIXR &gt; data_format &gt; image</p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1image/#public-types","title":"Public Types","text":"Type Name enum image_type"},{"location":"api/namespaceILLIXR_1_1data__format_1_1image/#public-attributes","title":"Public Attributes","text":"Type Name const std::map&lt; image_type, const std::string &gt; image_type_map   = <code>/* multi line expression */</code>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1image/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1image/#enum-image_type","title":"enum image_type","text":"<pre><code>enum ILLIXR::data_format::image::image_type {\n    LEFT_EYE,\n    RIGHT_EYE,\n    RGB,\n    DEPTH,\n    LEFT_EYE_PROCESSED,\n    RIGHT_EYE_PROCESSED,\n    RGB_PROCESSED,\n    CONFIDENCE\n};\n</code></pre> <p>Enumeration of image type </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1image/#variable-image_type_map","title":"variable image_type_map","text":"<pre><code>const std::map&lt;image_type, const std::string&gt; ILLIXR::data_format::image::image_type_map;\n</code></pre> <p>Mapping of <code>image_type</code> to a string representation. </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/","title":"Namespace ILLIXR::data_format::units","text":"<p>Namespace List &gt; ILLIXR &gt; data_format &gt; units</p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#public-types","title":"Public Types","text":"Type Name enum int eyes enum int measurement_unit"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#public-attributes","title":"Public Attributes","text":"Type Name constexpr float conversion_factor   = <code>/* multi line expression */</code> constexpr int last_convertable_unit   = <code>FOOT</code> const std::map&lt; measurement_unit, const std::string &gt; unit_str   = <code>/* multi line expression */</code>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#public-functions","title":"Public Functions","text":"Type Name float convert (const int from, const int to, float val)  eyes non_primary (eyes eye)"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#enum-eyes","title":"enum eyes","text":"<pre><code>enum ILLIXR::data_format::units::eyes {\n    LEFT_EYE = 0,\n    RIGHT_EYE = 1\n};\n</code></pre> <p>Enumeration for eyes </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#enum-measurement_unit","title":"enum measurement_unit","text":"<pre><code>enum ILLIXR::data_format::units::measurement_unit {\n    MILLIMETER = 0,\n    CENTIMETER = 1,\n    METER = 2,\n    INCH = 3,\n    FOOT = 4,\n    PERCENT = 5,\n    PIXEL = 6,\n    UNSET = 7\n};\n</code></pre> <p>Enumeration for units of distance </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#variable-conversion_factor","title":"variable conversion_factor","text":"<pre><code>constexpr float ILLIXR::data_format::units::conversion_factor[5][5];\n</code></pre> <p>Array of unit conversions, using <code>measurement_unit</code> as indices. The first index is the \"from\" unit and the second index is the \"to\" unit. For example <code>conversion_factor[MILLIMETER][INCH]</code> would yield 0.039, the conversion factor for millimeters to inches. </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#variable-last_convertable_unit","title":"variable last_convertable_unit","text":"<pre><code>constexpr int ILLIXR::data_format::units::last_convertable_unit;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#variable-unit_str","title":"variable unit_str","text":"<pre><code>const std::map&lt;measurement_unit, const std::string&gt; ILLIXR::data_format::units::unit_str;\n</code></pre> <p>Mapping of <code>measurement_unit</code> to a string representation. </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#function-convert","title":"function convert","text":"<pre><code>inline float ILLIXR::data_format::units::convert (\n    const int from,\n    const int to,\n    float val\n) \n</code></pre> <p>Convenience function for converting measurements. </p> <p>Parameters:</p> <ul> <li><code>from</code> The <code>measurement_unit</code> to convert from </li> <li><code>to</code> The <code>measurement_unit</code> to convert to </li> <li><code>val</code> The value to convert </li> </ul> <p>Returns:</p> <p>The converted value </p>"},{"location":"api/namespaceILLIXR_1_1data__format_1_1units/#function-non_primary","title":"function non_primary","text":"<pre><code>inline eyes ILLIXR::data_format::units::non_primary (\n    eyes eye\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/unit.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1display/","title":"Namespace ILLIXR::display","text":"<p>Namespace List &gt; ILLIXR &gt; display</p>"},{"location":"api/namespaceILLIXR_1_1display/#classes","title":"Classes","text":"Type Name class display_backend class glfw_extended class headless class x11_direct <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/display_backend.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1math__util/","title":"Namespace ILLIXR::math_util","text":"<p>Namespace List &gt; ILLIXR &gt; math_util</p>"},{"location":"api/namespaceILLIXR_1_1math__util/#public-attributes","title":"Public Attributes","text":"Type Name const Eigen::Matrix3f conversion   = <code>/* multi line expression */</code> const Eigen::Matrix3f identity   = <code>Eigen::Matrix3f::Identity()</code> const Eigen::Matrix3f invert_x   = <code>(Eigen::Matrix3f() &amp;lt;&amp;lt; -1., 0., 0., 0., 1., 0., 0., 0., 1.).finished()</code> const Eigen::Matrix3f invert_y   = <code>(Eigen::Matrix3f() &amp;lt;&amp;lt; 1., 0., 0., 0., -1., 0., 0., 0., 1.).finished()</code> const Eigen::Matrix3f invert_z   = <code>(Eigen::Matrix3f() &amp;lt;&amp;lt; 1., 0., 0., 0., 1., 0., 0., 0., -1.).finished()</code>"},{"location":"api/namespaceILLIXR_1_1math__util/#public-functions","title":"Public Functions","text":"Type Name void godot_projection (Eigen::Matrix4f * result, const float fov_left, const float fov_right, const float fov_up, const float fov_down)  void projection (Eigen::Matrix4f * result, const float tan_left, const float tan_right, const float tan_up, float const tan_down, const float near_z, const float far_z) Calculates a projection matrix with the given tangent angles and clip planes. void projection_fov (Eigen::Matrix4f * result, const float fov_left, const float fov_right, const float fov_up, const float fov_down, const float near_z, const float far_z, bool reverse_z=false) Calculates a projection matrix with the given FoVs and clip planes. void projection_reverse_z (Eigen::Matrix4f * result, const float tan_left, const float tan_right, const float tan_up, float const tan_down, const float near_z, const float far_z) Calculates a projection matrix with the given tangent angles and clip planes, with reversed depth. Eigen::Matrix3f rotation (const float alpha, const float beta, const float gamma)  void unreal_projection (Eigen::Matrix4f * result, const float fov_left, const float fov_right, const float fov_up, const float fov_down)"},{"location":"api/namespaceILLIXR_1_1math__util/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR_1_1math__util/#variable-conversion","title":"variable conversion","text":"<pre><code>const Eigen::Matrix3f ILLIXR::math_util::conversion[6][6];\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#variable-identity","title":"variable identity","text":"<pre><code>const Eigen::Matrix3f ILLIXR::math_util::identity;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#variable-invert_x","title":"variable invert_x","text":"<pre><code>const Eigen::Matrix3f ILLIXR::math_util::invert_x;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#variable-invert_y","title":"variable invert_y","text":"<pre><code>const Eigen::Matrix3f ILLIXR::math_util::invert_y;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#variable-invert_z","title":"variable invert_z","text":"<pre><code>const Eigen::Matrix3f ILLIXR::math_util::invert_z;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1math__util/#function-godot_projection","title":"function godot_projection","text":"<pre><code>void ILLIXR::math_util::godot_projection (\n    Eigen::Matrix4f * result,\n    const float fov_left,\n    const float fov_right,\n    const float fov_up,\n    const float fov_down\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#function-projection","title":"function projection","text":"<p>Calculates a projection matrix with the given tangent angles and clip planes. <pre><code>void ILLIXR::math_util::projection (\n    Eigen::Matrix4f * result,\n    const float tan_left,\n    const float tan_right,\n    const float tan_up,\n    float const tan_down,\n    const float near_z,\n    const float far_z\n) \n</code></pre></p>"},{"location":"api/namespaceILLIXR_1_1math__util/#function-projection_fov","title":"function projection_fov","text":"<p>Calculates a projection matrix with the given FoVs and clip planes. <pre><code>void ILLIXR::math_util::projection_fov (\n    Eigen::Matrix4f * result,\n    const float fov_left,\n    const float fov_right,\n    const float fov_up,\n    const float fov_down,\n    const float near_z,\n    const float far_z,\n    bool reverse_z=false\n) \n</code></pre></p>"},{"location":"api/namespaceILLIXR_1_1math__util/#function-projection_reverse_z","title":"function projection_reverse_z","text":"<p>Calculates a projection matrix with the given tangent angles and clip planes, with reversed depth. <pre><code>void ILLIXR::math_util::projection_reverse_z (\n    Eigen::Matrix4f * result,\n    const float tan_left,\n    const float tan_right,\n    const float tan_up,\n    float const tan_down,\n    const float near_z,\n    const float far_z\n) \n</code></pre></p>"},{"location":"api/namespaceILLIXR_1_1math__util/#function-rotation","title":"function rotation","text":"<pre><code>inline Eigen::Matrix3f ILLIXR::math_util::rotation (\n    const float alpha,\n    const float beta,\n    const float gamma\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1math__util/#function-unreal_projection","title":"function unreal_projection","text":"<pre><code>void ILLIXR::math_util::unreal_projection (\n    Eigen::Matrix4f * result,\n    const float fov_left,\n    const float fov_right,\n    const float fov_up,\n    const float fov_down\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/math_util.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1network/","title":"Namespace ILLIXR::network","text":"<p>Namespace List &gt; ILLIXR &gt; network</p>"},{"location":"api/namespaceILLIXR_1_1network/#classes","title":"Classes","text":"Type Name class TCPSocket class network_backend struct topic_config"},{"location":"api/namespaceILLIXR_1_1network/#public-attributes","title":"Public Attributes","text":"Type Name const std::string CLIENT_IP   = <code>\"127.0.0.1\"</code> const int CLIENT_PORT_1   = <code>5002</code> const int CLIENT_PORT_2   = <code>5003</code> const std::string SERVER_IP   = <code>\"127.0.0.1\"</code> const int SERVER_PORT_1   = <code>4042</code> const int SERVER_PORT_2   = <code>4003</code>"},{"location":"api/namespaceILLIXR_1_1network/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR_1_1network/#variable-client_ip","title":"variable CLIENT_IP","text":"<pre><code>const std::string ILLIXR::network::CLIENT_IP;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1network/#variable-client_port_1","title":"variable CLIENT_PORT_1","text":"<pre><code>const int ILLIXR::network::CLIENT_PORT_1;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1network/#variable-client_port_2","title":"variable CLIENT_PORT_2","text":"<pre><code>const int ILLIXR::network::CLIENT_PORT_2;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1network/#variable-server_ip","title":"variable SERVER_IP","text":"<pre><code>const std::string ILLIXR::network::SERVER_IP;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1network/#variable-server_port_1","title":"variable SERVER_PORT_1","text":"<pre><code>const int ILLIXR::network::SERVER_PORT_1;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1network/#variable-server_port_2","title":"variable SERVER_PORT_2","text":"<pre><code>const int ILLIXR::network::SERVER_PORT_2;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/net_config.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1vulkan/","title":"Namespace ILLIXR::vulkan","text":"<p>Namespace List &gt; ILLIXR &gt; vulkan</p>"},{"location":"api/namespaceILLIXR_1_1vulkan/#namespaces","title":"Namespaces","text":"Type Name namespace ffmpeg_utils"},{"location":"api/namespaceILLIXR_1_1vulkan/#classes","title":"Classes","text":"Type Name class app struct buffer_pool &lt;typename T&gt; class display_provider A display sink is a service that can display the rendered images to the screen. struct queue struct queue_families class render_pass struct swapchain_details class timewarp struct vk_image"},{"location":"api/namespaceILLIXR_1_1vulkan/#public-types","title":"Public Types","text":"Type Name typedef int8_t image_index_t"},{"location":"api/namespaceILLIXR_1_1vulkan/#public-functions","title":"Public Functions","text":"Type Name VkCommandBuffer begin_one_time_command (VkDevice vk_device, VkCommandPool vk_command_pool) Creates a one-time command buffer. void copy_buffer_to_image (VkDevice vk_device, queue q, VkCommandPool vk_command_pool, VkBuffer buffer, VkImage image, uint32_t width, uint32_t height) Copies a buffer to an image of the same size. VkCommandBuffer create_command_buffer (VkDevice device, VkCommandPool command_pool) Creates a VkCommandBuffer. VkCommandPool create_command_pool (VkDevice device, uint32_t queue_family_index) Creates a VkCommandPool. VkImageView create_image_view (VkDevice device, VkImage image, VkFormat format, VkImageAspectFlags aspect_flags)  VkShaderModule create_shader_module (VkDevice device, std::vector&lt; char &gt; &amp;&amp; code) Creates a VkShaderModule from SPIR-V bytecode. VkSemaphore create_timeline_semaphore (VkDevice device, int initial_value=0, VkExportSemaphoreCreateInfo * export_semaphore_create_info=nullptr)  VmaAllocator create_vma_allocator (VkInstance vk_instance, VkPhysicalDevice vk_physical_device, VkDevice vk_device) Creates a VMA allocator. void end_one_time_command (VkDevice vk_device, VkCommandPool vk_command_pool, const queue &amp; q, VkCommandBuffer vk_command_buffer) Ends, submits and frees a one-time command buffer. std::string error_string (VkResult err_code) Returns the string representation of a VkResult. queue_families find_queue_families (VkPhysicalDevice const &amp; physical_device, VkSurfaceKHR const &amp; vk_surface, bool no_present=false)  VkResult locked_queue_submit (queue &amp; q, uint32_t submitCount, const VkSubmitInfo * pSubmits, VkFence fence)  swapchain_details query_swapchain_details (VkPhysicalDevice const &amp; physical_device, VkSurfaceKHR const &amp; vk_surface)  std::vector&lt; char &gt; read_file (const std::string &amp; path) Reads a file into a vector of chars. void wait_timeline_semaphore (VkDevice device, VkSemaphore semaphore, uint64_t value)  void wait_timeline_semaphores (VkDevice device, const std::map&lt; VkSemaphore, uint64_t &gt; &amp; semaphores)"},{"location":"api/namespaceILLIXR_1_1vulkan/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1vulkan/#typedef-image_index_t","title":"typedef image_index_t","text":"<pre><code>typedef int8_t ILLIXR::vulkan::image_index_t;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1vulkan/#function-begin_one_time_command","title":"function begin_one_time_command","text":"<p>Creates a one-time command buffer. <pre><code>VkCommandBuffer ILLIXR::vulkan::begin_one_time_command (\n    VkDevice vk_device,\n    VkCommandPool vk_command_pool\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vk_device</code> The Vulkan device to use. </li> <li><code>vk_command_pool</code> The Vulkan command pool to use. </li> </ul> <p>Returns:</p> <p>The created command buffer. </p>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-copy_buffer_to_image","title":"function copy_buffer_to_image","text":"<p>Copies a buffer to an image of the same size. <pre><code>void ILLIXR::vulkan::copy_buffer_to_image (\n    VkDevice vk_device,\n    queue q,\n    VkCommandPool vk_command_pool,\n    VkBuffer buffer,\n    VkImage image,\n    uint32_t width,\n    uint32_t height\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vk_device</code> The Vulkan device to use. </li> <li><code>vk_queue</code> The Vulkan queue to use. </li> <li><code>vk_command_pool</code> The Vulkan command pool to use. </li> <li><code>buffer</code> The buffer to copy from. </li> <li><code>image</code> The image to copy to. </li> <li><code>width</code> The width of the image. </li> <li><code>height</code> The height of the image. </li> </ul>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-create_command_buffer","title":"function create_command_buffer","text":"<p>Creates a VkCommandBuffer. <pre><code>VkCommandBuffer ILLIXR::vulkan::create_command_buffer (\n    VkDevice device,\n    VkCommandPool command_pool\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>device</code> The Vulkan device to use. </li> <li><code>command_pool</code> The Vulkan command pool to use. </li> </ul>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-create_command_pool","title":"function create_command_pool","text":"<p>Creates a VkCommandPool. <pre><code>VkCommandPool ILLIXR::vulkan::create_command_pool (\n    VkDevice device,\n    uint32_t queue_family_index\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>device</code> The Vulkan device to use. </li> <li><code>queue_family_index</code> The queue family index to use. </li> </ul> <p>Returns:</p> <p>The created VkCommandPool. </p>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-create_image_view","title":"function create_image_view","text":"<pre><code>VkImageView ILLIXR::vulkan::create_image_view (\n    VkDevice device,\n    VkImage image,\n    VkFormat format,\n    VkImageAspectFlags aspect_flags\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-create_shader_module","title":"function create_shader_module","text":"<p>Creates a VkShaderModule from SPIR-V bytecode. <pre><code>VkShaderModule ILLIXR::vulkan::create_shader_module (\n    VkDevice device,\n    std::vector&lt; char &gt; &amp;&amp; code\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>device</code> The Vulkan device to use. </li> <li><code>code</code> The SPIR-V bytecode. </li> </ul> <p>Returns:</p> <p>The created VkShaderModule. </p>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-create_timeline_semaphore","title":"function create_timeline_semaphore","text":"<pre><code>VkSemaphore ILLIXR::vulkan::create_timeline_semaphore (\n    VkDevice device,\n    int initial_value=0,\n    VkExportSemaphoreCreateInfo * export_semaphore_create_info=nullptr\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-create_vma_allocator","title":"function create_vma_allocator","text":"<p>Creates a VMA allocator. <pre><code>VmaAllocator ILLIXR::vulkan::create_vma_allocator (\n    VkInstance vk_instance,\n    VkPhysicalDevice vk_physical_device,\n    VkDevice vk_device\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vk_instance</code> The Vulkan instance to use. </li> <li><code>vk_physical_device</code> The Vulkan physical device to use. </li> <li><code>vk_device</code> The Vulkan device to use. </li> </ul> <p>Returns:</p> <p>The created VMA allocator. </p>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-end_one_time_command","title":"function end_one_time_command","text":"<p>Ends, submits and frees a one-time command buffer. <pre><code>void ILLIXR::vulkan::end_one_time_command (\n    VkDevice vk_device,\n    VkCommandPool vk_command_pool,\n    const queue &amp; q,\n    VkCommandBuffer vk_command_buffer\n) \n</code></pre></p> <p>This function waits for the queue to become idle.</p> <p>Parameters:</p> <ul> <li><code>vk_device</code> The Vulkan device to use. </li> <li><code>vk_command_pool</code> The Vulkan command pool to use. </li> <li><code>vk_queue</code> The Vulkan queue to use. </li> <li><code>vk_command_buffer</code> The Vulkan command buffer to use. </li> </ul>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-error_string","title":"function error_string","text":"<p>Returns the string representation of a VkResult. <pre><code>std::string ILLIXR::vulkan::error_string (\n    VkResult err_code\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>err_code</code> The VkResult to convert to a string. </li> </ul> <p>Returns:</p> <p>The string representation of the VkResult. </p>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-find_queue_families","title":"function find_queue_families","text":"<pre><code>queue_families ILLIXR::vulkan::find_queue_families (\n    VkPhysicalDevice const &amp; physical_device,\n    VkSurfaceKHR const &amp; vk_surface,\n    bool no_present=false\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-locked_queue_submit","title":"function locked_queue_submit","text":"<pre><code>VkResult ILLIXR::vulkan::locked_queue_submit (\n    queue &amp; q,\n    uint32_t submitCount,\n    const VkSubmitInfo * pSubmits,\n    VkFence fence\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-query_swapchain_details","title":"function query_swapchain_details","text":"<pre><code>swapchain_details ILLIXR::vulkan::query_swapchain_details (\n    VkPhysicalDevice const &amp; physical_device,\n    VkSurfaceKHR const &amp; vk_surface\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-read_file","title":"function read_file","text":"<p>Reads a file into a vector of chars. <pre><code>std::vector&lt; char &gt; ILLIXR::vulkan::read_file (\n    const std::string &amp; path\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path</code> The path to the file. </li> </ul> <p>Returns:</p> <p>The vector of chars. </p>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-wait_timeline_semaphore","title":"function wait_timeline_semaphore","text":"<pre><code>void ILLIXR::vulkan::wait_timeline_semaphore (\n    VkDevice device,\n    VkSemaphore semaphore,\n    uint64_t value\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan/#function-wait_timeline_semaphores","title":"function wait_timeline_semaphores","text":"<pre><code>void ILLIXR::vulkan::wait_timeline_semaphores (\n    VkDevice device,\n    const std::map&lt; VkSemaphore, uint64_t &gt; &amp; semaphores\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/display_provider.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/","title":"Namespace ILLIXR::vulkan::ffmpeg_utils","text":"<p>Namespace List &gt; ILLIXR &gt; vulkan &gt; ffmpeg_utils</p>"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#classes","title":"Classes","text":"Type Name struct ffmpeg_vk_frame"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::weak_ptr&lt; vulkan::display_provider &gt; display_provider_ffmpeg"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#public-static-functions","title":"Public Static Functions","text":"Type Name void AV_ASSERT_SUCCESS (int ret)  void ffmpeg_lock_queue (struct AVHWDeviceContext * ctx, uint32_t queue_family, uint32_t index)  void ffmpeg_unlock_queue (struct AVHWDeviceContext * ctx, uint32_t queue_family, uint32_t index)  std::optional&lt; AVPixelFormat &gt; get_pix_format_from_vk_format (VkFormat format)"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#variable-display_provider_ffmpeg","title":"variable display_provider_ffmpeg","text":"<pre><code>std::weak_ptr&lt;vulkan::display_provider&gt; ILLIXR::vulkan::ffmpeg_utils::display_provider_ffmpeg;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#function-av_assert_success","title":"function AV_ASSERT_SUCCESS","text":"<pre><code>static void ILLIXR::vulkan::ffmpeg_utils::AV_ASSERT_SUCCESS (\n    int ret\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#function-ffmpeg_lock_queue","title":"function ffmpeg_lock_queue","text":"<pre><code>static void ILLIXR::vulkan::ffmpeg_utils::ffmpeg_lock_queue (\n    struct AVHWDeviceContext * ctx,\n    uint32_t queue_family,\n    uint32_t index\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#function-ffmpeg_unlock_queue","title":"function ffmpeg_unlock_queue","text":"<pre><code>static void ILLIXR::vulkan::ffmpeg_utils::ffmpeg_unlock_queue (\n    struct AVHWDeviceContext * ctx,\n    uint32_t queue_family,\n    uint32_t index\n) \n</code></pre>"},{"location":"api/namespaceILLIXR_1_1vulkan_1_1ffmpeg__utils/#function-get_pix_format_from_vk_format","title":"function get_pix_format_from_vk_format","text":"<pre><code>static std::optional&lt; AVPixelFormat &gt; ILLIXR::vulkan::ffmpeg_utils::get_pix_format_from_vk_format (\n    VkFormat format\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/ffmpeg_utils.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1zed__capture/","title":"Namespace ILLIXR::zed_capture","text":"<p>Namespace List &gt; ILLIXR &gt; zed_capture</p>"},{"location":"api/namespaceILLIXR_1_1zed__capture/#classes","title":"Classes","text":"Type Name class capture class files"},{"location":"api/namespaceILLIXR_1_1zed__capture/#public-types","title":"Public Types","text":"Type Name typedef std::map&lt; ILLIXR::data_format::image::image_type, cv::Mat &gt; img_map typedef std::map&lt; ILLIXR::data_format::image::image_type, std::string &gt; str_map"},{"location":"api/namespaceILLIXR_1_1zed__capture/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR_1_1zed__capture/#typedef-img_map","title":"typedef img_map","text":"<pre><code>typedef std::map&lt;ILLIXR::data_format::image::image_type, cv::Mat&gt; ILLIXR::zed_capture::img_map;\n</code></pre>"},{"location":"api/namespaceILLIXR_1_1zed__capture/#typedef-str_map","title":"typedef str_map","text":"<pre><code>typedef std::map&lt;ILLIXR::data_format::image::image_type, std::string&gt; ILLIXR::zed_capture::str_map;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/capture.hpp</code></p>"},{"location":"api/namespaceYAML/","title":"Namespace YAML","text":"<p>Namespace List &gt; YAML</p>"},{"location":"api/namespaceYAML/#classes","title":"Classes","text":"Type Name struct convert&lt; ILLIXR::Dependency &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/plugin.cpp</code></p>"},{"location":"api/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"api/namespace_member_enums/#c","title":"c","text":"<ul> <li>cam_type (ILLIXR::data_format::camera)</li> </ul>"},{"location":"api/namespace_member_enums/#e","title":"e","text":"<ul> <li>eyes (ILLIXR::data_format::units)</li> </ul>"},{"location":"api/namespace_member_enums/#f","title":"f","text":"<ul> <li>frame (ILLIXR::data_format::coordinates)</li> </ul>"},{"location":"api/namespace_member_enums/#g","title":"g","text":"<ul> <li>graphics_api (ILLIXR::data_format)</li> </ul>"},{"location":"api/namespace_member_enums/#h","title":"h","text":"<ul> <li>hand (ILLIXR::data_format::ht)</li> </ul>"},{"location":"api/namespace_member_enums/#i","title":"i","text":"<ul> <li>image_type (ILLIXR::data_format::image)</li> </ul>"},{"location":"api/namespace_member_enums/#l","title":"l","text":"<ul> <li>landmark_points (ILLIXR::data_format::ht)</li> </ul>"},{"location":"api/namespace_member_enums/#m","title":"m","text":"<ul> <li>measurement_unit (ILLIXR::data_format::units)</li> </ul>"},{"location":"api/namespace_member_enums/#r","title":"r","text":"<ul> <li>reference_space (ILLIXR::data_format::coordinates)</li> </ul>"},{"location":"api/namespace_member_enums/#s","title":"s","text":"<ul> <li>swapchain_usage (ILLIXR::data_format)</li> </ul>"},{"location":"api/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"api/namespace_member_functions/#a","title":"a","text":"<ul> <li>abs (ILLIXR::data_format)</li> <li>AV_ASSERT_SUCCESS (ILLIXR::vulkan::ffmpeg_utils)</li> <li>abort (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#b","title":"b","text":"<ul> <li>begin_one_time_command (ILLIXR::vulkan)</li> </ul>"},{"location":"api/namespace_member_functions/#c","title":"c","text":"<ul> <li>convert (ILLIXR::data_format::units)</li> <li>compare (ILLIXR::data_format)</li> <li>copy_buffer_to_image (ILLIXR::vulkan)</li> <li>create_command_buffer (ILLIXR::vulkan)</li> <li>create_command_pool (ILLIXR::vulkan)</li> <li>create_image_view (ILLIXR::vulkan)</li> <li>create_shader_module (ILLIXR::vulkan)</li> <li>create_timeline_semaphore (ILLIXR::vulkan)</li> <li>create_vma_allocator (ILLIXR::vulkan)</li> <li>cb_new_sample (ILLIXR)</li> <li>checked_negate (cxxopts::values)</li> <li>check_signed_range (cxxopts::values::detail)</li> </ul>"},{"location":"api/namespace_member_functions/#d","title":"d","text":"<ul> <li>denormalize (ILLIXR::data_format)</li> <li>denormalize&lt; ht::hand_points &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; ht::ht_detection &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; ht::ht_frame &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; ht::velocity &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; points_with_units &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; rect &gt; (ILLIXR::data_format)</li> <li>delta_q (ILLIXR)</li> <li>duration_to_double (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#e","title":"e","text":"<ul> <li>end_one_time_command (ILLIXR::vulkan)</li> <li>error_string (ILLIXR::vulkan)</li> <li>empty (cxxopts)</li> </ul>"},{"location":"api/namespace_member_functions/#f","title":"f","text":"<ul> <li>ffmpeg_lock_queue (ILLIXR::vulkan::ffmpeg_utils)</li> <li>ffmpeg_unlock_queue (ILLIXR::vulkan::ffmpeg_utils)</li> <li>find_queue_families (ILLIXR::vulkan)</li> <li>freq_to_period (ILLIXR)</li> <li>first_or_empty (cxxopts)</li> </ul>"},{"location":"api/namespace_member_functions/#g","title":"g","text":"<ul> <li>Gravity (ILLIXR)</li> <li>godot_projection (ILLIXR::math_util)</li> <li>get_pix_format_from_vk_format (ILLIXR::vulkan::ffmpeg_utils)</li> </ul>"},{"location":"api/namespace_member_functions/#i","title":"i","text":"<ul> <li>IsFalseText (cxxopts::values::parser_tool)</li> <li>IsTrueText (cxxopts::values::parser_tool)</li> <li>integer_parser (cxxopts::values)</li> </ul>"},{"location":"api/namespace_member_functions/#l","title":"l","text":"<ul> <li>locked_queue_submit (ILLIXR::vulkan)</li> </ul>"},{"location":"api/namespace_member_functions/#m","title":"m","text":"<ul> <li>makeOmega (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#n","title":"n","text":"<ul> <li>non_primary (ILLIXR::data_format::units)</li> <li>normalize (ILLIXR::data_format)</li> <li>normalize&lt; ht::hand_points &gt; (ILLIXR::data_format)</li> <li>normalize&lt; ht::ht_detection &gt; (ILLIXR::data_format)</li> <li>normalize&lt; ht::ht_frame &gt; (ILLIXR::data_format)</li> <li>normalize&lt; ht::velocity &gt; (ILLIXR::data_format)</li> <li>normalize&lt; points_with_units &gt; (ILLIXR::data_format)</li> <li>normalize&lt; rect &gt; (ILLIXR::data_format)</li> </ul>"},{"location":"api/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (ILLIXR::data_format::ht, ILLIXR::data_format, ILLIXR)</li> <li>operator* (ILLIXR::data_format)</li> <li>operator/ (ILLIXR::data_format)</li> <li>operator!= (ILLIXR)</li> <li>operator+ (ILLIXR)</li> <li>operator- (ILLIXR)</li> <li>operator&lt; (ILLIXR)</li> <li>operator&lt;= (ILLIXR)</li> <li>operator== (ILLIXR)</li> <li>operator&gt; (ILLIXR)</li> <li>operator&gt;= (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#p","title":"p","text":"<ul> <li>projection (ILLIXR::math_util)</li> <li>projection_fov (ILLIXR::math_util)</li> <li>projection_reverse_z (ILLIXR::math_util)</li> <li>p_dot (ILLIXR)</li> <li>predict_mean_rk4 (ILLIXR)</li> <li>ParseArgument (cxxopts::values::parser_tool)</li> <li>parse_value (cxxopts::values)</li> </ul>"},{"location":"api/namespace_member_functions/#q","title":"q","text":"<ul> <li>query_swapchain_details (ILLIXR::vulkan)</li> <li>q_dot (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#r","title":"r","text":"<ul> <li>rotation (ILLIXR::math_util)</li> <li>read_file (ILLIXR::vulkan)</li> <li>report_and_clear_errno (ILLIXR)</li> <li>run (ILLIXR)</li> <li>runtime_factory (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#s","title":"s","text":"<ul> <li>solve (ILLIXR)</li> <li>str_to_bool (ILLIXR)</li> <li>symmetric_skew (ILLIXR)</li> <li>serialize (boost::serialization)</li> <li>SplitInteger (cxxopts::values::parser_tool)</li> <li>split_option_names (cxxopts::values::parser_tool)</li> <li>stringstream_parser (cxxopts::values)</li> <li>stringAppend (cxxopts)</li> <li>stringLength (cxxopts)</li> </ul>"},{"location":"api/namespace_member_functions/#t","title":"t","text":"<ul> <li>transform_point (ILLIXR::data_format::ht)</li> <li>transform_points (ILLIXR::data_format::ht)</li> <li>throw_or_mimic (cxxopts)</li> <li>toLocalString (cxxopts)</li> <li>toUTF8String (cxxopts)</li> </ul>"},{"location":"api/namespace_member_functions/#u","title":"u","text":"<ul> <li>unreal_projection (ILLIXR::math_util)</li> </ul>"},{"location":"api/namespace_member_functions/#v","title":"v","text":"<ul> <li>v_dot (ILLIXR)</li> <li>value (cxxopts)</li> </ul>"},{"location":"api/namespace_member_functions/#w","title":"w","text":"<ul> <li>wait_timeline_semaphore (ILLIXR::vulkan)</li> <li>wait_timeline_semaphores (ILLIXR::vulkan)</li> </ul>"},{"location":"api/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"api/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>ccd_map (ILLIXR::data_format)</li> <li>clock_duration_ (ILLIXR)</li> <li>clock_period_ (ILLIXR)</li> <li>clock_rep_ (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>duration (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>image_index_t (ILLIXR::vulkan)</li> <li>img_map (ILLIXR::zed_capture)</li> </ul>"},{"location":"api/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>multi_pose_map (ILLIXR::data_format)</li> </ul>"},{"location":"api/namespace_member_typedefs/#n","title":"n","text":"<ul> <li>NameHashMap (cxxopts)</li> </ul>"},{"location":"api/namespace_member_typedefs/#o","title":"o","text":"<ul> <li>OptionMap (cxxopts)</li> <li>OptionNames (cxxopts)</li> </ul>"},{"location":"api/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>proper_quaterniond (ILLIXR::data_format)</li> <li>proper_quaternionf (ILLIXR::data_format)</li> <li>plugin_factory (ILLIXR)</li> <li>plugin_id_t (ILLIXR)</li> <li>ParsedHashMap (cxxopts)</li> <li>PositionalList (cxxopts)</li> <li>PositionalListIterator (cxxopts)</li> </ul>"},{"location":"api/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>str_map (ILLIXR::zed_capture)</li> <li>sensor_types (ILLIXR)</li> <li>String (cxxopts)</li> </ul>"},{"location":"api/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>timewarp_type (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>vk_image_handle (ILLIXR::data_format)</li> <li>void_ptr (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"api/namespace_member_variables/#c","title":"c","text":"<ul> <li>conversion_factor (ILLIXR::data_format::units)</li> <li>conversion (ILLIXR::math_util)</li> <li>CLIENT_IP (ILLIXR::network)</li> <li>CLIENT_PORT_1 (ILLIXR::network)</li> <li>CLIENT_PORT_2 (ILLIXR::network)</li> <li>currentMat (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#d","title":"d","text":"<ul> <li>display_provider_ffmpeg (ILLIXR::vulkan::ffmpeg_utils)</li> <li>dq_0 (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#e","title":"e","text":"<ul> <li>ENABLE_VERBOSE_ERRORS (ILLIXR)</li> <li>ENV_VARS (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#g","title":"g","text":"<ul> <li>global_normals (parser)</li> <li>global_verts (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#h","title":"h","text":"<ul> <li>hand_map (ILLIXR::data_format::ht)</li> </ul>"},{"location":"api/namespace_member_variables/#i","title":"i","text":"<ul> <li>image_type_map (ILLIXR::data_format::image)</li> <li>identity (ILLIXR::math_util)</li> <li>invert_x (ILLIXR::math_util)</li> <li>invert_y (ILLIXR::math_util)</li> <li>invert_z (ILLIXR::math_util)</li> <li>ignore_vars (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#l","title":"l","text":"<ul> <li>last_convertable_unit (ILLIXR::data_format::units)</li> <li>LOG_BUFFER_DELAY (ILLIXR)</li> <li>LOG_PERIOD (ILLIXR)</li> <li>log_count_ (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#m","title":"m","text":"<ul> <li>major (cxxopts)</li> <li>minor (cxxopts)</li> <li>mats (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#n","title":"n","text":"<ul> <li>NUM_LANDMARKS (ILLIXR::data_format::ht)</li> <li>n0_idx (parser)</li> <li>n1_idx (parser)</li> <li>n2_idx (parser)</li> <li>normal (parser)</li> <li>num_normals (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#o","title":"o","text":"<ul> <li>objects (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#p","title":"p","text":"<ul> <li>point_str_map (ILLIXR::data_format::ht)</li> <li>patch (cxxopts)</li> </ul>"},{"location":"api/namespace_member_variables/#r","title":"r","text":"<ul> <li>result (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#s","title":"s","text":"<ul> <li>SERVER_IP (ILLIXR::network)</li> <li>SERVER_PORT_1 (ILLIXR::network)</li> <li>SERVER_PORT_2 (ILLIXR::network)</li> <li>server_fov (ILLIXR)</li> <li>splitLine (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#t","title":"t","text":"<ul> <li>triangles (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#u","title":"u","text":"<ul> <li>unit_str (ILLIXR::data_format::units)</li> </ul>"},{"location":"api/namespace_member_variables/#v","title":"v","text":"<ul> <li>version (cxxopts)</li> <li>v0_idx (parser)</li> <li>v1_idx (parser)</li> <li>v2_idx (parser)</li> <li>vertex (parser)</li> </ul>"},{"location":"api/namespace_member_variables/#_","title":"_","text":"<ul> <li>_plugin_start_header (ILLIXR)</li> <li>_switchboard_callback_header (ILLIXR)</li> <li>_switchboard_topic_stop_header (ILLIXR)</li> <li>_threadloop_iteration_header (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/","title":"Namespace Members","text":""},{"location":"api/namespace_members/#a","title":"a","text":"<ul> <li>abs (ILLIXR::data_format)</li> <li>AV_ASSERT_SUCCESS (ILLIXR::vulkan::ffmpeg_utils)</li> <li>abort (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#b","title":"b","text":"<ul> <li>begin_one_time_command (ILLIXR::vulkan)</li> </ul>"},{"location":"api/namespace_members/#c","title":"c","text":"<ul> <li>cam_type (ILLIXR::data_format::camera)</li> <li>conversion_factor (ILLIXR::data_format::units)</li> <li>convert (ILLIXR::data_format::units)</li> <li>ccd_map (ILLIXR::data_format)</li> <li>compare (ILLIXR::data_format)</li> <li>conversion (ILLIXR::math_util)</li> <li>CLIENT_IP (ILLIXR::network)</li> <li>CLIENT_PORT_1 (ILLIXR::network)</li> <li>CLIENT_PORT_2 (ILLIXR::network)</li> <li>copy_buffer_to_image (ILLIXR::vulkan)</li> <li>create_command_buffer (ILLIXR::vulkan)</li> <li>create_command_pool (ILLIXR::vulkan)</li> <li>create_image_view (ILLIXR::vulkan)</li> <li>create_shader_module (ILLIXR::vulkan)</li> <li>create_timeline_semaphore (ILLIXR::vulkan)</li> <li>create_vma_allocator (ILLIXR::vulkan)</li> <li>cb_new_sample (ILLIXR)</li> <li>clock_duration_ (ILLIXR)</li> <li>clock_period_ (ILLIXR)</li> <li>clock_rep_ (ILLIXR)</li> <li>checked_negate (cxxopts::values)</li> <li>check_signed_range (cxxopts::values::detail)</li> <li>currentMat (parser)</li> </ul>"},{"location":"api/namespace_members/#d","title":"d","text":"<ul> <li>denormalize (ILLIXR::data_format)</li> <li>denormalize&lt; ht::hand_points &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; ht::ht_detection &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; ht::ht_frame &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; ht::velocity &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; points_with_units &gt; (ILLIXR::data_format)</li> <li>denormalize&lt; rect &gt; (ILLIXR::data_format)</li> <li>display_provider_ffmpeg (ILLIXR::vulkan::ffmpeg_utils)</li> <li>delta_q (ILLIXR)</li> <li>dq_0 (ILLIXR)</li> <li>duration (ILLIXR)</li> <li>duration_to_double (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#e","title":"e","text":"<ul> <li>ENABLE_VERBOSE_ERRORS (ILLIXR)</li> <li>ENV_VARS (ILLIXR)</li> <li>eyes (ILLIXR::data_format::units)</li> <li>end_one_time_command (ILLIXR::vulkan)</li> <li>error_string (ILLIXR::vulkan)</li> <li>empty (cxxopts)</li> </ul>"},{"location":"api/namespace_members/#f","title":"f","text":"<ul> <li>frame (ILLIXR::data_format::coordinates)</li> <li>ffmpeg_lock_queue (ILLIXR::vulkan::ffmpeg_utils)</li> <li>ffmpeg_unlock_queue (ILLIXR::vulkan::ffmpeg_utils)</li> <li>find_queue_families (ILLIXR::vulkan)</li> <li>freq_to_period (ILLIXR)</li> <li>first_or_empty (cxxopts)</li> </ul>"},{"location":"api/namespace_members/#g","title":"g","text":"<ul> <li>Gravity (ILLIXR)</li> <li>graphics_api (ILLIXR::data_format)</li> <li>godot_projection (ILLIXR::math_util)</li> <li>get_pix_format_from_vk_format (ILLIXR::vulkan::ffmpeg_utils)</li> <li>global_normals (parser)</li> <li>global_verts (parser)</li> </ul>"},{"location":"api/namespace_members/#h","title":"h","text":"<ul> <li>hand (ILLIXR::data_format::ht)</li> <li>hand_map (ILLIXR::data_format::ht)</li> </ul>"},{"location":"api/namespace_members/#i","title":"i","text":"<ul> <li>image_type (ILLIXR::data_format::image)</li> <li>image_type_map (ILLIXR::data_format::image)</li> <li>identity (ILLIXR::math_util)</li> <li>invert_x (ILLIXR::math_util)</li> <li>invert_y (ILLIXR::math_util)</li> <li>invert_z (ILLIXR::math_util)</li> <li>image_index_t (ILLIXR::vulkan)</li> <li>img_map (ILLIXR::zed_capture)</li> <li>ignore_vars (ILLIXR)</li> <li>IsFalseText (cxxopts::values::parser_tool)</li> <li>IsTrueText (cxxopts::values::parser_tool)</li> <li>integer_parser (cxxopts::values)</li> </ul>"},{"location":"api/namespace_members/#l","title":"l","text":"<ul> <li>landmark_points (ILLIXR::data_format::ht)</li> <li>last_convertable_unit (ILLIXR::data_format::units)</li> <li>locked_queue_submit (ILLIXR::vulkan)</li> <li>LOG_BUFFER_DELAY (ILLIXR)</li> <li>LOG_PERIOD (ILLIXR)</li> <li>log_count_ (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#m","title":"m","text":"<ul> <li>measurement_unit (ILLIXR::data_format::units)</li> <li>multi_pose_map (ILLIXR::data_format)</li> <li>makeOmega (ILLIXR)</li> <li>major (cxxopts)</li> <li>minor (cxxopts)</li> <li>mats (parser)</li> </ul>"},{"location":"api/namespace_members/#n","title":"n","text":"<ul> <li>NUM_LANDMARKS (ILLIXR::data_format::ht)</li> <li>non_primary (ILLIXR::data_format::units)</li> <li>normalize (ILLIXR::data_format)</li> <li>normalize&lt; ht::hand_points &gt; (ILLIXR::data_format)</li> <li>normalize&lt; ht::ht_detection &gt; (ILLIXR::data_format)</li> <li>normalize&lt; ht::ht_frame &gt; (ILLIXR::data_format)</li> <li>normalize&lt; ht::velocity &gt; (ILLIXR::data_format)</li> <li>normalize&lt; points_with_units &gt; (ILLIXR::data_format)</li> <li>normalize&lt; rect &gt; (ILLIXR::data_format)</li> <li>NameHashMap (cxxopts)</li> <li>n0_idx (parser)</li> <li>n1_idx (parser)</li> <li>n2_idx (parser)</li> <li>normal (parser)</li> <li>num_normals (parser)</li> </ul>"},{"location":"api/namespace_members/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (ILLIXR::data_format::ht, ILLIXR::data_format, ILLIXR)</li> <li>operator* (ILLIXR::data_format)</li> <li>operator/ (ILLIXR::data_format)</li> <li>operator!= (ILLIXR)</li> <li>operator+ (ILLIXR)</li> <li>operator- (ILLIXR)</li> <li>operator&lt; (ILLIXR)</li> <li>operator&lt;= (ILLIXR)</li> <li>operator== (ILLIXR)</li> <li>operator&gt; (ILLIXR)</li> <li>operator&gt;= (ILLIXR)</li> <li>OptionMap (cxxopts)</li> <li>OptionNames (cxxopts)</li> <li>objects (parser)</li> </ul>"},{"location":"api/namespace_members/#p","title":"p","text":"<ul> <li>point_str_map (ILLIXR::data_format::ht)</li> <li>proper_quaterniond (ILLIXR::data_format)</li> <li>proper_quaternionf (ILLIXR::data_format)</li> <li>projection (ILLIXR::math_util)</li> <li>projection_fov (ILLIXR::math_util)</li> <li>projection_reverse_z (ILLIXR::math_util)</li> <li>p_dot (ILLIXR)</li> <li>plugin_factory (ILLIXR)</li> <li>plugin_id_t (ILLIXR)</li> <li>predict_mean_rk4 (ILLIXR)</li> <li>ParsedHashMap (cxxopts)</li> <li>PositionalList (cxxopts)</li> <li>PositionalListIterator (cxxopts)</li> <li>ParseArgument (cxxopts::values::parser_tool)</li> <li>parse_value (cxxopts::values)</li> <li>patch (cxxopts)</li> </ul>"},{"location":"api/namespace_members/#q","title":"q","text":"<ul> <li>query_swapchain_details (ILLIXR::vulkan)</li> <li>q_dot (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#r","title":"r","text":"<ul> <li>reference_space (ILLIXR::data_format::coordinates)</li> <li>rotation (ILLIXR::math_util)</li> <li>read_file (ILLIXR::vulkan)</li> <li>report_and_clear_errno (ILLIXR)</li> <li>run (ILLIXR)</li> <li>runtime_factory (ILLIXR)</li> <li>result (parser)</li> </ul>"},{"location":"api/namespace_members/#s","title":"s","text":"<ul> <li>swapchain_usage (ILLIXR::data_format)</li> <li>SERVER_IP (ILLIXR::network)</li> <li>SERVER_PORT_1 (ILLIXR::network)</li> <li>SERVER_PORT_2 (ILLIXR::network)</li> <li>str_map (ILLIXR::zed_capture)</li> <li>sensor_types (ILLIXR)</li> <li>server_fov (ILLIXR)</li> <li>solve (ILLIXR)</li> <li>str_to_bool (ILLIXR)</li> <li>symmetric_skew (ILLIXR)</li> <li>serialize (boost::serialization)</li> <li>String (cxxopts)</li> <li>SplitInteger (cxxopts::values::parser_tool)</li> <li>split_option_names (cxxopts::values::parser_tool)</li> <li>stringstream_parser (cxxopts::values)</li> <li>stringAppend (cxxopts)</li> <li>stringLength (cxxopts)</li> <li>splitLine (parser)</li> </ul>"},{"location":"api/namespace_members/#t","title":"t","text":"<ul> <li>transform_point (ILLIXR::data_format::ht)</li> <li>transform_points (ILLIXR::data_format::ht)</li> <li>timewarp_type (ILLIXR)</li> <li>throw_or_mimic (cxxopts)</li> <li>toLocalString (cxxopts)</li> <li>toUTF8String (cxxopts)</li> <li>triangles (parser)</li> </ul>"},{"location":"api/namespace_members/#u","title":"u","text":"<ul> <li>unit_str (ILLIXR::data_format::units)</li> <li>unreal_projection (ILLIXR::math_util)</li> </ul>"},{"location":"api/namespace_members/#v","title":"v","text":"<ul> <li>vk_image_handle (ILLIXR::data_format)</li> <li>v_dot (ILLIXR)</li> <li>void_ptr (ILLIXR)</li> <li>value (cxxopts)</li> <li>version (cxxopts)</li> <li>v0_idx (parser)</li> <li>v1_idx (parser)</li> <li>v2_idx (parser)</li> <li>vertex (parser)</li> </ul>"},{"location":"api/namespace_members/#w","title":"w","text":"<ul> <li>wait_timeline_semaphore (ILLIXR::vulkan)</li> <li>wait_timeline_semaphores (ILLIXR::vulkan)</li> </ul>"},{"location":"api/namespace_members/#_","title":"_","text":"<ul> <li>_plugin_start_header (ILLIXR)</li> <li>_switchboard_callback_header (ILLIXR)</li> <li>_switchboard_topic_stop_header (ILLIXR)</li> <li>_threadloop_iteration_header (ILLIXR)</li> </ul>"},{"location":"api/namespaceboost/","title":"Namespace boost","text":"<p>Namespace List &gt; boost</p>"},{"location":"api/namespaceboost/#namespaces","title":"Namespaces","text":"Type Name namespace serialization <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/serializable_data.hpp</code></p>"},{"location":"api/namespaceboost_1_1serialization/","title":"Namespace boost::serialization","text":"<p>Namespace List &gt; boost &gt; serialization</p>"},{"location":"api/namespaceboost_1_1serialization/#public-functions","title":"Public Functions","text":"Type Name void serialize (Archive &amp; ar, ILLIXR::time_point &amp; tp, const unsigned int version)  void serialize (Archive &amp; ar, ILLIXR::data_format::pose_type &amp; pose, const unsigned int version)  void serialize (Archive &amp; ar, ILLIXR::data_format::fast_pose_type &amp; pose, const unsigned int version)"},{"location":"api/namespaceboost_1_1serialization/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceboost_1_1serialization/#function-serialize","title":"function serialize","text":"<pre><code>template&lt;class Archive&gt;\nvoid boost::serialization::serialize (\n    Archive &amp; ar,\n    ILLIXR::time_point &amp; tp,\n    const unsigned int version\n) \n</code></pre>"},{"location":"api/namespaceboost_1_1serialization/#function-serialize_1","title":"function serialize","text":"<pre><code>template&lt;class Archive&gt;\nvoid boost::serialization::serialize (\n    Archive &amp; ar,\n    ILLIXR::data_format::pose_type &amp; pose,\n    const unsigned int version\n) \n</code></pre>"},{"location":"api/namespaceboost_1_1serialization/#function-serialize_2","title":"function serialize","text":"<pre><code>template&lt;class Archive&gt;\nvoid boost::serialization::serialize (\n    Archive &amp; ar,\n    ILLIXR::data_format::fast_pose_type &amp; pose,\n    const unsigned int version\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/serializable_data.hpp</code></p>"},{"location":"api/namespacecxxopts/","title":"Namespace cxxopts","text":"<p>Namespace List &gt; cxxopts</p>"},{"location":"api/namespacecxxopts/#namespaces","title":"Namespaces","text":"Type Name namespace exceptions namespace values"},{"location":"api/namespacecxxopts/#classes","title":"Classes","text":"Type Name struct HelpGroupDetails struct HelpOptionDetails class KeyValue struct Option class OptionAdder class OptionDetails class OptionParser class OptionValue class Options class ParseResult class Value"},{"location":"api/namespacecxxopts/#public-types","title":"Public Types","text":"Type Name typedef std::unordered_map&lt; std::string, std::size_t &gt; NameHashMap typedef std::unordered_map&lt; std::string, std::shared_ptr&lt; OptionDetails &gt; &gt; OptionMap typedef std::vector&lt; std::string &gt; OptionNames typedef std::unordered_map&lt; std::size_t, OptionValue &gt; ParsedHashMap typedef std::vector&lt; std::string &gt; PositionalList typedef PositionalList::const_iterator PositionalListIterator typedef std::string String"},{"location":"api/namespacecxxopts/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t major uint8_t minor uint8_t patch"},{"location":"api/namespacecxxopts/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr struct cxxopts version   = <code>{CXXOPTS\\_\\_VERSION\\_MAJOR, CXXOPTS\\_\\_VERSION\\_MINOR, CXXOPTS\\_\\_VERSION\\_PATCH}</code> constexpr struct cxxopts version   = <code>{CXXOPTS\\_\\_VERSION\\_MAJOR, CXXOPTS\\_\\_VERSION\\_MINOR, CXXOPTS\\_\\_VERSION\\_PATCH}</code>"},{"location":"api/namespacecxxopts/#public-functions","title":"Public Functions","text":"Type Name bool empty (const std::string &amp; s)  CXXOPTS_NODISCARD const std::string &amp; first_or_empty (const OptionNames &amp; long_names)  String &amp; stringAppend (String &amp; s, const String &amp; a)  String &amp; stringAppend (String &amp; s, std::size_t n, char c)  String &amp; stringAppend (String &amp; s, Iterator begin, Iterator end)  std::size_t stringLength (const String &amp; s)  void throw_or_mimic (const std::string &amp; text)  T toLocalString (T &amp;&amp; t)  std::string toUTF8String (T &amp;&amp; t)  std::shared_ptr&lt; Value &gt; value ()  std::shared_ptr&lt; Value &gt; value (T &amp; t)"},{"location":"api/namespacecxxopts/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacecxxopts/#typedef-namehashmap","title":"typedef NameHashMap","text":"<pre><code>typedef std::unordered_map&lt; std::string, std::size_t &gt; cxxopts::NameHashMap;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-optionmap","title":"typedef OptionMap","text":"<pre><code>typedef std::unordered_map&lt; std::string, std::shared_ptr&lt; OptionDetails &gt; &gt; cxxopts::OptionMap;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-optionnames","title":"typedef OptionNames","text":"<pre><code>typedef std::vector&lt; std::string &gt; cxxopts::OptionNames;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-parsedhashmap","title":"typedef ParsedHashMap","text":"<pre><code>typedef std::unordered_map&lt; std::size_t, OptionValue &gt; cxxopts::ParsedHashMap;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-positionallist","title":"typedef PositionalList","text":"<pre><code>typedef std::vector&lt; std::string &gt; cxxopts::PositionalList;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-positionallistiterator","title":"typedef PositionalListIterator","text":"<pre><code>typedef PositionalList::const_iterator cxxopts::PositionalListIterator;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-string","title":"typedef String","text":"<pre><code>typedef std::string cxxopts::String;\n</code></pre>"},{"location":"api/namespacecxxopts/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacecxxopts/#variable-major","title":"variable major","text":"<pre><code>uint8_t cxxopts::major;\n</code></pre>"},{"location":"api/namespacecxxopts/#variable-minor","title":"variable minor","text":"<pre><code>uint8_t cxxopts::minor;\n</code></pre>"},{"location":"api/namespacecxxopts/#variable-patch","title":"variable patch","text":"<pre><code>uint8_t cxxopts::patch;\n</code></pre>"},{"location":"api/namespacecxxopts/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespacecxxopts/#variable-version","title":"variable version","text":"<pre><code>constexpr struct cxxopts cxxopts::version;\n</code></pre>"},{"location":"api/namespacecxxopts/#variable-version_1","title":"variable version","text":"<pre><code>constexpr struct cxxopts cxxopts::version;\n</code></pre>"},{"location":"api/namespacecxxopts/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts/#function-empty","title":"function empty","text":"<pre><code>inline bool cxxopts::empty (\n    const std::string &amp; s\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-first_or_empty","title":"function first_or_empty","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::first_or_empty (\n    const OptionNames &amp; long_names\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringappend","title":"function stringAppend","text":"<pre><code>inline String &amp; cxxopts::stringAppend (\n    String &amp; s,\n    const String &amp; a\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringappend_1","title":"function stringAppend","text":"<pre><code>inline String &amp; cxxopts::stringAppend (\n    String &amp; s,\n    std::size_t n,\n    char c\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringappend_2","title":"function stringAppend","text":"<pre><code>template&lt;typename Iterator&gt;\nString &amp; cxxopts::stringAppend (\n    String &amp; s,\n    Iterator begin,\n    Iterator end\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringlength","title":"function stringLength","text":"<pre><code>inline std::size_t cxxopts::stringLength (\n    const String &amp; s\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-throw_or_mimic","title":"function throw_or_mimic","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::throw_or_mimic (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-tolocalstring","title":"function toLocalString","text":"<pre><code>template&lt;typename T&gt;\nT cxxopts::toLocalString (\n    T &amp;&amp; t\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-toutf8string","title":"function toUTF8String","text":"<pre><code>template&lt;typename T&gt;\nstd::string cxxopts::toUTF8String (\n    T &amp;&amp; t\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-value","title":"function value","text":"<pre><code>template&lt;typename T&gt;\nstd::shared_ptr&lt; Value &gt; cxxopts::value () \n</code></pre>"},{"location":"api/namespacecxxopts/#function-value_1","title":"function value","text":"<pre><code>template&lt;typename T&gt;\nstd::shared_ptr&lt; Value &gt; cxxopts::value (\n    T &amp; t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1_0d55/","title":"Namespace cxxopts","text":"<p>Namespace List &gt; cxxopts</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1_0d60/","title":"Namespace cxxopts","text":"<p>Namespace List &gt; cxxopts</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1exceptions/","title":"Namespace cxxopts::exceptions","text":"<p>Namespace List &gt; cxxopts &gt; exceptions</p>"},{"location":"api/namespacecxxopts_1_1exceptions/#classes","title":"Classes","text":"Type Name class exception class gratuitous_argument_for_option class incorrect_argument_type class invalid_option_format class invalid_option_syntax class missing_argument class no_such_option class option_already_exists class option_has_no_value class option_requires_argument class parsing class requested_option_not_present class specification <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values/","title":"Namespace cxxopts::values","text":"<p>Namespace List &gt; cxxopts &gt; values</p>"},{"location":"api/namespacecxxopts_1_1values/#namespaces","title":"Namespaces","text":"Type Name namespace detail namespace parser_tool"},{"location":"api/namespacecxxopts_1_1values/#classes","title":"Classes","text":"Type Name class abstract_value &lt;typename T&gt; class standard_value &lt;typename T&gt; class standard_value&lt; bool &gt; &lt;&gt; struct type_is_container &lt;typename T&gt; struct type_is_container&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"api/namespacecxxopts_1_1values/#public-functions","title":"Public Functions","text":"Type Name void checked_negate (R &amp; r, T &amp;&amp; t, const std::string &amp;, std::true_type)  void checked_negate (R &amp;, T &amp;&amp;, const std::string &amp; text, std::false_type)  void integer_parser (const std::string &amp; text, T &amp; value)  void parse_value (const std::string &amp; text, T &amp; value)  void parse_value (const std::string &amp; text, bool &amp; value)  void parse_value (const std::string &amp; text, std::string &amp; value)  void parse_value (const std::string &amp; text, std::vector&lt; T &gt; &amp; value)  void parse_value (const std::string &amp; text, char &amp; c)  void stringstream_parser (const std::string &amp; text, T &amp; value)"},{"location":"api/namespacecxxopts_1_1values/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts_1_1values/#function-checked_negate","title":"function checked_negate","text":"<pre><code>template&lt;typename R, typename T&gt;\nvoid cxxopts::values::checked_negate (\n    R &amp; r,\n    T &amp;&amp; t,\n    const std::string &amp;,\n    std::true_type\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-checked_negate_1","title":"function checked_negate","text":"<pre><code>template&lt;typename R, typename T&gt;\nvoid cxxopts::values::checked_negate (\n    R &amp;,\n    T &amp;&amp;,\n    const std::string &amp; text,\n    std::false_type\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-integer_parser","title":"function integer_parser","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::values::integer_parser (\n    const std::string &amp; text,\n    T &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value","title":"function parse_value","text":"<pre><code>template&lt;typename T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type *&gt;\nvoid cxxopts::values::parse_value (\n    const std::string &amp; text,\n    T &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_1","title":"function parse_value","text":"<pre><code>inline void cxxopts::values::parse_value (\n    const std::string &amp; text,\n    bool &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_2","title":"function parse_value","text":"<pre><code>inline void cxxopts::values::parse_value (\n    const std::string &amp; text,\n    std::string &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_3","title":"function parse_value","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::values::parse_value (\n    const std::string &amp; text,\n    std::vector&lt; T &gt; &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_4","title":"function parse_value","text":"<pre><code>inline void cxxopts::values::parse_value (\n    const std::string &amp; text,\n    char &amp; c\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-stringstream_parser","title":"function stringstream_parser","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::values::stringstream_parser (\n    const std::string &amp; text,\n    T &amp; value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values_1_1detail/","title":"Namespace cxxopts::values::detail","text":"<p>Namespace List &gt; cxxopts &gt; values &gt; detail</p>"},{"location":"api/namespacecxxopts_1_1values_1_1detail/#classes","title":"Classes","text":"Type Name struct SignedCheck &lt;typename T, B&gt; struct SignedCheck&lt; T, false &gt; &lt;typename T&gt; struct SignedCheck&lt; T, true &gt; &lt;typename T&gt;"},{"location":"api/namespacecxxopts_1_1values_1_1detail/#public-functions","title":"Public Functions","text":"Type Name void check_signed_range (bool negative, U value, const std::string &amp; text)"},{"location":"api/namespacecxxopts_1_1values_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts_1_1values_1_1detail/#function-check_signed_range","title":"function check_signed_range","text":"<pre><code>template&lt;typename T, typename U&gt;\nvoid cxxopts::values::detail::check_signed_range (\n    bool negative,\n    U value,\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/","title":"Namespace cxxopts::values::parser_tool","text":"<p>Namespace List &gt; cxxopts &gt; values &gt; parser_tool</p>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#classes","title":"Classes","text":"Type Name struct ArguDesc struct IntegerDesc"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#public-functions","title":"Public Functions","text":"Type Name bool IsFalseText (const std::string &amp; text)  bool IsTrueText (const std::string &amp; text)  ArguDesc ParseArgument (const char * arg, bool &amp; matched)  IntegerDesc SplitInteger (const std::string &amp; text)  OptionNames split_option_names (const std::string &amp; text)"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-isfalsetext","title":"function IsFalseText","text":"<pre><code>inline bool cxxopts::values::parser_tool::IsFalseText (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-istruetext","title":"function IsTrueText","text":"<pre><code>inline bool cxxopts::values::parser_tool::IsTrueText (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-parseargument","title":"function ParseArgument","text":"<pre><code>inline ArguDesc cxxopts::values::parser_tool::ParseArgument (\n    const char * arg,\n    bool &amp; matched\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-splitinteger","title":"function SplitInteger","text":"<pre><code>inline IntegerDesc cxxopts::values::parser_tool::SplitInteger (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-split_option_names","title":"function split_option_names","text":"<pre><code>inline OptionNames cxxopts::values::parser_tool::split_option_names (\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool_1_1_0d55/","title":"Namespace cxxopts::values::parser_tool","text":"<p>Namespace List &gt; parser_tool</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool_1_1_0d60/","title":"Namespace cxxopts::values::parser_tool","text":"<p>Namespace List &gt; parser_tool</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/cxxopts.hpp</code></p>"},{"location":"api/namespaceparser/","title":"Namespace parser","text":"<p>Namespace List &gt; parser</p>"},{"location":"api/namespaceparser/#public-attributes","title":"Public Attributes","text":"Type Name str currentMat   = <code>\"\"</code> list global_normals   = <code>[]</code> list global_verts   = <code>[]</code> list mats   = <code>[]</code> int n0_idx   = <code>int(splitLine[1].split('/')[2])-1</code> int n1_idx   = <code>int(splitLine[2].split('/')[2])-1</code> int n2_idx   = <code>int(splitLine[3].split('/')[2])-1</code> list normal   = <code>global\\_normals[norm\\_idx]</code> int num_normals   = <code>0</code> list objects   = <code>[]</code> str result   = <code>\"\"</code> splitLine   = <code>line.rstrip().replace(\"  \", \" \").split(' ')</code> list triangles   = <code>[]</code> int v0_idx   = <code>int(splitLine[1].split('/')[0])-1</code> int v1_idx   = <code>int(splitLine[2].split('/')[0])-1</code> int v2_idx   = <code>int(splitLine[3].split('/')[0])-1</code> list vertex   = <code>global\\_verts[vert\\_idx]</code>"},{"location":"api/namespaceparser/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceparser/#variable-currentmat","title":"variable currentMat","text":"<pre><code>str parser.currentMat;\n</code></pre>"},{"location":"api/namespaceparser/#variable-global_normals","title":"variable global_normals","text":"<pre><code>list parser.global_normals;\n</code></pre>"},{"location":"api/namespaceparser/#variable-global_verts","title":"variable global_verts","text":"<pre><code>list parser.global_verts;\n</code></pre>"},{"location":"api/namespaceparser/#variable-mats","title":"variable mats","text":"<pre><code>list parser.mats;\n</code></pre>"},{"location":"api/namespaceparser/#variable-n0_idx","title":"variable n0_idx","text":"<pre><code>int parser.n0_idx;\n</code></pre>"},{"location":"api/namespaceparser/#variable-n1_idx","title":"variable n1_idx","text":"<pre><code>int parser.n1_idx;\n</code></pre>"},{"location":"api/namespaceparser/#variable-n2_idx","title":"variable n2_idx","text":"<pre><code>int parser.n2_idx;\n</code></pre>"},{"location":"api/namespaceparser/#variable-normal","title":"variable normal","text":"<pre><code>list parser.normal;\n</code></pre>"},{"location":"api/namespaceparser/#variable-num_normals","title":"variable num_normals","text":"<pre><code>int parser.num_normals;\n</code></pre>"},{"location":"api/namespaceparser/#variable-objects","title":"variable objects","text":"<pre><code>list parser.objects;\n</code></pre>"},{"location":"api/namespaceparser/#variable-result","title":"variable result","text":"<pre><code>str parser.result;\n</code></pre>"},{"location":"api/namespaceparser/#variable-splitline","title":"variable splitLine","text":"<pre><code>parser.splitLine;\n</code></pre>"},{"location":"api/namespaceparser/#variable-triangles","title":"variable triangles","text":"<pre><code>list parser.triangles;\n</code></pre>"},{"location":"api/namespaceparser/#variable-v0_idx","title":"variable v0_idx","text":"<pre><code>int parser.v0_idx;\n</code></pre>"},{"location":"api/namespaceparser/#variable-v1_idx","title":"variable v1_idx","text":"<pre><code>int parser.v1_idx;\n</code></pre>"},{"location":"api/namespaceparser/#variable-v2_idx","title":"variable v2_idx","text":"<pre><code>int parser.v2_idx;\n</code></pre>"},{"location":"api/namespaceparser/#variable-vertex","title":"variable vertex","text":"<pre><code>list parser.vertex;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/parser.py</code></p>"},{"location":"api/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace Eigen </li> <li>namespace ILLIXR RAC_ERRNO_MSG. <ul> <li>namespace data_format <ul> <li>namespace camera </li> <li>namespace coordinates </li> <li>namespace ht </li> <li>namespace image </li> <li>namespace units </li> </ul> </li> <li>namespace display </li> <li>namespace math_util </li> <li>namespace network </li> <li>namespace vulkan <ul> <li>namespace ffmpeg_utils </li> </ul> </li> <li>namespace zed_capture </li> </ul> </li> <li>namespace YAML </li> <li>namespace boost <ul> <li>namespace serialization </li> </ul> </li> <li>namespace cxxopts <ul> <li>namespace exceptions </li> <li>namespace values <ul> <li>namespace detail </li> <li>namespace parser_tool </li> </ul> </li> </ul> </li> <li>namespace cxxopts </li> <li>namespace cxxopts </li> <li>namespace parser_tool </li> <li>namespace parser_tool </li> <li>namespace parser </li> <li>namespace sl </li> <li>namespace std </li> <li>namespace vulkan </li> </ul>"},{"location":"api/namespacesl/","title":"Namespace sl","text":"<p>Namespace List &gt; sl</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p>"},{"location":"api/namespacestd/#classes","title":"Classes","text":"Type Name struct hash&lt; vertex &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.cpp</code></p>"},{"location":"api/namespacevulkan/","title":"Namespace vulkan","text":"<p>Namespace List &gt; vulkan</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/net__config_8hpp/","title":"File net_config.hpp","text":"<p>FileList &gt; illixr &gt; network &gt; net_config.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"api/net__config_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace network <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/net_config.hpp</code></p>"},{"location":"api/net__config_8hpp_source/","title":"File net_config.hpp","text":"<p>File List &gt; illixr &gt; network &gt; net_config.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iostream&gt;\n\nnamespace ILLIXR::network {\n\n// local\nconst std::string SERVER_IP     = \"127.0.0.1\";\nconst int         SERVER_PORT_1 = 4042;\nconst int         SERVER_PORT_2 = 4003;\n\n// local\nconst std::string CLIENT_IP     = \"127.0.0.1\";\nconst int         CLIENT_PORT_1 = 5002;\nconst int         CLIENT_PORT_2 = 5003;\n\n} // namespace ILLIXR::network\n</code></pre>"},{"location":"api/network__backend_8hpp/","title":"File network_backend.hpp","text":"<p>FileList &gt; illixr &gt; network &gt; network_backend.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"topic_config.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/network__backend_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace network"},{"location":"api/network__backend_8hpp/#classes","title":"Classes","text":"Type Name class network_backend <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/network_backend.hpp</code></p>"},{"location":"api/network__backend_8hpp_source/","title":"File network_backend.hpp","text":"<p>File List &gt; illixr &gt; network &gt; network_backend.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/phonebook.hpp\"\n#include \"topic_config.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nnamespace ILLIXR::network {\nclass network_backend : public phonebook::service {\npublic:\n    virtual void topic_create(std::string topic_name, topic_config&amp; config) = 0;\n\n    virtual bool is_topic_networked(std::string topic_name) = 0;\n\n    virtual void topic_send(std::string topic_name, std::string&amp;&amp; message) = 0;\n};\n} // namespace ILLIXR::network\n</code></pre>"},{"location":"api/offload__rendering__client_8cpp/","title":"File offload_rendering_client.cpp","text":"<p>FileList &gt; offload_rendering_client &gt; offload_rendering_client.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"offload_rendering_client.hpp\"</code></li> </ul>"},{"location":"api/offload__rendering__client_8cpp/#macros","title":"Macros","text":"Type Name define OFFLOAD_RENDERING_FFMPEG_DECODER_NAME <code>\"hevc\"</code>"},{"location":"api/offload__rendering__client_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/offload__rendering__client_8cpp/#define-offload_rendering_ffmpeg_decoder_name","title":"define OFFLOAD_RENDERING_FFMPEG_DECODER_NAME","text":"<pre><code>#define OFFLOAD_RENDERING_FFMPEG_DECODER_NAME `\"hevc\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/offload_rendering_client.cpp</code></p>"},{"location":"api/offload__rendering__client_8cpp_source/","title":"File offload_rendering_client.cpp","text":"<p>File List &gt; offload_rendering_client &gt; offload_rendering_client.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"offload_rendering_client.hpp\"\n\n#define OFFLOAD_RENDERING_FFMPEG_DECODER_NAME \"hevc\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\nusing namespace ILLIXR::vulkan::ffmpeg_utils;\n\noffload_rendering_client::offload_rendering_client(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n    , log_{spdlogger(nullptr)}\n    , display_provider_{pb-&gt;lookup_impl&lt;vulkan::display_provider&gt;()}\n    , frames_reader_{switchboard_-&gt;get_buffered_reader&lt;compressed_frame&gt;(\"compressed_frames\")}\n    , pose_writer_{switchboard_-&gt;get_network_writer&lt;fast_pose_type&gt;(\"render_pose\", {})}\n    , pose_prediction_{pb-&gt;lookup_impl&lt;pose_prediction&gt;()}\n    , clock_{pb-&gt;lookup_impl&lt;relative_clock&gt;()} {\n    display_provider_ffmpeg = display_provider_;\n\n    // Configure depth frame handling\n    use_depth_ = switchboard_-&gt;get_env_bool(\"ILLIXR_USE_DEPTH_IMAGES\");\n    log_-&gt;debug(use_depth_ ? \"Encoding depth images for the client\" : \"Not encoding depth images for the client\");\n}\n\nvoid offload_rendering_client::start() {\n    ffmpeg_init_device();\n    ffmpeg_init_cuda_device();\n    threadloop::start();\n}\n\nvoid offload_rendering_client::setup(VkRenderPass render_pass, uint32_t subpass,\n                                     std::shared_ptr&lt;vulkan::buffer_pool&lt;fast_pose_type&gt;&gt; buffer_pool) {\n    (void) render_pass;\n    (void) subpass;\n    this-&gt;buffer_pool_ = buffer_pool;\n    command_pool =\n        vulkan::create_command_pool(display_provider_-&gt;vk_device_, display_provider_-&gt;queues_[vulkan::queue::GRAPHICS].family);\n\n    // Initialize FFmpeg and frame resources\n    ffmpeg_init_frame_ctx();\n    ffmpeg_init_cuda_frame_ctx();\n    ffmpeg_init_buffer_pool();\n    ffmpeg_init_decoder();\n    ready_ = true;\n\n    // Initialize image layouts for color frames\n    for (auto&amp; frame : avvk_color_frames_) {\n        for (auto&amp; eye : frame) {\n            auto cmd_buf = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool);\n            transition_layout(cmd_buf, eye.frame, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n            vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool,\n                                         display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], cmd_buf);\n        }\n    }\n\n    // Initialize image layouts for depth frames if enabled\n    if (use_depth_) {\n        for (auto&amp; frame : avvk_depth_frames_) {\n            for (auto&amp; eye : frame) {\n                auto cmd_buf = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool);\n                transition_layout(cmd_buf, eye.frame, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n                vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool,\n                                             display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], cmd_buf);\n            }\n        }\n    }\n\n    // Create command buffers for layout transitions\n    for (size_t i = 0; i &lt; avvk_color_frames_.size(); i++) {\n        for (auto eye = 0; eye &lt; 2; eye++) {\n            // Create start transition command buffers\n            layout_transition_start_cmd_bufs_[i][eye] =\n                vulkan::create_command_buffer(display_provider_-&gt;vk_device_, command_pool);\n            VkCommandBufferBeginInfo begin_info{};\n            begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;\n            begin_info.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;\n            vkBeginCommandBuffer(layout_transition_start_cmd_bufs_[i][eye], &amp;begin_info);\n            transition_layout(layout_transition_start_cmd_bufs_[i][eye], avvk_color_frames_[i][eye].frame,\n                              VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);\n            if (use_depth_) {\n                transition_layout(layout_transition_start_cmd_bufs_[i][eye], avvk_depth_frames_[i][eye].frame,\n                                  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);\n            }\n            vkEndCommandBuffer(layout_transition_start_cmd_bufs_[i][eye]);\n\n            // Create end transition command buffers\n            layout_transition_end_cmd_bufs_[i][eye] =\n                vulkan::create_command_buffer(display_provider_-&gt;vk_device_, command_pool);\n            vkBeginCommandBuffer(layout_transition_end_cmd_bufs_[i][eye], &amp;begin_info);\n            transition_layout(layout_transition_end_cmd_bufs_[i][eye], avvk_color_frames_[i][eye].frame,\n                              VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n            if (use_depth_) {\n                transition_layout(layout_transition_end_cmd_bufs_[i][eye], avvk_depth_frames_[i][eye].frame,\n                                  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n            }\n            vkEndCommandBuffer(layout_transition_end_cmd_bufs_[i][eye]);\n        }\n    }\n\n    // Create fence for synchronization\n    VkFenceCreateInfo fence_info = {\n        .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,\n    };\n    vkCreateFence(display_provider_-&gt;vk_device_, &amp;fence_info, nullptr, &amp;fence_);\n}\n\nvoid offload_rendering_client::destroy() {\n    // Free color frame resources\n    for (auto&amp; frame : avvk_color_frames_) {\n        for (auto&amp; eye : frame) {\n            av_frame_free(&amp;eye.frame);\n        }\n    }\n\n    // Free depth frame resources if enabled\n    for (auto&amp; frame : avvk_depth_frames_) {\n        for (auto&amp; eye : frame) {\n            av_frame_free(&amp;eye.frame);\n        }\n    }\n\n    // Release FFmpeg contexts\n    av_buffer_unref(&amp;frame_ctx_);\n    av_buffer_unref(&amp;device_ctx_);\n}\n\n[[maybe_unused]] void offload_rendering_client::copy_image_to_cpu_and_save_file(AVFrame* frame) {\n    auto cpu_av_frame    = av_frame_alloc();\n    cpu_av_frame-&gt;format = AV_PIX_FMT_RGBA;\n    auto ret             = av_hwframe_transfer_data(cpu_av_frame, frame, 0);\n    AV_ASSERT_SUCCESS(ret);\n\n    // save cpu_av_frame as png\n    auto png_codec           = avcodec_find_encoder(AV_CODEC_ID_PNG);\n    auto png_codec_ctx       = avcodec_alloc_context3(png_codec);\n    png_codec_ctx-&gt;pix_fmt   = AV_PIX_FMT_RGBA;\n    png_codec_ctx-&gt;width     = cpu_av_frame-&gt;width;\n    png_codec_ctx-&gt;height    = cpu_av_frame-&gt;height;\n    png_codec_ctx-&gt;time_base = {1, 60};\n    png_codec_ctx-&gt;framerate = {60, 1};\n\n    ret = avcodec_open2(png_codec_ctx, png_codec, nullptr);\n    AV_ASSERT_SUCCESS(ret);\n    AVPacket* png_packet = av_packet_alloc();\n    ret                  = avcodec_send_frame(png_codec_ctx, cpu_av_frame);\n    AV_ASSERT_SUCCESS(ret);\n    ret = avcodec_receive_packet(png_codec_ctx, png_packet);\n    AV_ASSERT_SUCCESS(ret);\n\n    std::string filename = \"frame_\" + std::to_string(frame_count_) + \".png\";\n    FILE*       f        = fopen(filename.c_str(), \"wb\");\n    fwrite(png_packet-&gt;data, 1, png_packet-&gt;size, f);\n    fclose(f);\n\n    av_packet_free(&amp;png_packet);\n    av_frame_free(&amp;cpu_av_frame);\n    avcodec_free_context(&amp;png_codec_ctx);\n}\n\n[[maybe_unused]] void offload_rendering_client::save_nv12_img_to_png(AVFrame* cuda_frame) const {\n    auto cpu_av_frame    = av_frame_alloc();\n    cpu_av_frame-&gt;format = AV_PIX_FMT_NV12;\n    auto ret             = av_hwframe_transfer_data(cpu_av_frame, cuda_frame, 0);\n    AV_ASSERT_SUCCESS(ret);\n\n    AVFrame* frameGRB = av_frame_alloc();\n    frameGRB-&gt;width   = cpu_av_frame-&gt;width;\n    frameGRB-&gt;height  = cpu_av_frame-&gt;height;\n    frameGRB-&gt;format  = AV_PIX_FMT_RGBA;\n    av_frame_get_buffer(frameGRB, 0);\n\n    SwsContext* sws_context = sws_getContext(cpu_av_frame-&gt;width, cpu_av_frame-&gt;height, AV_PIX_FMT_NV12, frameGRB-&gt;width,\n                                             frameGRB-&gt;height, AV_PIX_FMT_RGBA, SWS_BICUBIC, NULL, NULL, NULL);\n    if (sws_context != NULL) {\n        sws_scale(sws_context, cpu_av_frame-&gt;data, cpu_av_frame-&gt;linesize, 0, cpu_av_frame-&gt;height, frameGRB-&gt;data,\n                  frameGRB-&gt;linesize);\n    }\n\n    // save cpu_av_frame as png\n    auto png_codec           = avcodec_find_encoder(AV_CODEC_ID_PNG);\n    auto png_codec_ctx       = avcodec_alloc_context3(png_codec);\n    png_codec_ctx-&gt;pix_fmt   = AV_PIX_FMT_RGBA;\n    png_codec_ctx-&gt;width     = cpu_av_frame-&gt;width;\n    png_codec_ctx-&gt;height    = cpu_av_frame-&gt;height;\n    png_codec_ctx-&gt;time_base = {1, 60};\n    png_codec_ctx-&gt;framerate = {60, 1};\n\n    ret = avcodec_open2(png_codec_ctx, png_codec, nullptr);\n    AV_ASSERT_SUCCESS(ret);\n    AVPacket* png_packet = av_packet_alloc();\n    ret                  = avcodec_send_frame(png_codec_ctx, frameGRB);\n    AV_ASSERT_SUCCESS(ret);\n    ret = avcodec_receive_packet(png_codec_ctx, png_packet);\n    AV_ASSERT_SUCCESS(ret);\n\n    std::string filename = \"frame_\" + std::to_string(frame_count_) + \".png\";\n    FILE*       f        = fopen(filename.c_str(), \"wb\");\n    fwrite(png_packet-&gt;data, 1, png_packet-&gt;size, f);\n    fclose(f);\n\n    av_packet_free(&amp;png_packet);\n    av_frame_free(&amp;cpu_av_frame);\n    avcodec_free_context(&amp;png_codec_ctx);\n}\n\n// Vulkan layout transition\n// supports: shader read &lt;-&gt; transfer dst\nvoid offload_rendering_client::transition_layout(VkCommandBuffer cmd_buf, AVFrame* frame, VkImageLayout old_layout,\n                                                 VkImageLayout new_layout) {\n    auto vk_frame = reinterpret_cast&lt;AVVkFrame*&gt;(frame-&gt;data[0]);\n    auto image    = vk_frame-&gt;img[0];\n\n    VkImageMemoryBarrier barrier{};\n    barrier.sType               = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;\n    barrier.oldLayout           = old_layout;\n    barrier.newLayout           = new_layout;\n    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.image               = image;\n    barrier.subresourceRange    = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};\n\n    VkPipelineStageFlags src_stage;\n    VkPipelineStageFlags dst_stage;\n\n    if (old_layout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL &amp;&amp; new_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {\n        barrier.srcAccessMask = VK_ACCESS_SHADER_READ_BIT;\n        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;\n        src_stage             = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;\n        dst_stage             = VK_PIPELINE_STAGE_TRANSFER_BIT;\n    } else if (old_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; new_layout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {\n        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;\n        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;\n        src_stage             = VK_PIPELINE_STAGE_TRANSFER_BIT;\n        dst_stage             = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;\n    } else if (old_layout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; new_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {\n        barrier.srcAccessMask = 0;\n        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;\n        src_stage             = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;\n        dst_stage             = VK_PIPELINE_STAGE_TRANSFER_BIT;\n    } else if (old_layout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; new_layout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {\n        barrier.srcAccessMask = 0;\n        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;\n        src_stage             = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;\n        dst_stage             = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;\n    } else {\n        throw std::invalid_argument(\"unsupported layout transition\");\n    }\n\n    vkCmdPipelineBarrier(cmd_buf, src_stage, dst_stage, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier);\n}\n\nvoid offload_rendering_client::_p_one_iteration() {\n    if (!ready_) {\n        return;\n    }\n\n    // Send latest pose to server\n    push_pose();\n\n    // Receive and process network data\n    if (!network_receive()) {\n        return;\n    }\n\n    // Track frame timing\n    auto timestamp = std::chrono::high_resolution_clock::now();\n    auto diff      = timestamp - decoded_frame_pose_.predict_target_time.time_since_epoch();\n\n    // Decode frames\n    auto decode_start = std::chrono::high_resolution_clock::now();\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        // Decode color frames\n        auto ret = avcodec_send_packet(codec_color_ctx_, decode_src_color_packets_[eye]);\n        if (ret == AVERROR(EAGAIN)) {\n            throw std::runtime_error{\"FFmpeg encoder returned EAGAIN. Internal buffer full? Try using a higher-end GPU.\"};\n        }\n        AV_ASSERT_SUCCESS(ret);\n\n        // Decode depth frames if enabled\n        if (use_depth_) {\n            ret = avcodec_send_packet(codec_depth_ctx_, decode_src_depth_packets_[eye]);\n            if (ret == AVERROR(EAGAIN)) {\n                throw std::runtime_error{\"FFmpeg encoder returned EAGAIN. Internal buffer full? Try using a higher-end GPU.\"};\n            }\n            AV_ASSERT_SUCCESS(ret);\n        }\n    }\n\n    // Receive decoded frames\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        auto ret = avcodec_receive_frame(codec_color_ctx_, decode_out_color_frames_[eye]);\n        assert(decode_out_color_frames_[eye]-&gt;format == AV_PIX_FMT_CUDA);\n        AV_ASSERT_SUCCESS(ret);\n\n        if (use_depth_) {\n            ret = avcodec_receive_frame(codec_depth_ctx_, decode_out_depth_frames_[eye]);\n            assert(decode_out_depth_frames_[eye]-&gt;format == AV_PIX_FMT_CUDA);\n            AV_ASSERT_SUCCESS(ret);\n        }\n    }\n    auto decode_end = std::chrono::high_resolution_clock::now();\n\n    // Perform color space conversion\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        // Convert NV12 to YUV420\n        NppiSize roi = {static_cast&lt;int&gt;(decode_out_color_frames_[eye]-&gt;width),\n                        static_cast&lt;int&gt;(decode_out_color_frames_[eye]-&gt;height)};\n        Npp8u*   pSrc[2];\n        pSrc[0] = reinterpret_cast&lt;Npp8u*&gt;(decode_out_color_frames_[eye]-&gt;data[0]);\n        pSrc[1] = reinterpret_cast&lt;Npp8u*&gt;(decode_out_color_frames_[eye]-&gt;data[1]);\n        Npp8u* pDst[3];\n        pDst[0] = yuv420_y_plane_;\n        pDst[1] = yuv420_u_plane_;\n        pDst[2] = yuv420_v_plane_;\n        int dst_linesizes[3];\n        dst_linesizes[0] = y_step_;\n        dst_linesizes[1] = u_step_;\n        dst_linesizes[2] = v_step_;\n\n        auto ret = nppiNV12ToYUV420_8u_P2P3R(pSrc, decode_out_color_frames_[eye]-&gt;linesize[0], pDst, dst_linesizes, roi);\n        assert(ret == NPP_SUCCESS);\n\n        // Convert YUV420 to BGRA\n        auto dst = reinterpret_cast&lt;Npp8u*&gt;(decode_converted_color_frames_[eye]-&gt;data[0]);\n        ret      = nppiYUV420ToBGR_8u_P3C4R(pDst, dst_linesizes, dst, decode_converted_color_frames_[eye]-&gt;linesize[0], roi);\n        assert(ret == NPP_SUCCESS);\n\n        // Process depth frames if enabled\n        if (use_depth_) {\n            // NppiSize roi_depth = {static_cast&lt;int&gt;(decode_out_depth_frames_[eye]-&gt;width),\n            //                       static_cast&lt;int&gt;(decode_out_depth_frames_[eye]-&gt;height)};\n            Npp8u* pSrc_depth[2];\n            pSrc_depth[0] = reinterpret_cast&lt;Npp8u*&gt;(decode_out_depth_frames_[eye]-&gt;data[0]);\n            pSrc_depth[1] = reinterpret_cast&lt;Npp8u*&gt;(decode_out_depth_frames_[eye]-&gt;data[1]);\n            ret = nppiNV12ToYUV420_8u_P2P3R(pSrc_depth, decode_out_depth_frames_[eye]-&gt;linesize[0], pDst, dst_linesizes, roi);\n            assert(ret == NPP_SUCCESS);\n            auto dst_depth = reinterpret_cast&lt;Npp8u*&gt;(decode_converted_depth_frames_[eye]-&gt;data[0]);\n            ret =\n                nppiYUV420ToBGR_8u_P3C4R(pDst, dst_linesizes, dst_depth, decode_converted_depth_frames_[eye]-&gt;linesize[0], roi);\n            assert(ret == NPP_SUCCESS);\n        }\n        cudaDeviceSynchronize();\n    }\n    auto conversion_end = std::chrono::high_resolution_clock::now();\n\n    // Update display buffers\n    auto ind            = buffer_pool_-&gt;src_acquire_image();\n    auto transfer_start = std::chrono::high_resolution_clock::now();\n\n    auto* frames = reinterpret_cast&lt;AVHWFramesContext*&gt;(frame_ctx_-&gt;data);\n    auto* vk     = static_cast&lt;AVVulkanFramesContext*&gt;(frames-&gt;hwctx);\n\n    // Transfer frames to display buffers\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        vk-&gt;lock_frame(frames, avvk_color_frames_[ind][eye].vk_frame);\n        if (use_depth_) {\n            vk-&gt;lock_frame(frames, avvk_depth_frames_[ind][eye].vk_frame);\n        }\n\n        vkResetFences(display_provider_-&gt;vk_device_, 1, &amp;fence_);\n\n        // Set up synchronization\n        std::vector&lt;VkSemaphore&gt;          timelines   = {avvk_color_frames_[ind][eye].vk_frame-&gt;sem[0]};\n        std::vector&lt;VkPipelineStageFlags&gt; wait_stages = {VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT};\n        if (use_depth_) {\n            timelines.push_back(avvk_depth_frames_[ind][eye].vk_frame-&gt;sem[0]);\n            wait_stages.push_back(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT);\n        }\n\n        std::vector&lt;uint64_t&gt; start_wait_values   = {avvk_color_frames_[ind][eye].vk_frame-&gt;sem_value[0]};\n        std::vector&lt;uint64_t&gt; start_signal_values = {++avvk_color_frames_[ind][eye].vk_frame-&gt;sem_value[0]};\n        if (use_depth_) {\n            start_wait_values.push_back(avvk_depth_frames_[ind][eye].vk_frame-&gt;sem_value[0]);\n            start_signal_values.push_back(++avvk_depth_frames_[ind][eye].vk_frame-&gt;sem_value[0]);\n        }\n\n        // Submit layout transition commands\n        VkTimelineSemaphoreSubmitInfo transition_start_timeline = {\n            .sType                     = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,\n            .pNext                     = nullptr,\n            .waitSemaphoreValueCount   = static_cast&lt;uint16_t&gt;(start_wait_values.size()),\n            .pWaitSemaphoreValues      = start_wait_values.data(),\n            .signalSemaphoreValueCount = static_cast&lt;uint16_t&gt;(start_signal_values.size()),\n            .pSignalSemaphoreValues    = start_signal_values.data(),\n        };\n\n        VkSubmitInfo transition_start_submit = {\n            .sType                = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n            .pNext                = &amp;transition_start_timeline,\n            .waitSemaphoreCount   = static_cast&lt;uint16_t&gt;(timelines.size()),\n            .pWaitSemaphores      = timelines.data(),\n            .pWaitDstStageMask    = wait_stages.data(),\n            .commandBufferCount   = 1,\n            .pCommandBuffers      = &amp;layout_transition_start_cmd_bufs_[ind][eye],\n            .signalSemaphoreCount = static_cast&lt;uint16_t&gt;(timelines.size()),\n            .pSignalSemaphores    = timelines.data(),\n        };\n        vulkan::locked_queue_submit(display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], 1, &amp;transition_start_submit, nullptr);\n\n        // Transfer frame data\n        auto ret = av_hwframe_transfer_data(avvk_color_frames_[ind][eye].frame, decode_converted_color_frames_[eye], 0);\n        AV_ASSERT_SUCCESS(ret);\n\n        if (use_depth_) {\n            ret = av_hwframe_transfer_data(avvk_depth_frames_[ind][eye].frame, decode_converted_depth_frames_[eye], 0);\n            AV_ASSERT_SUCCESS(ret);\n        }\n\n        // Submit end transition commands\n        std::vector&lt;uint64_t&gt; end_wait_values   = {avvk_color_frames_[ind][eye].vk_frame-&gt;sem_value[0]};\n        std::vector&lt;uint64_t&gt; end_signal_values = {++avvk_color_frames_[ind][eye].vk_frame-&gt;sem_value[0]};\n        if (use_depth_) {\n            end_wait_values.push_back(avvk_depth_frames_[ind][eye].vk_frame-&gt;sem_value[0]);\n            end_signal_values.push_back(++avvk_depth_frames_[ind][eye].vk_frame-&gt;sem_value[0]);\n        }\n\n        VkTimelineSemaphoreSubmitInfo transition_end_timeline = {\n            .sType                     = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,\n            .pNext                     = nullptr,\n            .waitSemaphoreValueCount   = static_cast&lt;uint16_t&gt;(end_wait_values.size()),\n            .pWaitSemaphoreValues      = end_wait_values.data(),\n            .signalSemaphoreValueCount = static_cast&lt;uint16_t&gt;(end_signal_values.size()),\n            .pSignalSemaphoreValues    = end_signal_values.data(),\n        };\n\n        VkSubmitInfo transition_end_submit = {\n            .sType                = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n            .pNext                = &amp;transition_end_timeline,\n            .waitSemaphoreCount   = static_cast&lt;uint16_t&gt;(timelines.size()),\n            .pWaitSemaphores      = timelines.data(),\n            .pWaitDstStageMask    = wait_stages.data(),\n            .commandBufferCount   = 1,\n            .pCommandBuffers      = &amp;layout_transition_end_cmd_bufs_[ind][eye],\n            .signalSemaphoreCount = static_cast&lt;uint16_t&gt;(timelines.size()),\n            .pSignalSemaphores    = timelines.data(),\n        };\n        vulkan::locked_queue_submit(display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], 1, &amp;transition_end_submit, fence_);\n        vkWaitForFences(display_provider_-&gt;vk_device_, 1, &amp;fence_, VK_TRUE, UINT64_MAX);\n\n        // Update frame counters and release resources\n        if (use_depth_) {\n            decode_out_color_frames_[eye]-&gt;pts = static_cast&lt;int64_t&gt;(frame_count_++);\n            decode_out_depth_frames_[eye]-&gt;pts = static_cast&lt;int64_t&gt;(frame_count_++);\n\n            vulkan::wait_timeline_semaphores(\n                display_provider_-&gt;vk_device_,\n                {{avvk_color_frames_[ind][eye].vk_frame-&gt;sem[0], avvk_color_frames_[ind][eye].vk_frame-&gt;sem_value[0]},\n                 {avvk_depth_frames_[ind][eye].vk_frame-&gt;sem[0], avvk_depth_frames_[ind][eye].vk_frame-&gt;sem_value[0]}});\n\n            vk-&gt;unlock_frame(frames, avvk_color_frames_[ind][eye].vk_frame);\n            vk-&gt;unlock_frame(frames, avvk_depth_frames_[ind][eye].vk_frame);\n        } else {\n            decode_out_color_frames_[eye]-&gt;pts = static_cast&lt;int64_t&gt;(frame_count_++);\n\n            vulkan::wait_timeline_semaphores(\n                display_provider_-&gt;vk_device_,\n                {{avvk_color_frames_[ind][eye].vk_frame-&gt;sem[0], avvk_color_frames_[ind][eye].vk_frame-&gt;sem_value[0]}});\n\n            vk-&gt;unlock_frame(frames, avvk_color_frames_[ind][eye].vk_frame);\n        }\n    }\n\n    auto transfer_end = std::chrono::high_resolution_clock::now();\n    buffer_pool_-&gt;src_release_image(ind, std::move(decoded_frame_pose_));\n\n    // Update performance metrics\n    metrics_[\"decode\"] += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(decode_end - decode_start).count();\n    metrics_[\"conversion\"] += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(conversion_end - decode_end).count();\n    metrics_[\"transfer\"] += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(transfer_end - transfer_start).count();\n\n    // Log performance metrics every second\n    if (std::chrono::duration_cast&lt;std::chrono::seconds&gt;(std::chrono::high_resolution_clock::now() - fps_start_time_).count() &gt;=\n        1) {\n        log_-&gt;info(\"Decoder FPS: {}\", fps_counter_);\n        fps_start_time_ = std::chrono::high_resolution_clock::now();\n\n        for (auto&amp; metric : metrics_) {\n            auto fps = std::max(fps_counter_, (uint16_t) 0);\n            log_-&gt;info(\"{}: {}\", metric.first, metric.second / (double) (fps));\n            metric.second = 0;\n        }\n        fps_counter_ = 0;\n    } else {\n        fps_counter_++;\n    }\n}\n\nvoid offload_rendering_client::push_pose() {\n    auto current_pose = pose_prediction_-&gt;get_fast_pose();\n\n    auto now = time_point{std::chrono::duration&lt;long, std::nano&gt;{std::chrono::high_resolution_clock::now().time_since_epoch()}};\n    current_pose.predict_target_time   = now;\n    current_pose.predict_computed_time = now;\n    std::cout &lt;&lt; \"Pushing new pose\" &lt;&lt; std::endl;\n    pose_writer_.put(std::make_shared&lt;fast_pose_type&gt;(current_pose));\n}\n\nbool offload_rendering_client::network_receive() {\n    // Free previous packets if they exist\n    if (decode_src_color_packets_[0] != nullptr) {\n        av_packet_free_side_data(decode_src_color_packets_[0]);\n        av_packet_free_side_data(decode_src_color_packets_[1]);\n        av_packet_free(&amp;decode_src_color_packets_[0]);\n        av_packet_free(&amp;decode_src_color_packets_[1]);\n        if (use_depth_) {\n            av_packet_free_side_data(decode_src_depth_packets_[0]);\n            av_packet_free_side_data(decode_src_depth_packets_[1]);\n            av_packet_free(&amp;decode_src_depth_packets_[0]);\n            av_packet_free(&amp;decode_src_depth_packets_[1]);\n        }\n    }\n\n    // Receive new frame data\n    auto frame = frames_reader_.dequeue();\n    if (frame == nullptr) {\n        return false;\n    }\n\n    // Store frame data\n    decode_src_color_packets_[0] = frame-&gt;left_color;\n    decode_src_color_packets_[1] = frame-&gt;right_color;\n    if (use_depth_) {\n        decode_src_depth_packets_[0] = frame-&gt;left_depth;\n        decode_src_depth_packets_[1] = frame-&gt;right_depth;\n    }\n\n    // Track frame timing\n    uint64_t timestamp =\n        std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch())\n            .count();\n    auto diff_ns = timestamp - frame-&gt;sent_time;\n    log_-&gt;info(\"Network latency (ms): {}\", static_cast&lt;double&gt;(diff_ns) / 1000000.0);\n\n    decoded_frame_pose_ = frame-&gt;pose;\n    return true;\n}\n\n[[maybe_unused]] void offload_rendering_client::submit_command_buffer(VkCommandBuffer vk_command_buffer) {\n    VkSubmitInfo submitInfo{\n        VK_STRUCTURE_TYPE_SUBMIT_INFO, // sType\n        nullptr,                       // pNext\n        0,                             // waitSemaphoreCount\n        nullptr,                       // pWaitSemaphores\n        nullptr,                       // pWaitDstStageMask\n        1,                             // commandBufferCount\n        &amp;vk_command_buffer,            // pCommandBuffers\n        0,                             // signalSemaphoreCount\n        nullptr                        // pSignalSemaphores\n    };\n    vulkan::locked_queue_submit(display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], 1, &amp;submitInfo, nullptr);\n}\n\nvoid offload_rendering_client::ffmpeg_init_device() {\n    this-&gt;device_ctx_     = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_VULKAN);\n    auto hwdev_ctx        = reinterpret_cast&lt;AVHWDeviceContext*&gt;(device_ctx_-&gt;data);\n    auto vulkan_hwdev_ctx = reinterpret_cast&lt;AVVulkanDeviceContext*&gt;(hwdev_ctx-&gt;hwctx);\n\n    // Configure Vulkan device context\n    vulkan_hwdev_ctx-&gt;inst            = display_provider_-&gt;vk_instance_;\n    vulkan_hwdev_ctx-&gt;phys_dev        = display_provider_-&gt;vk_physical_device_;\n    vulkan_hwdev_ctx-&gt;act_dev         = display_provider_-&gt;vk_device_;\n    vulkan_hwdev_ctx-&gt;device_features = display_provider_-&gt;features_;\n\n    // Set up queue families\n    for (auto&amp; queue : display_provider_-&gt;queues_) {\n        switch (queue.first) {\n        case vulkan::queue::GRAPHICS:\n            vulkan_hwdev_ctx-&gt;queue_family_index    = static_cast&lt;int&gt;(queue.second.family);\n            vulkan_hwdev_ctx-&gt;nb_graphics_queues    = 1;\n            vulkan_hwdev_ctx-&gt;queue_family_tx_index = static_cast&lt;int&gt;(queue.second.family);\n            vulkan_hwdev_ctx-&gt;nb_tx_queues          = 1;\n            break;\n        case vulkan::queue::COMPUTE:\n            vulkan_hwdev_ctx-&gt;queue_family_comp_index = static_cast&lt;int&gt;(queue.second.family);\n            vulkan_hwdev_ctx-&gt;nb_comp_queues          = 1;\n        default:\n            break;\n        }\n    }\n\n    // Configure dedicated transfer queue if available\n    if (display_provider_-&gt;queues_.find(vulkan::queue::DEDICATED_TRANSFER) != display_provider_-&gt;queues_.end()) {\n        vulkan_hwdev_ctx-&gt;queue_family_tx_index =\n            static_cast&lt;int&gt;(display_provider_-&gt;queues_[vulkan::queue::DEDICATED_TRANSFER].family);\n        vulkan_hwdev_ctx-&gt;nb_tx_queues = 1;\n    }\n\n    // Vulkan Video not used in this implementation\n    vulkan_hwdev_ctx-&gt;nb_encode_queues          = 0;\n    vulkan_hwdev_ctx-&gt;nb_decode_queues          = 0;\n    vulkan_hwdev_ctx-&gt;queue_family_encode_index = -1;\n    vulkan_hwdev_ctx-&gt;queue_family_decode_index = -1;\n\n    // Set up extensions and callbacks\n    vulkan_hwdev_ctx-&gt;alloc                      = nullptr;\n    vulkan_hwdev_ctx-&gt;get_proc_addr              = vkGetInstanceProcAddr;\n    vulkan_hwdev_ctx-&gt;enabled_inst_extensions    = display_provider_-&gt;enabled_instance_extensions_.data();\n    vulkan_hwdev_ctx-&gt;nb_enabled_inst_extensions = static_cast&lt;int&gt;(display_provider_-&gt;enabled_instance_extensions_.size());\n    vulkan_hwdev_ctx-&gt;enabled_dev_extensions     = display_provider_-&gt;enabled_device_extensions_.data();\n    vulkan_hwdev_ctx-&gt;nb_enabled_dev_extensions  = static_cast&lt;int&gt;(display_provider_-&gt;enabled_device_extensions_.size());\n    vulkan_hwdev_ctx-&gt;lock_queue                 = &amp;ffmpeg_lock_queue;\n    vulkan_hwdev_ctx-&gt;unlock_queue               = &amp;ffmpeg_unlock_queue;\n\n    AV_ASSERT_SUCCESS(av_hwdevice_ctx_init(device_ctx_));\n    log_-&gt;info(\"FFmpeg Vulkan hwdevice context initialized\");\n}\n\nvoid offload_rendering_client::ffmpeg_init_cuda_device() {\n    auto ret = av_hwdevice_ctx_create(&amp;cuda_device_ctx_, AV_HWDEVICE_TYPE_CUDA, nullptr, nullptr, 0);\n    AV_ASSERT_SUCCESS(ret);\n    if (cuda_device_ctx_ == nullptr) {\n        throw std::runtime_error{\"Failed to create FFmpeg CUDA hwdevice context\"};\n    }\n    log_-&gt;info(\"FFmpeg CUDA hwdevice context initialized\");\n}\n\nvoid offload_rendering_client::ffmpeg_init_frame_ctx() {\n    assert(this-&gt;buffer_pool_ != nullptr);\n    this-&gt;frame_ctx_ = av_hwframe_ctx_alloc(device_ctx_);\n    if (!frame_ctx_) {\n        throw std::runtime_error{\"Failed to create FFmpeg Vulkan hwframe context\"};\n    }\n\n    auto hwframe_ctx    = reinterpret_cast&lt;AVHWFramesContext*&gt;(frame_ctx_-&gt;data);\n    hwframe_ctx-&gt;format = AV_PIX_FMT_VULKAN;\n    auto pix_format     = vulkan::ffmpeg_utils::get_pix_format_from_vk_format(buffer_pool_-&gt;image_pool[0][0].image_info.format);\n    if (!pix_format) {\n        throw std::runtime_error{\"Unsupported Vulkan image format when creating FFmpeg Vulkan hwframe context\"};\n    }\n    assert(pix_format == AV_PIX_FMT_BGRA);\n    hwframe_ctx-&gt;sw_format         = AV_PIX_FMT_BGRA;\n    hwframe_ctx-&gt;width             = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n    hwframe_ctx-&gt;height            = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n    hwframe_ctx-&gt;initial_pool_size = 0;\n    auto ret                       = av_hwframe_ctx_init(frame_ctx_);\n    AV_ASSERT_SUCCESS(ret);\n}\n\nAVBufferRef* offload_rendering_client::create_cuda_frame_ctx(AVPixelFormat fmt) {\n    auto cuda_frame_ref = av_hwframe_ctx_alloc(cuda_device_ctx_);\n    if (!cuda_frame_ref) {\n        throw std::runtime_error{\"Failed to create FFmpeg CUDA hwframe context\"};\n    }\n    auto cuda_hwframe_ctx               = reinterpret_cast&lt;AVHWFramesContext*&gt;(cuda_frame_ref-&gt;data);\n    cuda_hwframe_ctx-&gt;format            = AV_PIX_FMT_CUDA;\n    cuda_hwframe_ctx-&gt;sw_format         = fmt;\n    cuda_hwframe_ctx-&gt;width             = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n    cuda_hwframe_ctx-&gt;height            = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n    cuda_hwframe_ctx-&gt;initial_pool_size = 0;\n    auto ret                            = av_hwframe_ctx_init(cuda_frame_ref);\n    AV_ASSERT_SUCCESS(ret);\n    return cuda_frame_ref;\n}\n\nvoid offload_rendering_client::ffmpeg_init_cuda_frame_ctx() {\n    assert(this-&gt;buffer_pool_ != nullptr);\n    this-&gt;cuda_nv12_frame_ctx_ = create_cuda_frame_ctx(AV_PIX_FMT_NV12);\n    this-&gt;cuda_bgra_frame_ctx_ = create_cuda_frame_ctx(AV_PIX_FMT_BGRA);\n}\n\nvoid offload_rendering_client::ffmpeg_init_buffer_pool() {\n    assert(this-&gt;buffer_pool_ != nullptr);\n    avvk_color_frames_.resize(buffer_pool_-&gt;image_pool.size());\n    avvk_depth_frames_.resize(buffer_pool_-&gt;image_pool.size());\n    layout_transition_start_cmd_bufs_.resize(buffer_pool_-&gt;image_pool.size());\n    layout_transition_end_cmd_bufs_.resize(buffer_pool_-&gt;image_pool.size());\n\n    // Initialize frame resources for each buffer in the pool\n    for (size_t i = 0; i &lt; buffer_pool_-&gt;image_pool.size(); i++) {\n        for (size_t eye = 0; eye &lt; 2; eye++) {\n            // Create and configure color frames\n            auto vk_frame = av_vk_frame_alloc();\n            if (!vk_frame) {\n                throw std::runtime_error{\"Failed to allocate FFmpeg Vulkan frame\"};\n            }\n            vk_frame-&gt;img[0]          = buffer_pool_-&gt;image_pool[i][eye].image;\n            vk_frame-&gt;tiling          = buffer_pool_-&gt;image_pool[i][eye].image_info.tiling;\n            vk_frame-&gt;mem[0]          = buffer_pool_-&gt;image_pool[i][eye].allocation_info.deviceMemory;\n            vk_frame-&gt;size[0]         = buffer_pool_-&gt;image_pool[i][eye].allocation_info.size;\n            vk_frame-&gt;offset[0]       = static_cast&lt;ptrdiff_t&gt;(buffer_pool_-&gt;image_pool[i][eye].allocation_info.offset);\n            vk_frame-&gt;queue_family[0] = display_provider_-&gt;queues_[vulkan::queue::GRAPHICS].family;\n\n            // Create timeline semaphore for synchronization\n            VkExportSemaphoreCreateInfo export_semaphore_create_info{VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO, nullptr,\n                                                                     VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT};\n            vk_frame-&gt;sem[0] =\n                vulkan::create_timeline_semaphore(display_provider_-&gt;vk_device_, 0, &amp;export_semaphore_create_info);\n            vk_frame-&gt;sem_value[0] = 0;\n\n            avvk_color_frames_[i][eye].vk_frame = vk_frame;\n\n            // Create and configure AVFrame\n            auto av_frame = av_frame_alloc();\n            if (!av_frame) {\n                throw std::runtime_error{\"Failed to allocate FFmpeg frame\"};\n            }\n            av_frame-&gt;format                 = AV_PIX_FMT_VULKAN;\n            av_frame-&gt;width                  = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[i][eye].image_info.extent.width);\n            av_frame-&gt;height                 = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[i][eye].image_info.extent.height);\n            av_frame-&gt;hw_frames_ctx          = av_buffer_ref(frame_ctx_);\n            av_frame-&gt;data[0]                = reinterpret_cast&lt;uint8_t*&gt;(vk_frame);\n            av_frame-&gt;buf[0]                 = av_buffer_create(av_frame-&gt;data[0], 0, [](void*, uint8_t*) { }, nullptr, 0);\n            av_frame-&gt;pts                    = 0;\n            avvk_color_frames_[i][eye].frame = av_frame;\n\n            // Create and configure depth frames if enabled\n            if (use_depth_) {\n                auto vk_depth_frame = av_vk_frame_alloc();\n                if (!vk_depth_frame) {\n                    throw std::runtime_error{\"Failed to allocate FFmpeg Vulkan frame\"};\n                }\n                vk_depth_frame-&gt;img[0]  = buffer_pool_-&gt;depth_image_pool[i][eye].image;\n                vk_depth_frame-&gt;tiling  = buffer_pool_-&gt;depth_image_pool[i][eye].image_info.tiling;\n                vk_depth_frame-&gt;mem[0]  = buffer_pool_-&gt;depth_image_pool[i][eye].allocation_info.deviceMemory;\n                vk_depth_frame-&gt;size[0] = buffer_pool_-&gt;depth_image_pool[i][eye].allocation_info.size;\n                vk_depth_frame-&gt;offset[0] =\n                    static_cast&lt;ptrdiff_t&gt;(buffer_pool_-&gt;depth_image_pool[i][eye].allocation_info.offset);\n                vk_depth_frame-&gt;queue_family[0] = display_provider_-&gt;queues_[vulkan::queue::GRAPHICS].family;\n\n                vk_depth_frame-&gt;sem[0] =\n                    vulkan::create_timeline_semaphore(display_provider_-&gt;vk_device_, 0, &amp;export_semaphore_create_info);\n                vk_depth_frame-&gt;sem_value[0] = 0;\n\n                avvk_depth_frames_[i][eye].vk_frame = vk_depth_frame;\n\n                auto av_depth_frame = av_frame_alloc();\n                if (!av_depth_frame) {\n                    throw std::runtime_error{\"Failed to allocate FFmpeg frame\"};\n                }\n                av_depth_frame-&gt;format = AV_PIX_FMT_VULKAN;\n                av_depth_frame-&gt;width  = static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[i][eye].image_info.extent.width);\n                av_depth_frame-&gt;height = static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[i][eye].image_info.extent.height);\n                av_depth_frame-&gt;hw_frames_ctx = av_buffer_ref(frame_ctx_);\n                av_depth_frame-&gt;data[0]       = reinterpret_cast&lt;uint8_t*&gt;(vk_depth_frame);\n                av_depth_frame-&gt;buf[0] = av_buffer_create(av_depth_frame-&gt;data[0], 0, [](void*, uint8_t*) { }, nullptr, 0);\n                av_depth_frame-&gt;pts    = 0;\n                avvk_depth_frames_[i][eye].frame = av_depth_frame;\n            }\n        }\n    }\n\n    // Initialize decode frames\n    for (size_t eye = 0; eye &lt; 2; eye++) {\n        // Initialize color decode frames\n        decode_out_color_frames_[eye]                = av_frame_alloc();\n        decode_out_color_frames_[eye]-&gt;format        = AV_PIX_FMT_CUDA;\n        decode_out_color_frames_[eye]-&gt;hw_frames_ctx = av_buffer_ref(cuda_nv12_frame_ctx_);\n        decode_out_color_frames_[eye]-&gt;width         = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n        decode_out_color_frames_[eye]-&gt;height = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n        auto ret                              = av_hwframe_get_buffer(cuda_nv12_frame_ctx_, decode_out_color_frames_[eye], 0);\n        decode_out_color_frames_[eye]-&gt;color_range     = AVCOL_RANGE_JPEG;\n        decode_out_color_frames_[eye]-&gt;colorspace      = AVCOL_SPC_BT709;\n        decode_out_color_frames_[eye]-&gt;color_trc       = AVCOL_TRC_BT709;\n        decode_out_color_frames_[eye]-&gt;color_primaries = AVCOL_PRI_BT709;\n        AV_ASSERT_SUCCESS(ret);\n\n        // Initialize color conversion frames\n        decode_converted_color_frames_[eye]                = av_frame_alloc();\n        decode_converted_color_frames_[eye]-&gt;format        = AV_PIX_FMT_CUDA;\n        decode_converted_color_frames_[eye]-&gt;hw_frames_ctx = av_buffer_ref(cuda_bgra_frame_ctx_);\n        decode_converted_color_frames_[eye]-&gt;width  = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n        decode_converted_color_frames_[eye]-&gt;height = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n        ret = av_hwframe_get_buffer(cuda_bgra_frame_ctx_, decode_converted_color_frames_[eye], 0);\n        AV_ASSERT_SUCCESS(ret);\n\n        // Initialize depth frames if enabled\n        if (use_depth_) {\n            decode_out_depth_frames_[eye]                = av_frame_alloc();\n            decode_out_depth_frames_[eye]-&gt;format        = AV_PIX_FMT_CUDA;\n            decode_out_depth_frames_[eye]-&gt;hw_frames_ctx = av_buffer_ref(cuda_nv12_frame_ctx_);\n            decode_out_depth_frames_[eye]-&gt;width =\n                static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.width);\n            decode_out_depth_frames_[eye]-&gt;height =\n                static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.height);\n            decode_out_depth_frames_[eye]-&gt;color_range     = AVCOL_RANGE_JPEG;\n            decode_out_depth_frames_[eye]-&gt;colorspace      = AVCOL_SPC_BT709;\n            decode_out_depth_frames_[eye]-&gt;color_trc       = AVCOL_TRC_BT709;\n            decode_out_depth_frames_[eye]-&gt;color_primaries = AVCOL_PRI_BT709;\n            ret = av_hwframe_get_buffer(cuda_nv12_frame_ctx_, decode_out_depth_frames_[eye], 0);\n            AV_ASSERT_SUCCESS(ret);\n\n            decode_converted_depth_frames_[eye]                = av_frame_alloc();\n            decode_converted_depth_frames_[eye]-&gt;format        = AV_PIX_FMT_CUDA;\n            decode_converted_depth_frames_[eye]-&gt;hw_frames_ctx = av_buffer_ref(cuda_bgra_frame_ctx_);\n            decode_converted_depth_frames_[eye]-&gt;width =\n                static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.width);\n            decode_converted_depth_frames_[eye]-&gt;height =\n                static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.height);\n            ret = av_hwframe_get_buffer(cuda_bgra_frame_ctx_, decode_converted_depth_frames_[eye], 0);\n            AV_ASSERT_SUCCESS(ret);\n        }\n    }\n\n    // Allocate NPP buffers for color space conversion\n    yuv420_u_plane_ = nppiMalloc_8u_C1(static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width) / 2,\n                                       static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height) / 2, &amp;u_step_);\n    yuv420_v_plane_ = nppiMalloc_8u_C1(static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width) / 2,\n                                       static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height) / 2, &amp;v_step_);\n    yuv420_y_plane_ = nppiMalloc_8u_C1(static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width),\n                                       static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height), &amp;y_step_);\n}\n\nvoid offload_rendering_client::ffmpeg_init_decoder() {\n    auto decoder = avcodec_find_decoder_by_name(OFFLOAD_RENDERING_FFMPEG_DECODER_NAME);\n    if (!decoder) {\n        throw std::runtime_error{\"Failed to find FFmpeg decoder\"};\n    }\n\n    // Initialize color decoder\n    this-&gt;codec_color_ctx_ = avcodec_alloc_context3(decoder);\n    if (!codec_color_ctx_) {\n        throw std::runtime_error{\"Failed to allocate FFmpeg decoder context\"};\n    }\n\n    // Configure decoder parameters\n    codec_color_ctx_-&gt;thread_count  = 0; // auto\n    codec_color_ctx_-&gt;thread_type   = FF_THREAD_SLICE;\n    codec_color_ctx_-&gt;pix_fmt       = AV_PIX_FMT_CUDA;\n    codec_color_ctx_-&gt;sw_pix_fmt    = AV_PIX_FMT_NV12;\n    codec_color_ctx_-&gt;hw_device_ctx = av_buffer_ref(cuda_device_ctx_);\n    codec_color_ctx_-&gt;hw_frames_ctx = av_buffer_ref(cuda_nv12_frame_ctx_);\n    codec_color_ctx_-&gt;width         = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n    codec_color_ctx_-&gt;height        = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n    codec_color_ctx_-&gt;framerate     = {0, 1};\n    codec_color_ctx_-&gt;flags |= AV_CODEC_FLAG_LOW_DELAY;\n    codec_color_ctx_-&gt;color_range     = AVCOL_RANGE_JPEG;\n    codec_color_ctx_-&gt;colorspace      = AVCOL_SPC_BT709;\n    codec_color_ctx_-&gt;color_trc       = AVCOL_TRC_BT709;\n    codec_color_ctx_-&gt;color_primaries = AVCOL_PRI_BT709;\n\n    // Set zero latency mode\n    av_opt_set_int(codec_color_ctx_-&gt;priv_data, \"zerolatency\", 1, 0);\n    av_opt_set_int(codec_color_ctx_-&gt;priv_data, \"delay\", 0, 0);\n    av_opt_set(codec_color_ctx_-&gt;priv_data, \"hwaccel\", \"cuda\", 0);\n\n    auto ret = avcodec_open2(codec_color_ctx_, decoder, nullptr);\n    AV_ASSERT_SUCCESS(ret);\n\n    // Initialize depth decoder if enabled\n    if (use_depth_) {\n        this-&gt;codec_depth_ctx_ = avcodec_alloc_context3(decoder);\n        if (!codec_depth_ctx_) {\n            throw std::runtime_error{\"Failed to allocate FFmpeg decoder context\"};\n        }\n\n        // Configure depth decoder parameters (same as color)\n        codec_depth_ctx_-&gt;thread_count  = 0;\n        codec_depth_ctx_-&gt;thread_type   = FF_THREAD_SLICE;\n        codec_depth_ctx_-&gt;pix_fmt       = AV_PIX_FMT_CUDA;\n        codec_depth_ctx_-&gt;sw_pix_fmt    = AV_PIX_FMT_NV12;\n        codec_depth_ctx_-&gt;hw_device_ctx = av_buffer_ref(cuda_device_ctx_);\n        codec_depth_ctx_-&gt;hw_frames_ctx = av_buffer_ref(cuda_nv12_frame_ctx_);\n        codec_depth_ctx_-&gt;width         = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n        codec_depth_ctx_-&gt;height        = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n        codec_depth_ctx_-&gt;framerate     = {0, 1};\n        codec_depth_ctx_-&gt;flags |= AV_CODEC_FLAG_LOW_DELAY;\n        codec_depth_ctx_-&gt;color_range     = AVCOL_RANGE_JPEG;\n        codec_depth_ctx_-&gt;colorspace      = AVCOL_SPC_BT709;\n        codec_depth_ctx_-&gt;color_trc       = AVCOL_TRC_BT709;\n        codec_depth_ctx_-&gt;color_primaries = AVCOL_PRI_BT709;\n\n        av_opt_set_int(codec_depth_ctx_-&gt;priv_data, \"zerolatency\", 1, 0);\n        av_opt_set_int(codec_depth_ctx_-&gt;priv_data, \"delay\", 0, 0);\n        av_opt_set(codec_depth_ctx_-&gt;priv_data, \"hwaccel\", \"cuda\", 0);\n\n        ret = avcodec_open2(codec_depth_ctx_, decoder, nullptr);\n        AV_ASSERT_SUCCESS(ret);\n    }\n}\n</code></pre>"},{"location":"api/offload__rendering__client_8hpp/","title":"File offload_rendering_client.hpp","text":"<p>FileList &gt; offload_rendering_client &gt; offload_rendering_client.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/data_format/serializable_data.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/ffmpeg_utils.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include \"illixr/vk/vk_extension_request.hpp\"</code></li> <li><code>#include \"illixr/vk/vulkan_utils.hpp\"</code></li> <li><code>#include \"libavfilter_illixr/buffersink.h\"</code></li> <li><code>#include \"libavfilter_illixr/buffersrc.h\"</code></li> <li><code>#include \"libswscale_illixr/swscale.h\"</code></li> <li><code>#include \"nppi.h\"</code></li> </ul>"},{"location":"api/offload__rendering__client_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/offload__rendering__client_8hpp/#classes","title":"Classes","text":"Type Name class offload_rendering_client"},{"location":"api/offload__rendering__client_8hpp/#macros","title":"Macros","text":"Type Name define DOUBLE_INCLUDE"},{"location":"api/offload__rendering__client_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/offload__rendering__client_8hpp/#define-double_include","title":"define DOUBLE_INCLUDE","text":"<pre><code>#define DOUBLE_INCLUDE \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/offload_rendering_client.hpp</code></p>"},{"location":"api/offload__rendering__client_8hpp_source/","title":"File offload_rendering_client.hpp","text":"<p>File List &gt; offload_rendering_client &gt; offload_rendering_client.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#define DOUBLE_INCLUDE\n// ILLIXR core headers\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/data_format/serializable_data.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#undef DOUBLE_INCLUDE\n// ILLIXR Vulkan headers\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/ffmpeg_utils.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n#include \"illixr/vk/vk_extension_request.hpp\"\n#include \"illixr/vk/vulkan_utils.hpp\"\n\n// FFmpeg headers (C interface)\nextern \"C\" {\n#include \"libavfilter_illixr/buffersink.h\"\n#include \"libavfilter_illixr/buffersrc.h\"\n#include \"libswscale_illixr/swscale.h\"\n}\n\n// NVIDIA nppi headers\n#include \"nppi.h\"\n\nnamespace ILLIXR {\n\nclass offload_rendering_client\n    : public threadloop\n    , public vulkan::app {\npublic:\n    offload_rendering_client(const std::string&amp; name, phonebook* pb);\n\n    void start() override;\n\n    void setup(VkRenderPass render_pass, uint32_t subpass,\n               std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool) override;\n\n    void record_command_buffer(VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) override {\n        (void) commandBuffer;\n        (void) framebuffer;\n        (void) buffer_ind;\n        (void) left;\n    }\n\n    void update_uniforms(const data_format::pose_type&amp; render_pose) override {\n        (void) render_pose;\n    }\n\n    bool is_external() override {\n        return true;\n    }\n\n    void destroy() override;\n\nprotected:\n    void _p_thread_setup() override { }\n\n    skip_option _p_should_skip() override {\n        return threadloop::_p_should_skip();\n    }\n\n    [[maybe_unused]] void copy_image_to_cpu_and_save_file(AVFrame* frame);\n    [[maybe_unused]] void save_nv12_img_to_png(AVFrame* cuda_frame) const;\n    void transition_layout(VkCommandBuffer cmd_buf, AVFrame* frame, VkImageLayout old_layout, VkImageLayout new_layout);\n\n    void _p_one_iteration() override;\n\nprivate:\n    void push_pose();\n\n    bool network_receive();\n\n    [[maybe_unused]] void submit_command_buffer(VkCommandBuffer vk_command_buffer);\n\n    void ffmpeg_init_device();\n\n    void ffmpeg_init_cuda_device();\n\n    void ffmpeg_init_frame_ctx();\n\n    AVBufferRef* create_cuda_frame_ctx(AVPixelFormat fmt);\n\n    void ffmpeg_init_cuda_frame_ctx();\n\n    void ffmpeg_init_buffer_pool();\n\n    void ffmpeg_init_decoder();\n\n    std::shared_ptr&lt;switchboard&gt;                                switchboard_;\n    std::shared_ptr&lt;spdlog::logger&gt;                             log_;\n    std::shared_ptr&lt;vulkan::display_provider&gt;                   display_provider_;\n    switchboard::buffered_reader&lt;data_format::compressed_frame&gt; frames_reader_;\n    switchboard::network_writer&lt;data_format::fast_pose_type&gt;    pose_writer_;\n    std::shared_ptr&lt;data_format::pose_prediction&gt;               pose_prediction_;\n    std::atomic&lt;bool&gt;                                           ready_ = false;\n\n    std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool_;\n    bool                                                              use_depth_ = false;\n    std::vector&lt;std::array&lt;vulkan::ffmpeg_utils::ffmpeg_vk_frame, 2&gt;&gt; avvk_color_frames_;\n    std::vector&lt;std::array&lt;vulkan::ffmpeg_utils::ffmpeg_vk_frame, 2&gt;&gt; avvk_depth_frames_;\n    std::vector&lt;std::array&lt;VkCommandBuffer, 2&gt;&gt;                       layout_transition_start_cmd_bufs_;\n    std::vector&lt;std::array&lt;VkCommandBuffer, 2&gt;&gt;                       layout_transition_end_cmd_bufs_;\n    AVBufferRef*                                                      device_ctx_          = nullptr;\n    AVBufferRef*                                                      cuda_device_ctx_     = nullptr;\n    AVBufferRef*                                                      frame_ctx_           = nullptr;\n    AVBufferRef*                                                      cuda_nv12_frame_ctx_ = nullptr;\n    AVBufferRef*                                                      cuda_bgra_frame_ctx_ = nullptr;\n\n    AVCodecContext*          codec_color_ctx_               = nullptr;\n    std::array&lt;AVPacket*, 2&gt; decode_src_color_packets_      = {nullptr, nullptr};\n    std::array&lt;AVFrame*, 2&gt;  decode_out_color_frames_       = {nullptr, nullptr};\n    std::array&lt;AVFrame*, 2&gt;  decode_converted_color_frames_ = {nullptr, nullptr};\n\n    AVCodecContext*          codec_depth_ctx_               = nullptr;\n    std::array&lt;AVPacket*, 2&gt; decode_src_depth_packets_      = {nullptr, nullptr};\n    std::array&lt;AVFrame*, 2&gt;  decode_out_depth_frames_       = {nullptr, nullptr};\n    std::array&lt;AVFrame*, 2&gt;  decode_converted_depth_frames_ = {nullptr, nullptr};\n\n    data_format::fast_pose_type decoded_frame_pose_;\n\n    VkCommandPool command_pool{};\n    Npp8u*        yuv420_y_plane_ = nullptr;\n    Npp8u*        yuv420_u_plane_ = nullptr;\n    Npp8u*        yuv420_v_plane_ = nullptr;\n    int           y_step_         = 0;\n    int           u_step_         = 0;\n    int           v_step_         = 0;\n\n    uint64_t frame_count_ = 0;\n\n    VkFence fence_{};\n\n    uint16_t                                       fps_counter_    = 0;\n    std::chrono::high_resolution_clock::time_point fps_start_time_ = std::chrono::high_resolution_clock::now();\n    std::map&lt;std::string, uint32_t&gt;                metrics_{};\n\n    std::shared_ptr&lt;relative_clock&gt; clock_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/offload__rendering__server_8cpp/","title":"File offload_rendering_server.cpp","text":"<p>FileList &gt; offload_rendering_server &gt; offload_rendering_server.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"offload_rendering_server.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/offload_rendering_server.cpp</code></p>"},{"location":"api/offload__rendering__server_8cpp_source/","title":"File offload_rendering_server.cpp","text":"<p>File List &gt; offload_rendering_server &gt; offload_rendering_server.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"offload_rendering_server.hpp\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\nusing namespace vulkan::ffmpeg_utils;\n\noffload_rendering_server::offload_rendering_server(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , log_{spdlogger(\"debug\")}\n    , switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n    , frames_topic_{switchboard_-&gt;get_network_writer&lt;compressed_frame&gt;(\"compressed_frames\", {})}\n    , render_pose_{switchboard_-&gt;get_reader&lt;fast_pose_type&gt;(\"render_pose\")} {\n    // Only encode and pass depth if requested - otherwise skip it.\n    use_pass_depth_ = switchboard_-&gt;get_env_char(\"ILLIXR_USE_DEPTH_IMAGES\") != nullptr &amp;&amp;\n        std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_USE_DEPTH_IMAGES\"));\n    nalu_only_ = switchboard_-&gt;get_env_char(\"ILLIXR_OFFLOAD_RENDERING_NALU_ONLY\") != nullptr &amp;&amp;\n        std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_OFFLOAD_RENDERING_NALU_ONLY\"));\n    if (use_pass_depth_) {\n        log_-&gt;debug(\"Encoding depth images for the client\");\n    } else {\n        log_-&gt;debug(\"Not encoding depth images for the client\");\n    }\n\n    if (nalu_only_) {\n        log_-&gt;info(\"Only sending NALUs to the client\");\n    }\n    spd_add_file_sink(\"fps\", \"csv\", \"warn\");\n    log_-&gt;warn(\"Log Time,FPS\");\n}\n\nvoid offload_rendering_server::start() {\n    threadloop::start();\n}\n\nvoid offload_rendering_server::_p_thread_setup() {\n    // Wait for display provider to be ready\n    while (display_provider_ == nullptr) {\n        try {\n            display_provider_       = phonebook_-&gt;lookup_impl&lt;vulkan::display_provider&gt;();\n            display_provider_ffmpeg = display_provider_;\n        } catch (const std::exception&amp; e) {\n            log_-&gt;debug(\"Display provider not ready yet\");\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n    }\n    log_-&gt;info(\"Obtained display provider\");\n\n    // Configure encoding bitrate from environment or use default\n    auto bitrate_env = switchboard_-&gt;get_env_char(\"ILLIXR_OFFLOAD_RENDERING_BITRATE\");\n    if (bitrate_env == nullptr) {\n        bitrate_ = OFFLOAD_RENDERING_BITRATE;\n    } else {\n        bitrate_ = std::stol(bitrate_env);\n    }\n    if (bitrate_ &lt;= 0) {\n        throw std::runtime_error{\"Invalid bitrate value\"};\n    }\n    log_-&gt;info(\"Using bitrate: {}\", bitrate_);\n\n    // Configure framerate from environment or use default\n    auto framerate_env = switchboard_-&gt;get_env_char(\"ILLIXR_OFFLOAD_RENDERING_FRAMERATE\");\n    if (framerate_env == nullptr) {\n        framerate_ = 144;\n    } else {\n        framerate_ = std::stoi(framerate_env);\n    }\n    if (framerate_ &lt;= 0) {\n        throw std::runtime_error{\"Invalid framerate value\"};\n    }\n    log_-&gt;info(\"Using framerate: {}\", framerate_);\n\n    // Initialize FFmpeg and CUDA resources\n    ffmpeg_init_device();\n    ffmpeg_init_cuda_device();\n    ready_ = true;\n}\n\nvoid offload_rendering_server::setup(VkRenderPass render_pass, uint32_t subpass,\n                                     std::shared_ptr&lt;vulkan::buffer_pool&lt;fast_pose_type&gt;&gt; buffer_pool,\n                                     bool                                                 input_texture_vulkan_coordinates) {\n    (void) render_pass;\n    (void) subpass;\n    (void) input_texture_vulkan_coordinates;\n    // Wait for initialization to complete\n    while (!ready_) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    this-&gt;buffer_pool_ = buffer_pool;\n\n    // Initialize FFmpeg frame contexts and encoders\n    ffmpeg_init_frame_ctx();\n    ffmpeg_init_cuda_frame_ctx();\n    ffmpeg_init_buffer_pool();\n    ffmpeg_init_encoder();\n\n    // Allocate output packets for encoded frames\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        encode_out_color_packets_[eye] = av_packet_alloc();\n        if (use_pass_depth_) {\n            encode_out_depth_packets_[eye] = av_packet_alloc();\n        }\n    }\n}\n\nvoid offload_rendering_server::destroy() {\n    // Free color frame resources\n    for (auto&amp; frame : avvk_color_frames_) {\n        for (auto&amp; eye : frame) {\n            av_frame_free(&amp;eye.frame);\n        }\n    }\n\n    // Free depth frame resources if enabled\n    if (use_pass_depth_) {\n        for (auto&amp; frame : avvk_depth_frames_) {\n            for (auto&amp; eye : frame) {\n                av_frame_free(&amp;eye.frame);\n            }\n        }\n    }\n\n    // Release FFmpeg contexts\n    av_buffer_unref(&amp;frame_ctx_);\n    av_buffer_unref(&amp;device_ctx_);\n}\n\nfast_pose_type offload_rendering_server::get_fast_pose() const {\n    auto pose = render_pose_.get_ro_nullable();\n    if (pose == nullptr) {\n        return {};\n    } else {\n        return *pose;\n    }\n}\n\nvoid offload_rendering_server::_p_one_iteration() {\n    // Skip if no new frame is available\n    if (buffer_pool_ == nullptr || buffer_pool_-&gt;latest_decoded_image == -1) {\n        log_-&gt;info(\"no decoded image, returning\");\n        return;\n    }\n\n    // Record timing for performance analysis\n    auto acquire_image_start_time = std::chrono::high_resolution_clock::now();\n\n    // Acquire the latest frame and pose data\n    std::pair&lt;ILLIXR::vulkan::image_index_t, fast_pose_type&gt; res =\n        buffer_pool_-&gt;post_processing_acquire_image(static_cast&lt;signed char&gt;(last_frame_ind_));\n    auto acquire_image_end_time = std::chrono::high_resolution_clock::now();\n\n    auto ind  = res.first;\n    auto pose = res.second;\n\n    if (ind == -1) {\n        return;\n    }\n    last_frame_ind_ = static_cast&lt;unsigned char&gt;(ind);\n\n    // Record copy operation timing\n    auto copy_start_time = std::chrono::high_resolution_clock::now();\n\n    // Process color frames for both eyes\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        // Transfer color frame data to encoding buffer\n        auto ret = av_hwframe_transfer_data(encode_src_color_frames_[eye], avvk_color_frames_[ind][eye].frame, 0);\n        AV_ASSERT_SUCCESS(ret);\n        encode_src_color_frames_[eye]-&gt;pts = static_cast&lt;int64_t&gt;(frame_count_++);\n\n        // Process depth frame if enabled\n        if (use_pass_depth_) {\n            ret = av_hwframe_transfer_data(encode_src_depth_frames_[eye], avvk_depth_frames_[ind][eye].frame, 0);\n            AV_ASSERT_SUCCESS(ret);\n            encode_src_depth_frames_[eye]-&gt;pts = static_cast&lt;int64_t&gt;(frame_count_++);\n        }\n    }\n\n    auto copy_end_time = std::chrono::high_resolution_clock::now();\n    buffer_pool_-&gt;post_processing_release_image(ind);\n\n    // Record encode operation timing\n    auto encode_start_time = std::chrono::high_resolution_clock::now();\n\n    // Encode frames for both eyes\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        // Encode color frame\n        auto ret = avcodec_send_frame(codec_color_ctx_, encode_src_color_frames_[eye]);\n        if (ret == AVERROR(EAGAIN)) {\n            throw std::runtime_error{\"FFmpeg encoder returned EAGAIN. Internal buffer full? Try using a higher-end GPU.\"};\n        }\n        AV_ASSERT_SUCCESS(ret);\n\n        // Encode depth frame if enabled\n        if (use_pass_depth_) {\n            ret = avcodec_send_frame(codec_depth_ctx_, encode_src_depth_frames_[eye]);\n            if (ret == AVERROR(EAGAIN)) {\n                throw std::runtime_error{\"FFmpeg encoder returned EAGAIN. Internal buffer full? Try using a higher-end GPU.\"};\n            }\n            AV_ASSERT_SUCCESS(ret);\n        }\n    }\n\n    // Receive encoded packets\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        // Receive color packet\n        auto ret = avcodec_receive_packet(codec_color_ctx_, encode_out_color_packets_[eye]);\n        if (ret == AVERROR(EAGAIN)) {\n            throw std::runtime_error{\"FFmpeg encoder returned EAGAIN when receiving packets. This should never happen.\"};\n        }\n        AV_ASSERT_SUCCESS(ret);\n\n        // Receive depth packet if enabled\n        if (use_pass_depth_) {\n            ret = avcodec_receive_packet(codec_depth_ctx_, encode_out_depth_packets_[eye]);\n            if (ret == AVERROR(EAGAIN)) {\n                throw std::runtime_error{\"FFmpeg encoder returned EAGAIN when receiving packets. This should never happen.\"};\n            }\n            AV_ASSERT_SUCCESS(ret);\n        }\n    }\n    auto encode_end_time = std::chrono::high_resolution_clock::now();\n\n    // Calculate timing metrics\n    auto copy_time   = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(copy_end_time - copy_start_time).count();\n    auto encode_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(encode_end_time - encode_start_time).count();\n    auto acquire_image_time =\n        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(acquire_image_end_time - acquire_image_start_time).count();\n\n    // Update performance metrics\n    metrics_[\"copy_time\"] += copy_time;\n    metrics_[\"encode_time\"] += encode_time;\n    metrics_[\"acquire_image_time\"] += acquire_image_time;\n\n    // Send encoded frame to client\n    enqueue_for_network_send(pose);\n\n    // Log performance metrics every second\n    if (std::chrono::duration_cast&lt;std::chrono::seconds&gt;(std::chrono::high_resolution_clock::now() - fps_start_time_).count() &gt;=\n        1) {\n        log_-&gt;info(\"Encoder FPS: {}\", fps_counter_);\n        fps_start_time_ = std::chrono::high_resolution_clock::now();\n        log_-&gt;warn(\"{},{}\", fps_start_time_.time_since_epoch().count(), fps_counter_);\n\n        for (auto&amp; metric : metrics_) {\n            double fps = std::max(fps_counter_, (double) 0);\n            log_-&gt;info(\"{}: {}\", metric.first, metric.second / fps);\n            metric.second = 0;\n        }\n\n        if (use_pass_depth_) {\n            log_-&gt;info(\"Depth frame sizes - Left: {} Right: {}\", encode_out_depth_packets_[0]-&gt;size,\n                       encode_out_depth_packets_[1]-&gt;size);\n            // std::cout &lt;&lt; \"depth left: \" &lt;&lt; encode_out_depth_packets_[0]-&gt;size &lt;&lt; \" depth right: \" &lt;&lt;\n            // encode_out_depth_packets_[0]-&gt;size &lt;&lt; std::endl;\n        }\n\n        fps_counter_ = 0;\n    } else {\n        fps_counter_++;\n    }\n}\n\nvoid offload_rendering_server::enqueue_for_network_send(fast_pose_type&amp; pose) {\n    uint64_t timestamp =\n        std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch())\n            .count();\n\n    if (use_pass_depth_) {\n        frames_topic_.put(std::make_shared&lt;compressed_frame&gt;(encode_out_color_packets_[0], encode_out_color_packets_[1],\n                                                             encode_out_depth_packets_[0], encode_out_depth_packets_[1], pose,\n                                                             timestamp, nalu_only_));\n    } else {\n        frames_topic_.put(std::make_shared&lt;compressed_frame&gt;(encode_out_color_packets_[0], encode_out_color_packets_[1], pose,\n                                                             timestamp, nalu_only_));\n    }\n}\n\nvoid offload_rendering_server::ffmpeg_init_device() {\n    this-&gt;device_ctx_     = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_VULKAN);\n    auto hwdev_ctx        = reinterpret_cast&lt;AVHWDeviceContext*&gt;(device_ctx_-&gt;data);\n    auto vulkan_hwdev_ctx = reinterpret_cast&lt;AVVulkanDeviceContext*&gt;(hwdev_ctx-&gt;hwctx);\n\n    // Configure Vulkan device context\n    vulkan_hwdev_ctx-&gt;inst            = display_provider_-&gt;vk_instance_;\n    vulkan_hwdev_ctx-&gt;phys_dev        = display_provider_-&gt;vk_physical_device_;\n    vulkan_hwdev_ctx-&gt;act_dev         = display_provider_-&gt;vk_device_;\n    vulkan_hwdev_ctx-&gt;device_features = display_provider_-&gt;features_;\n\n    // Configure queue families for different operations\n    for (auto&amp; queue : display_provider_-&gt;queues_) {\n        switch (queue.first) {\n        case vulkan::queue::GRAPHICS:\n            vulkan_hwdev_ctx-&gt;queue_family_index    = static_cast&lt;int&gt;(queue.second.family);\n            vulkan_hwdev_ctx-&gt;nb_graphics_queues    = 1;\n            vulkan_hwdev_ctx-&gt;queue_family_tx_index = static_cast&lt;int&gt;(queue.second.family);\n            vulkan_hwdev_ctx-&gt;nb_tx_queues          = 1;\n            // TODO: data race here! need to supply the lock_queue and unlock_queue function.\n            // Not yet available in release version of ffmpeg\n            break;\n        case vulkan::queue::COMPUTE:\n            vulkan_hwdev_ctx-&gt;queue_family_comp_index = static_cast&lt;int&gt;(queue.second.family);\n            vulkan_hwdev_ctx-&gt;nb_comp_queues          = 1;\n        default:\n            break;\n        }\n    }\n\n    // Configure dedicated transfer queue if available\n    if (display_provider_-&gt;queues_.find(vulkan::queue::DEDICATED_TRANSFER) != display_provider_-&gt;queues_.end()) {\n        vulkan_hwdev_ctx-&gt;queue_family_tx_index =\n            static_cast&lt;int&gt;(display_provider_-&gt;queues_[vulkan::queue::DEDICATED_TRANSFER].family);\n        vulkan_hwdev_ctx-&gt;nb_tx_queues = 1;\n    }\n\n    // Vulkan Video not used in current implementation\n    vulkan_hwdev_ctx-&gt;nb_encode_queues          = 0;\n    vulkan_hwdev_ctx-&gt;nb_decode_queues          = 0;\n    vulkan_hwdev_ctx-&gt;queue_family_encode_index = -1;\n    vulkan_hwdev_ctx-&gt;queue_family_decode_index = -1;\n\n    vulkan_hwdev_ctx-&gt;alloc         = nullptr;\n    vulkan_hwdev_ctx-&gt;get_proc_addr = vkGetInstanceProcAddr;\n\n    // Configure Vulkan extensions\n    vulkan_hwdev_ctx-&gt;enabled_inst_extensions    = display_provider_-&gt;enabled_instance_extensions_.data();\n    vulkan_hwdev_ctx-&gt;nb_enabled_inst_extensions = static_cast&lt;int&gt;(display_provider_-&gt;enabled_instance_extensions_.size());\n    vulkan_hwdev_ctx-&gt;enabled_dev_extensions     = display_provider_-&gt;enabled_device_extensions_.data();\n    vulkan_hwdev_ctx-&gt;nb_enabled_dev_extensions  = static_cast&lt;int&gt;(display_provider_-&gt;enabled_device_extensions_.size());\n\n    vulkan_hwdev_ctx-&gt;lock_queue   = &amp;ffmpeg_lock_queue;\n    vulkan_hwdev_ctx-&gt;unlock_queue = &amp;ffmpeg_unlock_queue;\n\n    AV_ASSERT_SUCCESS(av_hwdevice_ctx_init(device_ctx_));\n    log_-&gt;info(\"FFmpeg Vulkan hwdevice context initialized\");\n}\n\nvoid offload_rendering_server::ffmpeg_init_cuda_device() {\n    auto ret = av_hwdevice_ctx_create(&amp;cuda_device_ctx_, AV_HWDEVICE_TYPE_CUDA, nullptr, nullptr, 0);\n    AV_ASSERT_SUCCESS(ret);\n    if (cuda_device_ctx_ == nullptr) {\n        throw std::runtime_error{\"Failed to create FFmpeg CUDA hwdevice context\"};\n    }\n    log_-&gt;info(\"FFmpeg CUDA hwdevice context initialized\");\n}\n\nvoid offload_rendering_server::ffmpeg_init_frame_ctx() {\n    assert(this-&gt;buffer_pool_ != nullptr);\n    this-&gt;frame_ctx_ = av_hwframe_ctx_alloc(device_ctx_);\n    if (!frame_ctx_) {\n        throw std::runtime_error{\"Failed to create FFmpeg Vulkan hwframe context\"};\n    }\n\n    auto hwframe_ctx    = reinterpret_cast&lt;AVHWFramesContext*&gt;(frame_ctx_-&gt;data);\n    hwframe_ctx-&gt;format = AV_PIX_FMT_VULKAN;\n\n    // Configure pixel format based on Vulkan image format\n    auto pix_format = vulkan::ffmpeg_utils::get_pix_format_from_vk_format(buffer_pool_-&gt;image_pool[0][0].image_info.format);\n    if (!pix_format) {\n        throw std::runtime_error{\"Unsupported Vulkan image format when creating FFmpeg Vulkan hwframe context\"};\n    }\n    assert(pix_format == AV_PIX_FMT_BGRA);\n\n    // Set frame properties\n    hwframe_ctx-&gt;sw_format         = AV_PIX_FMT_BGRA;\n    hwframe_ctx-&gt;width             = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n    hwframe_ctx-&gt;height            = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n    hwframe_ctx-&gt;initial_pool_size = 0;\n\n    auto ret = av_hwframe_ctx_init(frame_ctx_);\n    AV_ASSERT_SUCCESS(ret);\n}\n\nvoid offload_rendering_server::ffmpeg_init_cuda_frame_ctx() {\n    assert(this-&gt;buffer_pool_ != nullptr);\n    auto cuda_frame_ref = av_hwframe_ctx_alloc(cuda_device_ctx_);\n    if (!cuda_frame_ref) {\n        throw std::runtime_error{\"Failed to create FFmpeg CUDA hwframe context\"};\n    }\n\n    // Configure CUDA frame properties\n    auto cuda_hwframe_ctx       = reinterpret_cast&lt;AVHWFramesContext*&gt;(cuda_frame_ref-&gt;data);\n    cuda_hwframe_ctx-&gt;format    = AV_PIX_FMT_CUDA;\n    cuda_hwframe_ctx-&gt;sw_format = AV_PIX_FMT_BGRA;\n    cuda_hwframe_ctx-&gt;width     = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n    cuda_hwframe_ctx-&gt;height    = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n\n    auto ret = av_hwframe_ctx_init(cuda_frame_ref);\n    AV_ASSERT_SUCCESS(ret);\n    this-&gt;cuda_frame_ctx_ = cuda_frame_ref;\n}\n\nvoid offload_rendering_server::ffmpeg_init_buffer_pool() {\n    assert(this-&gt;buffer_pool_ != nullptr);\n\n    // Initialize color frame arrays\n    avvk_color_frames_.resize(buffer_pool_-&gt;image_pool.size());\n    if (use_pass_depth_) {\n        avvk_depth_frames_.resize(buffer_pool_-&gt;depth_image_pool.size());\n    }\n\n    // Set up frames for each buffer in the pool\n    for (size_t i = 0; i &lt; buffer_pool_-&gt;image_pool.size(); i++) {\n        for (size_t eye = 0; eye &lt; 2; eye++) {\n            // Create and configure color frame\n            auto vk_frame = av_vk_frame_alloc();\n            if (!vk_frame) {\n                throw std::runtime_error{\"Failed to allocate FFmpeg Vulkan frame for color image\"};\n            }\n\n            // Configure Vulkan frame properties\n            vk_frame-&gt;img[0]          = buffer_pool_-&gt;image_pool[i][eye].image;\n            vk_frame-&gt;tiling          = buffer_pool_-&gt;image_pool[i][eye].image_info.tiling;\n            vk_frame-&gt;mem[0]          = buffer_pool_-&gt;image_pool[i][eye].allocation_info.deviceMemory;\n            vk_frame-&gt;size[0]         = buffer_pool_-&gt;image_pool[i][eye].allocation_info.size;\n            vk_frame-&gt;offset[0]       = static_cast&lt;ptrdiff_t&gt;(buffer_pool_-&gt;image_pool[i][eye].allocation_info.offset);\n            vk_frame-&gt;queue_family[0] = display_provider_-&gt;queues_[vulkan::queue::GRAPHICS].family;\n\n            // Create and configure semaphore for synchronization\n            VkExportSemaphoreCreateInfo export_semaphore_create_info{VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO, nullptr,\n                                                                     VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT};\n            vk_frame-&gt;sem[0] =\n                vulkan::create_timeline_semaphore(display_provider_-&gt;vk_device_, 0, &amp;export_semaphore_create_info);\n            vk_frame-&gt;sem_value[0] = 0;\n            vk_frame-&gt;layout[0]    = VK_IMAGE_LAYOUT_UNDEFINED;\n\n            avvk_color_frames_[i][eye].vk_frame = vk_frame;\n\n            // Create and configure AVFrame for color\n            auto av_frame = av_frame_alloc();\n            if (!av_frame) {\n                throw std::runtime_error{\"Failed to allocate FFmpeg frame for color image\"};\n            }\n            av_frame-&gt;format                 = AV_PIX_FMT_VULKAN;\n            av_frame-&gt;width                  = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[i][eye].image_info.extent.width);\n            av_frame-&gt;height                 = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[i][eye].image_info.extent.height);\n            av_frame-&gt;hw_frames_ctx          = av_buffer_ref(frame_ctx_);\n            av_frame-&gt;data[0]                = reinterpret_cast&lt;uint8_t*&gt;(vk_frame);\n            av_frame-&gt;buf[0]                 = av_buffer_create(av_frame-&gt;data[0], 0, [](void*, uint8_t*) { }, nullptr, 0);\n            av_frame-&gt;pts                    = 0;\n            avvk_color_frames_[i][eye].frame = av_frame;\n\n            // Set up depth frame if enabled\n            if (use_pass_depth_) {\n                auto vk_depth_frame = av_vk_frame_alloc();\n                if (!vk_depth_frame) {\n                    throw std::runtime_error{\"Failed to allocate FFmpeg Vulkan frame for depth image\"};\n                }\n\n                // Configure Vulkan depth frame properties\n                vk_depth_frame-&gt;img[0]  = buffer_pool_-&gt;depth_image_pool[i][eye].image;\n                vk_depth_frame-&gt;tiling  = buffer_pool_-&gt;depth_image_pool[i][eye].image_info.tiling;\n                vk_depth_frame-&gt;mem[0]  = buffer_pool_-&gt;depth_image_pool[i][eye].allocation_info.deviceMemory;\n                vk_depth_frame-&gt;size[0] = buffer_pool_-&gt;depth_image_pool[i][eye].allocation_info.size;\n                vk_depth_frame-&gt;offset[0] =\n                    static_cast&lt;ptrdiff_t&gt;(buffer_pool_-&gt;depth_image_pool[i][eye].allocation_info.offset);\n                vk_depth_frame-&gt;queue_family[0] = display_provider_-&gt;queues_[vulkan::queue::GRAPHICS].family;\n\n                vk_depth_frame-&gt;sem[0] =\n                    vulkan::create_timeline_semaphore(display_provider_-&gt;vk_device_, 0, &amp;export_semaphore_create_info);\n                vk_depth_frame-&gt;sem_value[0] = 0;\n                vk_depth_frame-&gt;layout[0]    = VK_IMAGE_LAYOUT_UNDEFINED;\n\n                avvk_depth_frames_[i][eye].vk_frame = vk_depth_frame;\n\n                // Create and configure AVFrame for depth\n                auto av_depth_frame = av_frame_alloc();\n                if (!av_depth_frame) {\n                    throw std::runtime_error{\"Failed to allocate FFmpeg frame for depth image\"};\n                }\n                av_depth_frame-&gt;format = AV_PIX_FMT_VULKAN;\n                av_depth_frame-&gt;width  = static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[i][eye].image_info.extent.width);\n                av_depth_frame-&gt;height = static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[i][eye].image_info.extent.height);\n                av_depth_frame-&gt;hw_frames_ctx = av_buffer_ref(frame_ctx_);\n                av_depth_frame-&gt;data[0]       = reinterpret_cast&lt;uint8_t*&gt;(vk_depth_frame);\n                av_depth_frame-&gt;buf[0] = av_buffer_create(av_depth_frame-&gt;data[0], 0, [](void*, uint8_t*) { }, nullptr, 0);\n                av_depth_frame-&gt;pts    = 0;\n                avvk_depth_frames_[i][eye].frame = av_depth_frame;\n            }\n        }\n    }\n\n    // Initialize source frames for encoding\n    for (size_t eye = 0; eye &lt; 2; eye++) {\n        // Set up color source frame\n        encode_src_color_frames_[eye]                = av_frame_alloc();\n        encode_src_color_frames_[eye]-&gt;format        = AV_PIX_FMT_CUDA;\n        encode_src_color_frames_[eye]-&gt;hw_frames_ctx = av_buffer_ref(cuda_frame_ctx_);\n        encode_src_color_frames_[eye]-&gt;width         = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n        encode_src_color_frames_[eye]-&gt;height = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n\n        // Configure color space properties\n        encode_src_color_frames_[eye]-&gt;color_range     = AVCOL_RANGE_JPEG;\n        encode_src_color_frames_[eye]-&gt;colorspace      = AVCOL_SPC_BT709;\n        encode_src_color_frames_[eye]-&gt;color_trc       = AVCOL_TRC_BT709;\n        encode_src_color_frames_[eye]-&gt;color_primaries = AVCOL_PRI_BT709;\n        encode_src_color_frames_[eye]-&gt;pict_type       = AV_PICTURE_TYPE_I;\n\n        auto ret = av_hwframe_get_buffer(cuda_frame_ctx_, encode_src_color_frames_[eye], 0);\n        AV_ASSERT_SUCCESS(ret);\n\n        // Set up depth source frame if enabled\n        if (use_pass_depth_) {\n            encode_src_depth_frames_[eye]                = av_frame_alloc();\n            encode_src_depth_frames_[eye]-&gt;format        = AV_PIX_FMT_CUDA;\n            encode_src_depth_frames_[eye]-&gt;hw_frames_ctx = av_buffer_ref(cuda_frame_ctx_);\n            encode_src_depth_frames_[eye]-&gt;width =\n                static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.width);\n            encode_src_depth_frames_[eye]-&gt;height =\n                static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.height);\n\n            // Configure depth frame color space\n            encode_src_depth_frames_[eye]-&gt;color_range     = AVCOL_RANGE_JPEG;\n            encode_src_depth_frames_[eye]-&gt;colorspace      = AVCOL_SPC_BT709;\n            encode_src_depth_frames_[eye]-&gt;color_trc       = AVCOL_TRC_BT709;\n            encode_src_depth_frames_[eye]-&gt;color_primaries = AVCOL_PRI_BT709;\n            encode_src_depth_frames_[eye]-&gt;pict_type       = AV_PICTURE_TYPE_I;\n\n            ret = av_hwframe_get_buffer(cuda_frame_ctx_, encode_src_depth_frames_[eye], 0);\n            AV_ASSERT_SUCCESS(ret);\n        }\n    }\n}\n\nvoid offload_rendering_server::ffmpeg_init_encoder() {\n    // Find hardware-accelerated encoder\n    auto encoder = avcodec_find_encoder_by_name(OFFLOAD_RENDERING_FFMPEG_ENCODER_NAME);\n    if (!encoder) {\n        throw std::runtime_error{\"Failed to find FFmpeg encoder\"};\n    }\n\n    // Initialize color encoder\n    this-&gt;codec_color_ctx_ = avcodec_alloc_context3(encoder);\n    if (!codec_color_ctx_) {\n        throw std::runtime_error{\"Failed to allocate FFmpeg encoder context for color images\"};\n    }\n\n    // Configure multithreading\n    codec_color_ctx_-&gt;thread_count = 0; // auto\n    codec_color_ctx_-&gt;thread_type  = FF_THREAD_SLICE;\n\n    // Configure pixel format and hardware acceleration\n    codec_color_ctx_-&gt;pix_fmt       = AV_PIX_FMT_CUDA;\n    codec_color_ctx_-&gt;sw_pix_fmt    = AV_PIX_FMT_BGRA;\n    codec_color_ctx_-&gt;hw_frames_ctx = av_buffer_ref(cuda_frame_ctx_);\n\n    // Set frame dimensions and timing\n    codec_color_ctx_-&gt;width     = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.width);\n    codec_color_ctx_-&gt;height    = static_cast&lt;int&gt;(buffer_pool_-&gt;image_pool[0][0].image_info.extent.height);\n    codec_color_ctx_-&gt;time_base = {1, framerate_};\n    codec_color_ctx_-&gt;framerate = {framerate_, 1};\n    codec_color_ctx_-&gt;bit_rate  = bitrate_;\n\n    // Configure color space\n    codec_color_ctx_-&gt;color_range     = AVCOL_RANGE_JPEG;\n    codec_color_ctx_-&gt;colorspace      = AVCOL_SPC_BT709;\n    codec_color_ctx_-&gt;color_trc       = AVCOL_TRC_BT709;\n    codec_color_ctx_-&gt;color_primaries = AVCOL_PRI_BT709;\n\n    // Configure for low latency\n    codec_color_ctx_-&gt;max_b_frames = 0;\n    codec_color_ctx_-&gt;gop_size     = 15; // Intra-frame interval\n    av_opt_set_int(codec_color_ctx_-&gt;priv_data, \"zerolatency\", 1, 0);\n    av_opt_set_int(codec_color_ctx_-&gt;priv_data, \"delay\", 0, 0);\n\n    auto ret = avcodec_open2(codec_color_ctx_, encoder, nullptr);\n    AV_ASSERT_SUCCESS(ret);\n\n    // Initialize depth encoder if enabled\n    if (use_pass_depth_) {\n        this-&gt;codec_depth_ctx_ = avcodec_alloc_context3(encoder);\n        if (!codec_depth_ctx_) {\n            throw std::runtime_error{\"Failed to allocate FFmpeg encoder context for depth images\"};\n        }\n\n        // Configure multithreading\n        codec_depth_ctx_-&gt;thread_count = 0;\n        codec_depth_ctx_-&gt;thread_type  = FF_THREAD_SLICE;\n\n        // Configure pixel format and hardware acceleration\n        codec_depth_ctx_-&gt;pix_fmt       = AV_PIX_FMT_CUDA;\n        codec_depth_ctx_-&gt;sw_pix_fmt    = AV_PIX_FMT_BGRA;\n        codec_depth_ctx_-&gt;hw_frames_ctx = av_buffer_ref(cuda_frame_ctx_);\n\n        // Set frame dimensions and timing\n        codec_depth_ctx_-&gt;width     = static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.width);\n        codec_depth_ctx_-&gt;height    = static_cast&lt;int&gt;(buffer_pool_-&gt;depth_image_pool[0][0].image_info.extent.height);\n        codec_depth_ctx_-&gt;time_base = {1, framerate_};\n        codec_depth_ctx_-&gt;framerate = {framerate_, 1};\n        codec_depth_ctx_-&gt;bit_rate  = bitrate_;\n\n        // Configure color space\n        codec_depth_ctx_-&gt;color_range     = AVCOL_RANGE_JPEG;\n        codec_depth_ctx_-&gt;colorspace      = AVCOL_SPC_BT709;\n        codec_depth_ctx_-&gt;color_trc       = AVCOL_TRC_BT709;\n        codec_depth_ctx_-&gt;color_primaries = AVCOL_PRI_BT709;\n\n        // Configure for low latency\n        codec_depth_ctx_-&gt;max_b_frames = 0;\n        codec_depth_ctx_-&gt;gop_size     = 15;\n        av_opt_set_int(codec_depth_ctx_-&gt;priv_data, \"zerolatency\", 1, 0);\n        av_opt_set_int(codec_depth_ctx_-&gt;priv_data, \"delay\", 0, 0);\n\n        ret = avcodec_open2(codec_depth_ctx_, encoder, nullptr);\n        AV_ASSERT_SUCCESS(ret);\n    }\n}\n</code></pre>"},{"location":"api/offload__rendering__server_8hpp/","title":"File offload_rendering_server.hpp","text":"<p>FileList &gt; offload_rendering_server &gt; offload_rendering_server.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/data_format/serializable_data.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/ffmpeg_utils.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include \"illixr/vk/vulkan_utils.hpp\"</code></li> </ul>"},{"location":"api/offload__rendering__server_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/offload__rendering__server_8hpp/#classes","title":"Classes","text":"Type Name class offload_rendering_server Main server implementation for offload rendering."},{"location":"api/offload__rendering__server_8hpp/#macros","title":"Macros","text":"Type Name define DOUBLE_INCLUDE"},{"location":"api/offload__rendering__server_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/offload__rendering__server_8hpp/#define-double_include","title":"define DOUBLE_INCLUDE","text":"<pre><code>#define DOUBLE_INCLUDE \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/offload_rendering_server.hpp</code></p>"},{"location":"api/offload__rendering__server_8hpp_source/","title":"File offload_rendering_server.hpp","text":"<p>File List &gt; offload_rendering_server &gt; offload_rendering_server.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#define DOUBLE_INCLUDE\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/data_format/serializable_data.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/ffmpeg_utils.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n#include \"illixr/vk/vulkan_utils.hpp\"\n#undef DOUBLE_INCLUDE\n\nnamespace ILLIXR {\n\nclass offload_rendering_server\n    : public threadloop\n    , public vulkan::timewarp\n    , public data_format::pose_prediction\n    , std::enable_shared_from_this&lt;plugin&gt; {\npublic:\n    offload_rendering_server(const std::string&amp; name, phonebook* pb);\n    void start() override;\n    void _p_thread_setup() override;\n\n    void setup(VkRenderPass render_pass, uint32_t subpass,\n               std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; _buffer_pool,\n               bool                                                              input_texture_vulkan_coordinates) override;\n\n    bool is_external() override {\n        return true;\n    }\n\n    void destroy() override;\n\n    data_format::fast_pose_type get_fast_pose() const override;\n\n    data_format::pose_type get_true_pose() const override {\n        return get_fast_pose().pose;\n    }\n\n    data_format::fast_pose_type get_fast_pose(time_point future_time) const override {\n        (void) future_time;\n        return get_fast_pose();\n    }\n\n    bool fast_pose_reliable() const override {\n        return render_pose_.get_ro_nullable() != nullptr;\n    }\n\n    bool true_pose_reliable() const override {\n        return false;\n    }\n\n    void set_offset(const Eigen::Quaternionf&amp; orientation) override {\n        (void) orientation;\n    }\n\n    Eigen::Quaternionf get_offset() override {\n        return {};\n    }\n\n    data_format::pose_type correct_pose(const data_format::pose_type&amp; pose) const override {\n        (void) pose;\n        return {};\n    }\n\n    void record_command_buffer(VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) override {\n        (void) commandBuffer;\n        (void) framebuffer;\n        (void) buffer_ind;\n        (void) left;\n    }\n\n    void update_uniforms(const data_format::pose_type&amp; r_pose) override {\n        (void) r_pose;\n    }\n\nprotected:\n    skip_option _p_should_skip() override {\n        return threadloop::_p_should_skip();\n    }\n\n    void _p_one_iteration() override;\n\nprivate:\n    void enqueue_for_network_send(data_format::fast_pose_type&amp; pose);\n\n    void ffmpeg_init_device();\n\n    void ffmpeg_init_cuda_device();\n\n    void ffmpeg_init_frame_ctx();\n\n    void ffmpeg_init_cuda_frame_ctx();\n\n    void ffmpeg_init_buffer_pool();\n\n    void ffmpeg_init_encoder();\n\n    std::shared_ptr&lt;spdlog::logger&gt;                                   log_;\n    std::shared_ptr&lt;vulkan::display_provider&gt;                         display_provider_;\n    std::shared_ptr&lt;switchboard&gt;                                      switchboard_;\n    switchboard::network_writer&lt;data_format::compressed_frame&gt;        frames_topic_;\n    switchboard::reader&lt;data_format::fast_pose_type&gt;                  render_pose_;\n    std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool_;\n    std::vector&lt;std::array&lt;vulkan::ffmpeg_utils::ffmpeg_vk_frame, 2&gt;&gt; avvk_color_frames_;\n    std::vector&lt;std::array&lt;vulkan::ffmpeg_utils::ffmpeg_vk_frame, 2&gt;&gt; avvk_depth_frames_;\n\n    int  framerate_ = 144;\n    long bitrate_   = OFFLOAD_RENDERING_BITRATE;\n\n    bool use_pass_depth_ = false;\n    bool nalu_only_      = false;\n\n    AVBufferRef* device_ctx_      = nullptr;\n    AVBufferRef* cuda_device_ctx_ = nullptr;\n    AVBufferRef* frame_ctx_       = nullptr;\n    AVBufferRef* cuda_frame_ctx_  = nullptr;\n\n    AVCodecContext*          codec_color_ctx_ = nullptr;\n    std::array&lt;AVFrame*, 2&gt;  encode_src_color_frames_{};\n    std::array&lt;AVPacket*, 2&gt; encode_out_color_packets_{};\n\n    AVCodecContext*          codec_depth_ctx_ = nullptr;\n    std::array&lt;AVFrame*, 2&gt;  encode_src_depth_frames_{};\n    std::array&lt;AVPacket*, 2&gt; encode_out_depth_packets_{};\n\n    uint64_t frame_count_ = 0;\n\n    double                                         fps_counter_    = 0;\n    std::chrono::high_resolution_clock::time_point fps_start_time_ = std::chrono::high_resolution_clock::now();\n    std::map&lt;std::string, uint32_t&gt;                metrics_;\n\n    uint16_t last_frame_ind_ = -1;\n\n    std::atomic&lt;bool&gt; ready_{false};\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/opencv__data__types_8hpp/","title":"File opencv_data_types.hpp","text":"<p>FileList &gt; data_format &gt; opencv_data_types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/unit.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;opencv4/opencv2/core/mat.hpp&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/opencv__data__types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format namespace camera namespace image"},{"location":"api/opencv__data__types_8hpp/#classes","title":"Classes","text":"Type Name struct binocular_cam_type struct cam_base_type struct depth_type struct monocular_cam_type struct rgb_depth_type <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/opencv__data__types_8hpp_source/","title":"File opencv_data_types.hpp","text":"<p>File List &gt; data_format &gt; opencv_data_types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/unit.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;fstream&gt;\n#include &lt;map&gt;\n#include &lt;opencv4/opencv2/core/mat.hpp&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR::data_format {\nnamespace image {\n    enum image_type { LEFT_EYE, RIGHT_EYE, RGB, DEPTH, LEFT_EYE_PROCESSED, RIGHT_EYE_PROCESSED, RGB_PROCESSED, CONFIDENCE };\n\n    const std::map&lt;image_type, const std::string&gt; image_type_map = {{LEFT_EYE, \"LEFT_EYE\"},\n                                                                    {RIGHT_EYE, \"RIGHT_EYE\"},\n                                                                    {RGB, \"RGB\"},\n                                                                    {DEPTH, \"DEPTH\"},\n                                                                    {LEFT_EYE_PROCESSED, \"LEFT_EYE_PROCESSED\"},\n                                                                    {RIGHT_EYE_PROCESSED, \"RIGHT_EYE_PROCESSED\"},\n                                                                    {RGB_PROCESSED, \"RGB_PROCESSED\"},\n                                                                    {CONFIDENCE, \"CONFIDENCE\"}};\n} // namespace image\n\nnamespace camera {\n    enum cam_type { BINOCULAR, MONOCULAR, RGB_DEPTH, DEPTH, ZED };\n}\n\nstruct cam_base_type : switchboard::event {\n    time_point                           time;     \n    camera::cam_type                     type;     \n    std::map&lt;image::image_type, cv::Mat&gt; images{}; \n\n    cam_base_type(time_point _time, std::map&lt;image::image_type, cv::Mat&gt; imgs, camera::cam_type _type)\n        : time(_time)\n        , type(_type)\n        , images{std::move(imgs)} { }\n\n    cv::Mat&amp; operator[](image::image_type idx) {\n        return images.at(idx);\n    }\n\n    int format(image::image_type idx) {\n        return images.at(idx).type();\n    }\n\n    [[nodiscard]] size_t size() const {\n        return images.size();\n    }\n\n    [[nodiscard]] cv::Mat at(const image::image_type idx) const {\n        return images.at(idx);\n    }\n\n    [[nodiscard]] std::map&lt;image::image_type, cv::Mat&gt;::const_iterator find(const image::image_type idx) const {\n        return images.find(idx);\n    }\n\n    [[nodiscard]] std::map&lt;image::image_type, cv::Mat&gt;::const_iterator begin() const {\n        return images.begin();\n    }\n\n    [[nodiscard]] std::map&lt;image::image_type, cv::Mat&gt;::const_iterator end() const {\n        return images.end();\n    }\n};\n\nstruct [[maybe_unused]] binocular_cam_type : cam_base_type {\n    binocular_cam_type(time_point _time, cv::Mat _img0, cv::Mat _img1)\n        : cam_base_type(_time, {{image::LEFT_EYE, _img0}, {image::RIGHT_EYE, _img1}}, camera::BINOCULAR) { }\n};\n\nstruct [[maybe_unused]] monocular_cam_type : cam_base_type {\n    monocular_cam_type(time_point _time, cv::Mat _img)\n        : cam_base_type(_time, {{image::RGB, _img}}, camera::MONOCULAR) { }\n\n    [[nodiscard]] cv::Mat img() const {\n        return images.at(image::RGB);\n    }\n};\n\nstruct [[maybe_unused]] rgb_depth_type : cam_base_type {\n    units::measurement_unit units;\n\n    rgb_depth_type(time_point _time, cv::Mat _rgb, cv::Mat _depth, units::measurement_unit units_ = units::UNSET)\n        : cam_base_type(_time, {{image::RGB, _rgb}, {image::DEPTH, _depth}}, camera::RGB_DEPTH)\n        , units{units_} { }\n};\n\nstruct [[maybe_unused]] depth_type : cam_base_type {\n    units::measurement_unit units;\n\n    depth_type(time_point _time, cv::Mat _depth, units::measurement_unit units_)\n        : cam_base_type(_time, {{image::DEPTH, _depth}}, camera::DEPTH)\n        , units{units_} { }\n};\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/openwarp__vk_8cpp/","title":"File openwarp_vk.cpp","text":"<p>FileList &gt; openwarp_vk &gt; openwarp_vk.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"openwarp_vk.hpp\"</code></li> <li><code>#include \"illixr/math_util.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/openwarp_vk.cpp</code></p>"},{"location":"api/openwarp__vk_8cpp_source/","title":"File openwarp_vk.cpp","text":"<p>File List &gt; openwarp_vk &gt; openwarp_vk.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"openwarp_vk.hpp\"\n\n#include \"illixr/math_util.hpp\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nopenwarp_vk::openwarp_vk(const phonebook* pb)\n    : phonebook_{pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , pose_prediction_{phonebook_-&gt;lookup_impl&lt;pose_prediction&gt;()}\n    , disable_warp_{switchboard_-&gt;get_env_bool(\"ILLIXR_TIMEWARP_DISABLE\", \"False\")} {\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_OPENWARP_WIDTH\") == nullptr ||\n        switchboard_-&gt;get_env_char(\"ILLIXR_OPENWARP_HEIGHT\") == nullptr) {\n        spdlog::get(\"illixr\")-&gt;info(\"[openwarp] Grid dimensions not set, defaulting to 512x512\");\n        openwarp_width_  = 512;\n        openwarp_height_ = 512;\n    } else {\n        openwarp_width_  = std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_OPENWARP_WIDTH\"));\n        openwarp_height_ = std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_OPENWARP_HEIGHT\"));\n    }\n\n    using_godot_ = switchboard_-&gt;get_env_bool(\"ILLIXR_USING_GODOT\");\n    if (using_godot_)\n        spdlog::get(\"illixr\")-&gt;info(\"[openwarp] Using Godot projection matrices\");\n    else\n        spdlog::get(\"illixr\")-&gt;info(\"[openwarp] Using Unreal projection matrices\");\n}\n\n// For objects that only need to be created a single time and do not need to change.\nvoid openwarp_vk::initialize() {\n    if (display_provider_-&gt;vma_allocator_) {\n        this-&gt;vma_allocator_ = display_provider_-&gt;vma_allocator_;\n    } else {\n        this-&gt;vma_allocator_ = vulkan::create_vma_allocator(\n            display_provider_-&gt;vk_instance_, display_provider_-&gt;vk_physical_device_, display_provider_-&gt;vk_device_);\n        deletion_queue_.emplace([=]() {\n            vmaDestroyAllocator(vma_allocator_);\n        });\n    }\n\n    command_pool_   = vulkan::create_command_pool(display_provider_-&gt;vk_device_,\n                                                  display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS].family);\n    command_buffer_ = vulkan::create_command_buffer(display_provider_-&gt;vk_device_, command_pool_);\n    deletion_queue_.emplace([=]() {\n        vkDestroyCommandPool(display_provider_-&gt;vk_device_, command_pool_, nullptr);\n    });\n\n    create_descriptor_set_layouts();\n    create_uniform_buffers();\n    create_texture_sampler();\n}\n\nvoid openwarp_vk::setup(VkRenderPass render_pass, uint32_t subpass,\n                        std::shared_ptr&lt;vulkan::buffer_pool&lt;fast_pose_type&gt;&gt; buffer_pool, bool input_texture_external) {\n    std::lock_guard&lt;std::mutex&gt; lock{setup_mutex_};\n\n    display_provider_ = phonebook_-&gt;lookup_impl&lt;vulkan::display_provider&gt;();\n\n    swapchain_width_  = display_provider_-&gt;swapchain_extent_.width == 0 ? display_params::width_pixels\n                                                                        : display_provider_-&gt;swapchain_extent_.width;\n    swapchain_height_ = display_provider_-&gt;swapchain_extent_.height == 0 ? display_params::height_pixels\n                                                                         : display_provider_-&gt;swapchain_extent_.height;\n\n    HMD::get_default_hmd_info(static_cast&lt;int&gt;(swapchain_width_), static_cast&lt;int&gt;(swapchain_height_),\n                              display_params::width_meters, display_params::height_meters, display_params::lens_separation,\n                              display_params::meters_per_tan_angle, display_params::aberration, hmd_info_);\n\n    this-&gt;input_texture_external_ = input_texture_external;\n    if (!initialized_) {\n        initialize();\n        initialized_ = true;\n    } else {\n        partial_destroy();\n    }\n\n    generate_openwarp_mesh(openwarp_width_, openwarp_height_);\n    generate_distortion_data();\n\n    create_vertex_buffers();\n    create_index_buffers();\n\n    this-&gt;buffer_pool_ = std::move(buffer_pool);\n\n    create_descriptor_pool();\n    create_openwarp_pipeline();\n    distortion_correction_render_pass_ = render_pass;\n    create_distortion_correction_pipeline(render_pass, subpass);\n\n    create_offscreen_images();\n    create_descriptor_sets();\n\n    this-&gt;offloaded_rendering_ = switchboard_-&gt;get_env_bool(\"ILLIXR_OFFLOADING_RENDERING\");\n}\n\nvoid openwarp_vk::partial_destroy() {\n    vmaDestroyBuffer(vma_allocator_, ow_vertex_buffer_, ow_vertex_alloc_);\n    vmaDestroyBuffer(vma_allocator_, dc_vertex_buffer_, dc_vertex_alloc_);\n    vmaDestroyBuffer(vma_allocator_, ow_index_buffer_, ow_index_alloc_);\n    vmaDestroyBuffer(vma_allocator_, dc_index_buffer_, dc_index_alloc_);\n\n    for (size_t i = 0; i &lt; offscreen_images_.size(); i++) {\n        vkDestroyFramebuffer(display_provider_-&gt;vk_device_, offscreen_framebuffers_[i], nullptr);\n\n        vkDestroyImageView(display_provider_-&gt;vk_device_, offscreen_image_views_[i], nullptr);\n        vmaDestroyImage(vma_allocator_, offscreen_images_[i], offscreen_image_allocs_[i]);\n\n        vkDestroyImageView(display_provider_-&gt;vk_device_, offscreen_depth_views_[i], nullptr);\n        vmaDestroyImage(vma_allocator_, offscreen_depths_[i], offscreen_depth_allocs_[i]);\n    }\n\n    vkDestroyRenderPass(display_provider_-&gt;vk_device_, openwarp_render_pass_, nullptr);\n\n    vkDestroyPipeline(display_provider_-&gt;vk_device_, openwarp_pipeline_, nullptr);\n    openwarp_pipeline_ = VK_NULL_HANDLE;\n\n    vkDestroyPipelineLayout(display_provider_-&gt;vk_device_, ow_pipeline_layout_, nullptr);\n    ow_pipeline_layout_ = VK_NULL_HANDLE;\n\n    vkDestroyPipeline(display_provider_-&gt;vk_device_, pipeline_, nullptr);\n    pipeline_ = VK_NULL_HANDLE;\n\n    vkDestroyPipelineLayout(display_provider_-&gt;vk_device_, dp_pipeline_layout_, nullptr);\n    dp_pipeline_layout_ = VK_NULL_HANDLE;\n\n    vkDestroyDescriptorPool(display_provider_-&gt;vk_device_, descriptor_pool_, nullptr);\n    descriptor_pool_ = VK_NULL_HANDLE;\n}\n\nvoid openwarp_vk::update_uniforms(const pose_type&amp; render_pose) {\n    num_update_uniforms_calls_++;\n\n    pose_type latest_pose = disable_warp_ ? render_pose : pose_prediction_-&gt;get_fast_pose().pose;\n\n    for (int eye = 0; eye &lt; 2; eye++) {\n        Eigen::Matrix4f renderedCameraMatrix = create_camera_matrix(render_pose, eye);\n        Eigen::Matrix4f currentCameraMatrix  = create_camera_matrix(latest_pose, eye);\n\n        Eigen::Matrix4f warpVP =\n            basic_projection_[eye] * currentCameraMatrix.inverse(); // inverse of camera matrix is view matrix\n\n        auto* ow_ubo = (WarpMatrices*) ow_matrices_uniform_alloc_info_.pMappedData;\n        memcpy(&amp;ow_ubo-&gt;render_inv_projection[eye], inverse_projection_[eye].data(), sizeof(Eigen::Matrix4f));\n        memcpy(&amp;ow_ubo-&gt;render_inv_view[eye], renderedCameraMatrix.data(), sizeof(Eigen::Matrix4f));\n        memcpy(&amp;ow_ubo-&gt;warp_view_projection[eye], warpVP.data(), sizeof(Eigen::Matrix4f));\n    }\n}\n\nvoid openwarp_vk::record_command_buffer(VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) {\n    num_record_calls_++;\n\n    if (left)\n        frame_count_++;\n\n    VkDeviceSize offsets = 0;\n    VkClearValue clear_colors[2];\n    clear_colors[0].color              = {0.0f, 0.0f, 0.0f, 1.0f};\n    clear_colors[1].depthStencil.depth = rendering_params::reverse_z ? 0.0 : 1.0;\n\n    // First render OpenWarp offscreen for a distortion correction pass later\n    VkRenderPassBeginInfo ow_render_pass_info{.sType           = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n                                              .pNext           = nullptr,\n                                              .renderPass      = openwarp_render_pass_,\n                                              .framebuffer     = offscreen_framebuffers_[left ? 0 : 1],\n                                              .renderArea      = {.offset = {.x = 0, .y = 0},\n                                                                  .extent = {.width  = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2),\n                                                                             .height = static_cast&lt;uint32_t&gt;(swapchain_height_)}},\n                                              .clearValueCount = 2,\n                                              .pClearValues    = clear_colors};\n\n    VkViewport ow_viewport{.x        = 0,\n                           .y        = 0,\n                           .width    = static_cast&lt;float&gt;(swapchain_width_) / 2.f,\n                           .height   = static_cast&lt;float&gt;(swapchain_height_),\n                           .minDepth = 0.0f,\n                           .maxDepth = 1.0f};\n\n    VkRect2D ow_scissor{\n        .offset = {.x = 0, .y = 0},\n        .extent = {.width = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2), .height = static_cast&lt;uint32_t&gt;(swapchain_height_)}};\n\n    auto eye = static_cast&lt;uint32_t&gt;(left ? 0 : 1);\n\n    vkCmdBeginRenderPass(commandBuffer, &amp;ow_render_pass_info, VK_SUBPASS_CONTENTS_INLINE);\n    vkCmdSetViewport(commandBuffer, 0, 1, &amp;ow_viewport);\n    vkCmdSetScissor(commandBuffer, 0, 1, &amp;ow_scissor);\n\n    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, openwarp_pipeline_);\n    vkCmdBindVertexBuffers(commandBuffer, 0, 1, &amp;ow_vertex_buffer_, &amp;offsets);\n    vkCmdPushConstants(commandBuffer, ow_pipeline_layout_, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(uint32_t), &amp;eye);\n    vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, ow_pipeline_layout_, 0, 1,\n                            &amp;ow_descriptor_sets_[!left][buffer_ind], 0, nullptr);\n    vkCmdBindIndexBuffer(commandBuffer, ow_index_buffer_, 0, VK_INDEX_TYPE_UINT32);\n    vkCmdDrawIndexed(commandBuffer, num_openwarp_indices_, 1, 0, 0, 0);\n    vkCmdEndRenderPass(commandBuffer);\n\n    // Then perform distortion correction to the framebuffer expected by Monado\n    VkClearValue clear_color;\n    clear_color.color = {0.0f, 0.0f, 0.0f, 1.0f};\n\n    VkRenderPassBeginInfo dc_render_pass_info{\n        .sType           = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n        .pNext           = nullptr,\n        .renderPass      = distortion_correction_render_pass_,\n        .framebuffer     = framebuffer,\n        .renderArea      = {.offset = {.x = left ? 0 : static_cast&lt;int32_t&gt;(swapchain_width_ / 2), .y = 0},\n                            .extent = {.width  = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2),\n                                       .height = static_cast&lt;uint32_t&gt;(swapchain_height_)}},\n        .clearValueCount = 1,\n        .pClearValues    = &amp;clear_color};\n\n    VkViewport dc_viewport{.x        = left ? 0.f : static_cast&lt;float&gt;(swapchain_width_) / 2.f,\n                           .y        = 0,\n                           .width    = static_cast&lt;float&gt;(swapchain_width_) / 2.f,\n                           .height   = static_cast&lt;float&gt;(swapchain_height_),\n                           .minDepth = 0.0f,\n                           .maxDepth = 1.0f};\n\n    VkRect2D dc_scissor{\n        .offset = {.x = left ? 0 : static_cast&lt;int32_t&gt;(swapchain_width_ / 2), .y = 0},\n        .extent = {.width = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2), .height = static_cast&lt;uint32_t&gt;(swapchain_height_)}};\n\n    vkCmdBeginRenderPass(commandBuffer, &amp;dc_render_pass_info, VK_SUBPASS_CONTENTS_INLINE);\n    vkCmdSetViewport(commandBuffer, 0, 1, &amp;dc_viewport);\n    vkCmdSetScissor(commandBuffer, 0, 1, &amp;dc_scissor);\n\n    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_);\n    vkCmdBindVertexBuffers(commandBuffer, 0, 1, &amp;dc_vertex_buffer_, &amp;offsets);\n    vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, dp_pipeline_layout_, 0, 1,\n                            &amp;dp_descriptor_sets_[!left][0], 0, nullptr);\n    vkCmdBindIndexBuffer(commandBuffer, dc_index_buffer_, 0, VK_INDEX_TYPE_UINT32);\n    vkCmdDrawIndexed(commandBuffer, num_distortion_indices_, 1, 0, static_cast&lt;int&gt;(num_distortion_vertices_ * !left), 0);\n    vkCmdEndRenderPass(commandBuffer);\n}\n\nbool openwarp_vk::is_external() {\n    return false;\n}\n\nvoid openwarp_vk::destroy() {\n    partial_destroy();\n    // drain deletion_queue_\n    while (!deletion_queue_.empty()) {\n        deletion_queue_.top()();\n        deletion_queue_.pop();\n    }\n}\n\nvoid openwarp_vk::create_offscreen_images() {\n    for (int eye = 0; eye &lt; 2; eye++) {\n        VkImageCreateInfo image_info{.sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,\n                                     .pNext                 = nullptr,\n                                     .flags                 = 0,\n                                     .imageType             = VK_IMAGE_TYPE_2D,\n                                     .format                = VK_FORMAT_R8G8B8A8_UNORM,\n                                     .extent                = {.width  = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2),\n                                                               .height = static_cast&lt;uint32_t&gt;(swapchain_height_),\n                                                               .depth  = 1},\n                                     .mipLevels             = 1,\n                                     .arrayLayers           = 1,\n                                     .samples               = VK_SAMPLE_COUNT_1_BIT,\n                                     .tiling                = VK_IMAGE_TILING_OPTIMAL,\n                                     .usage                 = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,\n                                     .sharingMode           = {},\n                                     .queueFamilyIndexCount = 0,\n                                     .pQueueFamilyIndices   = nullptr,\n                                     .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED};\n\n        VmaAllocationCreateInfo create_info = {.flags          = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT,\n                                               .usage          = VMA_MEMORY_USAGE_AUTO,\n                                               .requiredFlags  = {},\n                                               .preferredFlags = {},\n                                               .memoryTypeBits = {},\n                                               .pool           = {},\n                                               .pUserData      = nullptr,\n                                               .priority       = 1.0f};\n\n        VK_ASSERT_SUCCESS(vmaCreateImage(vma_allocator_, &amp;image_info, &amp;create_info, &amp;offscreen_images_[eye],\n                                         &amp;offscreen_image_allocs_[eye], nullptr));\n\n        VkImageViewCreateInfo view_info = {.sType            = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,\n                                           .pNext            = nullptr,\n                                           .flags            = {},\n                                           .image            = offscreen_images_[eye],\n                                           .viewType         = VK_IMAGE_VIEW_TYPE_2D,\n                                           .format           = VK_FORMAT_R8G8B8A8_UNORM,\n                                           .components       = {.r = VK_COMPONENT_SWIZZLE_IDENTITY,\n                                                                .g = VK_COMPONENT_SWIZZLE_IDENTITY,\n                                                                .b = VK_COMPONENT_SWIZZLE_IDENTITY,\n                                                                .a = VK_COMPONENT_SWIZZLE_IDENTITY},\n                                           .subresourceRange = {.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT,\n                                                                .baseMipLevel   = 0,\n                                                                .levelCount     = 1,\n                                                                .baseArrayLayer = 0,\n                                                                .layerCount     = 1}};\n\n        VK_ASSERT_SUCCESS(vkCreateImageView(display_provider_-&gt;vk_device_, &amp;view_info, nullptr, &amp;offscreen_image_views_[eye]));\n\n        VkImageCreateInfo depth_image_info{\n            .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,\n            .pNext                 = nullptr,\n            .flags                 = {},\n            .imageType             = VK_IMAGE_TYPE_2D,\n            .format                = VK_FORMAT_D16_UNORM,\n            .extent                = {.width  = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2),\n                                      .height = static_cast&lt;uint32_t&gt;(swapchain_height_),\n                                      .depth  = 1},\n            .mipLevels             = 1,\n            .arrayLayers           = 1,\n            .samples               = VK_SAMPLE_COUNT_1_BIT,\n            .tiling                = VK_IMAGE_TILING_OPTIMAL,\n            .usage                 = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,\n            .sharingMode           = {},\n            .queueFamilyIndexCount = 0,\n            .pQueueFamilyIndices   = nullptr,\n            .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED,\n        };\n\n        VmaAllocationCreateInfo depth_create_info = {.flags          = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT,\n                                                     .usage          = VMA_MEMORY_USAGE_AUTO,\n                                                     .requiredFlags  = {},\n                                                     .preferredFlags = {},\n                                                     .memoryTypeBits = 0,\n                                                     .pool           = {},\n                                                     .pUserData      = nullptr,\n                                                     .priority       = 1.0f};\n\n        VK_ASSERT_SUCCESS(vmaCreateImage(vma_allocator_, &amp;depth_image_info, &amp;depth_create_info, &amp;offscreen_depths_[eye],\n                                         &amp;offscreen_depth_allocs_[eye], nullptr));\n\n        VkImageViewCreateInfo depth_view_info = {.sType            = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,\n                                                 .pNext            = nullptr,\n                                                 .flags            = {},\n                                                 .image            = offscreen_depths_[eye],\n                                                 .viewType         = VK_IMAGE_VIEW_TYPE_2D,\n                                                 .format           = VK_FORMAT_D16_UNORM,\n                                                 .components       = {.r = VK_COMPONENT_SWIZZLE_IDENTITY,\n                                                                      .g = VK_COMPONENT_SWIZZLE_IDENTITY,\n                                                                      .b = VK_COMPONENT_SWIZZLE_IDENTITY,\n                                                                      .a = VK_COMPONENT_SWIZZLE_IDENTITY},\n                                                 .subresourceRange = {.aspectMask     = VK_IMAGE_ASPECT_DEPTH_BIT,\n                                                                      .baseMipLevel   = 0,\n                                                                      .levelCount     = 1,\n                                                                      .baseArrayLayer = 0,\n                                                                      .layerCount     = 1}};\n\n        VK_ASSERT_SUCCESS(\n            vkCreateImageView(display_provider_-&gt;vk_device_, &amp;depth_view_info, nullptr, &amp;offscreen_depth_views_[eye]));\n\n        VkImageView attachments[2] = {offscreen_image_views_[eye], offscreen_depth_views_[eye]};\n\n        // Need a framebuffer to render to\n        VkFramebufferCreateInfo framebuffer_info = {\n            .sType           = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,\n            .pNext           = nullptr,\n            .flags           = 0,\n            .renderPass      = openwarp_render_pass_,\n            .attachmentCount = 2,\n            .pAttachments    = attachments,\n            .width           = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2),\n            .height          = static_cast&lt;uint32_t&gt;(swapchain_height_),\n            .layers          = 1,\n        };\n\n        VK_ASSERT_SUCCESS(\n            vkCreateFramebuffer(display_provider_-&gt;vk_device_, &amp;framebuffer_info, nullptr, &amp;offscreen_framebuffers_[eye]));\n    }\n}\n\nvoid openwarp_vk::create_vertex_buffers() {\n    // OpenWarp Vertices\n    VkBufferCreateInfo ow_staging_buffer_info = {.sType                 = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                                 .pNext                 = nullptr,\n                                                 .flags                 = {},\n                                                 .size                  = sizeof(OpenWarpVertex) * num_openwarp_vertices_,\n                                                 .usage                 = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,\n                                                 .sharingMode           = {},\n                                                 .queueFamilyIndexCount = 0,\n                                                 .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo ow_staging_alloc_info = {};\n    ow_staging_alloc_info.usage                   = VMA_MEMORY_USAGE_AUTO;\n    ow_staging_alloc_info.flags                   = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n\n    VkBuffer      ow_staging_buffer;\n    VmaAllocation ow_staging_alloc;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;ow_staging_buffer_info, &amp;ow_staging_alloc_info, &amp;ow_staging_buffer,\n                                      &amp;ow_staging_alloc, nullptr))\n\n    VkBufferCreateInfo ow_buffer_info = {.sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                         .pNext       = nullptr,\n                                         .flags       = {},\n                                         .size        = sizeof(OpenWarpVertex) * num_openwarp_vertices_,\n                                         .usage       = VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,\n                                         .sharingMode = {},\n                                         .queueFamilyIndexCount = 0,\n                                         .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo ow_alloc_info = {};\n    ow_alloc_info.usage                   = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VK_ASSERT_SUCCESS(\n        vmaCreateBuffer(vma_allocator_, &amp;ow_buffer_info, &amp;ow_alloc_info, &amp;ow_vertex_buffer_, &amp;ow_vertex_alloc_, nullptr))\n\n    void* ow_mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, ow_staging_alloc, &amp;ow_mapped_data))\n    memcpy(ow_mapped_data, openwarp_vertices_.data(), sizeof(OpenWarpVertex) * num_openwarp_vertices_);\n    vmaUnmapMemory(vma_allocator_, ow_staging_alloc);\n\n    VkCommandBuffer ow_command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    ow_copy_region          = {};\n    ow_copy_region.size                     = sizeof(OpenWarpVertex) * num_openwarp_vertices_;\n    vkCmdCopyBuffer(ow_command_buffer_local, ow_staging_buffer, ow_vertex_buffer_, 1, &amp;ow_copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], ow_command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, ow_staging_buffer, ow_staging_alloc);\n\n    // Distortion Correction Vertices\n    VkBufferCreateInfo dc_staging_buffer_info = {.sType                 = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                                 .pNext                 = nullptr,\n                                                 .flags                 = {},\n                                                 .size                  = sizeof(OpenWarpVertex) * num_openwarp_vertices_,\n                                                 .usage                 = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,\n                                                 .sharingMode           = {},\n                                                 .queueFamilyIndexCount = 0,\n                                                 .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo dc_staging_alloc_info = {};\n    dc_staging_alloc_info.usage                   = VMA_MEMORY_USAGE_AUTO;\n    dc_staging_alloc_info.flags                   = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n\n    VkBuffer      dc_staging_buffer;\n    VmaAllocation dc_staging_alloc;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;dc_staging_buffer_info, &amp;dc_staging_alloc_info, &amp;dc_staging_buffer,\n                                      &amp;dc_staging_alloc, nullptr))\n\n    VkBufferCreateInfo dc_buffer_info = {.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                         .pNext = nullptr,\n                                         .flags = {},\n                                         .size  = sizeof(DistortionCorrectionVertex) * num_distortion_vertices_ * HMD::NUM_EYES,\n                                         .usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,\n                                         .sharingMode           = {},\n                                         .queueFamilyIndexCount = 0,\n                                         .pQueueFamilyIndices   = nullptr};\n    dc_buffer_info.size               = sizeof(DistortionCorrectionVertex) * num_distortion_vertices_ * HMD::NUM_EYES;\n\n    VmaAllocationCreateInfo dc_alloc_info = {};\n    dc_alloc_info.usage                   = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VK_ASSERT_SUCCESS(\n        vmaCreateBuffer(vma_allocator_, &amp;dc_buffer_info, &amp;dc_alloc_info, &amp;dc_vertex_buffer_, &amp;dc_vertex_alloc_, nullptr))\n\n    void* dc_mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, dc_staging_alloc, &amp;dc_mapped_data))\n    memcpy(dc_mapped_data, distortion_vertices_.data(),\n           sizeof(DistortionCorrectionVertex) * num_distortion_vertices_ * HMD::NUM_EYES);\n    vmaUnmapMemory(vma_allocator_, dc_staging_alloc);\n\n    VkCommandBuffer dc_command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    dc_copy_region          = {};\n    dc_copy_region.size                     = sizeof(DistortionCorrectionVertex) * num_distortion_vertices_ * HMD::NUM_EYES;\n    vkCmdCopyBuffer(dc_command_buffer_local, dc_staging_buffer, dc_vertex_buffer_, 1, &amp;dc_copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], dc_command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, dc_staging_buffer, dc_staging_alloc);\n}\n\nvoid openwarp_vk::create_index_buffers() {\n    // OpenWarp index buffer\n    VkBufferCreateInfo ow_staging_buffer_info = {.sType                 = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                                 .pNext                 = nullptr,\n                                                 .flags                 = {},\n                                                 .size                  = sizeof(uint32_t) * num_openwarp_indices_,\n                                                 .usage                 = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,\n                                                 .sharingMode           = {},\n                                                 .queueFamilyIndexCount = 0,\n                                                 .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo ow_staging_alloc_info = {};\n    ow_staging_alloc_info.usage                   = VMA_MEMORY_USAGE_AUTO;\n    ow_staging_alloc_info.flags                   = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n\n    VkBuffer      ow_staging_buffer;\n    VmaAllocation ow_staging_alloc;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;ow_staging_buffer_info, &amp;ow_staging_alloc_info, &amp;ow_staging_buffer,\n                                      &amp;ow_staging_alloc, nullptr))\n\n    VkBufferCreateInfo ow_buffer_info = {.sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                         .pNext       = nullptr,\n                                         .flags       = {},\n                                         .size        = sizeof(uint32_t) * num_openwarp_indices_,\n                                         .usage       = VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,\n                                         .sharingMode = {},\n                                         .queueFamilyIndexCount = 0,\n                                         .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo ow_alloc_info = {};\n    ow_alloc_info.usage                   = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VK_ASSERT_SUCCESS(\n        vmaCreateBuffer(vma_allocator_, &amp;ow_buffer_info, &amp;ow_alloc_info, &amp;ow_index_buffer_, &amp;ow_index_alloc_, nullptr))\n\n    void* ow_mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, ow_staging_alloc, &amp;ow_mapped_data))\n    memcpy(ow_mapped_data, openwarp_indices_.data(), sizeof(uint32_t) * num_openwarp_indices_);\n    vmaUnmapMemory(vma_allocator_, ow_staging_alloc);\n\n    VkCommandBuffer ow_command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    ow_copy_region          = {};\n    ow_copy_region.size                     = sizeof(uint32_t) * num_openwarp_indices_;\n    vkCmdCopyBuffer(ow_command_buffer_local, ow_staging_buffer, ow_index_buffer_, 1, &amp;ow_copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], ow_command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, ow_staging_buffer, ow_staging_alloc);\n\n    // Distortion correction index buffer\n    VkBufferCreateInfo dc_staging_buffer_info = {.sType                 = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                                 .pNext                 = nullptr,\n                                                 .flags                 = {},\n                                                 .size                  = sizeof(uint32_t) * num_distortion_indices_,\n                                                 .usage                 = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,\n                                                 .sharingMode           = {},\n                                                 .queueFamilyIndexCount = 0,\n                                                 .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo dc_staging_alloc_info = {};\n    dc_staging_alloc_info.usage                   = VMA_MEMORY_USAGE_AUTO;\n    dc_staging_alloc_info.flags                   = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n\n    VkBuffer      dc_staging_buffer;\n    VmaAllocation dc_staging_alloc;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;dc_staging_buffer_info, &amp;dc_staging_alloc_info, &amp;dc_staging_buffer,\n                                      &amp;dc_staging_alloc, nullptr))\n\n    VkBufferCreateInfo dc_buffer_info = {.sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                         .pNext       = nullptr,\n                                         .flags       = {},\n                                         .size        = sizeof(uint32_t) * num_distortion_indices_,\n                                         .usage       = VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,\n                                         .sharingMode = {},\n                                         .queueFamilyIndexCount = 0,\n                                         .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo dc_alloc_info = {};\n    dc_alloc_info.usage                   = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VK_ASSERT_SUCCESS(\n        vmaCreateBuffer(vma_allocator_, &amp;dc_buffer_info, &amp;dc_alloc_info, &amp;dc_index_buffer_, &amp;dc_index_alloc_, nullptr))\n\n    void* dc_mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, dc_staging_alloc, &amp;dc_mapped_data))\n    memcpy(dc_mapped_data, distortion_indices_.data(), sizeof(uint32_t) * num_distortion_indices_);\n    vmaUnmapMemory(vma_allocator_, dc_staging_alloc);\n\n    VkCommandBuffer dc_command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    dc_copy_region          = {};\n    dc_copy_region.size                     = sizeof(uint32_t) * num_distortion_indices_;\n    vkCmdCopyBuffer(dc_command_buffer_local, dc_staging_buffer, dc_index_buffer_, 1, &amp;dc_copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], dc_command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, dc_staging_buffer, dc_staging_alloc);\n}\n\nvoid openwarp_vk::generate_distortion_data() {\n    // Calculate the number of vertices+ineye_tiles_high distortion mesh.\n    num_distortion_vertices_ = (hmd_info_.eye_tiles_high + 1) * (hmd_info_.eye_tiles_wide + 1);\n    num_distortion_indices_  = hmd_info_.eye_tiles_high * hmd_info_.eye_tiles_wide * 6;\n\n    // Allocate memory for the elements/indices array.\n    distortion_indices_.resize(num_distortion_indices_);\n\n    // This is just a simple grid/plane index array, nothing fancy.\n    // Same for both eye distortions, too!\n    for (int y = 0; y &lt; hmd_info_.eye_tiles_high; y++) {\n        for (int x = 0; x &lt; hmd_info_.eye_tiles_wide; x++) {\n            const int offset = (y * hmd_info_.eye_tiles_wide + x) * 6;\n\n            distortion_indices_[offset + 0] = ((y + 0) * (hmd_info_.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 1] = ((y + 1) * (hmd_info_.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 2] = ((y + 0) * (hmd_info_.eye_tiles_wide + 1) + (x + 1));\n\n            distortion_indices_[offset + 3] = ((y + 0) * (hmd_info_.eye_tiles_wide + 1) + (x + 1));\n            distortion_indices_[offset + 4] = ((y + 1) * (hmd_info_.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 5] = ((y + 1) * (hmd_info_.eye_tiles_wide + 1) + (x + 1));\n        }\n    }\n\n    // There are `num_distortion_vertices_` distortion coordinates for each color channel (3) of each eye (2).\n    // These are NOT the coordinates of the distorted vertices. They are *coefficients* that will be used to\n    // offset the UV coordinates of the distortion mesh.\n    std::array&lt;std::array&lt;std::vector&lt;HMD::mesh_coord2d_t&gt;, HMD::NUM_COLOR_CHANNELS&gt;, HMD::NUM_EYES&gt; distort_coords;\n    for (auto&amp; eye_coords : distort_coords) {\n        for (auto&amp; channel_coords : eye_coords) {\n            channel_coords.resize(num_distortion_vertices_);\n        }\n    }\n    HMD::build_distortion_meshes(distort_coords, hmd_info_);\n\n    // Allocate memory for position and UV CPU buffers.\n    const std::size_t num_elems_pos_uv = HMD::NUM_EYES * num_distortion_vertices_;\n    distortion_vertices_.resize(num_elems_pos_uv);\n\n    // Construct perspective projection matrices\n    for (int eye = 0; eye &lt; 2; eye++) {\n        if (!offloaded_rendering_) {\n            if (!using_godot_) {\n                math_util::unreal_projection(&amp;basic_projection_[eye], index_params::fov_left[eye], index_params::fov_right[eye],\n                                             index_params::fov_up[eye], index_params::fov_down[eye]);\n            } else {\n                math_util::godot_projection(&amp;basic_projection_[eye], index_params::fov_left[eye], index_params::fov_right[eye],\n                                            index_params::fov_up[eye], index_params::fov_down[eye]);\n            }\n\n            inverse_projection_[eye] = basic_projection_[eye].inverse();\n        } else {\n            float scale = 1.0f;\n            if (switchboard_-&gt;get_env_char(\"ILLIXR_OVERSCAN\") != nullptr) {\n                scale = std::stof(switchboard_-&gt;get_env_char(\"ILLIXR_OVERSCAN\"));\n            }\n            float fov_left  = scale * server_params::fov_left[eye];\n            float fov_right = scale * server_params::fov_right[eye];\n            float fov_up    = scale * server_params::fov_up[eye];\n            float fov_down  = scale * server_params::fov_down[eye];\n\n            // The server can render at a larger FoV, so the inverse should account for that.\n            // The FOVs provided to the server should match the ones provided to Monado.\n            Eigen::Matrix4f server_fov;\n            if (!using_godot_) {\n                math_util::unreal_projection(&amp;server_fov, fov_left, fov_right, fov_up, fov_down);\n            } else {\n                math_util::godot_projection(&amp;server_fov, fov_left, fov_right, fov_up, fov_down);\n            }\n\n            inverse_projection_[eye] = server_fov.inverse();\n        }\n    }\n\n    for (int eye = 0; eye &lt; HMD::NUM_EYES; eye++) {\n        Eigen::Matrix4f distortion_matrix = calculate_distortion_transform(basic_projection_[eye]);\n        for (int y = 0; y &lt;= hmd_info_.eye_tiles_high; y++) {\n            for (int x = 0; x &lt;= hmd_info_.eye_tiles_wide; x++) {\n                const int index = y * (hmd_info_.eye_tiles_wide + 1) + x;\n\n                // Set the physical distortion mesh coordinates. These are rectangular/gridlike, not distorted.\n                // The distortion is handled by the UVs, not the actual mesh coordinates!\n                distortion_vertices_[eye * num_distortion_vertices_ + index].pos.x =\n                    (-1.0f + 2 * (static_cast&lt;float&gt;(x) / static_cast&lt;float&gt;(hmd_info_.eye_tiles_wide)));\n\n                distortion_vertices_[eye * num_distortion_vertices_ + index].pos.y = (input_texture_external_ ? 1.0f : -1.0f) *\n                    (-1.0f +\n                     2.0f * (static_cast&lt;float&gt;(hmd_info_.eye_tiles_high - y) / static_cast&lt;float&gt;(hmd_info_.eye_tiles_high)) *\n                         (static_cast&lt;float&gt;(hmd_info_.eye_tiles_high * hmd_info_.tile_pixels_high) /\n                          static_cast&lt;float&gt;(hmd_info_.display_pixels_high)));\n\n                distortion_vertices_[eye * num_distortion_vertices_ + index].pos.z = 0.0f;\n\n                // Use the previously-calculated distort_coords to set the UVs on the distortion mesh\n                Eigen::Vector4f vertex_uv0(distort_coords[eye][0][index].x, distort_coords[eye][0][index].y, -1, 1);\n                Eigen::Vector4f vertex_uv1(distort_coords[eye][1][index].x, distort_coords[eye][1][index].y, -1, 1);\n                Eigen::Vector4f vertex_uv2(distort_coords[eye][2][index].x, distort_coords[eye][2][index].y, -1, 1);\n\n                Eigen::Vector4f uv0 = distortion_matrix * vertex_uv0;\n                Eigen::Vector4f uv1 = distortion_matrix * vertex_uv1;\n                Eigen::Vector4f uv2 = distortion_matrix * vertex_uv2;\n\n                float factor0 = 1.0f / std::max(uv0.z(), 0.00001f);\n                float factor1 = 1.0f / std::max(uv1.z(), 0.00001f);\n                float factor2 = 1.0f / std::max(uv2.z(), 0.00001f);\n\n                distortion_vertices_[eye * num_distortion_vertices_ + index].uv0.x = uv0.x() * factor0;\n                distortion_vertices_[eye * num_distortion_vertices_ + index].uv0.y = uv0.y() * factor0;\n                distortion_vertices_[eye * num_distortion_vertices_ + index].uv1.x = uv1.x() * factor1;\n                distortion_vertices_[eye * num_distortion_vertices_ + index].uv1.y = uv1.y() * factor1;\n                distortion_vertices_[eye * num_distortion_vertices_ + index].uv2.x = uv2.x() * factor2;\n                distortion_vertices_[eye * num_distortion_vertices_ + index].uv2.y = uv2.y() * factor2;\n            }\n        }\n    }\n}\n\nvoid openwarp_vk::generate_openwarp_mesh(size_t width, size_t height) {\n    spdlog::get(\"illixr\")-&gt;info(\"[openwarp] Generating reprojection mesh with resolution ({}, {})\", width, height);\n\n    // width and height are not in # of verts, but in # of faces.\n    num_openwarp_indices_  = 2 * 3 * width * height;\n    num_openwarp_vertices_ = (width + 1) * (height + 1);\n\n    // Size the vectors accordingly\n    openwarp_indices_.resize(num_openwarp_indices_);\n    openwarp_vertices_.resize(num_openwarp_vertices_);\n\n    // Build indices.\n    for (size_t y = 0; y &lt; height; y++) {\n        for (size_t x = 0; x &lt; width; x++) {\n            const size_t offset = (y * width + x) * 6;\n\n            openwarp_indices_[offset + 0] = (GLuint) ((y + 0) * (width + 1) + (x + 0));\n            openwarp_indices_[offset + 1] = (GLuint) ((y + 1) * (width + 1) + (x + 0));\n            openwarp_indices_[offset + 2] = (GLuint) ((y + 0) * (width + 1) + (x + 1));\n\n            openwarp_indices_[offset + 3] = (GLuint) ((y + 0) * (width + 1) + (x + 1));\n            openwarp_indices_[offset + 4] = (GLuint) ((y + 1) * (width + 1) + (x + 0));\n            openwarp_indices_[offset + 5] = (GLuint) ((y + 1) * (width + 1) + (x + 1));\n        }\n    }\n\n    // Build vertices\n    for (size_t y = 0; y &lt; height + 1; y++) {\n        for (size_t x = 0; x &lt; width + 1; x++) {\n            size_t index = y * (width + 1) + x;\n\n            openwarp_vertices_[index].uv.x = static_cast&lt;float&gt;(x) / static_cast&lt;float&gt;(width);\n            openwarp_vertices_[index].uv.y = (static_cast&lt;float&gt;(height) - static_cast&lt;float&gt;(y)) / static_cast&lt;float&gt;(height);\n\n            if (x == 0) {\n                openwarp_vertices_[index].uv.x = -0.5f;\n            }\n            if (x == width) {\n                openwarp_vertices_[index].uv.x = 1.5f;\n            }\n\n            if (y == 0) {\n                openwarp_vertices_[index].uv.y = 1.5f;\n            }\n            if (y == height) {\n                openwarp_vertices_[index].uv.y = -0.5f;\n            }\n        }\n    }\n}\n\nvoid openwarp_vk::create_texture_sampler() {\n    VkSamplerCreateInfo sampler_info = {.sType     = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,\n                                        .pNext     = nullptr,\n                                        .flags     = {},\n                                        .magFilter = VK_FILTER_LINEAR, // how to interpolate texels that are magnified on screen\n                                        .minFilter = VK_FILTER_LINEAR,\n                                        .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR,\n\n                                        .addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,\n                                        .addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,\n                                        .addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,\n\n                                        .mipLodBias       = 0.f,\n                                        .anisotropyEnable = VK_FALSE,\n                                        .maxAnisotropy    = 0.f,\n                                        .compareEnable    = VK_FALSE,\n                                        .compareOp        = VK_COMPARE_OP_ALWAYS,\n                                        .minLod           = 0.f,\n                                        .maxLod           = 0.f,\n                                        .borderColor      = VK_BORDER_COLOR_INT_OPAQUE_BLACK, // black outside the texture\n                                        .unnormalizedCoordinates = VK_FALSE};\n\n    VK_ASSERT_SUCCESS(vkCreateSampler(display_provider_-&gt;vk_device_, &amp;sampler_info, nullptr, &amp;fb_sampler_))\n    deletion_queue_.emplace([=]() {\n        vkDestroySampler(display_provider_-&gt;vk_device_, fb_sampler_, nullptr);\n    });\n}\n\nvoid openwarp_vk::create_descriptor_set_layouts() {\n    // OpenWarp descriptor set\n    VkDescriptorSetLayoutBinding image_layout_binding = {.binding            = 0,\n                                                         .descriptorType     = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n                                                         .descriptorCount    = 1,\n                                                         .stageFlags         = VK_SHADER_STAGE_FRAGMENT_BIT,\n                                                         .pImmutableSamplers = nullptr};\n\n    VkDescriptorSetLayoutBinding depth_layout_binding = {.binding         = 1,\n                                                         .descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n                                                         .descriptorCount = 1,\n                                                         .stageFlags =\n                                                             VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,\n                                                         // .stageFlags                   = VK_SHADER_STAGE_VERTEX_BIT;\n                                                         .pImmutableSamplers = nullptr};\n\n    VkDescriptorSetLayoutBinding matrix_ubo_layout_binding = {.binding            = 2,\n                                                              .descriptorType     = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,\n                                                              .descriptorCount    = 1,\n                                                              .stageFlags         = VK_SHADER_STAGE_VERTEX_BIT,\n                                                              .pImmutableSamplers = nullptr};\n\n    std::array&lt;VkDescriptorSetLayoutBinding, 3&gt; ow_bindings    = {image_layout_binding, depth_layout_binding,\n                                                                  matrix_ubo_layout_binding};\n    VkDescriptorSetLayoutCreateInfo             ow_layout_info = {\n                    .sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,\n                    .pNext        = nullptr,\n                    .flags        = {},\n                    .bindingCount = static_cast&lt;uint32_t&gt;(ow_bindings.size()),\n                    .pBindings    = ow_bindings.data() // array of VkDescriptorSetLayoutBinding structs\n    };\n\n    VK_ASSERT_SUCCESS(\n        vkCreateDescriptorSetLayout(display_provider_-&gt;vk_device_, &amp;ow_layout_info, nullptr, &amp;ow_descriptor_set_layout_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyDescriptorSetLayout(display_provider_-&gt;vk_device_, ow_descriptor_set_layout_, nullptr);\n    });\n\n    // Distortion correction descriptor set\n    VkDescriptorSetLayoutBinding offscreen_image_layout_binding = {\n        .binding            = 0, // binding number in the shader\n        .descriptorType     = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n        .descriptorCount    = 1,\n        .stageFlags         = VK_SHADER_STAGE_FRAGMENT_BIT, // shader stages that can access the descriptor\n        .pImmutableSamplers = nullptr};\n\n    std::array&lt;VkDescriptorSetLayoutBinding, 1&gt; dc_bindings    = {offscreen_image_layout_binding};\n    VkDescriptorSetLayoutCreateInfo             dc_layout_info = {\n                    .sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,\n                    .pNext        = nullptr,\n                    .flags        = {},\n                    .bindingCount = static_cast&lt;uint32_t&gt;(dc_bindings.size()),\n                    .pBindings    = dc_bindings.data() // array of VkDescriptorSetLayoutBinding structs\n    };\n    VK_ASSERT_SUCCESS(\n        vkCreateDescriptorSetLayout(display_provider_-&gt;vk_device_, &amp;dc_layout_info, nullptr, &amp;dp_descriptor_set_layout_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyDescriptorSetLayout(display_provider_-&gt;vk_device_, dp_descriptor_set_layout_, nullptr);\n    });\n}\n\nvoid openwarp_vk::create_uniform_buffers() {\n    // Matrix data\n    VkBufferCreateInfo matrix_buffer_info = {.sType                 = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n                                             .pNext                 = nullptr,\n                                             .flags                 = {},\n                                             .size                  = sizeof(WarpMatrices),\n                                             .usage                 = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,\n                                             .sharingMode           = {},\n                                             .queueFamilyIndexCount = 0,\n                                             .pQueueFamilyIndices   = nullptr};\n\n    VmaAllocationCreateInfo createInfo = {};\n    createInfo.usage                   = VMA_MEMORY_USAGE_AUTO;\n    createInfo.flags         = VMA_ALLOCATION_CREATE_MAPPED_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n    createInfo.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;\n\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;matrix_buffer_info, &amp;createInfo, &amp;ow_matrices_uniform_buffer_,\n                                      &amp;ow_matrices_uniform_alloc_, &amp;ow_matrices_uniform_alloc_info_))\n    deletion_queue_.emplace([=]() {\n        vmaDestroyBuffer(vma_allocator_, ow_matrices_uniform_buffer_, ow_matrices_uniform_alloc_);\n    });\n}\n\nvoid openwarp_vk::create_descriptor_pool() {\n    std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes = {};\n    poolSizes[0].type                             = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;\n    poolSizes[0].descriptorCount                  = buffer_pool_-&gt;image_pool.size() * 2;\n    poolSizes[1].type                             = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n    poolSizes[1].descriptorCount                  = (2 * buffer_pool_-&gt;image_pool.size() + 1) * 2;\n\n    VkDescriptorPoolCreateInfo poolInfo = {.sType         = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,\n                                           .pNext         = nullptr,\n                                           .flags         = 0,\n                                           .maxSets       = 0,\n                                           .poolSizeCount = 0,\n                                           .pPoolSizes    = nullptr};\n    poolInfo.poolSizeCount              = static_cast&lt;uint32_t&gt;(poolSizes.size());\n    poolInfo.pPoolSizes                 = poolSizes.data();\n    poolInfo.maxSets                    = (buffer_pool_-&gt;image_pool.size() + 1) * 2;\n\n    VK_ASSERT_SUCCESS(vkCreateDescriptorPool(display_provider_-&gt;vk_device_, &amp;poolInfo, nullptr, &amp;descriptor_pool_))\n}\n\nvoid openwarp_vk::create_descriptor_sets() {\n    for (int eye = 0; eye &lt; 2; eye++) {\n        // OpenWarp descriptor sets\n        std::vector&lt;VkDescriptorSetLayout&gt; ow_layout = {buffer_pool_-&gt;image_pool.size(), ow_descriptor_set_layout_};\n        VkDescriptorSetAllocateInfo        ow_alloc_info{.sType              = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,\n                                                         .pNext              = nullptr,\n                                                         .descriptorPool     = descriptor_pool_,\n                                                         .descriptorSetCount = 0,\n                                                         .pSetLayouts        = ow_layout.data()};\n        ow_alloc_info.descriptorSetCount = buffer_pool_-&gt;image_pool.size();\n\n        ow_descriptor_sets_[eye].resize(buffer_pool_-&gt;image_pool.size());\n        VK_ASSERT_SUCCESS(\n            vkAllocateDescriptorSets(display_provider_-&gt;vk_device_, &amp;ow_alloc_info, ow_descriptor_sets_[eye].data()))\n\n        for (size_t image_idx = 0; image_idx &lt; buffer_pool_-&gt;image_pool.size(); image_idx++) {\n            VkDescriptorImageInfo image_info = {.sampler     = fb_sampler_,\n                                                .imageView   = buffer_pool_-&gt;image_pool[image_idx][eye].image_view,\n                                                .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL};\n\n            VkDescriptorImageInfo depth_info = {.sampler     = fb_sampler_,\n                                                .imageView   = buffer_pool_-&gt;depth_image_pool[image_idx][eye].image_view,\n                                                .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL};\n\n            VkDescriptorBufferInfo buffer_info = {\n                .buffer = ow_matrices_uniform_buffer_, .offset = 0, .range = sizeof(WarpMatrices)};\n\n            std::array&lt;VkWriteDescriptorSet, 3&gt; ow_descriptor_writes = {\n                VkWriteDescriptorSet{.sType            = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n                                     .pNext            = nullptr,\n                                     .dstSet           = ow_descriptor_sets_[eye][image_idx],\n                                     .dstBinding       = 0,\n                                     .dstArrayElement  = 0,\n                                     .descriptorCount  = 1,\n                                     .descriptorType   = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n                                     .pImageInfo       = &amp;image_info,\n                                     .pBufferInfo      = nullptr,\n                                     .pTexelBufferView = nullptr},\n                VkWriteDescriptorSet{.sType            = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n                                     .pNext            = nullptr,\n                                     .dstSet           = ow_descriptor_sets_[eye][image_idx],\n                                     .dstBinding       = 1,\n                                     .dstArrayElement  = 0,\n                                     .descriptorCount  = 1,\n                                     .descriptorType   = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n                                     .pImageInfo       = &amp;depth_info,\n                                     .pBufferInfo      = nullptr,\n                                     .pTexelBufferView = nullptr},\n                VkWriteDescriptorSet{.sType            = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n                                     .pNext            = nullptr,\n                                     .dstSet           = ow_descriptor_sets_[eye][image_idx],\n                                     .dstBinding       = 2,\n                                     .dstArrayElement  = 0,\n                                     .descriptorCount  = 1,\n                                     .descriptorType   = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,\n                                     .pImageInfo       = nullptr,\n                                     .pBufferInfo      = &amp;buffer_info,\n                                     .pTexelBufferView = nullptr}};\n\n            vkUpdateDescriptorSets(display_provider_-&gt;vk_device_, static_cast&lt;uint32_t&gt;(ow_descriptor_writes.size()),\n                                   ow_descriptor_writes.data(), 0, nullptr);\n        }\n\n        // Distortion correction descriptor sets\n        std::vector&lt;VkDescriptorSetLayout&gt; dc_layout     = {dp_descriptor_set_layout_};\n        VkDescriptorSetAllocateInfo        dc_alloc_info = {.sType          = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,\n                                                            .pNext          = nullptr,\n                                                            .descriptorPool = descriptor_pool_,\n                                                            .descriptorSetCount = 1,\n                                                            .pSetLayouts        = dc_layout.data()};\n\n        dp_descriptor_sets_[eye].resize(1);\n        VK_ASSERT_SUCCESS(\n            vkAllocateDescriptorSets(display_provider_-&gt;vk_device_, &amp;dc_alloc_info, dp_descriptor_sets_[eye].data()))\n\n        VkDescriptorImageInfo offscreen_image_info = {.sampler     = fb_sampler_,\n                                                      .imageView   = offscreen_image_views_[eye],\n                                                      .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL};\n\n        std::array&lt;VkWriteDescriptorSet, 1&gt; dc_descriptor_writes = {\n            VkWriteDescriptorSet{.sType            = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n                                 .pNext            = nullptr,\n                                 .dstSet           = dp_descriptor_sets_[eye][0],\n                                 .dstBinding       = 0,\n                                 .dstArrayElement  = 0,\n                                 .descriptorCount  = 1,\n                                 .descriptorType   = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n                                 .pImageInfo       = &amp;offscreen_image_info,\n                                 .pBufferInfo      = nullptr,\n                                 .pTexelBufferView = nullptr}};\n\n        vkUpdateDescriptorSets(display_provider_-&gt;vk_device_, static_cast&lt;uint32_t&gt;(dc_descriptor_writes.size()),\n                               dc_descriptor_writes.data(), 0, nullptr);\n    }\n}\n\nvoid openwarp_vk::create_openwarp_pipeline() {\n    // A renderpass also has to be created\n    VkAttachmentDescription color_attachment{.flags         = 0,\n                                             .format        = VK_FORMAT_R8G8B8A8_UNORM, // this should match the offscreen image\n                                             .samples       = VK_SAMPLE_COUNT_1_BIT,\n                                             .loadOp        = VK_ATTACHMENT_LOAD_OP_CLEAR,\n                                             .storeOp       = VK_ATTACHMENT_STORE_OP_STORE,\n                                             .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,\n                                             .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,\n                                             .initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED,\n                                             .finalLayout    = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL};\n\n    VkAttachmentReference color_attachment_ref{.attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};\n\n    VkAttachmentDescription depth_attachment{.flags          = 0,\n                                             .format         = VK_FORMAT_D16_UNORM, // this should match the offscreen image\n                                             .samples        = VK_SAMPLE_COUNT_1_BIT,\n                                             .loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR,\n                                             .storeOp        = VK_ATTACHMENT_STORE_OP_STORE,\n                                             .stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE,\n                                             .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,\n                                             .initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED,\n                                             .finalLayout    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL};\n\n    VkAttachmentReference depth_attachment_ref{.attachment = 1, .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL};\n\n    VkSubpassDescription subpass{.flags                   = 0,\n                                 .pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS,\n                                 .inputAttachmentCount    = 0,\n                                 .pInputAttachments       = nullptr,\n                                 .colorAttachmentCount    = 1,\n                                 .pColorAttachments       = &amp;color_attachment_ref,\n                                 .pResolveAttachments     = nullptr,\n                                 .pDepthStencilAttachment = &amp;depth_attachment_ref,\n                                 .preserveAttachmentCount = 0,\n                                 .pPreserveAttachments    = nullptr};\n\n    std::array&lt;VkAttachmentDescription, 2&gt; all_attachments = {color_attachment, depth_attachment};\n\n    VkSubpassDependency dependency{.srcSubpass      = 0,\n                                   .dstSubpass      = VK_SUBPASS_EXTERNAL,\n                                   .srcStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n                                   .dstStageMask    = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,\n                                   .srcAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,\n                                   .dstAccessMask   = VK_ACCESS_SHADER_READ_BIT,\n                                   .dependencyFlags = 0};\n\n    VkRenderPassCreateInfo render_pass_info{.sType           = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,\n                                            .pNext           = nullptr,\n                                            .flags           = 0,\n                                            .attachmentCount = static_cast&lt;uint32_t&gt;(all_attachments.size()),\n                                            .pAttachments    = all_attachments.data(),\n                                            .subpassCount    = 1,\n                                            .pSubpasses      = &amp;subpass,\n                                            .dependencyCount = 1,\n                                            .pDependencies   = &amp;dependency};\n\n    VK_ASSERT_SUCCESS(vkCreateRenderPass(display_provider_-&gt;vk_device_, &amp;render_pass_info, nullptr, &amp;openwarp_render_pass_));\n\n    if (openwarp_pipeline_ != VK_NULL_HANDLE) {\n        throw std::runtime_error(\"openwarp_vk::create_pipeline: pipeline already created\");\n    }\n\n    VkDevice device = display_provider_-&gt;vk_device_;\n\n    auto           folder = std::string(SHADER_FOLDER);\n    VkShaderModule vert   = vulkan::create_shader_module(device, vulkan::read_file(folder + \"/openwarp_mesh.vert.spv\"));\n    VkShaderModule frag   = vulkan::create_shader_module(device, vulkan::read_file(folder + \"/openwarp_mesh.frag.spv\"));\n\n    VkPipelineShaderStageCreateInfo vert_stage_info  = {.sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n                                                        .pNext  = nullptr,\n                                                        .flags  = {},\n                                                        .stage  = VK_SHADER_STAGE_VERTEX_BIT,\n                                                        .module = vert,\n                                                        .pName  = \"main\",\n                                                        .pSpecializationInfo = nullptr};\n    VkPipelineShaderStageCreateInfo frage_stage_info = {.sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n                                                        .pNext  = nullptr,\n                                                        .flags  = {},\n                                                        .stage  = VK_SHADER_STAGE_FRAGMENT_BIT,\n                                                        .module = frag,\n                                                        .pName  = \"main\",\n                                                        .pSpecializationInfo = nullptr};\n\n    VkPipelineShaderStageCreateInfo shader_stages[] = {vert_stage_info, frage_stage_info};\n\n    auto bindingDescription    = OpenWarpVertex::get_binding_description();\n    auto attributeDescriptions = OpenWarpVertex::get_attribute_descriptions();\n\n    VkPipelineVertexInputStateCreateInfo vertex_input_info = {\n        .sType                           = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,\n        .pNext                           = nullptr,\n        .flags                           = {},\n        .vertexBindingDescriptionCount   = 1,\n        .pVertexBindingDescriptions      = &amp;bindingDescription,\n        .vertexAttributeDescriptionCount = static_cast&lt;uint32_t&gt;(attributeDescriptions.size()),\n        .pVertexAttributeDescriptions    = attributeDescriptions.data()};\n    VkPipelineInputAssemblyStateCreateInfo input_assembly = {.sType =\n                                                                 VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,\n                                                             .pNext                  = nullptr,\n                                                             .flags                  = {},\n                                                             .topology               = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,\n                                                             .primitiveRestartEnable = {}};\n\n    VkPipelineRasterizationStateCreateInfo rasterizer = {.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,\n                                                         .pNext = nullptr,\n                                                         .flags = {},\n                                                         .depthClampEnable        = VK_FALSE,\n                                                         .rasterizerDiscardEnable = VK_FALSE,\n                                                         .polygonMode             = VK_POLYGON_MODE_FILL,\n                                                         .cullMode                = VK_CULL_MODE_BACK_BIT,\n                                                         .frontFace               = VK_FRONT_FACE_COUNTER_CLOCKWISE,\n                                                         .depthBiasEnable         = VK_FALSE,\n                                                         .depthBiasConstantFactor = 0.f,\n                                                         .depthBiasClamp          = 0.f,\n                                                         .depthBiasSlopeFactor    = 0.f,\n                                                         .lineWidth               = 1.0f};\n\n    // disable multisampling\n    VkPipelineMultisampleStateCreateInfo multisampling = {.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,\n                                                          .pNext = nullptr,\n                                                          .flags = {},\n                                                          .rasterizationSamples  = VK_SAMPLE_COUNT_1_BIT,\n                                                          .sampleShadingEnable   = VK_FALSE,\n                                                          .minSampleShading      = 0,\n                                                          .pSampleMask           = nullptr,\n                                                          .alphaToCoverageEnable = 0,\n                                                          .alphaToOneEnable      = 0};\n\n    VkPipelineColorBlendAttachmentState color_blend_attachment = {.blendEnable         = VK_FALSE,\n                                                                  .srcColorBlendFactor = {},\n                                                                  .dstColorBlendFactor = {},\n                                                                  .colorBlendOp        = {},\n                                                                  .srcAlphaBlendFactor = {},\n                                                                  .dstAlphaBlendFactor = {},\n                                                                  .alphaBlendOp        = {},\n                                                                  .colorWriteMask      = VK_COLOR_COMPONENT_R_BIT |\n                                                                      VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |\n                                                                      VK_COLOR_COMPONENT_A_BIT};\n\n    // disable blending\n    VkPipelineColorBlendStateCreateInfo color_blending = {.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,\n                                                          .pNext = nullptr,\n                                                          .flags = {},\n                                                          .logicOpEnable   = 0,\n                                                          .logicOp         = {},\n                                                          .attachmentCount = 1,\n                                                          .pAttachments    = &amp;color_blend_attachment,\n                                                          .blendConstants  = {}};\n\n    // enable depth testing\n    VkPipelineDepthStencilStateCreateInfo depth_stencil = {\n        .sType                 = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,\n        .pNext                 = nullptr,\n        .flags                 = {},\n        .depthTestEnable       = VK_TRUE,\n        .depthWriteEnable      = VK_TRUE,\n        .depthCompareOp        = rendering_params::reverse_z ? VK_COMPARE_OP_GREATER_OR_EQUAL : VK_COMPARE_OP_LESS_OR_EQUAL,\n        .depthBoundsTestEnable = VK_FALSE,\n        .stencilTestEnable     = VK_FALSE,\n        .front                 = {},\n        .back                  = {},\n        .minDepthBounds        = 0.0f,\n        .maxDepthBounds        = 1.0f};\n\n    // use dynamic state instead of a fixed viewport\n    std::vector&lt;VkDynamicState&gt; dynamic_states = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};\n\n    VkPipelineDynamicStateCreateInfo dynamic_state_create_info = {.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,\n                                                                  .pNext = nullptr,\n                                                                  .flags = {},\n                                                                  .dynamicStateCount =\n                                                                      static_cast&lt;uint32_t&gt;(dynamic_states.size()),\n                                                                  .pDynamicStates = dynamic_states.data()};\n\n    VkPipelineViewportStateCreateInfo viewport_state_create_info = {.sType =\n                                                                        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,\n                                                                    .pNext         = nullptr,\n                                                                    .flags         = {},\n                                                                    .viewportCount = 1,\n                                                                    .pViewports    = nullptr,\n                                                                    .scissorCount  = 1,\n                                                                    .pScissors     = nullptr};\n\n    VkPushConstantRange push_constant = {.stageFlags = VK_SHADER_STAGE_VERTEX_BIT, .offset = 0, .size = sizeof(uint32_t)};\n\n    VkPipelineLayoutCreateInfo pipeline_layout_info = {.sType                  = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,\n                                                       .pNext                  = nullptr,\n                                                       .flags                  = {},\n                                                       .setLayoutCount         = 1,\n                                                       .pSetLayouts            = &amp;ow_descriptor_set_layout_,\n                                                       .pushConstantRangeCount = 1,\n                                                       .pPushConstantRanges    = &amp;push_constant};\n\n    VK_ASSERT_SUCCESS(vkCreatePipelineLayout(device, &amp;pipeline_layout_info, nullptr, &amp;ow_pipeline_layout_))\n\n    VkGraphicsPipelineCreateInfo pipeline_info = {.sType               = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,\n                                                  .pNext               = nullptr,\n                                                  .flags               = {},\n                                                  .stageCount          = 2,\n                                                  .pStages             = shader_stages,\n                                                  .pVertexInputState   = &amp;vertex_input_info,\n                                                  .pInputAssemblyState = &amp;input_assembly,\n                                                  .pTessellationState  = {},\n                                                  .pViewportState      = &amp;viewport_state_create_info,\n                                                  .pRasterizationState = &amp;rasterizer,\n                                                  .pMultisampleState   = &amp;multisampling,\n                                                  .pDepthStencilState  = &amp;depth_stencil,\n                                                  .pColorBlendState    = &amp;color_blending,\n                                                  .pDynamicState       = &amp;dynamic_state_create_info,\n                                                  .layout              = ow_pipeline_layout_,\n                                                  .renderPass          = openwarp_render_pass_,\n                                                  .subpass             = 0,\n                                                  .basePipelineHandle  = {},\n                                                  .basePipelineIndex   = 0};\n    VK_ASSERT_SUCCESS(vkCreateGraphicsPipelines(display_provider_-&gt;vk_device_, VK_NULL_HANDLE, 1, &amp;pipeline_info, nullptr,\n                                                &amp;openwarp_pipeline_))\n\n    vkDestroyShaderModule(device, vert, nullptr);\n    vkDestroyShaderModule(device, frag, nullptr);\n}\n\nVkPipeline openwarp_vk::create_distortion_correction_pipeline(VkRenderPass render_pass, [[maybe_unused]] uint32_t subpass) {\n    if (pipeline_ != VK_NULL_HANDLE) {\n        throw std::runtime_error(\"openwarp_vk::create_distortion_correction_pipeline: pipeline already created\");\n    }\n\n    VkDevice device = display_provider_-&gt;vk_device_;\n\n    auto           folder = std::string(SHADER_FOLDER);\n    VkShaderModule vert   = vulkan::create_shader_module(device, vulkan::read_file(folder + \"/distortion_correction.vert.spv\"));\n    VkShaderModule frag   = vulkan::create_shader_module(device, vulkan::read_file(folder + \"/distortion_correction.frag.spv\"));\n\n    VkPipelineShaderStageCreateInfo vert_stage_info = {.sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n                                                       .pNext  = nullptr,\n                                                       .flags  = {},\n                                                       .stage  = VK_SHADER_STAGE_VERTEX_BIT,\n                                                       .module = vert,\n                                                       .pName  = \"main\",\n                                                       .pSpecializationInfo = nullptr};\n\n    VkPipelineShaderStageCreateInfo frage_stage_info = {.sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n                                                        .pNext  = nullptr,\n                                                        .flags  = {},\n                                                        .stage  = VK_SHADER_STAGE_FRAGMENT_BIT,\n                                                        .module = frag,\n                                                        .pName  = \"main\",\n                                                        .pSpecializationInfo = nullptr};\n\n    VkPipelineShaderStageCreateInfo shader_stages[] = {vert_stage_info, frage_stage_info};\n\n    auto bindingDescription    = DistortionCorrectionVertex::get_binding_description();\n    auto attributeDescriptions = DistortionCorrectionVertex::get_attribute_descriptions();\n\n    VkPipelineVertexInputStateCreateInfo vertex_input_info = {\n        .sType                           = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,\n        .pNext                           = nullptr,\n        .flags                           = {},\n        .vertexBindingDescriptionCount   = 1,\n        .pVertexBindingDescriptions      = &amp;bindingDescription,\n        .vertexAttributeDescriptionCount = static_cast&lt;uint32_t&gt;(attributeDescriptions.size()),\n        .pVertexAttributeDescriptions    = attributeDescriptions.data()};\n\n    VkPipelineInputAssemblyStateCreateInfo input_assembly = {.sType =\n                                                                 VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,\n                                                             .pNext                  = nullptr,\n                                                             .flags                  = {},\n                                                             .topology               = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,\n                                                             .primitiveRestartEnable = VK_FALSE};\n\n    VkPipelineRasterizationStateCreateInfo rasterizer = {.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,\n                                                         .pNext = nullptr,\n                                                         .flags = {},\n                                                         .depthClampEnable        = VK_FALSE,\n                                                         .rasterizerDiscardEnable = VK_FALSE,\n                                                         .polygonMode             = VK_POLYGON_MODE_FILL,\n                                                         .cullMode                = VK_CULL_MODE_NONE,\n                                                         .frontFace               = VK_FRONT_FACE_COUNTER_CLOCKWISE,\n                                                         .depthBiasEnable         = VK_FALSE,\n                                                         .depthBiasConstantFactor = 0.f,\n                                                         .depthBiasClamp          = 0.f,\n                                                         .depthBiasSlopeFactor    = 0.f,\n                                                         .lineWidth               = 1.0f};\n\n    // disable multisampling\n    VkPipelineMultisampleStateCreateInfo multisampling = {.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,\n                                                          .pNext = nullptr,\n                                                          .flags = {},\n                                                          .rasterizationSamples  = VK_SAMPLE_COUNT_1_BIT,\n                                                          .sampleShadingEnable   = VK_FALSE,\n                                                          .minSampleShading      = 0.f,\n                                                          .pSampleMask           = {},\n                                                          .alphaToCoverageEnable = VK_FALSE,\n                                                          .alphaToOneEnable      = VK_FALSE};\n\n    VkPipelineColorBlendAttachmentState color_blend_attachment = {.blendEnable         = VK_FALSE,\n                                                                  .srcColorBlendFactor = {},\n                                                                  .dstColorBlendFactor = {},\n                                                                  .colorBlendOp        = {},\n                                                                  .srcAlphaBlendFactor = {},\n                                                                  .dstAlphaBlendFactor = {},\n                                                                  .alphaBlendOp        = {},\n                                                                  .colorWriteMask      = VK_COLOR_COMPONENT_R_BIT |\n                                                                      VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |\n                                                                      VK_COLOR_COMPONENT_A_BIT};\n\n    // disable blending\n    VkPipelineColorBlendStateCreateInfo color_blending = {.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,\n                                                          .pNext = nullptr,\n                                                          .flags = {},\n                                                          .logicOpEnable   = VK_FALSE,\n                                                          .logicOp         = {},\n                                                          .attachmentCount = 1,\n                                                          .pAttachments    = &amp;color_blend_attachment,\n                                                          .blendConstants  = {}};\n\n    // use dynamic state instead of a fixed viewport\n    std::vector&lt;VkDynamicState&gt; dynamic_states = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};\n\n    VkPipelineDynamicStateCreateInfo dynamic_state_create_info = {.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,\n                                                                  .pNext = nullptr,\n                                                                  .flags = {},\n                                                                  .dynamicStateCount =\n                                                                      static_cast&lt;uint32_t&gt;(dynamic_states.size()),\n                                                                  .pDynamicStates = dynamic_states.data()};\n\n    VkPipelineViewportStateCreateInfo viewport_state_create_info = {.sType =\n                                                                        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,\n                                                                    .pNext         = nullptr,\n                                                                    .flags         = {},\n                                                                    .viewportCount = 1,\n                                                                    .pViewports    = nullptr,\n                                                                    .scissorCount  = 1,\n                                                                    .pScissors     = nullptr};\n\n    VkPipelineLayoutCreateInfo pipeline_layout_info = {.sType                  = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,\n                                                       .pNext                  = nullptr,\n                                                       .flags                  = {},\n                                                       .setLayoutCount         = 1,\n                                                       .pSetLayouts            = &amp;dp_descriptor_set_layout_,\n                                                       .pushConstantRangeCount = 0,\n                                                       .pPushConstantRanges    = nullptr};\n\n    VK_ASSERT_SUCCESS(vkCreatePipelineLayout(device, &amp;pipeline_layout_info, nullptr, &amp;dp_pipeline_layout_))\n\n    VkGraphicsPipelineCreateInfo pipeline_info = {.sType               = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,\n                                                  .pNext               = nullptr,\n                                                  .flags               = {},\n                                                  .stageCount          = 2,\n                                                  .pStages             = shader_stages,\n                                                  .pVertexInputState   = &amp;vertex_input_info,\n                                                  .pInputAssemblyState = &amp;input_assembly,\n                                                  .pTessellationState  = {},\n                                                  .pViewportState      = &amp;viewport_state_create_info,\n                                                  .pRasterizationState = &amp;rasterizer,\n                                                  .pMultisampleState   = &amp;multisampling,\n                                                  .pDepthStencilState  = nullptr,\n                                                  .pColorBlendState    = &amp;color_blending,\n                                                  .pDynamicState       = &amp;dynamic_state_create_info,\n                                                  .layout              = dp_pipeline_layout_,\n                                                  .renderPass          = render_pass,\n                                                  .subpass             = 0,\n                                                  .basePipelineHandle  = {},\n                                                  .basePipelineIndex   = 0};\n\n    VK_ASSERT_SUCCESS(vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipeline_info, nullptr, &amp;pipeline_))\n\n    vkDestroyShaderModule(device, vert, nullptr);\n    vkDestroyShaderModule(device, frag, nullptr);\n    return pipeline_;\n}\n\n/* Compute a view matrix with rotation and position */\nEigen::Matrix4f openwarp_vk::create_camera_matrix(const pose_type&amp; pose, int eye) {\n    Eigen::Matrix4f cameraMatrix   = Eigen::Matrix4f::Identity();\n    auto            ipd            = display_params::ipd / 2.0f;\n    cameraMatrix.block&lt;3, 1&gt;(0, 3) = pose.position + pose.orientation * Eigen::Vector3f(eye == 0 ? -ipd : ipd, 0, 0);\n    cameraMatrix.block&lt;3, 3&gt;(0, 0) = pose.orientation.toRotationMatrix();\n    return cameraMatrix;\n}\n\nEigen::Matrix4f openwarp_vk::calculate_distortion_transform(const Eigen::Matrix4f&amp; projection_matrix) {\n    // Eigen stores matrices internally in column-major order.\n    // However, the (i,j) accessors are row-major (i.e, the first argument\n    // is which row, and the second argument is which column.)\n    Eigen::Matrix4f texCoordProjection;\n    texCoordProjection &lt;&lt; 0.5f * projection_matrix(0, 0), 0.0f, 0.5f * projection_matrix(0, 2) - 0.5f, 0.0f, 0.0f,\n        -0.5f * projection_matrix(1, 1), 0.5f * projection_matrix(1, 2) - 0.5f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n        1.0f;\n\n    return texCoordProjection;\n}\n</code></pre>"},{"location":"api/openwarp__vk_8hpp/","title":"File openwarp_vk.hpp","text":"<p>FileList &gt; openwarp_vk &gt; openwarp_vk.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/hmd.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/matrix_transform.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/hash.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;stack&gt;</code></li> </ul>"},{"location":"api/openwarp__vk_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/openwarp__vk_8hpp/#classes","title":"Classes","text":"Type Name struct DistortionCorrectionVertex struct DistortionMatrix struct OpenWarpVertex struct WarpMatrices class openwarp_vk"},{"location":"api/openwarp__vk_8hpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL define GLM_FORCE_DEPTH_ZERO_TO_ONE define GLM_FORCE_RADIANS"},{"location":"api/openwarp__vk_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/openwarp__vk_8hpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre>"},{"location":"api/openwarp__vk_8hpp/#define-glm_force_depth_zero_to_one","title":"define GLM_FORCE_DEPTH_ZERO_TO_ONE","text":"<pre><code>#define GLM_FORCE_DEPTH_ZERO_TO_ONE \n</code></pre>"},{"location":"api/openwarp__vk_8hpp/#define-glm_force_radians","title":"define GLM_FORCE_RADIANS","text":"<pre><code>#define GLM_FORCE_RADIANS \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/openwarp_vk.hpp</code></p>"},{"location":"api/openwarp__vk_8hpp_source/","title":"File openwarp_vk.hpp","text":"<p>File List &gt; openwarp_vk &gt; openwarp_vk.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/hmd.hpp\"\n#include \"illixr/switchboard.hpp\"\n// #include \"illixr/threadloop.hpp\"\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n\n#define GLM_FORCE_RADIANS\n#define GLM_FORCE_DEPTH_ZERO_TO_ONE\n#define GLM_ENABLE_EXPERIMENTAL\n#include &lt;glm/glm.hpp&gt;\n#include &lt;glm/gtc/matrix_transform.hpp&gt;\n#include &lt;glm/gtx/hash.hpp&gt;\n#include &lt;mutex&gt;\n#include &lt;stack&gt;\n\nnamespace ILLIXR {\n\nstruct DistortionCorrectionVertex {\n    glm::vec3 pos;\n    glm::vec2 uv0;\n    glm::vec2 uv1;\n    glm::vec2 uv2;\n\n    static VkVertexInputBindingDescription get_binding_description() {\n        VkVertexInputBindingDescription binding_description = {};\n        binding_description.binding                         = 0;            // index of the binding in the array of bindings\n        binding_description.stride    = sizeof(DistortionCorrectionVertex); // number of bytes from one entry to the next\n        binding_description.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;        // no instancing\n\n        return binding_description;\n    }\n\n    static std::array&lt;VkVertexInputAttributeDescription, 4&gt; get_attribute_descriptions() {\n        std::array&lt;VkVertexInputAttributeDescription, 4&gt; attribute_descriptions = {};\n\n        // position\n        attribute_descriptions[0].binding  = 0;                          // which binding the per-vertex data comes from\n        attribute_descriptions[0].location = 0;                          // location directive of the input in the vertex shader\n        attribute_descriptions[0].format   = VK_FORMAT_R32G32B32_SFLOAT; // format of the data\n        attribute_descriptions[0].offset =\n            offsetof(DistortionCorrectionVertex, pos); // number of bytes since the start of the per-vertex data to read from\n\n        // uv0\n        attribute_descriptions[1].binding  = 0;\n        attribute_descriptions[1].location = 1;\n        attribute_descriptions[1].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[1].offset   = offsetof(DistortionCorrectionVertex, uv0);\n\n        // uv1\n        attribute_descriptions[2].binding  = 0;\n        attribute_descriptions[2].location = 2;\n        attribute_descriptions[2].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[2].offset   = offsetof(DistortionCorrectionVertex, uv1);\n\n        // uv2\n        attribute_descriptions[3].binding  = 0;\n        attribute_descriptions[3].location = 3;\n        attribute_descriptions[3].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[3].offset   = offsetof(DistortionCorrectionVertex, uv2);\n\n        return attribute_descriptions;\n    }\n};\n\nstruct OpenWarpVertex {\n    glm::vec3 pos;\n    glm::vec2 uv;\n\n    static VkVertexInputBindingDescription get_binding_description() {\n        VkVertexInputBindingDescription binding_description = {};\n        binding_description.binding                         = 0;     // index of the binding in the array of bindings\n        binding_description.stride    = sizeof(OpenWarpVertex);      // number of bytes from one entry to the next\n        binding_description.inputRate = VK_VERTEX_INPUT_RATE_VERTEX; // no instancing\n\n        return binding_description;\n    }\n\n    static std::array&lt;VkVertexInputAttributeDescription, 2&gt; get_attribute_descriptions() {\n        std::array&lt;VkVertexInputAttributeDescription, 2&gt; attribute_descriptions = {};\n\n        // position\n        attribute_descriptions[0].binding  = 0;                          // which binding the per-vertex data comes from\n        attribute_descriptions[0].location = 0;                          // location directive of the input in the vertex shader\n        attribute_descriptions[0].format   = VK_FORMAT_R32G32B32_SFLOAT; // format of the data\n        attribute_descriptions[0].offset =\n            offsetof(OpenWarpVertex, pos); // number of bytes since the start of the per-vertex data to read from\n\n        // uv\n        attribute_descriptions[1].binding  = 0;\n        attribute_descriptions[1].location = 1;\n        attribute_descriptions[1].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[1].offset   = offsetof(OpenWarpVertex, uv);\n\n        return attribute_descriptions;\n    }\n};\n\nstruct DistortionMatrix {\n    glm::mat4 transform;\n};\n\nstruct WarpMatrices {\n    glm::mat4 render_inv_projection[2];\n    glm::mat4 render_inv_view[2];\n    glm::mat4 warp_view_projection[2];\n};\n\nclass openwarp_vk : public vulkan::timewarp {\npublic:\n    explicit openwarp_vk(const phonebook* pb);\n    void initialize();\n    void setup(VkRenderPass render_pass, uint32_t subpass,\n               std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool_,\n               bool                                                              input_texture_external_) override;\n    void partial_destroy();\n    void update_uniforms(const data_format::pose_type&amp; render_pose) override;\n    void record_command_buffer(VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) override;\n    bool is_external() override;\n    void destroy() override;\n\nprivate:\n    void                   create_offscreen_images();\n    void                   create_vertex_buffers();\n    void                   create_index_buffers();\n    void                   generate_distortion_data();\n    void                   generate_openwarp_mesh(size_t width, size_t height);\n    void                   create_texture_sampler();\n    void                   create_descriptor_set_layouts();\n    void                   create_uniform_buffers();\n    void                   create_descriptor_pool();\n    void                   create_descriptor_sets();\n    void                   create_openwarp_pipeline();\n    VkPipeline             create_distortion_correction_pipeline(VkRenderPass render_pass, [[maybe_unused]] uint32_t subpass);\n    static Eigen::Matrix4f create_camera_matrix(const data_format::pose_type&amp; pose, int eye);\n    static Eigen::Matrix4f calculate_distortion_transform(const Eigen::Matrix4f&amp; projection_matrix);\n\n    const phonebook* const             phonebook_;\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n\n    const std::shared_ptr&lt;data_format::pose_prediction&gt; pose_prediction_;\n\n    bool                                      disable_warp_     = false;\n    std::shared_ptr&lt;vulkan::display_provider&gt; display_provider_ = nullptr;\n    std::mutex                                setup_mutex_;\n\n    bool initialized_            = false;\n    bool input_texture_external_ = false;\n\n    bool using_godot_         = false;\n    bool offloaded_rendering_ = false;\n\n    uint64_t frame_count_ = 0;\n\n    // Vulkan resources\n    std::stack&lt;std::function&lt;void()&gt;&gt; deletion_queue_;\n    VmaAllocator                      vma_allocator_{};\n\n    // Note that each frame occupies 2 elements in the buffer pool:\n    // i for the image itself, and i + 1 for the depth image.\n    size_t swapchain_width_{};\n    size_t swapchain_height_{};\n\n    std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool_;\n\n    VkSampler fb_sampler_{};\n\n    VkDescriptorPool descriptor_pool_{};\n    VkCommandPool    command_pool_{};\n    VkCommandBuffer  command_buffer_{};\n\n    // offscreen image used as an intermediate render target\n    std::array&lt;VkImage, 2&gt;       offscreen_images_{};\n    std::array&lt;VkImageView, 2&gt;   offscreen_image_views_{};\n    std::array&lt;VmaAllocation, 2&gt; offscreen_image_allocs_{};\n\n    std::array&lt;VkImage, 2&gt;       offscreen_depths_{};\n    std::array&lt;VkImageView, 2&gt;   offscreen_depth_views_{};\n    std::array&lt;VmaAllocation, 2&gt; offscreen_depth_allocs_{};\n\n    std::array&lt;VkFramebuffer, 2&gt; offscreen_framebuffers_{};\n\n    // openwarp mesh\n    VkPipelineLayout ow_pipeline_layout_{};\n\n    VkBuffer          ow_matrices_uniform_buffer_{};\n    VmaAllocation     ow_matrices_uniform_alloc_{};\n    VmaAllocationInfo ow_matrices_uniform_alloc_info_{};\n\n    VkDescriptorSetLayout                       ow_descriptor_set_layout_{};\n    std::array&lt;std::vector&lt;VkDescriptorSet&gt;, 2&gt; ow_descriptor_sets_;\n\n    uint32_t                    num_openwarp_vertices_{};\n    uint32_t                    num_openwarp_indices_{};\n    std::vector&lt;OpenWarpVertex&gt; openwarp_vertices_;\n    std::vector&lt;uint32_t&gt;       openwarp_indices_;\n    size_t                      openwarp_width_  = 0;\n    size_t                      openwarp_height_ = 0;\n\n    VkBuffer      ow_vertex_buffer_{};\n    VmaAllocation ow_vertex_alloc_{};\n    VkBuffer      ow_index_buffer_{};\n    VmaAllocation ow_index_alloc_{};\n\n    VkRenderPass openwarp_render_pass_{};\n    VkPipeline   openwarp_pipeline_ = VK_NULL_HANDLE;\n\n    // distortion data\n    HMD::hmd_info_t hmd_info_{};\n    Eigen::Matrix4f basic_projection_[2];\n    Eigen::Matrix4f inverse_projection_[2];\n\n    VkPipelineLayout  dp_pipeline_layout_{};\n    VkBuffer          dp_uniform_buffer_{};\n    VmaAllocation     dp_uniform_alloc_{};\n    VmaAllocationInfo dp_uniform_alloc_info_{};\n\n    VkDescriptorSetLayout                       dp_descriptor_set_layout_{};\n    std::array&lt;std::vector&lt;VkDescriptorSet&gt;, 2&gt; dp_descriptor_sets_;\n\n    uint32_t                                num_distortion_vertices_{};\n    uint32_t                                num_distortion_indices_{};\n    std::vector&lt;DistortionCorrectionVertex&gt; distortion_vertices_;\n    std::vector&lt;uint32_t&gt;                   distortion_indices_;\n\n    VkRenderPass  distortion_correction_render_pass_{};\n    VkBuffer      dc_vertex_buffer_{};\n    VmaAllocation dc_vertex_alloc_{};\n    VkBuffer      dc_index_buffer_{};\n    VmaAllocation dc_index_alloc_{};\n\n    // metrics\n    std::atomic&lt;uint32_t&gt; num_record_calls_{0};\n    std::atomic&lt;uint32_t&gt; num_update_uniforms_calls_{0};\n\n    friend class openwarp_vk_plugin;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p> <ul> <li>debugview </li> <li>gldemo </li> <li>Lighthouse </li> <li>native_renderer </li> <li>offload_rendering_client </li> <li>offload_rendering_server </li> <li>OpenNI </li> <li>openwarp_vk </li> <li>ORB-SLAM </li> <li>Record IMU Cam </li> <li>TCP_network_backend </li> <li>timewarp_gl </li> <li>timewarp_vk </li> <li>ZED Mini </li> <li>zed_capture </li> <li>ZED Data Injection </li> <li>FauxPose ILLIXR plugin </li> <li>vkdemo </li> </ul>"},{"location":"api/parser_8py/","title":"File parser.py","text":"<p>FileList &gt; gldemo &gt; parser.py</p> <p>Go to the source code of this file</p>"},{"location":"api/parser_8py/#namespaces","title":"Namespaces","text":"Type Name namespace parser <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/parser.py</code></p>"},{"location":"api/parser_8py_source/","title":"File parser.py","text":"<p>File List &gt; gldemo &gt; parser.py</p> <p>Go to the documentation of this file</p> <pre><code># Hacked together obj parser\n\n\nimport sys\n\ntriangles = []\nmats = []\nresult = \"\"\ntriangles.append([(0,0,0),(0,0,0),(0,0,0),(0,0,0)])\n#triangles.append([(100,100,800),(80,150,200),(200,200,1),(255,255,255)]);\n\nglobal_verts = []\nglobal_normals = []\n\nobjects = []\n\nnum_normals = 0\nwith open(sys.argv[1], 'r') as f:\n    print(\"// Parsing \" + sys.argv[1] + \" for obj data\")\n    currentMat = \"\"\n    for line in f:\n        splitLine = line.rstrip().replace(\"  \", \" \").split(' ')\n\n        if splitLine[0] == 'o':\n            objects.append({\"name\":splitLine[1], \"vert_indices\":[], \"normal_indices\":[]})\n            # print(\"New object being parsed: name = \" + splitLine[1])\n\n        if splitLine[0] == 'v':\n            for member in splitLine:\n                if member.isspace():\n                    splitLine.remove(member)\n            global_verts.append((float(splitLine[1]),float(splitLine[2]), float(splitLine[3])))\n        if splitLine[0] == 'vn':\n            global_normals.append((float(splitLine[1]),float(splitLine[2]), float(splitLine[3])))\n            num_normals += 1\n        if splitLine[0] == 'f':\n\n            v0_idx = int(splitLine[1].split('/')[0])-1\n            v1_idx = int(splitLine[2].split('/')[0])-1\n            v2_idx = int(splitLine[3].split('/')[0])-1\n\n            objects[-1][\"vert_indices\"].append((v0_idx, v1_idx, v2_idx))\n\n            # Get indices of vertex normals\n            n0_idx = int(splitLine[1].split('/')[2])-1\n            n1_idx = int(splitLine[2].split('/')[2])-1\n            n2_idx = int(splitLine[3].split('/')[2])-1\n\n            objects[-1][\"normal_indices\"].append((n0_idx, n1_idx, n2_idx))\n\n\n\n\nprint(\"// Autogenerated by parser.py\")\nprint(\"// Total objects: \" + str(len(objects)) + \"\\n\")\n\nprint(\"#ifndef MODEL_HH\")\nprint(\"#define MODEL_HH\")\n\nprint(\"#include &lt;GL/gl.h&gt;\")\n\nfor obj in objects:\n    print(\"static constexpr int \" + (obj[\"name\"].replace('.', '').capitalize()) + \"_NUM_TRIANGLES = \" + str(len(obj[\"vert_indices\"])) + \";\")\n    print(\"static constexpr int \" + (obj[\"name\"].replace('.', '').capitalize()) + \"_NUM_NORMALS = \" + str(len(obj[\"normal_indices\"])) + \";\")\n    print(\"static GLfloat \" + obj[\"name\"].replace('.', '') + \"_vertex_data[] = {\")\n    for tri in obj[\"vert_indices\"]:\n        for vert_idx in tri:\n            vertex = global_verts[vert_idx]\n            print(\"\\t\" + str(vertex).strip(\"()\") + \",\")\n    print(\"};\")\n\n    print(\"static GLfloat \" + obj[\"name\"].replace('.', '') + \"_normal_data[] = {\")\n    for tri in obj[\"normal_indices\"]:\n        for norm_idx in tri:\n            normal = global_normals[norm_idx]\n            print(\"\\t\" + str(normal).strip(\"()\") + \",\")\n    print(\"};\")\n\nprint(\"#endif\")\n\n\"\"\"\nindex = 0\nfor facegroup in faces:\n    print(\"// Material group \" + str(index) + \", \" + str(len(facegroup)) + \" faces in group\");\n    print(\"var \" + sys.argv[2] + \"_group\" + str(index) + \"_poly_data = [\")\n    index += 1\n    for face in facegroup[:-1]:\n        print(\"\\t\" + str(face).strip(\"()\") + \",\")\n    print(\"\\t\" + str(facegroup[-1]).strip(\"()\"))\n    print(\"];\\n\")\n\nprint(\"// Parsed \" + str(len(faces)) + \" material groups end autogenerated section\")\n\n\"\"\"\n</code></pre>"},{"location":"api/phonebook_8hpp/","title":"File phonebook.hpp","text":"<p>FileList &gt; illixr &gt; phonebook.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> </ul>"},{"location":"api/phonebook_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/phonebook_8hpp/#classes","title":"Classes","text":"Type Name class phonebook A service locator forILLIXR . class service A 'service' that can be registered in the phonebook. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/phonebook.hpp</code></p>"},{"location":"api/phonebook_8hpp_source/","title":"File phonebook.hpp","text":"<p>File List &gt; illixr &gt; phonebook.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;stdexcept&gt;\n#include &lt;typeindex&gt;\n#include &lt;unordered_map&gt;\n\n#ifndef NDEBUG\n    #include &lt;iostream&gt;\n    #include &lt;spdlog/spdlog.h&gt;\n// #include \"spdlog/sinks/stdout_color_sinks.h\"\n#endif\n\nnamespace ILLIXR {\n\nclass phonebook {\n    /*\n      Proof of thread-safety:\n      - Since all instance members are private, acquiring a lock in each method implies the class is datarace-free.\n      - Since there is only one lock and this does not call any code containing locks, this is deadlock-free.\n      - Both of these methods are only used during initialization, so the locks are not contended in steady-state.\n\n      However, to write a correct program, one must also check the thread-safety of the elements\n      inserted into this class by the caller.\n    */\n\npublic:\n    class service {\n    public:\n        // auto spdlogger(const char* log_level) {\n        //     if (!log_level) {\n        // #ifdef NDEBUG\n        //         log_level = \"warn\";\n        // #else\n        //         log_level = \"debug\";\n        // #endif\n        //     }\n        //     std::vector&lt;spdlog::sink_ptr&gt; sinks;\n        //     // auto                          file_sink = std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(\"logs/\" +\n        //     type_index.name() + \".log\"); auto                          console_sink =\n        //     std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;();\n        //     // sinks.push_back(file_sink);\n        //     sinks.push_back(console_sink);\n        //     plugin_logger = std::make_shared&lt;spdlog::logger&gt;(type_index.name(), begin(sinks), end(sinks));\n        //     plugin_logger-&gt;set_level(spdlog::level::from_str(log_level));\n        //     spdlog::register_logger(plugin_logger);\n        //     return plugin_logger;\n        // }\n\n        // void spd_add_file_sink(const std::string&amp; file_name, const std::string&amp; extension, const std::string&amp; log_level) {\n        //     if (!plugin_logger) {\n        //         throw std::runtime_error(\"Logger not found\");\n        //     }\n\n        // auto file_sink = std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(\"logs/\" + file_name + \".\" + extension, true);\n        // file_sink-&gt;set_level(spdlog::level::from_str(log_level));\n        // plugin_logger-&gt;sinks().push_back(file_sink);\n        // size_t sink_count = plugin_logger-&gt;sinks().size();\n        // plugin_logger-&gt;sinks()[sink_count-1]-&gt;set_pattern(\"%v\");\n        // }\n\n        virtual ~service() = default;\n\n        // std::shared_ptr&lt;spdlog::logger&gt;      plugin_logger;\n    };\n\n    template&lt;typename Specific_service&gt;\n    void register_impl(std::shared_ptr&lt;Specific_service&gt; impl) {\n        const std::unique_lock&lt;std::shared_mutex&gt; lock{mutex_};\n\n        const std::type_index type_index = std::type_index(typeid(Specific_service));\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[phonebook] Register {}\", type_index.name());\n#endif\n        assert(registry_.count(type_index) == 0);\n        registry_.try_emplace(type_index, impl);\n    }\n\n    template&lt;typename Specific_service&gt;\n    std::shared_ptr&lt;Specific_service&gt; lookup_impl() const {\n        const std::shared_lock&lt;std::shared_mutex&gt; lock{mutex_};\n\n        const std::type_index type_index = std::type_index(typeid(Specific_service));\n\n#ifndef NDEBUG\n        // if this fails, and there are no duplicate base classes, ensure the hash_code's are unique.\n        if (registry_.count(type_index) != 1) {\n            throw std::runtime_error{\"Attempted to lookup an unregistered implementation \" + std::string{type_index.name()}};\n        }\n#endif\n\n        std::shared_ptr&lt;service&gt; this_service = registry_.at(type_index);\n        if (!static_cast&lt;bool&gt;(this_service))\n            throw std::runtime_error{\"Could not find \" + std::string{type_index.name()}};\n\n        std::shared_ptr&lt;Specific_service&gt; this_specific_service = std::dynamic_pointer_cast&lt;Specific_service&gt;(this_service);\n        if (!static_cast&lt;bool&gt;(this_service))\n            throw std::runtime_error{\"Could not find specific \" + std::string{type_index.name()}};\n\n        return this_specific_service;\n    }\n\n    template&lt;typename specific_service&gt;\n    [[maybe_unused]] bool has_impl() const {\n        const std::shared_lock&lt;std::shared_mutex&gt; lock{mutex_};\n\n        const std::type_index type_index = std::type_index(typeid(specific_service));\n\n        return registry_.count(type_index) == 1;\n    }\n\nprivate:\n    std::unordered_map&lt;std::type_index, const std::shared_ptr&lt;service&gt;&gt; registry_;\n    mutable std::shared_mutex                                           mutex_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2audio__pipeline_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/audio_pipeline/CMakeLists.txt</code></p>"},{"location":"api/plugins_2audio__pipeline_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>include(GetAudio_Pipeline)\n</code></pre>"},{"location":"api/plugins_2debugview_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2debugview_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.debugview${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2debugview_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2debugview_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.debugview${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/debugview/CMakeLists.txt</code></p>"},{"location":"api/plugins_2debugview_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the debugview ILLIXR plugin\n\n\nset(PLUGIN_NAME plugin.debugview${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nset(DEBUGVIEW_SOURCES plugin.cpp\n    plugin.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/shaders/demo_shader.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/error_util.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/gl_util/obj.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/math_util.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/shader_util.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n    $&lt;TARGET_OBJECTS:illixr_imgui&gt;\n)\n\nadd_library(${PLUGIN_NAME} SHARED ${DEBUGVIEW_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${OpenCV_INCLUDE_DIRS} ${CMAKE_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${OpenCV_LIBRARIES} ${Eigen3_LIBRARIES} dl ${GLEW_LIBRARIES} Threads::Threads spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2debugview_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/debugview/README.md</code></p>"},{"location":"api/plugins_2debugview_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># debugview\n\n## Summary\n\n`debugview` is a simple debugging view for the ILLIXR system. By subscribing to several Switchboard endpoints, many\nimportant datapoints can be observed to help debug issues with the runtime. The debug view shows the current calculated\nSLAM pose and the (optional) ground truth pose read from the ground truth dataset as 3D headset models drawn on a\nbackdrop scene. In addition, camera and IMU data is also visible, with the stereoscopic onboard camera views shown in\none of the windows. Various offsets can be applied to the generated poses to aid in viewing. Dear ImGUI is used for\ndisplaying data and providing an interactive interface.\n\n## Switchboard connection\n\n- `debugview` subscribes to the slow-pose, which represents the latest pose published by the SLAM/IMU system.\n- In the future, `debugview` will also query for the most up-to-date predicted pose through an RPC-like query system.\n  This is not currently in our release version; but is in development and will be added soon. The \"fast pose\" referenced\n  in this plugin just samples the `slow_pose` instead.\n- `debugview` also is synchronously dependent on the `imu_cam` topic, as the stereoscopic camera views are displayed in\n  the debug window. In ILLIXR, \"synchronous dependencies\" are implemented as scheduled \"handlers\" that are executed from\n  a shared thread pool; this handler is executed every time a fresh \"packet\" is available from the `imu_cam` topic.\n  Given that this is a separate thread from the main graphics thread, this `imu_cam` packet must be saved/cached for\n  later, when the graphics thread renders the next frame. This is a good example to follow when writing your own\n  multithreaded components that use both synchronous and asynchronous dependencies, and need to share information across\n  dependency boundaries.\n\n## Environment Variables\n\n**DEBUGVIEW_LOG_LEVEL**: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"\ncritical\", or \"off\"\n\n## Notes\n\n`debugview` will be under heavy development in the near-term. Pull requests may or may not be accepted, due to the\nfrequency of rapid internal changes.\n\n## Known Issues\n\nCurrently, the poses returned from the SLAM system have an incorrect initial rotation, as the poses are returned in an\nincorrect frame of reference. Thus, the headsets may appear to be tilted incorrectly; the button \"calculate new\norientation offset\" will reset the orientation, such that the current orientation is considered the \"neutral\"\norientation. In a future update, the correct frame of reference/transform matrix will be applied and the pose will\naccurately reflect the actual head position.\n\n## Contributions\n\nContributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our\nexisting internal backlog.\n</code></pre>"},{"location":"api/plugins_2debugview_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; debugview &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/imgui/backends/imgui_impl_glfw.h\"</code></li> <li><code>#include \"illixr/imgui/backends/imgui_impl_opengl3.h\"</code></li> <li><code>#include \"illixr/imgui/imgui.h\"</code></li> <li><code>#include \"illixr/math_util.hpp\"</code></li> <li><code>#include \"illixr/shader_util.hpp\"</code></li> <li><code>#include \"illixr/shaders/demo_shader.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> </ul>"},{"location":"api/plugins_2debugview_2plugin_8cpp/#public-functions","title":"Public Functions","text":"Type Name Eigen::Matrix4f look_at (const Eigen::Vector3f &amp; eye, const Eigen::Vector3f &amp; target, const Eigen::Vector3f &amp; up)"},{"location":"api/plugins_2debugview_2plugin_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void glfw_error_callback (int error, const char * description) Callback function to handle glfw errors."},{"location":"api/plugins_2debugview_2plugin_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2debugview_2plugin_8cpp/#function-look_at","title":"function look_at","text":"<pre><code>Eigen::Matrix4f look_at (\n    const Eigen::Vector3f &amp; eye,\n    const Eigen::Vector3f &amp; target,\n    const Eigen::Vector3f &amp; up\n) \n</code></pre>"},{"location":"api/plugins_2debugview_2plugin_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/plugins_2debugview_2plugin_8cpp/#function-glfw_error_callback","title":"function glfw_error_callback","text":"<p>Callback function to handle glfw errors. <pre><code>static void glfw_error_callback (\n    int error,\n    const char * description\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/debugview/plugin.cpp</code></p>"},{"location":"api/plugins_2debugview_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; debugview &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/imgui/backends/imgui_impl_glfw.h\"\n#include \"illixr/imgui/backends/imgui_impl_opengl3.h\"\n#include \"illixr/imgui/imgui.h\"\n#include \"illixr/math_util.hpp\"\n#include \"illixr/shader_util.hpp\"\n#include \"illixr/shaders/demo_shader.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n// Loosely inspired by\n// http://spointeau.blogspot.com/2013/12/hello-i-am-looking-at-opengl-3.html\n\nEigen::Matrix4f look_at(const Eigen::Vector3f&amp; eye, const Eigen::Vector3f&amp; target, const Eigen::Vector3f&amp; up) {\n    using namespace Eigen;\n    Vector3f look_dir = (target - eye).normalized();\n    Vector3f up_dir   = up.normalized();\n    Vector3f side_dir = look_dir.cross(up_dir).normalized();\n    up_dir            = side_dir.cross(look_dir);\n\n    Matrix4f result;\n    result &lt;&lt; side_dir.x(), side_dir.y(), side_dir.z(), -side_dir.dot(eye), up_dir.x(), up_dir.y(), up_dir.z(),\n        -up_dir.dot(eye), -look_dir.x(), -look_dir.y(), -look_dir.z(), look_dir.dot(eye), 0, 0, 0, 1;\n\n    return result;\n}\n\nstatic void glfw_error_callback(int error, const char* description) {\n    spdlog::get(\"illixr\")-&gt;error(\"|| glfw error_callback: {}\\n|&gt; {}\", error, description);\n    ILLIXR::abort();\n}\n\n[[maybe_unused]] debugview::debugview(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , pose_prediction_{phonebook_-&gt;lookup_impl&lt;pose_prediction&gt;()}\n    , slow_pose_reader_{switchboard_-&gt;get_reader&lt;pose_type&gt;(\"slow_pose\")}\n    , fast_pose_reader_{switchboard_-&gt;get_reader&lt;imu_raw_type&gt;(\"imu_raw\")}\n    , rgb_depth_reader_(switchboard_-&gt;get_reader&lt;rgb_depth_type&gt;(\"rgb_depth\"))\n    , cam_reader_{switchboard_-&gt;get_buffered_reader&lt;data_format::binocular_cam_type&gt;(\"cam\")}\n    , display_backend_manages_glfw_{strcmp(switchboard_-&gt;get_env_char(\"ILLIXR_DISPLAY_MODE\"), \"glfw\") == 0} {\n    spdlogger(switchboard_-&gt;get_env_char(\"DEBUGVIEW_LOG_LEVEL\"));\n}\n\nvoid debugview::draw_GUI() {\n    RAC_ERRNO_MSG(\"debugview at start of draw_GUI\");\n\n    // Start the Dear ImGui frame\n    ImGui_ImplOpenGL3_NewFrame();\n\n    // Calls glfw within source code which sets errno\n    ImGui_ImplGlfw_NewFrame();\n\n    ImGui::NewFrame();\n\n    // Init the window docked to the bottom left corner.\n    ImGui::SetNextWindowPos(ImVec2(0.0f, ImGui::GetIO().DisplaySize.y), ImGuiCond_Once, ImVec2(0.0f, 1.0f));\n    ImGui::Begin(\"ILLIXR Debug View\");\n\n    ImGui::Text(\"Adjust options for the runtime debug view.\");\n    ImGui::Spacing();\n\n    if (ImGui::CollapsingHeader(\"Headset visualization options\", ImGuiTreeNodeFlags_DefaultOpen)) {\n        ImGui::Checkbox(\"Follow headset position\", &amp;follow_headset_);\n\n        ImGui::SliderFloat(\"View distance \", &amp;view_distance_, 0.1f, 10.0f);\n\n        ImGui::SliderFloat3(\"Tracking \\\"offset\\\"\", tracking_position_offset_.data(), -10.0f, 10.0f);\n\n        if (ImGui::Button(\"Reset\")) {\n            tracking_position_offset_ = Eigen::Vector3f{5.0f, 2.0f, -3.0f};\n        }\n        ImGui::SameLine();\n        ImGui::Text(\"Resets to default tracking universe\");\n\n        if (ImGui::Button(\"Zero\")) {\n            tracking_position_offset_ = Eigen::Vector3f{0.0f, 0.0f, 0.0f};\n        }\n        ImGui::SameLine();\n        ImGui::Text(\"Resets to zeroed out tracking universe\");\n\n        if (ImGui::Button(\"Zero orientation\")) {\n            const pose_type predicted_pose = pose_prediction_-&gt;get_fast_pose().pose;\n            if (pose_prediction_-&gt;fast_pose_reliable()) {\n                // Can only zero if predicted_pose is valid\n                pose_prediction_-&gt;set_offset(predicted_pose.orientation);\n            }\n        }\n        ImGui::SameLine();\n        ImGui::Text(\"Resets to zeroed out tracking universe\");\n    }\n    ImGui::Spacing();\n    ImGui::Text(\"Switchboard connection status:\");\n    ImGui::Text(\"Predicted pose topic:\");\n    ImGui::SameLine();\n\n    if (pose_prediction_-&gt;fast_pose_reliable()) {\n        const pose_type predicted_pose = pose_prediction_-&gt;get_fast_pose().pose;\n        ImGui::TextColored(ImVec4(0.0, 1.0, 0.0, 1.0), \"Valid predicted pose pointer\");\n        ImGui::Text(\"Predicted pose position (XYZ):\\n  (%f, %f, %f)\", predicted_pose.position.x(), predicted_pose.position.y(),\n                    predicted_pose.position.z());\n        ImGui::Text(\"Predicted pose quaternion (XYZW):\\n  (%f, %f, %f, %f)\", predicted_pose.orientation.x(),\n                    predicted_pose.orientation.y(), predicted_pose.orientation.z(), predicted_pose.orientation.w());\n    } else {\n        ImGui::TextColored(ImVec4(1.0, 0.0, 0.0, 1.0), \"Invalid predicted pose pointer\");\n    }\n\n    ImGui::Text(\"Fast pose topic:\");\n    ImGui::SameLine();\n\n    switchboard::ptr&lt;const imu_raw_type&gt; raw_imu = fast_pose_reader_.get_ro_nullable();\n    if (raw_imu) {\n        pose_type raw_pose;\n        raw_pose.position    = Eigen::Vector3f{float(raw_imu-&gt;pos(0)), float(raw_imu-&gt;pos(1)), float(raw_imu-&gt;pos(2))};\n        raw_pose.orientation = Eigen::Quaternionf{float(raw_imu-&gt;quat.w()), float(raw_imu-&gt;quat.x()), float(raw_imu-&gt;quat.y()),\n                                                  float(raw_imu-&gt;quat.z())};\n        pose_type swapped_pose = pose_prediction_-&gt;correct_pose(raw_pose);\n\n        ImGui::TextColored(ImVec4(0.0, 1.0, 0.0, 1.0), \"Valid fast pose pointer\");\n        ImGui::Text(\"Fast pose position (XYZ):\\n  (%f, %f, %f)\", swapped_pose.position.x(), swapped_pose.position.y(),\n                    swapped_pose.position.z());\n        ImGui::Text(\"Fast pose quaternion (XYZW):\\n  (%f, %f, %f, %f)\", swapped_pose.orientation.x(),\n                    swapped_pose.orientation.y(), swapped_pose.orientation.z(), swapped_pose.orientation.w());\n    } else {\n        ImGui::TextColored(ImVec4(1.0, 0.0, 0.0, 1.0), \"Invalid fast pose pointer\");\n    }\n\n    ImGui::Text(\"Slow pose topic:\");\n    ImGui::SameLine();\n\n    switchboard::ptr&lt;const pose_type&gt; slow_pose_ptr = slow_pose_reader_.get_ro_nullable();\n    if (slow_pose_ptr) {\n        pose_type swapped_pose = pose_prediction_-&gt;correct_pose(*slow_pose_ptr);\n        ImGui::TextColored(ImVec4(0.0, 1.0, 0.0, 1.0), \"Valid slow pose pointer\");\n        ImGui::Text(\"Slow pose position (XYZ):\\n  (%f, %f, %f)\", swapped_pose.position.x(), swapped_pose.position.y(),\n                    swapped_pose.position.z());\n        ImGui::Text(\"Slow pose quaternion (XYZW):\\n  (%f, %f, %f, %f)\", swapped_pose.orientation.x(),\n                    swapped_pose.orientation.y(), swapped_pose.orientation.z(), swapped_pose.orientation.w());\n    } else {\n        ImGui::TextColored(ImVec4(1.0, 0.0, 0.0, 1.0), \"Invalid slow pose pointer\");\n    }\n\n    ImGui::Text(\"Ground truth pose topic:\");\n    ImGui::SameLine();\n\n    if (pose_prediction_-&gt;true_pose_reliable()) {\n        const pose_type true_pose = pose_prediction_-&gt;get_true_pose();\n        ImGui::TextColored(ImVec4(0.0, 1.0, 0.0, 1.0), \"Valid ground truth pose pointer\");\n        ImGui::Text(\"Ground truth position (XYZ):\\n  (%f, %f, %f)\", true_pose.position.x(), true_pose.position.y(),\n                    true_pose.position.z());\n        ImGui::Text(\"Ground truth quaternion (XYZW):\\n  (%f, %f, %f, %f)\", true_pose.orientation.x(), true_pose.orientation.y(),\n                    true_pose.orientation.z(), true_pose.orientation.w());\n    } else {\n        ImGui::TextColored(ImVec4(1.0, 0.0, 0.0, 1.0), \"Invalid ground truth pose pointer\");\n    }\n\n    ImGui::Text(\"Debug view Eulers:\");\n    ImGui::Text(\"   (%f, %f)\", view_euler_.x(), view_euler_.y());\n\n    ImGui::End();\n\n    ImGui::Begin(\"Camera + IMU\");\n    ImGui::Text(\"Camera view buffers: \");\n    ImGui::Text(\"   Camera0: (%d, %d) \\n        GL texture handle: %d\", camera_texture_size_[0].x(),\n                camera_texture_size_[0].y(), camera_texture_[0]);\n    ImGui::Text(\"   Camera1: (%d, %d) \\n        GL texture handle: %d\", camera_texture_size_[1].x(),\n                camera_texture_size_[1].y(), camera_texture_[1]);\n    ImGui::End();\n\n    if (use_cam_) {\n        ImGui::SetNextWindowSize(ImVec2(700, 350), ImGuiCond_Once);\n        ImGui::SetNextWindowPos(ImVec2(ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y), ImGuiCond_Once,\n                                ImVec2(1.0f, 1.0f));\n        ImGui::Begin(\"Onboard camera views\");\n        auto window_size     = ImGui::GetWindowSize();\n        auto vertical_offset = ImGui::GetCursorPos().y;\n        ImGui::Image((void*) (intptr_t) camera_texture_[0], ImVec2(window_size.x / 2, window_size.y - vertical_offset * 2));\n        ImGui::SameLine();\n        ImGui::Image((void*) (intptr_t) camera_texture_[1], ImVec2(window_size.x / 2, window_size.y - vertical_offset * 2));\n        ImGui::End();\n    }\n\n    if (use_rgb_depth_) {\n        ImGui::SetNextWindowSize(ImVec2(700, 350), ImGuiCond_Once);\n\n        // if there are RGBD stream and Stereo images stream, then move the RGBD display window up\n        // essentially making the display images of RGBD on top of stereo\n        if (use_cam_)\n            ImGui::SetNextWindowPos(ImVec2(ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y - 350), ImGuiCond_Once,\n                                    ImVec2(1.0f, 1.0f));\n        else\n            ImGui::SetNextWindowPos(ImVec2(ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y), ImGuiCond_Once,\n                                    ImVec2(1.0f, 1.0f));\n        ImGui::Begin(\"Onboard RGBD views\");\n        auto window_size     = ImGui::GetWindowSize();\n        auto vertical_offset = ImGui::GetCursorPos().y;\n        ImGui::Image((void*) (intptr_t) rgb_depth_texture_[0], ImVec2(window_size.x / 2, window_size.y - vertical_offset * 2));\n        ImGui::SameLine();\n        ImGui::Image((void*) (intptr_t) rgb_depth_texture_[1], ImVec2(window_size.x / 2, window_size.y - vertical_offset * 2));\n        ImGui::End();\n    }\n\n    ImGui::Render();\n\n    RAC_ERRNO_MSG(\"debugview after ImGui render\");\n}\n\nbool debugview::load_camera_images() {\n    RAC_ERRNO_MSG(\"debugview at start of load_camera_images\");\n\n    cam_ = cam_reader_.size() == 0 ? nullptr : cam_reader_.dequeue();\n    if (cam_ == nullptr) {\n        return false;\n    }\n\n    if (!use_cam_)\n        use_cam_ = true;\n\n    glBindTexture(GL_TEXTURE_2D, camera_texture_[0]);\n    cv::Mat img0{cam_-&gt;at(image::LEFT_EYE).clone()};\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, img0.cols, img0.rows, 0, GL_RED, GL_UNSIGNED_BYTE, img0.ptr());\n    camera_texture_size_[0] = Eigen::Vector2i(img0.cols, img0.rows);\n    GLint swizzle_mask[]    = {GL_RED, GL_RED, GL_RED, GL_RED};\n    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzle_mask);\n\n    glBindTexture(GL_TEXTURE_2D, camera_texture_[1]);\n    cv::Mat img1{cam_-&gt;at(image::RIGHT_EYE).clone()}; \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, img1.cols, img1.rows, 0, GL_RED, GL_UNSIGNED_BYTE, img1.ptr());\n    camera_texture_size_[1] = Eigen::Vector2i(img1.cols, img1.rows);\n    GLint swizzle_mask1[]   = {GL_RED, GL_RED, GL_RED, GL_RED};\n    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzle_mask1);\n\n    RAC_ERRNO_MSG(\"debugview at end of load_camera_images\");\n    return true;\n}\n\nbool debugview::load_rgb_depth() {\n    RAC_ERRNO_MSG(\"debugview at start of load_rgb_depth\");\n\n    rgb_depth_ = rgb_depth_reader_.get_ro_nullable();\n    if (rgb_depth_ == nullptr) {\n        return false;\n    }\n\n    if (!use_rgb_depth_)\n        use_rgb_depth_ = true;\n\n    glBindTexture(GL_TEXTURE_2D, rgb_depth_texture_[0]);\n    cv::Mat rgb{rgb_depth_-&gt;at(image::RGB).clone()};\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, rgb.cols, rgb.rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, rgb.ptr());\n    rgbd_texture_size_[0] = Eigen::Vector2i(rgb.cols, rgb.rows);\n\n    glBindTexture(GL_TEXTURE_2D, rgb_depth_texture_[1]);\n    cv::Mat depth{rgb_depth_-&gt;at(image::DEPTH).clone()};\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, depth.cols, depth.rows, 0, GL_DEPTH_COMPONENT, GL_SHORT, depth.ptr());\n    rgbd_texture_size_[1] = Eigen::Vector2i(depth.cols, depth.rows);\n    GLint swizzle_mask[]  = {GL_RED, GL_RED, GL_RED, 1};\n    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzle_mask);\n\n    RAC_ERRNO_MSG(\"debugview at end of load_rgb_depth\");\n    return true;\n}\n\nEigen::Matrix4f debugview::generate_headset_transform(const Eigen::Vector3f&amp; position, const Eigen::Quaternionf&amp; rotation,\n                                                      const Eigen::Vector3f&amp; position_offset) {\n    Eigen::Matrix4f headset_position;\n    headset_position &lt;&lt; 1, 0, 0, position.x() + position_offset.x(), 0, 1, 0, position.y() + position_offset.y(), 0, 0, 1,\n        position.z() + position_offset.z(), 0, 0, 0, 1;\n\n    // We need to convert the headset rotation quaternion to a 4x4 homogenous matrix.\n    // First of all, we convert to 3x3 matrix, then extend to 4x4 by augmenting.\n    Eigen::Matrix3f rotation_matrix               = rotation.toRotationMatrix();\n    Eigen::Matrix4f rotation_matrix_homogeneous   = Eigen::Matrix4f::Identity();\n    rotation_matrix_homogeneous.block(0, 0, 3, 3) = rotation_matrix;\n    // Then we apply the headset rotation.\n    return headset_position * rotation_matrix_homogeneous;\n}\n\nvoid debugview::_p_thread_setup() {\n    RAC_ERRNO_MSG(\"debugview at start of _p_thread_setup\");\n\n    // Note: glfwMakeContextCurrent must be called from the thread which will be using it.\n    glfwMakeContextCurrent(gui_window_);\n}\n\nvoid debugview::_p_one_iteration() {\n    RAC_ERRNO_MSG(\"debugview at stat of _p_one_iteration\");\n\n    RAC_ERRNO_MSG(\"debugview before glfwPollEvents\");\n    glfwPollEvents();\n    RAC_ERRNO_MSG(\"debugview after glfwPollEvents\");\n\n    if (glfwGetMouseButton(gui_window_, GLFW_MOUSE_BUTTON_LEFT)) {\n        double xpos, ypos;\n\n        glfwGetCursorPos(gui_window_, &amp;xpos, &amp;ypos);\n\n        Eigen::Vector2d new_pos = Eigen::Vector2d{xpos, ypos};\n        if (!being_dragged_) {\n            last_mouse_position_ = new_pos;\n            being_dragged_       = true;\n        }\n        mouse_velocity_      = new_pos - last_mouse_position_;\n        last_mouse_position_ = new_pos;\n    } else {\n        being_dragged_ = false;\n    }\n\n    view_euler_.y() += mouse_velocity_.x() * 0.002f;\n    view_euler_.x() += mouse_velocity_.y() * 0.002f;\n\n    mouse_velocity_ = mouse_velocity_ * 0.95;\n\n    load_camera_images();\n    load_rgb_depth();\n\n    glUseProgram(demo_shader_program_);\n\n    Eigen::Matrix4f headset_pose = Eigen::Matrix4f::Identity();\n\n    const fast_pose_type predicted_pose = pose_prediction_-&gt;get_fast_pose();\n    if (pose_prediction_-&gt;fast_pose_reliable()) {\n        const pose_type    pose          = predicted_pose.pose;\n        Eigen::Quaternionf combined_quat = pose.orientation;\n        headset_pose                     = generate_headset_transform(pose.position, combined_quat, tracking_position_offset_);\n    }\n\n    Eigen::Matrix4f model_matrix = Eigen::Matrix4f::Identity();\n\n    // If we are following the headset, and have a valid pose, apply the optional offset.\n    Eigen::Vector3f optional_offset = (follow_headset_ &amp;&amp; pose_prediction_-&gt;fast_pose_reliable())\n        ? (predicted_pose.pose.position + tracking_position_offset_)\n        : Eigen::Vector3f{0.0f, 0.0f, 0.0f};\n\n    Eigen::Matrix4f user_view = look_at(Eigen::Vector3f{(float) (view_distance_ * cos(view_euler_.y())),\n                                                        (float) (view_distance_ * sin(view_euler_.x())),\n                                                        (float) (view_distance_ * sin(view_euler_.y()))} +\n                                            optional_offset,\n                                        optional_offset, Eigen::Vector3f::UnitY());\n\n    Eigen::Matrix4f model_view = user_view * model_matrix;\n\n    glUseProgram(demo_shader_program_);\n\n    // Size viewport to window size.\n    int display_w, display_h;\n\n    glfwGetFramebufferSize(gui_window_, &amp;display_w, &amp;display_h);\n    glViewport(0, 0, display_w, display_h);\n\n    float ratio = (float) display_h / (float) display_w;\n\n    // Construct a basic perspective projection\n    RAC_ERRNO_MSG(\"debugview before projection_fov\");\n    math_util::projection_fov(&amp;basic_projection_, 40.0f, 40.0f, 40.0f * ratio, 40.0f * ratio, 0.03f, 20.0f);\n    RAC_ERRNO_MSG(\"debugview after projection_fov\");\n\n    glEnable(GL_CULL_FACE);\n    glEnable(GL_DEPTH_TEST);\n\n    glClearDepth(1);\n\n    glUniformMatrix4fv(static_cast&lt;GLint&gt;(model_view_attr_), 1, GL_FALSE, (GLfloat*) model_view.data());\n    glUniformMatrix4fv(static_cast&lt;GLint&gt;(projection_attr_), 1, GL_FALSE, (GLfloat*) (basic_projection_.data()));\n    glBindVertexArray(demo_vao_);\n\n    // Draw things\n    glClearColor(0.8f, 0.8f, 0.8f, 1.0f);\n\n    RAC_ERRNO_MSG(\"debugview before glClear\");\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    RAC_ERRNO_MSG(\"debugview after glClear\");\n\n    demo_scene_.Draw();\n\n    model_view = user_view * headset_pose;\n\n    glUniformMatrix4fv(static_cast&lt;GLint&gt;(model_view_attr_), 1, GL_FALSE, (GLfloat*) model_view.data());\n\n    headset_.Draw();\n\n    draw_GUI();\n\n    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n    RAC_ERRNO_MSG(\"debugview before glfwSwapBuffers\");\n    glfwSwapBuffers(gui_window_);\n    RAC_ERRNO_MSG(\"debugview after glfwSwapBuffers\");\n}\n\nvoid debugview::start() {\n    RAC_ERRNO_MSG(\"debugview at the top of start()\");\n\n    // If the display backend already initialized GLFW, then we shouldn't try to do it again.\n    // Otherwise, GLFW should be initialized here.\n    if (!display_backend_manages_glfw_) {\n        if (!glfwInit()) {\n            ILLIXR::abort(\"[debugview] Failed to initialize glfw\");\n        }\n        RAC_ERRNO_MSG(\"debugview after glfwInit\");\n    }\n\n    glfwSetErrorCallback(glfw_error_callback);\n\n    glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);\n    glfwWindowHint(GLFW_VISIBLE, GL_TRUE);\n\n    constexpr std::string_view glsl_version{\"#version 330 core\"};\n\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);\n    gui_window_ = glfwCreateWindow(1600, 1000, \"ILLIXR Debug View\", nullptr, nullptr);\n    if (gui_window_ == nullptr) {\n        spdlog::get(name_)-&gt;error(\"couldn't create window {}:{}\", __FILE__, __LINE__);\n        ILLIXR::abort();\n    }\n\n    glfwSetWindowSize(gui_window_, 1600, 1000);\n\n    glfwMakeContextCurrent(gui_window_);\n\n    RAC_ERRNO_MSG(\"debuview before vsync\");\n    glfwSwapInterval(1); // Enable vsync!\n    RAC_ERRNO_MSG(\"debugview after vysnc\");\n\n    // glEnable(GL_DEBUG_OUTPUT);\n    // glDebugMessageCallback(MessageCallback, 0);\n\n    // Init and verify GLEW\n    const GLenum glew_err = glewInit();\n    if (glew_err != GLEW_OK) {\n        spdlog::get(name_)-&gt;error(\"GLEW Error: {}\", reinterpret_cast&lt;const char*&gt;(glewGetErrorString(glew_err)));\n        glfwDestroyWindow(gui_window_);\n        ILLIXR::abort(\"[debugview] Failed to initialize GLEW\");\n    }\n    RAC_ERRNO_MSG(\"debugview after glewInit\");\n\n    // Initialize IMGUI context.\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n\n    // Dark theme, of course.\n    ImGui::StyleColorsDark();\n\n    // Init IMGUI for OpenGL\n    ImGui_ImplGlfw_InitForOpenGL(gui_window_, true);\n    ImGui_ImplOpenGL3_Init(glsl_version.data());\n\n    // Create and bind global VAO object\n    glGenVertexArrays(1, &amp;demo_vao_);\n    glBindVertexArray(demo_vao_);\n\n    demo_shader_program_ = init_and_link(demo_vertex_shader, demo_fragment_shader);\n#ifndef NDEBUG\n    spdlog::get(name_)-&gt;debug(\"Demo app shader program is program {}\", demo_shader_program_);\n#endif\n\n    vertex_pos_attr     = glGetAttribLocation(demo_shader_program_, \"vertexPosition\");\n    vertex_normal_attr_ = glGetAttribLocation(demo_shader_program_, \"vertexNormal\");\n    model_view_attr_    = glGetUniformLocation(demo_shader_program_, \"u_modelview\");\n    projection_attr_    = glGetUniformLocation(demo_shader_program_, \"u_projection\");\n    color_uniform_      = glGetUniformLocation(demo_shader_program_, \"u_color\");\n    RAC_ERRNO_MSG(\"debugview after glGetUniformLocation\");\n\n    // Load/initialize the demo scene.\n    const std::string obj_dir = switchboard_-&gt;get_env(\"ILLIXR_DEMO_DATA\");\n    if (obj_dir.empty()) {\n        ILLIXR::abort(\"Please define ILLIXR_DEMO_DATA.\");\n    }\n\n    demo_scene_ = ObjScene(std::string(obj_dir), \"scene.obj\");\n    headset_    = ObjScene(std::string(obj_dir), \"headset.obj\");\n\n    // Generate fun test pattern for missing camera images.\n    for (unsigned x = 0; x &lt; TEST_PATTERN_WIDTH; x++) {\n        for (unsigned y = 0; y &lt; TEST_PATTERN_HEIGHT; y++) {\n            test_pattern_[x][y] = ((x + y) % 6 == 0) ? 255 : 0;\n        }\n    }\n\n    glGenTextures(2, &amp;(camera_texture_[0]));\n    glBindTexture(GL_TEXTURE_2D, camera_texture_[0]);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glBindTexture(GL_TEXTURE_2D, camera_texture_[1]);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    glGenTextures(2, &amp;(rgb_depth_texture_[0]));\n    glBindTexture(GL_TEXTURE_2D, rgb_depth_texture_[0]);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glBindTexture(GL_TEXTURE_2D, rgb_depth_texture_[1]);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    // Construct a basic perspective projection\n    math_util::projection_fov(&amp;basic_projection_, 40.0f, 40.0f, 40.0f, 40.0f, 0.03f, 20.0f);\n\n    glfwMakeContextCurrent(nullptr);\n    threadloop::start();\n\n    RAC_ERRNO_MSG(\"debuview at bottom of start()\");\n}\n\ndebugview::~debugview() {\n    RAC_ERRNO_MSG(\"debugview at start of destructor\");\n\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplGlfw_Shutdown();\n    ImGui::DestroyContext();\n\n    glfwDestroyWindow(gui_window_);\n\n    RAC_ERRNO_MSG(\"debugview during destructor\");\n\n    // If the display backend is GLFW, it will terminate the GLFW context.\n    // Otherwise, GLFW should be terminated here.\n    if (!display_backend_manages_glfw_) {\n        glfwTerminate();\n    }\n}\n\nPLUGIN_MAIN(debugview)\n</code></pre>"},{"location":"api/plugins_2debugview_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; debugview &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Geometry&gt;</code></li> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/gl_util/obj.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> </ul>"},{"location":"api/plugins_2debugview_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2debugview_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class debugview"},{"location":"api/plugins_2debugview_2plugin_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t TEST_PATTERN_HEIGHT   = <code>256</code> constexpr size_t TEST_PATTERN_WIDTH   = <code>256</code>"},{"location":"api/plugins_2debugview_2plugin_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/plugins_2debugview_2plugin_8hpp/#variable-test_pattern_height","title":"variable TEST_PATTERN_HEIGHT","text":"<pre><code>constexpr size_t TEST_PATTERN_HEIGHT;\n</code></pre>"},{"location":"api/plugins_2debugview_2plugin_8hpp/#variable-test_pattern_width","title":"variable TEST_PATTERN_WIDTH","text":"<pre><code>constexpr size_t TEST_PATTERN_WIDTH;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/debugview/plugin.hpp</code></p>"},{"location":"api/plugins_2debugview_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; debugview &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;eigen3/Eigen/Core&gt;\n#include &lt;eigen3/Eigen/Geometry&gt;\n\n// clang-format off\n#include &lt;GL/glew.h&gt;    // GLEW has to be loaded before other GL libraries\n#include &lt;GLFW/glfw3.h&gt; // Also loading first, just to be safe\n// clang-format on\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/gl_util/obj.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nconstexpr size_t TEST_PATTERN_WIDTH  = 256;\nconstexpr size_t TEST_PATTERN_HEIGHT = 256;\n\nnamespace ILLIXR {\nclass debugview : public threadloop {\npublic:\n    // Public constructor, Spindle passes the phonebook to this\n    // constructor. In turn, the constructor fills in the private\n    // references to the switchboard plugs, so the plugin can read\n    // the data whenever it needs to.\n\n    [[maybe_unused]] debugview(const std::string&amp; name, phonebook* pb);\n\n    void draw_GUI();\n\n    bool load_camera_images();\n\n    bool load_rgb_depth();\n\n    static Eigen::Matrix4f generate_headset_transform(const Eigen::Vector3f&amp; position, const Eigen::Quaternionf&amp; rotation,\n                                                      const Eigen::Vector3f&amp; position_offset);\n\n    void _p_thread_setup() override;\n\n    void _p_one_iteration() override;\n\n    /* compatibility interface */\n    // Debug view application overrides _p_start to control its own lifecycle/scheduling.\n    void start() override;\n\n    ~debugview() override;\n\nprivate:\n    // GLFWwindow * const glfw_context;\n    const std::shared_ptr&lt;switchboard&gt;                  switchboard_;\n    const std::shared_ptr&lt;data_format::pose_prediction&gt; pose_prediction_;\n\n    const bool display_backend_manages_glfw_;\n\n    switchboard::reader&lt;data_format::pose_type&gt;                   slow_pose_reader_;\n    switchboard::reader&lt;data_format::imu_raw_type&gt;                fast_pose_reader_;\n    switchboard::reader&lt;data_format::rgb_depth_type&gt;              rgb_depth_reader_;\n    switchboard::buffered_reader&lt;data_format::binocular_cam_type&gt; cam_reader_;\n\n    GLFWwindow* gui_window_{};\n\n    [[maybe_unused]] uint8_t test_pattern_[TEST_PATTERN_WIDTH][TEST_PATTERN_HEIGHT]{};\n\n    Eigen::Vector3d view_euler_          = Eigen::Vector3d::Zero();\n    Eigen::Vector2d last_mouse_position_ = Eigen::Vector2d::Zero();\n    Eigen::Vector2d mouse_velocity_      = Eigen::Vector2d::Zero();\n    bool            being_dragged_       = false;\n\n    float view_distance_ = 2.0;\n\n    bool follow_headset_ = true;\n\n    Eigen::Vector3f tracking_position_offset_ = Eigen::Vector3f{0.0f, 0.0f, 0.0f};\n\n    switchboard::ptr&lt;const data_format::binocular_cam_type&gt; cam_;\n    switchboard::ptr&lt;const data_format::rgb_depth_type&gt;     rgb_depth_;\n    bool                                                    use_cam_       = false;\n    bool                                                    use_rgb_depth_ = false;\n\n    GLuint                           camera_texture_[2]{};\n    Eigen::Vector2i                  camera_texture_size_[2] = {Eigen::Vector2i::Zero(), Eigen::Vector2i::Zero()};\n    GLuint                           rgb_depth_texture_[2]{};\n    [[maybe_unused]] Eigen::Vector2i rgbd_texture_size_[2] = {Eigen::Vector2i::Zero(), Eigen::Vector2i::Zero()};\n\n    GLuint demo_vao_{};\n    GLuint demo_shader_program_{};\n\n    [[maybe_unused]] GLuint vertex_pos_attr{};\n    [[maybe_unused]] GLuint vertex_normal_attr_{};\n    GLuint                  model_view_attr_{};\n    GLuint                  projection_attr_{};\n\n    [[maybe_unused]] GLuint color_uniform_{};\n\n    ObjScene demo_scene_;\n    ObjScene headset_;\n\n    Eigen::Matrix4f basic_projection_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2depthai_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2depthai_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name add_library (${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.)  get_external_for_plugin (DepthAI)"},{"location":"api/plugins_2depthai_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2depthai_2CMakeLists_8txt/#function-add_library","title":"function add_library","text":"<pre><code>add_library (\n    ${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.\n) \n</code></pre>"},{"location":"api/plugins_2depthai_2CMakeLists_8txt/#function-get_external_for_plugin","title":"function get_external_for_plugin","text":"<pre><code>get_external_for_plugin (\n    DepthAI\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/depthai/CMakeLists.txt</code></p>"},{"location":"api/plugins_2depthai_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the depthai ILLIXR plugin\n\nget_external_for_plugin(DepthAI)\n\nset(PLUGIN_NAME plugin.depthai${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n        )\nadd_definitions(-Wno-format-extra-args)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${DepthAI_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\n# if we are building DepthAI from source\nif(DepthAI_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} DepthAI_ext cleanup_depthai_spdlog)\n    target_link_libraries(${PLUGIN_NAME} PUBLIC ${DEPENDENCIES} ${OpenCV_LIBRARIES} PRIVATE ${DepthAI_LIBRARIES} spdlog::spdlog)\nelse()  # DepthAI already installed\n    target_link_libraries(${PLUGIN_NAME} PUBLIC ${DEPENDENCIES} ${OpenCV_LIBRARIES} PRIVATE depthai::core)\nendif()\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2depthai_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; depthai &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/depthai/plugin.cpp</code></p>"},{"location":"api/plugins_2depthai_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; depthai &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// ILLIXR includes\n#include \"plugin.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;eigen3/Eigen/Core&gt;\n#include &lt;functional&gt;\n#include &lt;mutex&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;string&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] depthai::depthai(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , imu_writer_{switchboard_-&gt;get_writer&lt;imu_type&gt;(\"imu\")}\n    , cam_writer_{switchboard_-&gt;get_writer&lt;binocular_cam_type&gt;(\"cam\")}\n    , rgb_depth_{switchboard_-&gt;get_writer&lt;rgb_depth_type&gt;(\"rgb_depth\")} // Initialize DepthAI pipeline and device\n    , device_{create_camera_pipeline()} {\n    spdlogger(switchboard_-&gt;get_env_char(\"DEPTHAI_LOG_LEVEL\"));\n#ifndef NDEBUG\n    spdlog::get(name)-&gt;debug(\"pipeline started\");\n#endif\n    color_queue_                           = device_.getOutputQueue(\"preview\", 1, false);\n    depth_queue_                           = device_.getOutputQueue(\"depth\", 1, false);\n    rectif_left_queue_                     = device_.getOutputQueue(\"rectified_left\", 1, false);\n    rectif_right_queue_                    = device_.getOutputQueue(\"rectified_right\", 1, false);\n    imu_queue_                             = device_.getOutputQueue(\"imu\", 1, false);\n    std::function&lt;void(void)&gt; imu_callback = [&amp;]() {\n        callback();\n    };\n    imu_queue_-&gt;addCallback(imu_callback);\n    test_time_point_ = std::chrono::steady_clock::now();\n}\n\nvoid depthai::callback() {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    // Check for available data\n    bool color_go      = color_queue_-&gt;has&lt;dai::ImgFrame&gt;();\n    bool depth_go      = depth_queue_-&gt;has&lt;dai::ImgFrame&gt;();\n    bool rectifL_go    = rectif_left_queue_-&gt;has&lt;dai::ImgFrame&gt;();\n    bool rectifR_go    = rectif_right_queue_-&gt;has&lt;dai::ImgFrame&gt;();\n    bool imu_packet_go = imu_queue_-&gt;has&lt;dai::IMUData&gt;();\n\n#ifndef NDEBUG\n    if (color_go) {\n        rgb_count_++;\n    }\n    if (depth_go) {\n        depth_count_++;\n    }\n    if (rectifL_go) {\n        left_count_++;\n    }\n    if (rectifR_go) {\n        right_count_++;\n    }\n#endif\n\n    if (rectifR_go &amp;&amp; rectifL_go &amp;&amp; depth_go &amp;&amp; color_go) {\n#ifndef NDEBUG\n        all_count_++;\n#endif\n        auto color_frame = color_queue_-&gt;tryGet&lt;dai::ImgFrame&gt;();\n        auto depth_frame = depth_queue_-&gt;tryGet&lt;dai::ImgFrame&gt;();\n        auto rectifL     = rectif_left_queue_-&gt;tryGet&lt;dai::ImgFrame&gt;();\n        auto rectifR     = rectif_right_queue_-&gt;tryGet&lt;dai::ImgFrame&gt;();\n\n        ullong cam_time = static_cast&lt;ullong&gt;(\n            std::chrono::time_point_cast&lt;std::chrono::nanoseconds&gt;(color_frame-&gt;getTimestamp()).time_since_epoch().count());\n        if (!first_cam_time_) {\n            first_cam_time_      = cam_time;\n            first_real_cam_time_ = clock_-&gt;now();\n        }\n\n        time_point cam_time_point{*first_real_cam_time_ + std::chrono::nanoseconds(cam_time - *first_cam_time_)};\n\n        cv::Mat color = cv::Mat(static_cast&lt;int&gt;(color_frame-&gt;getHeight()), static_cast&lt;int&gt;(color_frame-&gt;getWidth()), CV_8UC3,\n                                color_frame-&gt;getData().data());\n        cv::Mat rgb_out{color.clone()};\n        cv::Mat rectified_left_frame = cv::Mat(static_cast&lt;int&gt;(rectifL-&gt;getHeight()), static_cast&lt;int&gt;(rectifL-&gt;getWidth()),\n                                               CV_8UC1, rectifL-&gt;getData().data());\n        cv::Mat left_out{rectified_left_frame.clone()};\n        cv::flip(left_out, left_out, 1);\n        cv::Mat rectified_right_frame = cv::Mat(static_cast&lt;int&gt;(rectifR-&gt;getHeight()), static_cast&lt;int&gt;(rectifR-&gt;getWidth()),\n                                                CV_8UC1, rectifR-&gt;getData().data());\n        cv::Mat right_out{rectified_right_frame.clone()};\n        cv::flip(right_out, right_out, 1);\n\n        cv::Mat depth = cv::Mat(static_cast&lt;int&gt;(depth_frame-&gt;getHeight()), static_cast&lt;int&gt;(depth_frame-&gt;getWidth()), CV_16UC1,\n                                depth_frame-&gt;getData().data());\n        cv::Mat converted_depth;\n        depth.convertTo(converted_depth, CV_32FC1, 1000.f);\n\n        cam_writer_.put(cam_writer_.allocate&lt;binocular_cam_type&gt;({cam_time_point, cv::Mat{left_out}, cv::Mat{right_out}}));\n        rgb_depth_.put(rgb_depth_.allocate&lt;rgb_depth_type&gt;({cam_time_point, cv::Mat{rgb_out}, cv::Mat{converted_depth}}));\n    }\n\n    std::chrono::time_point&lt;std::chrono::steady_clock, std::chrono::steady_clock::duration&gt; gyro_ts;\n    Eigen::Vector3d                                                                         la;\n    Eigen::Vector3d                                                                         av;\n\n    if (imu_packet_go) {\n        auto imu_packet = imu_queue_-&gt;tryGet&lt;dai::IMUData&gt;();\n#ifndef NDEBUG\n        if (imu_packet_ == 0) {\n            first_packet_time_ = std::chrono::steady_clock::now();\n        }\n        imu_packet_++;\n#endif\n\n        auto imu_data = imu_packet-&gt;packets;\n        for (auto&amp; imu_datum : imu_data) {\n            gyro_ts = std::chrono::time_point_cast&lt;std::chrono::nanoseconds&gt;(imu_datum.gyroscope.timestamp.get());\n            if (gyro_ts &lt;= test_time_point_) {\n                return;\n            }\n            test_time_point_ = gyro_ts;\n            la               = {imu_datum.acceleroMeter.x, imu_datum.acceleroMeter.y, imu_datum.acceleroMeter.z};\n            av               = {imu_datum.gyroscope.x, imu_datum.gyroscope.y, imu_datum.gyroscope.z};\n        }\n\n        // Time as ullong (nanoseconds)\n        ullong imu_time = static_cast&lt;ullong&gt;(gyro_ts.time_since_epoch().count());\n        if (!first_imu_time_) {\n            first_imu_time_      = imu_time;\n            first_real_imu_time_ = clock_-&gt;now();\n        }\n\n        time_point imu_time_point{*first_real_imu_time_ + std::chrono::nanoseconds(imu_time - *first_imu_time_)};\n\n// Submit to switchboard\n#ifndef NDEBUG\n        imu_pub_++;\n#endif\n        imu_writer_.put(imu_writer_.allocate&lt;imu_type&gt;({\n            imu_time_point,\n            av,\n            la,\n        }));\n    }\n}\n\ndepthai::~depthai() {\n#ifndef NDEBUG\n    spdlog::get(name_)-&gt;debug(\"Destructor: Packets Received {} Published: IMU: {} RGB-D: {}\", imu_packet_, imu_pub_, rgbd_pub_);\n    auto dur = std::chrono::steady_clock::now() - first_packet_time_;\n    spdlog::get(name_)-&gt;debug(\"Time since first packet: {} ms\",\n                              std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).count());\n    spdlog::get(name_)-&gt;debug(\"RGB: {} Left: {} Right: {} Depth: {} All: {}\", rgb_count_, left_count_, right_count_,\n                              depth_count_, all_count_);\n#endif\n}\n\ndai::Pipeline depthai::create_camera_pipeline() const {\n#ifndef NDEBUG\n    spdlog::get(name_)-&gt;debug(\"creating pipeline\");\n#endif\n    dai::Pipeline p;\n\n    // IMU\n    auto imu      = p.create&lt;dai::node::IMU&gt;();\n    auto xout_imu = p.create&lt;dai::node::XLinkOut&gt;();\n    xout_imu-&gt;setStreamName(\"imu\");\n\n    // Enable raw readings at 500Hz for accel and gyro\n    if (use_raw_) {\n        imu-&gt;enableIMUSensor({dai::IMUSensor::ACCELEROMETER_RAW, dai::IMUSensor::GYROSCOPE_RAW}, 400);\n    } else {\n        imu-&gt;enableIMUSensor({dai::IMUSensor::ACCELEROMETER, dai::IMUSensor::GYROSCOPE_CALIBRATED}, 400);\n    }\n\n    // above this threshold packets will be sent in batch of X, if the host is not blocked\n    imu-&gt;setBatchReportThreshold(1);\n    // maximum number of IMU packets in a batch, if it's reached device will block sending until host can receive it\n    // if lower or equal to batchReportThreshold then the sending is always blocking on device\n    imu-&gt;setMaxBatchReports(1);\n    // WARNING, temporarily 6 is the max\n\n    // Link plugins CAM -&gt; XLINK\n    imu-&gt;out.link(xout_imu-&gt;input);\n\n    // Color Camera, default 30 FPS\n    auto color_cam = p.create&lt;dai::node::ColorCamera&gt;();\n    auto xlink_out = p.create&lt;dai::node::XLinkOut&gt;();\n    xlink_out-&gt;setStreamName(\"preview\");\n\n    color_cam-&gt;setPreviewSize(640, 480);\n    color_cam-&gt;setResolution(dai::ColorCameraProperties::SensorResolution::THE_1080_P);\n    color_cam-&gt;setInterleaved(true);\n\n    // Link plugins CAM -&gt; XLINK\n    color_cam-&gt;preview.link(xlink_out-&gt;input);\n\n    // Mono Cameras\n    auto mono_left  = p.create&lt;dai::node::MonoCamera&gt;();\n    auto mono_right = p.create&lt;dai::node::MonoCamera&gt;();\n    // MonoCamera\n    mono_left-&gt;setResolution(dai::MonoCameraProperties::SensorResolution::THE_400_P);\n    mono_left-&gt;setBoardSocket(dai::CameraBoardSocket::LEFT);\n    mono_left-&gt;setFps(30.0);\n    mono_right-&gt;setResolution(dai::MonoCameraProperties::SensorResolution::THE_400_P);\n    mono_right-&gt;setBoardSocket(dai::CameraBoardSocket::RIGHT);\n    mono_right-&gt;setFps(30.0);\n\n    // Stereo Setup\n    //  Better handling for occlusions:\n    bool lrcheck = true;\n    // Closer-in minimum depth, disparity range is doubled (from 95 to 190):\n    bool extended = false;\n    // Better accuracy for longer distance, fractional disparity 32-levels:\n    bool subpixel = false;\n\n    /*\n    int max_disp = 96;\n    if (extended)\n        max_disp *= 2;\n    if (subpixel)\n        max_disp *= 32; // 5 bits fractional disparity\n    */\n    // StereoDepth\n    auto stereo       = p.create&lt;dai::node::StereoDepth&gt;();\n    auto xout_rectifL = p.create&lt;dai::node::XLinkOut&gt;();\n    auto xout_rectifR = p.create&lt;dai::node::XLinkOut&gt;();\n    auto xout_depth   = p.create&lt;dai::node::XLinkOut&gt;();\n\n    stereo-&gt;initialConfig.setConfidenceThreshold(200);\n    stereo-&gt;setLeftRightCheck(lrcheck);\n    stereo-&gt;setExtendedDisparity(extended);\n    stereo-&gt;setSubpixel(subpixel);\n\n    xout_depth-&gt;setStreamName(\"depth\");\n    xout_rectifL-&gt;setStreamName(\"rectified_left\");\n    xout_rectifR-&gt;setStreamName(\"rectified_right\");\n\n    stereo-&gt;rectifiedLeft.link(xout_rectifL-&gt;input);\n    stereo-&gt;rectifiedRight.link(xout_rectifR-&gt;input);\n\n    stereo-&gt;depth.link(xout_depth-&gt;input);\n    // Link plugins CAM -&gt; STEREO -&gt; XLINK\n    mono_left-&gt;out.link(stereo-&gt;left);\n    mono_right-&gt;out.link(stereo-&gt;right);\n\n    return p;\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(depthai)\n</code></pre>"},{"location":"api/plugins_2depthai_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; depthai &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include &lt;depthai/depthai.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2depthai_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2depthai_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class depthai <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/depthai/plugin.hpp</code></p>"},{"location":"api/plugins_2depthai_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; depthai &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n#include &lt;depthai/depthai.hpp&gt;\n\nnamespace ILLIXR {\nclass depthai : public plugin {\npublic:\n    [[maybe_unused]] depthai(const std::string&amp; name, phonebook* pb);\n    void callback();\n\n    ~depthai() override;\n\nprivate:\n    dai::Pipeline create_camera_pipeline() const;\n\n    const std::shared_ptr&lt;switchboard&gt;                   switchboard_;\n    const std::shared_ptr&lt;const relative_clock&gt;          clock_;\n    switchboard::writer&lt;data_format::imu_type&gt;           imu_writer_;\n    switchboard::writer&lt;data_format::binocular_cam_type&gt; cam_writer_;\n    switchboard::writer&lt;data_format::rgb_depth_type&gt;     rgb_depth_;\n    std::mutex                                           mutex_;\n\n#ifndef NDEBUG\n    int imu_packet_{0};\n    int imu_pub_{0};\n    int rgbd_pub_{0};\n    int rgb_count_{0};\n    int left_count_{0};\n    int right_count_{0};\n    int depth_count_{0};\n    int all_count_{0};\n#endif\n    std::chrono::time_point&lt;std::chrono::steady_clock&gt;                                      first_packet_time_;\n    std::chrono::time_point&lt;std::chrono::steady_clock, std::chrono::steady_clock::duration&gt; test_time_point_;\n    bool                                                                                    use_raw_ = false;\n    dai::Device                                                                             device_;\n\n    std::shared_ptr&lt;dai::DataOutputQueue&gt; color_queue_;\n    std::shared_ptr&lt;dai::DataOutputQueue&gt; depth_queue_;\n    std::shared_ptr&lt;dai::DataOutputQueue&gt; rectif_left_queue_;\n    std::shared_ptr&lt;dai::DataOutputQueue&gt; rectif_right_queue_;\n    std::shared_ptr&lt;dai::DataOutputQueue&gt; imu_queue_;\n\n    std::optional&lt;ullong&gt;     first_imu_time_;\n    std::optional&lt;time_point&gt; first_real_imu_time_;\n\n    std::optional&lt;ullong&gt;     first_cam_time_;\n    std::optional&lt;time_point&gt; first_real_cam_time_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2gldemo_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2gldemo_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.gldemo${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2gldemo_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2gldemo_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.gldemo${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/CMakeLists.txt</code></p>"},{"location":"api/plugins_2gldemo_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the gldemo ILLIXR plugin\n\nset(PLUGIN_NAME plugin.gldemo${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/shaders/demo_shader.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/frame.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/error_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/extended_window.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/gl_util/obj.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/math_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/shader_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${gl_LIBRARIES}  ${Eigen3_LIBRARIES} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2gldemo_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/README.md</code></p>"},{"location":"api/plugins_2gldemo_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># gldemo\n\n## Summary\n\nThe `gldemo` plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application\nwithout an actual OpenXR application. `gldemo` will subscribe to several [_switchboard_][G10] plugs, render a simple,\nhard-coded 3D scene (in fact, the same 3D scene that is included in the [`debugview`][P10] plugin) and publish the\nresults to the Switchboard API. `gldemo` is intended to be as lightweight as possible, serving as a baseline debug \"\ndummy application\". During development, it is useful to have some content being published to the HMD display without\nneeding to use the full OpenXR interface; `gldemo` fills this requirement. As an important note, `gldemo` does not\nrender stereoscopically; the two eye renders are rendered from the same position. This may be updated to render\nstereoscopically in the future, but is not seen as a critical feature as this is generally intended as a debugging tool.\n\n## Switchboard connection\n\n`gldemo` subscribes to and publishes to several [_switchboard_][G10] plugs. Most notably, `gldemo` subscribes to the\n`fast_pose` plug, which (ideally) represents the most recent extrapolated pose. This connection represents an area of\nactive development in ILLIXR, as we are replacing the pose subscription with an RPC-like proper pose prediction system.\nAs of the time of writing, `fast_pose` is functionally identical to the `slow_pose` published by the SLAM system, but\nthis will change when proper pose extrapolation is implemented. `gldemo` also pulls the correct graphics context from\nPhonebook.\n\n`gldemo` publishes the rendered eyebuffers to the Switchboard system as well, using whichever eyebuffer format has been\nselected with the `USE_ALT_EYE_FORMAT` compile-time macro. The alternative eye format is more similar to the format used\nby Monado/OpenXR, and is more fully explained by the code comments.\n\n## Environment Variables\n\n**GLDEMO_LOG_LEVEL**: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"\ncritical\", or \"off\"\n\n## Notes\n\n`gldemo` does not pretend to be an OpenXR application; it does not use the OpenXR API, nor does it follow typical OpenXR\npatterns. It hooks directly into the Switchboard system and is intended as a debug/visualization tool. For more accurate\nand representative testing, consider running ILLIXR with an actual OpenXR application.\n\n## Known Issues\n\nAs noted above, `gldemo` does not actually render stereoscopically, and the two eye buffers are rendered from the same\neye location. (This is not to say that the two eye buffers are not rendered separately; they are actually two separate\ndraw calls.) In addition, the quality of the pose used by `gldemo` is dependent on the upstream pose, which is currently\nnot extrapolated/predicted and is subject to change.\n\n## Contributions\n\nContributions are welcome; please raise an issue first, though, as many issues are known and are a part of our existing\ninternal backlog.\n\n[//]: # (- glossary -)\n\n[G10]:   ../glossary.md#switchboard\n\n[//]: # (- plugins -)\n\n[P10]:   ../illixr_plugins.md#debugview\n</code></pre>"},{"location":"api/plugins_2gldemo_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; gldemo &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/math_util.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/plugins_2gldemo_2plugin_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr std::chrono::milliseconds VSYNC_SAFETY_DELAY   = <code>{1}</code>"},{"location":"api/plugins_2gldemo_2plugin_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/plugins_2gldemo_2plugin_8cpp/#variable-vsync_safety_delay","title":"variable VSYNC_SAFETY_DELAY","text":"<pre><code>constexpr std::chrono::milliseconds VSYNC_SAFETY_DELAY;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/plugin.cpp</code></p>"},{"location":"api/plugins_2gldemo_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; gldemo &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// clang-format off\n#include &lt;GL/glew.h&gt; // GLEW has to be loaded before other GL libraries\n// clang-format on\n\n#include \"plugin.hpp\"\n\n#include \"illixr/error_util.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/math_util.hpp\"\n\n#include &lt;array&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;eigen3/Eigen/Core&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n// Wake up 1 ms after vsync instead of exactly at vsync to account for scheduling uncertainty\nstatic constexpr std::chrono::milliseconds VSYNC_SAFETY_DELAY{1};\n\n[[maybe_unused]] gldemo::gldemo(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , ext_window_{new xlib_gl_extended_window{1, 1, phonebook_-&gt;lookup_impl&lt;xlib_gl_extended_window&gt;()-&gt;context_}}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , pose_prediction_{phonebook_-&gt;lookup_impl&lt;pose_prediction&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , vsync_{switchboard_-&gt;get_reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\")}\n    , image_handle_{switchboard_-&gt;get_writer&lt;image_handle&gt;(\"image_handle\")}\n    , eye_buffer_{switchboard_-&gt;get_writer&lt;rendered_frame&gt;(\"eyebuffer\")} {\n    spdlogger(switchboard_-&gt;get_env_char(\"GLDEMO_LOG_LEVEL\"));\n}\n\n// Essentially, a crude equivalent of XRWaitFrame.\nvoid gldemo::wait_vsync() {\n    switchboard::ptr&lt;const switchboard::event_wrapper&lt;time_point&gt;&gt; next_vsync = vsync_.get_ro_nullable();\n    time_point                                                     now        = clock_-&gt;now();\n    time_point                                                     wait_time{};\n\n    if (next_vsync == nullptr) {\n        // If no vsync data available, just sleep for roughly a vsync period.\n        // We'll get synced back up later.\n        std::this_thread::sleep_for(display_params::period);\n        return;\n    }\n\n#ifndef NDEBUG\n    if (log_count_ &gt; LOG_PERIOD) {\n        double vsync_in = duration_to_double&lt;std::milli&gt;(**next_vsync - now);\n        spdlog::get(name_)-&gt;debug(\"First vsync is in {} ms\", vsync_in);\n    }\n#endif\n\n    bool has_rendered_this_interval = (now - last_time_) &lt; display_params::period;\n\n    // If less than one frame interval has passed since we last rendered...\n    if (has_rendered_this_interval) {\n        // We'll wait until the next vsync, plus a small delay time.\n        // Delay time helps with some inaccuracies in scheduling.\n        wait_time = **next_vsync + VSYNC_SAFETY_DELAY;\n\n        // If our sleep target is in the past, bump it forward\n        // by a vsync period, so it's always in the future.\n        while (wait_time &lt; now) {\n            wait_time += display_params::period;\n        }\n\n#ifndef NDEBUG\n        if (log_count_ &gt; LOG_PERIOD) {\n            double wait_in = duration_to_double&lt;std::milli&gt;(wait_time - now);\n            spdlog::get(name_)-&gt;debug(\"Waiting until next vsync, in {} ms\", wait_in);\n        }\n#endif\n        // Perform the sleep.\n        // TODO: Consider using Monado-style sleeping, where we nanosleep for\n        // most of the wait, and then spin-wait for the rest?\n        std::this_thread::sleep_for(wait_time - now);\n    } else {\n#ifndef NDEBUG\n        if (log_count_ &gt; LOG_PERIOD) {\n            spdlog::get(name_)-&gt;debug(\"We haven't rendered yet, rendering immediately\");\n        }\n#endif\n    }\n}\n\nvoid gldemo::_p_thread_setup() {\n    last_time_ = clock_-&gt;now();\n\n    // Note: glXMakeContextCurrent must be called from the thread which will be using it.\n    [[maybe_unused]] const bool gl_result =\n        static_cast&lt;bool&gt;(glXMakeCurrent(ext_window_-&gt;display_, ext_window_-&gt;window_, ext_window_-&gt;context_));\n    assert(gl_result &amp;&amp; \"glXMakeCurrent should not fail\");\n}\n\nvoid gldemo::_p_one_iteration() {\n    // Essentially, XRWaitFrame.\n    wait_vsync();\n\n    glUseProgram(demo_shader_program_);\n    glBindFramebuffer(GL_FRAMEBUFFER, eye_texture_FBO_);\n\n    glUseProgram(demo_shader_program_);\n    glBindVertexArray(demo_vao_);\n    glViewport(0, 0, display_params::width_pixels, display_params::height_pixels);\n\n    glEnable(GL_CULL_FACE);\n    glEnable(GL_DEPTH_TEST);\n\n    glClearDepth(1);\n\n    Eigen::Matrix4f model_matrix = Eigen::Matrix4f::Identity();\n\n    const fast_pose_type fast_pose = pose_prediction_-&gt;get_fast_pose();\n    pose_type            pose      = fast_pose.pose;\n\n    Eigen::Matrix3f head_rotation_matrix = pose.orientation.toRotationMatrix();\n\n    // Excessive? Maybe.\n    constexpr int LEFT_EYE = 0;\n\n    for (auto eye_idx = 0; eye_idx &lt; 2; eye_idx++) {\n        // Offset of eyeball from pose\n        auto eyeball = Eigen::Vector3f((eye_idx == LEFT_EYE ? -display_params::ipd / 2.0f : display_params::ipd / 2.0f), 0, 0);\n\n        // Apply head rotation to eyeball offset vector\n        eyeball = head_rotation_matrix * eyeball;\n\n        // Apply head position to eyeball\n        eyeball += pose.position;\n\n        // Build our eye matrix from the pose's position + orientation.\n        Eigen::Matrix4f eye_matrix   = Eigen::Matrix4f::Identity();\n        eye_matrix.block&lt;3, 1&gt;(0, 3) = eyeball; // Set position to eyeball's position\n        eye_matrix.block&lt;3, 3&gt;(0, 0) = pose.orientation.toRotationMatrix();\n\n        // Objects' \"view matrix\" is inverse of eye matrix.\n        auto view_matrix = eye_matrix.inverse();\n\n        // We'll calculate this model view matrix\n        // using fresh pose data, if we have any.\n        Eigen::Matrix4f model_view_matrix = view_matrix * model_matrix;\n        glUniformMatrix4fv(static_cast&lt;GLint&gt;(model_view_), 1, GL_FALSE, (GLfloat*) (model_view_matrix.data()));\n        glUniformMatrix4fv(static_cast&lt;GLint&gt;(projection_), 1, GL_FALSE, (GLfloat*) (basic_projection_.data()));\n\n        glBindTexture(GL_TEXTURE_2D, eye_textures_[eye_idx]);\n        glFramebufferTexture(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, eye_textures_[eye_idx], 0);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glClearColor(0.9f, 0.9f, 0.9f, 1.0f);\n\n        RAC_ERRNO_MSG(\"gldemo before glClear\");\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        RAC_ERRNO_MSG(\"gldemo after glClear\");\n\n        demo_scene_.Draw();\n    }\n\n    glFinish();\n\n#ifndef NDEBUG\n    const double frame_duration_s = duration_to_double(clock_-&gt;now() - last_time_);\n    const double fps              = 1.0 / frame_duration_s;\n\n    if (log_count_ &gt; LOG_PERIOD) {\n        spdlog::get(name_)-&gt;debug(\"Submitting frame to buffer {}, frametime: {}, FPS: {}\", which_buffer_, frame_duration_s,\n                                  fps);\n    }\n#endif\n    last_time_ = clock_-&gt;now();\n\n    eye_buffer_.put(eye_buffer_.allocate&lt;rendered_frame&gt;(rendered_frame{\n        // Somehow, C++ won't let me construct this object if I remove the `rendered_frame{` and `}`.\n        // `allocate&lt;rendered_frame&gt;(...)` _should_ forward the arguments to rendered_frame's constructor, but I guess\n        // not.\n        std::array&lt;GLuint, 2&gt;{0, 0}, std::array&lt;GLuint, 2&gt;{which_buffer_, which_buffer_}, fast_pose,\n        fast_pose.predict_computed_time, last_time_}));\n\n    which_buffer_ = !which_buffer_;\n\n#ifndef NDEBUG\n    if (log_count_ &gt; LOG_PERIOD) {\n        log_count_ = 0;\n    } else {\n        log_count_++;\n    }\n#endif\n}\n\n// We override start() to control our own lifecycle\nvoid gldemo::start() {\n    [[maybe_unused]] const bool gl_result_0 =\n        static_cast&lt;bool&gt;(glXMakeCurrent(ext_window_-&gt;display_, ext_window_-&gt;window_, ext_window_-&gt;context_));\n    assert(gl_result_0 &amp;&amp; \"glXMakeCurrent should not fail\");\n\n    // Init and verify GLEW\n    const GLenum glew_err = glewInit();\n    if (glew_err != GLEW_OK) {\n        spdlog::get(name_)-&gt;error(\"GLEW Error: {}\", (void*) glewGetErrorString(glew_err));\n        ILLIXR::abort(\"Failed to initialize GLEW\");\n    }\n\n    glEnable(GL_DEBUG_OUTPUT);\n    glDebugMessageCallback(message_callback, nullptr);\n\n    // Create two shared textures, one for each eye.\n    create_shared_eyebuffer(&amp;(eye_textures_[0]));\n    image_handle_.put(image_handle_.allocate&lt;image_handle&gt;(image_handle{eye_textures_[0], 1, swapchain_usage::LEFT_SWAPCHAIN}));\n    create_shared_eyebuffer(&amp;(eye_textures_[1]));\n    image_handle_.put(\n        image_handle_.allocate&lt;image_handle&gt;(image_handle{eye_textures_[1], 1, swapchain_usage::RIGHT_SWAPCHAIN}));\n\n    // Initialize FBO and depth targets, attaching to the frame handle\n    create_FBO(&amp;(eye_textures_[0]), &amp;eye_texture_FBO_, &amp;eye_texture_depth_target_);\n\n    // Create and bind global VAO object\n    glGenVertexArrays(1, &amp;demo_vao_);\n    glBindVertexArray(demo_vao_);\n\n    demo_shader_program_ = init_and_link(demo_vertex_shader, demo_fragment_shader);\n#ifndef NDEBUG\n    spdlog::get(name_)-&gt;debug(\"Demo app shader program is program {}\", demo_shader_program_);\n#endif\n\n    vertex_position_ = glGetAttribLocation(demo_shader_program_, \"vertexPosition\");\n    vertex_normal_   = glGetAttribLocation(demo_shader_program_, \"vertexNormal\");\n    model_view_      = glGetUniformLocation(demo_shader_program_, \"u_modelview\");\n    projection_      = glGetUniformLocation(demo_shader_program_, \"u_projection\");\n    color_uniform_   = glGetUniformLocation(demo_shader_program_, \"u_color\");\n\n    // Load/initialize the demo scene\n    const char* obj_dir = switchboard_-&gt;get_env_char(\"ILLIXR_DEMO_DATA\");\n    if (obj_dir == nullptr) {\n        ILLIXR::abort(\"Please define ILLIXR_DEMO_DATA.\");\n    }\n\n    demo_scene_ = ObjScene(std::string(obj_dir), \"scene.obj\");\n\n    // Construct perspective projection matrix\n    math_util::projection_fov(&amp;basic_projection_, display_params::fov_x / 2.0f, display_params::fov_x / 2.0f,\n                              display_params::fov_y / 2.0f, display_params::fov_y / 2.0f, rendering_params::near_z,\n                              rendering_params::far_z);\n\n    [[maybe_unused]] const bool gl_result_1 = static_cast&lt;bool&gt;(glXMakeCurrent(ext_window_-&gt;display_, None, nullptr));\n    assert(gl_result_1 &amp;&amp; \"glXMakeCurrent should not fail\");\n\n    // Effectively, last vsync was at zero.\n    // Try to run gldemo right away.\n    threadloop::start();\n}\n\nvoid gldemo::create_shared_eyebuffer(GLuint* texture_handle) {\n    // Create the shared eye texture handle\n    glGenTextures(1, texture_handle);\n    glBindTexture(GL_TEXTURE_2D, *texture_handle);\n\n    // Set the texture parameters for the texture that the FBO will be mapped into\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, display_params::width_pixels, display_params::height_pixels, 0, GL_RGB,\n                 GL_UNSIGNED_BYTE, nullptr);\n\n    // Unbind texture\n    glBindTexture(GL_TEXTURE_2D, 0);\n}\n\nvoid gldemo::create_FBO(const GLuint* texture_handle, GLuint* fbo, GLuint* depth_target) {\n    // Create a framebuffer to draw some things to the eye texture\n    glGenFramebuffers(1, fbo);\n\n    // Bind the FBO as the active framebuffer\n    glBindFramebuffer(GL_FRAMEBUFFER, *fbo);\n    glGenRenderbuffers(1, depth_target);\n    glBindRenderbuffer(GL_RENDERBUFFER, *depth_target);\n    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, display_params::width_pixels, display_params::height_pixels);\n    // glRenderbufferStorageMultisample(GL_RENDERBUFFER, fboSampleCount, GL_DEPTH_COMPONENT, display_params::width_pixels,\n    // display_params::height_pixels);\n\n    glBindRenderbuffer(GL_RENDERBUFFER, 0);\n\n    // Bind eyebuffer texture\n    spdlog::get(name_)-&gt;info(\"About to bind eyebuffer texture, texture handle: {}\", *texture_handle);\n\n    glBindTexture(GL_TEXTURE_2D, *texture_handle);\n    glFramebufferTexture(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, *texture_handle, 0);\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    // attach a renderbuffer to depth attachment point\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, *depth_target);\n\n    // Unbind FBO\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n}\n\nPLUGIN_MAIN(gldemo)\n</code></pre>"},{"location":"api/plugins_2gldemo_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; gldemo &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/frame.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/extended_window.hpp\"</code></li> <li><code>#include \"illixr/gl_util/obj.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/shader_util.hpp\"</code></li> <li><code>#include \"illixr/shaders/demo_shader.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> </ul>"},{"location":"api/plugins_2gldemo_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2gldemo_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class gldemo <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gldemo/plugin.hpp</code></p>"},{"location":"api/plugins_2gldemo_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; gldemo &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/frame.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/extended_window.hpp\"\n#include \"illixr/gl_util/obj.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/shader_util.hpp\"\n#include \"illixr/shaders/demo_shader.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nnamespace ILLIXR {\n\n#ifndef NDEBUG\nsize_t       log_count_ = 0;\nconst size_t LOG_PERIOD = 20;\n#endif\n\nclass gldemo : public threadloop {\npublic:\n    // Public constructor, create_component passes Switchboard handles (\"plugs\")\n    // to this constructor. In turn, the constructor fills in the private\n    // references to the switchboard plugs, so the component can read the\n    // data whenever it needs to.\n    [[maybe_unused]] gldemo(const std::string&amp; name, phonebook* pb);\n    void wait_vsync();\n    void _p_thread_setup() override;\n    void _p_one_iteration() override;\n    void start() override;\n\nprivate:\n    static void create_shared_eyebuffer(GLuint* texture_handle);\n    void        create_FBO(const GLuint* texture_handle, GLuint* fbo, GLuint* depth_target);\n\n    const std::unique_ptr&lt;const xlib_gl_extended_window&gt;              ext_window_;\n    const std::shared_ptr&lt;switchboard&gt;                                switchboard_;\n    const std::shared_ptr&lt;data_format::pose_prediction&gt;               pose_prediction_;\n    const std::shared_ptr&lt;const relative_clock&gt;                       clock_;\n    const switchboard::reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_;\n\n    // Switchboard plug for application eye buffer.\n    // We're not \"writing\" the actual buffer data,\n    // we're just atomically writing the handle to the\n    // correct eye/framebuffer in the \"swapchain\".\n    switchboard::writer&lt;data_format::image_handle&gt;   image_handle_;\n    switchboard::writer&lt;data_format::rendered_frame&gt; eye_buffer_;\n\n    GLuint eye_textures_[2]{};\n    GLuint eye_texture_FBO_{};\n    GLuint eye_texture_depth_target_{};\n\n    unsigned char which_buffer_ = 0;\n\n    GLuint demo_vao_{};\n    GLuint demo_shader_program_{};\n\n    [[maybe_unused]] GLuint vertex_position_{};\n    [[maybe_unused]] GLuint vertex_normal_{};\n    GLuint                  model_view_{};\n    GLuint                  projection_{};\n\n    [[maybe_unused]] GLuint color_uniform_{};\n\n    ObjScene demo_scene_;\n\n    Eigen::Matrix4f basic_projection_;\n\n    time_point last_time_{};\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2ground__truth__slam_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.ground_truth_slam${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2ground__truth__slam_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2ground__truth__slam_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.ground_truth_slam${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/ground_truth_slam/CMakeLists.txt</code></p>"},{"location":"api/plugins_2ground__truth__slam_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the ground_truth_slam ILLIXR plugin\n\nset(PLUGIN_NAME plugin.ground_truth_slam${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_loading.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/csv_iterator.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n        )\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${Eigen3_LIBRARIES} spdlog::spdlog)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; ground_truth_slam &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/data_loading.hpp\"</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::map&lt; ullong, pose_type &gt; read_data (std::ifstream &amp; gt_file, const std::string &amp; file_name)"},{"location":"api/plugins_2ground__truth__slam_2plugin_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2ground__truth__slam_2plugin_8cpp/#function-read_data","title":"function read_data","text":"<pre><code>inline std::map&lt; ullong, pose_type &gt; read_data (\n    std::ifstream &amp; gt_file,\n    const std::string &amp; file_name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/ground_truth_slam/plugin.cpp</code></p>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; ground_truth_slam &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/data_loading.hpp\"\n\n#include &lt;utility&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\ninline std::map&lt;ullong, pose_type&gt; read_data(std::ifstream&amp; gt_file, const std::string&amp; file_name) {\n    (void) file_name;\n    std::map&lt;ullong, pose_type&gt; data;\n\n    for (csv_iterator row{gt_file, 1}; row != csv_iterator{}; ++row) {\n        ullong             t = std::stoull(row[0]);\n        Eigen::Vector3f    av{std::stof(row[1]), std::stof(row[2]), std::stof(row[3])};\n        Eigen::Quaternionf la{std::stof(row[4]), std::stof(row[5]), std::stof(row[6]), std::stof(row[7])};\n        data[t] = {{}, av, la};\n    }\n    return data;\n}\n\n[[maybe_unused]] ground_truth_slam::ground_truth_slam(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , true_pose_{switchboard_-&gt;get_writer&lt;pose_type&gt;(\"true_pose\")}\n    , ground_truth_offset_{switchboard_-&gt;get_writer&lt;switchboard::event_wrapper&lt;Eigen::Vector3f&gt;&gt;(\"ground_truth_offset\")}\n    , sensor_data_{load_data&lt;pose_type&gt;(\"state_groundtruth_estimate0\", \"ground_truth_slam\", &amp;read_data, switchboard_)}\n    // The relative-clock timestamp of each IMU is the difference between its dataset time and the IMU dataset_first_time.\n    // Therefore we need the IMU dataset_first_time to reproduce the real dataset time.\n    // TODO: Change the hardcoded number to be read from some configuration variables in the yaml file.\n    , dataset_first_time_{ViconRoom1Medium}\n    , first_time_{true} {\n    spdlogger(switchboard_-&gt;get_env_char(\"GROUND_TRUTH_SLAM_LOG_LEVEL\"));\n}\n\nvoid ground_truth_slam::start() {\n    plugin::start();\n    switchboard_-&gt;schedule&lt;imu_type&gt;(id_, \"imu\", [this](const switchboard::ptr&lt;const imu_type&gt;&amp; datum, std::size_t) {\n        this-&gt;feed_ground_truth(datum);\n    });\n}\n\nvoid ground_truth_slam::feed_ground_truth(const switchboard::ptr&lt;const imu_type&gt;&amp; datum) {\n    ullong rounded_time = datum-&gt;time.time_since_epoch().count() + dataset_first_time_;\n    auto   it           = sensor_data_.find(rounded_time);\n    if (it == sensor_data_.end()) {\n#ifndef NDEBUG\n        spdlog::get(name_)-&gt;debug(\"True pose not found at timestamp: {}\", rounded_time);\n#endif\n        return;\n    }\n\n    switchboard::ptr&lt;pose_type&gt; true_pose =\n        true_pose_.allocate&lt;pose_type&gt;(pose_type{time_point{datum-&gt;time}, it-&gt;second.position, it-&gt;second.orientation});\n\n#ifndef NDEBUG\n    spdlog::get(name_)-&gt;debug(\"Ground truth pose was found at T: {} | Pos: ({}, {}, {}) | Quat: ({}, {}, {}, {})\", rounded_time,\n                              true_pose-&gt;position[0], true_pose-&gt;position[1], true_pose-&gt;position[2],\n                              true_pose-&gt;orientation.w(), true_pose-&gt;orientation.x(), true_pose-&gt;orientation.y(),\n                              true_pose-&gt;orientation.z());\n#endif\n\n    if (first_time_) {\n        first_time_ = false;\n        ground_truth_offset_.put(ground_truth_offset_.allocate&lt;switchboard::event_wrapper&lt;Eigen::Vector3f&gt;&gt;(\n            switchboard::event_wrapper&lt;Eigen::Vector3f&gt;(true_pose-&gt;position)));\n    }\n\n    true_pose_.put(std::move(true_pose));\n}\n\nPLUGIN_MAIN(ground_truth_slam)\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; ground_truth_slam &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/data_loading.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> </ul>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class ground_truth_slam"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#macros","title":"Macros","text":"Type Name define ViconRoom1Difficult <code>1403715886544058112</code> define ViconRoom1Easy <code>1403715273262142976</code> define ViconRoom1Medium <code>1403715523912143104</code> define ViconRoom2Easy <code>1413393212225760512</code> define ViconRoom2Hard <code>1413394881555760384</code> define ViconRoom2Medium <code>1413393885975760384</code>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#define-viconroom1difficult","title":"define ViconRoom1Difficult","text":"<pre><code>#define ViconRoom1Difficult `1403715886544058112`\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#define-viconroom1easy","title":"define ViconRoom1Easy","text":"<pre><code>#define ViconRoom1Easy `1403715273262142976`\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#define-viconroom1medium","title":"define ViconRoom1Medium","text":"<pre><code>#define ViconRoom1Medium `1403715523912143104`\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#define-viconroom2easy","title":"define ViconRoom2Easy","text":"<pre><code>#define ViconRoom2Easy `1413393212225760512`\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#define-viconroom2hard","title":"define ViconRoom2Hard","text":"<pre><code>#define ViconRoom2Hard `1413394881555760384`\n</code></pre>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp/#define-viconroom2medium","title":"define ViconRoom2Medium","text":"<pre><code>#define ViconRoom2Medium `1413393885975760384`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/ground_truth_slam/plugin.hpp</code></p>"},{"location":"api/plugins_2ground__truth__slam_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; ground_truth_slam &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/data_loading.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\nnamespace ILLIXR {\n// These are the first IMU timestamp of the datasets. See line#31 for more info.\n#define ViconRoom1Easy      1403715273262142976\n#define ViconRoom1Medium    1403715523912143104\n#define ViconRoom1Difficult 1403715886544058112\n#define ViconRoom2Easy      1413393212225760512\n#define ViconRoom2Medium    1413393885975760384\n#define ViconRoom2Hard      1413394881555760384\n\ntypedef data_format::pose_type sensor_types;\n\nclass ground_truth_slam : public plugin {\npublic:\n    [[maybe_unused]] ground_truth_slam(const std::string&amp; name, phonebook* pb);\n    void start() override;\n    void feed_ground_truth(const switchboard::ptr&lt;const data_format::imu_type&gt;&amp; datum);\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;          switchboard_;\n    switchboard::writer&lt;data_format::pose_type&gt; true_pose_;\n\n    switchboard::writer&lt;switchboard::event_wrapper&lt;Eigen::Vector3f&gt;&gt; ground_truth_offset_;\n    const std::map&lt;ullong, sensor_types&gt;                             sensor_data_;\n    ullong                                                           dataset_first_time_;\n    bool                                                             first_time_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2gtsam__integrator_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name get_external_for_plugin (GTSAM)"},{"location":"api/plugins_2gtsam__integrator_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2gtsam__integrator_2CMakeLists_8txt/#function-get_external_for_plugin","title":"function get_external_for_plugin","text":"<pre><code>get_external_for_plugin (\n    GTSAM\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gtsam_integrator/CMakeLists.txt</code></p>"},{"location":"api/plugins_2gtsam__integrator_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the gtsam_integrator ILLIXR plugin\nget_external_for_plugin(GTSAM)\nset(PLUGIN_NAME plugin.gtsam_integrator${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\n# if GTSAM is being built from source\nif(GTSAM_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${GTSAM_DEP_STR})\nendif()\n\n#add_definitions(-Wall -Wextra -Werror)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${GTSAM_INCLUDE_DIR} ${EIGEN3_INCLUDE_DIR} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${GTSAM_LIBRARIES} ${Eigen3_LIBRARIES} spdlog::spdlog)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; gtsam_integrator &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;gtsam/base/Vector.h&gt;</code></li> <li><code>#include &lt;gtsam/navigation/AHRSFactor.h&gt;</code></li> <li><code>#include &lt;gtsam/navigation/ImuBias.h&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp/#public-types","title":"Public Types","text":"Type Name typedef gtsam::imuBias::ConstantBias ImuBias"},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr duration IMU_TTL   = <code>{std::chrono::seconds{5}}</code>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp/#typedef-imubias","title":"typedef ImuBias","text":"<pre><code>using ImuBias =  gtsam::imuBias::ConstantBias;\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp/#variable-imu_ttl","title":"variable IMU_TTL","text":"<pre><code>constexpr duration IMU_TTL;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gtsam_integrator/plugin.cpp</code></p>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; gtsam_integrator &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;gtsam/base/Vector.h&gt;\n#include &lt;gtsam/navigation/AHRSFactor.h&gt;\n#include &lt;gtsam/navigation/ImuBias.h&gt;\n#include &lt;iomanip&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n// IMU sample time to live in seconds\nconstexpr duration IMU_TTL{std::chrono::seconds{5}};\n\nusing ImuBias = gtsam::imuBias::ConstantBias;\n\n[[maybe_unused]] gtsam_integrator::gtsam_integrator(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , imu_integrator_input_{switchboard_-&gt;get_reader&lt;imu_integrator_input&gt;(\"imu_integrator_input\")}\n    , imu_raw_{switchboard_-&gt;get_writer&lt;imu_raw_type&gt;(\"imu_raw\")} {\n    spdlogger(switchboard_-&gt;get_env_char(\"GTSAM_INTEGRATOR_LOG_LEVEL\"));\n    switchboard_-&gt;schedule&lt;imu_type&gt;(id_, \"imu\", [&amp;](const switchboard::ptr&lt;const imu_type&gt;&amp; datum, size_t) {\n        callback(datum);\n    });\n    const double frequency  = 200.;\n    const double min_cutoff = 10.;\n    const double beta       = 1.;\n    const double d_cutoff   = 10.;\n\n    for (int i = 0; i &lt; 8; ++i) {\n        filters_.emplace_back(frequency, Eigen::Array&lt;double, 3, 1&gt;{min_cutoff, min_cutoff, min_cutoff},\n                              Eigen::Array&lt;double, 3, 1&gt;{beta, beta, beta},\n                              Eigen::Array&lt;double, 3, 1&gt;{d_cutoff, d_cutoff, d_cutoff}, Eigen::Array&lt;double, 3, 1&gt;::Zero(),\n                              Eigen::Array&lt;double, 3, 1&gt;::Ones(), [](auto&amp; in) {\n                                  return in.abs();\n                              });\n    }\n}\n\nvoid gtsam_integrator::callback(const switchboard::ptr&lt;const imu_type&gt;&amp; datum) {\n    imu_vector_.emplace_back(datum-&gt;time, datum-&gt;angular_v.cast&lt;double&gt;(), datum-&gt;linear_a.cast&lt;double&gt;());\n\n    clean_imu_vec(datum-&gt;time);\n    propagate_imu_values(datum-&gt;time);\n\n    RAC_ERRNO_MSG(\"gtsam_integrator\");\n}\n\ngtsam_integrator::pim_object::pim_object(const imu_int_t&amp; imu_int_input)\n    : imu_bias_{imu_int_input.bias_acc, imu_int_input.bias_gyro}\n    , pim_{nullptr} {\n    pim_t::Params params{imu_int_input.params.n_gravity};\n    params.setGyroscopeCovariance(std::pow(imu_int_input.params.gyro_noise, 2.0) * Eigen::Matrix3d::Identity());\n    params.setAccelerometerCovariance(std::pow(imu_int_input.params.acc_noise, 2.0) * Eigen::Matrix3d::Identity());\n    params.setIntegrationCovariance(std::pow(imu_int_input.params.imu_integration_sigma, 2.0) * Eigen::Matrix3d::Identity());\n    params.setBiasAccCovariance(std::pow(imu_int_input.params.acc_walk, 2.0) * Eigen::Matrix3d::Identity());\n    params.setBiasOmegaCovariance(std::pow(imu_int_input.params.gyro_walk, 2.0) * Eigen::Matrix3d::Identity());\n\n    pim_ = new pim_t{std::make_shared&lt;pim_t::Params&gt;(std::move(params)), imu_bias_};\n    reset_integration_and_set_bias(imu_int_input);\n}\n\ngtsam_integrator::pim_object::~pim_object() {\n    assert(pim_ != nullptr &amp;&amp; \"pim_ should not be null\");\n}\n\nvoid gtsam_integrator::pim_object::reset_integration_and_set_bias(const imu_int_t&amp; imu_int_input) noexcept {\n    assert(pim_ != nullptr &amp;&amp; \"pim_ should not be null\");\n\n    imu_bias_ = bias_t{imu_int_input.bias_acc, imu_int_input.bias_gyro};\n    pim_-&gt;resetIntegrationAndSetBias(imu_bias_);\n\n    nav_state_lkf_ = nav_t{gtsam::Pose3{gtsam::Rot3{imu_int_input.quat}, imu_int_input.position}, imu_int_input.velocity};\n}\n\nvoid gtsam_integrator::pim_object::integrate_measurement(const imu_t&amp; imu_input, const imu_t&amp; imu_input_next) noexcept {\n    assert(pim_ != nullptr &amp;&amp; \"pim_ shuold not be null\");\n\n    const gtsam::Vector3 measured_acc{imu_input.linear_a};\n    const gtsam::Vector3 measured_omega{imu_input.angular_v};\n\n    duration delta_t = imu_input_next.time - imu_input.time;\n\n    pim_-&gt;integrateMeasurement(measured_acc, measured_omega, duration_to_double(delta_t));\n}\n\n[[nodiscard]] bias_t gtsam_integrator::pim_object::bias_hat() const noexcept {\n    assert(pim_ != nullptr &amp;&amp; \"pim_ shuold not be null\");\n    return pim_-&gt;biasHat();\n}\n\n[[nodiscard]] nav_t gtsam_integrator::pim_object::predict() const noexcept {\n    assert(pim_ != nullptr &amp;&amp; \"pim_ should not be null\");\n    return pim_-&gt;predict(nav_state_lkf_, imu_bias_);\n}\n\n// Remove IMU values older than 'IMU_TTL' from the imu buffer\nvoid gtsam_integrator::clean_imu_vec(time_point timestamp) {\n    auto imu_iterator = imu_vector_.begin();\n\n    // Since the vector is ordered oldest to latest, keep deleting until you\n    // hit a value less than 'IMU_TTL' seconds old\n    while (imu_iterator != imu_vector_.end()) {\n        if (timestamp - imu_iterator-&gt;time &lt; IMU_TTL) {\n            break;\n        }\n\n        imu_iterator = imu_vector_.erase(imu_iterator);\n    }\n}\n\n// Timestamp we are propagating the biases to (new IMU reading time)\nvoid gtsam_integrator::propagate_imu_values(time_point real_time) {\n    auto input_values = imu_integrator_input_.get_ro_nullable();\n    if (input_values == nullptr) {\n        return;\n    }\n\n#ifndef NDEBUG\n    if (input_values-&gt;last_cam_integration_time &gt; last_cam_time_) {\n        spdlog::get(name_)-&gt;debug(\"New slow pose has arrived!\");\n        last_cam_time_ = input_values-&gt;last_cam_integration_time;\n    }\n#endif\n\n    if (pim_obj_ == nullptr) {\n        pim_obj_ = std::make_unique&lt;pim_object&gt;(*input_values);\n\n        last_imu_offset_ = input_values-&gt;t_offset;\n    } else {\n        pim_obj_-&gt;reset_integration_and_set_bias(*input_values);\n    }\n\n    assert(pim_obj_ != nullptr &amp;&amp; \"pim_obj_ should not be null\");\n\n    // TODO last_imu_offset_ is 0, t_offset only take effects when it's negative.\n    // However, why would we want to integrate to a past time point rather than the current time point?\n    time_point time_begin = input_values-&gt;last_cam_integration_time + last_imu_offset_;\n    time_point time_end   = real_time;\n\n    const std::vector&lt;imu_type&gt; prop_data = select_imu_readings(imu_vector_, time_begin, time_end);\n\n    if (prop_data.size() &lt; 2) {\n        return;\n    }\n\n    ImuBias prev_bias = pim_obj_-&gt;bias_hat();\n    ImuBias bias      = pim_obj_-&gt;bias_hat();\n\n    spdlog::get(name_)-&gt;debug(\"Integrating over {} IMU samples\", prop_data.size());\n\n    for (std::size_t i = 0; i &lt; prop_data.size() - 1; i++) {\n        pim_obj_-&gt;integrate_measurement(prop_data[i], prop_data[i + 1]);\n\n        prev_bias = bias;\n        bias      = pim_obj_-&gt;bias_hat();\n    }\n\n    gtsam::NavState navstate_k = pim_obj_-&gt;predict();\n    gtsam::Pose3    out_pose   = navstate_k.pose();\n\n    spdlog::get(name_)-&gt;debug(\"Base Position (x, y, z) = {}, {}, {}\", input_values-&gt;position(0), input_values-&gt;position(1),\n                              input_values-&gt;position(2));\n    spdlog::get(name_)-&gt;debug(\"New Position (x, y, z) = {}, {}, {}\", out_pose.x(), out_pose.y(), out_pose.z());\n\n    auto                        seconds_since_epoch = std::chrono::duration&lt;double&gt;(real_time.time_since_epoch()).count();\n    auto                        original_quaternion = out_pose.rotation().toQuaternion();\n    Eigen::Matrix&lt;double, 3, 1&gt; rotation_angles  = original_quaternion.toRotationMatrix().eulerAngles(0, 1, 2).cast&lt;double&gt;();\n    Eigen::Matrix&lt;double, 3, 1&gt; filtered_sins    = filters_[6](rotation_angles.array().sin(), seconds_since_epoch);\n    Eigen::Matrix&lt;double, 3, 1&gt; filtered_cosines = filters_[7](rotation_angles.array().cos(), seconds_since_epoch);\n    Eigen::Matrix&lt;double, 3, 1&gt; filtered_angles{atan2(filtered_sins[0], filtered_cosines[0]),\n                                                atan2(filtered_sins[1], filtered_cosines[1]),\n                                                atan2(filtered_sins[2], filtered_cosines[2])};\n\n    if (has_prev_ &amp;&amp;\n        (abs(rotation_angles[0] - prev_euler_angles_[0]) &gt; M_PI / 2 ||\n         abs(rotation_angles[1] - prev_euler_angles_[1]) &gt; M_PI / 2 ||\n         abs(rotation_angles[2] - prev_euler_angles_[2]) &gt; M_PI / 2)) {\n        filters_[6].clear();\n        filters_[7].clear();\n        filtered_sins    = filters_[6](rotation_angles.array().sin(), seconds_since_epoch);\n        filtered_cosines = filters_[7](rotation_angles.array().cos(), seconds_since_epoch);\n        filtered_angles  = {atan2(filtered_sins[0], filtered_cosines[0]), atan2(filtered_sins[1], filtered_cosines[1]),\n                            atan2(filtered_sins[2], filtered_cosines[2])};\n    } else {\n        has_prev_ = true;\n    }\n\n    prev_euler_angles_ = std::move(rotation_angles);\n\n    [[maybe_unused]] auto new_quaternion = Eigen::AngleAxisd(filtered_angles(0, 0), Eigen::Vector3d::UnitX()) *\n        Eigen::AngleAxisd(filtered_angles(1, 0), Eigen::Vector3d::UnitY()) *\n        Eigen::AngleAxisd(filtered_angles(2, 0), Eigen::Vector3d::UnitZ());\n\n    Eigen::MatrixWrapper&lt;Eigen::Array&lt;double, 3, 1, 0, 3, 1&gt;&gt; filtered_pos{\n        filters_[4](out_pose.translation().array(), seconds_since_epoch).matrix()};\n\n    imu_raw_.put(imu_raw_.allocate&lt;imu_raw_type&gt;(\n        imu_raw_type{prev_bias.gyroscope(), prev_bias.accelerometer(), bias.gyroscope(), bias.accelerometer(),\n                     filtered_pos,                                                    \n                     filters_[5](navstate_k.velocity().array(), seconds_since_epoch), \n                     new_quaternion,                                                  \n                     real_time}));\n}\n\n// Select IMU readings based on timestamp similar to how OpenVINS selects IMU values to propagate\nstd::vector&lt;imu_type&gt; gtsam_integrator::select_imu_readings(const std::vector&lt;imu_type&gt;&amp; imu_data, const time_point time_begin,\n                                                            const time_point time_end) {\n    std::vector&lt;imu_type&gt; prop_data;\n    if (imu_data.size() &lt; 2) {\n        return prop_data;\n    }\n\n    for (std::size_t i = 0; i &lt; imu_data.size() - 1; i++) {\n        // If time_begin comes inbetween two IMUs (A and B), interpolate A forward to time_begin\n        if (imu_data[i + 1].time &gt; time_begin &amp;&amp; imu_data[i].time &lt; time_begin) {\n            imu_type data = interpolate_imu(imu_data[i], imu_data[i + 1], time_begin);\n            prop_data.push_back(data);\n            continue;\n        }\n\n        // IMU is within time_begin and time_end\n        if (imu_data[i].time &gt;= time_begin &amp;&amp; imu_data[i + 1].time &lt;= time_end) {\n            prop_data.push_back(imu_data[i]);\n            continue;\n        }\n\n        // IMU is past time_end\n        if (imu_data[i + 1].time &gt; time_end) {\n            imu_type data = interpolate_imu(imu_data[i], imu_data[i + 1], time_end);\n            prop_data.push_back(data);\n            break;\n        }\n    }\n\n    // Loop through and ensure we do not have a zero dt values\n    // This would cause the noise covariance to be Infinity\n    for (int i = 0; i &lt; int(prop_data.size()) - 1; i++) {\n        // I need prop_data.size() - 1 to be signed, because it might equal -1.\n        if (std::chrono::abs(prop_data[i + 1].time - prop_data[i].time) &lt; std::chrono::nanoseconds{1}) {\n            prop_data.erase(prop_data.begin() + i);\n            i--;\n        }\n    }\n\n    return prop_data;\n}\n\n// For when an integration time ever falls inbetween two imu measurements (modeled after OpenVINS)\nimu_type gtsam_integrator::interpolate_imu(const imu_type&amp; imu_1, const imu_type&amp; imu_2, time_point timestamp) {\n    double lambda = duration_to_double(timestamp - imu_1.time) / duration_to_double(imu_2.time - imu_1.time);\n    return imu_type{timestamp, (1 - lambda) * imu_1.linear_a + lambda * imu_2.linear_a,\n                    (1 - lambda) * imu_1.angular_v + lambda * imu_2.angular_v};\n}\n\nPLUGIN_MAIN(gtsam_integrator)\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; gtsam_integrator &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"third_party/filter.h\"</code></li> <li><code>#include &lt;gtsam/navigation/CombinedImuFactor.h&gt;</code></li> <li><code>#include &lt;gtsam/navigation/ImuFactor.h&gt;</code></li> </ul>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class gtsam_integrator"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#public-types","title":"Public Types","text":"Type Name typedef gtsam::imuBias::ConstantBias ImuBias typedef ImuBias bias_t typedef ILLIXR::data_format::imu_integrator_input imu_int_t typedef ILLIXR::data_format::imu_type imu_t typedef gtsam::NavState nav_t typedef gtsam::PreintegrationType * pim_ptr_t typedef gtsam::PreintegratedCombinedMeasurements pim_t"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#typedef-imubias","title":"typedef ImuBias","text":"<pre><code>using ImuBias =  gtsam::imuBias::ConstantBias;\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#typedef-bias_t","title":"typedef bias_t","text":"<pre><code>using bias_t =  ImuBias;\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#typedef-imu_int_t","title":"typedef imu_int_t","text":"<pre><code>using imu_int_t =  ILLIXR::data_format::imu_integrator_input;\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#typedef-imu_t","title":"typedef imu_t","text":"<pre><code>using imu_t =  ILLIXR::data_format::imu_type;\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#typedef-nav_t","title":"typedef nav_t","text":"<pre><code>using nav_t =  gtsam::NavState;\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#typedef-pim_ptr_t","title":"typedef pim_ptr_t","text":"<pre><code>using pim_ptr_t =  gtsam::PreintegrationType*;\n</code></pre>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp/#typedef-pim_t","title":"typedef pim_t","text":"<pre><code>using pim_t =  gtsam::PreintegratedCombinedMeasurements;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/gtsam_integrator/plugin.hpp</code></p>"},{"location":"api/plugins_2gtsam__integrator_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; gtsam_integrator &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"third_party/filter.h\"\n\n#include &lt;gtsam/navigation/CombinedImuFactor.h&gt; // Used if IMU combined is off.\n#include &lt;gtsam/navigation/ImuFactor.h&gt;\n\nusing ImuBias = gtsam::imuBias::ConstantBias;\n\nusing imu_int_t = ILLIXR::data_format::imu_integrator_input;\nusing imu_t     = ILLIXR::data_format::imu_type;\nusing bias_t    = ImuBias;\nusing nav_t     = gtsam::NavState;\nusing pim_t     = gtsam::PreintegratedCombinedMeasurements;\nusing pim_ptr_t = gtsam::PreintegrationType*;\n\nnamespace ILLIXR {\nclass gtsam_integrator : public plugin {\npublic:\n    [[maybe_unused]] gtsam_integrator(const std::string&amp; name, phonebook* pb);\n    void callback(const switchboard::ptr&lt;const data_format::imu_type&gt;&amp; datum);\n\nprivate:\n    class pim_object {\n    public:\n        explicit pim_object(const imu_int_t&amp; imu_int_input);\n        ~pim_object();\n        void                 reset_integration_and_set_bias(const imu_int_t&amp; imu_int_input) noexcept;\n        void                 integrate_measurement(const imu_t&amp; imu_input, const imu_t&amp; imu_input_next) noexcept;\n        [[nodiscard]] bias_t bias_hat() const noexcept;\n        [[nodiscard]] nav_t  predict() const noexcept;\n\n    private:\n        bias_t    imu_bias_;\n        nav_t     nav_state_lkf_;\n        pim_ptr_t pim_;\n    };\n\n    void                                      clean_imu_vec(time_point timestamp);\n    void                                      propagate_imu_values(time_point real_time);\n    static std::vector&lt;data_format::imu_type&gt; select_imu_readings(const std::vector&lt;data_format::imu_type&gt;&amp; imu_data,\n                                                                  const time_point time_begin, const time_point time_end);\n    static data_format::imu_type interpolate_imu(const data_format::imu_type&amp; imu_1, const data_format::imu_type&amp; imu_2,\n                                                 time_point timestamp);\n\n    const std::shared_ptr&lt;switchboard&gt;    switchboard_;\n    const std::shared_ptr&lt;relative_clock&gt; clock_;\n\n    // IMU Data, Sequence Flag, and State Vars Needed\n    switchboard::reader&lt;data_format::imu_integrator_input&gt; imu_integrator_input_;\n\n    // Write IMU Biases for PP\n    switchboard::writer&lt;data_format::imu_raw_type&gt; imu_raw_;\n\n    std::shared_ptr&lt;spdlog::logger&gt; log_;\n\n    std::vector&lt;one_euro_filter&lt;Eigen::Array&lt;double, 3, 1&gt;, double&gt;&gt; filters_;\n    bool                                                             has_prev_ = false;\n    Eigen::Matrix&lt;double, 3, 1&gt;                                      prev_euler_angles_;\n    std::vector&lt;data_format::imu_type&gt;                               imu_vector_;\n\n    // std::vector&lt;pose_type&gt; filtered_poses;\n\n    [[maybe_unused]] time_point last_cam_time_{};\n    duration                    last_imu_offset_{};\n\n    std::unique_ptr&lt;pim_object&gt; pim_obj_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2hand__tracking_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking/CMakeLists.txt</code></p>"},{"location":"api/plugins_2hand__tracking_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>set(HT_ENABLE_GPU OFF)\ninclude(GetHandTracking)\n</code></pre>"},{"location":"api/plugins_2hand__tracking_2viewer_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2hand__tracking_2viewer_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.hand_tracking.viewer${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2hand__tracking_2viewer_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2hand__tracking_2viewer_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.hand_tracking.viewer${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking/viewer/CMakeLists.txt</code></p>"},{"location":"api/plugins_2hand__tracking_2viewer_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>set(PLUGIN_NAME plugin.hand_tracking.viewer${ILLIXR_BUILD_SUFFIX})\n\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/hand_tracking_data.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            $&lt;TARGET_OBJECTS:illixr_imgui&gt;\n)\n\nif(BUILD_OPENCV)\n    add_dependencies(${PLUGIN_NAME} OpenCV_Viz)\nendif()\n#target_compile_definitions(${PLUGIN_NAME} PUBLIC -DVIEW_DUMP)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_SOURCE_DIR}/include ${OpenCV_INCLUDE_DIRS} ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} PUBLIC ${OpenCV_LIBRARIES} ${Eigen3_LIBRARIES} dl Threads::Threads)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; hand_tracking &gt; viewer &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/gl_util/obj.hpp\"</code></li> <li><code>#include \"illixr/imgui/backends/imgui_impl_glfw.h\"</code></li> <li><code>#include \"illixr/imgui/backends/imgui_impl_opengl3.h\"</code></li> <li><code>#include \"illixr/shader_util.hpp\"</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::string image_type_string (const image::image_type it) Callback function to handle glfw errors."},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void glfw_error_callback (int error, const char * description) Callback function to handle glfw errors."},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp/#function-image_type_string","title":"function image_type_string","text":"<p>Callback function to handle glfw errors. <pre><code>std::string image_type_string (\n    const image::image_type it\n) \n</code></pre></p>"},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp/#function-glfw_error_callback","title":"function glfw_error_callback","text":"<p>Callback function to handle glfw errors. <pre><code>static void glfw_error_callback (\n    int error,\n    const char * description\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking/viewer/plugin.cpp</code></p>"},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; hand_tracking &gt; viewer &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/gl_util/obj.hpp\"\n#include \"illixr/imgui/backends/imgui_impl_glfw.h\"\n#include \"illixr/imgui/backends/imgui_impl_opengl3.h\"\n#include \"illixr/shader_util.hpp\"\n\n#include &lt;opencv2/opencv.hpp&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nint                     viewer::requested_unit_ = -1;\nunits::measurement_unit viewer::base_unit_      = units::UNSET;\n\nstatic void glfw_error_callback(int error, const char* description) {\n    spdlog::get(\"illixr\")-&gt;error(\"|| glfw error_callback: {}\\n|&gt; {}\", error, description);\n    ILLIXR::abort();\n}\n\n[[maybe_unused]] std::string image_type_string(const image::image_type it) {\n    switch (it) {\n    case image::LEFT_EYE:\n    case image::LEFT_EYE_PROCESSED:\n        return \"left\";\n    case image::RIGHT_EYE:\n    case image::RIGHT_EYE_PROCESSED:\n        return \"right\";\n    case image::RGB:\n    case image::RGB_PROCESSED:\n        return \"rgb\";\n    case image::DEPTH:\n        return \"depth\";\n    case image::CONFIDENCE:\n        return \"confidence\";\n    }\n    return \"\";\n}\n\nviewer::viewer(const std::string&amp; name_, phonebook* pb_)\n    : plugin{name_, pb_}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , switchboard_{pb_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , pose_{switchboard_-&gt;root_coordinates.position(), switchboard_-&gt;root_coordinates.orientation()}\n    , current_frame_(nullptr) { }\n\nvoid viewer::start() {\n    plugin::start();\n    if (!glfwInit()) {\n        ILLIXR::abort(\"[viewer] Failed to initialize glfw\");\n    }\n\n    glfwSetErrorCallback(glfw_error_callback);\n\n    glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);\n    glfwWindowHint(GLFW_VISIBLE, GL_TRUE);\n\n    constexpr std::string_view glsl_version{\"#version 330 core\"};\n\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);\n    viewport_ = glfwCreateWindow(640 * 3 + 20, 1000, \"ILLIXR Hand Tracking Viewer\", nullptr, nullptr);\n    if (viewport_ == nullptr) {\n        spdlog::get(name_)-&gt;error(\"couldn't create window {}:{}\", __FILE__, __LINE__);\n        ILLIXR::abort();\n    }\n\n    glfwSetWindowSize(viewport_, 640 * 3 + 20, 480 * 3 + 20);\n\n    glfwMakeContextCurrent(viewport_);\n\n    glfwSwapInterval(1);\n\n    const GLenum glew_err = glewInit();\n    if (glew_err != GLEW_OK) {\n        // spdlog::get(name)-&gt;error(\"GLEW Error: {}\", glewGetErrorString(glew_err));\n        glfwDestroyWindow(viewport_);\n        ILLIXR::abort(\"[hand_tracking viewer] Failed to initialize GLEW\");\n    }\n\n    // Initialize IMGUI context.\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n\n    // Dark theme, of course.\n    ImGui::StyleColorsDark();\n\n    // Init IMGUI for OpenGL\n    ImGui_ImplGlfw_InitForOpenGL(viewport_, true);\n    ImGui_ImplOpenGL3_Init(glsl_version.data());\n\n    glGenTextures(2, &amp;(textures_[0]));\n    for (unsigned int texture : textures_) {\n        glBindTexture(GL_TEXTURE_2D, texture);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    }\n\n    // Construct a basic perspective projection\n    // math_util::projection_fov(&amp;basicProjection, 40.0f, 40.0f, 40.0f, 40.0f, 0.03f, 20.0f);\n\n    glfwMakeContextCurrent(nullptr);\n    switchboard_-&gt;schedule&lt;ht::ht_frame&gt;(id_, \"ht\", [this](const switchboard::ptr&lt;const ht::ht_frame&gt;&amp; ht_frame, std::size_t) {\n        this-&gt;make_gui(ht_frame);\n    });\n}\n\nviewer::~viewer() {\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplGlfw_Shutdown();\n    ImGui::DestroyContext();\n\n    glfwDestroyWindow(viewport_);\n\n    RAC_ERRNO_MSG(\"debugview during destructor\");\n\n    glfwTerminate();\n}\n\nvoid viewer::make_position_table() const {\n    ImGui::RadioButton(\"millimeter\", &amp;requested_unit_, 0);\n    ImGui::SameLine();\n    ImGui::RadioButton(\"centimeter\", &amp;requested_unit_, 1);\n    ImGui::SameLine();\n    ImGui::RadioButton(\"meter\", &amp;requested_unit_, 2);\n    ImGui::SameLine();\n    ImGui::RadioButton(\"foot\", &amp;requested_unit_, 3);\n    ImGui::SameLine();\n    ImGui::RadioButton(\"inch\", &amp;requested_unit_, 4);\n    if (ImGui::BeginTable(\"Poses\", 2, ImGuiTableFlags_Borders)) {\n        ImGui::TableSetupColumn(\"Pose\");\n        ImGui::TableSetupColumn(\"x, y, z : w, x, y, z\");\n        ImGui::TableHeadersRow();\n        ImGui::TableNextRow();\n        ImGui::TableSetColumnIndex(0);\n        ImGui::Text(\"Origin\");\n        ImGui::TableSetColumnIndex(1);\n        ImGui::Text(\"%.2f, %.2f, %.2f : %.2f, %.2f, %.2f, %.2f\", pose_.position.x(), pose_.position.y(), pose_.position.z(),\n                    pose_.orientation.w(), pose_.orientation.x(), pose_.orientation.y(), pose_.orientation.z());\n        ImGui::TableNextRow();\n        ImGui::TableSetColumnIndex(0);\n        ImGui::Text(\"Current\");\n        ImGui::TableSetColumnIndex(1);\n        ImGui::Text(\"%.2f, %.2f, %.2f : %.2f, %.2f, %.2f, %.2f\", current_frame_-&gt;wcs_offset.position.x(),\n                    current_frame_-&gt;wcs_offset.position.y(), current_frame_-&gt;wcs_offset.position.z(),\n                    current_frame_-&gt;wcs_offset.orientation.w(), current_frame_-&gt;wcs_offset.orientation.x(),\n                    current_frame_-&gt;wcs_offset.orientation.y(), current_frame_-&gt;wcs_offset.orientation.z());\n        ImGui::EndTable();\n    }\n    std::string label;\n    if (ImGui::BeginTable(\"True Points\", 2, ImGuiTableFlags_Borders)) {\n        ImGui::TableNextRow();\n        for (int idx = 0; idx &lt; 2; idx++) {\n            if (idx == 0) {\n                label = \"True Points Left Hand\";\n            } else {\n                label = \"True Points Right Hand\";\n            }\n\n            ImGui::TableSetColumnIndex(idx);\n            if (ImGui::BeginTable(label.c_str(), 5, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg)) {\n                ImGui::TableSetupColumn(\"Point\");\n                ImGui::TableSetupColumn(\"x\");\n                ImGui::TableSetupColumn(\"y\");\n                ImGui::TableSetupColumn(\"z\");\n                ImGui::TableSetupColumn(\"Confidence\");\n                // ImGui::TableSetupColumn(\"Wx\");\n                // ImGui::TableSetupColumn(\"Wy\");\n                // ImGui::TableSetupColumn(\"Wz\");\n                ImGui::TableHeadersRow();\n                auto points = current_frame_-&gt;hand_positions.at(static_cast&lt;ht::hand&gt;(idx));\n                bool skip   = points.points.empty();\n                for (int row = ht::WRIST; row &lt; ht::PINKY_TIP; row++) {\n                    ImGui::TableNextRow();\n                    ImGui::TableSetColumnIndex(0);\n                    ImGui::Text(\"%s\", ht::point_str_map.at(row).c_str());\n                    point_with_units pnt;\n                    if (!skip) {\n                        pnt = points.points.at(row);\n                    }\n                    for (int i = 0; i &lt; 3; i++) {\n                        ImGui::TableSetColumnIndex(i + 1);\n                        if (pnt.valid) {\n                            ImGui::Text(\"%.3f\", pnt[i] * units::conversion_factor[points.unit][requested_unit_]);\n                            // ImGui::TableSetColumnIndex(i + 1 + 4);\n                            // ImGui::Text(\"%.3f\", thp.at(row)[i] * convert[points.unit][requested_unit_]);\n                        } else {\n                            ImGui::Text(\"\");\n                            ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg,\n                                                   ImGui::GetColorU32(ImVec4(0.7f, 0.3f, 0.3f, 0.65f)));\n                            // ImGui::TableSetColumnIndex(i + 1 + 4);\n                            // ImGui::Text(\"\");\n                            // ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg,\n                            //                        ImGui::GetColorU32(ImVec4(0.7f, 0.3f, 0.3f, 0.65f)));\n                        }\n                    }\n                    ImGui::TableSetColumnIndex(4);\n                    if (pnt.valid) {\n                        ImGui::Text(\"%.2f\", pnt.confidence);\n                    } else {\n                        ImGui::Text(\"\");\n                        ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, ImGui::GetColorU32(ImVec4(0.7f, 0.3f, 0.3f, 0.65f)));\n                    }\n                }\n                ImGui::EndTable();\n            }\n        }\n        ImGui::EndTable();\n    }\n}\n\nvoid viewer::make_detection_table(units::eyes eye, int idx, const std::string&amp; label) const {\n    if (ImGui::BeginTabItem(label.c_str())) {\n        if (ImGui::BeginTable(\"first_det\", 2, ImGuiTableFlags_Borders)) {\n            ImGui::TableSetupColumn(\"first_det_info\");\n            ImGui::TableSetupColumn(\"first_det_img\");\n            ImGui::TableNextRow();\n\n            ImGuiTableFlags flags = ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg;\n            ImGui::TableSetColumnIndex(0);\n\n            if (ImGui::BeginTable(\"Palms\", 6, flags)) {\n                ImGui::TableSetupColumn(\"\");\n                ImGui::TableSetupColumn(\"Unit\");\n                ImGui::TableSetupColumn(\"Center\");\n                ImGui::TableSetupColumn(\"Width\");\n                ImGui::TableSetupColumn(\"Height\");\n                ImGui::TableSetupColumn(\"Rotation\");\n                ImGui::TableHeadersRow();\n                for (auto i : ht::hand_map) {\n                    rect current_rect = current_frame_-&gt;detections.at(eye).palms.at(i);\n                    ImGui::TableNextRow();\n                    ImGui::TableSetColumnIndex(0);\n                    ImGui::Text(\"%s\", (i == 0) ? \"Left palm\" : \"Right palm\");\n                    ImGui::TableSetColumnIndex(1);\n                    ImGui::Text(\"%s\", units::unit_str.at(current_rect.unit).c_str());\n                    if (current_rect.valid) {\n                        ImGui::TableSetColumnIndex(2);\n                        ImGui::Text(\"%.2f, %.2f\", current_rect.x_center, current_rect.y_center);\n                        ImGui::TableSetColumnIndex(3);\n                        ImGui::Text(\"%.2f\", current_rect.width);\n                        ImGui::TableSetColumnIndex(4);\n                        ImGui::Text(\"%.2f\", current_rect.height);\n                        ImGui::TableSetColumnIndex(5);\n                        ImGui::Text(\"%.2f\", current_rect.rotation);\n                    }\n                }\n                ImGui::EndTable();\n            }\n            if (ImGui::BeginTable(\"Hands\", 6, flags)) {\n                ImGui::TableSetupColumn(\"\");\n                ImGui::TableSetupColumn(\"Unit\");\n                ImGui::TableSetupColumn(\"Center\");\n                ImGui::TableSetupColumn(\"Width\");\n                ImGui::TableSetupColumn(\"Height\");\n                ImGui::TableSetupColumn(\"Rotation\");\n                ImGui::TableHeadersRow();\n                for (auto i : ht::hand_map) {\n                    rect current_rect = current_frame_-&gt;detections.at(eye).hands.at(i);\n                    ImGui::TableNextRow();\n                    ImGui::TableSetColumnIndex(0);\n                    ImGui::Text(\"%s\", (i == 0) ? \"Left hand\" : \"Right hand\");\n                    ImGui::TableSetColumnIndex(1);\n                    ImGui::Text(\"%s\", units::unit_str.at(current_rect.unit).c_str());\n                    if (current_rect.valid) {\n                        ImGui::TableSetColumnIndex(2);\n                        ImGui::Text(\"%.2f, %.2f\", current_rect.x_center, current_rect.y_center);\n                        ImGui::TableSetColumnIndex(3);\n                        ImGui::Text(\"%.2f\", current_rect.width);\n                        ImGui::TableSetColumnIndex(4);\n                        ImGui::Text(\"%.2f\", current_rect.height);\n                        ImGui::TableSetColumnIndex(5);\n                        ImGui::Text(\"%.2f\", current_rect.rotation);\n                    }\n                }\n                ImGui::EndTable();\n            }\n            if (ImGui::BeginTable(\"Hand Points\", 3, flags)) {\n                ImGui::TableSetupColumn(\"Point\");\n                ImGui::TableSetupColumn(\"Left\");\n                ImGui::TableSetupColumn(\"Right\");\n                ImGui::TableHeadersRow();\n                ImGui::TableNextRow();\n                ImGui::TableSetColumnIndex(0);\n                ImGui::Text(\"%s\", \"Confidence\");\n                ImGui::TableSetColumnIndex(1);\n                ImGui::Text(\"%.2f\", current_frame_-&gt;detections.at(eye).confidence.at(ht::LEFT_HAND));\n                ImGui::TableSetColumnIndex(2);\n                ImGui::Text(\"%.2f\", current_frame_-&gt;detections.at(eye).confidence.at(ht::RIGHT_HAND));\n                for (int row = ht::WRIST; row &lt;= ht::PINKY_TIP; row++) {\n                    ImGui::TableNextRow();\n                    ImGui::TableSetColumnIndex(0);\n                    ImGui::Text(\"%s\", ht::point_str_map.at(row).c_str());\n                    ImGui::TableSetColumnIndex(1);\n                    auto pnt = current_frame_-&gt;detections.at(eye).points.at(ht::LEFT_HAND).points[row];\n                    if (pnt.valid) {\n                        ImGui::Text(\"%.2f, %.2f, %.2f\", pnt.x(), pnt.y(), pnt.z());\n                    } else {\n                        ImGui::Text(\"%s\", \"\");\n                        ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, ImGui::GetColorU32(ImVec4(0.7f, 0.3f, 0.3f, 0.65f)));\n                    }\n                    ImGui::TableSetColumnIndex(2);\n                    pnt = current_frame_-&gt;detections.at(eye).points.at(ht::RIGHT_HAND).points[row];\n                    if (pnt.valid) {\n                        ImGui::Text(\"%.2f, %.2f, %.2f\", pnt.x(), pnt.y(), pnt.z());\n                    } else {\n                        ImGui::Text(\"%s\", \"\");\n                        ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, ImGui::GetColorU32(ImVec4(0.7f, 0.3f, 0.3f, 0.65f)));\n                    }\n                }\n\n                ImGui::EndTable();\n            }\n            ImGui::TableSetColumnIndex(1);\n            ImGui::Image((void*) (intptr_t) textures_[idx], ImVec2(640, 480));\n            ImGui::EndTable();\n        }\n        ImGui::EndTabItem();\n    }\n}\n\nvoid viewer::make_gui(const switchboard::ptr&lt;const ht::ht_frame&gt;&amp; frame) {\n    glfwMakeContextCurrent(viewport_);\n    glfwPollEvents();\n    current_frame_ = frame.get();\n\n    if (base_unit_ == units::UNSET) {\n        base_unit_      = current_frame_-&gt;unit;\n        requested_unit_ = base_unit_;\n    }\n    std::vector&lt;image::image_type&gt; found_types;\n    cv::Mat                        raw_img[2];\n    int                            last_idx = 0;\n\n    if (current_frame_-&gt;find(image::LEFT_EYE_PROCESSED) != current_frame_-&gt;images.end()) {\n        found_types.push_back(image::LEFT_EYE_PROCESSED);\n        raw_img[0] = current_frame_-&gt;at(image::LEFT_EYE).clone();\n        last_idx++;\n    }\n\n    if (current_frame_-&gt;find(image::RIGHT_EYE_PROCESSED) != current_frame_-&gt;images.end()) {\n        found_types.push_back(image::RIGHT_EYE_PROCESSED);\n        raw_img[last_idx] = current_frame_-&gt;at(image::RIGHT_EYE).clone();\n    }\n\n    if (found_types.empty() &amp;&amp; current_frame_-&gt;find(image::RGB_PROCESSED) != current_frame_-&gt;images.end()) {\n        found_types.push_back(image::RGB_PROCESSED);\n        raw_img[0] = current_frame_-&gt;at(image::RGB).clone();\n    }\n\n    cv::Mat processed[2];\n    cv::Mat combined[2], flattened[2];\n    int     d_width, d_height;\n    glfwGetFramebufferSize(viewport_, &amp;d_width, &amp;d_height);\n    glViewport(0, 0, d_width, d_height);\n    glClearColor(clear_color_.x * clear_color_.w, clear_color_.y * clear_color_.w, clear_color_.z * clear_color_.w,\n                 clear_color_.w);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    ImGui_ImplOpenGL3_NewFrame();\n\n    ImGui_ImplGlfw_NewFrame();\n\n    ImGui::NewFrame();\n    float proc_time;\n    if (current_frame_-&gt;detections.count(units::LEFT_EYE) == 1 &amp;&amp; current_frame_-&gt;detections.count(units::RIGHT_EYE) == 1) {\n        raw_img[0]     = current_frame_-&gt;at(image::LEFT_EYE).clone();\n        raw_img[1]     = current_frame_-&gt;at(image::RIGHT_EYE).clone();\n        enabled_right_ = true;\n        tab_label_     = \"Left Eye Raw\";\n        single_eye_    = units::LEFT_EYE;\n        detections_    = {image::LEFT_EYE_PROCESSED, image::RIGHT_EYE_PROCESSED};\n        proc_time =\n            (float) std::max(current_frame_-&gt;detections.at(static_cast&lt;const units::eyes&gt;(image::LEFT_EYE)).proc_time,\n                             current_frame_-&gt;detections.at(static_cast&lt;const units::eyes&gt;(image::RIGHT_EYE)).proc_time) /\n            (1000.f * 1000.f);\n    } else {\n        image::image_type img_typ;\n        if (current_frame_-&gt;detections.count(units::LEFT_EYE) == 1) {\n            single_eye_ = units::LEFT_EYE;\n            detections_ = {image::LEFT_EYE_PROCESSED};\n            img_typ     = image::LEFT_EYE;\n            proc_time   = (float) current_frame_-&gt;detections.at(static_cast&lt;const units::eyes&gt;(image::LEFT_EYE)).proc_time /\n                (1000.f * 1000.f);\n        } else if (current_frame_-&gt;detections.count(units::RIGHT_EYE) == 1) {\n            single_eye_ = units::RIGHT_EYE;\n            detections_ = {image::RIGHT_EYE_PROCESSED};\n            img_typ     = image::RIGHT_EYE;\n            proc_time   = (float) current_frame_-&gt;detections.at(static_cast&lt;const units::eyes&gt;(image::RIGHT_EYE)).proc_time /\n                (1000.f * 1000.f);\n        } else {\n            return;\n        }\n        raw_img[0] = current_frame_-&gt;at(img_typ).clone();\n        raw_img[1].release();\n        enabled_right_ = false;\n        tab_label_     = \"Raw\";\n    }\n\n    for (size_t i = 0; i &lt; 2; i++) {\n        if (i == 1 &amp;&amp; !enabled_right_)\n            break;\n        processed[i] = current_frame_-&gt;at(detections_[i]).clone();\n        cv::Mat mask, inv, r;\n        cv::cvtColor(processed[i], mask, cv::COLOR_RGBA2GRAY);\n        cv::threshold(mask, mask, 10, 255, cv::THRESH_BINARY);\n        cv::bitwise_not(mask, mask);\n        cv::bitwise_and(raw_img[i], raw_img[i], r, mask);\n        cv::cvtColor(processed[i], flattened[i], cv::COLOR_RGBA2RGB);\n        combined[i] = flattened[i] + r;\n        glBindTexture(GL_TEXTURE_2D, textures_[i]);\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, combined[i].cols, combined[i].rows, 0, GL_RGB, GL_UNSIGNED_BYTE,\n                     combined[i].ptr());\n    }\n\n    if (ImGui::Begin(\"Hand Detections\")) {\n        if (ImGui::BeginMenuBar()) {\n            if (ImGui::BeginMenu(\"File\")) {\n                if (ImGui::MenuItem(\"Exit\")) { }\n                ImGui::EndMenu();\n            }\n            ImGui::EndMenuBar();\n        }\n        if (ImGui::BeginTable(\"times_table\", 2, ImGuiTableFlags_Borders)) {\n            ImGui::TableSetupColumn(\"title_label\");\n            ImGui::TableSetupColumn(\"time_label\");\n            ImGui::TableNextRow();\n            ImGui::TableSetColumnIndex(0);\n            ImGui::Text(\"%s\", \"Processing time (ms)\");\n            ImGui::TableSetColumnIndex(1);\n            ImGui::Text(\"%f\", proc_time);\n            ImGui::EndTable();\n        }\n        ImGui::Separator();\n\n        if (ImGui::BeginTabBar(\"TabBar\")) {\n            make_detection_table(single_eye_, 0, tab_label_);\n            if (enabled_right_) {\n                make_detection_table(units::RIGHT_EYE, 1, \"Right Eye Raw\");\n            }\n            if (ImGui::BeginTabItem(\"True Position\")) {\n                make_position_table();\n                ImGui::EndTabItem();\n            }\n            ImGui::EndTabBar();\n        }\n        ImGui::End();\n    }\n    ImGui::Render();\n\n    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n    glfwSwapBuffers(viewport_);\n}\n\nPLUGIN_MAIN(viewer)\n</code></pre>"},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; hand_tracking &gt; viewer &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include \"illixr/data_format/camera_data.hpp\"</code></li> <li><code>#include \"illixr/data_format/hand_tracking_data.hpp\"</code></li> <li><code>#include \"illixr/imgui/imgui.h\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> </ul>"},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class viewer <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking/viewer/plugin.hpp</code></p>"},{"location":"api/plugins_2hand__tracking_2viewer_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; hand_tracking &gt; viewer &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// clang-format off\n#include &lt;GL/glew.h&gt;    // GLEW has to be loaded before other GL libraries\n#include &lt;GLFW/glfw3.h&gt; // Also loading first, just to be safe\n// clang-format on\n\n#include \"illixr/data_format/camera_data.hpp\"\n#include \"illixr/data_format/hand_tracking_data.hpp\"\n#include \"illixr/imgui/imgui.h\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;eigen3/Eigen/Core&gt;\n\nnamespace ILLIXR {\nclass viewer : public plugin {\npublic:\n    viewer(const std::string&amp; name_, phonebook* pb_);\n    ~viewer() override;\n    void start() override;\n    void make_gui(const switchboard::ptr&lt;const data_format::ht::ht_frame&gt;&amp; frame);\n\nprivate:\n    void make_detection_table(data_format::units::eyes eye, int idx, const std::string&amp; label) const;\n    void make_position_table() const;\n\n    std::shared_ptr&lt;relative_clock&gt;            clock_;\n    const std::shared_ptr&lt;switchboard&gt;         switchboard_;\n    std::shared_ptr&lt;data_format::ht::ht_frame&gt; ht_frame_;\n    const data_format::pose_data               pose_;\n#ifdef VIEW_DUMP\n    std::map&lt;data_format::ht::hand, data_format::ht::hand_points&gt; _true_hand_positions;\n#endif\n\n    GLFWwindow* viewport_{};\n\n    GLuint          textures_[2];\n    Eigen::Vector2i raw_size       = Eigen::Vector2i::Zero();\n    Eigen::Vector2i processed_size = Eigen::Vector2i::Zero();\n    Eigen::Vector2i combined_size  = Eigen::Vector2i::Zero();\n\n    Eigen::Matrix4f                  basicProjection_;\n    const data_format::ht::ht_frame* current_frame_;\n    ImVec4                           clear_color_ = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    bool                                                enabled_right_ = false;\n    std::string                                         tab_label_;\n    data_format::units::eyes                            single_eye_ = data_format::units::LEFT_EYE;\n    std::vector&lt;ILLIXR::data_format::image::image_type&gt; detections_;\n\n    std::map&lt;uint64_t, data_format::ht::ht_frame&gt; ht_frames_;\n    static int                                    requested_unit_;\n    static data_format::units::measurement_unit   base_unit_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2hand__tracking__gpu_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/hand_tracking_gpu/CMakeLists.txt</code></p>"},{"location":"api/plugins_2hand__tracking__gpu_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>set(HT_ENABLE_GPU ON)\ninclude(GetHandTracking)\n</code></pre>"},{"location":"api/plugins_2lighthouse_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2lighthouse_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.lighthouse${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2lighthouse_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2lighthouse_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.lighthouse${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/lighthouse/CMakeLists.txt</code></p>"},{"location":"api/plugins_2lighthouse_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># To add compiler flags for debugging, uncomment the lines below.\n# SET(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -fsanitize=thread\")\n# SET(CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=thread\")\n\nCMAKE_MINIMUM_REQUIRED(VERSION 3.16)\n\nset(PLUGIN_NAME plugin.lighthouse${ILLIXR_BUILD_SUFFIX})\n\nSET(THREADS_PREFER_PTHREAD_FLAG TRUE)\n\nget_external_for_plugin(LibSurvive)\n\nset(SRC_FILES plugin.cpp\n    plugin.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/error_util.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n)\n\nadd_library(${PLUGIN_NAME} SHARED ${SRC_FILES})\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_INSTALL_PREFIX}/include ${Eigen3_INCLUDE_DIRS} ${survive_INCLUDE_DIRS} ${survive_INCLUDE_DIRS}/redist)\n\nif (LibSurvive_EXTERNAL)\n    message(\"SURVIVE   ${survive_INCLUDE_DIRS} ${survive_INCLUDE_DIRS}/redist ${survive_LIBRARIES}\")\n    add_dependencies(${PLUGIN_NAME} ${LibSurvive_DEP_STR})\nendif()\n\ntarget_link_libraries(${PLUGIN_NAME} ${Eigen3_LIBRARIES} spdlog::spdlog Threads::Threads ${survive_LIBRARIES})\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2lighthouse_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/lighthouse/README.md</code></p>"},{"location":"api/plugins_2lighthouse_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># Lighthouse\n## Summary\nThe ``lighthouse`` plugin supports lighthouse tracking using the [libsurvive library](https://github.com/collabora/libsurvive). To use this plugin, libsurvive should first be built, installed, and calibrated according to [their documentation](https://github.com/collabora/libsurvive/blob/master/README.md). Running ILLIXR's CMake to build the ``lighthouse`` plugin should automatically build and install ``libsurvive``, but the steps to calibrate the lighthouses should still be followed.\n\n## Note\n\nIf the ``lighthouse`` plugin is being used, make sure to set the environment variable ``ILLIXR_LIGHTHOUSE`` to true, as the ``pose_prediction`` relies on it.\n</code></pre>"},{"location":"api/plugins_2lighthouse_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; lighthouse &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/plugins_2lighthouse_2plugin_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name lighthouse * lighthouse_instance"},{"location":"api/plugins_2lighthouse_2plugin_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/plugins_2lighthouse_2plugin_8cpp/#variable-lighthouse_instance","title":"variable lighthouse_instance","text":"<pre><code>lighthouse* lighthouse_instance;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/lighthouse/plugin.cpp</code></p>"},{"location":"api/plugins_2lighthouse_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; lighthouse &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/error_util.hpp\"\n#include \"illixr/phonebook.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nlighthouse* lighthouse_instance;\n\n[[maybe_unused]] lighthouse::lighthouse(const std::string&amp; name_, phonebook* pb_)\n    : threadloop{name_, pb_}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , log_(spdlogger(\"info\"))\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , slow_pose_{switchboard_-&gt;get_writer&lt;pose_type&gt;(\"slow_pose\")}\n    , fast_pose_{switchboard_-&gt;get_writer&lt;fast_pose_type&gt;(\"fast_pose\")} {\n    lighthouse_instance = this;\n}\n\nvoid lighthouse::stop() {\n    threadloop::stop();\n    survive_close(s_context_);\n}\n\nvoid lighthouse::process_slow_pose(SurviveObject* so, survive_long_timecode timecode, const SurvivePose* pose) {\n    survive_default_pose_process(so, timecode, pose);\n\n    auto quat = Eigen::Quaternionf{pose-&gt;Rot[0], pose-&gt;Rot[1], pose-&gt;Rot[2], pose-&gt;Rot[3]};\n\n    // The libsurvive coordinate system must be adjusted.\n    auto adjustment = Eigen::Quaternionf{-sqrt(2.0) / 2.0, sqrt(2.0) / 2.0, 0.0, 0.0};\n    auto new_quat   = adjustment * quat;\n    new_quat.normalize();\n\n    lighthouse_instance-&gt;slow_pose_.put(lighthouse_instance-&gt;slow_pose_.allocate(\n        lighthouse_instance-&gt;clock_-&gt;now(), Eigen::Vector3d{pose-&gt;Pos[0], pose-&gt;Pos[2], -pose-&gt;Pos[1]}.cast&lt;float&gt;(),\n        new_quat));\n\n    lighthouse_instance-&gt;slow_pose_count_++;\n}\n\n// static void process_fast_pose(SurviveObject* so, survive_long_timecode timecode, const SurvivePose* pose) {\n//     survive_default_imupose_process(so, timecode, pose);\n//\n//     auto quat = Eigen::Quaterniond{pose-&gt;Rot[0], pose-&gt;Rot[1], pose-&gt;Rot[2], pose-&gt;Rot[3]}.cast&lt;float&gt;();\n//\n//     lighthouse_instance-&gt;_m_fast_pose.put(lighthouse_instance-&gt;_m_fast_pose.allocate(\n//         pose_type {lighthouse_instance-&gt;_m_clock-&gt;now(), Eigen::Vector3d{pose-&gt;Pos[0], pose-&gt;Pos[1],\n//         pose-&gt;Pos[2]}.cast&lt;float&gt;(),\n//          quat},\n//         lighthouse_instance-&gt;_m_clock-&gt;now(), lighthouse_instance-&gt;_m_clock-&gt;now()));\n//\n//     lighthouse_instance-&gt;fast_pose_count++;\n// }\n\nvoid lighthouse::_p_thread_setup() {\n    s_context_ = survive_init(0, nullptr);\n\n    survive_install_pose_fn(s_context_, process_slow_pose);\n\n    // survive_install_imupose_fn(ctx, process_fast_pose);\n}\n\nvoid lighthouse::_p_one_iteration() {\n    survive_poll(s_context_);\n\n    auto now = std::chrono::high_resolution_clock::now();\n    auto dt  = now - last_time_;\n    if (dt &gt; std::chrono::seconds(1)) {\n        log_-&gt;info(\"slow pose rate: {} Hz\", slow_pose_count_);\n        log_-&gt;info(\"fast pose rate: {} Hz\", fast_pose_count_);\n        slow_pose_count_ = 0;\n        fast_pose_count_ = 0;\n        last_time_       = now;\n    }\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(lighthouse)\n</code></pre>"},{"location":"api/plugins_2lighthouse_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; lighthouse &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"survive.h\"</code></li> </ul>"},{"location":"api/plugins_2lighthouse_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2lighthouse_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class lighthouse <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/lighthouse/plugin.hpp</code></p>"},{"location":"api/plugins_2lighthouse_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; lighthouse &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// ILLIXR includes\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"survive.h\"\n\nnamespace ILLIXR {\n\nclass lighthouse : public threadloop {\npublic:\n    [[maybe_unused]] lighthouse(const std::string&amp; name_, phonebook* pb_);\n    void stop() override;\n    // destructor\n    ~lighthouse() override = default;\n\nprotected:\n    static void process_slow_pose(SurviveObject* so, survive_long_timecode timecode, const SurvivePose* pose);\n    void        _p_thread_setup() override;\n    void        _p_one_iteration() override;\n\n    skip_option _p_should_skip() override {\n        return skip_option::run;\n    }\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;               switchboard_;\n    const std::shared_ptr&lt;spdlog::logger&gt;            log_;\n    const std::shared_ptr&lt;const relative_clock&gt;      clock_;\n    switchboard::writer&lt;data_format::pose_type&gt;      slow_pose_;\n    switchboard::writer&lt;data_format::fast_pose_type&gt; fast_pose_;\n    SurviveContext*                                  s_context_;\n\n    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; last_time_;\n    int                                                         slow_pose_count_ = 0;\n    int                                                         fast_pose_count_ = 0;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2native__renderer_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2native__renderer_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 22)  set (CMAKE_CXX_STANDARD 17)"},{"location":"api/plugins_2native__renderer_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2native__renderer_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre>"},{"location":"api/plugins_2native__renderer_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    CMAKE_CXX_STANDARD 17\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/native_renderer/CMakeLists.txt</code></p>"},{"location":"api/plugins_2native__renderer_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.22)\n\nproject(native_renderer)\n\nset(PLUGIN_NAME plugin.native_renderer${ILLIXR_BUILD_SUFFIX})\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/display_provider.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/render_pass.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/gl_util/lib/tiny_obj_loader.h\n            $&lt;TARGET_OBJECTS:illixr_vulkan_utils&gt;\n)\n\nset_target_properties(${PLUGIN_NAME} PROPERTIES OUTPUT_NAME ${PLUGIN_NAME})\nif(Vulkan_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${Vulkan_DEP_STR})\nendif()\ntarget_link_libraries(${PLUGIN_NAME} ${Vulkan_LIBRARIES} spdlog::spdlog)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${Vulkan_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2native__renderer_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/native_renderer/README.md</code></p>"},{"location":"api/plugins_2native__renderer_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># native_renderer\n\n## Summary\n\n`native_renderer` utilizes [`vkdemo`][P10] and [`timewarp_vk`][P11] to construct a full rendering pipeline. [\n`vkdemo`][P10] is used to render the scene, and [`timewarp_vk`][P11] is used to perform rotational reprojection. This\nplugin creates the necessary Vulkan resources and targets for [`vkdemo`][P10] and [`timewarp_vk`][P11] to render to, and\nthen composites the results into a single image. The resulting image is presented using the Vulkan swapchain provided by\n`display_vk`.\n\n## Environment Variables\n\n**NATIVE_RENDERER_LOG_LEVEL**: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"\nerror\", \"critical\", or \"off\"\n\n[//]: # (- plugins -)\n\n[P10]:  ../illixr_services.md#vkdemo\n\n[P11]:  ../illixr_plugins.md#timewarp_vk\n</code></pre>"},{"location":"api/plugins_2native__renderer_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; native_renderer &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include \"illixr/gl_util/lib/tiny_obj_loader.h\"</code></li> </ul>"},{"location":"api/plugins_2native__renderer_2plugin_8cpp/#macros","title":"Macros","text":"Type Name define NATIVE_RENDERER_BUFFER_POOL_SIZE <code>3</code> define TINYOBJLOADER_IMPLEMENTATION"},{"location":"api/plugins_2native__renderer_2plugin_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugins_2native__renderer_2plugin_8cpp/#define-native_renderer_buffer_pool_size","title":"define NATIVE_RENDERER_BUFFER_POOL_SIZE","text":"<pre><code>#define NATIVE_RENDERER_BUFFER_POOL_SIZE `3`\n</code></pre>"},{"location":"api/plugins_2native__renderer_2plugin_8cpp/#define-tinyobjloader_implementation","title":"define TINYOBJLOADER_IMPLEMENTATION","text":"<pre><code>#define TINYOBJLOADER_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/native_renderer/plugin.cpp</code></p>"},{"location":"api/plugins_2native__renderer_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; native_renderer &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/global_module_defs.hpp\"\n\n#include &lt;array&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\n#define TINYOBJLOADER_IMPLEMENTATION\n#include \"illixr/gl_util/lib/tiny_obj_loader.h\"\n\n#define NATIVE_RENDERER_BUFFER_POOL_SIZE 3\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] native_renderer::native_renderer(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , log_(spdlogger(switchboard_-&gt;get_env_char(\"NATIVE_RENDERER_LOG_LEVEL\")))\n    , pose_prediction_{phonebook_-&gt;lookup_impl&lt;pose_prediction&gt;()}\n    , display_sink_{phonebook_-&gt;lookup_impl&lt;vulkan::display_provider&gt;()}\n    , timewarp_{phonebook_-&gt;lookup_impl&lt;vulkan::timewarp&gt;()}\n    , app_{phonebook_-&gt;lookup_impl&lt;vulkan::app&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , vsync_{switchboard_-&gt;get_reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\")}\n    , last_fps_update_{std::chrono::duration&lt;long, std::nano&gt;{0}} {\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_WIDTH\") == nullptr || switchboard_-&gt;get_env_char(\"ILLIXR_HEIGHT\") == nullptr) {\n        log_-&gt;warn(\"Please define ILLIXR_WIDTH and ILLIXR_HEIGHT. Default values used.\");\n        width_  = display_sink_-&gt;swapchain_extent_.width;\n        height_ = display_sink_-&gt;swapchain_extent_.height;\n    } else {\n        width_  = std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_WIDTH\"));\n        height_ = std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_HEIGHT\"));\n    }\n\n    export_dma_ = switchboard_-&gt;get_env_bool(\"ILLIXR_EXPORT_DMA\");\n}\n\nnative_renderer::~native_renderer() {\n    vkDeviceWaitIdle(display_sink_-&gt;vk_device_);\n\n    app_-&gt;destroy();\n    timewarp_-&gt;destroy();\n\n    for (auto&amp; framebuffer : swapchain_framebuffers_) {\n        vkDestroyFramebuffer(display_sink_-&gt;vk_device_, framebuffer, nullptr);\n    }\n\n    // drain deletion_queue_\n    while (!deletion_queue_.empty()) {\n        deletion_queue_.top()();\n        deletion_queue_.pop();\n    }\n}\n\nvoid native_renderer::_p_thread_setup() {\n    depth_images_.resize(NATIVE_RENDERER_BUFFER_POOL_SIZE);\n    offscreen_images_.resize(NATIVE_RENDERER_BUFFER_POOL_SIZE);\n    depth_attachment_images_.resize(NATIVE_RENDERER_BUFFER_POOL_SIZE);\n\n    if (timewarp_-&gt;is_external() || app_-&gt;is_external()) {\n        create_offscreen_pool();\n    }\n    for (auto i = 0; i &lt; NATIVE_RENDERER_BUFFER_POOL_SIZE; i++) {\n        for (auto eye = 0; eye &lt; 2; eye++) {\n            create_offscreen_target(offscreen_images_[i][eye]);\n            create_offscreen_target(depth_images_[i][eye]);\n            create_depth_image(depth_attachment_images_[i][eye]);\n        }\n    }\n    this-&gt;buffer_pool_ = std::make_shared&lt;vulkan::buffer_pool&lt;fast_pose_type&gt;&gt;(offscreen_images_, depth_images_);\n\n    command_pool_ =\n        vulkan::create_command_pool(display_sink_-&gt;vk_device_, display_sink_-&gt;queues_[vulkan::queue::GRAPHICS].family);\n    app_command_buffer_      = vulkan::create_command_buffer(display_sink_-&gt;vk_device_, command_pool_);\n    timewarp_command_buffer_ = vulkan::create_command_buffer(display_sink_-&gt;vk_device_, command_pool_);\n    deletion_queue_.emplace([=]() {\n        vkDestroyCommandPool(display_sink_-&gt;vk_device_, command_pool_, nullptr);\n    });\n\n    create_sync_objects();\n    if (!app_-&gt;is_external()) {\n        create_app_pass();\n    }\n    if (!timewarp_-&gt;is_external()) {\n        create_timewarp_pass();\n    }\n    if (!app_-&gt;is_external()) {\n        create_offscreen_framebuffers();\n    }\n    create_swapchain_framebuffers();\n    app_-&gt;setup(app_pass_, 0, buffer_pool_);\n    timewarp_-&gt;setup(timewarp_pass_, 0, buffer_pool_, app_-&gt;is_external());\n}\n\nvoid native_renderer::_p_one_iteration() {\n    if (!timewarp_-&gt;is_external()) {\n        display_sink_-&gt;poll_window_events();\n\n        if (swapchain_image_index_ == UINT32_MAX) {\n            // Acquire the next image from the swapchain\n            auto ret = (vkAcquireNextImageKHR(display_sink_-&gt;vk_device_, display_sink_-&gt;vk_swapchain_, UINT64_MAX,\n                                              image_available_semaphore_, VK_NULL_HANDLE, &amp;swapchain_image_index_));\n\n            // Check if the swapchain is out of date or suboptimal\n            if (ret == VK_ERROR_OUT_OF_DATE_KHR || ret == VK_SUBOPTIMAL_KHR) {\n                display_sink_-&gt;recreate_swapchain();\n                return;\n            } else {\n                VK_ASSERT_SUCCESS(ret)\n            }\n        }\n        VK_ASSERT_SUCCESS(vkResetFences(display_sink_-&gt;vk_device_, 1, &amp;frame_fence_))\n    }\n\n    auto fast_pose = pose_prediction_-&gt;get_fast_pose();\n    if (!app_-&gt;is_external()) {\n        // Get the current fast pose and update the uniforms\n        // log_-&gt;debug(\"Updating uniforms\");\n        app_-&gt;update_uniforms(fast_pose.pose);\n\n        VK_ASSERT_SUCCESS(vkResetCommandBuffer(app_command_buffer_, 0))\n\n        vulkan::image_index_t buffer_index = buffer_pool_-&gt;src_acquire_image();\n\n        // Record the command buffer\n        record_src_command_buffer(buffer_index);\n\n        // Submit the command buffer to the graphics queue\n        const uint64_t ignored     = 0;\n        const uint64_t fired_value = timeline_semaphore_value_ + 1;\n\n        timeline_semaphore_value_ += 1;\n        VkTimelineSemaphoreSubmitInfo timeline_submit_info{\n            VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO, // sType\n            nullptr,                                          // pNext\n            1,                                                // waitSemaphoreValueCount\n            &amp;ignored,                                         // pWaitSemaphoreValues\n            1,                                                // signalSemaphoreValueCount\n            &amp;fired_value                                      // pSignalSemaphoreValues\n        };\n\n        VkSubmitInfo submit_info{\n            VK_STRUCTURE_TYPE_SUBMIT_INFO,  // sType\n            &amp;timeline_submit_info,          // pNext\n            0,                              // waitSemaphoreCount\n            nullptr,                        // pWaitSemaphores\n            nullptr,                        // pWaitDstStageMask\n            1,                              // commandBufferCount\n            &amp;app_command_buffer_,           // pCommandBuffers\n            1,                              // signalSemaphoreCount\n            &amp;app_render_finished_semaphore_ // pSignalSemaphores\n        };\n        if (timewarp_-&gt;is_external()) {\n            submit_info.waitSemaphoreCount = 0;\n            submit_info.pWaitSemaphores    = nullptr;\n            submit_info.pWaitDstStageMask  = nullptr;\n        }\n\n        VK_ASSERT_SUCCESS(\n            vulkan::locked_queue_submit(display_sink_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], 1, &amp;submit_info, nullptr))\n\n        // Wait for the application to finish rendering\n        VkSemaphoreWaitInfo wait_info{\n            VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, // sType\n            nullptr,                               // pNext\n            0,                                     // flags\n            1,                                     // semaphoreCount\n            &amp;app_render_finished_semaphore_,       // pSemaphores\n            &amp;fired_value                           // pValues\n        };\n        VK_ASSERT_SUCCESS(vkWaitSemaphores(display_sink_-&gt;vk_device_, &amp;wait_info, UINT64_MAX))\n        auto pt = fast_pose;\n        buffer_pool_-&gt;src_release_image(buffer_index, std::move(pt));\n    }\n\n    // TODO: for DRM, get vsync estimate\n    auto next_swap = vsync_.get_ro_nullable();\n    if (next_swap == nullptr) {\n        std::this_thread::sleep_for(display_params::period / 6.0 * 5);\n        log_-&gt;debug(\"No vsync estimate!\");\n    } else {\n        // convert next_swap_time to std::chrono::time_point\n        auto next_swap_time_point = std::chrono::time_point&lt;std::chrono::system_clock&gt;(\n            std::chrono::duration_cast&lt;std::chrono::system_clock::duration&gt;((**next_swap).time_since_epoch()));\n        auto current_time = clock_-&gt;now().time_since_epoch();\n        auto diff         = next_swap_time_point - current_time;\n        log_-&gt;debug(\"swap diff: {} ms\", std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(diff.time_since_epoch()).count());\n        next_swap_time_point -= std::chrono::duration_cast&lt;std::chrono::system_clock::duration&gt;(\n            display_params::period / 6.0 * 5); // sleep till 1/6 of the period before vsync to begin timewarp\n        std::this_thread::sleep_until(next_swap_time_point);\n    }\n\n    if (!timewarp_-&gt;is_external()) {\n        // Update the timewarp uniforms and submit the timewarp command buffer to the graphics queue\n        auto res          = buffer_pool_-&gt;post_processing_acquire_image();\n        auto buffer_index = res.first;\n        auto pose         = res.second;\n        timewarp_-&gt;update_uniforms(pose.pose);\n\n        if (buffer_index == -1) {\n            return;\n        }\n\n        record_post_processing_command_buffer(buffer_index, swapchain_image_index_);\n\n        VkPipelineStageFlags wait_stages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};\n        VkSubmitInfo         timewarp_submit_info{\n            VK_STRUCTURE_TYPE_SUBMIT_INFO,       // sType\n            nullptr,                             // pNext\n            1,                                   // waitSemaphoreCount\n            &amp;image_available_semaphore_,         // pWaitSemaphores\n            wait_stages,                         // pWaitDstStageMask\n            1,                                   // commandBufferCount\n            &amp;timewarp_command_buffer_,           // pCommandBuffers\n            1,                                   // signalSemaphoreCount\n            &amp;timewarp_render_finished_semaphore_ // pSignalSemaphores\n        };\n\n        VK_ASSERT_SUCCESS(vulkan::locked_queue_submit(display_sink_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], 1,\n                                                      &amp;timewarp_submit_info, frame_fence_))\n\n        // Present the rendered image\n        VkPresentInfoKHR present_info{\n            VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,   // sType\n            nullptr,                              // pNext\n            1,                                    // waitSemaphoreCount\n            &amp;timewarp_render_finished_semaphore_, // pWaitSemaphores\n            1,                                    // swapchainCount\n            &amp;display_sink_-&gt;vk_swapchain_,        // pSwapchains\n            &amp;swapchain_image_index_,              // pImageIndices\n            nullptr                               // pResults\n        };\n\n        VkResult ret = VK_SUCCESS;\n        {\n            std::lock_guard&lt;std::mutex&gt; lock{*display_sink_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS].mutex};\n            ret = (vkQueuePresentKHR(display_sink_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS].vk_queue, &amp;present_info));\n        }\n\n        // Wait for the previous frame to finish rendering\n        VK_ASSERT_SUCCESS(vkWaitForFences(display_sink_-&gt;vk_device_, 1, &amp;frame_fence_, VK_TRUE, UINT64_MAX))\n\n        swapchain_image_index_ = UINT32_MAX;\n\n        buffer_pool_-&gt;post_processing_release_image(buffer_index);\n\n        if (ret == VK_ERROR_OUT_OF_DATE_KHR || ret == VK_SUBOPTIMAL_KHR) {\n            display_sink_-&gt;recreate_swapchain();\n        } else {\n            VK_ASSERT_SUCCESS(ret)\n        }\n    }\n\n    // #ifndef NDEBUG\n    // Print the FPS\n    if (clock_-&gt;now() - last_fps_update_ &gt; std::chrono::milliseconds(1000)) {\n        log_-&gt;info(\"FPS: {}\", fps_);\n        fps_             = 0;\n        last_fps_update_ = clock_-&gt;now();\n    } else {\n        fps_++;\n    }\n    // #endif\n}\n\n[[maybe_unused]] void native_renderer::recreate_swapchain() {\n    vkDeviceWaitIdle(display_sink_-&gt;vk_device_);\n    for (auto&amp; framebuffer : swapchain_framebuffers_) {\n        vkDestroyFramebuffer(display_sink_-&gt;vk_device_, framebuffer, nullptr);\n    }\n    display_sink_-&gt;recreate_swapchain();\n    create_swapchain_framebuffers();\n}\n\nvoid native_renderer::create_swapchain_framebuffers() {\n    swapchain_framebuffers_.resize(display_sink_-&gt;swapchain_image_views_.size());\n\n    for (ulong i = 0; i &lt; display_sink_-&gt;swapchain_image_views_.size(); i++) {\n        std::array&lt;VkImageView, 1&gt; attachments = {display_sink_-&gt;swapchain_image_views_[i]};\n\n        assert(timewarp_pass_ != VK_NULL_HANDLE);\n        VkFramebufferCreateInfo framebuffer_info{\n            VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, // sType\n            nullptr,                                   // pNext\n            0,                                         // flags\n            timewarp_pass_,                            // renderPass\n            attachments.size(),                        // attachmentCount\n            attachments.data(),                        // pAttachments\n            display_sink_-&gt;swapchain_extent_.width,    // width\n            display_sink_-&gt;swapchain_extent_.height,   // height\n            1                                          // layers\n        };\n\n        VK_ASSERT_SUCCESS(\n            vkCreateFramebuffer(display_sink_-&gt;vk_device_, &amp;framebuffer_info, nullptr, &amp;swapchain_framebuffers_[i]))\n    }\n}\n\nvoid native_renderer::record_src_command_buffer(vulkan::image_index_t buffer_index) {\n    if (!app_-&gt;is_external()) {\n        // Begin recording app command buffer\n        VkCommandBufferBeginInfo begin_info = {\n            VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, // sType\n            nullptr,                                     // pNext\n            0,                                           // flags\n            nullptr                                      // pInheritanceInfo\n        };\n        VK_ASSERT_SUCCESS(vkBeginCommandBuffer(app_command_buffer_, &amp;begin_info))\n\n        for (auto eye = 0; eye &lt; 2; eye++) {\n            assert(app_pass_ != VK_NULL_HANDLE);\n            std::array&lt;VkClearValue, 3&gt; clear_values = {};\n            clear_values[0].color                    = {{1.0f, 1.0f, 1.0f, 1.0f}};\n\n            // Make sure the depth image is also cleared correctly\n            float clear_depth                  = rendering_params::reverse_z ? 0.0f : 1.0f;\n            clear_values[1].color              = {{clear_depth, clear_depth, clear_depth, 1.0f}};\n            clear_values[2].depthStencil.depth = clear_depth;\n\n            VkRenderPassBeginInfo render_pass_info{\n                VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,   // sType\n                nullptr,                                    // pNext\n                app_pass_,                                  // renderPass\n                offscreen_framebuffers_[buffer_index][eye], // framebuffer\n                {\n                    {0, 0},                                                                               // offset\n                    {display_sink_-&gt;swapchain_extent_.width / 2, display_sink_-&gt;swapchain_extent_.height} // extent\n                },                                                                                        // renderArea\n                clear_values.size(),                                                                      // clearValueCount\n                clear_values.data()                                                                       // pClearValues\n            };\n\n            vkCmdBeginRenderPass(app_command_buffer_, &amp;render_pass_info, VK_SUBPASS_CONTENTS_INLINE);\n            // Call app service to record the command buffer\n            app_-&gt;record_command_buffer(app_command_buffer_, offscreen_framebuffers_[buffer_index][eye], buffer_index,\n                                        eye == 0);\n            vkCmdEndRenderPass(app_command_buffer_);\n        }\n        VK_ASSERT_SUCCESS(vkEndCommandBuffer(app_command_buffer_))\n    }\n}\n\nvoid native_renderer::record_post_processing_command_buffer(vulkan::image_index_t buffer_index,\n                                                            uint32_t              swapchain_image_index) {\n    // Begin recording timewarp command buffer\n    VkCommandBufferBeginInfo timewarp_begin_info = {\n        VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, // sType\n        nullptr,                                     // pNext\n        0,                                           // flags\n        nullptr                                      // pInheritanceInfo\n    };\n    VK_ASSERT_SUCCESS(vkBeginCommandBuffer(timewarp_command_buffer_, &amp;timewarp_begin_info))\n\n    for (auto eye = 0; eye &lt; 2; eye++) {\n        timewarp_-&gt;record_command_buffer(timewarp_command_buffer_, swapchain_framebuffers_[swapchain_image_index], buffer_index,\n                                         eye == 0);\n    }\n\n    VK_ASSERT_SUCCESS(vkEndCommandBuffer(timewarp_command_buffer_))\n}\n\nvoid native_renderer::create_sync_objects() {\n    VkSemaphoreTypeCreateInfo timeline_semaphore_info{\n        VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO, // sType\n        nullptr,                                      // pNext\n        VK_SEMAPHORE_TYPE_TIMELINE,                   // semaphoreType\n        0                                             // initialValue\n    };\n\n    VkSemaphoreCreateInfo create_info{\n        VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, // sType\n        &amp;timeline_semaphore_info,                // pNext\n        0                                        // flags\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateSemaphore(display_sink_-&gt;vk_device_, &amp;create_info, nullptr, &amp;app_render_finished_semaphore_))\n    deletion_queue_.emplace([=]() {\n        vkDestroySemaphore(display_sink_-&gt;vk_device_, app_render_finished_semaphore_, nullptr);\n    });\n\n    VkSemaphoreCreateInfo semaphore_info{\n        VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, // sType\n        nullptr,                                 // pNext\n        0                                        // flags\n    };\n    VkFenceCreateInfo fence_info{\n        VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, // sType\n        nullptr,                             // pNext\n        VK_FENCE_CREATE_SIGNALED_BIT         // flags\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateSemaphore(display_sink_-&gt;vk_device_, &amp;semaphore_info, nullptr, &amp;image_available_semaphore_))\n    deletion_queue_.emplace([=]() {\n        vkDestroySemaphore(display_sink_-&gt;vk_device_, image_available_semaphore_, nullptr);\n    });\n\n    VK_ASSERT_SUCCESS(\n        vkCreateSemaphore(display_sink_-&gt;vk_device_, &amp;semaphore_info, nullptr, &amp;timewarp_render_finished_semaphore_))\n    deletion_queue_.emplace([=]() {\n        vkDestroySemaphore(display_sink_-&gt;vk_device_, timewarp_render_finished_semaphore_, nullptr);\n    });\n\n    VK_ASSERT_SUCCESS(vkCreateFence(display_sink_-&gt;vk_device_, &amp;fence_info, nullptr, &amp;frame_fence_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyFence(display_sink_-&gt;vk_device_, frame_fence_, nullptr);\n    });\n}\n\nvoid native_renderer::create_depth_image(vulkan::vk_image&amp; depth_image) {\n    VkImageCreateInfo image_info{\n        VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, // sType\n        nullptr,                             // pNext\n        0,                                   // flags\n        VK_IMAGE_TYPE_2D,                    // imageType\n        VK_FORMAT_D32_SFLOAT,                // format\n        {\n            width_ / 2,                                                           // width\n            height_,                                                              // height\n            1                                                                     // depth\n        },                                                                        // extent\n        1,                                                                        // mipLevels\n        1,                                                                        // arrayLayers\n        VK_SAMPLE_COUNT_1_BIT,                                                    // samples\n        VK_IMAGE_TILING_OPTIMAL,                                                  // tiling\n        VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, // usage\n        {},                                                                       // sharingMode\n        0,                                                                        // queueFamilyIndexCount\n        nullptr,                                                                  // pQueueFamilyIndices\n        {}                                                                        // initialLayout\n    };\n\n    depth_image.image_info = image_info;\n\n    VmaAllocationCreateInfo alloc_info{};\n    alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VK_ASSERT_SUCCESS(vmaCreateImage(display_sink_-&gt;vma_allocator_, &amp;image_info, &amp;alloc_info, &amp;depth_image.image,\n                                     &amp;depth_image.allocation, &amp;depth_image.allocation_info))\n    deletion_queue_.emplace([=]() {\n        vmaDestroyImage(display_sink_-&gt;vma_allocator_, depth_image.image, depth_image.allocation);\n    });\n\n    VkImageViewCreateInfo view_info{\n        VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, // sType\n        nullptr,                                  // pNext\n        0,                                        // flags\n        depth_image.image,                        // image\n        VK_IMAGE_VIEW_TYPE_2D,                    // viewType\n        VK_FORMAT_D32_SFLOAT,                     // format\n        {},                                       // components\n        {\n            VK_IMAGE_ASPECT_DEPTH_BIT, // aspectMask\n            0,                         // baseMipLevel\n            1,                         // levelCount\n            0,                         // baseArrayLayer\n            1                          // layerCount\n        } // subresourceRange\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateImageView(display_sink_-&gt;vk_device_, &amp;view_info, nullptr, &amp;depth_image.image_view))\n    deletion_queue_.emplace([=]() {\n        vkDestroyImageView(display_sink_-&gt;vk_device_, depth_image.image_view, nullptr);\n    });\n}\n\nvoid native_renderer::create_offscreen_pool() {\n    VkImageCreateInfo sample_create_info{\n        VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, // sType\n        nullptr,                             // pNext\n        0,                                   // flags\n        VK_IMAGE_TYPE_2D,                    // imageType\n        VK_FORMAT_B8G8R8A8_UNORM,            // format\n        {\n            width_ / 2,                                                 // width\n            height_,                                                    // height\n            1                                                           // depth\n        },                                                              // extent\n        1,                                                              // mipLevels\n        1,                                                              // arrayLayers\n        VK_SAMPLE_COUNT_1_BIT,                                          // samples\n        export_dma_ ? VK_IMAGE_TILING_LINEAR : VK_IMAGE_TILING_OPTIMAL, // tiling\n        static_cast&lt;VkImageUsageFlags&gt;(\n            (VK_IMAGE_USAGE_TRANSFER_DST_BIT | (export_dma_ ? 0 : VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)) |\n            (timewarp_-&gt;is_external() ? VK_IMAGE_USAGE_TRANSFER_SRC_BIT : VK_IMAGE_USAGE_SAMPLED_BIT)), // usage\n        {},                                                                                             // sharingMode\n        0,                                                                                              // queueFamilyIndexCount\n        nullptr,                                                                                        // pQueueFamilyIndices\n        {}                                                                                              // initialLayout\n    };\n\n    uint32_t                mem_type_index;\n    VmaAllocationCreateInfo alloc_info{.flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT, .usage = VMA_MEMORY_USAGE_GPU_ONLY};\n    vmaFindMemoryTypeIndexForImageInfo(display_sink_-&gt;vma_allocator_, &amp;sample_create_info, &amp;alloc_info, &amp;mem_type_index);\n\n    offscreen_export_mem_alloc_info_.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;\n    offscreen_export_mem_alloc_info_.handleTypes =\n        export_dma_ ? VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT : VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;\n\n    VmaPoolCreateInfo pool_create_info   = {};\n    pool_create_info.memoryTypeIndex     = mem_type_index;\n    pool_create_info.blockSize           = 0;\n    pool_create_info.maxBlockCount       = 0;\n    pool_create_info.pMemoryAllocateNext = &amp;offscreen_export_mem_alloc_info_;\n    this-&gt;offscreen_pool_create_info_    = pool_create_info;\n\n    VK_ASSERT_SUCCESS(vmaCreatePool(display_sink_-&gt;vma_allocator_, &amp;offscreen_pool_create_info_, &amp;offscreen_pool_));\n    deletion_queue_.emplace([=]() {\n        vmaDestroyPool(display_sink_-&gt;vma_allocator_, offscreen_pool_);\n    });\n}\n\nvoid native_renderer::create_offscreen_target(vulkan::vk_image&amp; image) {\n    if (timewarp_-&gt;is_external() || app_-&gt;is_external()) {\n        assert(offscreen_pool_ != VK_NULL_HANDLE);\n        image.export_image_info = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, nullptr,\n                                   export_dma_ ? VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT\n                                               : VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT};\n    }\n\n    std::vector&lt;uint32_t&gt; queue_family_indices;\n    queue_family_indices.push_back(display_sink_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS].family);\n    if (display_sink_-&gt;queues_.find(vulkan::queue::queue_type::COMPUTE) != display_sink_-&gt;queues_.end() &amp;&amp;\n        display_sink_-&gt;queues_.find(vulkan::queue::queue_type::COMPUTE)-&gt;second.family !=\n            display_sink_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS].family) {\n        queue_family_indices.push_back(display_sink_-&gt;queues_[vulkan::queue::queue_type::COMPUTE].family);\n    }\n    if (display_sink_-&gt;queues_.find(vulkan::queue::queue_type::DEDICATED_TRANSFER) != display_sink_-&gt;queues_.end()) {\n        queue_family_indices.push_back(display_sink_-&gt;queues_[vulkan::queue::queue_type::DEDICATED_TRANSFER].family);\n    }\n\n    image.image_info = {\n        VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,                                                    // sType\n        (app_-&gt;is_external() || timewarp_-&gt;is_external()) ? &amp;image.export_image_info : nullptr, // pNext\n        0,                                                                                      // flags\n        VK_IMAGE_TYPE_2D,                                                                       // imageType\n        VK_FORMAT_B8G8R8A8_UNORM,                                                               // format\n        {\n            width_ / 2,          // width\n            height_,             // height\n            1                    // depth\n        },                       // extent\n        1,                       // mipLevels\n        1,                       // arrayLayers\n        VK_SAMPLE_COUNT_1_BIT,   // samples\n        VK_IMAGE_TILING_OPTIMAL, // tiling\n        static_cast&lt;VkImageUsageFlags&gt;(\n            (VK_IMAGE_USAGE_TRANSFER_DST_BIT | (export_dma_ ? 0 : VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)) |\n            (timewarp_-&gt;is_external() ? VK_IMAGE_USAGE_TRANSFER_SRC_BIT : VK_IMAGE_USAGE_SAMPLED_BIT)), // usage\n        VK_SHARING_MODE_CONCURRENT,                                                                     // sharingMode\n        static_cast&lt;uint32_t&gt;(queue_family_indices.size()),                                             // queueFamilyIndexCount\n        queue_family_indices.data(),                                                                    // pQueueFamilyIndices\n        VK_IMAGE_LAYOUT_UNDEFINED                                                                       // initialLayout\n    };\n\n    VmaAllocationCreateInfo alloc_info{.flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT, .usage = VMA_MEMORY_USAGE_GPU_ONLY};\n    if (timewarp_-&gt;is_external() || app_-&gt;is_external()) {\n        alloc_info.pool = offscreen_pool_;\n    }\n\n    VK_ASSERT_SUCCESS(vmaCreateImage(display_sink_-&gt;vma_allocator_, &amp;image.image_info, &amp;alloc_info, &amp;image.image,\n                                     &amp;image.allocation, &amp;image.allocation_info))\n    assert(image.allocation_info.deviceMemory);\n    deletion_queue_.emplace([=]() {\n        vmaDestroyImage(display_sink_-&gt;vma_allocator_, image.image, image.allocation);\n    });\n\n    VkImageViewCreateInfo view_info{\n        VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, // sType\n        nullptr,                                  // pNext\n        0,                                        // flags\n        image.image,                              // image\n        VK_IMAGE_VIEW_TYPE_2D,                    // viewType\n        VK_FORMAT_B8G8R8A8_UNORM,                 // format\n        {},                                       // components\n        {\n            VK_IMAGE_ASPECT_COLOR_BIT, // aspectMask\n            0,                         // baseMipLevel\n            1,                         // levelCount\n            0,                         // baseArrayLayer\n            1                          // layerCount\n        } // subresourceRange\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateImageView(display_sink_-&gt;vk_device_, &amp;view_info, nullptr, &amp;image.image_view))\n\n    if (export_dma_) {\n        VkMemoryGetFdInfoKHR get_fd_info{VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, // sType\n                                         nullptr,                                  // pNext\n                                         image.allocation_info.deviceMemory,       // memory\n                                         VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT};\n\n        auto GetMemoryFdKHR =\n            reinterpret_cast&lt;PFN_vkGetMemoryFdKHR&gt;(vkGetDeviceProcAddr(display_sink_-&gt;vk_device_, \"vkGetMemoryFdKHR\"));\n\n        VK_ASSERT_SUCCESS(GetMemoryFdKHR(display_sink_-&gt;vk_device_, &amp;get_fd_info, &amp;image.fd))\n    }\n\n    deletion_queue_.emplace([=]() {\n        vkDestroyImageView(display_sink_-&gt;vk_device_, image.image_view, nullptr);\n    });\n}\n\nvoid native_renderer::create_offscreen_framebuffers() {\n    offscreen_framebuffers_.resize(NATIVE_RENDERER_BUFFER_POOL_SIZE);\n\n    for (auto i = 0; i &lt; NATIVE_RENDERER_BUFFER_POOL_SIZE; i++) {\n        for (auto eye = 0; eye &lt; 2; eye++) {\n            std::array&lt;VkImageView, 3&gt; attachments = {offscreen_images_[i][eye].image_view, depth_images_[i][eye].image_view,\n                                                      depth_attachment_images_[i][eye].image_view};\n\n            VkFramebufferCreateInfo framebuffer_info{\n                VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,  // sType\n                nullptr,                                    // pNext\n                0,                                          // flags\n                app_pass_,                                  // renderPass\n                static_cast&lt;uint32_t&gt;(attachments.size()),  // attachmentCount\n                attachments.data(),                         // pAttachments\n                display_sink_-&gt;swapchain_extent_.width / 2, // width\n                display_sink_-&gt;swapchain_extent_.height,    // height\n                1                                           // layers\n            };\n\n            VK_ASSERT_SUCCESS(\n                vkCreateFramebuffer(display_sink_-&gt;vk_device_, &amp;framebuffer_info, nullptr, &amp;offscreen_framebuffers_[i][eye]))\n\n            deletion_queue_.emplace([=]() {\n                vkDestroyFramebuffer(display_sink_-&gt;vk_device_, offscreen_framebuffers_[i][eye], nullptr);\n            });\n        }\n    }\n}\n\nvoid native_renderer::create_app_pass() {\n    std::array&lt;VkAttachmentDescription, 3&gt; attachment_descriptions{\n        {{\n             0,                                // flags\n             VK_FORMAT_B8G8R8A8_UNORM,         // format\n             VK_SAMPLE_COUNT_1_BIT,            // samples\n             VK_ATTACHMENT_LOAD_OP_CLEAR,      // loadOp\n             VK_ATTACHMENT_STORE_OP_STORE,     // storeOp\n             VK_ATTACHMENT_LOAD_OP_DONT_CARE,  // stencilLoadOp\n             VK_ATTACHMENT_STORE_OP_DONT_CARE, // stencilStoreOp\n             VK_IMAGE_LAYOUT_UNDEFINED,        // initialLayout\n             timewarp_-&gt;is_external() ? VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL\n                                      : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL // finalLayout\n         },\n         {\n             0,                                // flags\n             VK_FORMAT_B8G8R8A8_UNORM,         // format\n             VK_SAMPLE_COUNT_1_BIT,            // samples\n             VK_ATTACHMENT_LOAD_OP_CLEAR,      // loadOp\n             VK_ATTACHMENT_STORE_OP_STORE,     // storeOp\n             VK_ATTACHMENT_LOAD_OP_DONT_CARE,  // stencilLoadOp\n             VK_ATTACHMENT_STORE_OP_DONT_CARE, // stencilStoreOp\n             VK_IMAGE_LAYOUT_UNDEFINED,        // initialLayout\n             timewarp_-&gt;is_external() ? VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL\n                                      : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL // finalLayout\n         },\n         {\n             0,                                               // flags\n             VK_FORMAT_D32_SFLOAT,                            // format\n             VK_SAMPLE_COUNT_1_BIT,                           // samples\n             VK_ATTACHMENT_LOAD_OP_CLEAR,                     // loadOp\n             VK_ATTACHMENT_STORE_OP_DONT_CARE,                // storeOp\n             VK_ATTACHMENT_LOAD_OP_DONT_CARE,                 // stencilLoadOp\n             VK_ATTACHMENT_STORE_OP_DONT_CARE,                // stencilStoreOp\n             VK_IMAGE_LAYOUT_UNDEFINED,                       // initialLayout\n             VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL // finalLayout\n         }}};\n\n    VkAttachmentReference color_attachment_ref{\n        0,                                       // attachment\n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL // layout\n    };\n\n    VkAttachmentReference depth_image_attachment_ref{\n        1,                                       // attachment\n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL // layout\n    };\n\n    VkAttachmentReference color_refs[2] = {color_attachment_ref, depth_image_attachment_ref};\n\n    VkAttachmentReference depth_attachment_ref{\n        2,                                               // attachment\n        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL // layout\n    };\n\n    VkSubpassDescription subpass = {\n        0,                               // flags\n        VK_PIPELINE_BIND_POINT_GRAPHICS, // pipelineBindPoint\n        0,                               // inputAttachmentCount\n        nullptr,                         // pInputAttachments\n        2,                               // colorAttachmentCount\n        color_refs,                      // pColorAttachments\n        nullptr,                         // pResolveAttachments\n        &amp;depth_attachment_ref,           // pDepthStencilAttachment\n        0,                               // preserveAttachmentCount\n        nullptr                          // pPreserveAttachments\n    };\n\n    // Subpass dependencies for layout transitions\n    std::array&lt;VkSubpassDependency, 3&gt; dependencies{\n        {{\n             // After timewarp samples from the offscreen image, it needs to be transitioned to a color attachment\n             VK_SUBPASS_EXTERNAL,                                                                               // srcSubpass\n             0,                                                                                                 // dstSubpass\n             timewarp_-&gt;is_external() ? VK_PIPELINE_STAGE_TRANSFER_BIT : VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, // srcStageMask\n             VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,                                                     // dstStageMask\n             timewarp_-&gt;is_external() ? VK_ACCESS_TRANSFER_READ_BIT : VK_ACCESS_SHADER_READ_BIT,                // srcAccessMask\n             VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,                                                              // dstAccessMask\n             VK_DEPENDENCY_BY_REGION_BIT // dependencyFlags\n         },\n         {\n             // After the app is done rendering to the offscreen image, it needs to be transitioned to a shader read\n             0,                                             // srcSubpass\n             VK_SUBPASS_EXTERNAL,                           // dstSubpass\n             VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, // srcStageMask\n             timewarp_-&gt;is_external()\n                 ? VK_PIPELINE_STAGE_TRANSFER_BIT\n                 : VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,  // dstStageMask\n             VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,                                               // srcAccessMask\n             timewarp_-&gt;is_external() ? VK_ACCESS_TRANSFER_READ_BIT : VK_ACCESS_SHADER_READ_BIT, // dstAccessMask\n             VK_DEPENDENCY_BY_REGION_BIT                                                         // dependencyFlags\n         },\n         {// depth buffer write-after-write hazard\n          VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,\n          VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,\n          VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT, 0}}};\n\n    VkRenderPassCreateInfo render_pass_info{\n        VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,             // sType\n        nullptr,                                               // pNext\n        0,                                                     // flags\n        static_cast&lt;uint32_t&gt;(attachment_descriptions.size()), // attachmentCount\n        attachment_descriptions.data(),                        // pAttachments\n        1,                                                     // subpassCount\n        &amp;subpass,                                              // pSubpasses\n        static_cast&lt;uint32_t&gt;(dependencies.size()),            // dependencyCount\n        dependencies.data()                                    // pDependencies\n    };\n    VK_ASSERT_SUCCESS(vkCreateRenderPass(display_sink_-&gt;vk_device_, &amp;render_pass_info, nullptr, &amp;app_pass_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyRenderPass(display_sink_-&gt;vk_device_, app_pass_, nullptr);\n    });\n}\n\nvoid native_renderer::create_timewarp_pass() {\n    std::array&lt;VkAttachmentDescription, 1&gt; attchmentDescriptions{{{\n        0,                                             // flags\n        display_sink_-&gt;swapchain_image_format_.format, // format\n        VK_SAMPLE_COUNT_1_BIT,                         // samples\n        VK_ATTACHMENT_LOAD_OP_DONT_CARE,               // loadOp\n        VK_ATTACHMENT_STORE_OP_STORE,                  // storeOp\n        VK_ATTACHMENT_LOAD_OP_DONT_CARE,               // stencilLoadOp\n        VK_ATTACHMENT_STORE_OP_DONT_CARE,              // stencilStoreOp\n        VK_IMAGE_LAYOUT_UNDEFINED,                     // initialLayout\n        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR                // finalLayout\n    }}};\n\n    VkAttachmentReference color_attachment_ref{\n        0,                                       // attachment\n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL // layout\n    };\n\n    VkSubpassDependency dependency = {\n        .srcSubpass    = VK_SUBPASS_EXTERNAL,\n        .dstSubpass    = 0,\n        .srcStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n        .dstStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n        .srcAccessMask = 0,\n        .dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,\n    };\n\n    VkSubpassDescription subpass = {\n        0,                               // flags\n        VK_PIPELINE_BIND_POINT_GRAPHICS, // pipelineBindPoint\n        0,                               // inputAttachmentCount\n        nullptr,                         // pInputAttachments\n        1,                               // colorAttachmentCount\n        &amp;color_attachment_ref,           // pColorAttachments\n        nullptr,                         // pResolveAttachments\n        nullptr,                         // pDepthStencilAttachment\n        0,                               // preserveAttachmentCount\n        nullptr                          // pPreserveAttachments\n    };\n\n    // assert(app_-&gt;is_external());\n\n    VkRenderPassCreateInfo render_pass_info{\n        VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,           // sType\n        nullptr,                                             // pNext\n        0,                                                   // flags\n        static_cast&lt;uint32_t&gt;(attchmentDescriptions.size()), // attachmentCount\n        attchmentDescriptions.data(),                        // pAttachments\n        1,                                                   // subpassCount\n        &amp;subpass,                                            // pSubpasses\n        1,                                                   // dependencyCount\n        &amp;dependency                                          // pDependencies\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateRenderPass(display_sink_-&gt;vk_device_, &amp;render_pass_info, nullptr, &amp;timewarp_pass_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyRenderPass(display_sink_-&gt;vk_device_, timewarp_pass_, nullptr);\n    });\n}\n\nPLUGIN_MAIN(native_renderer)\n</code></pre>"},{"location":"api/plugins_2native__renderer_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; native_renderer &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include \"illixr/vk/vulkan_utils.hpp\"</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;stack&gt;</code></li> </ul>"},{"location":"api/plugins_2native__renderer_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2native__renderer_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class native_renderer <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/native_renderer/plugin.hpp</code></p>"},{"location":"api/plugins_2native__renderer_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; native_renderer &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n#include \"illixr/vk/vulkan_utils.hpp\"\n\n#include &lt;functional&gt;\n#include &lt;stack&gt;\n\nnamespace ILLIXR {\nclass native_renderer : public threadloop {\npublic:\n    [[maybe_unused]] native_renderer(const std::string&amp; name, phonebook* pb);\n    ~native_renderer() override;\n\n    void _p_thread_setup() override;\n\n    void _p_one_iteration() override;\n\nprivate:\n    [[maybe_unused]] void recreate_swapchain();\n\n    void create_swapchain_framebuffers();\n\n    void record_src_command_buffer(vulkan::image_index_t buffer_index);\n\n    void record_post_processing_command_buffer(vulkan::image_index_t buffer_index, uint32_t swapchain_image_index_);\n    void create_sync_objects();\n\n    void create_depth_image(vulkan::vk_image&amp; depth_image);\n\n    void create_offscreen_target(vulkan::vk_image&amp; image);\n\n    void create_offscreen_pool();\n\n    void create_offscreen_framebuffers();\n\n    void create_app_pass();\n\n    void create_timewarp_pass();\n\n    const std::shared_ptr&lt;switchboard&gt;                  switchboard_;\n    const std::shared_ptr&lt;spdlog::logger&gt;               log_;\n    const std::shared_ptr&lt;data_format::pose_prediction&gt; pose_prediction_;\n    const std::shared_ptr&lt;vulkan::display_provider&gt;     display_sink_;\n    const std::shared_ptr&lt;vulkan::timewarp&gt;             timewarp_;\n    const std::shared_ptr&lt;vulkan::app&gt;                  app_;\n    const std::shared_ptr&lt;const relative_clock&gt;         clock_;\n\n    uint32_t width_      = 0;\n    uint32_t height_     = 0;\n    bool     export_dma_ = false;\n\n    std::stack&lt;std::function&lt;void()&gt;&gt; deletion_queue_;\n\n    VkCommandPool   command_pool_{};\n    VkCommandBuffer app_command_buffer_{};\n    VkCommandBuffer timewarp_command_buffer_{};\n\n    std::vector&lt;std::array&lt;vulkan::vk_image, 2&gt;&gt; depth_images_{};\n    std::vector&lt;std::array&lt;vulkan::vk_image, 2&gt;&gt; depth_attachment_images_{};\n\n    VkExportMemoryAllocateInfo                offscreen_export_mem_alloc_info_{};\n    VmaPoolCreateInfo                         offscreen_pool_create_info_{};\n    VmaPool                                   offscreen_pool_{};\n    std::vector&lt;std::array&lt;VkFramebuffer, 2&gt;&gt; offscreen_framebuffers_{};\n\n    std::vector&lt;std::array&lt;vulkan::vk_image, 2&gt;&gt; offscreen_images_{};\n\n    std::vector&lt;VkFramebuffer&gt; swapchain_framebuffers_{};\n\n    VkRenderPass app_pass_{};\n\n    VkRenderPass timewarp_pass_{};\n    VkSemaphore  image_available_semaphore_{};\n    VkSemaphore  app_render_finished_semaphore_{};\n    VkSemaphore  timewarp_render_finished_semaphore_{};\n\n    VkFence frame_fence_{};\n\n    uint32_t swapchain_image_index_    = UINT32_MAX; // set to UINT32_MAX after present\n    uint64_t timeline_semaphore_value_ = 1;\n\n    int                                                         fps_{};\n    switchboard::reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_;\n    time_point                                                  last_fps_update_;\n\n    std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offline__cam_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offline__cam_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.offline_cam${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2offline__cam_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offline__cam_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.offline_cam${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_cam/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offline__cam_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the offline_cam ILLIXR plugin\n\nset(PLUGIN_NAME plugin.offline_cam${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_loading.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/csv_iterator.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${OpenCV_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${OpenCV_LIBRARIES} ${Eigen3_LIBRARIES} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offline__cam_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; offline_cam &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/data_loading.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/plugins_2offline__cam_2plugin_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::map&lt; ullong, sensor_types &gt; make_map (const std::map&lt; ullong, lazy_load_image &gt; &amp; cam0, const std::map&lt; ullong, lazy_load_image &gt; &amp; cam1)  std::map&lt; ullong, lazy_load_image &gt; read_data (std::ifstream &amp; gt_file, const std::string &amp; file_name)"},{"location":"api/plugins_2offline__cam_2plugin_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offline__cam_2plugin_8cpp/#function-make_map","title":"function make_map","text":"<pre><code>std::map&lt; ullong, sensor_types &gt; make_map (\n    const std::map&lt; ullong, lazy_load_image &gt; &amp; cam0,\n    const std::map&lt; ullong, lazy_load_image &gt; &amp; cam1\n) \n</code></pre>"},{"location":"api/plugins_2offline__cam_2plugin_8cpp/#function-read_data","title":"function read_data","text":"<pre><code>inline std::map&lt; ullong, lazy_load_image &gt; read_data (\n    std::ifstream &amp; gt_file,\n    const std::string &amp; file_name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_cam/plugin.cpp</code></p>"},{"location":"api/plugins_2offline__cam_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; offline_cam &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/data_loading.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;regex&gt;\n#include &lt;thread&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n// combine two maps into one\nstd::map&lt;ullong, sensor_types&gt; make_map(const std::map&lt;ullong, lazy_load_image&gt;&amp; cam0,\n                                        const std::map&lt;ullong, lazy_load_image&gt;&amp; cam1) {\n    std::map&lt;ullong, sensor_types&gt; data;\n    for (auto&amp; it : cam0) {\n        data[it.first].cam0 = it.second;\n    }\n    for (auto&amp; it : cam1) {\n        data[it.first].cam1 = it.second;\n    }\n    return data;\n}\n\ninline std::map&lt;ullong, lazy_load_image&gt; read_data(std::ifstream&amp; gt_file, const std::string&amp; file_name) {\n    std::map&lt;ullong, lazy_load_image&gt; data;\n    auto                              name = std::regex_replace(file_name, std::regex(\"\\\\.csv\"), \"/\");\n    for (csv_iterator row{gt_file, 1}; row != csv_iterator{}; ++row) {\n        ullong t = std::stoull(row[0]);\n        data[t]  = lazy_load_image{name + row[1]};\n    }\n    return data;\n}\n\n[[maybe_unused]] offline_cam::offline_cam(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , cam_publisher_{switchboard_-&gt;get_writer&lt;binocular_cam_type&gt;(\"cam\")}\n    , sensor_data_{make_map(load_data&lt;lazy_load_image&gt;(\"cam0\", \"offline_cam\", &amp;read_data, switchboard_),\n                            load_data&lt;lazy_load_image&gt;(\"cam1\", \"offline_cam\", &amp;read_data, switchboard_))}\n    , dataset_first_time_{sensor_data_.cbegin()-&gt;first}\n    , last_timestamp_{0}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , next_row_{sensor_data_.cbegin()} {\n    spdlogger(switchboard_-&gt;get_env_char(\"OFFLINE_CAM_LOG_LEVEL\"));\n}\n\nILLIXR::threadloop::skip_option offline_cam::_p_should_skip() {\n    if (true) {\n        return skip_option::run;\n    } else {\n        return skip_option::stop;\n    }\n}\n\nvoid offline_cam::_p_one_iteration() {\n    duration time_since_start = clock_-&gt;now().time_since_epoch();\n    // duration begin            = time_since_start;\n    ullong lookup_time = std::chrono::nanoseconds{time_since_start}.count() + dataset_first_time_;\n    std::map&lt;ullong, sensor_types&gt;::const_iterator nearest_row;\n\n    // \"std::map::upper_bound\" returns an iterator to the first pair whose key is GREATER than the argument.\n    auto after_nearest_row = sensor_data_.upper_bound(lookup_time);\n\n    if (after_nearest_row == sensor_data_.cend()) {\n#ifndef NDEBUG\n        spdlog::get(name_)-&gt;warn(\"Running out of the dataset! Time {} ({} + {}) after last datum {}\", lookup_time,\n                                 clock_-&gt;now().time_since_epoch().count(), dataset_first_time_, sensor_data_.rbegin()-&gt;first);\n#endif\n        // Handling the last camera images. There's no more rows after the nearest_row, so we set after_nearest_row\n        // to be nearest_row to avoiding sleeping at the end.\n        nearest_row       = std::prev(after_nearest_row, 1);\n        after_nearest_row = nearest_row;\n        // We are running out of the dataset and the loop will stop next time.\n        internal_stop();\n    } else if (after_nearest_row == sensor_data_.cbegin()) {\n        // Should not happen because lookup_time is bigger than dataset_first_time_\n#ifndef NDEBUG\n        spdlog::get(name_)-&gt;warn(\"Time {} ({} + {}) before first datum {}\", lookup_time,\n                                 clock_-&gt;now().time_since_epoch().count(), dataset_first_time_, sensor_data_.cbegin()-&gt;first);\n#endif\n    } else {\n        // Most recent\n        nearest_row = std::prev(after_nearest_row, 1);\n    }\n\n    if (last_timestamp_ != nearest_row-&gt;first) {\n        last_timestamp_ = nearest_row-&gt;first;\n\n        auto img0 = nearest_row-&gt;second.cam0.load();\n        auto img1 = nearest_row-&gt;second.cam1.load();\n\n        time_point expected_real_time_given_dataset_time(\n            std::chrono::duration&lt;long, std::nano&gt;{nearest_row-&gt;first - dataset_first_time_});\n        cam_publisher_.put(cam_publisher_.allocate&lt;binocular_cam_type&gt;(binocular_cam_type{\n            expected_real_time_given_dataset_time,\n            img0,\n            img1,\n        }));\n    }\n    std::this_thread::sleep_for(std::chrono::nanoseconds(after_nearest_row-&gt;first - dataset_first_time_ -\n                                                         clock_-&gt;now().time_since_epoch().count() - 2));\n}\n\nPLUGIN_MAIN(offline_cam)\n</code></pre>"},{"location":"api/plugins_2offline__cam_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; offline_cam &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/data_loading.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include &lt;opencv2/imgcodecs.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2offline__cam_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offline__cam_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class lazy_load_image class offline_cam struct sensor_types <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_cam/plugin.hpp</code></p>"},{"location":"api/plugins_2offline__cam_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; offline_cam &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/data_loading.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n#include &lt;opencv2/imgcodecs.hpp&gt;\n\nnamespace ILLIXR {\n\n/*\n * Uncommenting this preprocessor macro makes the offline_cam load each data from the disk as it is needed.\n * Otherwise, we load all of them at the beginning, hold them in memory, and drop them in the queue as needed.\n * Lazy loading has an artificial negative impact on performance which is absent from an online-sensor system.\n * Eager loading deteriorates the startup time and uses more memory.\n */\n// #define LAZY\n\nclass lazy_load_image {\npublic:\n    lazy_load_image() = default;\n\n    explicit lazy_load_image(std::string path)\n        : path_(std::move(path)) {\n#ifndef LAZY\n        mat_ = cv::imread(path_, cv::IMREAD_GRAYSCALE);\n#endif\n    }\n\n    [[nodiscard]] cv::Mat load() const {\n#ifdef LAZY\n        cv::Mat mat_ = cv::imread(path_, cv::IMREAD_GRAYSCALE);\n    #error \"Linux scheduler cannot interrupt IO work, so lazy-loading is unadvisable.\"\n#endif\n        assert(!mat_.empty());\n        return mat_;\n    }\n\nprivate:\n    std::string path_;\n    cv::Mat     mat_;\n};\n\ntypedef struct {\n    lazy_load_image cam0;\n    lazy_load_image cam1;\n} sensor_types;\n\nclass offline_cam : public threadloop {\npublic:\n    [[maybe_unused]] offline_cam(const std::string&amp; name, phonebook* pb);\n    skip_option _p_should_skip() override;\n    void        _p_one_iteration() override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;                   switchboard_;\n    switchboard::writer&lt;data_format::binocular_cam_type&gt; cam_publisher_;\n    const std::map&lt;ullong, sensor_types&gt;                 sensor_data_;\n    ullong                                               dataset_first_time_;\n    ullong                                               last_timestamp_;\n    std::shared_ptr&lt;relative_clock&gt;                      clock_;\n    std::map&lt;ullong, sensor_types&gt;::const_iterator       next_row_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offline__imu_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offline__imu_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.offline_imu${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2offline__imu_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offline__imu_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.offline_imu${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_imu/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offline__imu_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the offline_imu ILLIXR plugin\n\nset(PLUGIN_NAME plugin.offline_imu${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_loading.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/managed_thread.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/csv_iterator.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n)\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${Eigne3_LIBRARIES} spdlog::spdlog)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offline__imu_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; offline_imu &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/data_loading.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> </ul>"},{"location":"api/plugins_2offline__imu_2plugin_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::map&lt; ullong, sensor_types &gt; read_data (std::ifstream &amp; gt_file, const std::string &amp; file_name)"},{"location":"api/plugins_2offline__imu_2plugin_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offline__imu_2plugin_8cpp/#function-read_data","title":"function read_data","text":"<pre><code>inline std::map&lt; ullong, sensor_types &gt; read_data (\n    std::ifstream &amp; gt_file,\n    const std::string &amp; file_name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_imu/plugin.cpp</code></p>"},{"location":"api/plugins_2offline__imu_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; offline_imu &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/data_loading.hpp\"\n\n#include &lt;chrono&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\ninline std::map&lt;ullong, sensor_types&gt; read_data(std::ifstream&amp; gt_file, const std::string&amp; file_name) {\n    (void) file_name;\n    std::map&lt;ullong, sensor_types&gt; data;\n\n    for (csv_iterator row{gt_file, 1}; row != csv_iterator{}; ++row) {\n        ullong          t = std::stoull(row[0]);\n        Eigen::Vector3d av{std::stod(row[1]), std::stod(row[2]), std::stod(row[3])};\n        Eigen::Vector3d la{std::stod(row[4]), std::stod(row[5]), std::stod(row[6])};\n        data[t].imu0 = {av, la};\n    }\n    return data;\n}\n\n[[maybe_unused]] offline_imu::offline_imu(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , sensor_data_{load_data&lt;sensor_types&gt;(\"imu0\", \"offline_imu\", &amp;read_data, switchboard_)}\n    , sensor_data_it_{sensor_data_.cbegin()}\n    , imu_{switchboard_-&gt;get_writer&lt;imu_type&gt;(\"imu\")}\n    , dataset_first_time_{sensor_data_it_-&gt;first}\n    , dataset_now_{0}\n    , imu_cam_log_{record_logger_}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()} { }\n\nILLIXR::threadloop::skip_option offline_imu::_p_should_skip() {\n    if (sensor_data_it_ != sensor_data_.end()) {\n        assert(dataset_now_ &lt; sensor_data_it_-&gt;first);\n        dataset_now_ = sensor_data_it_-&gt;first;\n        // Sleep for the difference between the current IMU vs 1st IMU and current UNIX time vs UNIX time the component was\n        // init\n        std::this_thread::sleep_for(std::chrono::nanoseconds{dataset_now_ - dataset_first_time_} -\n                                    clock_-&gt;now().time_since_epoch());\n\n        return skip_option::run;\n\n    } else {\n        return skip_option::stop;\n    }\n}\n\nvoid offline_imu::_p_one_iteration() {\n    assert(sensor_data_it_ != sensor_data_.end());\n    time_point          real_now(std::chrono::duration&lt;long, std::nano&gt;{dataset_now_ - dataset_first_time_});\n    const sensor_types&amp; sensor_datum = sensor_data_it_-&gt;second;\n\n    imu_.put(imu_.allocate&lt;imu_type&gt;(imu_type{real_now, (sensor_datum.imu0.angular_v), (sensor_datum.imu0.linear_a)}));\n    ++sensor_data_it_;\n}\n\nPLUGIN_MAIN(offline_imu)\n</code></pre>"},{"location":"api/plugins_2offline__imu_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; offline_imu &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/managed_thread.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include &lt;map&gt;</code></li> </ul>"},{"location":"api/plugins_2offline__imu_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offline__imu_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class offline_imu struct raw_imu_type struct sensor_types <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_imu/plugin.hpp</code></p>"},{"location":"api/plugins_2offline__imu_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; offline_imu &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/managed_thread.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n#include &lt;map&gt;\n\nnamespace ILLIXR {\n\ntypedef struct {\n    Eigen::Vector3d angular_v;\n    Eigen::Vector3d linear_a;\n} raw_imu_type;\n\ntypedef struct {\n    raw_imu_type imu0;\n} sensor_types;\n\nclass offline_imu : public threadloop {\npublic:\n    [[maybe_unused]] offline_imu(const std::string&amp; name, phonebook* pb);\n\nprotected:\n    skip_option _p_should_skip() override;\n    void        _p_one_iteration() override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;             switchboard_;\n    const std::map&lt;ullong, sensor_types&gt;           sensor_data_;\n    std::map&lt;ullong, sensor_types&gt;::const_iterator sensor_data_it_;\n    switchboard::writer&lt;data_format::imu_type&gt;     imu_;\n\n    // Timestamp of the first IMU value from the dataset\n    ullong dataset_first_time_;\n    // Current IMU timestamp\n    ullong dataset_now_;\n\n    record_coalescer imu_cam_log_;\n\n    std::shared_ptr&lt;relative_clock&gt; clock_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offload__data_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offload__data_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.offload_data${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2offload__data_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offload__data_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.offload_data${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_data/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offload__data_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the offload_data ILLIXR plugin\n\nset(PLUGIN_NAME plugin.offload_data${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/error_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${Boost_INCLUDE_DIR} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} boost_filesystem ${Eigen3_LIBRARIES} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offload__data_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; offload_data &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;boost/filesystem.hpp&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include \"illixr/gl_util/lib/stb_image_write.h\"</code></li> </ul>"},{"location":"api/plugins_2offload__data_2plugin_8cpp/#macros","title":"Macros","text":"Type Name define STB_IMAGE_WRITE_IMPLEMENTATION"},{"location":"api/plugins_2offload__data_2plugin_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugins_2offload__data_2plugin_8cpp/#define-stb_image_write_implementation","title":"define STB_IMAGE_WRITE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_WRITE_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_data/plugin.cpp</code></p>"},{"location":"api/plugins_2offload__data_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; offload_data &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;boost/filesystem.hpp&gt;\n#include &lt;fstream&gt;\n#include &lt;numeric&gt;\n\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"\n#include \"illixr/gl_util/lib/stb_image_write.h\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] offload_data::offload_data(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , percent_{0}\n    , img_idx_{0}\n    , enable_offload_{switchboard_-&gt;get_env_bool(\"ILLIXR_OFFLOAD_ENABLE\", \"False\")}\n    , is_success_{true} \n    , obj_dir_{switchboard_-&gt;get_env_char(\"ILLIXR_OFFLOAD_PATH\", \"metrics/offloaded_data/\")} {\n    spdlogger(switchboard_-&gt;get_env_char(\"OFFLOAD_DATA_LOG_LEVEL\"));\n    switchboard_-&gt;schedule&lt;texture_pose&gt;(id_, \"texture_pose\", [&amp;](const switchboard::ptr&lt;const texture_pose&gt;&amp; datum, size_t) {\n        callback(datum);\n    });\n}\n\nvoid offload_data::callback(const switchboard::ptr&lt;const texture_pose&gt;&amp; datum) {\n#ifndef NDEBUG\n    spdlog::get(name_)-&gt;debug(\"Image index: {}\", img_idx_++);\n#endif\n    offload_data_container_.push_back(datum);\n}\n\noffload_data::~offload_data() {\n    // Write offloaded data from memory to disk\n    if (enable_offload_) {\n        boost::filesystem::path p(obj_dir_);\n        boost::filesystem::remove_all(p);\n        boost::filesystem::create_directories(p);\n\n        write_data_to_disk();\n    }\n}\n\nvoid offload_data::write_metadata() {\n    double mean  = std::accumulate(time_seq_.begin(), time_seq_.end(), 0.0) / static_cast&lt;double&gt;(time_seq_.size());\n    double accum = 0.0;\n    std::for_each(std::begin(time_seq_), std::end(time_seq_), [&amp;](const double d) {\n        accum += (d - mean) * (d - mean);\n    });\n    double stdev = sqrt(accum / static_cast&lt;double&gt;((time_seq_.size() - 1)));\n\n    auto max = std::max_element(time_seq_.begin(), time_seq_.end());\n    auto min = std::min_element(time_seq_.begin(), time_seq_.end());\n\n    std::ofstream meta_file(obj_dir_ + \"metadata.out\");\n    if (meta_file.is_open()) {\n        meta_file &lt;&lt; \"mean: \" &lt;&lt; mean &lt;&lt; std::endl;\n        meta_file &lt;&lt; \"max: \" &lt;&lt; *max &lt;&lt; std::endl;\n        meta_file &lt;&lt; \"min: \" &lt;&lt; *min &lt;&lt; std::endl;\n        meta_file &lt;&lt; \"stdev: \" &lt;&lt; stdev &lt;&lt; std::endl;\n        meta_file &lt;&lt; \"total number: \" &lt;&lt; time_seq_.size() &lt;&lt; std::endl;\n\n        meta_file &lt;&lt; \"raw time: \" &lt;&lt; std::endl;\n        for (long&amp; it : time_seq_)\n            meta_file &lt;&lt; it &lt;&lt; \" \";\n        meta_file &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; std::endl;\n\n        meta_file &lt;&lt; \"ordered time: \" &lt;&lt; std::endl;\n        std::sort(time_seq_.begin(), time_seq_.end(), [](int x, int y) {\n            return x &gt; y;\n        });\n        for (long&amp; it : time_seq_)\n            meta_file &lt;&lt; it &lt;&lt; \" \";\n    }\n    meta_file.close();\n}\n\nvoid offload_data::write_data_to_disk() {\n    stbi_flip_vertically_on_write(true);\n\n    spdlog::get(name_)-&gt;info(\"Writing offloaded images to disk...\");\n    img_idx_ = 0;\n    for (auto&amp; container_it : offload_data_container_) {\n        // Get collecting time for each frame\n        time_seq_.push_back(\n            std::chrono::duration_cast&lt;std::chrono::duration&lt;long, std::milli&gt;&gt;(container_it-&gt;offload_duration).count());\n\n        std::string image_name = obj_dir_ + std::to_string(img_idx_) + \".png\";\n        std::string pose_name  = obj_dir_ + std::to_string(img_idx_) + \".txt\";\n\n        // Write image\n        is_success_ = stbi_write_png(image_name.c_str(), display_params::width_pixels, display_params::height_pixels, 3,\n                                     container_it-&gt;image, 0);\n        if (!is_success_) {\n            ILLIXR::abort(\"Image create failed !!! \");\n        }\n\n        // Write pose\n        std::ofstream pose_file(pose_name);\n        if (pose_file.is_open()) {\n            // Transfer timestamp to duration\n            auto duration = (container_it-&gt;pose_time).time_since_epoch().count();\n\n            // Write time data\n            pose_file &lt;&lt; \"strTime: \" &lt;&lt; duration &lt;&lt; std::endl;\n\n            // Write position coordinates in x y z\n            int pose_size = static_cast&lt;int&gt;(container_it-&gt;position.size());\n            pose_file &lt;&lt; \"pos: \";\n            for (int pos_idx = 0; pos_idx &lt; pose_size; pos_idx++)\n                pose_file &lt;&lt; container_it-&gt;position(pos_idx) &lt;&lt; \" \";\n            pose_file &lt;&lt; std::endl;\n\n            // Write quaternion in w x y z\n            pose_file &lt;&lt; \"latest_pose_orientation: \";\n            pose_file &lt;&lt; container_it-&gt;latest_quaternion.w() &lt;&lt; \" \";\n            pose_file &lt;&lt; container_it-&gt;latest_quaternion.x() &lt;&lt; \" \";\n            pose_file &lt;&lt; container_it-&gt;latest_quaternion.y() &lt;&lt; \" \";\n            pose_file &lt;&lt; container_it-&gt;latest_quaternion.z() &lt;&lt; std::endl;\n\n            pose_file &lt;&lt; \"render_pose_orientation: \";\n            pose_file &lt;&lt; container_it-&gt;render_quaternion.w() &lt;&lt; \" \";\n            pose_file &lt;&lt; container_it-&gt;render_quaternion.x() &lt;&lt; \" \";\n            pose_file &lt;&lt; container_it-&gt;render_quaternion.y() &lt;&lt; \" \";\n            pose_file &lt;&lt; container_it-&gt;render_quaternion.z();\n        }\n        pose_file.close();\n\n        // Print progress\n        percent_ = static_cast&lt;int&gt;(100 * (img_idx_ + 1) / offload_data_container_.size());\n        std::cout &lt;&lt; \"\\r\"\n                  &lt;&lt; \"[\" &lt;&lt; std::string(percent_ / 2, (char) 61u) &lt;&lt; std::string(100 / 2 - percent_ / 2, ' ') &lt;&lt; \"] \";\n        std::cout &lt;&lt; percent_ &lt;&lt; \"%\"\n                  &lt;&lt; \" [Image \" &lt;&lt; img_idx_++ &lt;&lt; \" of \" &lt;&lt; offload_data_container_.size() &lt;&lt; \"]\";\n        std::cout.flush();\n    }\n    std::cout &lt;&lt; std::endl;\n    write_metadata();\n}\n\nPLUGIN_MAIN(offload_data)\n</code></pre>"},{"location":"api/plugins_2offload__data_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; offload_data &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> </ul>"},{"location":"api/plugins_2offload__data_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offload__data_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class offload_data <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_data/plugin.hpp</code></p>"},{"location":"api/plugins_2offload__data_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; offload_data &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\nnamespace ILLIXR {\nclass offload_data : public plugin {\npublic:\n    [[maybe_unused]] offload_data(const std::string&amp; name, phonebook* pb);\n    void callback(const switchboard::ptr&lt;const data_format::texture_pose&gt;&amp; datum);\n    ~offload_data() override;\n\nprivate:\n    void write_metadata();\n    void write_data_to_disk();\n\n    const std::shared_ptr&lt;switchboard&gt;                             switchboard_;\n    std::vector&lt;long&gt;                                              time_seq_;\n    std::vector&lt;switchboard::ptr&lt;const data_format::texture_pose&gt;&gt; offload_data_container_;\n\n    int         percent_;\n    int         img_idx_;\n    bool        enable_offload_;\n    bool        is_success_;\n    std::string obj_dir_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offload__rendering__client_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offload__rendering__client_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 16)  set (CMAKE_CXX_STANDARD 17)"},{"location":"api/plugins_2offload__rendering__client_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offload__rendering__client_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 16\n) \n</code></pre>"},{"location":"api/plugins_2offload__rendering__client_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    CMAKE_CXX_STANDARD 17\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offload__rendering__client_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.16)\n\nproject(offload_rendering_client)\n\nset(PLUGIN_NAME plugin.offload_rendering_client${ILLIXR_BUILD_SUFFIX})\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# ffmpeg\nget_external_for_plugin(ILLIXR_FFmpeg)\n\nfind_package(CUDAToolkit REQUIRED)\n\nadd_compile_definitions(ILLIXR_LIBAV)\n\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            offload_rendering_client.hpp\n            offload_rendering_client.cpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/serializable_data.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/frame.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/display_provider.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/ffmpeg_utils.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/render_pass.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/vk_extension_request.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/vulkan_utils.hpp\n            ${CMAKE_SOURCE_DIR}/utils/serializable_data.cpp\n)\n\nset_target_properties(${PLUGIN_NAME} PROPERTIES OUTPUT_NAME ${PLUGIN_NAME})\nif(Vulkan_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${Vulkan_DEP_STR})\nendif()\nif(ILLIXR_FFmpeg_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${ILLIXR_FFmpeg_DEP_STR})\nendif()\n\ntarget_link_libraries(${PLUGIN_NAME} illixr_vulkan_utils spdlog::spdlog ${Vulkan_LIBRARIES})\ntarget_include_directories(${PLUGIN_NAME} BEFORE PUBLIC ${Vulkan_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\ntarget_link_libraries(${PLUGIN_NAME} ${libavdevice_illixr_LIBRARIES} ${libavformat_illixr_LIBRARIES} ${libavcodec_illixr_LIBRARIES} ${libavutil_illixr_LIBRARIES} ${libswscale_illixr_LIBRARIES})\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${libavcodec_illixr_INCLUDE_DIRS})\n\ntarget_link_libraries(${PLUGIN_NAME} CUDA::cudart CUDA::nppif CUDA::nppial CUDA::nppicc CUDA::nppidei CUDA::nppig CUDA::nppim CUDA::nppist CUDA::nppisu CUDA::nppitc CUDA::npps CUDA::nvToolsExt)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CUDAToolkit_INCLUDE_DIRS})\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offload__rendering__client_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/README.md</code></p>"},{"location":"api/plugins_2offload__rendering__client_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># offload_rendering_client\n\n## Summary\n\n`offload_rendering_client` receives encoded frames from the network, and uses a mix of NPPI and FFMPEG to decode the\nframes before updating the buffer pool. Setting the environment variable ``ILLIXR_USE_DEPTH_IMAGES`` to a non-zero value\nindicates that depth images are being received, and should thus also be decoded.\n\nNote that there is a known color shift issue (to be fixed), where the decoded frame's colors are slightly different from\nthe original frame (likely due to the many conversions between YUV and RGBA). \n</code></pre>"},{"location":"api/plugins_2offload__rendering__client_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; offload_rendering_client &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <p>Offload Rendering Client Plugin Implementation. More...</p> <ul> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include \"illixr/vk/vk_extension_request.hpp\"</code></li> <li><code>#include \"libavfilter_illixr/buffersink.h\"</code></li> <li><code>#include \"libavfilter_illixr/buffersrc.h\"</code></li> <li><code>#include \"libswscale_illixr/swscale.h\"</code></li> <li><code>#include \"offload_rendering_client.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> </ul>"},{"location":"api/plugins_2offload__rendering__client_2plugin_8cpp/#classes","title":"Classes","text":"Type Name class offload_rendering_client_loader Plugin loader for the offload rendering client."},{"location":"api/plugins_2offload__rendering__client_2plugin_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This plugin implements the client-side component of ILLIXR's offload rendering system. It receives encoded frames from a remote server, decodes them using hardware-accelerated HEVC decoding, and displays them in VR. The system supports both color and depth frame reception and decoding.</p> <p>Key features: * Hardware-accelerated HEVC decoding using FFmpeg/CUDA * Support for stereo (left/right eye) rendering * Optional depth frame reception and decoding * Image comparison mode for testing/debugging * Performance metrics tracking</p> <p>Dependencies: * FFmpeg with CUDA support * NVIDIA Video Codec SDK * Vulkan SDK * CUDA Toolkit </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_client/plugin.cpp</code></p>"},{"location":"api/plugins_2offload__rendering__client_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; offload_rendering_client &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// ILLIXR core headers\n#include \"illixr/plugin.hpp\"\n\n// ILLIXR Vulkan headers\n#include \"illixr/vk/render_pass.hpp\"\n#include \"illixr/vk/vk_extension_request.hpp\"\n\n// FFmpeg headers (C interface)\nextern \"C\" {\n#include \"libavfilter_illixr/buffersink.h\"\n#include \"libavfilter_illixr/buffersrc.h\"\n#include \"libswscale_illixr/swscale.h\"\n}\n\n#include \"offload_rendering_client.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;map&gt;\nusing namespace ILLIXR;\nusing namespace ILLIXR::vulkan::ffmpeg_utils;\n\nclass offload_rendering_client_loader\n    : public plugin\n    , public vulkan::vk_extension_request {\npublic:\n    [[maybe_unused]] offload_rendering_client_loader(const std::string&amp; name, phonebook* pb)\n        : plugin(name, pb)\n        , offload_rendering_client_plugin{std::make_shared&lt;offload_rendering_client&gt;(name, pb)} {\n        pb-&gt;register_impl&lt;vulkan::app&gt;(offload_rendering_client_plugin);\n    }\n\n    std::vector&lt;const char*&gt; get_required_instance_extensions() override {\n        return {VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME, VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME,\n                VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME};\n    }\n\n    std::vector&lt;const char*&gt; get_required_devices_extensions() override {\n        return {VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME, VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME,\n                VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,\n                VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME};\n    }\n\n    void start() override {\n        offload_rendering_client_plugin-&gt;start();\n    }\n\n    void stop() override {\n        offload_rendering_client_plugin-&gt;stop();\n    }\n\nprivate:\n    std::shared_ptr&lt;offload_rendering_client&gt; offload_rendering_client_plugin;\n};\n\nPLUGIN_MAIN(offload_rendering_client_loader)\n</code></pre>"},{"location":"api/plugins_2offload__rendering__server_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offload__rendering__server_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 16)  set (PLUGIN_SOURCE \"${CMAKE_BINARY_DIR}/plugins/offload_rendering_server/plugin.cpp\")"},{"location":"api/plugins_2offload__rendering__server_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offload__rendering__server_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 16\n) \n</code></pre>"},{"location":"api/plugins_2offload__rendering__server_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_SOURCE \"${CMAKE_BINARY_DIR}/plugins/offload_rendering_server/plugin.cpp\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offload__rendering__server_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.16)\n\nproject(offload_rendering_server)\n\n# Note that the offload rendering server only supports Monado (not native)\nget_external_for_plugin(Monado_vk)\nset(PLUGIN_NAME \"plugin.offload_rendering_server${ILLIXR_BUILD_SUFFIX}\")\nset(PLUGIN_SOURCE \"${CMAKE_BINARY_DIR}/plugins/offload_rendering_server/plugin.cpp\")\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# ffmpeg\nget_external_for_plugin(ILLIXR_FFmpeg)\n\nadd_compile_definitions(ILLIXR_LIBAV)\n\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            offload_rendering_server.cpp\n            offload_rendering_server.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/serializable_data.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/frame.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/display_provider.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/ffmpeg_utils.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/render_pass.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/vulkan_utils.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/vk_extension_request.hpp\n            ${CMAKE_SOURCE_DIR}/utils/serializable_data.cpp\n)\n\ntarget_compile_definitions(${PLUGIN_NAME} PRIVATE MONADO_REQUIRED)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})\n\nset_target_properties(${PLUGIN_NAME} PROPERTIES OUTPUT_NAME ${PLUGIN_NAME})\nif(Vulkan_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${Vulkan_DEP_STR})\nendif()\nif(ILLIXR_FFmpeg_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${ILLIXR_FFmpeg_DEP_STR})\nendif()\n\ntarget_link_libraries(${PLUGIN_NAME} illixr_vulkan_utils spdlog::spdlog ${Vulkan_LIBRARIES})\ntarget_include_directories(${PLUGIN_NAME} BEFORE PUBLIC ${Vulkan_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\ntarget_link_libraries(${PLUGIN_NAME} ${libavdevice_illixr_LIBRARIES} ${libavformat_illixr_LIBRARIES} ${libavcodec_illixr_LIBRARIES} ${libavutil_illixr_LIBRARIES})\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${libavcodec_illixr_INCLUDE_DIRS})\nget_target_property(INC_DIRS ${PLUGIN_NAME} INCLUDE_DIRECTORIES)\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offload__rendering__server_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/README.md</code></p>"},{"location":"api/plugins_2offload__rendering__server_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># offload_rendering_server\n\n## Summary\n\n`offload_rendering_server` encodes frames using FFMPEG and transmits them to the client with the [network_backend][P10]\nfrom [_switchboard_][G10]. In addition to the frame, some additional information is also transmitted, e.g., the pose\nused for the rendered frame so that the client can reprojected the decoded frame accordingly.\n\nRelevant environment variables include:\n  - ``ILLIXR_USE_DEPTH_IMAGES`` set to non-zero will encode/transmit depth images.\n  - ``ILLIXR_OFFLOAD_RENDERING_BITRATE`` sets the encoding bitrate.\n  - ``ILLIXR_OFFLOAD_RENDERING_FRAMERATE`` sets the encoding framerate.\n  - ``ILLIXR_OFFLOAD_RENDERING_NALU_ONLY`` set to non-zero indicates a Jetson client.\n\n!!! note\n\n    Note that at the moment, the ``offload_rendering_server`` only supports Monado + OpenXR apps, and does not offload the native demos.\n\n[//]: # (- glossary -)\n\n[G10]:  ../glossary.md#switchboard\n\n\n[//]: # (- plugins -)\n\n[P10]:  ../illixr_plugins.md#tcp_network_backend\n</code></pre>"},{"location":"api/plugins_2offload__rendering__server_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; offload_rendering_server &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <p>Offload Rendering Server Plugin Implementation. More...</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> </ul>"},{"location":"api/plugins_2offload__rendering__server_2plugin_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This plugin implements the server-side component of ILLIXR's offload rendering system. It captures rendered frames, encodes them using hardware-accelerated H.264/HEVC encoding, and sends them to a remote client for display. The system supports both color and depth frame transmission, with configurable encoding parameters. </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/plugin.cpp</code></p>"},{"location":"api/plugins_2offload__rendering__server_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; offload_rendering_server &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::vulkan::ffmpeg_utils;\n\n[[maybe_unused]] offload_rendering_server_loader::offload_rendering_server_loader(const std::string&amp; name, phonebook* pb)\n    : plugin(name, pb)\n    , offload_rendering_server_plugin_{std::make_shared&lt;offload_rendering_server&gt;(name, pb)} {\n    pb-&gt;register_impl&lt;vulkan::timewarp&gt;(offload_rendering_server_plugin_);\n    pb-&gt;register_impl&lt;data_format::pose_prediction&gt;(offload_rendering_server_plugin_);\n    log_-&gt;info(\"Registered vulkan::timewarp and pose_prediction implementations\");\n}\n\nstd::vector&lt;const char*&gt; offload_rendering_server_loader::get_required_instance_extensions() {\n    return {VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME, VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME,\n            VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME};\n}\n\nstd::vector&lt;const char*&gt; offload_rendering_server_loader::get_required_devices_extensions() {\n    return {VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME, VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME,\n            VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME, VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,\n            VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME};\n}\n\nvoid offload_rendering_server_loader::start() {\n    offload_rendering_server_plugin_-&gt;start();\n}\n\nvoid offload_rendering_server_loader::stop() {\n    offload_rendering_server_plugin_-&gt;stop();\n}\n\nPLUGIN_MAIN(offload_rendering_server_loader)\n</code></pre>"},{"location":"api/plugins_2offload__rendering__server_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; offload_rendering_server &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/vk/vk_extension_request.hpp\"</code></li> <li><code>#include \"offload_rendering_server.hpp\"</code></li> </ul>"},{"location":"api/plugins_2offload__rendering__server_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offload__rendering__server_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class offload_rendering_server_loader Plugin loader for the offload rendering server. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_rendering_server/plugin.hpp</code></p>"},{"location":"api/plugins_2offload__rendering__server_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; offload_rendering_server &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/plugin.hpp\"\n#include \"illixr/vk/vk_extension_request.hpp\"\n#include \"offload_rendering_server.hpp\"\n\nnamespace ILLIXR {\n\nclass offload_rendering_server_loader\n    : public plugin\n    , public vulkan::vk_extension_request {\npublic:\n    [[maybe_unused]] offload_rendering_server_loader(const std::string&amp; name, phonebook* pb);\n\n    std::vector&lt;const char*&gt; get_required_instance_extensions() override;\n\n    std::vector&lt;const char*&gt; get_required_devices_extensions() override;\n\n    void start() override;\n\n    void stop() override;\n\nprivate:\n    std::shared_ptr&lt;offload_rendering_server&gt; offload_rendering_server_plugin_;\n    std::shared_ptr&lt;spdlog::logger&gt;           log_{spdlogger(\"debug\")};\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name add_library (${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.)  cmake_minimum_required (VERSION 3. 22)  protobuf::libprotobuf spdlog::spdlog target_compile_features (${PLUGIN_NAME} PRIVATE)  proto vio_output proto target_include_directories (${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${CMAKE_BINARY_DIR}/plugins/offload_vio/device_rx/)"},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt/#function-add_library","title":"function add_library","text":"<pre><code>add_library (\n    ${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt/#function-target_compile_features","title":"function target_compile_features","text":"<pre><code>protobuf::libprotobuf spdlog::spdlog target_compile_features (\n    ${PLUGIN_NAME} PRIVATE\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt/#function-target_include_directories","title":"function target_include_directories","text":"<pre><code>proto vio_output proto target_include_directories (\n    ${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${CMAKE_BINARY_DIR}/plugins/offload_vio/device_rx/\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_rx/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offload__vio_2device__rx_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the offload_vio.device_rx ILLIXR plugin\n\ncmake_minimum_required(VERSION 3.22)\nfind_package(Protobuf REQUIRED)\ninclude(../protoc_generate_cpp.cmake)\n\nset(PLUGIN_NAME plugin.offload_vio.device_rx${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\nset(protobuf_files\n        ${CMAKE_CURRENT_SOURCE_DIR}/../proto/vio_output.proto\n)\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${CMAKE_BINARY_DIR}/plugins/offload_vio/device_rx/protobuf)\n\nPROTOBUF_TARGET_CPP(${PLUGIN_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/../proto ${protobuf_files})\ntarget_link_libraries(${PLUGIN_NAME}\n        protobuf::libprotobuf\n        spdlog::spdlog\n        )\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__rx_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; device_rx &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/network/net_config.hpp\"</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_rx/plugin.cpp</code></p>"},{"location":"api/plugins_2offload__vio_2device__rx_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; device_rx &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/network/net_config.hpp\"\n\n#include &lt;utility&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] offload_reader::offload_reader(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , vio_pose_reader_{switchboard_-&gt;get_buffered_reader&lt;switchboard::event_wrapper&lt;std::string&gt;&gt;(\"vio_pose\")}\n    , pose_{switchboard_-&gt;get_writer&lt;pose_type&gt;(\"slow_pose\")}\n    , imu_integrator_input_{switchboard_-&gt;get_writer&lt;imu_integrator_input&gt;(\"imu_integrator_input\")} {\n    spdlogger(switchboard_-&gt;get_env_char(\"OFFLOAD_VIO_LOG_LEVEL\"));\n    pose_type                   datum_pose_tmp{time_point{}, Eigen::Vector3f{0, 0, 0}, Eigen::Quaternionf{1, 0, 0, 0}};\n    switchboard::ptr&lt;pose_type&gt; datum_pose = pose_.allocate&lt;pose_type&gt;(std::move(datum_pose_tmp));\n    pose_.put(std::move(datum_pose));\n}\n\nILLIXR::threadloop::skip_option offload_reader::_p_should_skip() {\n    return skip_option::run;\n}\n\nvoid offload_reader::_p_one_iteration() {\n    if (vio_pose_reader_.size() &gt; 0) {\n        auto                   buffer_ptr   = vio_pose_reader_.dequeue();\n        std::string            buffer_str   = **buffer_ptr;\n        std::string::size_type end_position = buffer_str.find(delimiter);\n        // process the data\n        vio_output_proto::VIOOutput vio_output;\n        bool                        success = vio_output.ParseFromString(buffer_str.substr(0, end_position));\n        if (success) {\n            receive_vio_output(vio_output);\n        } else {\n            spdlog::get(name_)-&gt;error(\"[offload_vio.device_rx: Cannot parse VIO output!!\");\n        }\n    }\n}\n\nvoid offload_reader::receive_vio_output(const vio_output_proto::VIOOutput&amp; vio_output) {\n    const vio_output_proto::SlowPose&amp; slow_pose = vio_output.slow_pose();\n\n    pose_type datum_pose_tmp{\n        time_point{std::chrono::nanoseconds{slow_pose.timestamp()}},\n        Eigen::Vector3f{static_cast&lt;float&gt;(slow_pose.position().x()), static_cast&lt;float&gt;(slow_pose.position().y()),\n                        static_cast&lt;float&gt;(slow_pose.position().z())},\n        Eigen::Quaternionf{static_cast&lt;float&gt;(slow_pose.rotation().w()), static_cast&lt;float&gt;(slow_pose.rotation().x()),\n                           static_cast&lt;float&gt;(slow_pose.rotation().y()), static_cast&lt;float&gt;(slow_pose.rotation().z())}};\n\n    switchboard::ptr&lt;pose_type&gt; datum_pose = pose_.allocate&lt;pose_type&gt;(std::move(datum_pose_tmp));\n    pose_.put(std::move(datum_pose));\n\n    const vio_output_proto::IMUIntInput&amp; imu_int_input = vio_output.imu_int_input();\n\n    imu_integrator_input datum_imu_int_tmp{\n        time_point{std::chrono::nanoseconds{imu_int_input.last_cam_integration_time()}},\n        duration(std::chrono::nanoseconds{imu_int_input.t_offset()}),\n        imu_params{\n            imu_int_input.imu_params().gyro_noise(),\n            imu_int_input.imu_params().acc_noise(),\n            imu_int_input.imu_params().gyro_walk(),\n            imu_int_input.imu_params().acc_walk(),\n            Eigen::Matrix&lt;double, 3, 1&gt;{\n                imu_int_input.imu_params().n_gravity().x(),\n                imu_int_input.imu_params().n_gravity().y(),\n                imu_int_input.imu_params().n_gravity().z(),\n            },\n            imu_int_input.imu_params().imu_integration_sigma(),\n            imu_int_input.imu_params().nominal_rate(),\n        },\n        Eigen::Vector3d{imu_int_input.biasacc().x(), imu_int_input.biasacc().y(), imu_int_input.biasacc().z()},\n        Eigen::Vector3d{imu_int_input.biasgyro().x(), imu_int_input.biasgyro().y(), imu_int_input.biasgyro().z()},\n        Eigen::Matrix&lt;double, 3, 1&gt;{imu_int_input.position().x(), imu_int_input.position().y(), imu_int_input.position().z()},\n        Eigen::Matrix&lt;double, 3, 1&gt;{imu_int_input.velocity().x(), imu_int_input.velocity().y(), imu_int_input.velocity().z()},\n        Eigen::Quaterniond{imu_int_input.rotation().w(), imu_int_input.rotation().x(), imu_int_input.rotation().y(),\n                           imu_int_input.rotation().z()}};\n\n    switchboard::ptr&lt;imu_integrator_input&gt; datum_imu_int =\n        imu_integrator_input_.allocate&lt;imu_integrator_input&gt;(std::move(datum_imu_int_tmp));\n    imu_integrator_input_.put(std::move(datum_imu_int));\n}\n\nPLUGIN_MAIN(offload_reader)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__rx_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; device_rx &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/network/tcpsocket.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"../proto/output_stub.hpp\"</code></li> </ul>"},{"location":"api/plugins_2offload__vio_2device__rx_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offload__vio_2device__rx_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class offload_reader <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_rx/plugin.hpp</code></p>"},{"location":"api/plugins_2offload__vio_2device__rx_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; device_rx &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/network/tcpsocket.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n// if the header exists, we are good; if not generate a stub class for IDEs to reduce on-screen errors\n#if __has_include(\"vio_output.pb.h\")\n    #include \"vio_output.pb.h\"\n#else\n    #include \"../proto/output_stub.hpp\"\n#endif\n\nnamespace ILLIXR {\nclass offload_reader : public threadloop {\npublic:\n    [[maybe_unused]] offload_reader(const std::string&amp; name, phonebook* pb);\n    skip_option _p_should_skip() override;\n    void        _p_one_iteration() override;\n\nprivate:\n    void receive_vio_output(const vio_output_proto::VIOOutput&amp; vio_output);\n\n    const std::shared_ptr&lt;switchboard&gt;                                    switchboard_;\n    const std::shared_ptr&lt;relative_clock&gt;                                 clock_;\n    switchboard::buffered_reader&lt;switchboard::event_wrapper&lt;std::string&gt;&gt; vio_pose_reader_;\n    switchboard::writer&lt;data_format::pose_type&gt;                           pose_;\n    switchboard::writer&lt;data_format::imu_integrator_input&gt;                imu_integrator_input_;\n\n    network::TCPSocket socket_;\n    std::string        server_ip_;\n\n    std::string delimiter = \"END!\";\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__tx_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offload__vio_2device__tx_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name add_library (${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp video_encoder.cpp video_encoder.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.)  cmake_minimum_required (VERSION 3. 22)  proto vio_input proto target_include_directories (${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${OpenCV_INCLUDE_DIRS} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/)"},{"location":"api/plugins_2offload__vio_2device__tx_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offload__vio_2device__tx_2CMakeLists_8txt/#function-add_library","title":"function add_library","text":"<pre><code>add_library (\n    ${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp video_encoder.cpp video_encoder.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__tx_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__tx_2CMakeLists_8txt/#function-target_include_directories","title":"function target_include_directories","text":"<pre><code>proto vio_input proto target_include_directories (\n    ${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${OpenCV_INCLUDE_DIRS} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offload__vio_2device__tx_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the offload_vio.device_tx ILLIXR plugin\n\ncmake_minimum_required(VERSION 3.22)\nfind_package(Protobuf REQUIRED)\ninclude(../protoc_generate_cpp.cmake)\n\nset(PLUGIN_NAME plugin.offload_vio.device_tx${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            video_encoder.cpp\n            video_encoder.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\nset(protobuf_files\n        ${CMAKE_CURRENT_SOURCE_DIR}/../proto/vio_input.proto\n)\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${OpenCV_INCLUDE_DIRS} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\nPROTOBUF_TARGET_CPP(${PLUGIN_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/../proto ${protobuf_files})\ntarget_link_libraries(${PLUGIN_NAME}\n        ${OpenCV_LIBS}\n        protobuf::libprotobuf\n        )\n\nfind_package(PkgConfig)\npkg_search_module(GLIB REQUIRED glib-2.0)\npkg_check_modules(GSTREAMER REQUIRED gstreamer-1.0)\npkg_check_modules(GST_APP REQUIRED gstreamer-app-1.0)\npkg_check_modules(GST_VIDEO REQUIRED gstreamer-video-1.0)\npkg_check_modules(GST_AUDIO REQUIRED gstreamer-audio-1.0)\n\ninclude_directories(\n        ${GSTREAMER_INCLUDE_DIRS}\n        ${GLIB_INCLUDE_DIRS}\n)\n\ntarget_link_libraries(${PLUGIN_NAME} ${GST_APP_LIBRARIES} ${GST_VIDEO_LIBRARIES} ${GST_AUDIO_LIBRARIES} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__tx_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; device_tx &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/network/topic_config.hpp\"</code></li> <li><code>#include \"video_encoder.hpp\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;opencv2/core/mat.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/plugin.cpp</code></p>"},{"location":"api/plugins_2offload__vio_2device__tx_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; device_tx &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/network/topic_config.hpp\"\n#include \"video_encoder.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;opencv2/core/mat.hpp&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n// #define USE_COMPRESSION\n\n[[maybe_unused]] offload_writer::offload_writer(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , stoplight_{phonebook_-&gt;lookup_impl&lt;stoplight&gt;()}\n    , cam_{switchboard_-&gt;get_buffered_reader&lt;binocular_cam_type&gt;(\"cam\")}\n    , imu_cam_writer_{switchboard_-&gt;get_network_writer&lt;switchboard::event_wrapper&lt;std::string&gt;&gt;(\n          \"compressed_imu_cam\",\n          network::topic_config{.serialization_method = network::topic_config::SerializationMethod::PROTOBUF})}\n    , log_(spdlogger(switchboard_-&gt;get_env_char(\"OFFLOAD_VIO_LOG_LEVEL\"))) {\n    std::srand(std::time(0));\n}\n\nvoid offload_writer::start() {\n    threadloop::start();\n\n    encoder_ = std::make_unique&lt;video_encoder&gt;([this](const GstMapInfo&amp; img0, const GstMapInfo&amp; img1) {\n        queue_.consume_one([&amp;](uint64_t&amp; timestamp) {\n            (void) timestamp;\n            uint64_t curr =\n                std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::now().time_since_epoch())\n                    .count();\n        });\n        {\n            std::lock_guard&lt;std::mutex&gt; lock{mutex_};\n            this-&gt;img0_ = img0;\n            this-&gt;img1_ = img1;\n            img_ready_  = true;\n        }\n        condition_var_.notify_one();\n    });\n    encoder_-&gt;init();\n\n    switchboard_-&gt;schedule&lt;imu_type&gt;(id_, \"imu\", [this](const switchboard::ptr&lt;const imu_type&gt;&amp; datum, std::size_t) {\n        this-&gt;prepare_imu_cam_data(datum);\n    });\n}\n\nvoid offload_writer::_p_one_iteration() {\n    while (!stoplight_-&gt;check_should_stop()) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    }\n}\n\nvoid offload_writer::send_imu_cam_data(std::optional&lt;time_point&gt;&amp; cam_time) {\n    data_buffer_-&gt;set_real_timestamp(\n        std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count());\n    data_buffer_-&gt;set_frame_id(frame_id_);\n\n    std::string data_to_be_sent = data_buffer_-&gt;SerializeAsString();\n    std::string delimiter       = \"EEND!\";\n\n    log_-&gt;info(\"{},{}\", cam_time.value().time_since_epoch().count(),\n               (double) (clock_-&gt;now().time_since_epoch().count() - cam_time.value().time_since_epoch().count()) / 1e6);\n    // socket.write(data_to_be_sent + delimitter);\n    imu_cam_writer_.put(std::make_shared&lt;switchboard::event_wrapper&lt;std::string&gt;&gt;(data_to_be_sent + delimiter));\n\n    frame_id_++;\n    delete data_buffer_;\n    data_buffer_ = new vio_input_proto::IMUCamVec();\n    cam_time.reset();\n}\n\nvoid offload_writer::prepare_imu_cam_data(switchboard::ptr&lt;const imu_type&gt; datum) {\n    // Ensures that slam doesnt start before valid IMU readings come in\n    if (datum == nullptr) {\n        assert(!latest_imu_time_);\n        return;\n    }\n\n    // Ensure that IMU data is received in the time order\n    assert(datum-&gt;time &gt; latest_imu_time_);\n    latest_imu_time_ = datum-&gt;time;\n\n    vio_input_proto::IMUData* imu_data = data_buffer_-&gt;add_imu_data();\n    imu_data-&gt;set_timestamp(datum-&gt;time.time_since_epoch().count());\n\n    auto* angular_vel = new vio_input_proto::Vec3();\n    angular_vel-&gt;set_x(datum-&gt;angular_v.x());\n    angular_vel-&gt;set_y(datum-&gt;angular_v.y());\n    angular_vel-&gt;set_z(datum-&gt;angular_v.z());\n    imu_data-&gt;set_allocated_angular_vel(angular_vel);\n\n    auto* linear_accel = new vio_input_proto::Vec3();\n    linear_accel-&gt;set_x(datum-&gt;linear_a.x());\n    linear_accel-&gt;set_y(datum-&gt;linear_a.y());\n    linear_accel-&gt;set_z(datum-&gt;linear_a.z());\n    imu_data-&gt;set_allocated_linear_accel(linear_accel);\n\n    if (latest_cam_time_ &amp;&amp; latest_imu_time_ &gt; latest_cam_time_) {\n        send_imu_cam_data(latest_cam_time_);\n    }\n\n    switchboard::ptr&lt;const binocular_cam_type&gt; cam;\n\n    if (cam_.size() != 0 &amp;&amp; !latest_cam_time_) {\n        cam = cam_.dequeue();\n\n        cv::Mat cam_img0      = (cam-&gt;at(image::LEFT_EYE)).clone();\n        cv::Mat cam_img1      = (cam-&gt;at(image::RIGHT_EYE)).clone();\n        int     cam_img0_size = cam_img0.rows * cam_img0.cols;\n\n        auto* cam_data = new vio_input_proto::CamData();\n        cam_data-&gt;set_timestamp(cam-&gt;time.time_since_epoch().count());\n        cam_data-&gt;set_rows(cam_img0.rows);\n        cam_data-&gt;set_cols(cam_img0.cols);\n\n#ifdef USE_COMPRESSION\n        uint64_t curr =\n            std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();\n        queue_.push(curr);\n        std::unique_lock&lt;std::mutex&gt; lock{mutex_};\n        encoder_-&gt;enqueue(cam_img0, cam_img1);\n        condition_var_.wait(lock, [this]() {\n            return img_ready_;\n        });\n        img_ready_ = false;\n\n        sizes_.push_back((int) this-&gt;img0_.size);\n\n        // calculate average sizes\n        // if (sizes_.size() &gt; 100) {\n        //    int32_t sum = 0;\n        //    for (auto&amp; s : sizes_) {\n        //        sum += s;\n        //    }\n        // For debugging, prints out average image size after compression and compression ratio\n        // std::cout &lt;&lt; \"compression ratio: \" &lt;&lt; img0_size / (sum / sizes_.size()) &lt;&lt; \" average size after compression \"\n        // &lt;&lt; sum / sizes_.size() &lt;&lt; std::endl;\n        //}\n\n        cam_data-&gt;set_img0_data((void*) this-&gt;img0_.data, this-&gt;img0_.size);\n        cam_data-&gt;set_img1_data((void*) this-&gt;img1_.data, this-&gt;img1_.size);\n\n        lock.unlock();\n#else\n        cam_data-&gt;set_img0_data((void*) cam_img0.data, cam_img0_size);\n        cam_data-&gt;set_img1_data((void*) cam_img1.data, cam_img0_size);\n#endif\n        data_buffer_-&gt;set_allocated_cam_data(cam_data);\n        latest_cam_time_ = cam-&gt;time;\n        if (latest_imu_time_ &lt;= latest_cam_time_) {\n            return;\n        } else {\n            send_imu_cam_data(latest_cam_time_);\n        }\n    }\n}\n\nPLUGIN_MAIN(offload_writer)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2device__tx_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; device_tx &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/network/tcpsocket.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/stoplight.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"video_encoder.hpp\"</code></li> <li><code>#include \"../proto/input_stub.hpp\"</code></li> <li><code>#include &lt;boost/lockfree/spsc_queue.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2offload__vio_2device__tx_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offload__vio_2device__tx_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class offload_writer <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/plugin.hpp</code></p>"},{"location":"api/plugins_2offload__vio_2device__tx_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; device_tx &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/network/tcpsocket.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/stoplight.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"video_encoder.hpp\"\n\n// if the header exists, we are good; if not generate a stub class for IDEs to reduce on-screen errors\n#if __has_include(\"vio_input.pb.h\")\n    #include \"vio_input.pb.h\"\n#else\n    #include \"../proto/input_stub.hpp\"\n#endif\n\n#include &lt;boost/lockfree/spsc_queue.hpp&gt;\n\nnamespace ILLIXR {\nclass offload_writer : public threadloop {\npublic:\n    [[maybe_unused]] offload_writer(const std::string&amp; name, phonebook* pb);\n    void start() override;\n    void send_imu_cam_data(std::optional&lt;time_point&gt;&amp; cam_time);\n    void prepare_imu_cam_data(switchboard::ptr&lt;const data_format::imu_type&gt; datum);\n\nprotected:\n    void _p_thread_setup() override { }\n\n    void _p_one_iteration() override;\n\nprivate:\n    boost::lockfree::spsc_queue&lt;uint64_t&gt; queue_{1000};\n    std::vector&lt;int32_t&gt;                  sizes_;\n    std::mutex                            mutex_;\n    std::condition_variable               condition_var_;\n    GstMapInfo                            img0_{};\n    GstMapInfo                            img1_{};\n    bool                                  img_ready_ = false;\n\n    std::unique_ptr&lt;video_encoder&gt;                                       encoder_ = nullptr;\n    std::optional&lt;time_point&gt;                                            latest_imu_time_;\n    std::optional&lt;time_point&gt;                                            latest_cam_time_;\n    int                                                                  frame_id_    = 0;\n    vio_input_proto::IMUCamVec*                                          data_buffer_ = new vio_input_proto::IMUCamVec();\n    const std::shared_ptr&lt;switchboard&gt;                                   switchboard_;\n    const std::shared_ptr&lt;relative_clock&gt;                                clock_;\n    const std::shared_ptr&lt;stoplight&gt;                                     stoplight_;\n    switchboard::buffered_reader&lt;data_format::binocular_cam_type&gt;        cam_;\n    switchboard::network_writer&lt;switchboard::event_wrapper&lt;std::string&gt;&gt; imu_cam_writer_;\n    std::shared_ptr&lt;spdlog::logger&gt;                                      log_;\n    network::TCPSocket                                                   socket_;\n    std::string                                                          server_ip_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__rx_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offload__vio_2server__rx_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name add_library (${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp video_decoder.cpp video_decoder.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.)  cmake_minimum_required (VERSION 3. 22)  proto vio_input proto target_include_directories (${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${OpenCV_INCLUDE_DIRS} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/)"},{"location":"api/plugins_2offload__vio_2server__rx_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offload__vio_2server__rx_2CMakeLists_8txt/#function-add_library","title":"function add_library","text":"<pre><code>add_library (\n    ${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp video_decoder.cpp video_decoder.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__rx_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__rx_2CMakeLists_8txt/#function-target_include_directories","title":"function target_include_directories","text":"<pre><code>proto vio_input proto target_include_directories (\n    ${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${OpenCV_INCLUDE_DIRS} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offload__vio_2server__rx_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the offload_vio.server_rx ILLIXR plugin\n\ncmake_minimum_required(VERSION 3.22)\nfind_package(Protobuf REQUIRED)\ninclude(../protoc_generate_cpp.cmake)\n\nset(PLUGIN_NAME plugin.offload_vio.server_rx${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            video_decoder.cpp\n            video_decoder.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\nset(protobuf_files\n        ${CMAKE_CURRENT_SOURCE_DIR}/../proto/vio_input.proto\n)\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${OpenCV_INCLUDE_DIRS}  ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\nPROTOBUF_TARGET_CPP(${PLUGIN_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/../proto ${protobuf_files})\ntarget_link_libraries(${PLUGIN_NAME}\n        ${OpenCV_LIBS}\n        protobuf::libprotobuf\n        spdlog::spdlog\n        )\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\nfind_package(PkgConfig)\npkg_search_module(GLIB REQUIRED glib-2.0)\npkg_check_modules(GSTREAMER REQUIRED gstreamer-1.0)\npkg_check_modules(GST_APP REQUIRED gstreamer-app-1.0)\npkg_check_modules(GST_VIDEO REQUIRED gstreamer-video-1.0)\npkg_check_modules(GST_AUDIO REQUIRED gstreamer-audio-1.0)\n\ninclude_directories(\n        ${GSTREAMER_INCLUDE_DIRS}\n        ${GLIB_INCLUDE_DIRS}\n)\n\ntarget_link_libraries(${PLUGIN_NAME} ${GST_APP_LIBRARIES} ${GST_VIDEO_LIBRARIES} ${GST_AUDIO_LIBRARIES})\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__rx_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; offload_vio &gt; server_rx &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/network/net_config.hpp\"</code></li> <li><code>#include \"video_decoder.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/plugin.cpp</code></p>"},{"location":"api/plugins_2offload__vio_2server__rx_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; offload_vio &gt; server_rx &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/network/net_config.hpp\"\n#include \"video_decoder.hpp\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n// #define USE_COMPRESSION\n\n[[maybe_unused]] server_reader::server_reader(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{pb-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , imu_{switchboard_-&gt;get_writer&lt;imu_type&gt;(\"imu\")}\n    , cam_{switchboard_-&gt;get_writer&lt;binocular_cam_type&gt;(\"cam\")}\n    , imu_cam_reader_{switchboard_-&gt;get_buffered_reader&lt;switchboard::event_wrapper&lt;std::string&gt;&gt;(\"compressed_imu_cam\")}\n    , log_(spdlogger(switchboard_-&gt;get_env_char(\"OFFLOAD_VIO_LOG_LEVEL\"))) {\n    log_-&gt;info(\"Camera Time,Uplink Time(ms)\");\n}\n\nILLIXR::threadloop::skip_option server_reader::_p_should_skip() {\n    return skip_option::run;\n}\n\nvoid server_reader::_p_one_iteration() {\n    if (imu_cam_reader_.size() &gt; 0) {\n        auto                       buffer_ptr   = imu_cam_reader_.dequeue();\n        std::string                buffer_str   = **buffer_ptr;\n        std::string::size_type     end_position = buffer_str.find(delimiter_);\n        vio_input_proto::IMUCamVec vio_input;\n        bool                       success = vio_input.ParseFromString(buffer_str.substr(0, end_position));\n        if (!success) {\n            log_-&gt;error(\"[offload_vio.server_rx]Error parsing the protobuf, vio input size = {}\",\n                        buffer_str.size() - delimiter_.size());\n        } else {\n            receive_vio_input(vio_input);\n        }\n    }\n}\n\nvoid server_reader::start() {\n    threadloop::start();\n\n    decoder_ = std::make_unique&lt;video_decoder&gt;([this](cv::Mat&amp;&amp; img0, cv::Mat&amp;&amp; img1) {\n        queue_.consume_one([&amp;](uint64_t&amp; timestamp) {\n            (void) timestamp;\n            uint64_t curr =\n                std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::now().time_since_epoch())\n                    .count();\n            // std::cout &lt;&lt; \"=== latency: \" &lt;&lt; (curr - timestamp) / 1000000.0 &lt;&lt; std::endl;\n        });\n        {\n            std::lock_guard&lt;std::mutex&gt; lock{mutex_};\n            this-&gt;img0_dst_ = std::forward&lt;cv::Mat&gt;(img0);\n            this-&gt;img1_dst_ = std::forward&lt;cv::Mat&gt;(img1);\n            img_ready_      = true;\n        }\n        condition_variable_.notify_one();\n    });\n    decoder_-&gt;init();\n}\n\nvoid server_reader::receive_vio_input(const vio_input_proto::IMUCamVec&amp; vio_input) {\n    // Logging the transmitting time\n    unsigned long long curr_time =\n        std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();\n    double msec_to_trans = (curr_time - vio_input.real_timestamp()) / 1e6;\n\n    // Loop through and publish all IMU values first\n    for (int i = 0; i &lt; vio_input.imu_data_size() - 1; i++) {\n        vio_input_proto::IMUData curr_data = vio_input.imu_data(i);\n        imu_.put(imu_.allocate&lt;imu_type&gt;(imu_type{\n            time_point{std::chrono::nanoseconds{curr_data.timestamp()}},\n            Eigen::Vector3d{curr_data.angular_vel().x(), curr_data.angular_vel().y(), curr_data.angular_vel().z()},\n            Eigen::Vector3d{curr_data.linear_accel().x(), curr_data.linear_accel().y(), curr_data.linear_accel().z()}}));\n    }\n    // Publish the Cam value then\n    vio_input_proto::CamData cam_data = vio_input.cam_data();\n    log_-&gt;info(\"{},{}\", cam_data.timestamp(), msec_to_trans);\n\n    // Must do a deep copy of the received data (in the form of a string of bytes)\n    auto img0_copy = std::string(cam_data.img0_data());\n    auto img1_copy = std::string(cam_data.img1_data());\n\n#ifdef USE_COMPRESSION\n    time_point start_decomp = clock_-&gt;now();\n    // With compression\n    uint64_t curr =\n        std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();\n    queue_.push(curr);\n    std::unique_lock&lt;std::mutex&gt; lock{mutex_};\n    decoder_-&gt;enqueue(img0_copy, img1_copy);\n    condition_variable_.wait(lock, [this]() {\n        return img_ready_;\n    });\n    img_ready_ = false;\n\n    cv::Mat img0(img0_dst_.clone());\n    cv::Mat img1(img1_dst_.clone());\n\n    lock.unlock();\n    log_-&gt;warn(\"{},{}\", cam_data.timestamp(), (clock_-&gt;now() - start_decomp).count() / 1e6);\n    // With compression end\n#else\n    // Without compression\n    cv::Mat img0(cam_data.rows(), cam_data.cols(), CV_8UC1, img0_copy.data());\n    cv::Mat img1(cam_data.rows(), cam_data.cols(), CV_8UC1, img1_copy.data());\n    // Without compression end\n#endif\n    cam_.put(cam_.allocate&lt;binocular_cam_type&gt;(binocular_cam_type{\n        time_point{std::chrono::nanoseconds{cam_data.timestamp()}},\n        img0.clone(),\n        img1.clone(),\n    }));\n    // If we publish all IMU samples before the camera data, the camera data may not be captured in any of the IMU callbacks\n    // in the tracking algorithm (e.g. OpenVINS), and has to wait for another camera frame time (until the next packet\n    // arrives) to be consumed. Therefore, we publish one (or more) IMU samples after the camera data to make sure that the\n    // camera data will be captured.\n    vio_input_proto::IMUData last_imu = vio_input.imu_data(vio_input.imu_data_size() - 1);\n    imu_.put(imu_.allocate&lt;imu_type&gt;(\n        imu_type{time_point{std::chrono::nanoseconds{last_imu.timestamp()}},\n                 Eigen::Vector3d{last_imu.angular_vel().x(), last_imu.angular_vel().y(), last_imu.angular_vel().z()},\n                 Eigen::Vector3d{last_imu.linear_accel().x(), last_imu.linear_accel().y(), last_imu.linear_accel().z()}}));\n}\n\nPLUGIN_MAIN(server_reader)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__rx_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; offload_vio &gt; server_rx &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/network/tcpsocket.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"video_decoder.hpp\"</code></li> <li><code>#include \"../proto/input_stub.hpp\"</code></li> <li><code>#include &lt;boost/lockfree/spsc_queue.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2offload__vio_2server__rx_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offload__vio_2server__rx_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class server_reader <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/plugin.hpp</code></p>"},{"location":"api/plugins_2offload__vio_2server__rx_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; offload_vio &gt; server_rx &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/network/tcpsocket.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"video_decoder.hpp\"\n// if the header exists, we are good; if not generate a stub class for IDEs to reduce on-screen errors\n#if __has_include(\"vio_input.pb.h\")\n    #include \"vio_input.pb.h\"\n#else\n    #include \"../proto/input_stub.hpp\"\n#endif\n\n#include &lt;boost/lockfree/spsc_queue.hpp&gt;\n\nnamespace ILLIXR {\nclass server_reader : public threadloop {\npublic:\n    [[maybe_unused]] server_reader(const std::string&amp; name, phonebook* pb);\n    skip_option _p_should_skip() override;\n    void        _p_one_iteration() override;\n    void        start() override;\n\nprivate:\n    void receive_vio_input(const vio_input_proto::IMUCamVec&amp; vio_input);\n\n    std::unique_ptr&lt;video_decoder&gt; decoder_;\n\n    boost::lockfree::spsc_queue&lt;uint64_t&gt; queue_{1000};\n    std::mutex                            mutex_;\n    std::condition_variable               condition_variable_;\n    cv::Mat                               img0_dst_;\n    cv::Mat                               img1_dst_;\n    bool                                  img_ready_ = false;\n\n    const std::shared_ptr&lt;switchboard&gt;                                    switchboard_;\n    const std::shared_ptr&lt;relative_clock&gt;                                 clock_;\n    switchboard::writer&lt;data_format::imu_type&gt;                            imu_;\n    switchboard::writer&lt;data_format::binocular_cam_type&gt;                  cam_;\n    switchboard::buffered_reader&lt;switchboard::event_wrapper&lt;std::string&gt;&gt; imu_cam_reader_;\n    std::string                                                           buffer_str_;\n    std::shared_ptr&lt;spdlog::logger&gt;                                       log_;\n\n    const std::string delimiter_ = \"EEND!\";\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name add_library (${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.)  cmake_minimum_required (VERSION 3. 22)  protobuf::libprotobuf spdlog::spdlog target_compile_features (${PLUGIN_NAME} PRIVATE)  proto vio_output proto target_include_directories (${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/)"},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt/#function-add_library","title":"function add_library","text":"<pre><code>add_library (\n    ${PLUGIN_NAME} SHARED plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt/#function-target_compile_features","title":"function target_compile_features","text":"<pre><code>protobuf::libprotobuf spdlog::spdlog target_compile_features (\n    ${PLUGIN_NAME} PRIVATE\n) \n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt/#function-target_include_directories","title":"function target_include_directories","text":"<pre><code>proto vio_output proto target_include_directories (\n    ${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_tx/CMakeLists.txt</code></p>"},{"location":"api/plugins_2offload__vio_2server__tx_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the offload_vio.server_tx ILLIXR plugin\n\ncmake_minimum_required(VERSION 3.22)\nfind_package(Protobuf REQUIRED)\ninclude(../protoc_generate_cpp.cmake)\n\nset(PLUGIN_NAME plugin.offload_vio.server_tx${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\nset(protobuf_files\n        ${CMAKE_CURRENT_SOURCE_DIR}/../proto/vio_output.proto\n)\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${Protobuf_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\nPROTOBUF_TARGET_CPP(${PLUGIN_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/../proto ${protobuf_files})\ntarget_link_libraries(${PLUGIN_NAME}\n        protobuf::libprotobuf\n        spdlog::spdlog\n        )\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__tx_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; offload_vio &gt; server_tx &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/network/net_config.hpp\"</code></li> <li><code>#include \"illixr/network/tcpsocket.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"../proto/output_stub.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_tx/plugin.cpp</code></p>"},{"location":"api/plugins_2offload__vio_2server__tx_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; offload_vio &gt; server_tx &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/network/net_config.hpp\"\n#include \"illixr/network/tcpsocket.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/switchboard.hpp\"\n// if the header exists, we are good; if not generate a stub class for IDEs to reduce on-screen errors\n#if __has_include(\"vio_output.pb.h\")\n    #include \"vio_output.pb.h\"\n#else\n    #include \"../proto/output_stub.hpp\"\n#endif\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] server_writer::server_writer(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , imu_int_input_{switchboard_-&gt;get_reader&lt;imu_integrator_input&gt;(\"imu_integrator_input\")}\n    , vio_pose_writer_{switchboard_-&gt;get_network_writer&lt;switchboard::event_wrapper&lt;std::string&gt;&gt;(\n          \"vio_pose\", network::topic_config{.serialization_method = network::topic_config::SerializationMethod::PROTOBUF})} {\n    spdlogger(switchboard_-&gt;get_env_char(\"OFFLOAD_VIO_LOG_LEVEL\"));\n}\n\n// This schedule function cant go in the constructor because there seems to be an issue with\n// the call being triggered before any data is written to slow_pose. This needs debugging.\nvoid server_writer::start() {\n    plugin::start();\n\n    switchboard_-&gt;schedule&lt;pose_type&gt;(id_, \"slow_pose\", [this](const switchboard::ptr&lt;const pose_type&gt;&amp; datum, std::size_t) {\n        this-&gt;send_vio_output(datum);\n    });\n}\n\nvoid server_writer::send_vio_output(const switchboard::ptr&lt;const pose_type&gt;&amp; datum) {\n    // Construct slow pose for output\n    auto* protobuf_slow_pose = new vio_output_proto::SlowPose();\n    protobuf_slow_pose-&gt;set_timestamp(datum-&gt;sensor_time.time_since_epoch().count());\n\n    auto* position = new vio_output_proto::Vec3();\n    position-&gt;set_x(datum-&gt;position.x());\n    position-&gt;set_y(datum-&gt;position.y());\n    position-&gt;set_z(datum-&gt;position.z());\n    protobuf_slow_pose-&gt;set_allocated_position(position);\n\n    auto* rotation = new vio_output_proto::Quat();\n    rotation-&gt;set_w(datum-&gt;orientation.w());\n    rotation-&gt;set_x(datum-&gt;orientation.x());\n    rotation-&gt;set_y(datum-&gt;orientation.y());\n    rotation-&gt;set_z(datum-&gt;orientation.z());\n    protobuf_slow_pose-&gt;set_allocated_rotation(rotation);\n\n    // Construct IMU integrator input for output\n    switchboard::ptr&lt;const imu_integrator_input&gt; imu_int_input = imu_int_input_.get_ro_nullable();\n\n    auto* protobuf_imu_int_input = new vio_output_proto::IMUIntInput();\n    protobuf_imu_int_input-&gt;set_t_offset(imu_int_input-&gt;t_offset.count());\n    protobuf_imu_int_input-&gt;set_last_cam_integration_time(imu_int_input-&gt;last_cam_integration_time.time_since_epoch().count());\n\n    auto* imu_params = new vio_output_proto::IMUParams();\n    imu_params-&gt;set_gyro_noise(imu_int_input-&gt;params.gyro_noise);\n    imu_params-&gt;set_acc_noise(imu_int_input-&gt;params.acc_noise);\n    imu_params-&gt;set_gyro_walk(imu_int_input-&gt;params.gyro_walk);\n    imu_params-&gt;set_acc_walk(imu_int_input-&gt;params.acc_walk);\n    auto* n_gravity = new vio_output_proto::Vec3();\n    n_gravity-&gt;set_x(imu_int_input-&gt;params.n_gravity.x());\n    n_gravity-&gt;set_y(imu_int_input-&gt;params.n_gravity.y());\n    n_gravity-&gt;set_z(imu_int_input-&gt;params.n_gravity.z());\n    imu_params-&gt;set_allocated_n_gravity(n_gravity);\n    imu_params-&gt;set_imu_integration_sigma(imu_int_input-&gt;params.imu_integration_sigma);\n    imu_params-&gt;set_nominal_rate(imu_int_input-&gt;params.nominal_rate);\n    protobuf_imu_int_input-&gt;set_allocated_imu_params(imu_params);\n\n    auto* bias_acc = new vio_output_proto::Vec3();\n    bias_acc-&gt;set_x(imu_int_input-&gt;bias_acc.x());\n    bias_acc-&gt;set_y(imu_int_input-&gt;bias_acc.y());\n    bias_acc-&gt;set_z(imu_int_input-&gt;bias_acc.z());\n    protobuf_imu_int_input-&gt;set_allocated_biasacc(bias_acc);\n\n    auto* bias_gyro = new vio_output_proto::Vec3();\n    bias_gyro-&gt;set_x(imu_int_input-&gt;bias_gyro.x());\n    bias_gyro-&gt;set_y(imu_int_input-&gt;bias_gyro.y());\n    bias_gyro-&gt;set_z(imu_int_input-&gt;bias_gyro.z());\n    protobuf_imu_int_input-&gt;set_allocated_biasgyro(bias_gyro);\n\n    auto* position_int = new vio_output_proto::Vec3();\n    position_int-&gt;set_x(imu_int_input-&gt;position.x());\n    position_int-&gt;set_y(imu_int_input-&gt;position.y());\n    position_int-&gt;set_z(imu_int_input-&gt;position.z());\n    protobuf_imu_int_input-&gt;set_allocated_position(position_int);\n\n    auto* velocity = new vio_output_proto::Vec3();\n    velocity-&gt;set_x(imu_int_input-&gt;velocity.x());\n    velocity-&gt;set_y(imu_int_input-&gt;velocity.y());\n    velocity-&gt;set_z(imu_int_input-&gt;velocity.z());\n    protobuf_imu_int_input-&gt;set_allocated_velocity(velocity);\n\n    auto* rotation_int = new vio_output_proto::Quat();\n    rotation_int-&gt;set_w(imu_int_input-&gt;quat.w());\n    rotation_int-&gt;set_x(imu_int_input-&gt;quat.x());\n    rotation_int-&gt;set_y(imu_int_input-&gt;quat.y());\n    rotation_int-&gt;set_z(imu_int_input-&gt;quat.z());\n    protobuf_imu_int_input-&gt;set_allocated_rotation(rotation_int);\n\n    auto* vio_output_params = new vio_output_proto::VIOOutput();\n    vio_output_params-&gt;set_allocated_slow_pose(protobuf_slow_pose);\n    vio_output_params-&gt;set_allocated_imu_int_input(protobuf_imu_int_input);\n\n    unsigned long long end_pose_time =\n        std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();\n    vio_output_params-&gt;set_end_server_timestamp(end_pose_time);\n\n    // Prepare data delivery\n    std::string       data_to_be_sent = vio_output_params-&gt;SerializeAsString();\n    const std::string delimiter       = \"END!\";\n\n    vio_pose_writer_.put(std::make_shared&lt;switchboard::event_wrapper&lt;std::string&gt;&gt;(data_to_be_sent + delimiter));\n\n    delete vio_output_params;\n}\n\nPLUGIN_MAIN(server_writer)\n</code></pre>"},{"location":"api/plugins_2offload__vio_2server__tx_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; offload_vio &gt; server_tx &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/network/tcpsocket.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> </ul>"},{"location":"api/plugins_2offload__vio_2server__tx_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2offload__vio_2server__tx_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class server_writer <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_tx/plugin.hpp</code></p>"},{"location":"api/plugins_2offload__vio_2server__tx_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; offload_vio &gt; server_tx &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/network/tcpsocket.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\nnamespace ILLIXR {\nclass server_writer : public plugin {\npublic:\n    [[maybe_unused]] server_writer(const std::string&amp; name, phonebook* pb);\n    void start() override;\n    void send_vio_output(const switchboard::ptr&lt;const data_format::pose_type&gt;&amp; datum);\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;                                   switchboard_;\n    switchboard::reader&lt;data_format::imu_integrator_input&gt;               imu_int_input_;\n    switchboard::network_writer&lt;switchboard::event_wrapper&lt;std::string&gt;&gt; vio_pose_writer_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2openni_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2openni_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name pkg_check_modules (libopenni2 REQUIRED libopenni2)  set (OPENNI_SOURCES plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp ${CMAKE_SOURCE_DIR}/include/illixr/threadloop. hpp)"},{"location":"api/plugins_2openni_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2openni_2CMakeLists_8txt/#function-pkg_check_modules","title":"function pkg_check_modules","text":"<pre><code>pkg_check_modules (\n    libopenni2 REQUIRED libopenni2\n) \n</code></pre>"},{"location":"api/plugins_2openni_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    OPENNI_SOURCES plugin.cpp plugin.hpp ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp ${CMAKE_SOURCE_DIR}/include/illixr/threadloop. hpp\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openni/CMakeLists.txt</code></p>"},{"location":"api/plugins_2openni_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>pkg_check_modules(libopenni2 REQUIRED libopenni2)\n\nset(PLUGIN_NAME plugin.openni${ILLIXR_BUILD_SUFFIX})\n\nset(OPENNI_SOURCES plugin.cpp\n    plugin.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n)\nadd_library(${PLUGIN_NAME} SHARED ${OPENNI_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${OpenCV_INCLUDE_DIRS} ${libopenni2_INCLUDE_DIR})\ntarget_link_libraries(${PLUGIN_NAME} ${OpenCV_LIBRARIES} ${libopenni2_LIBRARY} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2openni_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openni/README.md</code></p>"},{"location":"api/plugins_2openni_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># OpenNI\n\n## Set Camera Mode\n\nIf you wish to switch up the video modes of OpenNI, update these two macros in `openni/plugin.cpp` accordingly:\n</code></pre>"},{"location":"api/plugins_2openni_2README_8md_source/#define-rgb_mode-0","title":"define RGB_MODE 0","text":""},{"location":"api/plugins_2openni_2README_8md_source/#define-depth_mode-0","title":"define DEPTH_MODE 0","text":"<p><pre><code>You can see the list of available modes once you run ILLIXR the first time. \n\n## Debugging\n</code></pre> Device open failed:     DeviceOpen using default: no devices found <pre><code>**Solution**: No OpenNI compatible device is plugged in. So plug one in\n</code></pre> Device open failed:     Could not open \"1d27/0601@3/2\": USB transfer timeout! <pre><code>**Solution**: This is usually fixed by unplug and plug back in.\n</code></pre> Device open failed:     Could not open \"1d27/0601@3/2\": Failed to open the USB device! <pre><code>**Solution**: Fix by running with sudo \n\n## Environment Variables\n\n**OPENNI_LOG_LEVEL**: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"critical\", or \"off\"\n</code></pre></p>"},{"location":"api/plugins_2openni_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; openni &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;opencv2/core/core.hpp&gt;</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2openni_2plugin_8cpp/#macros","title":"Macros","text":"Type Name define DEPTH_MODE <code>0</code> define RGB_MODE <code>0</code>"},{"location":"api/plugins_2openni_2plugin_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugins_2openni_2plugin_8cpp/#define-depth_mode","title":"define DEPTH_MODE","text":"<pre><code>#define DEPTH_MODE `0`\n</code></pre>"},{"location":"api/plugins_2openni_2plugin_8cpp/#define-rgb_mode","title":"define RGB_MODE","text":"<pre><code>#define RGB_MODE `0`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openni/plugin.cpp</code></p>"},{"location":"api/plugins_2openni_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; openni &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;iomanip&gt;\n#include &lt;opencv2/core/core.hpp&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n\n#define RGB_MODE   0\n#define DEPTH_MODE 0\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] openni_plugin::openni_plugin(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , rgb_depth_{switchboard_-&gt;get_writer&lt;rgb_depth_type&gt;(\"rgb_depth\")} {\n    spdlogger(switchboard_-&gt;get_env_char(\"OPENNI_LOG_LEVEL\"));\n    if (!camera_initialize()) {\n        spdlog::get(name)-&gt;error(\"Initialization failed\");\n        exit(0);\n    }\n}\n\nopenni_plugin::~openni_plugin() {\n    color_.destroy();\n    depth_.destroy();\n}\n\nthreadloop::skip_option openni_plugin::_p_should_skip() {\n    auto now  = std::chrono::steady_clock::now();\n    cam_time_ = std::chrono::time_point_cast&lt;std::chrono::milliseconds&gt;(now).time_since_epoch().count();\n    if (cam_time_ &gt; last_timestamp_) {\n        std::this_thread::sleep_for(std::chrono::milliseconds{time_sleep_});\n        return skip_option::run;\n    } else {\n        return skip_option::skip_and_yield;\n    }\n}\n\nvoid openni_plugin::_p_one_iteration() {\n    RAC_ERRNO_MSG(\"openni at start of _p_one_iteration\");\n\n    // read cam data\n    color_.readFrame(&amp;color_frame_);\n    depth_.readFrame(&amp;depth_frame_);\n    // get timestamp\n    assert(color_frame_.getTimestamp() != depth_frame_.getTimestamp());\n\n    // convert to cv format\n    cv::Mat color_mat;\n    color_mat.create(color_frame_.getHeight(), color_frame_.getWidth(), CV_8UC3);\n    auto* color_buffer = (const openni::RGB888Pixel*) color_frame_.getData();\n    memcpy(color_mat.data, color_buffer, 3 * color_frame_.getHeight() * color_frame_.getWidth() * sizeof(uint8_t));\n    cv::cvtColor(color_mat, color_mat, cv::COLOR_BGR2BGRA);\n    color_mat.convertTo(color_mat, CV_8UC4);\n\n    cv::Mat depth_mat;\n    depth_mat.create(depth_frame_.getHeight(), depth_frame_.getWidth(), CV_16UC1);\n    auto* depth_buffer = (const openni::DepthPixel*) depth_frame_.getData();\n    memcpy(depth_mat.data, depth_buffer, depth_frame_.getHeight() * depth_frame_.getWidth() * sizeof(uint16_t));\n\n    assert(cam_time_);\n    if (first_time_ == 0) {\n        first_time_      = cam_time_;\n        first_real_time_ = clock_-&gt;now();\n    }\n    time_point _cam_time_point{first_real_time_ + std::chrono::nanoseconds(cam_time_ - first_time_)};\n    rgb_depth_.put(rgb_depth_.allocate(_cam_time_point, color_mat, depth_mat));\n\n    last_timestamp_ = cam_time_;\n    RAC_ERRNO_MSG(\"openni at end of _p_one_iteration\");\n}\n\nbool openni_plugin::camera_initialize() {\n    // initialize openni\n    device_status_ = openni::OpenNI::initialize();\n    if (device_status_ != openni::STATUS_OK)\n        spdlog::get(name_)-&gt;error(\"Initialize failed: {}\", openni::OpenNI::getExtendedError());\n\n    // open device_\n    device_status_ = device_.open(openni::ANY_DEVICE);\n    if (device_status_ != openni::STATUS_OK)\n        spdlog::get(name_)-&gt;error(\"Device open failed: {}\", openni::OpenNI::getExtendedError());\n\n    /*_____________________________ DEPTH ___________________________*/\n    // create depth_ channel\n    device_status_ = depth_.create(device_, openni::SENSOR_DEPTH);\n    if (device_status_ != openni::STATUS_OK)\n        spdlog::get(name_)-&gt;warn(\"Couldn't find depth stream:\\n{}\", openni::OpenNI::getExtendedError());\n\n    // get depth_ options\n    const openni::SensorInfo*               depth_info  = device_.getSensorInfo(openni::SENSOR_DEPTH);\n    const openni::Array&lt;openni::VideoMode&gt;&amp; modes_depth = depth_info-&gt;getSupportedVideoModes();\n#ifndef NDEBUG\n    for (int i = 0; i &lt; modes_depth.getSize(); i++) {\n        spdlog::get(name_)-&gt;debug(\"Depth Mode {}: {}x{}, {} fps, {} format\", i, modes_depth[i].getResolutionX(),\n                                  modes_depth[i].getResolutionY(), modes_depth[i].getFps(), modes_depth[i].getPixelFormat());\n    }\n#endif\n    device_status_ = depth_.setVideoMode(modes_depth[DEPTH_MODE]);\n    if (openni::STATUS_OK != device_status_)\n        spdlog::get(name_)-&gt;error(\"error: depth format not supported...\");\n    // start depth_ stream\n    device_status_ = depth_.start();\n    if (device_status_ != openni::STATUS_OK)\n        spdlog::get(name_)-&gt;error(\"Couldn't start the depth_ stream {}\", openni::OpenNI::getExtendedError());\n\n    /*_____________________________ COLOR ___________________________*/\n    // create color_ channel\n    device_status_ = color_.create(device_, openni::SENSOR_COLOR);\n#ifndef NDEBUG\n    if (device_status_ != openni::STATUS_OK)\n        spdlog::get(name_)-&gt;debug(\"Couldn't find color stream:\\n{}\", openni::OpenNI::getExtendedError());\n#endif\n\n    // get color_ options\n    const openni::SensorInfo*               color_info  = device_.getSensorInfo(openni::SENSOR_COLOR);\n    const openni::Array&lt;openni::VideoMode&gt;&amp; modes_color = color_info-&gt;getSupportedVideoModes();\n#ifndef NDEBUG\n    for (int i = 0; i &lt; modes_color.getSize(); i++) {\n        spdlog::get(name_)-&gt;debug(\"Color Mode {}: {}x{}, {} fps, {} format\", i, modes_color[i].getResolutionX(),\n                                  modes_color[i].getResolutionY(), modes_color[i].getFps(), modes_color[i].getPixelFormat());\n    }\n#endif\n    device_status_ = color_.setVideoMode(modes_color[RGB_MODE]);\n    if (openni::STATUS_OK != device_status_)\n        spdlog::get(name_)-&gt;error(\"error: color format not supported...\");\n    // start color_ stream\n    device_status_ = color_.start();\n#ifndef NDEBUG\n    if (device_status_ != openni::STATUS_OK)\n        spdlog::get(name_)-&gt;debug(\"Couldn't start color stream:\\n{}\", openni::OpenNI::getExtendedError());\n#endif\n    int min_fps = std::min(modes_color[RGB_MODE].getFps(), modes_depth[DEPTH_MODE].getFps());\n    time_sleep_ = static_cast&lt;uint64_t&gt;((1.0f / static_cast&lt;float&gt;(min_fps)) * 1000);\n\n    return depth_.isValid() &amp;&amp; color_.isValid();\n}\n\nPLUGIN_MAIN(openni_plugin)\n</code></pre>"},{"location":"api/plugins_2openni_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; openni &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include &lt;openni2/OpenNI.h&gt;</code></li> </ul>"},{"location":"api/plugins_2openni_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2openni_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class openni_plugin <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openni/plugin.hpp</code></p>"},{"location":"api/plugins_2openni_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; openni &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n#include &lt;openni2/OpenNI.h&gt;\n\nnamespace ILLIXR {\nclass openni_plugin : public threadloop {\npublic:\n    [[maybe_unused]] openni_plugin(const std::string&amp; name, phonebook* pb);\n\n    ~openni_plugin() override;\n\nprotected:\n    skip_option _p_should_skip() override;\n    void        _p_one_iteration() override;\n    bool        camera_initialize();\n\nprivate:\n    // ILLIXR\n    const std::shared_ptr&lt;switchboard&gt;               switchboard_;\n    const std::shared_ptr&lt;const relative_clock&gt;      clock_;\n    switchboard::writer&lt;data_format::rgb_depth_type&gt; rgb_depth_;\n\n    // OpenNI\n    openni::Status        device_status_ = openni::STATUS_OK;\n    openni::Device        device_;\n    openni::VideoStream   depth_, color_;\n    openni::VideoFrameRef depth_frame_, color_frame_;\n\n    // timestamp\n    uint64_t   cam_time_{};\n    uint64_t   last_timestamp_ = 0;\n    uint64_t   first_time_{};\n    time_point first_real_time_{};\n    uint64_t   time_sleep_{};\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2openvins_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openvins/CMakeLists.txt</code></p>"},{"location":"api/plugins_2openvins_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>include(GetOpenVINS)\n</code></pre>"},{"location":"api/plugins_2openwarp__vk_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2openwarp__vk_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 16)  set (PLUGIN_SOURCE \"plugin.cpp\")"},{"location":"api/plugins_2openwarp__vk_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2openwarp__vk_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 16\n) \n</code></pre>"},{"location":"api/plugins_2openwarp__vk_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_SOURCE \"plugin.cpp\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/CMakeLists.txt</code></p>"},{"location":"api/plugins_2openwarp__vk_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.16)\n\nproject(openwarp_vk)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nfind_package(glm REQUIRED)\n\nif(NOT PLUGIN_NAME)\n    set(PLUGIN_NAME \"plugin.openwarp_vk${ILLIXR_BUILD_SUFFIX}\")\n    set(PLUGIN_SOURCE \"plugin.cpp\")\n    set(OW_PREFIX \"\")\n    set(OW_POSTFIX \"\")\nendif()\n\nfile(GLOB_RECURSE GLSL_SOURCE_FILES\n     \"${OW_PREFIX}shaders/*.frag\"\n     \"${OW_PREFIX}shaders/*.vert\"\n)\n\nset(PROJECT_BINARY_DIR \"${PROJECT_BINARY_DIR}${OW_POSTFIX}\")\n\nforeach(GLSL ${GLSL_SOURCE_FILES})\n    get_filename_component(FILE_NAME ${GLSL} NAME)\n    set(SPIRV \"${PROJECT_BINARY_DIR}/shaders/${FILE_NAME}.spv\")\n    if(NOT TARGET PROCESS_OW_${FILE_NAME})\n        add_custom_target(PROCESS_OW_${FILE_NAME} ALL\n                          COMMAND ${CMAKE_COMMAND} -E make_directory \"${PROJECT_BINARY_DIR}/shaders/\"\n                          COMMAND ${Vulkan_GLSLANG_VALIDATOR_EXECUTABLE} ${GLSL} -V -o ${SPIRV}\n                          BYPRODUCTS ${SPIRV}\n                          DEPENDS ${GLSL}\n        )\n        if(Vulkan_EXTERNAL)\n            add_dependencies(PROCESS_OW_${FILE_NAME} ${Vulkan_DEP_STR})\n        endif()\n    endif()\n    list(APPEND SPIRV_BINARY_FILES ${SPIRV})\nendforeach(GLSL)\n\nif(NOT TARGET OpenWarp_VK_Shaders)\n    add_custom_target(\n            OpenWarp_VK_Shaders\n            DEPENDS ${SPIRV_BINARY_FILES}\n    )\nendif()\n\nadd_library(${PLUGIN_NAME} SHARED\n            ${PLUGIN_SOURCE}\n            ${OW_PREFIX}plugin.hpp\n            ${OW_PREFIX}openwarp_vk.hpp\n            ${OW_PREFIX}openwarp_vk.cpp\n            $&lt;TARGET_OBJECTS:illixr_hmd&gt;\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/math_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/display_provider.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/render_pass.hpp\n            $&lt;TARGET_OBJECTS:illixr_vulkan_utils&gt;\n)\nif(OW_PLUGIN_DEFINITIONS)\n    target_compile_definitions(${PLUGIN_NAME} PUBLIC ${OW_PLUGIN_DEFINITIONS})\n    target_compile_definitions(${PLUGIN_NAME} PRIVATE MONADO_REQUIRED)\n    target_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/..)\nendif()\n\nadd_dependencies(${PLUGIN_NAME} OpenWarp_VK_Shaders)\n\nset_target_properties(${PLUGIN_NAME} PROPERTIES OUTPUT_NAME ${PLUGIN_NAME})\n\ntarget_link_libraries(${PLUGIN_NAME} PUBLIC ${Vulkan_LIBRARIES} spdlog::spdlog)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${Vulkan_INCLUDE_DIRS})\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${ILLIXR_SOURCE_DIR}/include)\n\ninstall_shaders(SPIRV_BINARY_FILES openwarp_vk ${PLUGIN_NAME})\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2openwarp__vk_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/README.md</code></p>"},{"location":"api/plugins_2openwarp__vk_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># openwarp_vk\n\n## Summary\n\n`openwarp_vk` is a Vulkan-based translational reprojection service intended for use in the ILLIXR architecture.\n\n## Phonebook Service\n\n`openwarp_vk` is registered as a service in phonebook, conforming to the `timewarp` render pass interface. Three\nfunctions are exposed:\n\n* `setup(VkRenderPass render_pass, uint32_t subpass)` initializes the required Vulkan pipeline and resources given a\n  specific render pass and subpass, to which `openwarp_vk` binds to\n* `update_uniforms(const pose_type render_pose)` calculates the reprojection matrix given the current pose and the pose\n  used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before\n  `record_command_buffer` is called\n* `record_command_buffer(VkCommandBuffer commandBuffer, int left)` records the commands into a given command buffer that\n  would perform the reprojection for one eye, for which 1 is left and 0 is right\n\n!!! note\n\n    Note that at the moment, OpenWarp assumes that a reverse depth buffer is being used (as in Unreal Engine, Godot, and our native demo). If you're using an application that uses forward depth, the projection matrices and Vulkan pipeline configuration should be updated accordingly.\n</code></pre>"},{"location":"api/plugins_2openwarp__vk_2monado_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2openwarp__vk_2monado_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name get_external_for_plugin (Monado_vk)"},{"location":"api/plugins_2openwarp__vk_2monado_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2openwarp__vk_2monado_2CMakeLists_8txt/#function-get_external_for_plugin","title":"function get_external_for_plugin","text":"<pre><code>get_external_for_plugin (\n    Monado_vk\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/monado/CMakeLists.txt</code></p>"},{"location":"api/plugins_2openwarp__vk_2monado_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>get_external_for_plugin(Monado_vk)\nfile(COPY_FILE ${CMAKE_SOURCE_DIR}/plugins/openwarp_vk/plugin.cpp ${CMAKE_BINARY_DIR}/plugins/openwarp_vk/plugin_m.cpp)\nset(PLUGIN_NAME \"plugin.openwarp_vk.monado${ILLIXR_BUILD_SUFFIX}\")\nset(OW_PLUGIN_DEFINITIONS MONADO_REQUIRED)\nset(PLUGIN_SOURCE \"${CMAKE_BINARY_DIR}/plugins/openwarp_vk/plugin_m.cpp\")\nset(OW_PREFIX \"../\")\nset(OW_POSTFIX \"/..\")\n\ninclude(../CMakeLists.txt)\n</code></pre>"},{"location":"api/plugins_2openwarp__vk_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; openwarp_vk &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/hmd.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/plugin.cpp</code></p>"},{"location":"api/plugins_2openwarp__vk_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; openwarp_vk &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/hmd.hpp\"\n#include \"illixr/switchboard.hpp\"\n\nusing namespace ILLIXR;\n\n[[maybe_unused]] openwarp_vk_plugin::openwarp_vk_plugin(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , timewarp_{std::make_shared&lt;openwarp_vk&gt;(pb)} {\n    pb-&gt;register_impl&lt;vulkan::timewarp&gt;(std::static_pointer_cast&lt;vulkan::timewarp&gt;(timewarp_));\n}\n\nvoid openwarp_vk_plugin::_p_one_iteration() {\n    auto fps = timewarp_-&gt;num_record_calls_.exchange(0) / 2; // two eyes\n    auto ups = timewarp_-&gt;num_update_uniforms_calls_.exchange(0);\n\n    // std::cout &lt;&lt; \"openwarp_vk: cb records: \" &lt;&lt; fps &lt;&lt; \", uniform updates: \" &lt;&lt; ups &lt;&lt; std::endl;\n}\n\nthreadloop::skip_option openwarp_vk_plugin::_p_should_skip() {\n    // Get the current time in milliseconds\n    auto now =\n        std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();\n\n    // Only print every 1 second\n    if (now - last_print_ &lt; 1000) {\n        return skip_option::skip_and_yield;\n    } else {\n        last_print_ = now;\n        return skip_option::run;\n    }\n}\n\nPLUGIN_MAIN(openwarp_vk_plugin)\n</code></pre>"},{"location":"api/plugins_2openwarp__vk_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; openwarp_vk &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"openwarp_vk.hpp\"</code></li> </ul>"},{"location":"api/plugins_2openwarp__vk_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2openwarp__vk_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class openwarp_vk_plugin <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/plugin.hpp</code></p>"},{"location":"api/plugins_2openwarp__vk_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; openwarp_vk &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"openwarp_vk.hpp\"\n\nnamespace ILLIXR {\n\nclass openwarp_vk_plugin : public threadloop {\npublic:\n    [[maybe_unused]] openwarp_vk_plugin(const std::string&amp; name, phonebook* pb);\n    void        _p_one_iteration() override;\n    skip_option _p_should_skip() override;\n\nprivate:\n    std::shared_ptr&lt;openwarp_vk&gt; timewarp_;\n    int64_t                      last_print_ = 0;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2orb__slam3_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/orb_slam3/CMakeLists.txt</code></p>"},{"location":"api/plugins_2orb__slam3_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>include(GetORB_SLAM3)\n</code></pre>"},{"location":"api/plugins_2orb__slam3_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/orb_slam3/README.md</code></p>"},{"location":"api/plugins_2orb__slam3_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># ORB-SLAM\n\nThis plugin uses the [ORB-SLAM3](https://github.com/UZ-SLAMLab/ORB_SLAM3) library for real-time VIO.\n</code></pre>"},{"location":"api/plugins_2passthrough__integrator_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2passthrough__integrator_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.passthrough_integrator${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2passthrough__integrator_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2passthrough__integrator_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.passthrough_integrator${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/passthrough_integrator/CMakeLists.txt</code></p>"},{"location":"api/plugins_2passthrough__integrator_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the passthrough_integrator ILLIXR plugin\n\nset(PLUGIN_NAME plugin.passthrough_integrator${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${Eigen3_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\ntarget_link_libraries(${PLUGIN_NAME} ${Eigen3_LIBRARIES})\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2passthrough__integrator_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; passthrough_integrator &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/passthrough_integrator/plugin.cpp</code></p>"},{"location":"api/plugins_2passthrough__integrator_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; passthrough_integrator &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;memory&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] passthrough_integrator::passthrough_integrator(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , imu_integrator_input_{switchboard_-&gt;get_reader&lt;imu_integrator_input&gt;(\"imu_integrator_input\")}\n    , imu_raw_{switchboard_-&gt;get_writer&lt;imu_raw_type&gt;(\"imu_raw\")} {\n    switchboard_-&gt;schedule&lt;imu_type&gt;(id_, \"imu\", [&amp;](const switchboard::ptr&lt;const imu_type&gt;&amp; datum, size_t) {\n        callback(datum);\n    });\n}\n\nvoid passthrough_integrator::callback(const switchboard::ptr&lt;const imu_type&gt;&amp; datum) {\n    auto input_values = imu_integrator_input_.get_ro_nullable();\n    if (input_values == nullptr) {\n        return;\n    }\n\n    Eigen::Matrix&lt;double, 4, 1&gt; curr_quat{input_values-&gt;quat.x(), input_values-&gt;quat.y(), input_values-&gt;quat.z(),\n                                          input_values-&gt;quat.w()};\n    Eigen::Matrix&lt;double, 3, 1&gt; curr_pos = input_values-&gt;position;\n    Eigen::Matrix&lt;double, 3, 1&gt; curr_vel = input_values-&gt;velocity;\n\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat2;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat2;\n\n    w_hat  = datum-&gt;angular_v - input_values-&gt;bias_gyro;\n    a_hat  = datum-&gt;linear_a - input_values-&gt;bias_acc;\n    w_hat2 = datum-&gt;angular_v - input_values-&gt;bias_gyro;\n    a_hat2 = datum-&gt;linear_a - input_values-&gt;bias_acc;\n\n    imu_raw_.put(imu_raw_.allocate(w_hat, a_hat, w_hat2, a_hat2, curr_pos, curr_vel,\n                                   Eigen::Quaterniond{curr_quat(3), curr_quat(0), curr_quat(1), curr_quat(2)}, datum-&gt;time));\n}\n\nPLUGIN_MAIN(passthrough_integrator)\n</code></pre>"},{"location":"api/plugins_2passthrough__integrator_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; passthrough_integrator &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> </ul>"},{"location":"api/plugins_2passthrough__integrator_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2passthrough__integrator_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class passthrough_integrator <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/passthrough_integrator/plugin.hpp</code></p>"},{"location":"api/plugins_2passthrough__integrator_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; passthrough_integrator &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\nnamespace ILLIXR {\nclass passthrough_integrator : public plugin {\npublic:\n    [[maybe_unused]] passthrough_integrator(const std::string&amp; name, phonebook* pb);\n\n    void callback(const switchboard::ptr&lt;const data_format::imu_type&gt;&amp; datum);\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n\n    // IMU Data, Sequence Flag, and State Vars Needed\n    switchboard::reader&lt;data_format::imu_integrator_input&gt; imu_integrator_input_;\n\n    // IMU state\n    switchboard::writer&lt;data_format::imu_raw_type&gt; imu_raw_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2realsense_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2realsense_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.realsense${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2realsense_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2realsense_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.realsense${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/realsense/CMakeLists.txt</code></p>"},{"location":"api/plugins_2realsense_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the realsense ILLIXR plugin\n\nset(PLUGIN_NAME plugin.realsense${ILLIXR_BUILD_SUFFIX})\n\nfind_package(realsense2 REQUIRED)\nfind_package(realsense2-gl REQUIRED)\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${OpenCV_INCLUDE_DIRS} ${Eigen3_INCLUDE_DIRS} ${realsense2_INCLUDE_DIR} ${ILLIXR_SOURCE_DIR}/include)\nadd_definitions(-Wno-format-extra-args)\ntarget_link_libraries(${PLUGIN_NAME} ${DEPENDENCIES} ${OpenCV_LIBRARIES} ${realsense2_LIBRARY} ${Eigen3_LIBRATIES} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; realsense &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr int ACCEL_RATE_D4XX   = <code>250</code> constexpr int FPS_D4XX   = <code>30</code> constexpr int GYRO_RATE_D4XX   = <code>400</code> constexpr int IMAGE_HEIGHT_D4XX   = <code>480</code> constexpr int IMAGE_HEIGHT_T26X   = <code>800</code> constexpr int IMAGE_WIDTH_D4XX   = <code>640</code> constexpr int IMAGE_WIDTH_T26X   = <code>848</code>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/plugins_2realsense_2plugin_8cpp/#variable-accel_rate_d4xx","title":"variable ACCEL_RATE_D4XX","text":"<pre><code>constexpr int ACCEL_RATE_D4XX;\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#variable-fps_d4xx","title":"variable FPS_D4XX","text":"<pre><code>constexpr int FPS_D4XX;\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#variable-gyro_rate_d4xx","title":"variable GYRO_RATE_D4XX","text":"<pre><code>constexpr int GYRO_RATE_D4XX;\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#variable-image_height_d4xx","title":"variable IMAGE_HEIGHT_D4XX","text":"<pre><code>constexpr int IMAGE_HEIGHT_D4XX;\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#variable-image_height_t26x","title":"variable IMAGE_HEIGHT_T26X","text":"<pre><code>constexpr int IMAGE_HEIGHT_T26X;\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#variable-image_width_d4xx","title":"variable IMAGE_WIDTH_D4XX","text":"<pre><code>constexpr int IMAGE_WIDTH_D4XX;\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8cpp/#variable-image_width_t26x","title":"variable IMAGE_WIDTH_T26X","text":"<pre><code>constexpr int IMAGE_WIDTH_T26X;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/realsense/plugin.cpp</code></p>"},{"location":"api/plugins_2realsense_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; realsense &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;mutex&gt;\n#include &lt;opencv2/opencv.hpp&gt; // Include OpenCV API\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nstatic constexpr int IMAGE_WIDTH_D4XX  = 640;\nstatic constexpr int IMAGE_HEIGHT_D4XX = 480;\nstatic constexpr int FPS_D4XX          = 30;\nstatic constexpr int GYRO_RATE_D4XX    = 400; // 200 or 400\nstatic constexpr int ACCEL_RATE_D4XX   = 250; // 63 or 250\n\nstatic constexpr int IMAGE_WIDTH_T26X  = 848;\nstatic constexpr int IMAGE_HEIGHT_T26X = 800;\n\n[[maybe_unused]] realsense::realsense(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , imu_{switchboard_-&gt;get_writer&lt;imu_type&gt;(\"imu\")}\n    , cam_{switchboard_-&gt;get_writer&lt;binocular_cam_type&gt;(\"cam\")}\n    , rgb_depth_{switchboard_-&gt;get_writer&lt;rgb_depth_type&gt;(\"rgb_depth\")}\n    , realsense_cam_{switchboard_-&gt;get_env(\"REALSENSE_CAM\", \"auto\")} {\n    spdlogger(switchboard_-&gt;get_env_char(\"REALSENSE_LOG_LEVEL\"));\n    accel_data_.iteration = -1;\n    config_.disable_all_streams();\n    configure_camera();\n}\n\nvoid realsense::callback(const rs2::frame&amp; frame) {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    // This lock guarantees that concurrent invocations of `callback` are serialized.\n    // Even if the API does not invoke `callback` in parallel, this is still important for the memory-model.\n    // Without this lock, prior invocations of `callback` are not necessarily \"happens-before\" ordered, so accessing\n    // persistent variables constitutes a data-race, which is undefined behavior in the C++ memory model.\n\n    // This callback function may start running before the relative clock is started. If that happens, the data\n    // timestamps will be messed up. We therefore add this guard to ignore all data samples before the clock is started.\n    if (!clock_-&gt;is_started()) {\n        return;\n    }\n    if (auto mf = frame.as&lt;rs2::motion_frame&gt;()) {\n        std::string s = mf.get_profile().stream_name();\n\n        if (s == \"Accel\") {\n            accel_data_.data      = mf.get_motion_data();\n            accel_data_.iteration = iteration_accel_;\n            iteration_accel_++;\n        }\n\n        if (s == \"Gyro\") {\n            if (last_iteration_accel_ == accel_data_.iteration) {\n                return;\n            }\n\n            last_iteration_accel_ = accel_data_.iteration;\n            rs2_vector accel      = accel_data_.data;\n            double     ts         = mf.get_timestamp();\n            rs2_vector gyro_data  = mf.get_motion_data();\n\n            // IMU data\n            Eigen::Vector3f la = {accel.x, accel.y, accel.z};\n            Eigen::Vector3f av = {gyro_data.x, gyro_data.y, gyro_data.z};\n\n            // Time as ullong (nanoseconds)\n            auto imu_time = static_cast&lt;ullong&gt;(ts * 1000000);\n            if (!first_imu_time_) {\n                first_imu_time_      = imu_time;\n                first_real_time_imu_ = clock_-&gt;now();\n            }\n\n            // Time as time_point\n            time_point imu_time_point{*first_real_time_imu_ + std::chrono::nanoseconds(imu_time - *first_imu_time_)};\n\n            // Submit to switchboard\n            imu_.put(imu_.allocate&lt;imu_type&gt;({imu_time_point, av.cast&lt;double&gt;(), la.cast&lt;double&gt;()}));\n        }\n    }\n\n    if (auto fs = frame.as&lt;rs2::frameset&gt;()) {\n        double ts       = fs.get_timestamp();\n        auto   cam_time = static_cast&lt;ullong&gt;(ts * 1000000);\n        if (!first_cam_time_) {\n            first_cam_time_      = cam_time;\n            first_real_time_cam_ = clock_-&gt;now();\n        }\n        time_point cam_time_point{*first_real_time_cam_ + std::chrono::nanoseconds(cam_time - *first_cam_time_)};\n        if (cam_select_ == D4XXI) {\n            rs2::video_frame ir_frame_left  = fs.get_infrared_frame(1);\n            rs2::video_frame ir_frame_right = fs.get_infrared_frame(2);\n            rs2::video_frame depth_frame    = fs.get_depth_frame();\n            rs2::video_frame rgb_frame      = fs.get_color_frame();\n            cv::Mat ir_left = cv::Mat(cv::Size(IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX), CV_8UC1, (void*) ir_frame_left.get_data());\n            cv::Mat ir_right =\n                cv::Mat(cv::Size(IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX), CV_8UC1, (void*) ir_frame_right.get_data());\n            cv::Mat rgb   = cv::Mat(cv::Size(IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX), CV_8UC3, (void*) rgb_frame.get_data());\n            cv::Mat depth = cv::Mat(cv::Size(IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX), CV_16UC1, (void*) depth_frame.get_data());\n            cv::Mat converted_depth;\n            float   depth_scale = pipeline_.get_active_profile()\n                                    .get_device()\n                                    .first&lt;rs2::depth_sensor&gt;()\n                                    .get_depth_scale(); // for converting measurements into millimeters\n            depth.convertTo(converted_depth, CV_32FC1, depth_scale * 1000.f);\n            cam_.put(cam_.allocate&lt;binocular_cam_type&gt;({cam_time_point, ir_left, ir_right}));\n            rgb_depth_.put(rgb_depth_.allocate&lt;rgb_depth_type&gt;({cam_time_point, rgb, depth}));\n        } else if (cam_select_ == T26X) {\n            rs2::video_frame fisheye_frame_left  = fs.get_fisheye_frame(1);\n            rs2::video_frame fisheye_frame_right = fs.get_fisheye_frame(2);\n            cv::Mat          fisheye_left =\n                cv::Mat(cv::Size(IMAGE_WIDTH_T26X, IMAGE_HEIGHT_T26X), CV_8UC1, (void*) fisheye_frame_left.get_data());\n            cv::Mat fisheye_right =\n                cv::Mat(cv::Size(IMAGE_WIDTH_T26X, IMAGE_HEIGHT_T26X), CV_8UC1, (void*) fisheye_frame_right.get_data());\n            cam_.put(cam_.allocate&lt;binocular_cam_type&gt;({cam_time_point, fisheye_left, fisheye_right}));\n        }\n    }\n};\n\nrealsense::~realsense() {\n    pipeline_.stop();\n}\n\nvoid realsense::find_supported_devices(const rs2::device_list&amp; devices) {\n    bool gyro_found{false};\n    bool accel_found{false};\n    for (rs2::device device : devices) {\n        if (device.supports(RS2_CAMERA_INFO_PRODUCT_LINE)) {\n            std::string product_line = device.get_info(RS2_CAMERA_INFO_PRODUCT_LINE);\n#ifndef NDEBUG\n            spdlog::get(name_)-&gt;debug(\"Found Product Line: {}\", product_line);\n#endif\n            if (product_line == \"D400\") {\n#ifndef NDEBUG\n                spdlog::get(name_)-&gt;debug(\"Checking for supported streams\");\n#endif\n                std::vector&lt;rs2::sensor&gt; sensors = device.query_sensors();\n                for (const rs2::sensor&amp; sensor : sensors) {\n                    std::vector&lt;rs2::stream_profile&gt; stream_profiles = sensor.get_stream_profiles();\n                    // Currently, all D4XX cameras provide infrared, RGB, and depth, so we only need to check for accel and\n                    // gyro\n                    for (auto&amp;&amp; sp : stream_profiles) {\n                        if (sp.stream_type() == RS2_STREAM_GYRO) {\n                            gyro_found = true;\n                        }\n                        if (sp.stream_type() == RS2_STREAM_ACCEL) {\n                            accel_found = true;\n                        }\n                    }\n                }\n                if (accel_found &amp;&amp; gyro_found) {\n                    D4XXI_found_ = true;\n#ifndef NDEBUG\n                    spdlog::get(name_)-&gt;debug(\"Supported D4XX found!\");\n#endif\n                }\n            } else if (product_line == \"T200\") {\n                T26X_found_ = true;\n#ifndef NDEBUG\n                spdlog::get(name_)-&gt;debug(\"T26X found!\");\n#endif\n            }\n        }\n    }\n    if (!T26X_found_ &amp;&amp; !D4XXI_found_) {\n#ifndef NDEBUG\n        spdlog::get(name_)-&gt;warn(\"No supported Realsense device detected!\");\n#endif\n    }\n}\n\nvoid realsense::configure_camera() {\n    rs2::context     ctx;\n    rs2::device_list devices = ctx.query_devices();\n    // This plugin assumes only one device should be connected to the system. If multiple supported devices are found the\n    // preference is to choose D4XX with IMU over T26X systems.\n    find_supported_devices(devices);\n    if (realsense_cam_ == \"auto\") {\n        if (D4XXI_found_) {\n            cam_select_ = D4XXI;\n#ifndef NDEBUG\n            spdlog::get(name_)-&gt;debug(\"Setting cam_select_: D4XX\");\n#endif\n        } else if (T26X_found_) {\n            cam_select_ = T26X;\n#ifndef NDEBUG\n            spdlog::get(name_)-&gt;debug(\"Setting cam_select_: T26X\");\n#endif\n        }\n    } else if ((realsense_cam_ == \"D4XX\") &amp;&amp; D4XXI_found_) {\n        cam_select_ = D4XXI;\n#ifndef NDEBUG\n        spdlog::get(name_)-&gt;debug(\"Setting cam_select_: D4XX\");\n#endif\n    } else if ((realsense_cam_ == \"T26X\") &amp;&amp; T26X_found_) {\n        cam_select_ = T26X;\n#ifndef NDEBUG\n        spdlog::get(name_)-&gt;debug(\"Setting cam_select_: T26X\");\n#endif\n    }\n    if (cam_select_ == UNSUPPORTED) {\n        ILLIXR::abort(\"Supported Realsense device NOT found!\");\n    }\n    if (cam_select_ == T26X) {\n        // T26X series has fixed options for accel rate, gyro rate, fisheye resolution, and FPS\n        config_.enable_stream(RS2_STREAM_ACCEL, RS2_FORMAT_MOTION_XYZ32F); // 62 Hz\n        config_.enable_stream(RS2_STREAM_GYRO, RS2_FORMAT_MOTION_XYZ32F);  // 200 Hz\n        config_.enable_stream(RS2_STREAM_FISHEYE, 1, RS2_FORMAT_Y8);       // 848x800, 30 FPS\n        config_.enable_stream(RS2_STREAM_FISHEYE, 2, RS2_FORMAT_Y8);       // 848x800, 30 FPS\n        profiles_ = pipeline_.start(config_, [&amp;](const rs2::frame&amp; frame) {\n            this-&gt;callback(frame);\n        });\n    } else if (cam_select_ == D4XXI) {\n        config_.enable_stream(RS2_STREAM_ACCEL, RS2_FORMAT_MOTION_XYZ32F,\n                              ACCEL_RATE_D4XX); // adjustable to 0, 63 (default), 250 hz\n        config_.enable_stream(RS2_STREAM_GYRO, RS2_FORMAT_MOTION_XYZ32F,\n                              GYRO_RATE_D4XX); // adjustable set to 0, 200 (default), 400 hz\n        config_.enable_stream(RS2_STREAM_INFRARED, 1, IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX, RS2_FORMAT_Y8, FPS_D4XX);\n        config_.enable_stream(RS2_STREAM_INFRARED, 2, IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX, RS2_FORMAT_Y8, FPS_D4XX);\n        config_.enable_stream(RS2_STREAM_COLOR, IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX, RS2_FORMAT_BGR8, FPS_D4XX);\n        config_.enable_stream(RS2_STREAM_DEPTH, IMAGE_WIDTH_D4XX, IMAGE_HEIGHT_D4XX, RS2_FORMAT_Z16, FPS_D4XX);\n        profiles_ = pipeline_.start(config_, [&amp;](const rs2::frame&amp; frame) {\n            this-&gt;callback(frame);\n        });\n        profiles_.get_device().first&lt;rs2::depth_sensor&gt;().set_option(\n            RS2_OPTION_EMITTER_ENABLED, 0.f); // disables IR emitter to use stereo images for SLAM but degrades depth\n                                              // quality in low texture environments.\n    }\n}\n\nPLUGIN_MAIN(realsense)\n</code></pre>"},{"location":"api/plugins_2realsense_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; realsense &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include &lt;librealsense2/rs.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2realsense_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2realsense_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class realsense <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/realsense/plugin.hpp</code></p>"},{"location":"api/plugins_2realsense_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; realsense &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n#include &lt;librealsense2/rs.hpp&gt; // Include RealSense Cross Platform API\n\nnamespace ILLIXR {\nclass realsense : public plugin {\npublic:\n    [[maybe_unused]] realsense(const std::string&amp; name, phonebook* pb);\n    void callback(const rs2::frame&amp; frame);\n    ~realsense() override;\n\nprivate:\n    typedef enum { UNSUPPORTED, D4XXI, T26X } cam_enum;\n\n    typedef struct {\n        rs2_vector data;\n        int        iteration;\n    } accel_type;\n\n    void find_supported_devices(const rs2::device_list&amp; devices);\n    void configure_camera();\n\n    const std::shared_ptr&lt;switchboard&gt;                   switchboard_;\n    const std::shared_ptr&lt;const relative_clock&gt;          clock_;\n    switchboard::writer&lt;data_format::imu_type&gt;           imu_;\n    switchboard::writer&lt;data_format::binocular_cam_type&gt; cam_;\n    switchboard::writer&lt;data_format::rgb_depth_type&gt;     rgb_depth_;\n    std::mutex                                           mutex_;\n    rs2::pipeline_profile                                profiles_;\n    rs2::pipeline                                        pipeline_;\n    rs2::config                                          config_;\n\n    cam_enum cam_select_{UNSUPPORTED};\n    bool     D4XXI_found_{false};\n    bool     T26X_found_{false};\n\n    accel_type  accel_data_{};\n    int         iteration_accel_ = 0;\n    int         last_iteration_accel_{};\n    std::string realsense_cam_;\n\n    std::optional&lt;ullong&gt;     first_imu_time_;\n    std::optional&lt;time_point&gt; first_real_time_imu_;\n\n    std::optional&lt;ullong&gt;     first_cam_time_;\n    std::optional&lt;time_point&gt; first_real_time_cam_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2record__imu__cam_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2record__imu__cam_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.record_imu_cam${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2record__imu__cam_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2record__imu__cam_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.record_imu_cam${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_imu_cam/CMakeLists.txt</code></p>"},{"location":"api/plugins_2record__imu__cam_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the record_imu_cam ILLIXR plugin\n\nset(PLUGIN_NAME plugin.record_imu_cam${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${BOOST_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${OpenCV_LIBRARIES} boost_filesystem ${Eigen3_LIBRARIES})\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2record__imu__cam_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_imu_cam/README.md</code></p>"},{"location":"api/plugins_2record__imu__cam_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># Record IMU Cam\n\nThe purpose of this plugin is to record a dataset, similar to the [EuRoC MAV dataset][E10] that includes the [_IMU_][G10] data and\nCam images.\n\n## How to record a dataset\n\nAdd `record_imu_cam` to either your input yaml file or to your `--plugins` argument when invoking the ILLIXR executable.\n\nAfter recording, the dataset will be stored in the ILLIXR project directory, with the following structure:\n\n    ILLIXR/data_record\n        \\_ cam0/\n            \\_ data/ \n                \\_ timestamp.png\n                \\_ ...\n            \\_ data.csv\n        \\_ cam1/\n            \\_ data/\n                \\_ timestamp.png\n                \\_ ...\n            \\_ data.csv\n        \\_ imu0\n            \\_ data.csv\n\n### Format\n\n1. `cam0/data.csv` and `cam1/data.csv` are both formatted as\n\n        timestamp [ns], timestamp.png\n2. `imu0/data.csv` is formatted as\n\n        timestamp [ns],w_x [rad s^-1],w_y [rad s^-1],w_z [rad s^-1],a_x [m s^-2],a_y [m s^-2],a_z [m s^-2]\n\n## How to rerun recorded dataset\n\n1. **(IMPORTANT)** Do not specify `record_imu_cam` in either your input yaml file or to your `--plugins` argument when\n   invoking the ILLIXR executable.\n\n2. When running the ILLIXR executable do one of the following:\n\n    - In the input yaml file add a line to the `env_vars` section: `  data: &lt;PATH_TO_ILLIXR&gt;/data_record`\n    - Add `--data=&lt;PATH_TO_ILLIXR&gt;/data_record` to the command line arguments\n    - Set the environment variable `ILLIXR_DATA` to `&lt;PATH_TO_ILLIXR&gt;/data_record`\n\n3. Make sure other plugins that feed images and IMU are not being used, such as [`offline_cam`][P10], \n   [`offline_imu`][P11], [`zed`][P12], and [`realsense`][P13].\n\n\n[//]: # (- glossary -)\n\n[G10]:  ../glossary.md#inertial-measurement-unit\n\n[//]: # (- plugins -)\n\n[P10]:  ../illixr_plugins.md#offline_cam\n\n[P11]:  ../illixr_plugins.md#offline_imu\n\n[P12]:  ../illixr_plugins.md#zed\n\n[P13]:  ../illixr_plugins.md#realsense\n\n\n[//]: # (- External -)\n\n[E10]:    https://projects.asl.ethz.ch/datasets/doku.php?id=kmavvisualinertialdatasets\n</code></pre>"},{"location":"api/plugins_2record__imu__cam_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; record_imu_cam &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;opencv2/imgcodecs.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_imu_cam/plugin.cpp</code></p>"},{"location":"api/plugins_2record__imu__cam_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; record_imu_cam &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;iomanip&gt;\n#include &lt;memory&gt;\n#include &lt;opencv2/imgcodecs.hpp&gt;\n#include &lt;string&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] record_imu_cam::record_imu_cam(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , cam_{switchboard_-&gt;get_buffered_reader&lt;binocular_cam_type&gt;(\"cam\")}\n    , record_data_{get_record_data_path()}\n    , cam0_data_dir_{record_data_ / \"cam0\" / \"data\"}\n    , cam1_data_dir_{record_data_ / \"cam1\" / \"data\"} {\n    // check folder exist, if exist delete it\n    boost::filesystem::remove_all(record_data_);\n\n    // create imu0 directory\n    boost::filesystem::path imu_dir = record_data_ / \"imu0\";\n    boost::filesystem::create_directories(imu_dir);\n    std::string imu_file = imu_dir.string() + \"/data.csv\";\n    imu_wt_file_.open(imu_file, std::ofstream::out);\n    imu_wt_file_ &lt;&lt; \"#timestamp [ns],w_x [rad s^-1],w_y [rad s^-1],w_z [rad s^-1],a_x [m s^-2],a_y [m s^-2],a_z [m s^-2]\"\n                 &lt;&lt; std::endl;\n\n    // create cam0 directory\n    boost::filesystem::create_directories(cam0_data_dir_);\n    std::string cam0_file = (record_data_ / \"cam0\" / \"data.csv\").string();\n    cam0_wt_file_.open(cam0_file, std::ofstream::out);\n    cam0_wt_file_ &lt;&lt; \"#timestamp [ns],filename\" &lt;&lt; std::endl;\n\n    // create cam1 directory\n    boost::filesystem::create_directories(cam1_data_dir_);\n    std::string cam1_file = (record_data_ / \"cam1\" / \"data.csv\").string();\n    cam1_wt_file_.open(cam1_file, std::ofstream::out);\n    cam1_wt_file_ &lt;&lt; \"#timestamp [ns],filename\" &lt;&lt; std::endl;\n\n    switchboard_-&gt;schedule&lt;imu_type&gt;(id_, \"imu\", [this](const switchboard::ptr&lt;const imu_type&gt;&amp; datum, const std::size_t&amp;) {\n        this-&gt;dump_data(datum);\n    });\n}\n\nvoid record_imu_cam::dump_data(const switchboard::ptr&lt;const imu_type&gt;&amp; datum) {\n    long            timestamp = datum-&gt;time.time_since_epoch().count();\n    Eigen::Vector3d angular_v = datum-&gt;angular_v;\n    Eigen::Vector3d linear_a  = datum-&gt;linear_a;\n\n    // write imu0\n    imu_wt_file_ &lt;&lt; timestamp &lt;&lt; \",\" &lt;&lt; std::setprecision(17) &lt;&lt; angular_v[0] &lt;&lt; \",\" &lt;&lt; angular_v[1] &lt;&lt; \",\" &lt;&lt; angular_v[2]\n                 &lt;&lt; \",\" &lt;&lt; linear_a[0] &lt;&lt; \",\" &lt;&lt; linear_a[1] &lt;&lt; \",\" &lt;&lt; linear_a[2] &lt;&lt; std::endl;\n\n    // write cam0 and cam1\n    switchboard::ptr&lt;const binocular_cam_type&gt; cam;\n    cam                  = cam_.size() == 0 ? nullptr : cam_.dequeue();\n    std::string cam0_img = cam0_data_dir_.string() + \"/\" + std::to_string(timestamp) + \".png\";\n    std::string cam1_img = cam1_data_dir_.string() + \"/\" + std::to_string(timestamp) + \".png\";\n    if (cam != nullptr) {\n        cam0_wt_file_ &lt;&lt; timestamp &lt;&lt; \",\" &lt;&lt; timestamp &lt;&lt; \".png \" &lt;&lt; std::endl;\n        cv::imwrite(cam0_img, cam-&gt;at(image::LEFT_EYE));\n        cam1_wt_file_ &lt;&lt; timestamp &lt;&lt; \",\" &lt;&lt; timestamp &lt;&lt; \".png \" &lt;&lt; std::endl;\n        cv::imwrite(cam1_img, cam-&gt;at(image::RIGHT_EYE));\n    }\n}\n\nrecord_imu_cam::~record_imu_cam() {\n    imu_wt_file_.close();\n    cam0_wt_file_.close();\n    cam1_wt_file_.close();\n}\n\n// TODO: This should come from a yaml file\nboost::filesystem::path record_imu_cam::get_record_data_path() {\n    boost::filesystem::path ILLIXR_DIR = boost::filesystem::current_path();\n    return ILLIXR_DIR / \"data_record\";\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(record_imu_cam)\n</code></pre>"},{"location":"api/plugins_2record__imu__cam_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; record_imu_cam &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;boost/filesystem.hpp&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> </ul>"},{"location":"api/plugins_2record__imu__cam_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2record__imu__cam_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class record_imu_cam <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_imu_cam/plugin.hpp</code></p>"},{"location":"api/plugins_2record__imu__cam_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; record_imu_cam &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;boost/filesystem.hpp&gt;\n#include &lt;fstream&gt;\n\nnamespace ILLIXR {\nclass record_imu_cam : public plugin {\npublic:\n    [[maybe_unused]] record_imu_cam(const std::string&amp; name, phonebook* pb);\n    void dump_data(const switchboard::ptr&lt;const data_format::imu_type&gt;&amp; datum);\n    ~record_imu_cam() override;\n\nprivate:\n    static boost::filesystem::path get_record_data_path();\n\n    std::ofstream                      imu_wt_file_;\n    std::ofstream                      cam0_wt_file_;\n    std::ofstream                      cam1_wt_file_;\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n\n    switchboard::buffered_reader&lt;data_format::binocular_cam_type&gt; cam_;\n\n    const boost::filesystem::path record_data_;\n    const boost::filesystem::path cam0_data_dir_;\n    const boost::filesystem::path cam1_data_dir_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2record__rgb__depth_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2record__rgb__depth_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.record_rgb_depth${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2record__rgb__depth_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2record__rgb__depth_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.record_rgb_depth${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_rgb_depth/CMakeLists.txt</code></p>"},{"location":"api/plugins_2record__rgb__depth_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>set(PLUGIN_NAME plugin.record_rgb_depth${ILLIXR_BUILD_SUFFIX})\n\nset(RECORD_RGB_SOURCES plugin.cpp\n    plugin.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n)\nadd_library(${PLUGIN_NAME} SHARED ${RECORD_RGB_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${OpenCV_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${OpenCV_LIBRARIES} boost_filesystem)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2record__rgb__depth_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; record_rgb_depth &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;opencv2/imgcodecs.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_rgb_depth/plugin.cpp</code></p>"},{"location":"api/plugins_2record__rgb__depth_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; record_rgb_depth &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;opencv2/imgcodecs.hpp&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] record_rgb_depth::record_rgb_depth(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , record_data_{get_record_data_path()}\n    , rgb_data_dir_{record_data_ / \"rgb\" / \"data\"}\n    , depth_data_dir_{record_data_ / \"depth\" / \"data\"} {\n    // check folder exist, if exist delete it\n    boost::filesystem::remove_all(record_data_);\n\n    // create cam0 directory\n    boost::filesystem::create_directories(rgb_data_dir_);\n    std::string cam0_file = (record_data_ / \"rgb\" / \"data.csv\").string();\n    rgb_wt_file_.open(cam0_file, std::ofstream::out);\n    rgb_wt_file_ &lt;&lt; \"#timestamp [ns],filename\" &lt;&lt; std::endl;\n\n    // create cam1 directory\n    boost::filesystem::create_directories(depth_data_dir_);\n    std::string cam1_file = (record_data_ / \"depth\" / \"data.csv\").string();\n    depth_wt_file_.open(cam1_file, std::ofstream::out);\n    depth_wt_file_ &lt;&lt; \"#timestamp [ns],filename\" &lt;&lt; std::endl;\n\n    switchboard_-&gt;schedule&lt;rgb_depth_type&gt;(id_, \"rgb_depth\",\n                                           [&amp;](const switchboard::ptr&lt;const rgb_depth_type&gt;&amp; datum, std::size_t) {\n                                               this-&gt;dump_data(datum);\n                                           });\n}\n\nvoid record_rgb_depth::dump_data(const switchboard::ptr&lt;const rgb_depth_type&gt;&amp; datum) {\n    if (!datum)\n        return;\n    long timestamp = datum-&gt;time.time_since_epoch().count();\n\n    // write rgb and depth\n    std::string rgb_img   = rgb_data_dir_.string() + \"/\" + std::to_string(timestamp) + \".png\";\n    std::string depth_img = depth_data_dir_.string() + \"/\" + std::to_string(timestamp) + \".png\";\n    rgb_wt_file_ &lt;&lt; timestamp &lt;&lt; \",\" &lt;&lt; timestamp &lt;&lt; \".png \" &lt;&lt; std::endl;\n    cv::imwrite(rgb_img, datum-&gt;at(image::RGB));\n    depth_wt_file_ &lt;&lt; timestamp &lt;&lt; \",\" &lt;&lt; timestamp &lt;&lt; \".png \" &lt;&lt; std::endl;\n    cv::imwrite(depth_img, datum-&gt;at(image::DEPTH));\n}\n\nrecord_rgb_depth::~record_rgb_depth() {\n    rgb_wt_file_.close();\n    depth_wt_file_.close();\n}\n\n// TODO: This should come from a yaml file\nboost::filesystem::path record_rgb_depth::get_record_data_path() {\n    boost::filesystem::path ILLIXR_DIR = boost::filesystem::current_path();\n    return ILLIXR_DIR / \"data_rgbd_record\";\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(record_rgb_depth)\n</code></pre>"},{"location":"api/plugins_2record__rgb__depth_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; record_rgb_depth &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;boost/filesystem.hpp&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> </ul>"},{"location":"api/plugins_2record__rgb__depth_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2record__rgb__depth_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class record_rgb_depth <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/record_rgb_depth/plugin.hpp</code></p>"},{"location":"api/plugins_2record__rgb__depth_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; record_rgb_depth &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;boost/filesystem.hpp&gt;\n#include &lt;fstream&gt;\n\nnamespace ILLIXR {\nclass record_rgb_depth : public plugin {\npublic:\n    [[maybe_unused]] record_rgb_depth(const std::string&amp; name, phonebook* pb);\n    void dump_data(const switchboard::ptr&lt;const data_format::rgb_depth_type&gt;&amp; datum);\n    ~record_rgb_depth() override;\n\nprivate:\n    static boost::filesystem::path get_record_data_path();\n\n    std::ofstream                      rgb_wt_file_;\n    std::ofstream                      depth_wt_file_;\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n\n    const boost::filesystem::path record_data_;\n    const boost::filesystem::path rgb_data_dir_;\n    const boost::filesystem::path depth_data_dir_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2rk4__integrator_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2rk4__integrator_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.rk4_integrator${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2rk4__integrator_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2rk4__integrator_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.rk4_integrator${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/rk4_integrator/CMakeLists.txt</code></p>"},{"location":"api/plugins_2rk4__integrator_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the rk4_integrator ILLIXR plugin\n\nset(PLUGIN_NAME plugin.rk4_integrator${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${Eigen3_LIBRARIES})\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2rk4__integrator_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; rk4_integrator &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/runge-kutta.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/plugins_2rk4__integrator_2plugin_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr duration IMU_SAMPLE_LIFETIME   = <code>{std::chrono::seconds{5}}</code>"},{"location":"api/plugins_2rk4__integrator_2plugin_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/plugins_2rk4__integrator_2plugin_8cpp/#variable-imu_sample_lifetime","title":"variable IMU_SAMPLE_LIFETIME","text":"<pre><code>constexpr duration IMU_SAMPLE_LIFETIME;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/rk4_integrator/plugin.cpp</code></p>"},{"location":"api/plugins_2rk4__integrator_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; rk4_integrator &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// This entire IMU integrator has been ported almost as-is from the original OpenVINS integrator, which\n// can be found here: https://github.com/rpng/open_vins/blob/master/ov_msckf/src/state/Propagator.cpp\n\n#include \"plugin.hpp\"\n\n#include \"illixr/runge-kutta.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;iomanip&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nconstexpr duration IMU_SAMPLE_LIFETIME{std::chrono::seconds{5}};\n\n[[maybe_unused]] rk4_integrator::rk4_integrator(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , imu_integrator_input_{switchboard_-&gt;get_reader&lt;imu_integrator_input&gt;(\"imu_integrator_input\")}\n    , imu_raw_{switchboard_-&gt;get_writer&lt;imu_raw_type&gt;(\"imu_raw\")} {\n    switchboard_-&gt;schedule&lt;imu_type&gt;(id_, \"imu\", [&amp;](const switchboard::ptr&lt;const imu_type&gt;&amp; datum, size_t) {\n        callback(datum);\n    });\n}\n\nvoid rk4_integrator::callback(const switchboard::ptr&lt;const imu_type&gt;&amp; datum) {\n    imu_vec_.emplace_back(datum-&gt;time, datum-&gt;angular_v, datum-&gt;linear_a);\n\n    clean_imu_vec(datum-&gt;time);\n    propagate_imu_values(datum-&gt;time);\n\n    RAC_ERRNO_MSG(\"rk4_integrator\");\n}\n\n// Clean IMU values older than IMU_SAMPLE_LIFETIME seconds\nvoid rk4_integrator::clean_imu_vec(time_point timestamp) {\n    auto it0 = imu_vec_.begin();\n    while (it0 != imu_vec_.end()) {\n        if (timestamp - it0-&gt;time &lt; IMU_SAMPLE_LIFETIME) {\n            break;\n        }\n        it0 = imu_vec_.erase(it0);\n    }\n}\n\n// Timestamp we are propagating the biases to (new IMU reading time)\nvoid rk4_integrator::propagate_imu_values(time_point real_time) {\n    auto input_values = imu_integrator_input_.get_ro_nullable();\n    if (input_values == nullptr) {\n        return;\n    }\n\n    if (!has_last_offset_) {\n        last_imu_offset_ = input_values-&gt;t_offset;\n        has_last_offset_ = true;\n    }\n\n    proper_quaterniond          curr_quat = {input_values-&gt;quat.w(), input_values-&gt;quat.x(), input_values-&gt;quat.y(),\n                                             input_values-&gt;quat.z()};\n    Eigen::Matrix&lt;double, 3, 1&gt; curr_pos  = input_values-&gt;position;\n    Eigen::Matrix&lt;double, 3, 1&gt; curr_vel  = input_values-&gt;velocity;\n\n    // Uncomment this for some helpful prints\n    // total_imu_++;\n    // if (input_values-&gt;last_cam_integration_time &gt; last_cam_time_) {\n    //  cam_count_++;\n    //  last_cam_time_ = input_values-&gt;last_cam_integration_time;\n    //  std::cout &lt;&lt; \"Num IMUs received since last cam: \" &lt;&lt; counter_ &lt;&lt; \" Diff between new cam and latest IMU: \"\n    //            &lt;&lt; timestamp - last_cam_time_ &lt;&lt; \" Expected IMUs received VS Actual: \" &lt;&lt; cam_count_*10 &lt;&lt; \", \" &lt;&lt;\n    // total_imu_\n    // &lt;&lt; std::endl;    counter_ = 0;\n    // }\n    // counter_++;\n\n    // Get what our IMU-camera offset should be (t_imu = t_cam + calib_dt)\n    duration t_off_new = input_values-&gt;t_offset;\n\n    // This is the last CAM time\n    time_point time0 = input_values-&gt;last_cam_integration_time + last_imu_offset_;\n    time_point time1 = real_time + t_off_new;\n\n    std::vector&lt;imu_type&gt;       prop_data = select_imu_readings(imu_vec_, time0, time1);\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat2;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat2;\n\n    // Loop through all IMU messages, and use them to move the state forward in time\n    // This uses the zero'th order quat, and then constant acceleration discrete\n    if (prop_data.size() &gt; 1) {\n        for (size_t i = 0; i &lt; prop_data.size() - 1; i++) {\n            // Time elapsed over interval\n            double dt = duration_to_double(prop_data[i + 1].time - prop_data[i].time);\n\n            // Corrected imu measurements\n            w_hat  = prop_data[i].angular_v - input_values-&gt;bias_gyro;\n            a_hat  = prop_data[i].linear_a - input_values-&gt;bias_acc;\n            w_hat2 = prop_data[i + 1].angular_v - input_values-&gt;bias_gyro;\n            a_hat2 = prop_data[i + 1].linear_a - input_values-&gt;bias_acc;\n\n            // Compute the new state mean value\n            state_plus sp =\n                ::ILLIXR::predict_mean_rk4(dt, state_plus(curr_quat, curr_vel, curr_pos), w_hat, a_hat, w_hat2, a_hat2);\n\n            curr_quat = sp.orientation;\n            curr_pos  = sp.position;\n            curr_vel  = sp.velocity;\n        }\n    }\n\n    imu_raw_.put(imu_raw_.allocate(w_hat, a_hat, w_hat2, a_hat2, curr_pos, curr_vel, curr_quat, real_time));\n}\n\n// Select IMU readings based on timestamp similar to how OpenVINS selects IMU values to propagate\nstd::vector&lt;imu_type&gt; rk4_integrator::select_imu_readings(const std::vector&lt;imu_type&gt;&amp; imu_data, time_point time_begin,\n                                                          time_point time_end) {\n    std::vector&lt;imu_type&gt; prop_data;\n    if (imu_data.size() &lt; 2) {\n        return prop_data;\n    }\n\n    for (size_t i = 0; i &lt; imu_data.size() - 1; i++) {\n        // If time_begin comes inbetween two IMUs (A and B), interpolate A forward to time_begin\n        if (imu_data[i + 1].time &gt; time_begin &amp;&amp; imu_data[i].time &lt; time_begin) {\n            imu_type data = interpolate_imu(imu_data[i], imu_data[i + 1], time_begin);\n            prop_data.push_back(data);\n            continue;\n        }\n\n        // IMU is within time_begin and time_end\n        if (imu_data[i].time &gt;= time_begin &amp;&amp; imu_data[i + 1].time &lt;= time_end) {\n            prop_data.push_back(imu_data[i]);\n            continue;\n        }\n\n        // IMU is past time_end\n        if (imu_data[i + 1].time &gt; time_end) {\n            imu_type data = interpolate_imu(imu_data[i], imu_data[i + 1], time_end);\n            prop_data.push_back(data);\n            break;\n        }\n    }\n\n    // Loop through and ensure we do not have zero dt values\n    // This would cause the noise covariance to be Infinity\n    for (int i = 0; i &lt; int(prop_data.size()) - 1; i++) {\n        if (std::chrono::abs(prop_data[i + 1].time - prop_data[i].time) &lt; std::chrono::nanoseconds{1}) {\n            prop_data.erase(prop_data.begin() + i);\n            i--; // i can be negative, so use type int\n        }\n    }\n\n    return prop_data;\n}\n\n// For when an integration time ever falls inbetween two imu measurements (modeled after OpenVINS)\nimu_type rk4_integrator::interpolate_imu(const imu_type&amp; imu_1, const imu_type&amp; imu_2, time_point timestamp) {\n    double lambda = duration_to_double(timestamp - imu_1.time) / duration_to_double(imu_2.time - imu_1.time);\n    return imu_type{timestamp, (1 - lambda) * imu_1.linear_a + lambda * imu_2.linear_a,\n                    (1 - lambda) * imu_1.angular_v + lambda * imu_2.angular_v};\n}\n\nPLUGIN_MAIN(rk4_integrator)\n</code></pre>"},{"location":"api/plugins_2rk4__integrator_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; rk4_integrator &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> </ul>"},{"location":"api/plugins_2rk4__integrator_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2rk4__integrator_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class rk4_integrator <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/rk4_integrator/plugin.hpp</code></p>"},{"location":"api/plugins_2rk4__integrator_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; rk4_integrator &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/switchboard.hpp\"\n\nnamespace ILLIXR {\nclass rk4_integrator : public plugin {\npublic:\n    [[maybe_unused]] rk4_integrator(const std::string&amp; name, phonebook* pb);\n    void callback(const switchboard::ptr&lt;const data_format::imu_type&gt;&amp; datum);\n\nprivate:\n    void                                      clean_imu_vec(time_point timestamp);\n    void                                      propagate_imu_values(time_point real_time);\n    static std::vector&lt;data_format::imu_type&gt; select_imu_readings(const std::vector&lt;data_format::imu_type&gt;&amp; imu_data,\n                                                                  time_point time_begin, time_point time_end);\n    static data_format::imu_type interpolate_imu(const data_format::imu_type&amp; imu1, const data_format::imu_type&amp; imu2,\n                                                 time_point timestamp);\n\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n\n    // IMU Data, Sequence Flag, and State Vars Needed\n    switchboard::reader&lt;data_format::imu_integrator_input&gt; imu_integrator_input_;\n\n    // IMU Biases\n    switchboard::writer&lt;data_format::imu_raw_type&gt; imu_raw_;\n    std::vector&lt;data_format::imu_type&gt;             imu_vec_;\n    duration                                       last_imu_offset_{};\n    bool                                           has_last_offset_ = false;\n\n    [[maybe_unused]] int    counter_       = 0;\n    [[maybe_unused]] int    cam_count_     = 0;\n    [[maybe_unused]] int    total_imu_     = 0;\n    [[maybe_unused]] double last_cam_time_ = 0;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2tcp__network__backend_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2tcp__network__backend_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 16)  set (CMAKE_CXX_STANDARD 17)"},{"location":"api/plugins_2tcp__network__backend_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2tcp__network__backend_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 16\n) \n</code></pre>"},{"location":"api/plugins_2tcp__network__backend_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    CMAKE_CXX_STANDARD 17\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/tcp_network_backend/CMakeLists.txt</code></p>"},{"location":"api/plugins_2tcp__network__backend_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.16)\n\nproject(tcp_network_backend)\n\nset(PLUGIN_NAME plugin.tcp_network_backend${ILLIXR_BUILD_SUFFIX})\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/network/network_backend.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/network/tcpsocket.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/network/topic_config.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n)\n\nset_target_properties(${PLUGIN_NAME} PROPERTIES OUTPUT_NAME ${PLUGIN_NAME})\n\ntarget_link_libraries(${PLUGIN_NAME} spdlog::spdlog)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${ILLIXR_SOURCE_DIR}/include)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2tcp__network__backend_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/tcp_network_backend/README.md</code></p>"},{"location":"api/plugins_2tcp__network__backend_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <p><pre><code># TCP_network_backend\n## Summary\n`TCP_network_backend` manages the transmission and reception of data published on networked topics (created by `get_network_writer` in Switchboard) through a TCP backend.\nThe users need to specify the IP address and port number of the server and client through setting some environment variables.\n</code></pre> ILLIXR_TCP_SERVER_IP: IP address of the server. ILLIXR_TCP_SERVER_PORT: Port number of the server. ILLIXR_IS_CLIENT: Set to <code>1</code> if this process is acting as a client; otherwise, <code>0</code>. <pre><code>The client will initiate connection to the server by specifying the IP and port number, and the server will accept the connection request.\n\nOptionally, the client can set its IP address and port number.\n</code></pre> ILLIXR_TCP_CLIENT_IP: IP address of the client. ILLIXR_TCP_CLIENT_PORT: Port number of the client. <pre><code>\n</code></pre></p>"},{"location":"api/plugins_2tcp__network__backend_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; tcp_network_backend &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> </ul>"},{"location":"api/plugins_2tcp__network__backend_2plugin_8cpp/#public-functions","title":"Public Functions","text":"Type Name plugin * this_plugin_factory (phonebook * pb)"},{"location":"api/plugins_2tcp__network__backend_2plugin_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2tcp__network__backend_2plugin_8cpp/#function-this_plugin_factory","title":"function this_plugin_factory","text":"<pre><code>plugin * this_plugin_factory (\n    phonebook * pb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/tcp_network_backend/plugin.cpp</code></p>"},{"location":"api/plugins_2tcp__network__backend_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; tcp_network_backend &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\nusing namespace ILLIXR;\n\ntcp_network_backend::tcp_network_backend(const std::string&amp; name_, phonebook* pb_)\n    : plugin(name_, pb_)\n    , switchboard_{pb_-&gt;lookup_impl&lt;switchboard&gt;()} {\n    // read environment variables\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_TCP_SERVER_IP\")) {\n        server_ip_ = switchboard_-&gt;get_env_char(\"ILLIXR_TCP_SERVER_IP\");\n        spdlog::get(\"illixr\")-&gt;info(\"[tcp_network_backend] Using TCP server IP {}\", server_ip_);\n    }\n\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_TCP_SERVER_PORT\")) {\n        server_port_ = std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_TCP_SERVER_PORT\"));\n        spdlog::get(\"illixr\")-&gt;info(\"[tcp_network_backend] Using TCP server port {}\", server_port_);\n    }\n\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_TCP_CLIENT_IP\")) {\n        client_ip_ = switchboard_-&gt;get_env_char(\"ILLIXR_TCP_CLIENT_IP\");\n        spdlog::get(\"illixr\")-&gt;info(\"[tcp_network_backend] Using TCP client IP {}\", client_ip_);\n    }\n\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_TCP_CLIENT_PORT\")) {\n        client_port_ = std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_TCP_CLIENT_PORT\"));\n        spdlog::get(\"illixr\")-&gt;info(\"[tcp_network_backend] Using TCP client port {}\", client_port_);\n    }\n\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_IS_CLIENT\")) {\n        is_client_ = std::stoi(switchboard_-&gt;get_env_char(\"ILLIXR_IS_CLIENT\"));\n        spdlog::get(\"illixr\")-&gt;info(\"[tcp_network_backend] Is client\", is_client_);\n    }\n\n    if (is_client_) {\n        client = true;\n        std::thread([this]() {\n            start_client();\n        }).detach();\n\n        // wait till we are connected\n        while (!ready_) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    } else {\n        client = false;\n        std::thread([this]() {\n            start_server();\n        }).detach();\n\n        while (!ready_) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n}\n\nvoid tcp_network_backend::start_client() {\n    auto* socket = new network::TCPSocket();\n    if (switchboard_-&gt;get_env_char(\"ILLIXR_TCP_CLIENT_IP\") &amp;&amp; switchboard_-&gt;get_env_char(\"ILLIXR_TCP_CLIENT_PORT\")) {\n        socket-&gt;socket_bind(client_ip_, client_port_);\n    }\n    socket-&gt;socket_set_reuseaddr();\n    socket-&gt;enable_no_delay();\n    peer_socket_ = socket;\n\n    std::cout &lt;&lt; \"Connecting to \" + server_ip_ + \" at port \" + std::to_string(server_port_) &lt;&lt; std::endl;\n    socket-&gt;socket_connect(server_ip_, server_port_);\n    std::cout &lt;&lt; \"Connected to server\" &lt;&lt; std::endl;\n\n    ready_ = true;\n    read_loop(socket);\n}\n\nvoid tcp_network_backend::start_server() {\n    network::TCPSocket server_socket;\n    server_socket.socket_set_reuseaddr();\n    server_socket.socket_bind(server_ip_, server_port_);\n    server_socket.enable_no_delay();\n    server_socket.socket_listen();\n\n    auto* client_socket = new network::TCPSocket(server_socket.socket_accept());\n    std::cout &lt;&lt; \"Accepted connection from client: \" &lt;&lt; client_socket-&gt;peer_address() &lt;&lt; std::endl;\n    peer_socket_ = client_socket;\n    ready_       = true;\n    read_loop(client_socket);\n}\n\nvoid tcp_network_backend::read_loop(network::TCPSocket* socket) {\n    std::string buffer;\n    while (running_) {\n        // read from socket\n        // packet are in the format\n        // total_length:4bytes|topic_name_length:4bytes|topic_name|message\n        std::string packet = socket-&gt;read_data();\n        buffer += packet;\n\n        // check if we have a complete packet\n        while (buffer.size() &gt;= 8) {\n            uint32_t total_length = *reinterpret_cast&lt;uint32_t*&gt;(buffer.data());\n            if (buffer.size() &gt;= total_length) {\n                uint32_t          topic_name_length = *reinterpret_cast&lt;uint32_t*&gt;(buffer.data() + 4);\n                std::string       topic_name(buffer.data() + 8, topic_name_length);\n                std::vector&lt;char&gt; message(buffer.begin() + 8 + topic_name_length, buffer.begin() + total_length);\n                topic_receive(topic_name, message);\n                buffer.erase(buffer.begin(), buffer.begin() + total_length);\n            } else {\n                break;\n            }\n        }\n    }\n}\n\nvoid tcp_network_backend::topic_create(std::string topic_name, network::topic_config&amp; config) {\n    networked_topics_.push_back(topic_name);\n    networked_topics_configs_[topic_name] = config;\n    std::string serializaiton;\n    if (config.serialization_method == network::topic_config::SerializationMethod::BOOST) {\n        serializaiton = \"BOOST\";\n    } else {\n        serializaiton = \"PROTOBUF\";\n    }\n    std::string message = \"create_topic\" + topic_name + delimiter_ + serializaiton;\n    send_to_peer(\"illixr_control\", std::move(message));\n}\n\nbool tcp_network_backend::is_topic_networked(std::string topic_name) {\n    return std::find(networked_topics_.begin(), networked_topics_.end(), topic_name) != networked_topics_.end();\n}\n\nvoid tcp_network_backend::topic_send(std::string topic_name, std::string&amp;&amp; message) {\n    if (is_topic_networked(topic_name) == false) {\n        std::cout &lt;&lt; \"Topic not networked\" &lt;&lt; std::endl;\n        return;\n    }\n\n    std::cout &lt;&lt; \"Sending to peer: \" &lt;&lt; topic_name &lt;&lt; std::endl;\n    send_to_peer(topic_name, std::move(message));\n}\n\n// Helper function to queue a received message into the corresponding topic\nvoid tcp_network_backend::topic_receive(const std::string&amp; topic_name, std::vector&lt;char&gt;&amp; message) {\n    if (topic_name == \"illixr_control\") {\n        std::string message_str(message.begin(), message.end());\n        // check if message starts with \"create_topic\"\n        if (message_str.find(\"create_topic\") == 0) {\n            size_t d_pos = message_str.find(delimiter_);\n            assert(d_pos != std::string::npos);\n            std::string l_topic_name  = message_str.substr(12, d_pos - 12);\n            std::string serialization = message_str.substr(d_pos + 1);\n            networked_topics_.push_back(l_topic_name);\n            network::topic_config config;\n            if (serialization == \"BOOST\") {\n                config.serialization_method = network::topic_config::SerializationMethod::BOOST;\n            } else {\n                config.serialization_method = network::topic_config::SerializationMethod::PROTOBUF;\n            }\n            networked_topics_configs_[l_topic_name] = config;\n            std::cout &lt;&lt; \"Received create_topic for \" &lt;&lt; l_topic_name &lt;&lt; std::endl;\n        }\n        return;\n    }\n\n    if (!switchboard_-&gt;topic_exists(topic_name)) {\n        return;\n    }\n\n    switchboard_-&gt;get_topic(topic_name).deserialize_and_put(message, networked_topics_configs_[topic_name]);\n}\n\nvoid tcp_network_backend::stop() {\n    running_ = false;\n    delete peer_socket_;\n}\n\nvoid tcp_network_backend::send_to_peer(const std::string&amp; topic_name, std::string&amp;&amp; message) {\n    // packet are in the format\n    // total_length:4bytes|topic_name_length:4bytes|topic_name|message\n    uint32_t    total_length = 8 + topic_name.size() + message.size();\n    std::string packet;\n    packet.append(reinterpret_cast&lt;char*&gt;(&amp;total_length), 4);\n    uint32_t topic_name_length = topic_name.size();\n    packet.append(reinterpret_cast&lt;char*&gt;(&amp;topic_name_length), 4);\n    packet.append(topic_name);\n    packet.append(message.begin(), message.end());\n    peer_socket_-&gt;write_data(packet);\n}\n\nextern \"C\" plugin* this_plugin_factory(phonebook* pb) {\n    auto plugin_ptr = std::make_shared&lt;tcp_network_backend&gt;(\"tcp_network_backend\", pb);\n    pb-&gt;register_impl&lt;network::network_backend&gt;(plugin_ptr);\n    auto* obj = plugin_ptr.get();\n    return obj;\n}\n</code></pre>"},{"location":"api/plugins_2tcp__network__backend_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; tcp_network_backend &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/network/network_backend.hpp\"</code></li> <li><code>#include \"illixr/network/tcpsocket.hpp\"</code></li> <li><code>#include \"illixr/network/topic_config.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> </ul>"},{"location":"api/plugins_2tcp__network__backend_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2tcp__network__backend_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class tcp_network_backend <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/tcp_network_backend/plugin.hpp</code></p>"},{"location":"api/plugins_2tcp__network__backend_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; tcp_network_backend &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/network/network_backend.hpp\"\n#include \"illixr/network/tcpsocket.hpp\"\n#include \"illixr/network/topic_config.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/switchboard.hpp\"\n\nnamespace ILLIXR {\n\nclass tcp_network_backend\n    : public plugin\n    , public network::network_backend {\npublic:\n    explicit tcp_network_backend(const std::string&amp; name_, phonebook* pb_);\n    void start_client();\n    void start_server();\n    void read_loop(network::TCPSocket* socket);\n    void topic_create(std::string topic_name, network::topic_config&amp; config) override;\n    bool is_topic_networked(std::string topic_name) override;\n    void topic_send(std::string topic_name, std::string&amp;&amp; message) override;\n    void topic_receive(const std::string&amp; topic_name, std::vector&lt;char&gt;&amp; message);\n    void stop() override;\n    bool client;\n\nprivate:\n    void send_to_peer(const std::string&amp; topic_name, std::string&amp;&amp; message);\n\n    std::shared_ptr&lt;switchboard&gt; switchboard_;\n    std::atomic&lt;bool&gt;            running_     = true;\n    std::atomic&lt;bool&gt;            ready_       = false;\n    network::TCPSocket*          peer_socket_ = nullptr;\n\n    std::string server_ip_;\n    int         server_port_;\n    std::string client_ip_;\n    int         client_port_;\n    int         is_client_;\n\n    std::vector&lt;std::string&gt;                               networked_topics_;\n    std::unordered_map&lt;std::string, network::topic_config&gt; networked_topics_configs_;\n\n    // To delimit the topic_name and the serialization method when creating a topic\n    std::string delimiter_ = \":\";\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2timewarp__gl_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name if (NOT DEFINED BUILDING_ILLIXR)  set (PLUGIN_SOURCE \"plugin.cpp\")"},{"location":"api/plugins_2timewarp__gl_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2timewarp__gl_2CMakeLists_8txt/#function-if","title":"function if","text":"<pre><code>if (\n    NOT DEFINED BUILDING_ILLIXR\n) \n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_SOURCE \"plugin.cpp\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/CMakeLists.txt</code></p>"},{"location":"api/plugins_2timewarp__gl_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the timewarp_gl ILLIXR plugin\nif(NOT DEFINED BUILDING_ILLIXR)\n    message(ERROR \"The timewarp_gl plugin cannot be built outside of the main ILLIXR build\")\nendif()\n\nif(NOT PLUGIN_NAME)\n    set(PLUGIN_NAME \"plugin.timewarp_gl${ILLIXR_BUILD_SUFFIX}\")\n    set(PLUGIN_SOURCE \"plugin.cpp\")\n    set(TW_PREFIX \"\")\nendif()\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED\n            ${PLUGIN_SOURCE}\n            ${TW_PREFIX}plugin.hpp\n            ${TW_PREFIX}shaders/timewarp_shader.hpp\n            $&lt;TARGET_OBJECTS:illixr_hmd_gl&gt;\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/frame.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/error_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/extended_window.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/math_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/shader_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n)\n\nif(TW_PLUGIN_DEFINITIONS)\n    target_compile_definitions(${PLUGIN_NAME} PRIVATE ${TW_PLUGIN_DEFINITIONS})\n    target_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/..)\nendif()\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS} ${Vulkan_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} spdlog::spdlog ${Vulkan_LIBRARY})\nif(Vulkan_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${Vulkan_DEP_STR})\nendif()\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/README.md</code></p>"},{"location":"api/plugins_2timewarp__gl_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># timewarp_gl\n\n## Summary\n\n`timewarp_gl` is an OpenGL-based asynchronous rotational reprojection plugin intended for use in the ILLIXR\narchitecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only\nrotation).\n\n## Switchboard connection\n\n`timewarp_gl` subscribes to and publishes to several Switchboard plugs and Phonebook resources.\n\n- The plugin grabs the GL context from Phonebook. This is necessary to share the eyebuffers with the rendering\n  application (or [`gldemo`][P10]). As this is an OpenGL-based reprojection plugin, it relies on [_OpenGL_][G10]\n  resources for the eyebuffers.\n- `timewarp_gl` subscribes to the most recent pose published by the system. Currently, as our pose-prediction system is\n  still under development, this is not technically accurate; the final, intended functionality is that the timewarp\n  plugin will sample a pose prediction algorithm through an RPC-like mechanism. As we complete our work on our pose\n  prediction system, this plugin will be modified to use this mechanism.\n- `timewarp_gl` also subscribes to the most recent frame published by the system. This frame data also includes the pose\n  that was used to render the frame; this is how the timewarp algorithm calculates the \"diff\" to be used to reproject\n  the frame.\n\n## Environment Variables\n\n**TIMEWARP_GL_LOG_LEVEL**: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"\ncritical\", or \"off\"\n\n**ILLIXR_TIMEWARP_DISABLE**: whether to disable warping, values can be \"True\" or \"False\" (default)\n\n**ILLIXR_OFFLOAD_ENABLE**: whether to enable offloading, values can be \"True\" or \"False\" (default)\n\n## Notes\n\nThe rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the\nlate Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his\ncodebase [here][E10].\n\n## Known Issues\n\nAs noted above, this plugin currently samples `slow_pose`. This will be changed to sample a `fast_pose` topic through an\nRPC mechanism. In addition, JMP Van Waveren's algorithm includes a method for warping between two reprojection matrices\nbased on the actual progress of the display controller's \"scanline\"; this is simply commented out in our code, but can\nbe re-enabled when our pose prediction system comes online.\n\n## Contributions\n\nContributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our\nexisting internal backlog.\n\n\n[//]: # (- glossary -)\n\n[G10]: ../glossary.md#opengl\n\n\n[//]: # (- plugins -)\n\n[P10]:  ../illixr_plugins.md#gldemo\n\n\n[//]: # (- external -)\n\n[E10]:  https://github.com/KhronosGroup/Vulkan-Samples-Deprecated/tree/master/samples/apps/atw\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2monado_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2timewarp__gl_2monado_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name get_external_for_plugin (Monado_vk)"},{"location":"api/plugins_2timewarp__gl_2monado_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2timewarp__gl_2monado_2CMakeLists_8txt/#function-get_external_for_plugin","title":"function get_external_for_plugin","text":"<pre><code>get_external_for_plugin (\n    Monado_vk\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/monado/CMakeLists.txt</code></p>"},{"location":"api/plugins_2timewarp__gl_2monado_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>get_external_for_plugin(Monado_vk)\nfile(COPY_FILE ${CMAKE_SOURCE_DIR}/plugins/timewarp_gl/plugin.cpp ${CMAKE_BINARY_DIR}/plugins/timewarp_gl/plugin_m.cpp)\nset(PLUGIN_NAME \"plugin.timewarp_gl.monado${ILLIXR_BUILD_SUFFIX}\")\nset(TW_PLUGIN_DEFINITIONS \"MONADO_REQUIRED\")\nset(PLUGIN_SOURCE \"${CMAKE_BINARY_DIR}/plugins/timewarp_gl/plugin_m.cpp\")\nset(TW_PREFIX \"../\")\n\ninclude(../CMakeLists.txt)\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; timewarp_gl &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/math_util.hpp\"</code></li> <li><code>#include \"illixr/shader_util.hpp\"</code></li> <li><code>#include \"shaders/timewarp_shader.hpp\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#public-types","title":"Public Types","text":"Type Name typedef void(* glXSwapIntervalEXTProc"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name const record_header mtp_record   = <code>/* multi line expression */</code> const record_header timewarp_gpu_record   = <code>/* multi line expression */</code>"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#macros","title":"Macros","text":"Type Name define GL_GLEXT_PROTOTYPES"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#typedef-glxswapintervalextproc","title":"typedef glXSwapIntervalEXTProc","text":"<pre><code>typedef void(* glXSwapIntervalEXTProc) (Display *display_, GLXDrawable drawable, int interval);\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#variable-mtp_record","title":"variable mtp_record","text":"<pre><code>const record_header mtp_record;\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#variable-timewarp_gpu_record","title":"variable timewarp_gpu_record","text":"<pre><code>const record_header timewarp_gpu_record;\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp/#define-gl_glext_prototypes","title":"define GL_GLEXT_PROTOTYPES","text":"<pre><code>#define GL_GLEXT_PROTOTYPES \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/plugin.cpp</code></p>"},{"location":"api/plugins_2timewarp__gl_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; timewarp_gl &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#define GL_GLEXT_PROTOTYPES\n// clang-format off\n#include &lt;GL/glew.h&gt; // GLEW has to be loaded before other GL libraries\n#include &lt;GL/glx.h&gt;\n// clang-format on\n\n#include \"plugin.hpp\"\n\n#include \"illixr/error_util.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/math_util.hpp\"\n#include \"illixr/shader_util.hpp\"\n#include \"shaders/timewarp_shader.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\ntypedef void (*glXSwapIntervalEXTProc)(Display* display_, GLXDrawable drawable, int interval);\n\nconst record_header timewarp_gpu_record{\"timewarp_gpu\",\n                                        {\n                                            {\"iteration_no\", typeid(std::size_t)},\n                                            {\"wall_time_start\", typeid(time_point)},\n                                            {\"wall_time_stop\", typeid(time_point)},\n                                            {\"gpu_time_duration\", typeid(std::chrono::nanoseconds)},\n                                        }};\n\nconst record_header mtp_record{\"mtp_record\",\n                               {\n                                   {\"iteration_no\", typeid(std::size_t)},\n                                   {\"vsync\", typeid(time_point)},\n                                   {\"imu_to_display\", typeid(std::chrono::nanoseconds)},\n                                   {\"predict_to_display\", typeid(std::chrono::nanoseconds)},\n                                   {\"render_to_display\", typeid(std::chrono::nanoseconds)},\n                               }};\n\ntimewarp_gl::timewarp_gl(const std::string&amp; name, phonebook* pb)\n    : timewarp_type{name, pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , pose_prediction_{phonebook_-&gt;lookup_impl&lt;pose_prediction&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n#ifndef ENABLE_MONADO\n    , eyebuffer_{switchboard_-&gt;get_reader&lt;rendered_frame&gt;(\"eyebuffer\")}\n    , vsync_estimate_{switchboard_-&gt;get_writer&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\")}\n    , offload_data_{switchboard_-&gt;get_writer&lt;texture_pose&gt;(\"texture_pose\")}\n    , mtp_logger_{record_logger_}\n    // TODO: Use #198 to configure this.\n    // This is useful for experiments which seek to evaluate the end-effect of timewarp vs no-timewarp.\n    // Timewarp poses a \"second channel\" by which pose data can correct the video stream,\n    // which results in a \"multipath\" between the pose and the video stream.\n    // In production systems, this is certainly a good thing, but it makes the system harder to analyze.\n    , disable_warp_{switchboard_-&gt;get_env_bool(\"ILLIXR_TIMEWARP_DISABLE\", \"False\")}\n    , enable_offload_{switchboard_-&gt;get_env_bool(\"ILLIXR_OFFLOAD_ENABLE\", \"False\")}\n#else\n    , signal_quad_{switchboard_-&gt;get_writer&lt;signal_to_quad&gt;(\"signal_quad\")}\n#endif\n    , timewarp_gpu_logger_{record_logger_}\n    , hologram_{switchboard_-&gt;get_writer&lt;hologram_input&gt;(\"hologram_in\")} {\n    spdlogger(switchboard_-&gt;get_env_char(\"TIMEWARP_GL_LOG_LEVEL\"));\n#ifndef ENABLE_MONADO\n    const std::shared_ptr&lt;xlib_gl_extended_window&gt; x_win = phonebook_-&gt;lookup_impl&lt;xlib_gl_extended_window&gt;();\n    display_                                             = x_win-&gt;display_;\n    root_window_                                         = x_win-&gt;window_;\n    context_                                             = x_win-&gt;context_;\n#else\n    // If we use Monado, timewarp_gl must create its own GL context because the extended window isn't used\n    std::cout &lt;&lt; \"Timewarp creating GL Context\" &lt;&lt; std::endl;\n    GLint        attr[] = {GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None};\n    XVisualInfo* vi;\n    /* open display */\n    if (!(display_ = XOpenDisplay(NULL))) {\n        fprintf(stderr, \"cannot connect to X server\\n\\n\");\n        exit(1);\n    }\n\n    /* get root_window_ window */\n    root_window_ = DefaultRootWindow(display_);\n\n    /* get visual matching attr */\n    if (!(vi = glXChooseVisual(display_, 0, attr))) {\n        fprintf(stderr, \"no appropriate visual found\\n\\n\");\n        exit(1);\n    }\n\n    /* create a context using the root_window_ window */\n    if (!(context_ = glXCreateContext(display_, vi, NULL, GL_TRUE))) {\n        fprintf(stderr, \"failed to create context\\n\\n\");\n        exit(1);\n    }\n#endif\n    client_backend_      = graphics_api::TBD;\n    rendering_ready_     = false;\n    image_handles_ready_ = false;\n\n    switchboard_-&gt;schedule&lt;image_handle&gt;(id_, \"image_handle\", [this](switchboard::ptr&lt;const image_handle&gt; handle, std::size_t) {\n    // only 2 swapchains (for the left and right eye) are supported for now.\n#ifdef ENABLE_MONADO\n        static bool left_output_ready = false, right_output_ready = false;\n#else\n        static bool left_output_ready = true, right_output_ready = true;\n#endif\n\n        switch (handle-&gt;usage) {\n        case swapchain_usage::LEFT_SWAPCHAIN: {\n            this-&gt;eye_image_handles_[0].push_back(*handle);\n            this-&gt;eye_swapchains_size_[0] = handle-&gt;num_images;\n            break;\n        }\n        case swapchain_usage::RIGHT_SWAPCHAIN: {\n            this-&gt;eye_image_handles_[1].push_back(*handle);\n            this-&gt;eye_swapchains_size_[1] = handle-&gt;num_images;\n            break;\n        }\n#ifdef ENABLE_MONADO\n        case swapchain_usage::LEFT_RENDER: {\n            this-&gt;eye_output_handles_[0] = *handle;\n            left_output_ready            = true;\n            break;\n        }\n        case swapchain_usage::RIGHT_RENDER: {\n            this-&gt;eye_output_handles_[1] = *handle;\n            right_output_ready           = true;\n            break;\n        }\n#endif\n        default: {\n            spdlog::get(name_)-&gt;warn(\"Invalid swapchain usage provided\");\n            break;\n        }\n        }\n\n        if (client_backend_ == graphics_api::TBD) {\n            client_backend_ = handle-&gt;type;\n        } else {\n            assert(client_backend_ == handle-&gt;type);\n        }\n\n        if (this-&gt;eye_image_handles_[0].size() == this-&gt;eye_swapchains_size_[0] &amp;&amp;\n            this-&gt;eye_image_handles_[1].size() == this-&gt;eye_swapchains_size_[1] &amp;&amp; left_output_ready &amp;&amp; right_output_ready) {\n            image_handles_ready_ = true;\n        }\n    });\n\n    this-&gt;_setup();\n\n#ifdef ENABLE_MONADO\n    switchboard_-&gt;schedule&lt;rendered_frame&gt;(id_, \"eyebuffer\", [this](switchboard::ptr&lt;const rendered_frame&gt; datum, std::size_t) {\n        this-&gt;warp(datum);\n    });\n#endif\n}\n\nGLubyte* timewarp_gl::read_texture_image() {\n    const unsigned mem_size = display_params::width_pixels * display_params::height_pixels * 3;\n    auto*          pixels   = new GLubyte[mem_size];\n\n    // Start timer\n    time_point start_get_tex_time = clock_-&gt;now();\n\n    // Read the contents of the default framebuffer to the PBO\n    glBindBuffer(GL_PIXEL_PACK_BUFFER, PBO_buffer_);\n    glReadPixels(0, 0, display_params::width_pixels, display_params::height_pixels, GL_RGB, GL_UNSIGNED_BYTE, pixels);\n\n    glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);\n\n    // Record the image collection time\n    offload_duration_ = clock_-&gt;now() - start_get_tex_time;\n\n#ifndef NDEBUG\n    double time = duration_to_double&lt;std::milli&gt;(offload_duration_);\n    spdlog::get(name_)-&gt;debug(\"Texture image collecting time: {} ms\", time);\n#endif\n\n    return pixels;\n}\n\nGLuint timewarp_gl::convert_vk_format_to_GL(int64_t vk_format) {\n    switch (vk_format) {\n    case VK_FORMAT_R8G8B8A8_UNORM:\n        return GL_RGBA8;\n    case VK_FORMAT_B8G8R8A8_SRGB:\n    case VK_FORMAT_R8G8B8A8_SRGB:\n        return GL_SRGB8_ALPHA8;\n    default:\n        return 0;\n    }\n}\n\nvoid timewarp_gl::import_vulkan_image(const vk_image_handle&amp; vk_handle, swapchain_usage usage) {\n    [[maybe_unused]] const bool gl_result = static_cast&lt;bool&gt;(glXMakeCurrent(display_, root_window_, context_));\n    assert(gl_result &amp;&amp; \"glXMakeCurrent should not fail\");\n    assert(GLEW_EXT_memory_object_fd &amp;&amp; \"[timewarp_gl] Missing object memory extensions for Vulkan-GL interop\");\n\n    // first get the memory handle of the vulkan object\n    GLuint memory_handle;\n    GLint  dedicated = GL_TRUE;\n    glCreateMemoryObjectsEXT(1, &amp;memory_handle);\n    glMemoryObjectParameterivEXT(memory_handle, GL_DEDICATED_MEMORY_OBJECT_EXT, &amp;dedicated);\n    glImportMemoryFdEXT(memory_handle, vk_handle.allocation_size, GL_HANDLE_TYPE_OPAQUE_FD_EXT, vk_handle.file_descriptor);\n\n    // then use the imported memory as the opengl texture.\n    // since we're writing to an intermediate texture that's the same memory format as Monado's layer renderer,\n    // there's no need to reformat anything.\n    GLuint format = convert_vk_format_to_GL(vk_handle.format);\n    assert(format != 0 &amp;&amp; \"Given Vulkan format not handled!\");\n    GLuint image_handle;\n    glGenTextures(1, &amp;image_handle);\n    glBindTexture(GL_TEXTURE_2D, image_handle);\n    glTextureStorageMem2DEXT(image_handle, 1, format, static_cast&lt;GLsizei&gt;(vk_handle.width),\n                             static_cast&lt;GLsizei&gt;(vk_handle.height), memory_handle, 0);\n\n    float color[4] = {0.0f, 0.0f, 0.0f, 1.0f};\n    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, color);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);\n\n    switch (usage) {\n    case swapchain_usage::LEFT_SWAPCHAIN: {\n        eye_swapchains_[0].push_back(image_handle);\n        break;\n    }\n    case swapchain_usage::RIGHT_SWAPCHAIN: {\n        eye_swapchains_[1].push_back(image_handle);\n        break;\n    }\n    case swapchain_usage::LEFT_RENDER: {\n        eye_output_textures_[0] = image_handle;\n        break;\n    }\n    case swapchain_usage::RIGHT_RENDER: {\n        eye_output_textures_[1] = image_handle;\n        break;\n    }\n    default: {\n        assert(false &amp;&amp; \"Invalid swapchain usage\");\n        // break;\n    }\n    }\n}\n\nvoid timewarp_gl::build_timewarp(HMD::hmd_info_t&amp; hmd_info) {\n    // Calculate the number of vertices+indices in the distortion mesh.\n    num_distortion_vertices_ = (hmd_info.eye_tiles_high + 1) * (hmd_info.eye_tiles_wide + 1);\n    num_distortion_indices_  = hmd_info.eye_tiles_high * hmd_info.eye_tiles_wide * 6;\n\n    // Allocate memory for the elements/indices array.\n    distortion_indices_.resize(num_distortion_indices_);\n\n    // This is just a simple grid/plane index array, nothing fancy.\n    // Same for both eye distortions, too!\n    for (int y = 0; y &lt; hmd_info.eye_tiles_high; y++) {\n        for (int x = 0; x &lt; hmd_info.eye_tiles_wide; x++) {\n            const int offset = (y * hmd_info.eye_tiles_wide + x) * 6;\n\n            // How are the indices figured out?\n            distortion_indices_[offset + 0] = (GLuint) ((y + 0) * (hmd_info.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 1] = (GLuint) ((y + 1) * (hmd_info.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 2] = (GLuint) ((y + 0) * (hmd_info.eye_tiles_wide + 1) + (x + 1));\n\n            distortion_indices_[offset + 3] = (GLuint) ((y + 0) * (hmd_info.eye_tiles_wide + 1) + (x + 1));\n            distortion_indices_[offset + 4] = (GLuint) ((y + 1) * (hmd_info.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 5] = (GLuint) ((y + 1) * (hmd_info.eye_tiles_wide + 1) + (x + 1));\n        }\n    }\n\n    // There are `num_distortion_vertices_` distortion coordinates for each color channel (3) of each eye (2).\n    // These are NOT the coordinates of the distorted vertices. They are *coefficients* that will be used to\n    // offset the UV coordinates of the distortion mesh.\n    std::array&lt;std::array&lt;std::vector&lt;HMD::mesh_coord2d_t&gt;, HMD::NUM_COLOR_CHANNELS&gt;, HMD::NUM_EYES&gt; distort_coords;\n    for (auto&amp; eye_coords : distort_coords) {\n        for (auto&amp; channel_coords : eye_coords) {\n            channel_coords.resize(num_distortion_vertices_);\n        }\n    }\n    HMD::build_distortion_meshes(distort_coords, hmd_info);\n\n    // Allocate memory for position and UV CPU buffers.\n    const std::size_t num_elems_pos_uv = HMD::NUM_EYES * num_distortion_vertices_;\n    distortion_positions_.resize(num_elems_pos_uv);\n    distortion_uv0_.resize(num_elems_pos_uv);\n    distortion_uv1_.resize(num_elems_pos_uv);\n    distortion_uv2_.resize(num_elems_pos_uv);\n\n    for (int eye = 0; eye &lt; HMD::NUM_EYES; eye++) {\n        for (int y = 0; y &lt;= hmd_info.eye_tiles_high; y++) {\n            for (int x = 0; x &lt;= hmd_info.eye_tiles_wide; x++) {\n                const int index = y * (hmd_info.eye_tiles_wide + 1) + x;\n\n                // Set the physical distortion mesh coordinates. These are rectangular/grid-like, not distorted.\n                // The distortion is handled by the UVs, not the actual mesh coordinates!\n                distortion_positions_[eye * num_distortion_vertices_ + index].x =\n                    (-1.0f + 2.0f * (static_cast&lt;float&gt;(x) / static_cast&lt;float&gt;(hmd_info.eye_tiles_wide)));\n                distortion_positions_[eye * num_distortion_vertices_ + index].y =\n                    (-1.0f +\n                     2.0f *\n                         ((static_cast&lt;float&gt;(hmd_info.eye_tiles_high) - static_cast&lt;float&gt;(y)) /\n                          static_cast&lt;float&gt;(hmd_info.eye_tiles_high)) *\n                         (static_cast&lt;float&gt;(hmd_info.eye_tiles_high * hmd_info.tile_pixels_high) /\n                          static_cast&lt;float&gt;(hmd_info.display_pixels_high)));\n                distortion_positions_[eye * num_distortion_vertices_ + index].z = 0.0f;\n\n                // Use the previously-calculated distort_coords to set the UVs on the distortion mesh\n                distortion_uv0_[eye * num_distortion_vertices_ + index].u = distort_coords[eye][0][index].x;\n                distortion_uv0_[eye * num_distortion_vertices_ + index].v = distort_coords[eye][0][index].y;\n                distortion_uv1_[eye * num_distortion_vertices_ + index].u = distort_coords[eye][1][index].x;\n                distortion_uv1_[eye * num_distortion_vertices_ + index].v = distort_coords[eye][1][index].y;\n                distortion_uv2_[eye * num_distortion_vertices_ + index].u = distort_coords[eye][2][index].x;\n                distortion_uv2_[eye * num_distortion_vertices_ + index].v = distort_coords[eye][2][index].y;\n            }\n        }\n    }\n\n    // Construct perspective projection matrix\n    math_util::projection_fov(&amp;basic_projection_, display_params::fov_x / 2.0f, display_params::fov_x / 2.0f,\n                              display_params::fov_y / 2.0f, display_params::fov_y / 2.0f, rendering_params::near_z,\n                              rendering_params::far_z);\n}\n\n/* Calculate timewarp transform from projection matrix, view matrix, etc */\nvoid timewarp_gl::calculate_time_warp_transform(Eigen::Matrix4f&amp; transform, const Eigen::Matrix4f&amp; render_projection_matrix,\n                                                const Eigen::Matrix4f&amp; render_view_matrix,\n                                                const Eigen::Matrix4f&amp; new_view_matrix) {\n    // Eigen stores matrices internally in column-major order.\n    // However, the (i,j) accessors are row-major (i.e, the first argument\n    // is which row, and the second argument is which column.)\n    Eigen::Matrix4f tex_coord_projection;\n    tex_coord_projection &lt;&lt; 0.5f * render_projection_matrix(0, 0), 0.0f, 0.5f * render_projection_matrix(0, 2) - 0.5f, 0.0f,\n        0.0f, 0.5f * render_projection_matrix(1, 1), 0.5f * render_projection_matrix(1, 2) - 0.5f, 0.0f, 0.0f, 0.0f, -1.0f,\n        0.0f, 0.0f, 0.0f, 0.0f, 1.0f;\n\n    // Calculate the delta between the view matrix used for rendering and\n    // a more recent or predicted view matrix based on new sensor input.\n    Eigen::Matrix4f inverse_render_view_matrix = render_view_matrix.inverse();\n\n    Eigen::Matrix4f delta_view_matrix = inverse_render_view_matrix * new_view_matrix;\n\n    delta_view_matrix(0, 3) = 0.0f;\n    delta_view_matrix(1, 3) = 0.0f;\n    delta_view_matrix(2, 3) = 0.0f;\n\n    // Accumulate the transforms.\n    transform = tex_coord_projection * delta_view_matrix;\n}\n\n#ifndef ENABLE_MONADO\n// Get the estimated time of the next swap/next Vsync.\n// This is an estimate, used to wait until *just* before vsync.\n[[nodiscard]] time_point timewarp_gl::get_next_swap_time_estimate() const {\n    return time_last_swap_ + display_params::period;\n}\n\n// Get the estimated amount of time to put the CPU thread to sleep,\n// given a specified percentage of the total Vsync period to delay.\n[[maybe_unused]] [[nodiscard]] duration timewarp_gl::estimate_time_to_sleep(const double frame_percentage) const {\n    return std::chrono::duration_cast&lt;duration&gt;((get_next_swap_time_estimate() - clock_-&gt;now()) * frame_percentage);\n}\n#endif\n\nvoid timewarp_gl::_setup() {\n    // Generate reference HMD and physical body dimensions\n    HMD::get_default_hmd_info(display_params::width_pixels, display_params::height_pixels, display_params::width_meters,\n                              display_params::height_meters, display_params::lens_separation,\n                              display_params::meters_per_tan_angle, display_params::aberration, hmd_info_);\n\n    // Construct timewarp meshes and other data\n    build_timewarp(hmd_info_);\n\n    // includes setting swap interval\n    [[maybe_unused]] const bool gl_result_0 = static_cast&lt;bool&gt;(glXMakeCurrent(display_, root_window_, context_));\n    assert(gl_result_0 &amp;&amp; \"glXMakeCurrent should not fail\");\n\n    // set swap interval for 1\n    // TODO do we still need this if timewarp is not doing the presenting?\n    auto glx_swap_interval_ext = (glXSwapIntervalEXTProc) glXGetProcAddressARB((const GLubyte*) \"glx_swap_interval_ext\");\n    glx_swap_interval_ext(display_, root_window_, 1);\n\n    // Init and verify GLEW\n    glewExperimental      = GL_TRUE;\n    const GLenum glew_err = glewInit();\n    if (glew_err != GLEW_OK) {\n        spdlog::get(name_)-&gt;error(\"[timewarp_gl] GLEW Error: {}\", reinterpret_cast&lt;const char*&gt;(glewGetErrorString(glew_err)));\n        ILLIXR::abort(\"[timewarp_gl] Failed to initialize GLEW\");\n    }\n\n    glEnable(GL_DEBUG_OUTPUT);\n\n    glDebugMessageCallback(message_callback, nullptr);\n\n    // Create and bind global VAO object\n    glGenVertexArrays(1, &amp;tw_vao);\n    glBindVertexArray(tw_vao);\n\n#ifdef USE_ALT_EYE_FORMAT\n    timewarp_shader_program_ =\n        init_and_link(time_warp_chromatic_vertex_program_GLSL, time_warp_chromatic_fragment_program_GLSL_alternative);\n#else\n    timewarp_shader_program_ =\n        init_and_link(time_warp_chromatic_vertex_program_GLSL, time_warp_chromatic_fragment_program_GLSL);\n#endif\n    // Acquire attribute and uniform locations from the compiled and linked shader program\n    distortion_pos_attr_ = glGetAttribLocation(timewarp_shader_program_, \"vertexPosition\");\n    distortion_uv0_attr_ = glGetAttribLocation(timewarp_shader_program_, \"vertexUv0\");\n    distortion_uv1_attr_ = glGetAttribLocation(timewarp_shader_program_, \"vertexUv1\");\n    distortion_uv2_attr_ = glGetAttribLocation(timewarp_shader_program_, \"vertexUv2\");\n\n    tw_start_transform_uniform_ = glGetUniformLocation(timewarp_shader_program_, \"TimeWarpStartTransform\");\n    tw_end_transform_uniform_   = glGetUniformLocation(timewarp_shader_program_, \"TimeWarpEndTransform\");\n    tw_eye_index_uniform_       = glGetUniformLocation(timewarp_shader_program_, \"ArrayLayer\");\n\n    eye_sampler_0_ = glGetUniformLocation(timewarp_shader_program_, \"Texture[0]\");\n    eye_sampler_1_ = glGetUniformLocation(timewarp_shader_program_, \"Texture[1]\");\n\n    flip_y_uniform_ = glGetUniformLocation(timewarp_shader_program_, \"flipY\");\n\n    // Config distortion mesh position vbo\n    glGenBuffers(1, &amp;distortion_positions_vbo_);\n    glBindBuffer(GL_ARRAY_BUFFER, distortion_positions_vbo_);\n\n    const std::size_t num_elems_pos_uv = HMD::NUM_EYES * num_distortion_vertices_;\n\n    HMD::mesh_coord3d_t* const distortion_positions_data = distortion_positions_.data();\n    assert(distortion_positions_data != nullptr &amp;&amp; \"Timewarp allocation should not fail\");\n    glBufferData(GL_ARRAY_BUFFER, static_cast&lt;GLsizeiptr&gt;(num_elems_pos_uv * sizeof(HMD::mesh_coord3d_t)),\n                 distortion_positions_data, GL_STATIC_DRAW);\n\n    glVertexAttribPointer(distortion_pos_attr_, 3, GL_FLOAT, GL_FALSE, 0, nullptr);\n    // glEnableVertexAttribArray(distortion_pos_attr_);\n\n    // Config distortion uv0 vbo\n    glGenBuffers(1, &amp;distortion_uv0_vbo_);\n    glBindBuffer(GL_ARRAY_BUFFER, distortion_uv0_vbo_);\n\n    HMD::uv_coord_t* const distortion_uv0_data = distortion_uv0_.data();\n    assert(distortion_uv0_data != nullptr &amp;&amp; \"Timewarp allocation should not fail\");\n    glBufferData(GL_ARRAY_BUFFER, static_cast&lt;GLsizeiptr&gt;(num_elems_pos_uv * sizeof(HMD::uv_coord_t)), distortion_uv0_data,\n                 GL_STATIC_DRAW);\n\n    glVertexAttribPointer(distortion_uv0_attr_, 2, GL_FLOAT, GL_FALSE, 0, nullptr);\n    // glEnableVertexAttribArray(distortion_uv0_attr_);\n\n    // Config distortion uv1 vbo\n    glGenBuffers(1, &amp;distortion_uv1_vbo_);\n    glBindBuffer(GL_ARRAY_BUFFER, distortion_uv1_vbo_);\n\n    HMD::uv_coord_t* const distortion_uv1_data = distortion_uv1_.data();\n    assert(distortion_uv1_data != nullptr &amp;&amp; \"Timewarp allocation should not fail\");\n    glBufferData(GL_ARRAY_BUFFER, static_cast&lt;GLsizeiptr&gt;(num_elems_pos_uv * sizeof(HMD::uv_coord_t)), distortion_uv1_data,\n                 GL_STATIC_DRAW);\n\n    glVertexAttribPointer(distortion_uv1_attr_, 2, GL_FLOAT, GL_FALSE, 0, nullptr);\n    // glEnableVertexAttribArray(distortion_uv1_attr_);\n\n    // Config distortion uv2 vbo\n    glGenBuffers(1, &amp;distortion_uv2_vbo_);\n    glBindBuffer(GL_ARRAY_BUFFER, distortion_uv2_vbo_);\n\n    HMD::uv_coord_t* const distortion_uv2_data = distortion_uv2_.data();\n    assert(distortion_uv2_data != nullptr &amp;&amp; \"Timewarp allocation should not fail\");\n    glBufferData(GL_ARRAY_BUFFER, static_cast&lt;GLsizeiptr&gt;(num_elems_pos_uv * sizeof(HMD::uv_coord_t)), distortion_uv2_data,\n                 GL_STATIC_DRAW);\n\n    glVertexAttribPointer(distortion_uv2_attr_, 2, GL_FLOAT, GL_FALSE, 0, nullptr);\n    // glEnableVertexAttribArray(distortion_uv2_attr_);\n\n    // Config distortion mesh indices vbo\n    glGenBuffers(1, &amp;distortion_indices_vbo_);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, distortion_indices_vbo_);\n\n    GLuint* const distortion_indices_data = distortion_indices_.data();\n    assert(distortion_indices_data != nullptr &amp;&amp; \"Timewarp allocation should not fail\");\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, static_cast&lt;GLsizeiptr&gt;(num_distortion_indices_ * sizeof(GLuint)),\n                 distortion_indices_data, GL_STATIC_DRAW);\n\n    if (enable_offload_) {\n        // Config PBO for texture image collection\n        glGenBuffers(1, &amp;PBO_buffer_);\n        glBindBuffer(GL_PIXEL_PACK_BUFFER, PBO_buffer_);\n        glBufferData(GL_PIXEL_PACK_BUFFER, display_params::width_pixels * display_params::height_pixels * 3, nullptr,\n                     GL_STREAM_DRAW);\n    }\n\n    [[maybe_unused]] const bool gl_result_1 = static_cast&lt;bool&gt;(glXMakeCurrent(display_, None, nullptr));\n    assert(gl_result_1 &amp;&amp; \"glXMakeCurrent should not fail\");\n}\n\nvoid timewarp_gl::_prepare_rendering() {\n    [[maybe_unused]] const bool gl_result = static_cast&lt;bool&gt;(glXMakeCurrent(display_, root_window_, context_));\n    assert(gl_result &amp;&amp; \"glXMakeCurrent should not fail\");\n\n    if (!rendering_ready_) {\n        assert(image_handles_ready_);\n        for (int eye = 0; eye &lt; 2; eye++) {\n            uint32_t num_images = eye_image_handles_[eye][0].num_images;\n            for (uint32_t image_index = 0; image_index &lt; num_images; image_index++) {\n                image_handle image = eye_image_handles_[eye][image_index];\n                if (client_backend_ == graphics_api::OPENGL) {\n                    eye_swapchains_[eye].push_back(image.gl_handle);\n                } else {\n                    import_vulkan_image(image.vk_handle, image.usage);\n                }\n            }\n        }\n\n        // If we're using Monado, we need to import the eye output textures to render to.\n        // Otherwise, with native, we can directly create the textures.\n        for (int eye = 0; eye &lt; 2; eye++) {\n#ifdef ENABLE_MONADO\n            image_handle image = eye_output_handles_[eye];\n            import_vulkan_image(image.vk_handle, image.usage);\n#else\n            GLuint eye_output_texture;\n            glGenTextures(1, &amp;eye_output_texture);\n            eye_output_textures_[eye] = eye_output_texture;\n\n            glBindTexture(GL_TEXTURE_2D, eye_output_texture);\n            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, display_params::width_pixels * 0.5f, display_params::height_pixels, 0,\n                         GL_RGB, GL_FLOAT, NULL);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n#endif\n\n            // Once the eye output textures are created, we bind them to the framebuffer\n            GLuint framebuffer;\n            glGenFramebuffers(1, &amp;framebuffer);\n            eye_framebuffers_[eye] = framebuffer;\n\n            glBindFramebuffer(GL_FRAMEBUFFER, eye_framebuffers_[eye]);\n            glBindTexture(GL_TEXTURE_2D, eye_output_textures_[eye]);\n            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, eye_output_textures_[eye], 0);\n\n            uint32_t attachment = GL_COLOR_ATTACHMENT0;\n            glDrawBuffers(1, &amp;attachment);\n        }\n\n        rendering_ready_ = true;\n    }\n}\n\nvoid timewarp_gl::warp(const switchboard::ptr&lt;const rendered_frame&gt;&amp; most_recent_frame) {\n    if (!rendering_ready_)\n        _prepare_rendering();\n    assert(this-&gt;image_handles_ready_ &amp;&amp; rendering_ready_);\n    // Use the timewarp program\n    glUseProgram(timewarp_shader_program_);\n\n    // Generate \"starting\" view matrix, from the pose sampled at the time of rendering the frame\n    Eigen::Matrix4f view_matrix   = Eigen::Matrix4f::Identity();\n    view_matrix.block(0, 0, 3, 3) = most_recent_frame-&gt;render_pose.pose.orientation.toRotationMatrix();\n\n    // We simulate two asynchronous view matrices, one at the beginning of\n    // display refresh, and one at the end of display refresh. The\n    // distortion shader will leap between these two predictive view\n    // transformations as it renders across the horizontal view,\n    // compensating for display panel refresh delay (wow!)\n    Eigen::Matrix4f view_matrix_begin = Eigen::Matrix4f::Identity();\n    Eigen::Matrix4f view_matrix_end   = Eigen::Matrix4f::Identity();\n\n    const fast_pose_type latest_pose    = disable_warp_ ? most_recent_frame-&gt;render_pose : pose_prediction_-&gt;get_fast_pose();\n    view_matrix_begin.block(0, 0, 3, 3) = latest_pose.pose.orientation.toRotationMatrix();\n\n    // TODO: We set the \"end\" pose to the same as the beginning pose, but this really should be the pose for\n    // `display_period` later\n    view_matrix_end = view_matrix_begin;\n\n    // Calculate the timewarp transformation matrices. These are a product\n    // of the last-known-good view matrix and the predictive transforms.\n    Eigen::Matrix4f time_warp_start_transform4x4;\n    Eigen::Matrix4f time_warp_end_transform4x4;\n\n    // Calculate timewarp transforms using predictive view transforms\n    calculate_time_warp_transform(time_warp_start_transform4x4, basic_projection_, view_matrix, view_matrix_begin);\n    calculate_time_warp_transform(time_warp_end_transform4x4, basic_projection_, view_matrix, view_matrix_end);\n\n    glUniformMatrix4fv(static_cast&lt;GLint&gt;(tw_start_transform_uniform_), 1, GL_FALSE,\n                       (GLfloat*) (time_warp_start_transform4x4.data()));\n    glUniformMatrix4fv(static_cast&lt;GLint&gt;(tw_end_transform_uniform_), 1, GL_FALSE,\n                       (GLfloat*) (time_warp_end_transform4x4.data()));\n\n    // Flip the Y axis if the client is using a Vulkan backend\n    glUniform1i(static_cast&lt;GLint&gt;(flip_y_uniform_), false);\n\n    // Debugging aid, toggle switch for rendering in the fragment shader\n    glUniform1i(glGetUniformLocation(timewarp_shader_program_, \"ArrayIndex\"), 0);\n    glUniform1i(static_cast&lt;GLint&gt;(eye_sampler_0_), 0);\n\n    glBindVertexArray(tw_vao);\n\n    auto     gpu_start_wall_time = clock_-&gt;now();\n    GLuint   query               = 0;\n    GLuint64 elapsed_time        = 0;\n\n    glGenQueries(1, &amp;query);\n    glBeginQuery(GL_TIME_ELAPSED, query);\n\n    // Loop over each eye\n    for (int eye = 0; eye &lt; HMD::NUM_EYES; eye++) {\n        // Choose the appropriate texture to render to\n        glBindFramebuffer(GL_FRAMEBUFFER, eye_framebuffers_[eye]);\n        glViewport(0, 0, display_params::width_pixels * 0.5, display_params::height_pixels);\n        glClearColor(1.0, 1.0, 1.0, 1.0);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n        glDepthFunc(GL_LEQUAL);\n\n        [[maybe_unused]] const bool is_texture =\n            static_cast&lt;bool&gt;(glIsTexture(eye_swapchains_[eye][most_recent_frame-&gt;swapchain_indices[eye]]));\n        assert(is_texture &amp;&amp; \"The requested image is not a texture!\");\n        // std::cout &lt;&lt; \"Binding the texture\\n\";\n        glBindTexture(GL_TEXTURE_2D, eye_swapchains_[eye][most_recent_frame-&gt;swapchain_indices[eye]]);\n\n        // The distortion_positions_vbo_ GPU buffer already contains\n        // the distortion mesh for both eyes! They are contiguously\n        // laid out in GPU memory. Therefore, on each eye render,\n        // we set the attribute pointer to be offset by the full\n        // eye's distortion mesh size, rendering the correct eye mesh\n        // to that region of the screen. This prevents re-uploading\n        // GPU data for each eye.\n        glBindBuffer(GL_ARRAY_BUFFER, distortion_positions_vbo_);\n        glVertexAttribPointer(distortion_pos_attr_, 3, GL_FLOAT, GL_FALSE, 0,\n                              (void*) (eye * num_distortion_vertices_ * sizeof(HMD::mesh_coord3d_t)));\n        glEnableVertexAttribArray(distortion_pos_attr_);\n\n        // We do the exact same thing for the UV GPU memory.\n        glBindBuffer(GL_ARRAY_BUFFER, distortion_uv0_vbo_);\n        glVertexAttribPointer(distortion_uv0_attr_, 2, GL_FLOAT, GL_FALSE, 0,\n                              (void*) (eye * num_distortion_vertices_ * sizeof(HMD::mesh_coord2d_t)));\n        glEnableVertexAttribArray(distortion_uv0_attr_);\n\n        // We do the exact same thing for the UV GPU memory.\n        glBindBuffer(GL_ARRAY_BUFFER, distortion_uv1_vbo_);\n        glVertexAttribPointer(distortion_uv1_attr_, 2, GL_FLOAT, GL_FALSE, 0,\n                              (void*) (eye * num_distortion_vertices_ * sizeof(HMD::mesh_coord2d_t)));\n        glEnableVertexAttribArray(distortion_uv1_attr_);\n\n        // We do the exact same thing for the UV GPU memory.\n        glBindBuffer(GL_ARRAY_BUFFER, distortion_uv2_vbo_);\n        glVertexAttribPointer(distortion_uv2_attr_, 2, GL_FLOAT, GL_FALSE, 0,\n                              (void*) (eye * num_distortion_vertices_ * sizeof(HMD::mesh_coord2d_t)));\n        glEnableVertexAttribArray(distortion_uv2_attr_);\n\n        // Interestingly, the element index buffer is identical for both eyes, and is\n        // reused for both eyes. Therefore, glDrawElements can be immediately called,\n        // with the UV and position buffers correctly offset.\n        glDrawElements(GL_TRIANGLES, static_cast&lt;GLsizei&gt;(num_distortion_indices_), GL_UNSIGNED_INT, (void*) nullptr);\n    }\n\n    glFinish();\n    glEndQuery(GL_TIME_ELAPSED);\n\n#ifdef ENABLE_MONADO\n    // signal quad layer in Monado\n    signal_quad_.put(signal_quad_.allocate(++signal_quad_seq_));\n#else\n    // If we're not using Monado, we want to composite the left and right buffers into one\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n    glViewport(0, 0, display_params::width_pixels, display_params::height_pixels);\n\n    // Blit the left and right color buffers onto the default color buffer\n    glBindFramebuffer(GL_READ_FRAMEBUFFER, eye_framebuffers_[0]);\n    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);\n    glBlitFramebuffer(0, 0, display_params::width_pixels * 0.5, display_params::height_pixels, 0, 0,\n                      display_params::width_pixels * 0.5, display_params::height_pixels, GL_COLOR_BUFFER_BIT, GL_NEAREST);\n\n    glBindFramebuffer(GL_READ_FRAMEBUFFER, eye_framebuffers_[1]);\n    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);\n    glBlitFramebuffer(0, 0, display_params::width_pixels * 0.5, display_params::height_pixels,\n                      display_params::width_pixels * 0.5, 0, display_params::width_pixels, display_params::height_pixels,\n                      GL_COLOR_BUFFER_BIT, GL_NEAREST);\n\n    // Call swap buffers; when vsync is enabled, this will return to the\n    // CPU thread once the buffers have been successfully swapped.\n    [[maybe_unused]] time_point time_before_swap = clock_-&gt;now();\n    glXSwapBuffers(display_, root_window_);\n\n    // The swap time needs to be obtained and published as soon as possible\n    time_last_swap_                             = clock_-&gt;now();\n    [[maybe_unused]] time_point time_after_swap = time_last_swap_;\n\n    // Now that we have the most recent swap time, we can publish the new estimate.\n    vsync_estimate_.put(vsync_estimate_.allocate&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\n        switchboard::event_wrapper&lt;time_point&gt;(get_next_swap_time_estimate())));\n\n    std::chrono::nanoseconds imu_to_display     = time_last_swap_ - latest_pose.pose.sensor_time;\n    std::chrono::nanoseconds predict_to_display = time_last_swap_ - latest_pose.predict_computed_time;\n    std::chrono::nanoseconds render_to_display  = time_last_swap_ - most_recent_frame-&gt;render_time;\n\n    mtp_logger_.log(record{mtp_record,\n                           {\n                               {iteration_no},\n                               {time_last_swap_},\n                               {imu_to_display},\n                               {predict_to_display},\n                               {render_to_display},\n                           }});\n\n    #ifndef NDEBUG // Timewarp only has vsync estimates if we're running with native-gl\n\n    if (log_count_ &gt; LOG_PERIOD_) {\n        const double     time_swap         = duration_to_double&lt;std::milli&gt;(time_after_swap - time_before_swap);\n        const double     latency_mtd       = duration_to_double&lt;std::milli&gt;(imu_to_display);\n        const double     latency_ptd       = duration_to_double&lt;std::milli&gt;(predict_to_display);\n        const double     latency_rtd       = duration_to_double&lt;std::milli&gt;(render_to_display);\n        const time_point time_next_swap    = get_next_swap_time_estimate();\n        const double     timewarp_estimate = duration_to_double&lt;std::milli&gt;(time_next_swap - time_last_swap_);\n\n        spdlog::get(name_)-&gt;debug(\"Swap time: {} ms\", time_swap);\n        spdlog::get(name_)-&gt;debug(\"Motion-to-display latency: {} ms\", latency_mtd);\n        spdlog::get(name_)-&gt;debug(\"Prediction-to-display latency: {} ms\", latency_ptd);\n        spdlog::get(name_)-&gt;debug(\"Render-to-display latency: {} ms\", latency_rtd);\n        spdlog::get(name_)-&gt;debug(\"Next swap in: {} ms in the future\", timewarp_estimate);\n    }\n    #endif\n\n    // For now, it only makes sense to enable offloading in native mode\n    // because running timewarp with Monado will not produce a single texture.\n    if (enable_offload_) {\n        // Read texture image from texture buffer\n        GLubyte* image = read_texture_image();\n\n        // Publish image and pose\n        offload_data_.put(offload_data_.allocate&lt;texture_pose&gt;(\n            texture_pose{offload_duration_, image, time_last_swap_, latest_pose.pose.position, latest_pose.pose.orientation,\n                         most_recent_frame-&gt;render_pose.pose.orientation}));\n    }\n#endif\n\n    // retrieving the recorded elapsed time\n    // wait until the query result is available\n    int done = 0;\n    glGetQueryObjectiv(query, GL_QUERY_RESULT_AVAILABLE, &amp;done);\n\n    while (!done) {\n        std::this_thread::yield();\n        glGetQueryObjectiv(query, GL_QUERY_RESULT_AVAILABLE, &amp;done);\n    }\n\n    // get the query result\n    glGetQueryObjectui64v(query, GL_QUERY_RESULT, &amp;elapsed_time);\n\n    timewarp_gpu_logger_.log(record{timewarp_gpu_record,\n                                    {\n                                        {iteration_no},\n                                        {gpu_start_wall_time},\n                                        {clock_-&gt;now()},\n                                        {std::chrono::nanoseconds(elapsed_time)},\n                                    }});\n\n#ifdef ENABLE_MONADO\n    // Manually increment the iteration number if timewarp is running as a plugin\n    ++iteration_no;\n#endif\n\n    // Call Hologram\n    hologram_.put(hologram_.allocate&lt;hologram_input&gt;(hologram_input(++hologram_seq_)));\n\n#ifndef NDEBUG\n    if (log_count_ &gt; LOG_PERIOD_) {\n        log_count_ = 0;\n    } else {\n        log_count_++;\n    }\n#endif\n}\n\n#ifndef ENABLE_MONADO\nthreadloop::skip_option timewarp_gl::_p_should_skip() {\n    using namespace std::chrono_literals;\n    // Sleep for approximately 90% of the time until the next vsync.\n    // Scheduling granularity can't be assumed to be super accurate here,\n    // so don't push your luck (i.e. don't wait too long....) Tradeoff with\n    // MTP here. More you wait, closer to the display sync you sample the pose.\n    std::this_thread::sleep_for(estimate_time_to_sleep(DELAY_FRACTION));\n    if (image_handles_ready_.load() &amp;&amp; eyebuffer_.get_ro_nullable() != nullptr) {\n        return skip_option::run;\n    } else {\n        // Null means system is nothing has been pushed yet\n        // because not all components are initialized yet\n        return skip_option::skip_and_yield;\n    }\n}\n\nvoid timewarp_gl::_p_thread_setup() {\n    _setup();\n}\n\nvoid timewarp_gl::_p_one_iteration() {\n    switchboard::ptr&lt;const rendered_frame&gt; most_recent_frame = eyebuffer_.get_ro();\n    warp(most_recent_frame);\n}\n#endif\n\nPLUGIN_MAIN(timewarp_gl)\n</code></pre>"},{"location":"api/plugins_2timewarp__gl_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; timewarp_gl &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/frame.hpp\"</code></li> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/extended_window.hpp\"</code></li> <li><code>#include \"illixr/hmd.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> </ul>"},{"location":"api/plugins_2timewarp__gl_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2timewarp__gl_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class timewarp_gl"},{"location":"api/plugins_2timewarp__gl_2plugin_8hpp/#macros","title":"Macros","text":"Type Name define VULKAN_REQUIRED"},{"location":"api/plugins_2timewarp__gl_2plugin_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugins_2timewarp__gl_2plugin_8hpp/#define-vulkan_required","title":"define VULKAN_REQUIRED","text":"<pre><code>#define VULKAN_REQUIRED \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_gl/plugin.hpp</code></p>"},{"location":"api/plugins_2timewarp__gl_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; timewarp_gl &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#define VULKAN_REQUIRED\n\n#include \"illixr/data_format/frame.hpp\"\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/extended_window.hpp\"\n#include \"illixr/hmd.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nnamespace ILLIXR {\n\n#ifdef ENABLE_MONADO\ntypedef plugin timewarp_type;\n#else\ntypedef threadloop timewarp_type;\n#endif\n\nclass timewarp_gl : public timewarp_type {\npublic:\n    // Public constructor, create_component passes Switchboard handles (\"plugs\")\n    // to this constructor. In turn, the constructor fills in the private\n    // references to the switchboard plugs, so the component can read the\n    // data whenever it needs to.\n    timewarp_gl(const std::string&amp; name, phonebook* pb);\n    void _setup();\n    void _prepare_rendering();\n    void warp(const switchboard::ptr&lt;const data_format::rendered_frame&gt;&amp; most_recent_frame);\n#ifndef ENABLE_MONADO\n    skip_option _p_should_skip() override;\n    void        _p_thread_setup() override;\n    void        _p_one_iteration() override;\n#endif\n\nprivate:\n    GLubyte*      read_texture_image();\n    static GLuint convert_vk_format_to_GL(int64_t vk_format);\n    void          import_vulkan_image(const data_format::vk_image_handle&amp; vk_handle, data_format::swapchain_usage usage);\n    void          build_timewarp(HMD::hmd_info_t&amp; hmd_info);\n    static void   calculate_time_warp_transform(Eigen::Matrix4f&amp; transform, const Eigen::Matrix4f&amp; render_projection_matrix,\n                                                const Eigen::Matrix4f&amp; render_view_matrix,\n                                                const Eigen::Matrix4f&amp; new_view_matrix);\n#ifndef ENABLE_MONADO\n    [[nodiscard]] time_point                get_next_swap_time_estimate() const;\n    [[maybe_unused]] [[nodiscard]] duration estimate_time_to_sleep(double frame_percentage) const;\n#endif\n\n    const std::shared_ptr&lt;switchboard&gt;                  switchboard_;\n    const std::shared_ptr&lt;data_format::pose_prediction&gt; pose_prediction_;\n    const std::shared_ptr&lt;const relative_clock&gt;         clock_;\n\n    // OpenGL objects\n    Display*   display_;\n    Window     root_window_;\n    GLXContext context_;\n\n    // Shared objects between ILLIXR and the application (either gldemo or Monado)\n    bool                      rendering_ready_;\n    data_format::graphics_api client_backend_;\n    std::atomic&lt;bool&gt;         image_handles_ready_{};\n\n    // Left and right eye images\n    std::array&lt;std::vector&lt;data_format::image_handle&gt;, 2&gt; eye_image_handles_;\n    std::array&lt;std::vector&lt;GLuint&gt;, 2&gt;                    eye_swapchains_;\n    std::array&lt;size_t, 2&gt;                                 eye_swapchains_size_{};\n\n    // Intermediate timewarp framebuffers for left and right eye textures\n    std::array&lt;GLuint, 2&gt; eye_output_textures_{};\n    std::array&lt;GLuint, 2&gt; eye_framebuffers_{};\n\n#ifdef ENABLE_MONADO\n    std::array&lt;data_format::image_handle, 2&gt; eye_output_handles_;\n\n    // Synchronization helper for Monado\n    switchboard::writer&lt;data_format::signal_to_quad&gt; signal_quad_;\n\n    // When using Monado, timewarp is a plugin and not a threadloop, but we still keep track of the iteration number\n    std::size_t iteration_no = 0;\n#else\n    // Note: 0.9 works fine without hologram, but we need a larger safety net with hologram enabled\n    static constexpr double DELAY_FRACTION = 0.9;\n\n    // Switchboard plug for application eye buffer.\n    switchboard::reader&lt;data_format::rendered_frame&gt; eyebuffer_;\n\n    // Switchboard plug for publishing vsync estimates\n    switchboard::writer&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_estimate_;\n\n    // Switchboard plug for publishing offloaded data\n    switchboard::writer&lt;data_format::texture_pose&gt; offload_data_;\n    // Timewarp only has vsync estimates with native-gl\n    record_coalescer mtp_logger_;\n#endif\n\n    GLuint timewarp_shader_program_{};\n\n    time_point time_last_swap_{};\n\n    HMD::hmd_info_t hmd_info_{};\n\n    // Eye sampler array\n    GLuint                  eye_sampler_0_{};\n    [[maybe_unused]] GLuint eye_sampler_1_{};\n\n    // Eye index uniform\n    [[maybe_unused]] GLuint tw_eye_index_uniform_{};\n\n    // VAOs\n    GLuint tw_vao{};\n\n    // Position and UV attribute locations\n    GLuint distortion_pos_attr_{};\n    GLuint distortion_uv0_attr_{};\n    GLuint distortion_uv1_attr_{};\n    GLuint distortion_uv2_attr_{};\n\n    // Distortion mesh information\n    GLuint num_distortion_vertices_{};\n    GLuint num_distortion_indices_{};\n\n    // Distortion mesh CPU buffers and GPU VBO handles\n    std::vector&lt;HMD::mesh_coord3d_t&gt; distortion_positions_;\n    GLuint                           distortion_positions_vbo_{};\n    std::vector&lt;GLuint&gt;              distortion_indices_;\n    GLuint                           distortion_indices_vbo_{};\n    std::vector&lt;HMD::uv_coord_t&gt;     distortion_uv0_;\n    GLuint                           distortion_uv0_vbo_{};\n    std::vector&lt;HMD::uv_coord_t&gt;     distortion_uv1_;\n    GLuint                           distortion_uv1_vbo_{};\n    std::vector&lt;HMD::uv_coord_t&gt;     distortion_uv2_;\n    GLuint                           distortion_uv2_vbo_{};\n\n    // Handles to the start and end timewarp\n    // transform matrices (3x4 uniforms)\n    GLuint tw_start_transform_uniform_{};\n    GLuint tw_end_transform_uniform_{};\n    // bool uniform to check if the Y axis needs to be inverted\n    GLuint flip_y_uniform_{};\n    // Basic perspective projection matrix\n    Eigen::Matrix4f basic_projection_;\n\n    // Hologram call data\n    ullong hologram_seq_{0};\n    ullong signal_quad_seq_{0};\n\n    bool disable_warp_;\n\n    bool             enable_offload_;\n    record_coalescer timewarp_gpu_logger_;\n    // Switchboard plug for sending hologram calls\n    switchboard::writer&lt;data_format::hologram_input&gt; hologram_;\n\n    // PBO buffer for reading texture image\n    GLuint PBO_buffer_{};\n\n    duration offload_duration_{};\n\n#ifndef NDEBUG\n    size_t log_count_  = 0;\n    size_t LOG_PERIOD_ = 20;\n#endif\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2timewarp__vk_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2timewarp__vk_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 22)  set (PLUGIN_SOURCE \"plugin.cpp\")"},{"location":"api/plugins_2timewarp__vk_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2timewarp__vk_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre>"},{"location":"api/plugins_2timewarp__vk_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_SOURCE \"plugin.cpp\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/CMakeLists.txt</code></p>"},{"location":"api/plugins_2timewarp__vk_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.22)\n\nproject(timewarp_vk)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nfind_package(glm REQUIRED)\n\nif(NOT PLUGIN_NAME)\n    set(PLUGIN_NAME \"plugin.timewarp_vk${ILLIXR_BUILD_SUFFIX}\")\n    set(PLUGIN_SOURCE \"plugin.cpp\")\n    set(TW_PREFIX \"\")\n    set(TW_POSTFIX \"\")\nendif()\n\nfile(GLOB_RECURSE GLSL_SOURCE_FILES\n     \"${TW_PREFIX}shaders/*.frag\"\n     \"${TW_PREFIX}shaders/*.vert\"\n)\nset(TIMEWARP_VK_DEP_STR \"\")\nif(Vulkan_EXTERNAL)\n    set(TIMEWARP_VK_DEP_STR ${Vulkan_DEP_STR})\nendif()\n\nset(PROJECT_BINARY_DIR \"${PROJECT_BINARY_DIR}${TW_POSTFIX}\")\n\nforeach(GLSL ${GLSL_SOURCE_FILES})\n    get_filename_component(FILE_NAME ${GLSL} NAME)\n    set(SPIRV \"${PROJECT_BINARY_DIR}/shaders/${FILE_NAME}.spv\")\n    if(NOT TARGET PROCESS_TWV_${FILE_NAME})\n        add_custom_target(PROCESS_TWV_${FILE_NAME} ALL\n                          COMMAND ${CMAKE_COMMAND} -E make_directory \"${PROJECT_BINARY_DIR}/shaders/\"\n                          COMMAND ${Vulkan_GLSLANG_VALIDATOR_EXECUTABLE} ${GLSL} -V -o ${SPIRV}\n                          BYPRODUCTS ${SPIRV}\n                          DEPENDS ${GLSL} ${TIMEWARP_VK_DEP_STR}\n        )\n        if(Vulkan_EXTERNAL)\n            add_dependencies(PROCESS_TWV_${FILE_NAME} ${Vulkan_DEP_STR})\n        endif()\n    endif()\n    list(APPEND SPIRV_BINARY_FILES ${SPIRV})\nendforeach(GLSL)\nif(NOT TARGET Timewarp_VK_Shaders)\n    add_custom_target(\n            Timewarp_VK_Shaders\n            DEPENDS ${SPIRV_BINARY_FILES}\n    )\nendif()\n\nadd_library(${PLUGIN_NAME} SHARED\n            ${PLUGIN_SOURCE}\n            ${TW_PREFIX}plugin.hpp\n            ${TW_PREFIX}timewarp_vk.cpp\n            ${TW_PREFIX}timewarp_vk.hpp\n            $&lt;TARGET_OBJECTS:illixr_hmd&gt;\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/math_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/display_provider.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/render_pass.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/vulkan_utils.hpp\n            $&lt;TARGET_OBJECTS:illixr_vulkan_utils&gt;\n)\nif(TW_PLUGIN_DEFINITIONS)\n    target_compile_definitions(${PLUGIN_NAME} PRIVATE ${TW_PLUGIN_DEFINITIONS})\n    target_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/..)\nendif()\n\nadd_dependencies(${PLUGIN_NAME} Timewarp_VK_Shaders)\nif(Vulkan_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${Vulkan_DEP_STR})\nendif()\n\nset_target_properties(${PLUGIN_NAME} PROPERTIES OUTPUT_NAME ${PLUGIN_NAME})\n\ntarget_link_libraries(${PLUGIN_NAME} ${Vulkan_LIBRARIES} spdlog::spdlog)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${Vulkan_INCLUDE_DIRS})\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${ILLIXR_SOURCE_DIR}/include)\n\ninstall_shaders(SPIRV_BINARY_FILES timewarp_vk ${PLUGIN_NAME})\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2timewarp__vk_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/README.md</code></p>"},{"location":"api/plugins_2timewarp__vk_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># timewarp_vk\n\n## Summary\n\n`timewarp_vk` is a [_Vulkan-based_][G10] rotational reprojection service intended for use in the ILLIXR architecture.\nThis plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).\n\n## Phonebook Service\n\n`timewarp_vk` is registered as a service in phonebook, conforming to the `timewarp` render pass interface. Three\nfunctions are exposed:\n\n- `setup(VkRenderPass render_pass, uint32_t subpass)` initializes the required Vulkan pipeline and resources given a\n  specific render pass and subpass, to which `timewarp_vk` binds to\n- `update_uniforms(const pose_type render_pose)` calculates the reprojection matrix given the current pose and the pose\n  used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before\n  `record_command_buffer` is called\n- `record_command_buffer(VkCommandBuffer commandBuffer, int left)` records the commands into a given command buffer that\n  would perform the reprojection for one eye, for which 1 is left and 0 is right\n\n## Environment Variables\n\n**ILLIXR_TIMEWARP_DISABLE**: whether to disable the warping, values can be \"True\" or \"False\"(default)\n\n## Notes\n\nThe rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the\nlate Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his\ncodebase [here][E10].\n\n\n[//]: # (- glossary -)\n\n[G10]: ../glossary.md#vulkan\n\n\n[//]: # (- external -)\n\n[E10]:  https://github.com/KhronosGroup/Vulkan-Samples-Deprecated/tree/master/samples/apps/atw\n</code></pre>"},{"location":"api/plugins_2timewarp__vk_2monado_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2timewarp__vk_2monado_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name get_external_for_plugin (Monado_vk)"},{"location":"api/plugins_2timewarp__vk_2monado_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2timewarp__vk_2monado_2CMakeLists_8txt/#function-get_external_for_plugin","title":"function get_external_for_plugin","text":"<pre><code>get_external_for_plugin (\n    Monado_vk\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/monado/CMakeLists.txt</code></p>"},{"location":"api/plugins_2timewarp__vk_2monado_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>get_external_for_plugin(Monado_vk)\nfile(COPY_FILE ${CMAKE_SOURCE_DIR}/plugins/timewarp_vk/plugin.cpp ${CMAKE_BINARY_DIR}/plugins/timewarp_vk/plugin_m.cpp)\nset(PLUGIN_NAME \"plugin.timewarp_vk.monado${ILLIXR_BUILD_SUFFIX}\")\nset(TW_PLUGIN_DEFINITIONS MONADO_REQUIRED)\nset(PLUGIN_SOURCE \"${CMAKE_BINARY_DIR}/plugins/timewarp_vk/plugin_m.cpp\")\nset(TW_PREFIX \"../\")\nset(TW_POSTFIX \"/..\")\n\ninclude(../CMakeLists.txt)\n</code></pre>"},{"location":"api/plugins_2timewarp__vk_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; timewarp_vk &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/plugin.cpp</code></p>"},{"location":"api/plugins_2timewarp__vk_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; timewarp_vk &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n[[maybe_unused]] timewarp_vk_plugin::timewarp_vk_plugin(const std::string&amp; name, phonebook* pb)\n    : threadloop{name, pb}\n    , timewarp_{std::make_shared&lt;timewarp_vk&gt;(phonebook_)} {\n    pb-&gt;register_impl&lt;vulkan::timewarp&gt;(std::static_pointer_cast&lt;vulkan::timewarp&gt;(timewarp_));\n}\n\nvoid timewarp_vk_plugin::_p_one_iteration() {\n    auto fps = timewarp_-&gt;num_record_calls_.exchange(0) / 2; // two eyes\n    auto ups = timewarp_-&gt;num_update_uniforms_calls_.exchange(0);\n\n    // std::cout &lt;&lt; \"timewarp_vk: cb records: \" &lt;&lt; fps &lt;&lt; \", uniform updates: \" &lt;&lt; ups &lt;&lt; std::endl;\n}\n\nthreadloop::skip_option timewarp_vk_plugin::_p_should_skip() {\n    // Get the current time in milliseconds\n    auto now =\n        std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();\n\n    // Only print every 1 second\n    if (now - last_print_ &lt; 1000) {\n        return skip_option::skip_and_yield;\n    } else {\n        last_print_ = now;\n        return skip_option::run;\n    }\n}\n\nPLUGIN_MAIN(timewarp_vk_plugin)\n</code></pre>"},{"location":"api/plugins_2timewarp__vk_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; timewarp_vk &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"timewarp_vk.hpp\"</code></li> </ul>"},{"location":"api/plugins_2timewarp__vk_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2timewarp__vk_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class timewarp_vk_plugin <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/plugin.hpp</code></p>"},{"location":"api/plugins_2timewarp__vk_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; timewarp_vk &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/threadloop.hpp\"\n#include \"timewarp_vk.hpp\"\n\nnamespace ILLIXR {\n\nclass timewarp_vk_plugin : public threadloop {\npublic:\n    [[maybe_unused]] timewarp_vk_plugin(const std::string&amp; name, phonebook* pb);\n    void        _p_one_iteration() override;\n    skip_option _p_should_skip() override;\n\nprivate:\n    std::shared_ptr&lt;timewarp_vk&gt; timewarp_;\n\n    int64_t last_print_ = 0;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2webcam_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2webcam_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.webcam${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2webcam_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2webcam_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.webcam${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/webcam/CMakeLists.txt</code></p>"},{"location":"api/plugins_2webcam_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>set(PLUGIN_NAME plugin.webcam${ILLIXR_BUILD_SUFFIX})\n\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp\n            plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/relative_clock.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n)\n\nif(BUILD_OPENCV)\n    add_dependencies(${PLUGIN_NAME} OpenCV_Viz)\nendif()\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${OpenCV_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} PUBLIC ${OpenCV_LIBRARIES})\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2webcam_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; webcam &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include &lt;opencv2/imgproc.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/webcam/plugin.cpp</code></p>"},{"location":"api/plugins_2webcam_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; webcam &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/relative_clock.hpp\"\n\n#include &lt;opencv2/imgproc.hpp&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\n[[maybe_unused]] webcam::webcam(const std::string&amp; name_, phonebook* pb_)\n    : threadloop{name_, pb_}\n    , switchboard_{pb_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , frame_pub_{switchboard_-&gt;get_writer&lt;monocular_cam_type&gt;(\"webcam\")} {\n    const char* video_stream = switchboard_-&gt;get_env_char(\"INPUT_VIDEO\");\n    load_video_              = video_stream != nullptr;\n    if (load_video_) {\n        capture_.open(video_stream);\n    } else {\n        capture_.open(0);\n    }\n    if (!capture_.isOpened()) {\n        throw std::runtime_error(\"Cannot open camera\");\n    }\n#if (CV_MAJOR_VERSION &gt;= 3) &amp;&amp; (CV_MINOR_VERSION &gt;= 2)\n    capture_.set(cv::CAP_PROP_FRAME_WIDTH, 640);\n    capture_.set(cv::CAP_PROP_FRAME_HEIGHT, 480);\n    capture_.set(cv::CAP_PROP_FPS, 30);\n#endif\n}\n\nvoid webcam::_p_one_iteration() {\n    cv::Mat camera_frame_raw;\n    capture_ &gt;&gt; camera_frame_raw;\n    if (camera_frame_raw.empty())\n        return;\n    cv::Mat camera_frame;\n    cv::cvtColor(camera_frame_raw, camera_frame, cv::COLOR_BGR2RGB);\n    time_point current_time(\n        std::chrono::duration&lt;long, std::nano&gt;{std::chrono::system_clock::now().time_since_epoch().count()});\n    frame_pub_.put(frame_pub_.allocate&lt;monocular_cam_type&gt;({current_time, camera_frame}));\n}\n\nPLUGIN_MAIN(webcam)\n</code></pre>"},{"location":"api/plugins_2webcam_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; webcam &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include &lt;opencv4/opencv2/videoio.hpp&gt;</code></li> </ul>"},{"location":"api/plugins_2webcam_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2webcam_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class webcam <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/webcam/plugin.hpp</code></p>"},{"location":"api/plugins_2webcam_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; webcam &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n#include &lt;opencv4/opencv2/videoio.hpp&gt;\n\nnamespace ILLIXR {\nclass webcam : public threadloop {\npublic:\n    [[maybe_unused]] webcam(const std::string&amp; name_, phonebook* pb_);\n    void _p_one_iteration() override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;                   switchboard_;\n    switchboard::writer&lt;data_format::monocular_cam_type&gt; frame_pub_;\n    cv::VideoCapture                                     capture_;\n    bool                                                 load_video_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2zed_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2zed_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.zed${ILLIXR_BUILD_SUFFIX})  EXACT REQUIRED set (SRC_FILES plugin.cpp zed_camera.cpp zed_camera_thread. cpp)"},{"location":"api/plugins_2zed_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2zed_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.zed${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre>"},{"location":"api/plugins_2zed_2CMakeLists_8txt/#function-set_1","title":"function set","text":"<pre><code>EXACT REQUIRED set (\n    SRC_FILES plugin.cpp zed_camera.cpp zed_camera_thread. cpp\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/CMakeLists.txt</code></p>"},{"location":"api/plugins_2zed_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># To add compiler flags for debugging, uncomment the lines below.\n# SET(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -fsanitize=thread\")\n# SET(CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=thread\")\n\nCMAKE_MINIMUM_REQUIRED(VERSION 3.16)\n\nset(PLUGIN_NAME plugin.zed${ILLIXR_BUILD_SUFFIX})\nif (CMAKE_VERSION VERSION_GREATER_EQUAL \"3.27.0\")\n    cmake_policy(SET CMP0146 OLD)\n    if (CMAKE_VERSION VERSION_GREATER_EQUAL \"3.28.0\")\n        cmake_policy(SET CMP0153 OLD)\n    endif()\nendif()\n\nSET(THREADS_PREFER_PTHREAD_FLAG TRUE)\n\nfind_package(Threads REQUIRED)\nfind_package(ZED 3 REQUIRED)\nfind_package(CUDA ${ZED_CUDA_VERSION} EXACT REQUIRED)\n\nset(SRC_FILES plugin.cpp\n    zed_camera.cpp\n    zed_camera_thread.cpp\n)\nset(HDR_FILES include/zed_opencv.hpp\n    zed_camera.hpp\n    zed_camera_thread.hpp\n    plugin.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/zed_cam.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n)\n\nSET(ZED_LIBS ${ZED_LIBRARIES} ${CUDA_CUDA_LIBRARY} ${CUDA_CUDART_LIBRARY})\nadd_library(${PLUGIN_NAME} SHARED ${HDR_FILES} ${SRC_FILES})\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${CUDA_INCLUDE_DIRS} ${ZED_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS} ${Eigen3_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/include)\n\ntarget_link_libraries(${PLUGIN_NAME} ${ZED_LIBS} ${OpenCV_LIBRARIES} ${Eigen3_LIBRARIES} Threads::Threads spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2zed_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/README.md</code></p>"},{"location":"api/plugins_2zed_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># ZED Mini\n\n## Getting started\n\n- First, download the latest version of the ZED SDK on [stereolabs.com](https://www.stereolabs.com/docs/installation/linux/).\n- For more information, read the ZED [API documentation](https://www.stereolabs.com/developers/documentation/API/).\n\n### Prerequisites\n\n- Ubuntu 22.04 or 24.04\n- [CUDA](https://developer.nvidia.com/cuda-toolkit-archive)\n- [ZED SDK](https://www.stereolabs.com/docs/installation/linux/)\n- OpenCV 4\n</code></pre>"},{"location":"api/plugins_2zed_2capture_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2zed_2capture_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 22)  EXACT REQUIRED find_package (Boost REQUIRED CONFIG COMPONENTS filesystem)"},{"location":"api/plugins_2zed_2capture_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2zed_2capture_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre>"},{"location":"api/plugins_2zed_2capture_2CMakeLists_8txt/#function-find_package","title":"function find_package","text":"<pre><code>EXACT REQUIRED find_package (\n    Boost REQUIRED CONFIG COMPONENTS filesystem\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/CMakeLists.txt</code></p>"},{"location":"api/plugins_2zed_2capture_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.22)\nif (POLICY CMP0153)\n    cmake_policy(SET CMP0153 OLD)\nendif()\n\nif (POLICY CMP0146)\n    cmake_policy(SET CMP0146 OLD)\nendif()\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\n\nadd_compile_options(-Wno-deprecated-declarations)\n\nfind_package(OpenCV 4 REQUIRED)\nfind_package(ZED 3 REQUIRED)\nfind_package(CUDA ${ZED_CUDA_VERSION} EXACT REQUIRED)\nfind_package(Boost REQUIRED CONFIG COMPONENTS filesystem)\n\nset(ZED_LIBS ${ZED_LIBRARIES} ${CUDA_CUDA_LIBRARY} ${CUDA_CUDART_LIBRARY})\n\nfind_package(PkgConfig)\nfind_package(Eigen3 REQUIRED)\nset(ENABLE_OPENCV ON)\nfind_package(glfw3 QUIET)\nif(NOT glfw3_FOUND)\n    pkg_search_module(glfw3 REQUIRED glfw3)\nendif()\nfind_package(X11 REQUIRED)\npkg_check_modules(glu REQUIRED glu)\nfind_package(GLEW REQUIRED)\npkg_check_modules(gl REQUIRED gl)\n\nfind_package(OpenGL REQUIRED)\n\nadd_executable(zed_capture\n               capture.hpp\n               capture.cpp\n               capture_main.cpp\n               cxxopts.hpp\n               zed_opencv.hpp\n               files.hpp\n               files.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imconfig.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imgui.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imgui.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imgui_demo.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imgui_draw.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imgui_internal.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imgui_tables.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imgui_widgets.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imstb_rectpack.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imstb_textedit.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/imstb_truetype.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/misc/cpp/imgui_stdlib.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/misc/cpp/imgui_stdlib.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/backends/imgui_impl_glfw.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/backends/imgui_impl_glfw.cpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/backends/imgui_impl_opengl3.h\n               ${CMAKE_SOURCE_DIR}/include/illixr/imgui/backends/imgui_impl_opengl3.cpp\n\n)\n\nadd_compile_definitions(-DHAVE_ZED)\ntarget_link_libraries(zed_capture PUBLIC\n                      ${ZED_LIBS}\n                      ${X11_LIBRARIES}\n                      ${GLEW_LIBRARIES}\n                      ${glu_LDFLAGS}\n                      ${OpenCV_LIBRARIES}\n                      glfw\n                      OpenGL::GL\n                      ${Eigen3_LIBRARIES}\n                      dl\n                      Threads::Threads\n                      boost_filesystem\n)\ntarget_include_directories(zed_capture PUBLIC\n                           ${CMAKE_SOURCE_DIR}/include\n                           ${ZED_INCLUDE_DIRS}\n                           ${X11_INCLUDE_DIR}\n                           ${GLEW_INCLUDE_DIR}\n                           ${GLU_INCLUDE_DIR}\n                           ${OpenCV_INCLUDE_DIRS}\n                           ${glfw3_INCLUDE_DIRS}\n                           ${gl_INCLUDE_DIRS}\n                           ${BOOST_INCLUDE_DIRS}\n)\n\ninstall(TARGETS zed_capture DESTINATION bin)\n</code></pre>"},{"location":"api/plugins_2zed_2capture_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/README.md</code></p>"},{"location":"api/plugins_2zed_2capture_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># zed_capture\n\nThe `zed_capture` binary is used to generate test data for injection into ILLIXR. The binary is a stand-alone feature and\ndoes not interact with the rest of ILLIXR. It takes the following command line arguments.\n\n| Argument       | Description                                                                                                                   | Default                    |\n|----------------|-------------------------------------------------------------------------------------------------------------------------------|----------------------------|\n| -d, --duration | The duration to run for in seconds                                                                                            | 10                         |\n| -f, --fps      | Frames per second                                                                                                             | 30                         |\n| --wc           | The origin of the world coordinate system in relation to the camera. Must be 7 comma separated values x, y, z, w, wx, wy, wz. | 0., 0., 0., 1., 0., 0., 0. |\n| -p --path      | The root path to write the data to.                                                                                           | Current working directory  |\n\n`zed_capture` will write out the left and right camera images and the current pose at each frame. Note that it may not\nwork at the requested fps due to overheads of writing files. This will be addressed in future updates. Note that the\ndepth information is also not captured currently as [_OpenCV_][G10] does not properly write out cv::Mat objects with float formats.\nThis will also be addressed in future updates.\n\nData are written to &lt;path&gt;/'fps' + &lt;fps_value&gt; + 'dur' + &lt;duration_value&gt; (e.g. &lt;path&gt;/fps30_dur10 will contain data \ntaken at 30 frames per second with a total run time of 10 seconds, or 300 frames, it will always contain 300 frames\nregardless of any slow down due to overheads). This format is compatible with the zed.data_injection plugin.\n\n\n[//]: # (- glossary -)\n\n[G10]:  ../glossary.md#opencv\n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/","title":"File cxxopts.hpp","text":"<p>FileList &gt; capture &gt; cxxopts.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;locale&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> </ul>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cxxopts namespace exceptions namespace values namespace detail namespace parser_tool"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#classes","title":"Classes","text":"Type Name struct HelpGroupDetails struct HelpOptionDetails class KeyValue struct Option class OptionAdder class OptionDetails class OptionParser class OptionValue class Options class ParseResult class Iterator class Value class exception class gratuitous_argument_for_option class incorrect_argument_type class invalid_option_format class invalid_option_syntax class missing_argument class no_such_option class option_already_exists class option_has_no_value class option_requires_argument class parsing class requested_option_not_present class specification class abstract_value &lt;typename T&gt; struct SignedCheck&lt; T, false &gt; &lt;typename T&gt; struct SignedCheck&lt; T, true &gt; &lt;typename T&gt; struct ArguDesc struct IntegerDesc class standard_value &lt;typename T&gt; class standard_value&lt; bool &gt; &lt;&gt; struct type_is_container &lt;typename T&gt; struct type_is_container&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#macros","title":"Macros","text":"Type Name define CXXOPTS_DIAGNOSTIC_POP define CXXOPTS_DIAGNOSTIC_PUSH define CXXOPTS_IGNORE_WARNING (x)  define CXXOPTS_LINKONCE define CXXOPTS_LINKONCE_CONST define CXXOPTS_NODISCARD define CXXOPTS_RTTI_CAST <code>dynamic\\_cast</code> define CXXOPTS_VECTOR_DELIMITER <code>','</code> define CXXOPTS__VERSION_MAJOR <code>3</code> define CXXOPTS__VERSION_MINOR <code>1</code> define CXXOPTS__VERSION_PATCH <code>1</code>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_diagnostic_pop","title":"define CXXOPTS_DIAGNOSTIC_POP","text":"<pre><code>#define CXXOPTS_DIAGNOSTIC_POP \n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_diagnostic_push","title":"define CXXOPTS_DIAGNOSTIC_PUSH","text":"<pre><code>#define CXXOPTS_DIAGNOSTIC_PUSH \n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_ignore_warning","title":"define CXXOPTS_IGNORE_WARNING","text":"<pre><code>#define CXXOPTS_IGNORE_WARNING (\n    x\n) \n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_linkonce","title":"define CXXOPTS_LINKONCE","text":"<pre><code>#define CXXOPTS_LINKONCE \n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_linkonce_const","title":"define CXXOPTS_LINKONCE_CONST","text":"<pre><code>#define CXXOPTS_LINKONCE_CONST \n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_nodiscard","title":"define CXXOPTS_NODISCARD","text":"<pre><code>#define CXXOPTS_NODISCARD \n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_rtti_cast","title":"define CXXOPTS_RTTI_CAST","text":"<pre><code>#define CXXOPTS_RTTI_CAST `dynamic_cast`\n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts_vector_delimiter","title":"define CXXOPTS_VECTOR_DELIMITER","text":"<pre><code>#define CXXOPTS_VECTOR_DELIMITER `','`\n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts__version_major","title":"define CXXOPTS__VERSION_MAJOR","text":"<pre><code>#define CXXOPTS__VERSION_MAJOR `3`\n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts__version_minor","title":"define CXXOPTS__VERSION_MINOR","text":"<pre><code>#define CXXOPTS__VERSION_MINOR `1`\n</code></pre>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp/#define-cxxopts__version_patch","title":"define CXXOPTS__VERSION_PATCH","text":"<pre><code>#define CXXOPTS__VERSION_PATCH `1`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/plugins_2zed_2capture_2cxxopts_8hpp_source/","title":"File cxxopts.hpp","text":"<p>File List &gt; capture &gt; cxxopts.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n\nCopyright (c) 2014-2022 Jarryd Beck\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// vim: ts=2:sw=2:expandtab\n\n#ifndef CXXOPTS_HPP_INCLUDED\n#define CXXOPTS_HPP_INCLUDED\n\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n#include &lt;exception&gt;\n#include &lt;initializer_list&gt;\n#include &lt;limits&gt;\n#include &lt;locale&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#ifdef CXXOPTS_NO_EXCEPTIONS\n    #include &lt;iostream&gt;\n#endif\n\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n    #if (__GNUC__ * 10 + __GNUC_MINOR__) &lt; 49\n        #define CXXOPTS_NO_REGEX true\n    #endif\n#endif\n#if defined(_MSC_VER) &amp;&amp; !defined(__clang__)\n    #define CXXOPTS_LINKONCE_CONST __declspec(selectany) extern\n    #define CXXOPTS_LINKONCE       __declspec(selectany) extern\n#else\n    #define CXXOPTS_LINKONCE_CONST\n    #define CXXOPTS_LINKONCE\n#endif\n\n#ifndef CXXOPTS_NO_REGEX\n    #include &lt;regex&gt;\n#endif // CXXOPTS_NO_REGEX\n\n// Nonstandard before C++17, which is coincidentally what we also need for &lt;optional&gt;\n#ifdef __has_include\n    #if __has_include(&lt;optional&gt;)\n        #include &lt;optional&gt;\n        #ifdef __cpp_lib_optional\n            #define CXXOPTS_HAS_OPTIONAL\n        #endif\n    #endif\n#endif\n\n#if __cplusplus &gt;= 201603L\n    #define CXXOPTS_NODISCARD [[nodiscard]]\n#else\n    #define CXXOPTS_NODISCARD\n#endif\n\n#ifndef CXXOPTS_VECTOR_DELIMITER\n    #define CXXOPTS_VECTOR_DELIMITER ','\n#endif\n\n#define CXXOPTS__VERSION_MAJOR 3\n#define CXXOPTS__VERSION_MINOR 1\n#define CXXOPTS__VERSION_PATCH 1\n\n#if (__GNUC__ &lt; 10 || (__GNUC__ == 10 &amp;&amp; __GNUC_MINOR__ &lt; 1)) &amp;&amp; __GNUC__ &gt;= 6\n    #define CXXOPTS_NULL_DEREF_IGNORE\n#endif\n\n#if defined(__GNUC__)\n    #define DO_PRAGMA(x)              _Pragma(#x)\n    #define CXXOPTS_DIAGNOSTIC_PUSH   DO_PRAGMA(GCC diagnostic push)\n    #define CXXOPTS_DIAGNOSTIC_POP    DO_PRAGMA(GCC diagnostic pop)\n    #define CXXOPTS_IGNORE_WARNING(x) DO_PRAGMA(GCC diagnostic ignored x)\n#else\n    // define other compilers here if needed\n    #define CXXOPTS_DIAGNOSTIC_PUSH\n    #define CXXOPTS_DIAGNOSTIC_POP\n    #define CXXOPTS_IGNORE_WARNING(x)\n#endif\n\n#ifdef CXXOPTS_NO_RTTI\n    #define CXXOPTS_RTTI_CAST static_cast\n#else\n    #define CXXOPTS_RTTI_CAST dynamic_cast\n#endif\n\nnamespace cxxopts {\nstatic constexpr struct {\n    uint8_t major, minor, patch;\n} version = {CXXOPTS__VERSION_MAJOR, CXXOPTS__VERSION_MINOR, CXXOPTS__VERSION_PATCH};\n} // namespace cxxopts\n\n// when we ask cxxopts to use Unicode, help strings are processed using ICU,\n// which results in the correct lengths being computed for strings when they\n// are formatted for the help output\n// it is necessary to make sure that &lt;unicode/unistr.h&gt; can be found by the\n// compiler, and that icu-uc is linked in to the binary.\n\n#ifdef CXXOPTS_USE_UNICODE\n    #include &lt;unicode/unistr.h&gt;\n\nnamespace cxxopts {\n\nusing String = icu::UnicodeString;\n\ninline String toLocalString(std::string s) {\n    return icu::UnicodeString::fromUTF8(std::move(s));\n}\n\n// GNU GCC with -Weffc++ will issue a warning regarding the upcoming class, we want to silence it:\n// warning: base class 'class std::enable_shared_from_this&lt;cxxopts::Value&gt;' has accessible non-virtual destructor\nCXXOPTS_DIAGNOSTIC_PUSH\nCXXOPTS_IGNORE_WARNING(\"-Wnon-virtual-dtor\")\n\n// This will be ignored under other compilers like LLVM clang.\nclass UnicodeStringIterator {\npublic:\n    using iterator_category = std::forward_iterator_tag;\n    using value_type        = int32_t;\n    using difference_type   = std::ptrdiff_t;\n    using pointer           = value_type*;\n    using reference         = value_type&amp;;\n\n    UnicodeStringIterator(const icu::UnicodeString* string, int32_t pos)\n        : s(string)\n        , i(pos) { }\n\n    value_type operator*() const {\n        return s-&gt;char32At(i);\n    }\n\n    bool operator==(const UnicodeStringIterator&amp; rhs) const {\n        return s == rhs.s &amp;&amp; i == rhs.i;\n    }\n\n    bool operator!=(const UnicodeStringIterator&amp; rhs) const {\n        return !(*this == rhs);\n    }\n\n    UnicodeStringIterator&amp; operator++() {\n        ++i;\n        return *this;\n    }\n\n    UnicodeStringIterator operator+(int32_t v) {\n        return UnicodeStringIterator(s, i + v);\n    }\n\nprivate:\n    const icu::UnicodeString* s;\n    int32_t                   i;\n};\n\nCXXOPTS_DIAGNOSTIC_POP\n\ninline String&amp; stringAppend(String&amp; s, String a) {\n    return s.append(std::move(a));\n}\n\ninline String&amp; stringAppend(String&amp; s, std::size_t n, UChar32 c) {\n    for (std::size_t i = 0; i != n; ++i) {\n        s.append(c);\n    }\n\n    return s;\n}\n\ntemplate&lt;typename Iterator&gt;\nString&amp; stringAppend(String&amp; s, Iterator begin, Iterator end) {\n    while (begin != end) {\n        s.append(*begin);\n        ++begin;\n    }\n\n    return s;\n}\n\ninline size_t stringLength(const String&amp; s) {\n    return static_cast&lt;size_t&gt;(s.length());\n}\n\ninline std::string toUTF8String(const String&amp; s) {\n    std::string result;\n    s.toUTF8String(result);\n\n    return result;\n}\n\ninline bool empty(const String&amp; s) {\n    return s.isEmpty();\n}\n\n} // namespace cxxopts\n\nnamespace std {\n\ninline cxxopts::UnicodeStringIterator begin(const icu::UnicodeString&amp; s) {\n    return cxxopts::UnicodeStringIterator(&amp;s, 0);\n}\n\ninline cxxopts::UnicodeStringIterator end(const icu::UnicodeString&amp; s) {\n    return cxxopts::UnicodeStringIterator(&amp;s, s.length());\n}\n\n} // namespace std\n\n// ifdef CXXOPTS_USE_UNICODE\n#else\n\nnamespace cxxopts {\n\nusing String = std::string;\n\ntemplate&lt;typename T&gt;\nT toLocalString(T&amp;&amp; t) {\n    return std::forward&lt;T&gt;(t);\n}\n\ninline std::size_t stringLength(const String&amp; s) {\n    return s.length();\n}\n\ninline String&amp; stringAppend(String&amp; s, const String&amp; a) {\n    return s.append(a);\n}\n\ninline String&amp; stringAppend(String&amp; s, std::size_t n, char c) {\n    return s.append(n, c);\n}\n\ntemplate&lt;typename Iterator&gt;\nString&amp; stringAppend(String&amp; s, Iterator begin, Iterator end) {\n    return s.append(begin, end);\n}\n\ntemplate&lt;typename T&gt;\nstd::string toUTF8String(T&amp;&amp; t) {\n    return std::forward&lt;T&gt;(t);\n}\n\ninline bool empty(const std::string&amp; s) {\n    return s.empty();\n}\n\n} // namespace cxxopts\n\n// ifdef CXXOPTS_USE_UNICODE\n#endif\n\nnamespace cxxopts {\n\nnamespace {\n    CXXOPTS_LINKONCE_CONST std::string LQUOTE(\"\\'\");\n    CXXOPTS_LINKONCE_CONST std::string RQUOTE(\"\\'\");\n} // namespace\n\n// GNU GCC with -Weffc++ will issue a warning regarding the upcoming class, we\n// want to silence it: warning: base class 'class\n// std::enable_shared_from_this&lt;cxxopts::Value&gt;' has accessible non-virtual\n// destructor This will be ignored under other compilers like LLVM clang.\nCXXOPTS_DIAGNOSTIC_PUSH\nCXXOPTS_IGNORE_WARNING(\"-Wnon-virtual-dtor\")\n\n// some older versions of GCC warn under this warning\nCXXOPTS_IGNORE_WARNING(\"-Weffc++\")\n\nclass Value : public std::enable_shared_from_this&lt;Value&gt; {\npublic:\n    virtual ~Value() = default;\n\n    virtual std::shared_ptr&lt;Value&gt; clone() const = 0;\n\n    virtual void parse(const std::string&amp; text) const = 0;\n\n    virtual void parse() const = 0;\n\n    virtual bool has_default() const = 0;\n\n    virtual bool is_container() const = 0;\n\n    virtual bool has_implicit() const = 0;\n\n    virtual std::string get_default_value() const = 0;\n\n    virtual std::string get_implicit_value() const = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; default_value(const std::string&amp; value) = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; implicit_value(const std::string&amp; value) = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; no_implicit_value() = 0;\n\n    virtual bool is_boolean() const = 0;\n};\n\nCXXOPTS_DIAGNOSTIC_POP\n\nnamespace exceptions {\n\n    class exception : public std::exception {\n    public:\n        explicit exception(std::string message)\n            : m_message(std::move(message)) { }\n\n        CXXOPTS_NODISCARD\n        const char* what() const noexcept override {\n            return m_message.c_str();\n        }\n\n    private:\n        std::string m_message;\n    };\n\n    class specification : public exception {\n    public:\n        explicit specification(const std::string&amp; message)\n            : exception(message) { }\n    };\n\n    class parsing : public exception {\n    public:\n        explicit parsing(const std::string&amp; message)\n            : exception(message) { }\n    };\n\n    class option_already_exists : public specification {\n    public:\n        explicit option_already_exists(const std::string&amp; option)\n            : specification(\"Option \" + LQUOTE + option + RQUOTE + \" already exists\") { }\n    };\n\n    class invalid_option_format : public specification {\n    public:\n        explicit invalid_option_format(const std::string&amp; format)\n            : specification(\"Invalid option format \" + LQUOTE + format + RQUOTE) { }\n    };\n\n    class invalid_option_syntax : public parsing {\n    public:\n        explicit invalid_option_syntax(const std::string&amp; text)\n            : parsing(\"Argument \" + LQUOTE + text + RQUOTE + \" starts with a - but has incorrect syntax\") { }\n    };\n\n    class no_such_option : public parsing {\n    public:\n        explicit no_such_option(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" does not exist\") { }\n    };\n\n    class missing_argument : public parsing {\n    public:\n        explicit missing_argument(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" is missing an argument\") { }\n    };\n\n    class option_requires_argument : public parsing {\n    public:\n        explicit option_requires_argument(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" requires an argument\") { }\n    };\n\n    class gratuitous_argument_for_option : public parsing {\n    public:\n        gratuitous_argument_for_option(const std::string&amp; option, const std::string&amp; arg)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" does not take an argument, but argument \" + LQUOTE + arg +\n                      RQUOTE + \" given\") { }\n    };\n\n    class requested_option_not_present : public parsing {\n    public:\n        explicit requested_option_not_present(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" not present\") { }\n    };\n\n    class option_has_no_value : public exception {\n    public:\n        explicit option_has_no_value(const std::string&amp; option)\n            : exception(!option.empty() ? (\"Option \" + LQUOTE + option + RQUOTE + \" has no value\") : \"Option has no value\") { }\n    };\n\n    class incorrect_argument_type : public parsing {\n    public:\n        explicit incorrect_argument_type(const std::string&amp; arg)\n            : parsing(\"Argument \" + LQUOTE + arg + RQUOTE + \" failed to parse\") { }\n    };\n\n} // namespace exceptions\n\ntemplate&lt;typename T&gt;\nvoid throw_or_mimic(const std::string&amp; text) {\n    static_assert(std::is_base_of&lt;std::exception, T&gt;::value,\n                  \"throw_or_mimic only works on std::exception and \"\n                  \"deriving classes\");\n\n#ifndef CXXOPTS_NO_EXCEPTIONS\n    // If CXXOPTS_NO_EXCEPTIONS is not defined, just throw\n    throw T{text};\n#else\n    // Otherwise manually instantiate the exception, print what() to stderr,\n    // and exit\n    T exception{text};\n    std::cerr &lt;&lt; exception.what() &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n#endif\n}\n\nusing OptionNames = std::vector&lt;std::string&gt;;\n\nnamespace values {\n\n    namespace parser_tool {\n\n        struct IntegerDesc {\n            std::string negative = \"\";\n            std::string base     = \"\";\n            std::string value    = \"\";\n        };\n\n        struct ArguDesc {\n            std::string arg_name  = \"\";\n            bool        grouping  = false;\n            bool        set_value = false;\n            std::string value     = \"\";\n        };\n\n#ifdef CXXOPTS_NO_REGEX\n        inline IntegerDesc SplitInteger(const std::string&amp; text) {\n            if (text.empty()) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n            IntegerDesc desc;\n            const char* pdata = text.c_str();\n            if (*pdata == '-') {\n                pdata += 1;\n                desc.negative = \"-\";\n            }\n            if (strncmp(pdata, \"0x\", 2) == 0) {\n                pdata += 2;\n                desc.base = \"0x\";\n            }\n            if (*pdata != '\\0') {\n                desc.value = std::string(pdata);\n            } else {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n            return desc;\n        }\n\n        inline bool IsTrueText(const std::string&amp; text) {\n            const char* pdata = text.c_str();\n            if (*pdata == 't' || *pdata == 'T') {\n                pdata += 1;\n                if (strncmp(pdata, \"rue\\0\", 4) == 0) {\n                    return true;\n                }\n            } else if (strncmp(pdata, \"1\\0\", 2) == 0) {\n                return true;\n            }\n            return false;\n        }\n\n        inline bool IsFalseText(const std::string&amp; text) {\n            const char* pdata = text.c_str();\n            if (*pdata == 'f' || *pdata == 'F') {\n                pdata += 1;\n                if (strncmp(pdata, \"alse\\0\", 5) == 0) {\n                    return true;\n                }\n            } else if (strncmp(pdata, \"0\\0\", 2) == 0) {\n                return true;\n            }\n            return false;\n        }\n\n        inline OptionNames split_option_names(const std::string&amp; text) {\n            OptionNames split_names;\n\n            std::string::size_type token_start_pos = 0;\n            auto                   length          = text.length();\n\n            if (length == 0) {\n                throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n            }\n\n            while (token_start_pos &lt; length) {\n                const auto&amp; npos               = std::string::npos;\n                auto        next_non_space_pos = text.find_first_not_of(' ', token_start_pos);\n                if (next_non_space_pos == npos) {\n                    throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                }\n                token_start_pos         = next_non_space_pos;\n                auto next_delimiter_pos = text.find(',', token_start_pos);\n                if (next_delimiter_pos == token_start_pos) {\n                    throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                }\n                if (next_delimiter_pos == npos) {\n                    next_delimiter_pos = length;\n                }\n                auto token_length = next_delimiter_pos - token_start_pos;\n                // validate the token itself matches the regex /([:alnum:][-_[:alnum:]]*/\n                {\n                    const char* option_name_valid_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                                                          \"abcdefghijklmnopqrstuvwxyz\"\n                                                          \"0123456789\"\n                                                          \"_-.?\";\n\n                    if (!std::isalnum(text[token_start_pos], std::locale::classic()) ||\n                        text.find_first_not_of(option_name_valid_chars, token_start_pos) &lt; next_delimiter_pos) {\n                        throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                    }\n                }\n                split_names.emplace_back(text.substr(token_start_pos, token_length));\n                token_start_pos = next_delimiter_pos + 1;\n            }\n            return split_names;\n        }\n\n        inline ArguDesc ParseArgument(const char* arg, bool&amp; matched) {\n            ArguDesc    argu_desc;\n            const char* pdata = arg;\n            matched           = false;\n            if (strncmp(pdata, \"--\", 2) == 0) {\n                pdata += 2;\n                if (isalnum(*pdata, std::locale::classic())) {\n                    argu_desc.arg_name.push_back(*pdata);\n                    pdata += 1;\n                    while (isalnum(*pdata, std::locale::classic()) || *pdata == '-' || *pdata == '_') {\n                        argu_desc.arg_name.push_back(*pdata);\n                        pdata += 1;\n                    }\n                    if (argu_desc.arg_name.length() &gt; 1) {\n                        if (*pdata == '=') {\n                            argu_desc.set_value = true;\n                            pdata += 1;\n                            if (*pdata != '\\0') {\n                                argu_desc.value = std::string(pdata);\n                            }\n                            matched = true;\n                        } else if (*pdata == '\\0') {\n                            matched = true;\n                        }\n                    }\n                }\n            } else if (strncmp(pdata, \"-\", 1) == 0) {\n                pdata += 1;\n                argu_desc.grouping = true;\n                while (isalnum(*pdata, std::locale::classic())) {\n                    argu_desc.arg_name.push_back(*pdata);\n                    pdata += 1;\n                }\n                matched = !argu_desc.arg_name.empty() &amp;&amp; *pdata == '\\0';\n            }\n            return argu_desc;\n        }\n\n#else // CXXOPTS_NO_REGEX\n\n        namespace {\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; integer_pattern(\"(-)?(0x)?([0-9a-zA-Z]+)|((0x)?0)\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; truthy_pattern(\"(t|T)(rue)?|1\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; falsy_pattern(\"(f|F)(alse)?|0\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_matcher(\"--([[:alnum:]][-_[:alnum:]\\\\.]+)(=(.*))?|-([[:alnum:]].*)\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_specifier(\"([[:alnum:]][-_[:alnum:]\\\\.]*)(,[ ]*[[:alnum:]][-_[:alnum:]]*)*\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_specifier_separator(\", *\");\n\n        } // namespace\n\n        inline IntegerDesc SplitInteger(const std::string&amp; text) {\n            std::smatch match;\n            std::regex_match(text, match, integer_pattern);\n\n            if (match.length() == 0) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            IntegerDesc desc;\n            desc.negative = match[1];\n            desc.base     = match[2];\n            desc.value    = match[3];\n\n            if (match.length(4) &gt; 0) {\n                desc.base  = match[5];\n                desc.value = \"0\";\n                return desc;\n            }\n\n            return desc;\n        }\n\n        inline bool IsTrueText(const std::string&amp; text) {\n            std::smatch result;\n            std::regex_match(text, result, truthy_pattern);\n            return !result.empty();\n        }\n\n        inline bool IsFalseText(const std::string&amp; text) {\n            std::smatch result;\n            std::regex_match(text, result, falsy_pattern);\n            return !result.empty();\n        }\n\n        // Gets the option names specified via a single, comma-separated string,\n        // and returns the separate, space-discarded, non-empty names\n        // (without considering which or how many are single-character)\n        inline OptionNames split_option_names(const std::string&amp; text) {\n            if (!std::regex_match(text.c_str(), option_specifier)) {\n                throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n            }\n\n            OptionNames split_names;\n\n            constexpr int use_non_matches{-1};\n            auto          token_iterator =\n                std::sregex_token_iterator(text.begin(), text.end(), option_specifier_separator, use_non_matches);\n            std::copy(token_iterator, std::sregex_token_iterator(), std::back_inserter(split_names));\n            return split_names;\n        }\n\n        inline ArguDesc ParseArgument(const char* arg, bool&amp; matched) {\n            std::match_results&lt;const char*&gt; result;\n            std::regex_match(arg, result, option_matcher);\n            matched = !result.empty();\n\n            ArguDesc argu_desc;\n            if (matched) {\n                argu_desc.arg_name  = result[1].str();\n                argu_desc.set_value = result[2].length() &gt; 0;\n                argu_desc.value     = result[3].str();\n                if (result[4].length() &gt; 0) {\n                    argu_desc.grouping = true;\n                    argu_desc.arg_name = result[4].str();\n                }\n            }\n\n            return argu_desc;\n        }\n\n#endif // CXXOPTS_NO_REGEX\n#undef CXXOPTS_NO_REGEX\n    } // namespace parser_tool\n\n    namespace detail {\n\n        template&lt;typename T, bool B&gt;\n        struct SignedCheck;\n\n        template&lt;typename T&gt;\n        struct SignedCheck&lt;T, true&gt; {\n            template&lt;typename U&gt;\n            void operator()(bool negative, U u, const std::string&amp; text) {\n                if (negative) {\n                    if (u &gt; static_cast&lt;U&gt;((std::numeric_limits&lt;T&gt;::min)())) {\n                        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n                    }\n                } else {\n                    if (u &gt; static_cast&lt;U&gt;((std::numeric_limits&lt;T&gt;::max)())) {\n                        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n                    }\n                }\n            }\n        };\n\n        template&lt;typename T&gt;\n        struct SignedCheck&lt;T, false&gt; {\n            template&lt;typename U&gt;\n            void operator()(bool, U, const std::string&amp;) const { }\n        };\n\n        template&lt;typename T, typename U&gt;\n        void check_signed_range(bool negative, U value, const std::string&amp; text) {\n            SignedCheck&lt;T, std::numeric_limits&lt;T&gt;::is_signed&gt;()(negative, value, text);\n        }\n\n    } // namespace detail\n\n    template&lt;typename R, typename T&gt;\n    void checked_negate(R&amp; r, T&amp;&amp; t, const std::string&amp;, std::true_type) {\n        // if we got to here, then `t` is a positive number that fits into\n        // `R`. So to avoid MSVC C4146, we first cast it to `R`.\n        // See https://github.com/jarro2783/cxxopts/issues/62 for more details.\n        r = static_cast&lt;R&gt;(-static_cast&lt;R&gt;(t - 1) - 1);\n    }\n\n    template&lt;typename R, typename T&gt;\n    void checked_negate(R&amp;, T&amp;&amp;, const std::string&amp; text, std::false_type) {\n        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n    }\n\n    template&lt;typename T&gt;\n    void integer_parser(const std::string&amp; text, T&amp; value) {\n        parser_tool::IntegerDesc int_desc = parser_tool::SplitInteger(text);\n\n        using US                 = typename std::make_unsigned&lt;T&gt;::type;\n        constexpr bool is_signed = std::numeric_limits&lt;T&gt;::is_signed;\n\n        const bool         negative    = int_desc.negative.length() &gt; 0;\n        const uint8_t      base        = int_desc.base.length() &gt; 0 ? 16 : 10;\n        const std::string&amp; value_match = int_desc.value;\n\n        US result = 0;\n\n        for (char ch : value_match) {\n            US digit = 0;\n\n            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {\n                digit = static_cast&lt;US&gt;(ch - '0');\n            } else if (base == 16 &amp;&amp; ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') {\n                digit = static_cast&lt;US&gt;(ch - 'a' + 10);\n            } else if (base == 16 &amp;&amp; ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') {\n                digit = static_cast&lt;US&gt;(ch - 'A' + 10);\n            } else {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            const US next = static_cast&lt;US&gt;(result * base + digit);\n            if (result &gt; next) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            result = next;\n        }\n\n        detail::check_signed_range&lt;T&gt;(negative, result, text);\n\n        if (negative) {\n            checked_negate&lt;T&gt;(value, result, text, std::integral_constant&lt;bool, is_signed&gt;());\n        } else {\n            value = static_cast&lt;T&gt;(result);\n        }\n    }\n\n    template&lt;typename T&gt;\n    void stringstream_parser(const std::string&amp; text, T&amp; value) {\n        std::stringstream in(text);\n        in &gt;&gt; value;\n        if (!in) {\n            throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n        }\n    }\n\n    template&lt;typename T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;\n    void parse_value(const std::string&amp; text, T&amp; value) {\n        integer_parser(text, value);\n    }\n\n    inline void parse_value(const std::string&amp; text, bool&amp; value) {\n        if (parser_tool::IsTrueText(text)) {\n            value = true;\n            return;\n        }\n\n        if (parser_tool::IsFalseText(text)) {\n            value = false;\n            return;\n        }\n\n        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n    }\n\n    inline void parse_value(const std::string&amp; text, std::string&amp; value) {\n        value = text;\n    }\n\n    // The fallback parser. It uses the stringstream parser to parse all types\n    // that have not been overloaded explicitly.  It has to be placed in the\n    // source code before all other more specialized templates.\n    template&lt;typename T, typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;\n    void parse_value(const std::string&amp; text, T&amp; value) {\n        stringstream_parser(text, value);\n    }\n\n    template&lt;typename T&gt;\n    void parse_value(const std::string&amp; text, std::vector&lt;T&gt;&amp; value) {\n        if (text.empty()) {\n            T v;\n            parse_value(text, v);\n            value.emplace_back(std::move(v));\n            return;\n        }\n        std::stringstream in(text);\n        std::string       token;\n        while (!in.eof() &amp;&amp; std::getline(in, token, CXXOPTS_VECTOR_DELIMITER)) {\n            T v;\n            parse_value(token, v);\n            value.emplace_back(std::move(v));\n        }\n    }\n\n#ifdef CXXOPTS_HAS_OPTIONAL\n    template&lt;typename T&gt;\n    void parse_value(const std::string&amp; text, std::optional&lt;T&gt;&amp; value) {\n        T result;\n        parse_value(text, result);\n        value = std::move(result);\n    }\n#endif\n\n    inline void parse_value(const std::string&amp; text, char&amp; c) {\n        if (text.length() != 1) {\n            throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n        }\n\n        c = text[0];\n    }\n\n    template&lt;typename T&gt;\n    struct type_is_container {\n        static constexpr bool value = false;\n    };\n\n    template&lt;typename T&gt;\n    struct type_is_container&lt;std::vector&lt;T&gt;&gt; {\n        static constexpr bool value = true;\n    };\n\n    template&lt;typename T&gt;\n    class abstract_value : public Value {\n        using Self = abstract_value&lt;T&gt;;\n\n    public:\n        abstract_value()\n            : m_result(std::make_shared&lt;T&gt;())\n            , m_store(m_result.get()) { }\n\n        explicit abstract_value(T* t)\n            : m_store(t) { }\n\n        ~abstract_value() override = default;\n\n        abstract_value&amp; operator=(const abstract_value&amp;) = default;\n\n        abstract_value(const abstract_value&amp; rhs) {\n            if (rhs.m_result) {\n                m_result = std::make_shared&lt;T&gt;();\n                m_store  = m_result.get();\n            } else {\n                m_store = rhs.m_store;\n            }\n\n            m_default        = rhs.m_default;\n            m_implicit       = rhs.m_implicit;\n            m_default_value  = rhs.m_default_value;\n            m_implicit_value = rhs.m_implicit_value;\n        }\n\n        void parse(const std::string&amp; text) const override {\n            parse_value(text, *m_store);\n        }\n\n        bool is_container() const override {\n            return type_is_container&lt;T&gt;::value;\n        }\n\n        void parse() const override {\n            parse_value(m_default_value, *m_store);\n        }\n\n        bool has_default() const override {\n            return m_default;\n        }\n\n        bool has_implicit() const override {\n            return m_implicit;\n        }\n\n        std::shared_ptr&lt;Value&gt; default_value(const std::string&amp; value) override {\n            m_default       = true;\n            m_default_value = value;\n            return shared_from_this();\n        }\n\n        std::shared_ptr&lt;Value&gt; implicit_value(const std::string&amp; value) override {\n            m_implicit       = true;\n            m_implicit_value = value;\n            return shared_from_this();\n        }\n\n        std::shared_ptr&lt;Value&gt; no_implicit_value() override {\n            m_implicit = false;\n            return shared_from_this();\n        }\n\n        std::string get_default_value() const override {\n            return m_default_value;\n        }\n\n        std::string get_implicit_value() const override {\n            return m_implicit_value;\n        }\n\n        bool is_boolean() const override {\n            return std::is_same&lt;T, bool&gt;::value;\n        }\n\n        const T&amp; get() const {\n            if (m_store == nullptr) {\n                return *m_result;\n            }\n            return *m_store;\n        }\n\n    protected:\n        std::shared_ptr&lt;T&gt; m_result{};\n        T*                 m_store{};\n\n        bool m_default  = false;\n        bool m_implicit = false;\n\n        std::string m_default_value{};\n        std::string m_implicit_value{};\n    };\n\n    template&lt;typename T&gt;\n    class standard_value : public abstract_value&lt;T&gt; {\n    public:\n        using abstract_value&lt;T&gt;::abstract_value;\n\n        CXXOPTS_NODISCARD\n        std::shared_ptr&lt;Value&gt; clone() const override {\n            return std::make_shared&lt;standard_value&lt;T&gt;&gt;(*this);\n        }\n    };\n\n    template&lt;&gt;\n    class standard_value&lt;bool&gt; : public abstract_value&lt;bool&gt; {\n    public:\n        ~standard_value() override = default;\n\n        standard_value() {\n            set_default_and_implicit();\n        }\n\n        explicit standard_value(bool* b)\n            : abstract_value(b) {\n            m_implicit       = true;\n            m_implicit_value = \"true\";\n        }\n\n        std::shared_ptr&lt;Value&gt; clone() const override {\n            return std::make_shared&lt;standard_value&lt;bool&gt;&gt;(*this);\n        }\n\n    private:\n        void set_default_and_implicit() {\n            m_default        = true;\n            m_default_value  = \"false\";\n            m_implicit       = true;\n            m_implicit_value = \"true\";\n        }\n    };\n\n} // namespace values\n\ntemplate&lt;typename T&gt;\nstd::shared_ptr&lt;Value&gt; value() {\n    return std::make_shared&lt;values::standard_value&lt;T&gt;&gt;();\n}\n\ntemplate&lt;typename T&gt;\nstd::shared_ptr&lt;Value&gt; value(T&amp; t) {\n    return std::make_shared&lt;values::standard_value&lt;T&gt;&gt;(&amp;t);\n}\n\nclass OptionAdder;\n\nCXXOPTS_NODISCARD\ninline const std::string&amp; first_or_empty(const OptionNames&amp; long_names) {\n    static const std::string empty{\"\"};\n    return long_names.empty() ? empty : long_names.front();\n}\n\nclass OptionDetails {\npublic:\n    OptionDetails(std::string short_, OptionNames long_, String desc, std::shared_ptr&lt;const Value&gt; val)\n        : m_short(std::move(short_))\n        , m_long(std::move(long_))\n        , m_desc(std::move(desc))\n        , m_value(std::move(val))\n        , m_count(0) {\n        m_hash = std::hash&lt;std::string&gt;{}(first_long_name() + m_short);\n    }\n\n    OptionDetails(const OptionDetails&amp; rhs)\n        : m_desc(rhs.m_desc)\n        , m_value(rhs.m_value-&gt;clone())\n        , m_count(rhs.m_count) { }\n\n    OptionDetails(OptionDetails&amp;&amp; rhs) = default;\n\n    CXXOPTS_NODISCARD\n    const String&amp; description() const {\n        return m_desc;\n    }\n\n    CXXOPTS_NODISCARD\n    const Value&amp; value() const {\n        return *m_value;\n    }\n\n    CXXOPTS_NODISCARD\n    std::shared_ptr&lt;Value&gt; make_storage() const {\n        return m_value-&gt;clone();\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; short_name() const {\n        return m_short;\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; first_long_name() const {\n        return first_or_empty(m_long);\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; essential_name() const {\n        return m_long.empty() ? m_short : m_long.front();\n    }\n\n    CXXOPTS_NODISCARD\n    const OptionNames&amp; long_names() const {\n        return m_long;\n    }\n\n    std::size_t hash() const {\n        return m_hash;\n    }\n\nprivate:\n    std::string                  m_short{};\n    OptionNames                  m_long{};\n    String                       m_desc{};\n    std::shared_ptr&lt;const Value&gt; m_value{};\n    int                          m_count;\n\n    std::size_t m_hash{};\n};\n\nstruct HelpOptionDetails {\n    std::string s;\n    OptionNames l;\n    String      desc;\n    bool        has_default;\n    std::string default_value;\n    bool        has_implicit;\n    std::string implicit_value;\n    std::string arg_help;\n    bool        is_container;\n    bool        is_boolean;\n};\n\nstruct HelpGroupDetails {\n    std::string                    name{};\n    std::string                    description{};\n    std::vector&lt;HelpOptionDetails&gt; options{};\n};\n\nclass OptionValue {\npublic:\n    void parse(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details, const std::string&amp; text) {\n        ensure_value(details);\n        ++m_count;\n        m_value-&gt;parse(text);\n        m_long_names = &amp;details-&gt;long_names();\n    }\n\n    void parse_default(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        ensure_value(details);\n        m_default    = true;\n        m_long_names = &amp;details-&gt;long_names();\n        m_value-&gt;parse();\n    }\n\n    void parse_no_value(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        m_long_names = &amp;details-&gt;long_names();\n    }\n\n#if defined(CXXOPTS_NULL_DEREF_IGNORE)\n    CXXOPTS_DIAGNOSTIC_PUSH\n    CXXOPTS_IGNORE_WARNING(\"-Wnull-dereference\")\n#endif\n\n    CXXOPTS_NODISCARD\n    std::size_t count() const noexcept {\n        return m_count;\n    }\n\n#if defined(CXXOPTS_NULL_DEREF_IGNORE)\n    CXXOPTS_DIAGNOSTIC_POP\n#endif\n\n    // TODO: maybe default options should count towards the number of arguments\n    CXXOPTS_NODISCARD\n    bool has_default() const noexcept {\n        return m_default;\n    }\n\n    template&lt;typename T&gt;\n    const T&amp; as() const {\n        if (m_value == nullptr) {\n            throw_or_mimic&lt;exceptions::option_has_no_value&gt;(m_long_names == nullptr ? \"\" : first_or_empty(*m_long_names));\n        }\n\n        return CXXOPTS_RTTI_CAST&lt;const values::standard_value&lt;T&gt;&amp;&gt;(*m_value).get();\n    }\n\nprivate:\n    void ensure_value(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        if (m_value == nullptr) {\n            m_value = details-&gt;make_storage();\n        }\n    }\n\n    const OptionNames* m_long_names = nullptr;\n    // Holding this pointer is safe, since OptionValue's only exist in key-value pairs,\n    // where the key has the string we point to.\n    std::shared_ptr&lt;Value&gt; m_value{};\n    std::size_t            m_count   = 0;\n    bool                   m_default = false;\n};\n\nclass KeyValue {\npublic:\n    KeyValue(std::string key_, std::string value_) noexcept\n        : m_key(std::move(key_))\n        , m_value(std::move(value_)) { }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; key() const {\n        return m_key;\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; value() const {\n        return m_value;\n    }\n\n    template&lt;typename T&gt;\n    T as() const {\n        T result;\n        values::parse_value(m_value, result);\n        return result;\n    }\n\nprivate:\n    std::string m_key;\n    std::string m_value;\n};\n\nusing ParsedHashMap = std::unordered_map&lt;std::size_t, OptionValue&gt;;\nusing NameHashMap   = std::unordered_map&lt;std::string, std::size_t&gt;;\n\nclass ParseResult {\npublic:\n    class Iterator {\n    public:\n        using iterator_category = std::forward_iterator_tag;\n        using value_type        = KeyValue;\n        using difference_type   = void;\n        using pointer           = const KeyValue*;\n        using reference         = const KeyValue&amp;;\n\n        Iterator()                = default;\n        Iterator(const Iterator&amp;) = default;\n\n        // GCC complains about m_iter not being initialised in the member\n        // initializer list\n        CXXOPTS_DIAGNOSTIC_PUSH\n        CXXOPTS_IGNORE_WARNING(\"-Weffc++\")\n\n        Iterator(const ParseResult* pr, bool end = false)\n            : m_pr(pr) {\n            if (end) {\n                m_sequential = false;\n                m_iter       = m_pr-&gt;m_defaults.end();\n            } else {\n                m_sequential = true;\n                m_iter       = m_pr-&gt;m_sequential.begin();\n\n                if (m_iter == m_pr-&gt;m_sequential.end()) {\n                    m_sequential = false;\n                    m_iter       = m_pr-&gt;m_defaults.begin();\n                }\n            }\n        }\n\n        CXXOPTS_DIAGNOSTIC_POP\n\n        Iterator&amp; operator++() {\n            ++m_iter;\n            if (m_sequential &amp;&amp; m_iter == m_pr-&gt;m_sequential.end()) {\n                m_sequential = false;\n                m_iter       = m_pr-&gt;m_defaults.begin();\n                return *this;\n            }\n            return *this;\n        }\n\n        Iterator operator++(int) {\n            Iterator retval = *this;\n            ++(*this);\n            return retval;\n        }\n\n        bool operator==(const Iterator&amp; other) const {\n            return (m_sequential == other.m_sequential) &amp;&amp; (m_iter == other.m_iter);\n        }\n\n        bool operator!=(const Iterator&amp; other) const {\n            return !(*this == other);\n        }\n\n        const KeyValue&amp; operator*() {\n            return *m_iter;\n        }\n\n        const KeyValue* operator-&gt;() {\n            return m_iter.operator-&gt;();\n        }\n\n    private:\n        const ParseResult*                    m_pr;\n        std::vector&lt;KeyValue&gt;::const_iterator m_iter;\n        bool                                  m_sequential = true;\n    };\n\n    ParseResult()                   = default;\n    ParseResult(const ParseResult&amp;) = default;\n\n    ParseResult(NameHashMap&amp;&amp; keys, ParsedHashMap&amp;&amp; values, std::vector&lt;KeyValue&gt; sequential,\n                std::vector&lt;KeyValue&gt; default_opts, std::vector&lt;std::string&gt;&amp;&amp; unmatched_args)\n        : m_keys(std::move(keys))\n        , m_values(std::move(values))\n        , m_sequential(std::move(sequential))\n        , m_defaults(std::move(default_opts))\n        , m_unmatched(std::move(unmatched_args)) { }\n\n    ParseResult&amp; operator=(ParseResult&amp;&amp;)      = default;\n    ParseResult&amp; operator=(const ParseResult&amp;) = default;\n\n    Iterator begin() const {\n        return Iterator(this);\n    }\n\n    Iterator end() const {\n        return Iterator(this, true);\n    }\n\n    std::size_t count(const std::string&amp; o) const {\n        auto iter = m_keys.find(o);\n        if (iter == m_keys.end()) {\n            return 0;\n        }\n\n        auto viter = m_values.find(iter-&gt;second);\n\n        if (viter == m_values.end()) {\n            return 0;\n        }\n\n        return viter-&gt;second.count();\n    }\n\n    const OptionValue&amp; operator[](const std::string&amp; option) const {\n        auto iter = m_keys.find(option);\n\n        if (iter == m_keys.end()) {\n            throw_or_mimic&lt;exceptions::requested_option_not_present&gt;(option);\n        }\n\n        auto viter = m_values.find(iter-&gt;second);\n\n        if (viter == m_values.end()) {\n            throw_or_mimic&lt;exceptions::requested_option_not_present&gt;(option);\n        }\n\n        return viter-&gt;second;\n    }\n\n    const std::vector&lt;KeyValue&gt;&amp; arguments() const {\n        return m_sequential;\n    }\n\n    const std::vector&lt;std::string&gt;&amp; unmatched() const {\n        return m_unmatched;\n    }\n\n    const std::vector&lt;KeyValue&gt;&amp; defaults() const {\n        return m_defaults;\n    }\n\n    const std::string arguments_string() const {\n        std::string result;\n        for (const auto&amp; kv : m_sequential) {\n            result += kv.key() + \" = \" + kv.value() + \"\\n\";\n        }\n        for (const auto&amp; kv : m_defaults) {\n            result += kv.key() + \" = \" + kv.value() + \" \" + \"(default)\" + \"\\n\";\n        }\n        return result;\n    }\n\nprivate:\n    NameHashMap              m_keys{};\n    ParsedHashMap            m_values{};\n    std::vector&lt;KeyValue&gt;    m_sequential{};\n    std::vector&lt;KeyValue&gt;    m_defaults{};\n    std::vector&lt;std::string&gt; m_unmatched{};\n};\n\nstruct Option {\n    Option(std::string opts, std::string desc, std::shared_ptr&lt;const Value&gt; value = ::cxxopts::value&lt;bool&gt;(),\n           std::string arg_help = \"\")\n        : opts_(std::move(opts))\n        , desc_(std::move(desc))\n        , value_(std::move(value))\n        , arg_help_(std::move(arg_help)) { }\n\n    std::string                  opts_;\n    std::string                  desc_;\n    std::shared_ptr&lt;const Value&gt; value_;\n    std::string                  arg_help_;\n};\n\nusing OptionMap              = std::unordered_map&lt;std::string, std::shared_ptr&lt;OptionDetails&gt;&gt;;\nusing PositionalList         = std::vector&lt;std::string&gt;;\nusing PositionalListIterator = PositionalList::const_iterator;\n\nclass OptionParser {\npublic:\n    OptionParser(const OptionMap&amp; options, const PositionalList&amp; positional, bool allow_unrecognised)\n        : m_options(options)\n        , m_positional(positional)\n        , m_allow_unrecognised(allow_unrecognised) { }\n\n    ParseResult parse(int argc, const char* const* argv);\n\n    bool consume_positional(const std::string&amp; a, PositionalListIterator&amp; next);\n\n    void checked_parse_arg(int argc, const char* const* argv, int&amp; current, const std::shared_ptr&lt;OptionDetails&gt;&amp; value,\n                           const std::string&amp; name);\n\n    void add_to_option(OptionMap::const_iterator iter, const std::string&amp; option, const std::string&amp; arg);\n\n    void parse_option(const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; name, const std::string&amp; arg = \"\");\n\n    void parse_default(const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\n    void parse_no_value(const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\nprivate:\n    void finalise_aliases();\n\n    const OptionMap&amp;      m_options;\n    const PositionalList&amp; m_positional;\n\n    std::vector&lt;KeyValue&gt; m_sequential{};\n    std::vector&lt;KeyValue&gt; m_defaults{};\n    bool                  m_allow_unrecognised;\n\n    ParsedHashMap m_parsed{};\n    NameHashMap   m_keys{};\n};\n\nclass Options {\npublic:\n    explicit Options(std::string program_name, std::string help_string = \"\")\n        : m_program(std::move(program_name))\n        , m_help_string(toLocalString(std::move(help_string)))\n        , m_custom_help(\"[OPTION...]\")\n        , m_positional_help(\"positional parameters\")\n        , m_show_positional(false)\n        , m_allow_unrecognised(false)\n        , m_width(76)\n        , m_tab_expansion(false)\n        , m_options(std::make_shared&lt;OptionMap&gt;()) { }\n\n    Options&amp; positional_help(std::string help_text) {\n        m_positional_help = std::move(help_text);\n        return *this;\n    }\n\n    Options&amp; custom_help(std::string help_text) {\n        m_custom_help = std::move(help_text);\n        return *this;\n    }\n\n    Options&amp; show_positional_help() {\n        m_show_positional = true;\n        return *this;\n    }\n\n    Options&amp; allow_unrecognised_options() {\n        m_allow_unrecognised = true;\n        return *this;\n    }\n\n    Options&amp; set_width(std::size_t width) {\n        m_width = width;\n        return *this;\n    }\n\n    Options&amp; set_tab_expansion(bool expansion = true) {\n        m_tab_expansion = expansion;\n        return *this;\n    }\n\n    ParseResult parse(int argc, const char* const* argv);\n\n    OptionAdder add_options(std::string group = \"\");\n\n    void add_options(const std::string&amp; group, std::initializer_list&lt;Option&gt; options);\n\n    void add_option(const std::string&amp; group, const Option&amp; option);\n\n    void add_option(const std::string&amp; group, const std::string&amp; s, const OptionNames&amp; l, std::string desc,\n                    const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help);\n\n    void add_option(const std::string&amp; group, const std::string&amp; short_name, const std::string&amp; single_long_name,\n                    std::string desc, const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n        OptionNames long_names;\n        long_names.emplace_back(single_long_name);\n        add_option(group, short_name, long_names, desc, value, arg_help);\n    }\n\n    // parse positional arguments into the given option\n    void parse_positional(std::string option);\n\n    void parse_positional(std::vector&lt;std::string&gt; options);\n\n    void parse_positional(std::initializer_list&lt;std::string&gt; options);\n\n    template&lt;typename Iterator&gt;\n    void parse_positional(Iterator begin, Iterator end) {\n        parse_positional(std::vector&lt;std::string&gt;{begin, end});\n    }\n\n    std::string help(const std::vector&lt;std::string&gt;&amp; groups = {}, bool print_usage = true) const;\n\n    std::vector&lt;std::string&gt; groups() const;\n\n    const HelpGroupDetails&amp; group_help(const std::string&amp; group) const;\n\n    const std::string&amp; program() const {\n        return m_program;\n    }\n\nprivate:\n    void add_one_option(const std::string&amp; option, const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\n    String help_one_group(const std::string&amp; group) const;\n\n    void generate_group_help(String&amp; result, const std::vector&lt;std::string&gt;&amp; groups) const;\n\n    void generate_all_groups_help(String&amp; result) const;\n\n    std::string m_program{};\n    String      m_help_string{};\n    std::string m_custom_help{};\n    std::string m_positional_help{};\n    bool        m_show_positional;\n    bool        m_allow_unrecognised;\n    std::size_t m_width;\n    bool        m_tab_expansion;\n\n    std::shared_ptr&lt;OptionMap&gt;      m_options;\n    std::vector&lt;std::string&gt;        m_positional{};\n    std::unordered_set&lt;std::string&gt; m_positional_set{};\n\n    // mapping from groups to help options\n    std::map&lt;std::string, HelpGroupDetails&gt; m_help{};\n};\n\nclass OptionAdder {\npublic:\n    OptionAdder(Options&amp; options, std::string group)\n        : m_options(options)\n        , m_group(std::move(group)) { }\n\n    OptionAdder&amp; operator()(const std::string&amp; opts, const std::string&amp; desc,\n                            const std::shared_ptr&lt;const Value&gt;&amp; value = ::cxxopts::value&lt;bool&gt;(), std::string arg_help = \"\");\n\nprivate:\n    Options&amp;    m_options;\n    std::string m_group;\n};\n\nnamespace {\n    constexpr std::size_t OPTION_LONGEST  = 30;\n    constexpr std::size_t OPTION_DESC_GAP = 2;\n\n    String format_option(const HelpOptionDetails&amp; o) {\n        const auto&amp; s = o.s;\n        const auto&amp; l = first_or_empty(o.l);\n\n        String result = \"  \";\n\n        if (!s.empty()) {\n            result += \"-\" + toLocalString(s);\n            if (!l.empty()) {\n                result += \",\";\n            }\n        } else {\n            result += \"   \";\n        }\n\n        if (!l.empty()) {\n            result += \" --\" + toLocalString(l);\n        }\n\n        auto arg = !o.arg_help.empty() ? toLocalString(o.arg_help) : \"arg\";\n\n        if (!o.is_boolean) {\n            if (o.has_implicit) {\n                result += \" [=\" + arg + \"(=\" + toLocalString(o.implicit_value) + \")]\";\n            } else {\n                result += \" \" + arg;\n            }\n        }\n\n        return result;\n    }\n\n    String format_description(const HelpOptionDetails&amp; o, std::size_t start, std::size_t allowed, bool tab_expansion) {\n        auto desc = o.desc;\n\n        if (o.has_default &amp;&amp; (!o.is_boolean || o.default_value != \"false\")) {\n            if (!o.default_value.empty()) {\n                desc += toLocalString(\" (default: \" + o.default_value + \")\");\n            } else {\n                desc += toLocalString(\" (default: \\\"\\\")\");\n            }\n        }\n\n        String result;\n\n        if (tab_expansion) {\n            String desc2;\n            auto   size = std::size_t{0};\n            for (auto c = std::begin(desc); c != std::end(desc); ++c) {\n                if (*c == '\\n') {\n                    desc2 += *c;\n                    size = 0;\n                } else if (*c == '\\t') {\n                    auto skip = 8 - size % 8;\n                    stringAppend(desc2, skip, ' ');\n                    size += skip;\n                } else {\n                    desc2 += *c;\n                    ++size;\n                }\n            }\n            desc = desc2;\n        }\n\n        desc += \" \";\n\n        auto current   = std::begin(desc);\n        auto previous  = current;\n        auto startLine = current;\n        auto lastSpace = current;\n\n        auto size = std::size_t{};\n\n        bool appendNewLine;\n        bool onlyWhiteSpace = true;\n\n        while (current != std::end(desc)) {\n            appendNewLine = false;\n            if (*previous == ' ' || *previous == '\\t') {\n                lastSpace = current;\n            }\n            if (*current != ' ' &amp;&amp; *current != '\\t') {\n                onlyWhiteSpace = false;\n            }\n\n            while (*current == '\\n') {\n                previous = current;\n                ++current;\n                appendNewLine = true;\n            }\n\n            if (!appendNewLine &amp;&amp; size &gt;= allowed) {\n                if (lastSpace != startLine) {\n                    current  = lastSpace;\n                    previous = current;\n                }\n                appendNewLine = true;\n            }\n\n            if (appendNewLine) {\n                stringAppend(result, startLine, current);\n                startLine = current;\n                lastSpace = current;\n\n                if (*previous != '\\n') {\n                    stringAppend(result, \"\\n\");\n                }\n\n                stringAppend(result, start, ' ');\n\n                if (*previous != '\\n') {\n                    stringAppend(result, lastSpace, current);\n                }\n\n                onlyWhiteSpace = true;\n                size           = 0;\n            }\n\n            previous = current;\n            ++current;\n            ++size;\n        }\n\n        // append whatever is left but ignore whitespace\n        if (!onlyWhiteSpace) {\n            stringAppend(result, startLine, previous);\n        }\n\n        return result;\n    }\n\n} // namespace\n\ninline void Options::add_options(const std::string&amp; group, std::initializer_list&lt;Option&gt; options) {\n    OptionAdder option_adder(*this, group);\n    for (const auto&amp; option : options) {\n        option_adder(option.opts_, option.desc_, option.value_, option.arg_help_);\n    }\n}\n\ninline OptionAdder Options::add_options(std::string group) {\n    return OptionAdder(*this, std::move(group));\n}\n\ninline OptionAdder&amp; OptionAdder::operator()(const std::string&amp; opts, const std::string&amp; desc,\n                                            const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n    OptionNames option_names = values::parser_tool::split_option_names(opts);\n    // Note: All names will be non-empty; but we must separate the short\n    // (length-1) and longer names\n    std::string short_name{\"\"};\n    auto        first_short_name_iter = std::partition(option_names.begin(), option_names.end(), [&amp;](const std::string&amp; name) {\n        return name.length() &gt; 1;\n    });\n    auto        num_length_1_names    = (option_names.end() - first_short_name_iter);\n    switch (num_length_1_names) {\n    case 1:\n        short_name = *first_short_name_iter;\n        option_names.erase(first_short_name_iter);\n    case 0:\n        break;\n    default:\n        throw_or_mimic&lt;exceptions::invalid_option_format&gt;(opts);\n    };\n\n    m_options.add_option(m_group, short_name, option_names, desc, value, std::move(arg_help));\n\n    return *this;\n}\n\ninline void OptionParser::parse_default(const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    // TODO: remove the duplicate code here\n    auto&amp; store = m_parsed[details-&gt;hash()];\n    store.parse_default(details);\n    m_defaults.emplace_back(details-&gt;essential_name(), details-&gt;value().get_default_value());\n}\n\ninline void OptionParser::parse_no_value(const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    auto&amp; store = m_parsed[details-&gt;hash()];\n    store.parse_no_value(details);\n}\n\ninline void OptionParser::parse_option(const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; /*name*/,\n                                       const std::string&amp;                    arg) {\n    auto  hash   = value-&gt;hash();\n    auto&amp; result = m_parsed[hash];\n    result.parse(value, arg);\n\n    m_sequential.emplace_back(value-&gt;essential_name(), arg);\n}\n\ninline void OptionParser::checked_parse_arg(int argc, const char* const* argv, int&amp; current,\n                                            const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; name) {\n    if (current + 1 &gt;= argc) {\n        if (value-&gt;value().has_implicit()) {\n            parse_option(value, name, value-&gt;value().get_implicit_value());\n        } else {\n            throw_or_mimic&lt;exceptions::missing_argument&gt;(name);\n        }\n    } else {\n        if (value-&gt;value().has_implicit()) {\n            parse_option(value, name, value-&gt;value().get_implicit_value());\n        } else {\n            parse_option(value, name, argv[current + 1]);\n            ++current;\n        }\n    }\n}\n\ninline void OptionParser::add_to_option(OptionMap::const_iterator iter, const std::string&amp; option, const std::string&amp; arg) {\n    parse_option(iter-&gt;second, option, arg);\n}\n\ninline bool OptionParser::consume_positional(const std::string&amp; a, PositionalListIterator&amp; next) {\n    while (next != m_positional.end()) {\n        auto iter = m_options.find(*next);\n        if (iter != m_options.end()) {\n            if (!iter-&gt;second-&gt;value().is_container()) {\n                auto&amp; result = m_parsed[iter-&gt;second-&gt;hash()];\n                if (result.count() == 0) {\n                    add_to_option(iter, *next, a);\n                    ++next;\n                    return true;\n                }\n                ++next;\n                continue;\n            }\n            add_to_option(iter, *next, a);\n            return true;\n        }\n        throw_or_mimic&lt;exceptions::no_such_option&gt;(*next);\n    }\n\n    return false;\n}\n\ninline void Options::parse_positional(std::string option) {\n    parse_positional(std::vector&lt;std::string&gt;{std::move(option)});\n}\n\ninline void Options::parse_positional(std::vector&lt;std::string&gt; options) {\n    m_positional = std::move(options);\n\n    m_positional_set.insert(m_positional.begin(), m_positional.end());\n}\n\ninline void Options::parse_positional(std::initializer_list&lt;std::string&gt; options) {\n    parse_positional(std::vector&lt;std::string&gt;(options));\n}\n\ninline ParseResult Options::parse(int argc, const char* const* argv) {\n    OptionParser parser(*m_options, m_positional, m_allow_unrecognised);\n\n    return parser.parse(argc, argv);\n}\n\ninline ParseResult OptionParser::parse(int argc, const char* const* argv) {\n    int  current           = 1;\n    bool consume_remaining = false;\n    auto next_positional   = m_positional.begin();\n\n    std::vector&lt;std::string&gt; unmatched;\n\n    while (current != argc) {\n        if (strcmp(argv[current], \"--\") == 0) {\n            consume_remaining = true;\n            ++current;\n            break;\n        }\n        bool                          matched   = false;\n        values::parser_tool::ArguDesc argu_desc = values::parser_tool::ParseArgument(argv[current], matched);\n\n        if (!matched) {\n            // not a flag\n\n            // but if it starts with a `-`, then it's an error\n            if (argv[current][0] == '-' &amp;&amp; argv[current][1] != '\\0') {\n                if (!m_allow_unrecognised) {\n                    throw_or_mimic&lt;exceptions::invalid_option_syntax&gt;(argv[current]);\n                }\n            }\n\n            // if true is returned here then it was consumed, otherwise it is\n            // ignored\n            if (consume_positional(argv[current], next_positional)) {\n            } else {\n                unmatched.emplace_back(argv[current]);\n            }\n            // if we return from here then it was parsed successfully, so continue\n        } else {\n            // short or long option?\n            if (argu_desc.grouping) {\n                const std::string&amp; s = argu_desc.arg_name;\n\n                for (std::size_t i = 0; i != s.size(); ++i) {\n                    std::string name(1, s[i]);\n                    auto        iter = m_options.find(name);\n\n                    if (iter == m_options.end()) {\n                        if (m_allow_unrecognised) {\n                            unmatched.push_back(std::string(\"-\") + s[i]);\n                            continue;\n                        }\n                        // error\n                        throw_or_mimic&lt;exceptions::no_such_option&gt;(name);\n                    }\n\n                    auto value = iter-&gt;second;\n\n                    if (i + 1 == s.size()) {\n                        // it must be the last argument\n                        checked_parse_arg(argc, argv, current, value, name);\n                    } else if (value-&gt;value().has_implicit()) {\n                        parse_option(value, name, value-&gt;value().get_implicit_value());\n                    } else if (i + 1 &lt; s.size()) {\n                        std::string arg_value = s.substr(i + 1);\n                        parse_option(value, name, arg_value);\n                        break;\n                    } else {\n                        // error\n                        throw_or_mimic&lt;exceptions::option_requires_argument&gt;(name);\n                    }\n                }\n            } else if (argu_desc.arg_name.length() != 0) {\n                const std::string&amp; name = argu_desc.arg_name;\n\n                auto iter = m_options.find(name);\n\n                if (iter == m_options.end()) {\n                    if (m_allow_unrecognised) {\n                        // keep unrecognised options in argument list, skip to next argument\n                        unmatched.emplace_back(argv[current]);\n                        ++current;\n                        continue;\n                    }\n                    // error\n                    throw_or_mimic&lt;exceptions::no_such_option&gt;(name);\n                }\n\n                auto opt = iter-&gt;second;\n\n                // equals provided for long option?\n                if (argu_desc.set_value) {\n                    // parse the option given\n\n                    parse_option(opt, name, argu_desc.value);\n                } else {\n                    // parse the next argument\n                    checked_parse_arg(argc, argv, current, opt, name);\n                }\n            }\n        }\n\n        ++current;\n    }\n\n    for (auto&amp; opt : m_options) {\n        auto&amp;       detail = opt.second;\n        const auto&amp; value  = detail-&gt;value();\n\n        auto&amp; store = m_parsed[detail-&gt;hash()];\n\n        if (value.has_default()) {\n            if (!store.count() &amp;&amp; !store.has_default()) {\n                parse_default(detail);\n            }\n        } else {\n            parse_no_value(detail);\n        }\n    }\n\n    if (consume_remaining) {\n        while (current &lt; argc) {\n            if (!consume_positional(argv[current], next_positional)) {\n                break;\n            }\n            ++current;\n        }\n\n        // adjust argv for any that couldn't be swallowed\n        while (current != argc) {\n            unmatched.emplace_back(argv[current]);\n            ++current;\n        }\n    }\n\n    finalise_aliases();\n\n    ParseResult parsed(std::move(m_keys), std::move(m_parsed), std::move(m_sequential), std::move(m_defaults),\n                       std::move(unmatched));\n    return parsed;\n}\n\ninline void OptionParser::finalise_aliases() {\n    for (auto&amp; option : m_options) {\n        auto&amp; detail                = *option.second;\n        auto  hash                  = detail.hash();\n        m_keys[detail.short_name()] = hash;\n        for (const auto&amp; long_name : detail.long_names()) {\n            m_keys[long_name] = hash;\n        }\n\n        m_parsed.emplace(hash, OptionValue());\n    }\n}\n\ninline void Options::add_option(const std::string&amp; group, const Option&amp; option) {\n    add_options(group, {option});\n}\n\ninline void Options::add_option(const std::string&amp; group, const std::string&amp; s, const OptionNames&amp; l, std::string desc,\n                                const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n    auto stringDesc = toLocalString(std::move(desc));\n    auto option     = std::make_shared&lt;OptionDetails&gt;(s, l, stringDesc, value);\n\n    if (!s.empty()) {\n        add_one_option(s, option);\n    }\n\n    for (const auto&amp; long_name : l) {\n        add_one_option(long_name, option);\n    }\n\n    // add the help details\n    auto&amp; options = m_help[group];\n\n    options.options.emplace_back(HelpOptionDetails{s, l, stringDesc, value-&gt;has_default(), value-&gt;get_default_value(),\n                                                   value-&gt;has_implicit(), value-&gt;get_implicit_value(), std::move(arg_help),\n                                                   value-&gt;is_container(), value-&gt;is_boolean()});\n}\n\ninline void Options::add_one_option(const std::string&amp; option, const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    auto in = m_options-&gt;emplace(option, details);\n\n    if (!in.second) {\n        throw_or_mimic&lt;exceptions::option_already_exists&gt;(option);\n    }\n}\n\ninline String Options::help_one_group(const std::string&amp; g) const {\n    using OptionHelp = std::vector&lt;std::pair&lt;String, String&gt;&gt;;\n\n    auto group = m_help.find(g);\n    if (group == m_help.end()) {\n        return \"\";\n    }\n\n    OptionHelp format;\n\n    std::size_t longest = 0;\n\n    String result;\n\n    if (!g.empty()) {\n        result += toLocalString(\" \" + g + \" options:\\n\");\n    }\n\n    for (const auto&amp; o : group-&gt;second.options) {\n        if (o.l.size() &amp;&amp; m_positional_set.find(o.l.front()) != m_positional_set.end() &amp;&amp; !m_show_positional) {\n            continue;\n        }\n\n        auto s  = format_option(o);\n        longest = (std::max)(longest, stringLength(s));\n        format.push_back(std::make_pair(s, String()));\n    }\n    longest = (std::min)(longest, OPTION_LONGEST);\n\n    // widest allowed description -- min 10 chars for helptext/line\n    std::size_t allowed = 10;\n    if (m_width &gt; allowed + longest + OPTION_DESC_GAP) {\n        allowed = m_width - longest - OPTION_DESC_GAP;\n    }\n\n    auto fiter = format.begin();\n    for (const auto&amp; o : group-&gt;second.options) {\n        if (o.l.size() &amp;&amp; m_positional_set.find(o.l.front()) != m_positional_set.end() &amp;&amp; !m_show_positional) {\n            continue;\n        }\n\n        auto d = format_description(o, longest + OPTION_DESC_GAP, allowed, m_tab_expansion);\n\n        result += fiter-&gt;first;\n        if (stringLength(fiter-&gt;first) &gt; longest) {\n            result += '\\n';\n            result += toLocalString(std::string(longest + OPTION_DESC_GAP, ' '));\n        } else {\n            result += toLocalString(std::string(longest + OPTION_DESC_GAP - stringLength(fiter-&gt;first), ' '));\n        }\n        result += d;\n        result += '\\n';\n\n        ++fiter;\n    }\n\n    return result;\n}\n\ninline void Options::generate_group_help(String&amp; result, const std::vector&lt;std::string&gt;&amp; print_groups) const {\n    for (std::size_t i = 0; i != print_groups.size(); ++i) {\n        const String&amp; group_help_text = help_one_group(print_groups[i]);\n        if (empty(group_help_text)) {\n            continue;\n        }\n        result += group_help_text;\n        if (i &lt; print_groups.size() - 1) {\n            result += '\\n';\n        }\n    }\n}\n\ninline void Options::generate_all_groups_help(String&amp; result) const {\n    std::vector&lt;std::string&gt; all_groups;\n\n    std::transform(m_help.begin(), m_help.end(), std::back_inserter(all_groups),\n                   [](const std::map&lt;std::string, HelpGroupDetails&gt;::value_type&amp; group) {\n                       return group.first;\n                   });\n\n    generate_group_help(result, all_groups);\n}\n\ninline std::string Options::help(const std::vector&lt;std::string&gt;&amp; help_groups, bool print_usage) const {\n    String result = m_help_string;\n    if (print_usage) {\n        result += \"\\nUsage:\\n  \" + toLocalString(m_program);\n    }\n\n    if (!m_custom_help.empty()) {\n        result += \" \" + toLocalString(m_custom_help);\n    }\n\n    if (!m_positional.empty() &amp;&amp; !m_positional_help.empty()) {\n        result += \" \" + toLocalString(m_positional_help);\n    }\n\n    result += \"\\n\\n\";\n\n    if (help_groups.empty()) {\n        generate_all_groups_help(result);\n    } else {\n        generate_group_help(result, help_groups);\n    }\n\n    return toUTF8String(result);\n}\n\ninline std::vector&lt;std::string&gt; Options::groups() const {\n    std::vector&lt;std::string&gt; g;\n\n    std::transform(m_help.begin(), m_help.end(), std::back_inserter(g),\n                   [](const std::map&lt;std::string, HelpGroupDetails&gt;::value_type&amp; pair) {\n                       return pair.first;\n                   });\n\n    return g;\n}\n\ninline const HelpGroupDetails&amp; Options::group_help(const std::string&amp; group) const {\n    return m_help.at(group);\n}\n\n} // namespace cxxopts\n\n#endif // CXXOPTS_HPP_INCLUDED\n</code></pre>"},{"location":"api/plugins_2zed_2data__injection_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/plugins_2zed_2data__injection_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.zed.data_injection${ILLIXR_BUILD_SUFFIX})"},{"location":"api/plugins_2zed_2data__injection_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/plugins_2zed_2data__injection_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.zed.data_injection${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/data_injection/CMakeLists.txt</code></p>"},{"location":"api/plugins_2zed_2data__injection_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># To add compiler flags for debugging, uncomment the lines below.\n# SET(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -fsanitize=thread\")\n# SET(CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=thread\")\n\nCMAKE_MINIMUM_REQUIRED(VERSION 3.16)\n\nset(PLUGIN_NAME plugin.zed.data_injection${ILLIXR_BUILD_SUFFIX})\n\nset(SRC_FILES plugin.cpp\n    plugin.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/opencv_data_types.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n)\n\nadd_library(${PLUGIN_NAME} SHARED ${SRC_FILES})\n\nif(BUILD_OPENCV)\n    add_dependencies(${PLUGIN_NAME} OpenCV_Viz)\nendif()\n\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${OpenCV_INCLUDE_DIRS} ${Eigen3_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/include)\n\ntarget_link_libraries(${PLUGIN_NAME} ${OpenCV_LIBRARIES} ${Eigen3_LIBRARIES} Threads::Threads spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/plugins_2zed_2data__injection_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/data_injection/README.md</code></p>"},{"location":"api/plugins_2zed_2data__injection_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># ZED Data Injection\n\nThis plugin reads in binocular images and pose information from files on disk and publishes them to ILLIXR. It is\ndesigned to feed data recorded by the zed_capture binary into the ILLIXR system. The root directory of the data\nmust be specified in the `ILLIXR_TEST_DATA` environment variable.\n</code></pre>"},{"location":"api/plugins_2zed_2data__injection_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; data_injection &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;opencv2/imgcodecs.hpp&gt;</code></li> <li><code>#include &lt;opencv2/imgproc.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/data_injection/plugin.cpp</code></p>"},{"location":"api/plugins_2zed_2data__injection_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; data_injection &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include &lt;filesystem&gt;\n#include &lt;fstream&gt;\n#include &lt;opencv2/imgcodecs.hpp&gt;\n#include &lt;opencv2/imgproc.hpp&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nvoid data_injection::read_cam_data() {\n    char          comma;\n    std::ifstream data(data_root_path_ + \"data/cam.csv\", std::ifstream::in);\n    size_t        w, h;\n    std::string   line;\n    float         fps, bl, lcx, lcy, lvf, lhf, rcx, rcy, rvf, rhf;\n    data &gt;&gt; line; // get header\n    data &gt;&gt; w &gt;&gt; comma &gt;&gt; h &gt;&gt; comma &gt;&gt; fps &gt;&gt; comma &gt;&gt; bl &gt;&gt; comma &gt;&gt; lcx &gt;&gt; comma &gt;&gt; lcy &gt;&gt; comma &gt;&gt; lvf &gt;&gt; comma &gt;&gt; lhf &gt;&gt;\n        comma &gt;&gt; rcx &gt;&gt; comma &gt;&gt; rcy &gt;&gt; comma &gt;&gt; rvf &gt;&gt; comma &gt;&gt; rhf;\n\n    data.close();\n    ccd_map cmap = {{units::LEFT_EYE, {lcx, lcy, lvf, lhf}}, {units::RIGHT_EYE, {rcx, rcy, rvf, rhf}}};\n    camera_data_ = {w, h, fps, bl, units::MILLIMETER, cmap};\n}\n\nvoid data_injection::read_poses() {\n    std::string   line;\n    char          comma;\n    auto          temp = data_root_path_ + \"data/data.csv\";\n    std::ifstream data(temp, std::ifstream::in);\n    data &gt;&gt; line; // get header\n    uint64_t t, tt;\n    float    tx, ty, tz, w, x, y, z;\n    base_time_ = 0;\n    while (data) {\n        data &gt;&gt; tt &gt;&gt; comma &gt;&gt; tx &gt;&gt; comma &gt;&gt; ty &gt;&gt; comma &gt;&gt; tz &gt;&gt; comma &gt;&gt; w &gt;&gt; comma &gt;&gt; x &gt;&gt; comma &gt;&gt; y &gt;&gt; comma &gt;&gt; z;\n        if (base_time_ == 0)\n            base_time_ = tt - 1;\n        t = tt - base_time_;\n        timepoints_.push_back(t);\n        poses_[t] = new pose_data(Eigen::Vector3f{tx, ty, tx}, Eigen::Quaternionf{w, x, y, z}, units::MILLIMETER,\n                                  coordinates::RIGHT_HANDED_Y_UP, coordinates::WORLD, 1.);\n    }\n}\n\nvoid data_injection::load_images_on_the_fly() {\n    data_injection::images_.clear();\n    std::string f_root = std::to_string(base_time_ + timepoints_[current_]);\n    std::string temp   = data_root_path_ + \"imgs/camL/\" + f_root + \".png\";\n    cv::Mat     tempi;\n    if (std::filesystem::exists(data_root_path_ + \"imgs/camL/\" + f_root + \".png\")) {\n        tempi = cv::imread(temp); // data_root_path_ + \"imgs/camL/\" + f_root + \".png\");\n        cv::cvtColor(tempi, tempi, cv::COLOR_BGR2RGB);\n        images_[image::LEFT_EYE] = tempi.clone();\n    } else {\n        std::cout &lt;&lt; \"FAIL \" &lt;&lt; f_root &lt;&lt; std::endl;\n    }\n    temp = data_root_path_ + \"imgs/camR/\" + f_root + \".png\";\n    if (std::filesystem::exists(data_root_path_ + \"imgs/camR/\" + f_root + \".png\")) {\n        tempi = cv::imread(temp);\n        cv::cvtColor(tempi, tempi, cv::COLOR_BGR2RGB);\n        images_[image::RIGHT_EYE] = tempi.clone();\n    }\n}\n\ndata_injection::data_injection(const std::string&amp; name_, phonebook* pb_)\n    : threadloop{name_, pb_}\n    , switchboard_{pb_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , frame_img_writer_{switchboard_-&gt;get_writer&lt;binocular_cam_type&gt;(\"cam\")}\n    , frame_pose_writer_{switchboard_-&gt;get_writer&lt;pose_type&gt;(\"pose\")}\n    , camera_data_writer_{switchboard_-&gt;get_writer&lt;camera_data&gt;(\"cam_data\")}\n    , counter_{0} {\n    std::string test_data_root = switchboard_-&gt;get_env(\"ILLIXR_TEST_DATA\");\n    if (test_data_root.empty())\n        throw std::runtime_error(\"No test data root specified\");\n    std::string test_data_root_str(test_data_root);\n    data_root_path_ = test_data_root_str + \"/\";\n    read_cam_data();\n    read_poses();\n    current_ = 0;\n    offset_  = 0;\n    step_    = timepoints_[1] - timepoints_[0];\n}\n\nvoid data_injection::start() {\n    threadloop::start();\n    camera_data_writer_.put(camera_data_writer_.allocate&lt;camera_data&gt;(camera_data{camera_data_}));\n}\n\ndata_injection::~data_injection() {\n    timepoints_.clear();\n    for (auto p : poses_)\n        delete p.second;\n    poses_.clear();\n    images_.clear();\n    threadloop::~threadloop();\n}\n\nvoid data_injection::_p_one_iteration() {\n    load_images_on_the_fly();\n    frame_img_writer_.put(frame_img_writer_.allocate&lt;binocular_cam_type&gt;(\n        binocular_cam_type{time_point{clock_duration_(timepoints_[current_] + offset_)}, images_.at(image::LEFT_EYE),\n                           images_.at(image::RIGHT_EYE)}));\n    frame_pose_writer_.put(frame_pose_writer_.allocate&lt;pose_type&gt;(\n        pose_type{time_point{clock_duration_(timepoints_[current_] + offset_)}, *poses_.at(timepoints_[current_])}));\n    current_++;\n    if (current_ == timepoints_.size()) {\n        current_ = 0;\n        counter_++;\n        offset_ = ((counter_ * timepoints_.size()) + 1) * step_;\n    }\n    std::this_thread::sleep_for(std::chrono::nanoseconds(step_));\n}\n\nPLUGIN_MAIN(data_injection)\n</code></pre>"},{"location":"api/plugins_2zed_2data__injection_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; data_injection &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/camera_data.hpp\"</code></li> <li><code>#include \"illixr/data_format/hand_tracking_data.hpp\"</code></li> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> </ul>"},{"location":"api/plugins_2zed_2data__injection_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2zed_2data__injection_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class data_injection <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/data_injection/plugin.hpp</code></p>"},{"location":"api/plugins_2zed_2data__injection_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; data_injection &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/camera_data.hpp\"\n#include \"illixr/data_format/hand_tracking_data.hpp\"\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nnamespace ILLIXR {\n\nclass data_injection : public threadloop {\npublic:\n    [[maybe_unused]] data_injection(const std::string&amp; name_, phonebook* pb_);\n\n    void _p_one_iteration() override;\n    ~data_injection() override;\n    void start() override;\n\nprivate:\n    void read_cam_data();\n    void read_poses();\n    void load_images_on_the_fly();\n\n    const std::shared_ptr&lt;switchboard&gt;                   switchboard_;\n    switchboard::writer&lt;data_format::binocular_cam_type&gt; frame_img_writer_;\n    switchboard::writer&lt;data_format::pose_type&gt;          frame_pose_writer_;\n    switchboard::writer&lt;data_format::camera_data&gt;        camera_data_writer_;\n\n    std::map&lt;data_format::image::image_type, cv::Mat&gt; images_;\n    std::map&lt;uint64_t, data_format::pose_data*&gt;       poses_;\n    std::vector&lt;uint64_t&gt;                             timepoints_;\n    data_format::camera_data                          camera_data_;\n    std::string                                       data_root_path_;\n    uint64_t                                          counter_;\n    uint64_t                                          current_;\n    uint64_t                                          step_;\n    uint64_t                                          offset_;\n    uint64_t                                          base_time_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugins_2zed_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; plugins &gt; zed &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/plugins_2zed_2plugin_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr int EXPOSURE_TIME_PERCENT   = <code>30</code> const record_header __imu_cam_record   = <code>/* multi line expression */</code>"},{"location":"api/plugins_2zed_2plugin_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/plugins_2zed_2plugin_8cpp/#variable-exposure_time_percent","title":"variable EXPOSURE_TIME_PERCENT","text":"<pre><code>constexpr int EXPOSURE_TIME_PERCENT;\n</code></pre>"},{"location":"api/plugins_2zed_2plugin_8cpp/#variable-__imu_cam_record","title":"variable __imu_cam_record","text":"<pre><code>const record_header __imu_cam_record;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/plugin.cpp</code></p>"},{"location":"api/plugins_2zed_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; plugins &gt; zed &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n\n#include \"illixr/error_util.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;memory&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nconstexpr int EXPOSURE_TIME_PERCENT = 30;\n\nconst record_header __imu_cam_record{\"imu_cam\",\n                                     {\n                                         {\"iteration_no\", typeid(std::size_t)},\n                                         {\"has_camera\", typeid(bool)},\n                                     }};\n\nstd::shared_ptr&lt;zed_camera&gt; zed_imu_thread::start_camera() {\n    std::shared_ptr&lt;zed_camera&gt; zed_cam            = std::make_shared&lt;zed_camera&gt;(switchboard_);\n    bool                        with_hand_tracking = true;\n    assert(zed_cam != nullptr &amp;&amp; \"Zed camera should be initialized\");\n\n    // Cam setup\n    sl::InitParameters init_params;\n    init_params.camera_resolution      = (with_hand_tracking) ? sl::RESOLUTION::HD720 : sl::RESOLUTION::VGA;\n    init_params.coordinate_units       = sl::UNIT::UNITS;                          // For scene reconstruction\n    init_params.coordinate_system      = sl::COORDINATE_SYSTEM::RIGHT_HANDED_Y_UP; // Coordinate system used in ROS\n    init_params.camera_fps             = 30;                                       // gives the best user experience\n    init_params.depth_mode             = (with_hand_tracking) ? sl::DEPTH_MODE::QUALITY : sl::DEPTH_MODE::PERFORMANCE;\n    init_params.depth_stabilization    = true;\n    init_params.depth_minimum_distance = 0.3;\n\n    // Open the camera\n    sl::ERROR_CODE err = zed_cam-&gt;open(init_params);\n    if (err != sl::ERROR_CODE::SUCCESS) {\n        spdlog::get(\"illixr\")-&gt;error(\"[zed] {}\", toString(err).c_str());\n        throw std::runtime_error(\"ZED camera could not be initialized\");\n    }\n    zed_cam-&gt;setCameraSettings(sl::VIDEO_SETTINGS::EXPOSURE, EXPOSURE_TIME_PERCENT);\n    return zed_cam;\n}\n\nvoid zed_imu_thread::stop() {\n    camera_thread_.stop();\n    threadloop::stop();\n}\n\nzed_imu_thread::zed_imu_thread(const std::string&amp; name_, phonebook* pb_)\n    : threadloop{name_, pb_}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , zed_cam_{start_camera()}\n    , camera_thread_{\"zed_camera_thread\", pb_, zed_cam_}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , imu_{switchboard_-&gt;get_writer&lt;imu_type&gt;(\"imu\")}\n    , cam_reader_{switchboard_-&gt;get_reader&lt;cam_type_zed&gt;(\"cam_zed\")}\n    , cam_publisher_{switchboard_-&gt;get_writer&lt;binocular_cam_type&gt;(\"cam\")}\n    , rgb_depth_{switchboard_-&gt;get_writer&lt;rgb_depth_type&gt;(\"rgb_depth\")}\n    , cam_conf_pub_{switchboard_-&gt;get_writer&lt;camera_data&gt;(\"cam_data\")}\n    , it_log_{record_logger_} { }\n\n// destructor\nzed_imu_thread::~zed_imu_thread() {\n    zed_cam_-&gt;close();\n}\n\nvoid zed_imu_thread::start() {\n    camera_thread_.start();\n    threadloop::start();\n    cam_conf_pub_.put(cam_conf_pub_.allocate&lt;camera_data&gt;(camera_data{zed_cam_-&gt;get_config()}));\n}\n\nthreadloop::skip_option zed_imu_thread::_p_should_skip() {\n    zed_cam_-&gt;getSensorsData(sensors_data_, sl::TIME_REFERENCE::CURRENT);\n    if (sensors_data_.imu.timestamp &gt; last_imu_ts_) {\n        std::this_thread::sleep_for(std::chrono::milliseconds{2});\n        return skip_option::run;\n    } else {\n        return skip_option::skip_and_yield;\n    }\n}\n\nvoid zed_imu_thread::_p_one_iteration() {\n    RAC_ERRNO_MSG(\"zed at start of _p_one_iteration\");\n    // std::cout &lt;&lt; \"IMU Rate: \" &lt;&lt; sensors_data.imu.effective_rate &lt;&lt; \"\\n\" &lt;&lt; std::endl;\n\n    // Time as ullong (nanoseconds)\n    auto imu_time = static_cast&lt;ullong&gt;(sensors_data_.imu.timestamp.getNanoseconds());\n\n    // Time as time_point\n    if (!first_imu_time_) {\n        first_imu_time_  = imu_time;\n        first_real_time_ = clock_-&gt;now();\n    }\n    // _m_first_real_time is the time point when the system receives the first IMU sample\n    // Timestamp for later IMU samples is its dataset time difference from the first sample added to _m_first_real_time\n    time_point imu_time_point{*first_real_time_ + std::chrono::nanoseconds(imu_time - *first_imu_time_)};\n\n    // Linear Acceleration and Angular Velocity (av converted from deg/s to rad/s)\n    Eigen::Vector3f la = {sensors_data_.imu.linear_acceleration_uncalibrated.x,\n                          sensors_data_.imu.linear_acceleration_uncalibrated.y,\n                          sensors_data_.imu.linear_acceleration_uncalibrated.z};\n    Eigen::Vector3f av = {static_cast&lt;float&gt;(sensors_data_.imu.angular_velocity_uncalibrated.x * (M_PI / 180)),\n                          static_cast&lt;float&gt;(sensors_data_.imu.angular_velocity_uncalibrated.y * (M_PI / 180)),\n                          static_cast&lt;float&gt;(sensors_data_.imu.angular_velocity_uncalibrated.z * (M_PI / 180))};\n\n    imu_.put(imu_.allocate&lt;imu_type&gt;({imu_time_point, av.cast&lt;double&gt;(), la.cast&lt;double&gt;()}));\n\n    switchboard::ptr&lt;const cam_type_zed&gt; c = cam_reader_.get_ro_nullable();\n    if (c &amp;&amp; c-&gt;serial_no != last_serial_no_) {\n        cv::Mat left_gray, right_gray;\n        cv::cvtColor(c-&gt;at(image::LEFT_EYE), left_gray, cv::COLOR_RGB2GRAY);\n        cv::cvtColor(c-&gt;at(image::RIGHT_EYE), right_gray, cv::COLOR_RGB2GRAY);\n        cam_publisher_.put(\n            cam_publisher_.allocate&lt;binocular_cam_type&gt;({imu_time_point, cv::Mat{left_gray}, cv::Mat{right_gray}}));\n        rgb_depth_.put(\n            rgb_depth_.allocate&lt;rgb_depth_type&gt;({imu_time_point, cv::Mat{c-&gt;at(image::RGB)}, cv::Mat{c-&gt;at(image::DEPTH)}}));\n        last_serial_no_ = c-&gt;serial_no;\n    }\n\n    last_imu_ts_.setNanoseconds(sensors_data_.imu.timestamp.getNanoseconds());\n\n    RAC_ERRNO_MSG(\"zed_imu at end of _p_one_iteration\");\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(zed_imu_thread)\n</code></pre>"},{"location":"api/plugins_2zed_2plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; plugins &gt; zed &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"zed_camera_thread.hpp\"</code></li> </ul>"},{"location":"api/plugins_2zed_2plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugins_2zed_2plugin_8hpp/#classes","title":"Classes","text":"Type Name class zed_imu_thread <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/plugin.hpp</code></p>"},{"location":"api/plugins_2zed_2plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; plugins &gt; zed &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/opencv_data_types.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"zed_camera_thread.hpp\"\n\nnamespace ILLIXR {\n\nclass zed_imu_thread : public threadloop {\npublic:\n    [[maybe_unused]] zed_imu_thread(const std::string&amp; name, phonebook* pb);\n    void stop() override;\n    void start() override;\n    ~zed_imu_thread() override;\n\nprotected:\n    skip_option _p_should_skip() override;\n    void        _p_one_iteration() override;\n\nprivate:\n    std::shared_ptr&lt;zed_camera&gt; start_camera();\n\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n    std::shared_ptr&lt;zed_camera&gt;        zed_cam_;\n    zed_camera_thread                  camera_thread_;\n\n    const std::shared_ptr&lt;const relative_clock&gt;          clock_;\n    switchboard::writer&lt;data_format::imu_type&gt;           imu_;\n    switchboard::reader&lt;data_format::cam_type_zed&gt;       cam_reader_;\n    switchboard::writer&lt;data_format::binocular_cam_type&gt; cam_publisher_;\n    switchboard::writer&lt;data_format::rgb_depth_type&gt;     rgb_depth_;\n    switchboard::writer&lt;data_format::camera_data&gt;        cam_conf_pub_;\n\n    // IMU\n    sl::SensorsData sensors_data_;\n    sl::Timestamp   last_imu_ts_    = 0;\n    std::size_t     last_serial_no_ = 0;\n\n    // Logger\n    record_coalescer it_log_;\n\n    std::optional&lt;ullong&gt;     first_imu_time_;\n    std::optional&lt;time_point&gt; first_real_time_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/point_8hpp/","title":"File point.hpp","text":"<p>FileList &gt; data_format &gt; point.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/data_format/template.hpp\"</code></li> <li><code>#include \"illixr/data_format/unit.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> </ul>"},{"location":"api/point_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/point_8hpp/#classes","title":"Classes","text":"Type Name struct point struct point_with_units struct point_with_validity struct points_with_units struct raw_point <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/point.hpp</code></p>"},{"location":"api/point_8hpp_source/","title":"File point.hpp","text":"<p>File List &gt; data_format &gt; point.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/data_format/template.hpp\"\n#include \"illixr/data_format/unit.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n\nnamespace ILLIXR::data_format {\n//**********************************************************************************\n//  Points\n//**********************************************************************************\n\n/*\n * struct representing a point in 3-D space. It is essentially an Eigen::Vector with some additional functions\n */\nstruct [[maybe_unused]] point : Eigen::Vector3f {\n    /*\n     * Initial point at the origin\n     */\n    point()\n        : Eigen::Vector3f{0., 0., 0.} { }\n\n    point(const float x, const float y, const float z = 0.)\n        : Eigen::Vector3f(x, y, z) { }\n\n    void set(const float x_, const float y_, const float z_ = 0.) {\n        x() = x_;\n        y() = y_;\n        z() = z_;\n    }\n\n    point&amp; operator=(const Eigen::Vector3f&amp; other) {\n        x() = other.x();\n        y() = other.y();\n        z() = other.z();\n        return *this;\n    }\n\n    template&lt;typename T, typename U, int Option&gt;\n    point&amp; operator=(const Eigen::Product&lt;T, U, Option&gt;&amp; pr) {\n        x() = pr.x();\n        y() = pr.y();\n        z() = pr.z();\n        return *this;\n    }\n\n    point&amp; operator+=(const Eigen::Vector3f&amp; other) {\n        x() += other.x();\n        y() += other.y();\n        z() += other.z();\n        return *this;\n    }\n\n    point&amp; operator-=(const Eigen::Vector3f&amp; other) {\n        x() -= other.x();\n        y() -= other.y();\n        z() -= other.z();\n        return *this;\n    }\n};\n\n/*\n * struct representing a point in 3D space with a flag indicating whether the data are valid/reliable\n */\nstruct [[maybe_unused]] point_with_validity : point {\n    bool  valid      = false; \n    float confidence = 0.;    \n\n    point_with_validity()\n        : point()\n        , valid{false} { }\n\n    point_with_validity(const float x, const float y, const float z, bool valid_ = true, const float confidence_ = 0.)\n        : point{x, y, z}\n        , valid{valid_}\n        , confidence{confidence_} { }\n\n    point_with_validity(const point&amp; pnt, bool valid_ = true, const float confidence_ = 0.)\n        : point{pnt}\n        , valid{valid_}\n        , confidence{confidence_} { }\n};\n\n/*\n * struct representing a point in 3D space with a flag indicating whether the data are valid/reliable and the units the point is\n * in\n */\nstruct [[maybe_unused]] point_with_units : point_with_validity {\n    units::measurement_unit unit; \n\n    explicit point_with_units(units::measurement_unit unit_ = units::UNSET)\n        : point_with_validity()\n        , unit{unit_} { }\n\n    point_with_units(const float x, const float y, const float z, units::measurement_unit unit_ = units::UNSET,\n                     bool valid_ = true, const float confidence_ = 0.)\n        : point_with_validity{x, y, z, valid_, confidence_}\n        , unit{unit_} { }\n\n    point_with_units(const point&amp; pnt, units::measurement_unit unit_ = units::UNSET, bool valid_ = true,\n                     const float confidence_ = 0.)\n        : point_with_validity{pnt, valid_, confidence_}\n        , unit{unit_} { }\n\n    explicit point_with_units(const point_with_validity&amp; pnt, units::measurement_unit unit_ = units::UNSET)\n        : point_with_validity{pnt}\n        , unit{unit_} { }\n\n    point_with_units operator+(const point_with_units&amp; pnt) const {\n        point_with_units p_out;\n        p_out.x()   = x() + pnt.x();\n        p_out.y()   = y() + pnt.y();\n        p_out.z()   = z() + pnt.z();\n        p_out.unit  = unit;\n        p_out.valid = valid &amp;&amp; pnt.valid;\n        return p_out;\n    }\n\n    point_with_units operator-(const point_with_units&amp; pnt) const {\n        point_with_units p_out;\n        p_out.x()   = x() - pnt.x();\n        p_out.y()   = y() - pnt.y();\n        p_out.z()   = z() - pnt.z();\n        p_out.unit  = unit;\n        p_out.valid = valid &amp;&amp; pnt.valid;\n        return p_out;\n    }\n\n    point_with_units operator+(const Eigen::Vector3f&amp; pnt) const {\n        point_with_units p_out;\n        p_out.x()   = x() + pnt.x();\n        p_out.y()   = y() + pnt.y();\n        p_out.z()   = z() + pnt.z();\n        p_out.unit  = unit;\n        p_out.valid = valid;\n        return p_out;\n    }\n\n    point_with_units operator-(const Eigen::Vector3f&amp; pnt) const {\n        point_with_units p_out;\n        p_out.x()   = x() - pnt.x();\n        p_out.y()   = y() - pnt.y();\n        p_out.z()   = z() - pnt.z();\n        p_out.unit  = unit;\n        p_out.valid = valid;\n        return p_out;\n    }\n\n    point_with_units operator*(const float val) const {\n        point_with_units p_out;\n        p_out.x() *= val;\n        p_out.y() *= val;\n        p_out.z() *= val;\n        p_out.unit  = unit;\n        p_out.valid = valid;\n        return p_out;\n    }\n\n    point_with_units operator/(const float val) const {\n        point_with_units p_out;\n        p_out.x() /= val;\n        p_out.y() /= val;\n        p_out.z() /= val;\n        p_out.unit  = unit;\n        p_out.valid = valid;\n        return p_out;\n    }\n\n    void set(const float x_, const float y_, const float z_, units::measurement_unit unit_, bool valid_ = true) {\n        x()   = x_;\n        y()   = y_;\n        z()   = z_;\n        unit  = unit_;\n        valid = valid_;\n    }\n\n    void set(const Eigen::Vector3f&amp; vec) {\n        x() = vec.x();\n        y() = vec.y();\n        z() = vec.z();\n    }\n\n    void set(const point_with_units&amp; pnt) {\n        x()   = pnt.x();\n        y()   = pnt.y();\n        z()   = pnt.z();\n        unit  = pnt.unit;\n        valid = pnt.valid;\n    }\n};\n\n/*\n * Take the absolute value of the point\n */\ninline point abs(const point&amp; pnt) {\n    return {std::abs(pnt.x()), std::abs(pnt.y()), std::abs(pnt.z())};\n}\n\n/*\n * Take the absolute value of the point\n */\n[[maybe_unused]] inline point_with_validity abs(const point_with_validity&amp; pnt) {\n    return {abs(point(pnt.x(), pnt.y(), pnt.z())), pnt.valid, pnt.confidence};\n}\n\n[[maybe_unused]] inline point_with_units abs(const point_with_units&amp; pnt) {\n    return {abs(point(pnt.x(), pnt.y(), pnt.z())), pnt.unit, pnt.valid, pnt.confidence};\n}\n\n/*\n * struct containing a vector of points, along with their unit, and overall validity/reliability\n */\nstruct [[maybe_unused]] points_with_units {\n    std::vector&lt;point_with_units&gt; points; \n    units::measurement_unit       unit;   \n    bool valid; \n    bool fixed = false; \n\n    explicit points_with_units(units::measurement_unit unit_ = units::UNSET)\n        : points{std::vector&lt;point_with_units&gt;()}\n        , unit{unit_}\n        , valid{false} { }\n\n    explicit points_with_units(const int size, units::measurement_unit unit_ = units::UNSET)\n        : points{std::vector&lt;point_with_units&gt;(size, point_with_units(unit_))}\n        , unit{unit_}\n        , valid{false}\n        , fixed{true} { }\n\n    explicit points_with_units(std::vector&lt;point_with_units&gt; points_)\n        : points{std::move(points_)} {\n        if (!points.empty())\n            unit = points[0].unit;\n        valid = true;\n        for (const auto&amp; pnt : points)\n            valid |= pnt.valid; // it is still valid as long as one point is valid\n    }\n\n    points_with_units(const points_with_units&amp; points_)\n        : points_with_units(points_.points) { }\n\n    points_with_units&amp; operator=(const points_with_units&amp; other) {\n        if (this == &amp;other)\n            return *this;\n        this-&gt;points.resize(other.points.size());\n        for (size_t i = 0; i &lt; other.points.size(); i++)\n            this-&gt;points[i] = other.points[i];\n        this-&gt;unit  = other.unit;\n        this-&gt;valid = other.valid;\n        this-&gt;fixed = other.fixed;\n        return *this;\n    }\n\n    explicit points_with_units(std::vector&lt;point_with_validity&gt;&amp; points_, units::measurement_unit unit_ = units::UNSET)\n        : unit{unit_} {\n        points.resize(points_.size());\n        valid = true;\n        for (size_t i = 0; i &lt; points_.size(); i++) {\n            points[i] = point_with_units(points_[i], unit_);\n            valid |= points_[i].valid; // it is still valid as long as one point is valid\n        }\n    }\n\n    explicit points_with_units(std::vector&lt;point&gt;&amp; points_, units::measurement_unit unit_ = units::UNSET, bool valid_ = true)\n        : unit{unit_}\n        , valid{valid_} {\n        points.resize(points_.size());\n        for (size_t i = 0; i &lt; points_.size(); i++)\n            points[i] = point_with_units(points_[i], unit_, valid_);\n    }\n\n    point_with_units&amp; operator[](const size_t idx) {\n        if (fixed)\n            return points.at(idx);\n        return points[idx];\n    }\n\n    point_with_units&amp; at(const size_t idx) {\n        return points.at(idx);\n    }\n\n    [[nodiscard]] const point_with_units&amp; at(const size_t idx) const {\n        return points.at(idx);\n    }\n\n    [[nodiscard]] size_t size() const {\n        return points.size();\n    }\n\n    [[maybe_unused]] void mult(const Eigen::Matrix3f&amp; ref_frm) {\n        for (point&amp; pnt : points)\n            pnt = ref_frm * pnt;\n    }\n\n    void transform(const pose_data&amp; pose) {\n        for (point&amp; pnt : points)\n            pnt = (Eigen::Vector3f)((pose.orientation * pnt) + pose.position);\n    }\n\n    [[maybe_unused]] void enforce_bounds(const float x_lim = -1., const float y_lim = -1, const float z_lim = -1) {\n        for (auto&amp; pnt : points) {\n            if (!pnt.valid)\n                continue;\n            if (x_lim &gt; 0.) {\n                if (pnt.x() &lt; 0. || pnt.x() &gt;= x_lim) {\n                    pnt.valid = false;\n                    continue;\n                }\n            }\n            if (y_lim &gt; 0.) {\n                if (pnt.y() &lt; 0. || pnt.y() &gt;= y_lim) {\n                    pnt.valid = false;\n                    continue;\n                }\n            }\n            if (z_lim &gt; 0.) {\n                if (pnt.z() &lt; 0. || pnt.z() &gt;= z_lim) {\n                    pnt.valid = false;\n                    continue;\n                }\n            }\n        }\n    }\n\n    [[maybe_unused]] void check_validity() {\n        valid = false;\n        for (point_with_validity&amp; pnt : points) {\n            if (pnt.valid) {\n                valid = true;\n                return;\n            }\n        }\n    }\n};\n\ntemplate&lt;&gt;\n[[maybe_unused]] inline void normalize&lt;points_with_units&gt;(points_with_units&amp; obj, const float width, const float height,\n                                                          const float depth) {\n    if (obj.unit == units::PERCENT) {\n        std::cout &lt;&lt; \"Points are already normalized\";\n        return;\n    }\n    for (auto&amp; pnt : obj.points)\n        ::ILLIXR::data_format::normalize(pnt, width, height, depth);\n    obj.unit = units::PERCENT;\n}\n\ntemplate&lt;&gt;\n[[maybe_unused]] inline void denormalize&lt;points_with_units&gt;(points_with_units&amp; obj, const float width, const float height,\n                                                            const float depth, units::measurement_unit unit_) {\n    for (auto&amp; pnt : obj.points)\n        ::ILLIXR::data_format::denormalize(pnt, width, height, depth, unit_);\n    obj.unit = unit_;\n}\n\n#ifdef ENABLE_OXR\n/*\n * This struct is utilized when working with OpenXR. The internal variables are in a basic form since OpenXR uses\n * C, rather than C++ (e.g. points do not inherit from Eigen::Vector)\n */\nstruct raw_point {\n    float x;\n    float y;\n    float z;\n    bool  valid;\n\n    raw_point()\n        : x{0.f}\n        , y{0.f}\n        , z{0.f}\n        , valid{false} { }\n\n    [[maybe_unused]] explicit raw_point(const point_with_units&amp; pnt)\n        : x{pnt.x()}\n        , y{pnt.y()}\n        , z{pnt.z()}\n        , valid{pnt.valid} { }\n\n    void copy(const point_with_units&amp; pnt) {\n        x     = pnt.x();\n        y     = pnt.y();\n        z     = pnt.z();\n        valid = pnt.valid;\n    }\n\n    [[maybe_unused]] void mult(const Eigen::Matrix3f&amp; ref_frm) {\n        Eigen::Vector3f vec{x, y, z};\n        vec = ref_frm * vec;\n        x   = vec.x();\n        y   = vec.y();\n        z   = vec.z();\n    }\n\n    void transform(const pose_data&amp; pose) {\n        Eigen::Vector3f vec{x, y, z};\n        vec = (Eigen::Vector3f)((pose.orientation * vec) + pose.position);\n        x   = vec.x();\n        y   = vec.y();\n        z   = vec.z();\n    }\n\n    [[maybe_unused]] void de_transform(const pose_data&amp; pose) {\n        Eigen::Vector3f vec{x, y, z};\n        vec -= pose.position;\n        vec = (Eigen::Vector3f)((pose.orientation.inverse() * vec));\n        x   = vec.x();\n        y   = vec.y();\n        z   = vec.z();\n    }\n};\n#endif\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/pose_8hpp/","title":"File pose.hpp","text":"<p>FileList &gt; data_format &gt; pose.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/coordinate.hpp\"</code></li> <li><code>#include \"illixr/data_format/unit.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> </ul>"},{"location":"api/pose_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/pose_8hpp/#classes","title":"Classes","text":"Type Name struct fast_pose_type struct pose_data struct pose_type struct raw_pose struct texture_pose <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose.hpp</code></p>"},{"location":"api/pose_8hpp_source/","title":"File pose.hpp","text":"<p>File List &gt; data_format &gt; pose.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/coordinate.hpp\"\n#include \"illixr/data_format/unit.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n\nnamespace ILLIXR::data_format {\nstruct pose_data {\n    Eigen::Vector3f         position;    \n    Eigen::Quaternionf      orientation; \n    float                   confidence;  \n    units::measurement_unit unit;        \n    coordinates::frame      co_frame;    \n    coordinates::reference_space\n         ref_space; \n    bool valid;     \n\n    pose_data()\n        : position{0., 0., 0.}\n        , orientation{1., 0., 0., 0.}\n        , confidence{0}\n        , unit{units::UNSET}\n        , co_frame{coordinates::RIGHT_HANDED_Y_UP}\n        , ref_space{coordinates::VIEWER}\n        , valid{false} { }\n\n    pose_data(Eigen::Vector3f position_, Eigen::Quaternionf orientation_, units::measurement_unit unit_ = units::UNSET,\n              coordinates::frame frm = coordinates::RIGHT_HANDED_Y_UP, coordinates::reference_space ref = coordinates::VIEWER,\n              const float confidence_ = 0., bool valid_ = true)\n        : position{std::move(position_)}\n        , orientation{std::move(orientation_)}\n        , confidence(confidence_)\n        , unit{unit_}\n        , co_frame{frm}\n        , ref_space{ref}\n        , valid{valid_} { }\n};\n\nstruct [[maybe_unused]] pose_type\n    : public switchboard::event\n    , public pose_data {\n    time_point sensor_time; \n\n    pose_type()\n        : pose_data()\n        , sensor_time{time_point{}} { }\n\n    pose_type(time_point sensor_time_, Eigen::Vector3f&amp; position_, Eigen::Quaternionf&amp; orientation_,\n              units::measurement_unit unit_ = units::UNSET, coordinates::frame frm = coordinates::RIGHT_HANDED_Y_UP,\n              coordinates::reference_space ref = coordinates::VIEWER, const float confidence_ = 0.)\n        : pose_data{position_, orientation_, unit_, frm, ref, confidence_}\n        , sensor_time{sensor_time_} { }\n\n    pose_type(time_point sensor_time_, const Eigen::Vector3f&amp; position_, const Eigen::Quaternionf&amp; orientation_,\n              units::measurement_unit unit_ = units::UNSET, coordinates::frame frm = coordinates::RIGHT_HANDED_Y_UP,\n              coordinates::reference_space ref = coordinates::VIEWER, const float confidence_ = 0.)\n        : pose_data{position_, orientation_, unit_, frm, ref, confidence_}\n        , sensor_time{sensor_time_} { }\n\n    pose_type(time_point sensor_time_, pose_data&amp; other)\n        : pose_data{other.position, other.orientation, other.unit, other.co_frame, other.ref_space, other.confidence}\n        , sensor_time{sensor_time_} { }\n};\n\nstruct fast_pose_type : public switchboard::event {\n    pose_type  pose;                  \n    time_point predict_computed_time; \n    time_point predict_target_time;   \n\n    fast_pose_type()\n        : pose{}\n        , predict_computed_time{time_point{}}\n        , predict_target_time{time_point{}} { }\n\n    fast_pose_type(pose_type pose_, time_point predict_computed_time_, time_point predict_target_time_)\n        : pose{std::move(pose_)}\n        , predict_computed_time{predict_computed_time_}\n        , predict_target_time{predict_target_time_} { }\n};\n\nstruct [[maybe_unused]] texture_pose : public switchboard::event {\n    duration           offload_duration{};\n    unsigned char*     image{};\n    time_point         pose_time{};\n    Eigen::Vector3f    position;\n    Eigen::Quaternionf latest_quaternion;\n    Eigen::Quaternionf render_quaternion;\n\n    texture_pose() = default;\n\n    texture_pose(duration offload_duration_, unsigned char* image_, time_point pose_time_, Eigen::Vector3f position_,\n                 Eigen::Quaternionf latest_quaternion_, Eigen::Quaternionf render_quaternion_)\n        : offload_duration{offload_duration_}\n        , image{image_}\n        , pose_time{pose_time_}\n        , position{std::move(position_)}\n        , latest_quaternion{std::move(latest_quaternion_)}\n        , render_quaternion{std::move(render_quaternion_)} { }\n};\n\n[[maybe_unused]] typedef std::map&lt;units::eyes, pose_type&gt; multi_pose_map;\n\n#ifdef ENABLE_OXR\nstruct raw_pose {\n    float x;     \n    float y;     \n    float z;     \n    float w;     \n    float wx;    \n    float wy;    \n    float wz;    \n    bool  valid; \n\n    raw_pose()\n        : x{0.f}\n        , y{0.f}\n        , z{0.f}\n        , w{0.f}\n        , wx{0.f}\n        , wy{0.f}\n        , wz{0.f}\n        , valid{false} { }\n\n    explicit raw_pose(const pose_data&amp; pd) {\n        copy(pd);\n    }\n\n    void copy(const pose_data&amp; pd) {\n        x     = pd.position.x();\n        y     = pd.position.y();\n        z     = pd.position.z();\n        w     = pd.orientation.w();\n        wx    = pd.orientation.x();\n        wy    = pd.orientation.y();\n        wz    = pd.orientation.z();\n        valid = pd.valid;\n    }\n};\n\n#endif\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/pose__lookup_2service_8cpp/","title":"File service.cpp","text":"<p>FileList &gt; pose_lookup &gt; service.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"service.hpp\"</code></li> <li><code>#include \"utils.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> </ul>"},{"location":"api/pose__lookup_2service_8cpp/#classes","title":"Classes","text":"Type Name class pose_lookup_plugin"},{"location":"api/pose__lookup_2service_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::map&lt; ullong, pose_type &gt; read_data (std::ifstream &amp; gt_file, const std::string &amp; file_name)"},{"location":"api/pose__lookup_2service_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/pose__lookup_2service_8cpp/#function-read_data","title":"function read_data","text":"<pre><code>inline std::map&lt; ullong, pose_type &gt; read_data (\n    std::ifstream &amp; gt_file,\n    const std::string &amp; file_name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_lookup/service.cpp</code></p>"},{"location":"api/pose__lookup_2service_8cpp_source/","title":"File service.cpp","text":"<p>File List &gt; pose_lookup &gt; service.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"service.hpp\"\n\n#include \"utils.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;shared_mutex&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\ninline std::map&lt;ullong, pose_type&gt; read_data(std::ifstream&amp; gt_file, const std::string&amp; file_name) {\n    (void) file_name;\n    std::map&lt;ullong, pose_type&gt; data;\n\n    for (csv_iterator row{gt_file, 1}; row != csv_iterator{}; ++row) {\n        ullong             t = std::stoull(row[0]);\n        Eigen::Vector3f    av{std::stof(row[1]), std::stof(row[2]), std::stof(row[3])};\n        Eigen::Quaternionf la{std::stof(row[4]), std::stof(row[5]), std::stof(row[6]), std::stof(row[7])};\n        data[t] = {{}, av, la};\n    }\n    return data;\n}\n\npose_lookup_impl::pose_lookup_impl(const phonebook* const pb)\n    : switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{pb-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , sensor_data_{load_data&lt;pose_type&gt;(\"state_groundtruth_estimate0\", \"pose_lookup\", &amp;read_data, switchboard_)}\n    , sensor_data_it_{sensor_data_.cbegin()}\n    , dataset_first_time_{sensor_data_it_-&gt;first}\n    , vsync_estimate_{switchboard_-&gt;get_reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\")}\n    , enable_alignment_{switchboard_-&gt;get_env_bool(\"ILLIXR_ALIGNMENT_ENABLE\", \"False\")}\n    , init_pos_offset_{Eigen::Vector3f::Zero()}\n    , align_rot_{Eigen::Matrix3f::Zero()}\n    , align_trans_{Eigen::Vector3f::Zero()}\n    , align_quat_{Eigen::Vector4f::Zero()}\n    , align_scale_{0.0} {\n    if (enable_alignment_) {\n        std::string path_to_alignment(switchboard_-&gt;get_env(\"ILLIXR_ALIGNMENT_FILE\", \"./metrics/alignMatrix.txt\"));\n        load_align_parameters(path_to_alignment, align_rot_, align_trans_, align_quat_, align_scale_);\n    }\n    // Read position data of the first frame\n    init_pos_offset_ = sensor_data_.cbegin()-&gt;second.position;\n\n    auto newoffset = correct_pose(sensor_data_.begin()-&gt;second).orientation;\n    set_offset(newoffset);\n}\n\nfast_pose_type pose_lookup_impl::get_fast_pose() const {\n    const switchboard::ptr&lt;const switchboard::event_wrapper&lt;time_point&gt;&gt; estimated_vsync = vsync_estimate_.get_ro_nullable();\n    if (estimated_vsync == nullptr) {\n        spdlog::get(\"illixr\")-&gt;trace(\"[pose_lookup] Vsync estimation not valid yet, returning fast_pose for now()\");\n        return get_fast_pose(clock_-&gt;now());\n    } else {\n        return get_fast_pose(**estimated_vsync);\n    }\n}\n\npose_type pose_lookup_impl::get_true_pose() const {\n    throw std::logic_error{\"Not Implemented\"};\n}\n\nbool pose_lookup_impl::fast_pose_reliable() const {\n    return true;\n}\n\nbool pose_lookup_impl::true_pose_reliable() const {\n    return false;\n}\n\nEigen::Quaternionf pose_lookup_impl::get_offset() {\n    return offset_;\n}\n\npose_type pose_lookup_impl::correct_pose(const pose_type&amp; pose) const {\n    pose_type swapped_pose;\n\n    // Step 1: Compensate starting point to (0, 0, 0), pos only\n    auto input_pose = pose_type{pose.sensor_time,\n                                Eigen::Vector3f{\n                                    pose.position(0) - init_pos_offset_(0),\n                                    pose.position(1) - init_pos_offset_(1),\n                                    pose.position(2) - init_pos_offset_(2),\n                                },\n                                pose.orientation};\n\n    if (enable_alignment_) {\n        // Step 2: Apply estimated alignment parameters\n        // Step 2.1: Position alignment\n        input_pose.position = align_scale_ * align_rot_ * input_pose.position + align_trans_;\n\n        // Step 2.2: Orientation alignment\n        Eigen::Vector4f quat_in    = {pose.orientation.x(), pose.orientation.y(), pose.orientation.z(), pose.orientation.w()};\n        Eigen::Vector4f quat_out   = ori_multiply(quat_in, ori_inv(align_quat_));\n        input_pose.orientation.x() = quat_out(0);\n        input_pose.orientation.y() = quat_out(1);\n        input_pose.orientation.z() = quat_out(2);\n        input_pose.orientation.w() = quat_out(3);\n    }\n\n    // Step 3: Swap axis for both position and orientation\n    // Step 3.1: Swap for position\n    // This uses the OpenVINS standard output coordinate system.\n    // This is a mapping between the OV coordinate system and the OpenGL system.\n    swapped_pose.position.x() = -input_pose.position.y();\n    swapped_pose.position.y() = input_pose.position.z();\n    swapped_pose.position.z() = -input_pose.position.x();\n\n    // Step 3.2: Swap for orientation\n    // There is a slight issue with the orientations: basically,\n    // the output orientation acts as though the \"top of the head\" is the\n    // forward direction, and the \"eye direction\" is the up direction.\n    Eigen::Quaternionf raw_o(input_pose.orientation.w(), -input_pose.orientation.y(), input_pose.orientation.z(),\n                             -input_pose.orientation.x());\n\n    swapped_pose.orientation = apply_offset(raw_o);\n\n    return swapped_pose;\n}\n\nvoid pose_lookup_impl::set_offset(const Eigen::Quaternionf&amp; raw_o_times_offset) {\n    std::unique_lock   lock{offset_mutex_};\n    Eigen::Quaternionf raw_o = raw_o_times_offset * offset_.inverse();\n    // std::cout &lt;&lt; \"pose_prediction: set_offset\" &lt;&lt; std::endl;\n    offset_ = raw_o.inverse();\n}\n\nEigen::Quaternionf pose_lookup_impl::apply_offset(const Eigen::Quaternionf&amp; orientation) const {\n    std::shared_lock lock{offset_mutex_};\n    return orientation * offset_;\n}\n\nfast_pose_type pose_lookup_impl::get_fast_pose(time_point time) const {\n    ullong lookup_time = time.time_since_epoch().count() + dataset_first_time_;\n\n    auto nearest_row = sensor_data_.upper_bound(lookup_time);\n\n    if (nearest_row == sensor_data_.cend()) {\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[pose_lookup] Time {} ({} + {}) after last datum {}\", lookup_time,\n                                     std::chrono::nanoseconds(time.time_since_epoch()).count(), dataset_first_time_,\n                                     sensor_data_.rbegin()-&gt;first);\n#endif\n        nearest_row--;\n    } else if (nearest_row == sensor_data_.cbegin()) {\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[pose_lookup] Time {} ({} + {}) before first datum {}\", lookup_time,\n                                     std::chrono::nanoseconds(time.time_since_epoch()).count(), dataset_first_time_,\n                                     sensor_data_.cbegin()-&gt;first);\n#endif\n    } else {\n        // \"std::map::upper_bound\" returns an iterator to the first pair whose key is GREATER than the argument.\n        // I already know we aren't at the begin()\n        // So I will decrement nearest_row here.\n        nearest_row--;\n    }\n\n    auto looked_up_pose        = nearest_row-&gt;second;\n    looked_up_pose.sensor_time = time_point{std::chrono::nanoseconds{nearest_row-&gt;first - dataset_first_time_}};\n    return fast_pose_type{correct_pose(looked_up_pose), clock_-&gt;now(), time};\n}\n\nclass pose_lookup_plugin : public plugin {\npublic:\n    [[maybe_unused]] pose_lookup_plugin(const std::string&amp; name, phonebook* pb)\n        : plugin{name, pb} {\n        pb-&gt;register_impl&lt;pose_prediction&gt;(std::static_pointer_cast&lt;pose_prediction&gt;(std::make_shared&lt;pose_lookup_impl&gt;(pb)));\n    }\n};\n\nPLUGIN_MAIN(pose_lookup_plugin)\n</code></pre>"},{"location":"api/pose__lookup_2service_8hpp/","title":"File service.hpp","text":"<p>FileList &gt; pose_lookup &gt; service.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/data_loading.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> </ul>"},{"location":"api/pose__lookup_2service_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/pose__lookup_2service_8hpp/#classes","title":"Classes","text":"Type Name class pose_lookup_impl <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_lookup/service.hpp</code></p>"},{"location":"api/pose__lookup_2service_8hpp_source/","title":"File service.hpp","text":"<p>File List &gt; pose_lookup &gt; service.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/data_loading.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n\nnamespace ILLIXR {\n\ntypedef data_format::pose_type sensor_types;\n\nclass pose_lookup_impl : public data_format::pose_prediction {\npublic:\n    explicit pose_lookup_impl(const phonebook* const pb);\n    data_format::fast_pose_type get_fast_pose() const override;\n    data_format::pose_type      get_true_pose() const override;\n    bool                        fast_pose_reliable() const override;\n    bool                        true_pose_reliable() const override;\n    Eigen::Quaternionf          get_offset() override;\n    data_format::pose_type      correct_pose(const data_format::pose_type&amp; pose) const override;\n    void                        set_offset(const Eigen::Quaternionf&amp; raw_o_times_offset) override;\n    Eigen::Quaternionf          apply_offset(const Eigen::Quaternionf&amp; orientation) const;\n    data_format::fast_pose_type get_fast_pose(time_point time) const override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;          switchboard_;\n    const std::shared_ptr&lt;const relative_clock&gt; clock_;\n    mutable Eigen::Quaternionf                  offset_{Eigen::Quaternionf::Identity()};\n    mutable std::shared_mutex                   offset_mutex_;\n\n    const std::map&lt;ullong, sensor_types&gt;                        sensor_data_;\n    std::map&lt;ullong, sensor_types&gt;::const_iterator              sensor_data_it_;\n    ullong                                                      dataset_first_time_;\n    switchboard::reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_estimate_;\n\n    bool            enable_alignment_;\n    Eigen::Vector3f init_pos_offset_;\n    Eigen::Matrix3f align_rot_;\n    Eigen::Vector3f align_trans_;\n    Eigen::Vector4f align_quat_;\n    double          align_scale_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/pose__prediction_2service_8cpp/","title":"File service.cpp","text":"<p>FileList &gt; pose_prediction &gt; service.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"service.hpp\"</code></li> <li><code>#include \"illixr/runge-kutta.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> </ul>"},{"location":"api/pose__prediction_2service_8cpp/#classes","title":"Classes","text":"Type Name class pose_prediction_plugin <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_prediction/service.cpp</code></p>"},{"location":"api/pose__prediction_2service_8cpp_source/","title":"File service.cpp","text":"<p>File List &gt; pose_prediction &gt; service.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"service.hpp\"\n\n#include \"illixr/runge-kutta.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;filesystem&gt;\n#include &lt;shared_mutex&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\npose_prediction_impl::pose_prediction_impl(const phonebook* const pb)\n    : switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{pb-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , slow_pose_{switchboard_-&gt;get_reader&lt;pose_type&gt;(\"slow_pose\")}\n    , imu_raw_{switchboard_-&gt;get_reader&lt;imu_raw_type&gt;(\"imu_raw\")}\n    , true_pose_{switchboard_-&gt;get_reader&lt;pose_type&gt;(\"true_pose\")}\n    , ground_truth_offset_{switchboard_-&gt;get_reader&lt;switchboard::event_wrapper&lt;Eigen::Vector3f&gt;&gt;(\"ground_truth_offset\")}\n    , vsync_estimate_{switchboard_-&gt;get_reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\")}\n    , using_lighthouse_{switchboard_-&gt;get_env_bool(\"ILLIXR_LIGHTHOUSE\")} { }\n\n// No parameter get_fast_pose() should just predict to the next vsync\n// However, we don't have vsync estimation yet.\n// So we will predict to `now()`, as a temporary approximation\nfast_pose_type pose_prediction_impl::get_fast_pose() const {\n    switchboard::ptr&lt;const switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_estimate = vsync_estimate_.get_ro_nullable();\n\n    if (vsync_estimate == nullptr) {\n        return get_fast_pose(clock_-&gt;now());\n    } else {\n        return get_fast_pose(vsync_estimate.get()-&gt;operator time_point());\n    }\n}\n\npose_type pose_prediction_impl::get_true_pose() const {\n    switchboard::ptr&lt;const pose_type&gt;                                   pose_ptr   = true_pose_.get_ro_nullable();\n    switchboard::ptr&lt;const switchboard::event_wrapper&lt;Eigen::Vector3f&gt;&gt; offset_ptr = ground_truth_offset_.get_ro_nullable();\n\n    pose_type offset_pose;\n\n    // Subtract offset if valid pose and offset, otherwise use zero pose.\n    // Checking that pose and offset are both valid is safer than just\n    // checking one or the other because it assumes nothing about the\n    // ordering of writes on the producer's end or about the producer\n    // actually writing to both streams.\n    if (pose_ptr != nullptr &amp;&amp; offset_ptr != nullptr) {\n        offset_pose = *pose_ptr;\n        offset_pose.position -= **offset_ptr;\n    } else {\n        offset_pose.sensor_time = clock_-&gt;now();\n        offset_pose.position    = Eigen::Vector3f{0, 0, 0};\n        offset_pose.orientation = Eigen::Quaternionf{1, 0, 0, 0};\n    }\n\n    return correct_pose(offset_pose);\n}\n\n// future_time: An absolute timepoint in the future\nfast_pose_type pose_prediction_impl::get_fast_pose(time_point future_timestamp) const {\n    switchboard::ptr&lt;const pose_type&gt; slow_pose = slow_pose_.get_ro_nullable();\n    if (slow_pose == nullptr) {\n        // No slow pose, return 0\n        return fast_pose_type{\n            correct_pose(pose_type{}),\n            clock_-&gt;now(),\n            future_timestamp,\n        };\n    }\n\n    switchboard::ptr&lt;const imu_raw_type&gt; imu_raw = imu_raw_.get_ro_nullable();\n    if (imu_raw == nullptr) {\n        if (!using_lighthouse_)\n            spdlog::get(\"illixr\")-&gt;debug(\"[POSEPREDICTION] FAST POSE IS SLOW POSE!\");\n\n        // No imu_raw, return slow_pose\n        return fast_pose_type{\n            correct_pose(*slow_pose),\n            clock_-&gt;now(),\n            future_timestamp,\n        };\n    }\n\n    // slow_pose and imu_raw, do pose prediction\n\n    double     dt      = duration_to_double(future_timestamp - imu_raw-&gt;imu_time);\n    state_plus state_p = ::ILLIXR::predict_mean_rk4(dt, state_plus(imu_raw-&gt;quat, imu_raw-&gt;vel, imu_raw-&gt;pos), imu_raw-&gt;w_hat,\n                                                    imu_raw-&gt;a_hat, imu_raw-&gt;w_hat2, imu_raw-&gt;a_hat2);\n\n    // predictor_imu_time is the most recent IMU sample that was used to compute the prediction.\n    auto predictor_imu_time = imu_raw-&gt;imu_time;\n\n    pose_type predicted_pose =\n        correct_pose({predictor_imu_time, state_p.position.cast&lt;float&gt;(), state_p.orientation.cast&lt;float&gt;()});\n\n    // Make the first valid fast pose be straight ahead.\n    if (first_time_) {\n        std::unique_lock lock{offset_mutex_};\n        // check again, now that we have mutual exclusion\n        if (first_time_) {\n            first_time_ = false;\n            offset_     = predicted_pose.orientation.inverse();\n        }\n    }\n\n    // Several timestamps are logged:\n    //       - the prediction compute time (time when this prediction was computed, i.e., now)\n    //       - the prediction target (the time that was requested for this pose.)\n    return fast_pose_type{predicted_pose, clock_-&gt;now(), future_timestamp};\n}\n\nvoid pose_prediction_impl::set_offset(const Eigen::Quaternionf&amp; raw_o_times_offset) {\n    std::unique_lock   lock{offset_mutex_};\n    Eigen::Quaternionf raw_o = raw_o_times_offset * offset_.inverse();\n    offset_                  = raw_o.inverse();\n    /*\n      Now, `raw_o` is maps to the identity quaternion.\n      Proof:\n      apply_offset(raw_o)\n          = raw_o * offset_\n          = raw_o * raw_o.inverse()\n          = Identity.\n     */\n}\n\nEigen::Quaternionf pose_prediction_impl::apply_offset(const Eigen::Quaternionf&amp; orientation) const {\n    std::shared_lock lock{offset_mutex_};\n    return orientation * offset_;\n}\n\nbool pose_prediction_impl::fast_pose_reliable() const {\n    if (using_lighthouse_)\n        return true;\n\n    return slow_pose_.get_ro_nullable() &amp;&amp; imu_raw_.get_ro_nullable();\n    /*\n      SLAM takes some time to initialize, so initially fast_pose\n      is unreliable.\n\n  In such cases, we might return a fast_pose based only on the\n  IMU data (currently, we just return a zero-pose)., and mark\n  it as \"unreliable\"\n\n  This way, there always a pose coming out of pose_prediction,\n  representing our best guess at that time, and we indicate\n  how reliable that guess is here.\n\n */\n}\n\nbool pose_prediction_impl::true_pose_reliable() const {\n    // return true_pose_.valid();\n    /*\n      We do not have a \"ground truth\" available in all cases, such\n      as when reading live data.\n     */\n    return bool(true_pose_.get_ro_nullable());\n}\n\nEigen::Quaternionf pose_prediction_impl::get_offset() {\n    return offset_;\n}\n\n// Correct the orientation of the pose due to the lopsided IMU in the\n// current Dataset we are using (EuRoC)\npose_type pose_prediction_impl::correct_pose(const pose_type&amp; pose) const {\n    if (using_lighthouse_) // The lighthouse plugin should already apply the correct pose.\n        return pose;\n\n    pose_type swapped_pose;\n\n    // Make any changes to the axes direction below\n    // This is a mapping between the coordinate system of the current\n    // SLAM (OpenVINS) we are using and the OpenGL system.\n    swapped_pose.position.x() = -pose.position.y();\n    swapped_pose.position.y() = pose.position.z();\n    swapped_pose.position.z() = -pose.position.x();\n\n    // Make any changes to orientation of the output below\n    // For the dataset were currently using (EuRoC), the output orientation acts as though\n    // the \"top of the head\" is the forward direction, and the \"eye direction\" is the up direction.\n    Eigen::Quaternionf raw_o(pose.orientation.w(), -pose.orientation.y(), pose.orientation.z(), -pose.orientation.x());\n\n    swapped_pose.orientation = apply_offset(raw_o);\n    swapped_pose.sensor_time = pose.sensor_time;\n\n    return swapped_pose;\n}\n\nclass pose_prediction_plugin : public plugin {\npublic:\n    [[maybe_unused]] pose_prediction_plugin(const std::string&amp; name, phonebook* pb)\n        : plugin{name, pb} {\n        pb-&gt;register_impl&lt;pose_prediction&gt;(\n            std::static_pointer_cast&lt;pose_prediction&gt;(std::make_shared&lt;pose_prediction_impl&gt;(pb)));\n    }\n};\n\nPLUGIN_MAIN(pose_prediction_plugin)\n</code></pre>"},{"location":"api/pose__prediction_2service_8hpp/","title":"File service.hpp","text":"<p>FileList &gt; pose_prediction &gt; service.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/imu.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> </ul>"},{"location":"api/pose__prediction_2service_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/pose__prediction_2service_8hpp/#classes","title":"Classes","text":"Type Name class pose_prediction_impl <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_prediction/service.hpp</code></p>"},{"location":"api/pose__prediction_2service_8hpp_source/","title":"File service.hpp","text":"<p>File List &gt; pose_prediction &gt; service.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/imu.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n\nnamespace ILLIXR {\nclass pose_prediction_impl : public data_format::pose_prediction {\npublic:\n    explicit pose_prediction_impl(const phonebook* const pb);\n    data_format::fast_pose_type get_fast_pose() const override;\n    data_format::pose_type      get_true_pose() const override;\n    data_format::fast_pose_type get_fast_pose(time_point future_timestamp) const override;\n    void                        set_offset(const Eigen::Quaternionf&amp; raw_o_times_offset) override;\n    Eigen::Quaternionf          apply_offset(const Eigen::Quaternionf&amp; orientation) const;\n    bool                        fast_pose_reliable() const override;\n    bool                        true_pose_reliable() const override;\n    Eigen::Quaternionf          get_offset() override;\n    data_format::pose_type      correct_pose(const data_format::pose_type&amp; pose) const override;\n\nprivate:\n    mutable std::atomic&lt;bool&gt;                                        first_time_{true};\n    const std::shared_ptr&lt;switchboard&gt;                               switchboard_;\n    const std::shared_ptr&lt;const relative_clock&gt;                      clock_;\n    switchboard::reader&lt;data_format::pose_type&gt;                      slow_pose_;\n    switchboard::reader&lt;data_format::imu_raw_type&gt;                   imu_raw_;\n    switchboard::reader&lt;data_format::pose_type&gt;                      true_pose_;\n    switchboard::reader&lt;switchboard::event_wrapper&lt;Eigen::Vector3f&gt;&gt; ground_truth_offset_;\n    switchboard::reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;      vsync_estimate_;\n    mutable Eigen::Quaternionf                                       offset_{Eigen::Quaternionf::Identity()};\n    mutable std::shared_mutex                                        offset_mutex_;\n    const bool                                                       using_lighthouse_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/pose__prediction_8hpp/","title":"File pose_prediction.hpp","text":"<p>FileList &gt; data_format &gt; pose_prediction.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Geometry&gt;</code></li> </ul>"},{"location":"api/pose__prediction_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/pose__prediction_8hpp/#classes","title":"Classes","text":"Type Name class pose_prediction <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose_prediction.hpp</code></p>"},{"location":"api/pose__prediction_8hpp_source/","title":"File pose_prediction.hpp","text":"<p>File List &gt; data_format &gt; pose_prediction.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n\n#include &lt;eigen3/Eigen/Geometry&gt;\n\nnamespace ILLIXR::data_format {\n\nclass pose_prediction : public phonebook::service {\npublic:\n    [[nodiscard]] virtual fast_pose_type                      get_fast_pose() const                             = 0;\n    [[nodiscard]] virtual pose_type                           get_true_pose() const                             = 0;\n    [[nodiscard]] virtual fast_pose_type                      get_fast_pose(time_point future_time) const       = 0;\n    [[nodiscard]] virtual bool                                fast_pose_reliable() const                        = 0;\n    [[nodiscard]] virtual bool                                true_pose_reliable() const                        = 0;\n    virtual void                                              set_offset(const Eigen::Quaternionf&amp; orientation) = 0;\n    [[maybe_unused]] [[nodiscard]] virtual Eigen::Quaternionf get_offset()                                      = 0;\n    [[nodiscard]] virtual pose_type                           correct_pose(const pose_type&amp; pose) const         = 0;\n\n    ~pose_prediction() override = default;\n\nprotected:\n    [[nodiscard]] pose_type _correct_pose(const pose_type&amp; pose) const {\n        return correct_pose(pose);\n    }\n\n    void _set_offset(const Eigen::Quaternionf&amp; orientation) {\n        set_offset(orientation);\n    }\n};\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/proper__quaternion_8hpp/","title":"File proper_quaternion.hpp","text":"<p>FileList &gt; data_format &gt; proper_quaternion.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"api/proper__quaternion_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/proper__quaternion_8hpp/#classes","title":"Classes","text":"Type Name class proper_quaternion &lt;typename Scalar_, Options_&gt;A more complete implementation of the Eigen::Quaternion. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/proper_quaternion.hpp</code></p>"},{"location":"api/proper__quaternion_8hpp_source/","title":"File proper_quaternion.hpp","text":"<p>File List &gt; data_format &gt; proper_quaternion.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;iostream&gt;\n\nnamespace ILLIXR::data_format {\n\ntemplate&lt;typename Scalar_, int Options_ = Eigen::AutoAlign&gt;\nclass proper_quaternion : public Eigen::Quaternion&lt;Scalar_, Options_&gt; {\npublic:\n    typedef typename Eigen::Quaternion&lt;Scalar_&gt;::Base Base;\n\n    using Base::operator=;\n\n    inline proper_quaternion&amp; operator=(const proper_quaternion&amp; other) {\n        Base::operator=(other);\n        return *this;\n    }\n\n    using Base::operator*=;\n\n    // constructors\n    proper_quaternion()                               = default;\n    proper_quaternion(const proper_quaternion&amp; other) = default;\n\n    [[maybe_unused]] explicit proper_quaternion(const Eigen::Quaternion&lt;Scalar_, Options_&gt;&amp; other)\n        : Eigen::Quaternion&lt;Scalar_, Options_&gt;(other) { }\n\n    [[maybe_unused]] proper_quaternion(const Scalar_&amp; w, const Scalar_&amp; x, const Scalar_&amp; y, const Scalar_&amp; z)\n        : Eigen::Quaternion&lt;Scalar_, Options_&gt;(w, x, y, z) { }\n\n    template&lt;typename Derived&gt;\n    [[maybe_unused]] proper_quaternion(const Scalar_&amp; w, const Eigen::MatrixBase&lt;Derived&gt;&amp; vec)\n        : Eigen::Quaternion&lt;Scalar_, Options_&gt;(w, vec) { }\n\n    [[maybe_unused]] explicit proper_quaternion(const Scalar_* data)\n        : Eigen::Quaternion&lt;Scalar_, Options_&gt;(data) { }\n\n    [[maybe_unused]] explicit proper_quaternion(const Eigen::Matrix&lt;Scalar_, 4, 1&gt;&amp; vec)\n        : Eigen::Quaternion&lt;Scalar_, Options_&gt;(vec[3], vec[0], vec[1], vec[2]) { }\n\n    template&lt;typename Derived&gt;\n    [[maybe_unused]] explicit proper_quaternion(const Eigen::QuaternionBase&lt;Derived&gt;&amp; other)\n        : Eigen::Quaternion&lt;Scalar_&gt;(other) { }\n\n    proper_quaternion&amp; operator*=(const Scalar_&amp; a) {\n        this-&gt;x() *= a;\n        this-&gt;y() *= a;\n        this-&gt;z() *= a;\n        this-&gt;w() *= a;\n        return *this;\n    }\n\n    proper_quaternion operator*(const int a) const {\n        return proper_quaternion&lt;Scalar_, Options_&gt;(this-&gt;w() * a, this-&gt;x() * a, this-&gt;y() * a, this-&gt;z() * a);\n    }\n\n    proper_quaternion operator*(const float a) const {\n        return proper_quaternion&lt;Scalar_, Options_&gt;(this-&gt;w() * a, this-&gt;x() * a, this-&gt;y() * a, this-&gt;z() * a);\n    }\n\n    proper_quaternion operator*(const double a) const {\n        return proper_quaternion&lt;Scalar_, Options_&gt;(this-&gt;w() * a, this-&gt;x() * a, this-&gt;y() * a, this-&gt;z() * a);\n    }\n\n    proper_quaternion&lt;Scalar_&gt; operator*(const Eigen::Quaternion&lt;Scalar_&gt;&amp; other) const {\n        return proper_quaternion&lt;Scalar_&gt;(Eigen::Quaternion&lt;Scalar_&gt;::operator*(other));\n    }\n\n    Eigen::Matrix&lt;Scalar_, 4, 1&gt; asVector() const {\n        return Eigen::Matrix&lt;Scalar_, 4, 1&gt;(this-&gt;x(), this-&gt;y(), this-&gt;z(), this-&gt;w());\n    }\n\n    proper_quaternion&lt;Scalar_&gt;&amp; operator+=(const proper_quaternion&lt;Scalar_&gt;&amp; other) {\n        this-&gt;w() += other.w();\n        this-&gt;x() += other.x();\n        this-&gt;y() += other.y();\n        this-&gt;z() += other.z();\n        return *this;\n    }\n\n    proper_quaternion&lt;Scalar_&gt; operator+(const proper_quaternion&lt;Scalar_&gt;&amp; other) const {\n        proper_quaternion&lt;Scalar_&gt; result(*this);\n        result += other;\n        return result;\n    }\n\n    template&lt;typename T&gt;\n    proper_quaternion&lt;T&gt; cast() {\n        return proper_quaternion&lt;T&gt;(static_cast&lt;T&gt;(this-&gt;w()), static_cast&lt;T&gt;(this-&gt;x()), static_cast&lt;T&gt;(this-&gt;y()),\n                                    static_cast&lt;T&gt;(this-&gt;z()));\n    }\n\n    inline void normalize() {\n        if (this-&gt;w() &lt; 0.)\n            (*this) *= -1.;\n\n        Eigen::Quaternion&lt;Scalar_, Options_&gt;::normalize();\n    }\n};\n\ntemplate&lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const proper_quaternion&lt;T&gt;&amp; pq) {\n    os &lt;&lt; \"X \" &lt;&lt; pq.x() &lt;&lt; std::endl &lt;&lt; \"Y \" &lt;&lt; pq.y() &lt;&lt; std::endl &lt;&lt; \"Z \" &lt;&lt; pq.z() &lt;&lt; std::endl &lt;&lt; \"W \" &lt;&lt; pq.w();\n    return os;\n}\n\n[[maybe_unused]] typedef proper_quaternion&lt;double&gt; proper_quaterniond;\n[[maybe_unused]] typedef proper_quaternion&lt;float&gt;  proper_quaternionf;\n\ntemplate&lt;typename Scalar_&gt;\ninline proper_quaternion&lt;Scalar_&gt; operator*(Scalar_ x, const proper_quaternion&lt;Scalar_&gt;&amp; pq) {\n    return proper_quaternion&lt;Scalar_&gt;(x * pq.w(), x * pq.x(), x * pq.y(), x * pq.z());\n}\n\ntemplate&lt;typename Scalar_&gt;\ninline proper_quaternion&lt;Scalar_&gt; operator/(const proper_quaternion&lt;Scalar_&gt;&amp; pq, Scalar_ x) {\n    return proper_quaternion&lt;Scalar_&gt;(pq.w() / x, pq.x() / x, pq.y() / x, pq.z() / x);\n}\n\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/record__logger_8hpp/","title":"File record_logger.hpp","text":"<p>FileList &gt; illixr &gt; record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;any&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"api/record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/record__logger_8hpp/#classes","title":"Classes","text":"Type Name class data_use_indicator A helper class that lets one dynamically determine if some data gets used. class gen_guid This class generates unique IDs. class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_logger The ILLIXR logging service for structured records. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/record_logger.hpp</code></p>"},{"location":"api/record__logger_8hpp_source/","title":"File record_logger.hpp","text":"<p>File List &gt; illixr &gt; record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n\n#include &lt;any&gt;\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#ifndef NDEBUG\n    #include &lt;iostream&gt;\n    #include &lt;sstream&gt;\n#endif\n\nnamespace ILLIXR {\n\nclass record_header {\npublic:\n    record_header(const std::string&amp; name, std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns_)\n        : id_{std::hash&lt;std::string&gt;{}(name)}\n        , name_{name}\n        , columns_{std::move(columns_)} { }\n\n    bool operator==(const record_header&amp; other) const {\n        // Check pointer first\n        if (this == &amp;other) {\n            return true;\n        }\n\n        if (name_ != other.name_ || columns_.size() != other.columns_.size() || id_ != other.id_) {\n            return false;\n        }\n        for (std::size_t i = 0; i &lt; columns_.size(); ++i) {\n            if (columns_[i] != other.columns_[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool operator!=(const record_header&amp; other) const {\n        return !(*this == other);\n    }\n\n    [[nodiscard]] std::size_t get_id() const {\n        return id_;\n    }\n\n    [[nodiscard]] const std::string&amp; get_name() const {\n        return name_;\n    }\n\n    [[nodiscard]] const std::string&amp; get_column_name(unsigned column) const {\n        return columns_[column].first;\n    }\n\n    [[nodiscard]] const std::type_info&amp; get_column_type(unsigned column) const {\n        return columns_[column].second;\n    }\n\n    [[nodiscard]] unsigned get_columns() const {\n        return columns_.size();\n    }\n\n    [[nodiscard]] std::string to_string() const {\n        std::string ret = std::string{\"record_header \"} + name_ + std::string{\" { \"};\n        for (const auto&amp; pair : columns_) {\n            ret += std::string{pair.second.name()} + std::string{\" \"} + pair.first + std::string{\"; \"};\n        }\n        ret.erase(ret.size() - 2);\n        ret += std::string{\" }\"};\n        return ret;\n    }\n\nprivate:\n    std::size_t                                                      id_;\n    std::string                                                      name_;\n    const std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns_;\n};\n\nclass data_use_indicator {\npublic:\n    data_use_indicator()\n        : used_{false} { }\n\n    data_use_indicator(const data_use_indicator&amp; other)\n        : used_{false} {\n        other.used_ = true;\n    }\n\n    data_use_indicator&amp; operator=(const data_use_indicator&amp; other) {\n        if (&amp;other != this) {\n            other.used_ = true;\n            used_       = false;\n        }\n        return *this;\n    }\n\n    /*\n      copy constructors are just as efficient as move constructors would be,\n      so I won't define move constructors. C++ will invoke copy instead (for no loss).\n    */\n    bool is_used() const {\n        return used_;\n    }\n\n    void mark_used() const {\n        used_ = true;\n    }\n\n    [[maybe_unused]] void mark_unused() const {\n        used_ = false;\n    }\n\nprivate:\n    mutable bool used_;\n};\n\nclass record {\npublic:\n    record(const record_header&amp; rh, std::vector&lt;std::any&gt; values)\n        : record_header_{rh}\n        , values_(std::move(values)) {\n#ifndef NDEBUG\n        assert(record_header_);\n        if (values_.size() != record_header_-&gt;get().get_columns()) {\n            spdlog::get(\"illixr\")-&gt;error(\"[record_logger] {} elements passed, but rh for {} only specifies {}.\", values_.size(),\n                                         record_header_-&gt;get().get_name(), record_header_-&gt;get().get_columns());\n            abort();\n        }\n        for (std::size_t column = 0; column &lt; values_.size(); ++column) {\n            if (values_[column].type() != record_header_-&gt;get().get_column_type(column)) {\n                spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Caller got wrong type for column {} of {}.\", column,\n                                             record_header_-&gt;get().get_name());\n                spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Caller passed: {}; record_header specifies: {}\",\n                                             values_[column].type().name(),\n                                             record_header_-&gt;get().get_column_type(column).name());\n                abort();\n            }\n        }\n#endif\n    }\n\n    record() = default;\n\n    ~record() {\n#ifndef NDEBUG\n        if (record_header_ &amp;&amp; !data_use_indicator_.is_used()) {\n            spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Record was deleted without being logged.\");\n            abort();\n        }\n#endif\n    }\n\n    template&lt;typename T&gt;\n    T get_value(unsigned column) const {\n#ifndef NDEBUG\n        assert(record_header_);\n        data_use_indicator_.mark_used();\n        if (record_header_-&gt;get().get_column_type(column) != typeid(T)) {\n            std::ostringstream ss;\n            ss &lt;&lt; \"Caller column type for \" &lt;&lt; column &lt;&lt; \" of \" &lt;&lt; record_header_-&gt;get().get_name() &lt;&lt; \". \"\n               &lt;&lt; \"Caller passed: \" &lt;&lt; typeid(T).name() &lt;&lt; \"; \"\n               &lt;&lt; \"record_header specifies: \" &lt;&lt; record_header_-&gt;get().get_column_type(column).name() &lt;&lt; \". \";\n            throw std::runtime_error{ss.str()};\n        }\n#endif\n        return std::any_cast&lt;T&gt;(values_[column]);\n    }\n\n    const record_header&amp; get_record_header() const {\n        assert(record_header_);\n        return record_header_-&gt;get();\n    }\n\n    [[maybe_unused]] void mark_used() const {\n#ifndef NDEBUG\n        assert(record_header_);\n        data_use_indicator_.mark_used();\n#endif\n    }\n\nprivate:\n    // Holding a pointer to a record_header is more efficient than\n    // requiring each record to hold a list of its column names\n    // and table name_. This is just one pointer.\n    std::optional&lt;std::reference_wrapper&lt;const record_header&gt;&gt; record_header_;\n    std::vector&lt;std::any&gt;                                      values_;\n#ifndef NDEBUG\n    data_use_indicator data_use_indicator_;\n#endif\n};\n\nclass record_logger : public phonebook::service {\npublic:\n    ~record_logger() override = default;\n\n    virtual void log(const record&amp; r) = 0;\n\n    virtual void log(const std::vector&lt;record&gt;&amp; rs) {\n        for (const record&amp; r : rs) {\n            log(r);\n        }\n    }\n};\n\nclass gen_guid : public phonebook::service {\npublic:\n    std::size_t get(std::size_t namespace_ = 0, std::size_t sub_namespace = 0, std::size_t sub_sub_namespace = 0) {\n        if (guid_starts_[namespace_][sub_namespace].count(sub_sub_namespace) == 0) {\n            guid_starts_[namespace_][sub_namespace][sub_sub_namespace].store(1);\n        }\n        return guid_starts_[namespace_][sub_namespace][sub_sub_namespace]++;\n    }\n\nprivate:\n    std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::atomic&lt;std::size_t&gt;&gt;&gt;&gt;\n        guid_starts_;\n};\n\nstatic std::chrono::milliseconds LOG_BUFFER_DELAY{1000};\n\nclass record_coalescer {\npublic:\n    explicit record_coalescer(std::shared_ptr&lt;record_logger&gt; logger_)\n        : logger_{std::move(logger_)}\n        , last_log_{std::chrono::high_resolution_clock::now()} { }\n\n    ~record_coalescer() {\n        flush();\n    }\n\n    void log(const record&amp; r) {\n        if (logger_) {\n            buffer_.push_back(r);\n            // Log coalescer should only be used with\n            // In the common case, they will be the same pointer, quickly check the pointers.\n            // In the less common case, we check for object-structural equality.\n#ifndef NDEBUG\n            if (&amp;r.get_record_header() != &amp;buffer_[0].get_record_header() &amp;&amp;\n                r.get_record_header() == buffer_[0].get_record_header()) {\n                spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Tried to push a record of type {} to a record logger for type {}\",\n                                             r.get_record_header().to_string(), buffer_[0].get_record_header().to_string());\n                abort();\n            }\n#endif\n            maybe_flush();\n        }\n    }\n\n    void maybe_flush() {\n        if (std::chrono::high_resolution_clock::now() &gt; last_log_ + LOG_BUFFER_DELAY) {\n            flush();\n        }\n    }\n\n    void flush() {\n        if (logger_) {\n            std::vector&lt;record&gt; buffer2;\n            buffer_.swap(buffer2);\n            logger_-&gt;log(buffer2);\n            last_log_ = std::chrono::high_resolution_clock::now();\n        }\n    }\n\n    explicit operator bool() const {\n        return bool(logger_);\n    }\n\nprivate:\n    std::shared_ptr&lt;record_logger&gt;                              logger_;\n    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; last_log_;\n    std::vector&lt;record&gt;                                         buffer_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/relative__clock_8hpp/","title":"File relative_clock.hpp","text":"<p>FileList &gt; illixr &gt; relative_clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;ratio&gt;</code></li> </ul>"},{"location":"api/relative__clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/relative__clock_8hpp/#classes","title":"Classes","text":"Type Name class relative_clock Relative clock for all of ILLIXR . class time_point <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/relative_clock.hpp</code></p>"},{"location":"api/relative__clock_8hpp_source/","title":"File relative_clock.hpp","text":"<p>File List &gt; illixr &gt; relative_clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;ratio&gt;\n\nnamespace ILLIXR {\n\nusing clock_rep_      = long;\nusing clock_period_   = std::nano;\nusing clock_duration_ = std::chrono::duration&lt;clock_rep_, clock_period_&gt;;\n\nclass time_point {\npublic:\n    using duration = clock_duration_;\n\n    time_point() = default;\n\n    constexpr explicit time_point(const duration&amp; time_since_epoch)\n        : time_since_epoch_{time_since_epoch} { }\n\n    [[nodiscard]] duration time_since_epoch() const {\n        return time_since_epoch_;\n    }\n\n    time_point&amp; operator+=(const duration&amp; d) {\n        this-&gt;time_since_epoch_ += d;\n        return *this;\n    }\n\n    time_point&amp; operator-=(const duration&amp; d) {\n        this-&gt;time_since_epoch_ -= d;\n        return *this;\n    }\n\n    duration time_since_epoch_;\n};\n\ninline time_point::duration operator-(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() - rhs.time_since_epoch();\n}\n\ninline time_point operator+(const time_point&amp; pt, const time_point::duration&amp; d) {\n    return time_point(pt.time_since_epoch() + d);\n}\n\ninline time_point operator+(const time_point::duration&amp; d, const time_point&amp; pt) {\n    return time_point(pt.time_since_epoch() + d);\n}\n\ninline bool operator&lt;(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &lt; rhs.time_since_epoch();\n}\n\ninline bool operator&gt;(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &gt; rhs.time_since_epoch();\n}\n\ninline bool operator&lt;=(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &lt;= rhs.time_since_epoch();\n}\n\ninline bool operator&gt;=(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &gt;= rhs.time_since_epoch();\n}\n\ninline bool operator==(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() == rhs.time_since_epoch();\n}\n\ninline bool operator!=(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() != rhs.time_since_epoch();\n}\n\nclass relative_clock : public phonebook::service {\npublic:\n    using duration = clock_duration_;\n    static_assert(std::chrono::steady_clock::is_steady);\n\n    [[nodiscard]] time_point now() const {\n        assert(this-&gt;is_started() &amp;&amp; \"Can't call now() before this clock has been start()ed.\");\n        return time_point{std::chrono::steady_clock::now() - start_};\n    }\n\n    [[maybe_unused]] int64_t absolute_ns(time_point relative) {\n        return std::chrono::nanoseconds{start_.time_since_epoch()}.count() +\n            std::chrono::nanoseconds{relative.time_since_epoch()}.count();\n    }\n\n    void start() {\n        start_ = std::chrono::steady_clock::now();\n    }\n\n    [[nodiscard]] bool is_started() const {\n        return start_ &gt; std::chrono::steady_clock::time_point{};\n    }\n\n    [[maybe_unused]] [[nodiscard]] time_point start_time() const {\n        return time_point{start_.time_since_epoch()};\n    }\n\nprivate:\n    std::chrono::steady_clock::time_point start_;\n};\n\nusing duration = relative_clock::duration;\n\ntemplate&lt;typename Unit = std::ratio&lt;1&gt;&gt;\ndouble duration_to_double(duration dur) {\n    return std::chrono::duration&lt;double, Unit&gt;{dur}.count();\n}\n\nconstexpr duration freq_to_period(double fps) {\n    return duration{static_cast&lt;size_t&gt;(std::chrono::nanoseconds{std::chrono::seconds{1}}.count() / fps)};\n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/render__pass_8hpp/","title":"File render_pass.hpp","text":"<p>FileList &gt; illixr &gt; vk &gt; render_pass.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"vulkan_objects.hpp\"</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/render__pass_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace vulkan"},{"location":"api/render__pass_8hpp/#classes","title":"Classes","text":"Type Name class app class render_pass class timewarp"},{"location":"api/render__pass_8hpp/#macros","title":"Macros","text":"Type Name define GLFW_INCLUDE_VULKAN"},{"location":"api/render__pass_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/render__pass_8hpp/#define-glfw_include_vulkan","title":"define GLFW_INCLUDE_VULKAN","text":"<pre><code>#define GLFW_INCLUDE_VULKAN \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/render_pass.hpp</code></p>"},{"location":"api/render__pass_8hpp_source/","title":"File render_pass.hpp","text":"<p>File List &gt; illixr &gt; vk &gt; render_pass.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#define GLFW_INCLUDE_VULKAN\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/pose.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"vulkan_objects.hpp\"\n\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;vector&gt;\n\nnamespace ILLIXR::vulkan {\n\n// render_pass defines the interface for a render pass. For now, it is only used for timewarp and\n// app.\nclass render_pass : public phonebook::service {\npublic:\n    virtual void record_command_buffer(VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) = 0;\n\n    virtual void update_uniforms(const data_format::pose_type&amp; render_pose) {\n        (void) render_pose;\n    };\n\n    virtual void destroy() { };\n\n    virtual bool is_external() = 0;\n\n    ~render_pass() override = default;\n\n    VkPipeline pipeline_ = VK_NULL_HANDLE;\n};\n\n// timewarp defines the interface for a warping render pass as a service.\nclass timewarp : public render_pass {\npublic:\n    virtual void setup(VkRenderPass render_pass, uint32_t subpass,\n                       std::shared_ptr&lt;buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool,\n                       bool                                                      input_texture_vulkan_coordinates) = 0;\n};\n\n// app defines the interface for an application render pass as a service.\nclass app : public render_pass {\npublic:\n    virtual void setup(VkRenderPass render_pass, uint32_t subpass,\n                       std::shared_ptr&lt;buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool) = 0;\n};\n} // namespace ILLIXR::vulkan\n</code></pre>"},{"location":"api/runge-kutta_8hpp/","title":"File runge-kutta.hpp","text":"<p>FileList &gt; illixr &gt; runge-kutta.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"data_format/proper_quaternion.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"api/runge-kutta_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/runge-kutta_8hpp/#classes","title":"Classes","text":"Type Name struct state_plus <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/runge-kutta.hpp</code></p>"},{"location":"api/runge-kutta_8hpp_source/","title":"File runge-kutta.hpp","text":"<p>File List &gt; illixr &gt; runge-kutta.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"data_format/proper_quaternion.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;iostream&gt;\n\nnamespace ILLIXR {\n\nconst data_format::proper_quaterniond dq_0(1., 0., 0., 0.);    \nconst Eigen::Vector3d                 Gravity(0.0, 0.0, 9.81); \ninline Eigen::Matrix3d symmetric_skew(const Eigen::Vector3d&amp; vec) {\n    Eigen::Matrix3d skew_q;\n    skew_q &lt;&lt; 0, -vec[2], vec[1], vec[2], 0, -vec[0], -vec[1], vec[0], 0;\n    return skew_q;\n}\n\ninline Eigen::Matrix4d makeOmega(const Eigen::Vector3d&amp; w) {\n    Eigen::Matrix4d omega   = Eigen::Matrix4d::Zero();\n    omega.block&lt;3, 3&gt;(0, 0) = -symmetric_skew(w);\n    omega.block&lt;1, 3&gt;(3, 0) = -w.transpose();\n    omega.block&lt;3, 1&gt;(0, 3) = w;\n    return omega;\n}\n\ninline data_format::proper_quaterniond delta_q(const data_format::proper_quaterniond&amp; k_n) {\n    data_format::proper_quaterniond dq(dq_0 + 0.5 * k_n);\n    dq.normalize();\n    return dq;\n}\n\ninline data_format::proper_quaterniond q_dot(const Eigen::Vector3d&amp; av, const data_format::proper_quaterniond&amp; dq) {\n    return data_format::proper_quaterniond(Eigen::Vector4d(0.5 * makeOmega(av) * dq.asVector()));\n}\n\ninline Eigen::Vector3d p_dot(const Eigen::Vector3d&amp; iv, const Eigen::Vector3d&amp; k_n) {\n    return Eigen::Vector3d(iv + 0.5 * k_n);\n}\n\ninline Eigen::Vector3d v_dot(const data_format::proper_quaterniond&amp; dq, const data_format::proper_quaterniond&amp; q,\n                             const Eigen::Vector3d&amp; l_acc) {\n    data_format::proper_quaterniond temp = q * dq;\n    temp.normalize();\n    return temp.toRotationMatrix() * l_acc - Gravity;\n}\n\ntemplate&lt;typename T&gt;\ninline T solve(const T&amp; yn, const T&amp; k1, const T&amp; k2, const T&amp; k3, const T&amp; k4) {\n    return yn + (k1 + 2. * (k2 + k3) + k4) / 6.;\n}\n\nstruct state_plus {\n    data_format::proper_quaterniond orientation;\n    Eigen::Vector3d                 velocity;\n    Eigen::Vector3d                 position;\n\n    [[maybe_unused]] state_plus(const data_format::proper_quaterniond&amp; pq, const Eigen::Vector3d&amp; vel,\n                                const Eigen::Vector3d&amp; pos)\n        : orientation(pq)\n        , velocity(vel)\n        , position(pos) { }\n\n    [[maybe_unused]] state_plus(const Eigen::Quaterniond&amp; pq, const Eigen::Vector3d&amp; vel, const Eigen::Vector3d&amp; pos)\n        : orientation(pq)\n        , velocity(vel)\n        , position(pos) { }\n\n    state_plus() = default;\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const state_plus&amp; sp) {\n    os &lt;&lt; \"Quat \" &lt;&lt; sp.orientation &lt;&lt; std::endl;\n    os &lt;&lt; \"Vel  \" &lt;&lt; sp.velocity &lt;&lt; std::endl;\n    os &lt;&lt; \"Pos  \" &lt;&lt; sp.position &lt;&lt; std::endl;\n    return os;\n}\n\nstate_plus predict_mean_rk4(double dt, const state_plus&amp; sp, const Eigen::Vector3d&amp; ang_vel, const Eigen::Vector3d&amp; linear_acc,\n                            const Eigen::Vector3d&amp; ang_vel2, const Eigen::Vector3d&amp; linear_acc2) {\n    Eigen::Vector3d       av       = ang_vel;\n    Eigen::Vector3d       la       = linear_acc;\n    const Eigen::Vector3d delta_av = (ang_vel2 - ang_vel) / dt;\n    const Eigen::Vector3d delta_la = (linear_acc2 - linear_acc) / dt;\n\n    // y0 ================\n    data_format::proper_quaterniond q_0 = sp.orientation; // initial orientation quaternion\n    Eigen::Vector3d                 p_0 = sp.position;    // initial position vector\n    Eigen::Vector3d                 v_0 = sp.velocity;    // initial velocity vector\n\n    // Calculate the RK4 coefficients\n    // solve orientation\n    // k1\n    data_format::proper_quaterniond k1_q = q_dot(av, dq_0) * dt;\n    av += 0.5 * delta_av * dt;\n    // k2\n    data_format::proper_quaterniond dq_1 = delta_q(k1_q);\n    data_format::proper_quaterniond k2_q = q_dot(av, dq_1) * dt;\n    // k3\n    data_format::proper_quaterniond dq_2 = delta_q(k2_q);\n    data_format::proper_quaterniond k3_q = q_dot(av, dq_2) * dt;\n    // k4\n    av += 0.5 * delta_av * dt;\n    data_format::proper_quaterniond dq_3 = delta_q(2. * k3_q);\n    data_format::proper_quaterniond k4_q = q_dot(av, dq_3) * dt;\n\n    // solve velocity\n    // k1\n    Eigen::Vector3d k1_v = v_dot(dq_0, q_0, la) * dt;\n    // k2\n    la += 0.5 * delta_la * dt;\n    Eigen::Vector3d k2_v = v_dot(dq_1, q_0, la) * dt;\n    // k3\n    Eigen::Vector3d k3_v = v_dot(dq_2, q_0, la) * dt;\n    // k4\n    la += 0.5 * delta_la * dt;\n    Eigen::Vector3d k4_v = v_dot(dq_3, q_0, la) * dt;\n\n    // solve position\n    // k1\n    Eigen::Vector3d k1_p = v_0 * dt;\n    // k2\n    Eigen::Vector3d k2_p = p_dot(v_0, k1_v) * dt;\n    // k3\n    Eigen::Vector3d k3_p = p_dot(v_0, k2_v) * dt;\n    // k4\n    Eigen::Vector3d k4_p = p_dot(v_0, 2. * k3_v) * dt;\n\n    // y+dt ================\n    state_plus                      state_plus;\n    data_format::proper_quaterniond dq = solve(dq_0, k1_q, k2_q, k3_q, k4_q);\n    dq.normalize();\n    state_plus.orientation = q_0 * dq;\n    state_plus.orientation.normalize();\n    state_plus.position = solve(p_0, k1_p, k2_p, k3_p, k4_p);\n    state_plus.velocity = solve(v_0, k1_v, k2_v, k3_v, k4_v);\n    return state_plus;\n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/runtime_8hpp/","title":"File runtime.hpp","text":"<p>FileList &gt; illixr &gt; runtime.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/runtime_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/runtime_8hpp/#classes","title":"Classes","text":"Type Name class runtime <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/runtime.hpp</code></p>"},{"location":"api/runtime_8hpp_source/","title":"File runtime.hpp","text":"<p>File List &gt; illixr &gt; runtime.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace ILLIXR {\nclass plugin;\n\ntypedef plugin* (*plugin_factory)(phonebook*);\n\nclass runtime {\npublic:\n    virtual void                  load_so(const std::vector&lt;std::string&gt;&amp; so) = 0;\n    [[maybe_unused]] virtual void load_so(const std::string_view&amp; so)         = 0;\n    virtual void                  load_plugin_factory(plugin_factory plugin)  = 0;\n\n    virtual void wait() = 0;\n\n    virtual void _stop() = 0;\n\n    void stop() {\n        _stop();\n    }\n\n    std::shared_ptr&lt;switchboard&gt; get_switchboard() {\n        return switchboard_;\n    }\n\n    virtual ~runtime() = default;\n\nprotected:\n    bool                         enable_monado_ = false;\n    std::shared_ptr&lt;switchboard&gt; switchboard_;\n};\n\nextern \"C\" runtime* runtime_factory();\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/runtime__impl_8cpp/","title":"File runtime_impl.cpp","text":"<p>FileList &gt; src &gt; runtime_impl.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/runtime.hpp\"</code></li> <li><code>#include \"illixr/dynamic_lib.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/record_logger.hpp\"</code></li> <li><code>#include \"illixr/stoplight.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"sqlite_record_logger.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/sinks/basic_file_sink.h&gt;</code></li> <li><code>#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/runtime__impl_8cpp/#classes","title":"Classes","text":"Type Name class runtime_impl"},{"location":"api/runtime__impl_8cpp/#public-types","title":"Public Types","text":"Type Name typedef bool(* n_monado_t"},{"location":"api/runtime__impl_8cpp/#public-functions","title":"Public Functions","text":"Type Name runtime * runtime_factory ()  void spdlogger (const std::string &amp; name, const char * log_level)"},{"location":"api/runtime__impl_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/runtime__impl_8cpp/#typedef-n_monado_t","title":"typedef n_monado_t","text":"<pre><code>typedef bool(* n_monado_t) ();\n</code></pre>"},{"location":"api/runtime__impl_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/runtime__impl_8cpp/#function-runtime_factory","title":"function runtime_factory","text":"<pre><code>runtime * runtime_factory () \n</code></pre>"},{"location":"api/runtime__impl_8cpp/#function-spdlogger","title":"function spdlogger","text":"<pre><code>void spdlogger (\n    const std::string &amp; name,\n    const char * log_level\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/runtime_impl.cpp</code></p>"},{"location":"api/runtime__impl_8cpp_source/","title":"File runtime_impl.cpp","text":"<p>File List &gt; src &gt; runtime_impl.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr/runtime.hpp\"\n\n#include \"illixr/dynamic_lib.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/record_logger.hpp\"\n#include \"illixr/stoplight.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"sqlite_record_logger.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/sinks/basic_file_sink.h&gt;\n#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\ntypedef bool (*n_monado_t)();\n\nvoid spdlogger(const std::string&amp; name, const char* log_level) {\n    if (!log_level) {\n#ifdef NDEBUG\n        log_level = \"warn\";\n#else\n        log_level = \"debug\";\n#endif\n    }\n    std::vector&lt;spdlog::sink_ptr&gt; sinks;\n    sinks.push_back(std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;());\n    sinks.push_back(std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(\"logs/\" + name + \".log\"));\n    auto logger = std::make_shared&lt;spdlog::logger&gt;(name, begin(sinks), end(sinks));\n    logger-&gt;set_level(spdlog::level::from_str(log_level));\n    spdlog::register_logger(logger);\n}\n\nclass runtime_impl : public runtime {\npublic:\n    explicit runtime_impl() {\n        spdlogger(\"illixr\", std::getenv(\"ILLIXR_LOG_LEVEL\")); // can't use switchboard interface here\n        phonebook_.register_impl&lt;relative_clock&gt;(std::make_shared&lt;relative_clock&gt;());\n        phonebook_.register_impl&lt;record_logger&gt;(std::make_shared&lt;sqlite_record_logger&gt;());\n        phonebook_.register_impl&lt;gen_guid&gt;(std::make_shared&lt;gen_guid&gt;());\n        phonebook_.register_impl&lt;switchboard&gt;(std::make_shared&lt;switchboard&gt;(&amp;phonebook_));\n        switchboard_   = phonebook_.lookup_impl&lt;switchboard&gt;();\n        enable_monado_ = false;\n        phonebook_.register_impl&lt;stoplight&gt;(std::make_shared&lt;stoplight&gt;());\n    }\n\n    void load_so(const std::vector&lt;std::string&gt;&amp; so_paths) override {\n        RAC_ERRNO_MSG(\"runtime_impl before creating any dynamic library\");\n\n        std::transform(so_paths.cbegin(), so_paths.cend(), std::back_inserter(libraries_), [](const auto&amp; so_path) {\n            RAC_ERRNO_MSG(\"runtime_impl before creating the dynamic library\");\n            return dynamic_lib::create(so_path);\n        });\n        for (auto&amp; i : libraries_) {\n            enable_monado_ = enable_monado_ || i.get&lt;n_monado_t&gt;(\"needs_monado\")();\n        }\n        RAC_ERRNO_MSG(\"runtime_impl after creating the dynamic libraries\");\n\n        std::vector&lt;plugin_factory&gt; plugin_factories;\n        std::transform(libraries_.cbegin(), libraries_.cend(), std::back_inserter(plugin_factories), [](const auto&amp; lib) {\n            return lib.template get&lt;plugin* (*) (phonebook*)&gt;(\"this_plugin_factory\");\n        });\n\n        if (!enable_monado_) {\n            // get env var ILLIXR_DISPLAY_MODE\n            std::string display_mode =\n                switchboard_-&gt;get_env_char(\"ILLIXR_DISPLAY_MODE\") ? switchboard_-&gt;get_env_char(\"ILLIXR_DISPLAY_MODE\") : \"glfw\";\n            if (display_mode != \"none\")\n                phonebook_.register_impl&lt;vulkan::display_provider&gt;(std::make_shared&lt;display_vk&gt;(&amp;phonebook_));\n        }\n\n        RAC_ERRNO_MSG(\"runtime_impl after generating plugin factories\");\n\n        std::transform(plugin_factories.cbegin(), plugin_factories.cend(), std::back_inserter(plugins_),\n                       [this](const auto&amp; plugin_factory) {\n                           RAC_ERRNO_MSG(\"runtime_impl before building the plugin\");\n                           return std::unique_ptr&lt;plugin&gt;{plugin_factory(&amp;phonebook_)};\n                       });\n\n        phonebook_.lookup_impl&lt;relative_clock&gt;()-&gt;start();\n\n        if (!enable_monado_) {\n            const std::string display_mode =\n                switchboard_-&gt;get_env_char(\"ILLIXR_DISPLAY_MODE\") ? switchboard_-&gt;get_env_char(\"ILLIXR_DISPLAY_MODE\") : \"glfw\";\n            if (display_mode != \"none\") {\n                std::set&lt;const char*&gt; instance_extensions;\n                std::set&lt;const char*&gt; device_extensions;\n\n                std::for_each(plugins_.cbegin(), plugins_.cend(), [&amp;](const auto&amp; plugin) {\n                    auto requester = std::dynamic_pointer_cast&lt;ILLIXR::vulkan::vk_extension_request&gt;(plugin);\n                    if (requester != nullptr) {\n                        auto requested_instance_extensions = requester-&gt;get_required_instance_extensions();\n                        instance_extensions.insert(requested_instance_extensions.begin(), requested_instance_extensions.end());\n\n                        auto requested_device_extensions = requester-&gt;get_required_devices_extensions();\n                        device_extensions.insert(requested_device_extensions.begin(), requested_device_extensions.end());\n                    }\n                });\n\n                auto display = std::static_pointer_cast&lt;display_vk&gt;(phonebook_.lookup_impl&lt;vulkan::display_provider&gt;());\n                display-&gt;start(instance_extensions, device_extensions);\n            }\n        }\n\n        std::for_each(plugins_.cbegin(), plugins_.cend(), [](const auto&amp; plugin) {\n            // Well-behaved plugins_ (any derived from threadloop) start there threads here, and then wait on the Stoplight.\n            plugin-&gt;start();\n        });\n\n        // This actually kicks off the plugins\n\n        phonebook_.lookup_impl&lt;stoplight&gt;()-&gt;signal_ready();\n    }\n\n    void load_so(const std::string_view&amp; so) override {\n        auto lib                 = dynamic_lib::create(so);\n        auto this_plugin_factory = lib.get&lt;plugin* (*) (phonebook*)&gt;(\"this_plugin_factory\");\n        load_plugin_factory(this_plugin_factory);\n        libraries_.push_back(std::move(lib));\n    }\n\n    void load_plugin_factory(plugin_factory plugin_main) override {\n        plugins_.emplace_back(plugin_main(&amp;phonebook_));\n        plugins_.back()-&gt;start();\n    }\n\n    void wait() override {\n        // We don't want wait() returning before all the plugin threads have been joined.\n        // That would cause a nasty race-condition if the client tried to delete the runtime right after wait() returned.\n        phonebook_.lookup_impl&lt;stoplight&gt;()-&gt;wait_for_shutdown_complete();\n    }\n\n    void _stop() override {\n        phonebook_.lookup_impl&lt;stoplight&gt;()-&gt;signal_should_stop();\n        // After this point, threads may exit their main loops\n        // They still have destructors and still have to be joined.\n\n        phonebook_.lookup_impl&lt;switchboard&gt;()-&gt;stop();\n        // After this point, Switchboard's internal thread-workers which power synchronous callbacks are stopped and joined.\n\n        for (const std::shared_ptr&lt;plugin&gt;&amp; plugin : plugins_) {\n            plugin-&gt;stop();\n            // Each plugin gets joined in its stop\n        }\n\n        // Tell runtime::wait() that it can return\n        phonebook_.lookup_impl&lt;stoplight&gt;()-&gt;signal_shutdown_complete();\n    }\n\n    ~runtime_impl() override {\n        if (!phonebook_.lookup_impl&lt;stoplight&gt;()-&gt;check_shutdown_complete()) {\n            stop();\n        }\n        // This will be re-enabled in #225\n        // assert(errno == 0 &amp;&amp; \"errno was set during run. Maybe spurious?\");\n        /*\n          Note that this assertion can have false positives AND false negatives!\n          - False positive because the contract of some functions specifies that errno is only meaningful if the return code was\n          an error [1].\n            - We will try to mitigate this by clearing errno on success in ILLIXR.\n          - False negative if some intervening call clears errno.\n            - We will try to mitigate this by checking for errors immediately after a call.\n\n          Despite these mitigations, the best way to catch errors is to check errno immediately after a calling function.\n\n          [1] https://cboard.cprogramming.com/linux-programming/119957-xlib-perversity.html\n         */\n    }\n\nprivate:\n    // I have to keep the dynamic libraries in scope until the program is dead\n    std::vector&lt;dynamic_lib&gt;             libraries_;\n    phonebook                            phonebook_;\n    std::vector&lt;std::shared_ptr&lt;plugin&gt;&gt; plugins_;\n};\n\nextern \"C\" [[maybe_unused]] runtime* runtime_factory() {\n    RAC_ERRNO_MSG(\"runtime_impl before creating the runtime\");\n    return new runtime_impl{};\n}\n</code></pre>"},{"location":"api/serializable__data_8cpp/","title":"File serializable_data.cpp","text":"<p>FileList &gt; utils &gt; serializable_data.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"serializable_data.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/serializable_data.cpp</code></p>"},{"location":"api/serializable__data_8cpp_source/","title":"File serializable_data.cpp","text":"<p>File List &gt; utils &gt; serializable_data.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"serializable_data.hpp\"\n\nBOOST_CLASS_EXPORT_IMPLEMENT(ILLIXR::switchboard::event)\nBOOST_CLASS_EXPORT_IMPLEMENT(ILLIXR::data_format::compressed_frame)\nBOOST_CLASS_EXPORT_IMPLEMENT(ILLIXR::data_format::pose_type)\nBOOST_CLASS_EXPORT_IMPLEMENT(ILLIXR::data_format::fast_pose_type)\n</code></pre>"},{"location":"api/services_2fauxpose_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/services_2fauxpose_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.fauxpose${ILLIXR_BUILD_SUFFIX})"},{"location":"api/services_2fauxpose_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/services_2fauxpose_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.fauxpose${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/fauxpose/CMakeLists.txt</code></p>"},{"location":"api/services_2fauxpose_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the fauxpose ILLIXR service\n\nset(PLUGIN_NAME plugin.fauxpose${ILLIXR_BUILD_SUFFIX})\n\nset(FAUXPOSE_SOURCES service.cpp\n    service.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n)\n\nadd_library(${PLUGIN_NAME} SHARED ${FAUXPOSE_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include)\ntarget_link_libraries(${PLUGIN_NAME} PUBLIC spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/services_2fauxpose_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/fauxpose/README.md</code></p>"},{"location":"api/services_2fauxpose_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># FauxPose ILLIXR plugin\n\n## Summary\n\nThe `FauxPose` ILLIXR plugin generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The\nintent is for use when debugging other plugins and the developer wants a known pose trajectory without having to\nconfigure actual tracking.\n\nThe movement is hard-coded to be on the Y=center.y plane, with the X and Z values set to rotate in a circle. The period\nand amplitude of the movement\nare have default values (0.5, and 2.0 respectively) that can be changed through environment variables.\n\n    Topic details:\n    -   *Publishes* `pose_position` on `fast_pose` topic.\n\n## Usage\n\nThe \"FauxPose\" plugin must be included in the YAML configuration file prior to any rendering plugin (such as [\n`debugview`][P10] or [`gldemo`][P11]). Also, no other pose-generating plugin should be included.\n\nAn example `profiles/fauxpose.yaml` configuration file is included as an example.\n\nBy default, the \"orbit\" of the tracked position will be about the point (0.0, 1.5, 0.0), with a default amplitude of \"\n2.0\", and period of \"0.5\" seconds, with the orientation facing the negative-X direction. The first three of these values\ncan be overridden through environment variables:\n\n    - FAUXPOSE_PERIOD=&lt;n&gt;\n    - FAUXPOSE_AMPLITUDE=&lt;n&gt;\n    - FAUXPOSE_CENTER=&lt;x,y,z&gt;\n\n[//]: # (- plugins -)\n\n[P10]:  ../illixr_plugins.md#debugview\n\n[P11]:  ../illixr_plugins.md#gldemo\n</code></pre>"},{"location":"api/services_2pose__lookup_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/services_2pose__lookup_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.pose_lookup${ILLIXR_BUILD_SUFFIX})"},{"location":"api/services_2pose__lookup_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/services_2pose__lookup_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.pose_lookup${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_lookup/CMakeLists.txt</code></p>"},{"location":"api/services_2pose__lookup_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the pose_lookup ILLIXR plugin\n\nset(PLUGIN_NAME plugin.pose_lookup${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED service.cpp\n            service.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_loading.hpp\n            utils.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/error_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/csv_iterator.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/misc.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${Eigen3_LIBRARIES} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/services_2pose__prediction_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/services_2pose__prediction_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name set (PLUGIN_NAME plugin.pose_prediction${ILLIXR_BUILD_SUFFIX})"},{"location":"api/services_2pose__prediction_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/services_2pose__prediction_2CMakeLists_8txt/#function-set","title":"function set","text":"<pre><code>set (\n    PLUGIN_NAME plugin.pose_prediction${ILLIXR_BUILD_SUFFIX}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_prediction/CMakeLists.txt</code></p>"},{"location":"api/services_2pose__prediction_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code># module to build and install the pose_prediction ILLIXR plugin\n\nset(PLUGIN_NAME plugin.pose_prediction${ILLIXR_BUILD_SUFFIX})\n\n# source files, listed individually so that any changes will trigger a rebuild\nadd_library(${PLUGIN_NAME} SHARED service.cpp\n            service.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/plugin.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/imu.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${Eigen3_LIBRARIES} spdlog::spdlog)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/services_2vkdemo_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/services_2vkdemo_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name cmake_minimum_required (VERSION 3. 22)"},{"location":"api/services_2vkdemo_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/services_2vkdemo_2CMakeLists_8txt/#function-cmake_minimum_required","title":"function cmake_minimum_required","text":"<pre><code>cmake_minimum_required (\n    VERSION 3. 22\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/CMakeLists.txt</code></p>"},{"location":"api/services_2vkdemo_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>cmake_minimum_required(VERSION 3.22)\n\nproject(vkdemo)\n\nset(PLUGIN_NAME plugin.vkdemo${ILLIXR_BUILD_SUFFIX})\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n\nfile(GLOB_RECURSE GLSL_SOURCE_FILES\n        \"shaders/*.frag\"\n        \"shaders/*.vert\"\n        )\n\nset(VKDEMO_DEP_STR \"\")\nif(Vulkan_EXTERNAL)\n    set(VKDEMO_DEP_STR ${Vulkan_DEP_STR})\nendif()\n\nforeach (GLSL ${GLSL_SOURCE_FILES})\n    get_filename_component(FILE_NAME ${GLSL} NAME)\n    set(SPIRV \"${PROJECT_BINARY_DIR}/shaders/${FILE_NAME}.spv\")\n    add_custom_command(\n            OUTPUT ${SPIRV}\n            COMMAND ${CMAKE_COMMAND} -E make_directory \"${PROJECT_BINARY_DIR}/shaders/\"\n            COMMAND ${Vulkan_GLSLANG_VALIDATOR_EXECUTABLE} ${GLSL} -V -o ${SPIRV}\n            DEPENDS ${GLSL} ${VKDEMO_DEP_STR})\n    list(APPEND SPIRV_BINARY_FILES ${SPIRV})\nendforeach (GLSL)\n\nadd_custom_target(\n        Vkdemo_Shaders\n        DEPENDS ${SPIRV_BINARY_FILES}\n)\n\nadd_library(${PLUGIN_NAME} SHARED service.cpp\n            service.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/global_module_defs.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/math_util.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/data_format/pose_prediction.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/switchboard.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/threadloop.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/display_provider.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/render_pass.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/vk/vulkan_utils.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/gl_util/lib/tiny_obj_loader.h\n            ${CMAKE_SOURCE_DIR}/include/illixr/gl_util/lib/stb_image.h\n)\nif(Vulkan_EXTERNAL)\n    add_dependencies(${PLUGIN_NAME} ${Vulkan_DEP_STR})\nendif()\n\nadd_dependencies(${PLUGIN_NAME} Vkdemo_Shaders)\nset_target_properties(${PLUGIN_NAME} PROPERTIES OUTPUT_NAME ${PLUGIN_NAME})\n\ntarget_link_libraries(${PLUGIN_NAME} ${Vulkan_LIBRARIES} spdlog::spdlog)\ntarget_include_directories(${PLUGIN_NAME} PUBLIC ${Vulkan_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include)\n\ninstall_shaders(SPIRV_BINARY_FILES vkdemo ${PLUGIN_NAME})\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre>"},{"location":"api/services_2vkdemo_2README_8md/","title":"File README.md","text":"<p>FileList &gt; README.md</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/README.md</code></p>"},{"location":"api/services_2vkdemo_2README_8md_source/","title":"File README.md","text":"<p>File List &gt; README.md</p> <p>Go to the documentation of this file</p> <pre><code># vkdemo\n\n## Summary\n\nThe `vkdemo` service serves as a stand-in for an actual application when ILLIXR is run as a standalone application\nwithout an actual [_OpenXR_][G10] application. `vkdemo` will subscribe to several [_switchboard_][G11] plugs, render a\nsimple, hard-coded 3D scene (in fact, the same 3D scene that is included in the [`debugview`][P10] plugin) and publish\nthe results to the [_switchboard_][G11] API. `vkdemo` is intended to be as lightweight as possible, serving as a\nbaseline debug \"dummy application\". During development, it is useful to have some content being published to the \n[_HMD_][G12] display without needing to use the full OpenXR interface; `vkdemo` fills this requirement.\n\n## Phonebook Service\n\n`vkdemo` is registered as a service in phonebook, conforming to the `app` render pass interface. Three functions are\nexposed:\n\n- `setup(VkRenderPass render_pass, uint32_t subpass)` initializes the required Vulkan pipeline and resources given a\n  specific render pass and subpass, to which `vkdemo` binds to\n- `update_uniforms(const pose_type render_pose)` updates the uniform buffer with the given pose, which is used to render\n  the scene. This must be called before `record_command_buffer` is called.\n- `record_command_buffer(VkCommandBuffer commandBuffer, int eye)` records the commands into a given command buffer that\n  would perform the rendering for one eye, for which 0 is left and 1 is right. To achieve stereoscopic rendering, the\n  function is called twice, once for each eye.\n- `virtual void destroy()` cleans up the resources allocated by `vkdemo`. Currently, this part is not yet implemented.\n\n[//]: # (- glossary -)\n\n[G10]:  ../glossary.md#openxr\n\n[G11]:  ../glossary.md#switchboard\n\n[G12]:  ../glossary.md#head-mounted-display\n\n\n[//]: # (- plugins -)\n\n[P10]:  ../illixr_plugins.md#debugview\n</code></pre>"},{"location":"api/shader__util_8hpp/","title":"File shader_util.hpp","text":"<p>FileList &gt; illixr &gt; shader_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;GL/gl.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/shader__util_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr std::size_t GL_MAX_LOG_LENGTH   = <code>4096U</code>"},{"location":"api/shader__util_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name GLuint init_and_link (const char * vertex_shader, const char * fragment_shader)  void GLAPIENTRY message_callback (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * message, const void * user_param)"},{"location":"api/shader__util_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/shader__util_8hpp/#variable-gl_max_log_length","title":"variable GL_MAX_LOG_LENGTH","text":"<pre><code>constexpr std::size_t GL_MAX_LOG_LENGTH;\n</code></pre>"},{"location":"api/shader__util_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/shader__util_8hpp/#function-init_and_link","title":"function init_and_link","text":"<pre><code>static GLuint init_and_link (\n    const char * vertex_shader,\n    const char * fragment_shader\n) \n</code></pre>"},{"location":"api/shader__util_8hpp/#function-message_callback","title":"function message_callback","text":"<pre><code>static void GLAPIENTRY message_callback (\n    GLenum source,\n    GLenum type,\n    GLuint id,\n    GLenum severity,\n    GLsizei length,\n    const GLchar * message,\n    const void * user_param\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/shader_util.hpp</code></p>"},{"location":"api/shader__util_8hpp_source/","title":"File shader_util.hpp","text":"<p>File List &gt; illixr &gt; shader_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"error_util.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;cstring&gt;\n// clang-format off\n#include &lt;GL/glew.h&gt;\n#include &lt;GL/gl.h&gt;\n// clang-format on\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\n\nstatic constexpr std::size_t GL_MAX_LOG_LENGTH = 4096U;\n\nstatic void GLAPIENTRY message_callback([[maybe_unused]] GLenum source, [[maybe_unused]] GLenum type,\n                                        [[maybe_unused]] GLuint id, [[maybe_unused]] GLenum severity,\n                                        [[maybe_unused]] GLsizei length, [[maybe_unused]] const GLchar* message,\n                                        [[maybe_unused]] const void* user_param) {\n#ifndef NDEBUG\n    if (severity == GL_DEBUG_SEVERITY_NOTIFICATION) {\n        return;\n    }\n    std::string type_error = (type == GL_DEBUG_TYPE_ERROR) ? \"** GL ERROR **\" : \"\";\n    spdlog::get(\"illixr\")-&gt;warn(\"[shader_util] GL CALLBACK: {} type = {:x}, severity = {:x}, message = {}\", type_error, type,\n                                severity, message);\n    // https://www.khronos.org/opengl/wiki/Debug_Output#Message_Components\n    if (severity == GL_DEBUG_SEVERITY_HIGH) {\n        ILLIXR::abort();\n    } \n#endif\n}\n\nstatic GLuint init_and_link(const char* vertex_shader, const char* fragment_shader) {\n    // GL handles for intermediary objects.\n    GLint result, vertex_shader_handle, fragment_shader_handle, shader_program;\n\n    vertex_shader_handle = glCreateShader(GL_VERTEX_SHADER);\n    auto vert_shader_len = static_cast&lt;GLint&gt;(strlen(vertex_shader));\n    glShaderSource(vertex_shader_handle, 1, &amp;vertex_shader, &amp;vert_shader_len);\n    glCompileShader(vertex_shader_handle);\n    glGetShaderiv(vertex_shader_handle, GL_COMPILE_STATUS, &amp;result);\n    if (result == GL_FALSE) {\n        GLsizei             length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetShaderInfoLog(vertex_shader_handle, GL_MAX_LOG_LENGTH * sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get vertex_shader_handle: \" + msg);\n    }\n\n    GLint frag_result      = GL_FALSE;\n    fragment_shader_handle = glCreateShader(GL_FRAGMENT_SHADER);\n    auto frag_shader_len   = static_cast&lt;GLint&gt;(strlen(fragment_shader));\n    glShaderSource(fragment_shader_handle, 1, &amp;fragment_shader, &amp;frag_shader_len);\n    glCompileShader(fragment_shader_handle);\n    glGetShaderiv(fragment_shader_handle, GL_COMPILE_STATUS, &amp;frag_result);\n    if (frag_result == GL_FALSE) {\n        GLsizei             length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetShaderInfoLog(fragment_shader_handle, GL_MAX_LOG_LENGTH * sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get fragment_shader_handle: \" + msg);\n    }\n\n    // Create program and link shaders\n    shader_program = glCreateProgram();\n    glAttachShader(shader_program, vertex_shader_handle);\n    glAttachShader(shader_program, fragment_shader_handle);\n    const GLenum gl_err_attach = glGetError();\n    if (gl_err_attach != GL_NO_ERROR) {\n        ILLIXR::abort(\"[shader_util] AttachShader or createProgram failed\");\n    }\n\n    // Link and verify\n\n    glLinkProgram(shader_program);\n\n    const GLenum gl_err_link = glGetError();\n    if (gl_err_link != GL_NO_ERROR) {\n        ILLIXR::abort(\"[shader_util] Linking failed\");\n    }\n\n    glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;result);\n    if (result == GL_FALSE) {\n        GLsizei             length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetProgramInfoLog(shader_program, GL_MAX_LOG_LENGTH * sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get shader program: \" + msg);\n    }\n\n    // After successful link, detach shaders from shader program\n    glDetachShader(shader_program, vertex_shader_handle);\n    glDetachShader(shader_program, fragment_shader_handle);\n\n    return shader_program;\n}\n</code></pre>"},{"location":"api/shape_8hpp/","title":"File shape.hpp","text":"<p>FileList &gt; data_format &gt; shape.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include \"illixr/data_format/template.hpp\"</code></li> <li><code>#include \"illixr/data_format/unit.hpp\"</code></li> </ul>"},{"location":"api/shape_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/shape_8hpp/#classes","title":"Classes","text":"Type Name struct rect <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/shape.hpp</code></p>"},{"location":"api/shape_8hpp_source/","title":"File shape.hpp","text":"<p>File List &gt; data_format &gt; shape.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifndef NDEBUG\n    #include &lt;spdlog/spdlog.h&gt;\n#endif\n\n#include \"illixr/data_format/template.hpp\"\n#include \"illixr/data_format/unit.hpp\"\n\nnamespace ILLIXR::data_format {\nstruct [[maybe_unused]] rect {\n    double x_center; \n    double y_center; \n    double width;    \n    double height;   \n\n    double                  rotation; \n    units::measurement_unit unit;\n    bool                    valid; \n\n    rect()\n        : x_center{0.}\n        , y_center{0.}\n        , width{0.}\n        , height{0.}\n        , rotation{0.}\n        , unit{units::UNSET}\n        , valid{false} { }\n\n    explicit rect(rect* other) {\n        if (other != nullptr) {\n            x_center = other-&gt;x_center;\n            y_center = other-&gt;y_center;\n            width    = other-&gt;width;\n            height   = other-&gt;height;\n            rotation = other-&gt;rotation;\n            unit     = other-&gt;unit;\n            valid    = other-&gt;valid;\n        }\n    }\n\n    rect(const double xc, const double yc, const double w, const double h, const double r,\n         units::measurement_unit unit_ = units::UNSET)\n        : x_center{xc}\n        , y_center{yc}\n        , width{w}\n        , height{h}\n        , rotation{r}\n        , unit{unit_}\n        , valid{true} { }\n\n    void set(const double xc, const double yc, const double w, const double h, const double r,\n             units::measurement_unit unit_ = units::UNSET) {\n        x_center = xc;\n        y_center = yc;\n        width    = w;\n        height   = h;\n\n        rotation = r;\n        unit     = unit_;\n        valid    = true;\n    }\n\n    void flip_y(const uint im_height = 0) {\n        if (unit == units::PERCENT) {\n            y_center = 1.0 - y_center;\n            return;\n        }\n        if (im_height == 0)\n            throw std::runtime_error(\"Cannot rectify rect with non percent units if no image height is given.\");\n        y_center = (float) im_height - y_center;\n    }\n};\n\ntemplate&lt;&gt;\ninline void normalize&lt;rect&gt;(rect&amp; obj, const float width, const float height, const float depth) {\n    (void) depth;\n    if (obj.unit == units::PERCENT) {\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;info(\"[normalize] rect already normalized\");\n#endif\n        return;\n    }\n    obj.x_center /= width;\n    obj.y_center /= height;\n    obj.width /= width;\n    obj.height /= height;\n    obj.unit = units::PERCENT;\n}\n\ntemplate&lt;&gt;\ninline void denormalize&lt;rect&gt;(rect&amp; obj, const float width, const float height, const float depth,\n                              units::measurement_unit unit) {\n    (void) depth;\n    if (!obj.valid)\n        return;\n    if (obj.unit != units::PERCENT) {\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;info(\"[denormalize] rect already denormalized\");\n#endif\n        return;\n    }\n    if (unit == units::PERCENT)\n        throw std::runtime_error(\"Cannot denormalize to PERCENT\");\n    obj.x_center *= width;\n    obj.y_center *= height;\n    obj.width *= width;\n    obj.height *= height;\n    obj.unit = unit;\n}\n\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/sqlite__record__logger_8hpp/","title":"File sqlite_record_logger.hpp","text":"<p>FileList &gt; src &gt; sqlite_record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/concurrentqueue/blockingconcurrentqueue.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/record_logger.hpp\"</code></li> <li><code>#include \"sqlite3pp/sqlite3pp.hpp\"</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/sqlite__record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/sqlite__record__logger_8hpp/#classes","title":"Classes","text":"Type Name class sqlite_record_logger class sqlite_thread <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/sqlite_record_logger.hpp</code></p>"},{"location":"api/sqlite__record__logger_8hpp_source/","title":"File sqlite_record_logger.hpp","text":"<p>File List &gt; src &gt; sqlite_record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/concurrentqueue/blockingconcurrentqueue.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/record_logger.hpp\"\n#include \"sqlite3pp/sqlite3pp.hpp\"\n\n#include &lt;filesystem&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;thread&gt;\n\nnamespace ILLIXR {\n\nclass sqlite_thread {\npublic:\n    sqlite3pp::database prep_db() {\n        RAC_ERRNO_MSG(\"sqlite_record_logger at start of prep_db\");\n\n        if (!std::filesystem::exists(directory_)) {\n            std::filesystem::create_directory(directory_);\n        }\n\n        const std::string path = directory_ / (table_name_ + std::string{\".sqlite\"});\n\n        RAC_ERRNO_MSG(\"sqlite_record_logger before sqlite3pp::database\");\n        sqlite3pp::database database{path.c_str()};\n        RAC_ERRNO_MSG(\"sqlite_record_logger after sqlite3pp::database\");\n\n        return database;\n    }\n\n    std::string prep_insert_str() {\n        RAC_ERRNO_MSG(\"sqlite_record_logger at start of prep_insert_str\");\n\n        std::string drop_table_string = std::string{\"DROP TABLE IF EXISTS \"} + table_name_ + std::string{\";\"};\n        database_.execute(drop_table_string.c_str());\n        RAC_ERRNO_MSG(\"sqlite_record_logger after drop table execute.\");\n\n        std::string create_table_string = std::string{\"CREATE TABLE \"} + table_name_ + std::string{\"(\"};\n        for (unsigned int i = 0; i &lt; record_header_.get_columns(); ++i) {\n            create_table_string += record_header_.get_column_name(i) + std::string{\" \"};\n            const std::type_info&amp; rh_type = record_header_.get_column_type(i);\n            if (rh_type == typeid(std::size_t) || rh_type == typeid(bool) || rh_type == typeid(std::chrono::nanoseconds) ||\n                rh_type == typeid(std::chrono::high_resolution_clock::time_point) || rh_type == typeid(duration) ||\n                rh_type == typeid(time_point)) {\n                create_table_string += std::string{\"INTEGER\"};\n            } else if (rh_type == typeid(double)) {\n                create_table_string += std::string{\"REAL\"}; // For performance timing. Will be deleted when implementing #208.\n            } else if (rh_type == typeid(std::string)) {\n                create_table_string += std::string{\"TEXT\"};\n            } else {\n                throw std::runtime_error{std::string{\"type \"} + std::string{record_header_.get_column_type(i).name()} +\n                                         std::string{\" not found\"}};\n            }\n            create_table_string += std::string{\", \"};\n        }\n        create_table_string.erase(create_table_string.size() - 2);\n        create_table_string += std::string{\");\"};\n\n        RAC_ERRNO_MSG(\"sqlite_record_logger before create table execute\");\n        database_.execute(create_table_string.c_str());\n        RAC_ERRNO_MSG(\"sqlite_record_logger after create table execute\");\n\n        std::string insert_string = std::string{\"INSERT INTO \"} + table_name_ + std::string{\" VALUES (\"};\n        for (unsigned int i = 0; i &lt; record_header_.get_columns(); ++i) {\n            insert_string += std::string{\"?\"} + std::to_string(i + 1) + std::string{\", \"};\n        }\n        insert_string.erase(insert_string.size() - 2);\n        insert_string += std::string{\");\"};\n        return insert_string;\n    }\n\n    explicit sqlite_thread(const record_header&amp; rh_)\n        : record_header_{rh_}\n        , table_name_{record_header_.get_name()}\n        , database_{prep_db()}\n        , insert_str_{prep_insert_str()}\n        , insert_cmd_{database_, insert_str_.c_str()}\n        , thread_{[this] {\n            pull_queue();\n        }} { }\n\n    void pull_queue() {\n        const std::size_t   max_record_batch_size = 1024 * 256;\n        std::vector&lt;record&gt; record_batch{max_record_batch_size};\n        std::size_t         actual_batch_size;\n\n        spdlog::get(\"illixr\")-&gt;set_pattern(\"[%Y-%m-%d %H:%M:%S.%e] [%n] [%^%l%$] [sqlite_record_logger] thread_ %t %v\");\n        spdlog::get(\"illixr\")-&gt;debug(\"{}\", table_name_);\n        spdlog::get(\"illixr\")-&gt;set_pattern(\"%+\");\n\n        std::size_t processed = 0;\n        while (!terminate_.load()) {\n            std::this_thread::sleep_for(std::chrono::seconds{1});\n            // Uncomment this block to log in \"real time\";\n            // Otherwise, everything gets logged \"post real time\".\n            /*\n            const std::chrono::seconds max_record_match_wait_time {10};\n            actual_batch_size = queue_.wait_dequeue_bulk_timed(record_batch.begin(), record_batch.size(),\n            max_record_match_wait_time); process(record_batch, actual_batch_size); processed += actual_batch_size;\n            */\n        }\n\n        // We got the terminate_ command,\n        // So drain whatever is left in the queue_.\n        // But don't wait around once it is empty.\n        std::size_t post_processed = 0;\n        while ((actual_batch_size = queue_.try_dequeue_bulk(record_batch.begin(), record_batch.size()))) {\n            process(record_batch, actual_batch_size);\n            post_processed += actual_batch_size;\n        }\n        spdlog::get(\"illixr\")-&gt;debug(\"[sqlite_record_logger] Drained {} (sqlite); {}/{} done post real time\", table_name_,\n                                     post_processed, (processed + post_processed));\n    }\n\n    void process(const std::vector&lt;record&gt;&amp; record_batch, std::size_t batch_size) {\n        sqlite3pp::transaction xct{database_};\n        for (std::size_t i = 0; i &lt; batch_size; ++i) {\n            // TODO(performance): reuse the sqlite3pp statement\n            // This currently has to be 'reinterpreted' for every iteration.\n            sqlite3pp::command cmd{database_, insert_str_.c_str()};\n            const record&amp;      r = record_batch[i];\n            for (int j = 0; j &lt; static_cast&lt;int&gt;(record_header_.get_columns()); ++j) {\n                /*\n                  If you get a `std::bad_any_cast` here, make sure the user didn't lie about record.get_record_header().\n                  The types there should be the same as those in record.get_values().\n                */\n                const std::type_info&amp; rh_type = record_header_.get_column_type(j);\n                if (rh_type == typeid(std::size_t)) {\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(r.get_value&lt;std::size_t&gt;(j)));\n                } else if (rh_type == typeid(bool)) {\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(r.get_value&lt;bool&gt;(j)));\n                } else if (rh_type == typeid(double)) {\n                    cmd.bind(j + 1, r.get_value&lt;double&gt;(j));\n                } else if (rh_type == typeid(std::chrono::nanoseconds)) {\n                    auto val = r.get_value&lt;duration&gt;(j);\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh_type == typeid(std::chrono::high_resolution_clock::time_point)) {\n                    auto val = r.get_value&lt;std::chrono::high_resolution_clock::time_point&gt;(j).time_since_epoch();\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh_type == typeid(duration)) {\n                    auto val = r.get_value&lt;duration&gt;(j);\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh_type == typeid(time_point)) {\n                    auto val = r.get_value&lt;time_point&gt;(j).time_since_epoch();\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh_type == typeid(std::string)) {\n                    // r.get_value&lt;std::string&gt;(j) returns a std::string temporary\n                    // c_str() returns a pointer into that std::string temporary\n                    // Therefore, need to copy.\n                    cmd.bind(j + 1, r.get_value&lt;std::string&gt;(j).c_str(), sqlite3pp::copy);\n                } else {\n                    throw std::runtime_error{std::string{\"type \"} + std::string{record_header_.get_column_type(j).name()} +\n                                             std::string{\" not implemented\"}};\n                }\n            }\n            RAC_ERRNO_MSG(\"sqlite_record_logger set errno before process cmd execute\");\n\n            cmd.execute();\n            RAC_ERRNO_MSG(\"sqlite_record_logger after process cmd execute\");\n        }\n        xct.commit();\n    }\n\n    void put_queue(const std::vector&lt;record&gt;&amp; buffer_in) {\n        queue_.enqueue_bulk(buffer_in.begin(), buffer_in.size());\n    }\n\n    void put_queue(const record&amp; record_in) {\n        queue_.enqueue(record_in);\n    }\n\n    ~sqlite_thread() {\n        terminate_.store(true);\n        thread_.join();\n    }\n\nprivate:\n    static const std::filesystem::path          directory_;\n    const record_header&amp;                        record_header_;\n    std::string                                 table_name_;\n    sqlite3pp::database                         database_;\n    std::string                                 insert_str_;\n    sqlite3pp::command                          insert_cmd_;\n    moodycamel::BlockingConcurrentQueue&lt;record&gt; queue_;\n    std::atomic&lt;bool&gt;                           terminate_{false};\n    std::thread                                 thread_;\n};\n\nconst std::filesystem::path sqlite_thread::directory_{\"metrics\"};\n\nclass sqlite_record_logger : public record_logger {\nprotected:\n    void log(const std::vector&lt;record&gt;&amp; r) override {\n        if (!r.empty()) {\n            get_sqlite_thread(r[0]).put_queue(r);\n        }\n    }\n\n    void log(const record&amp; r) override {\n        get_sqlite_thread(r).put_queue(r);\n    }\n\nprivate:\n    sqlite_thread&amp; get_sqlite_thread(const record&amp; r) {\n        const record_header&amp; record_header_ = r.get_record_header();\n        {\n            const std::shared_lock&lt;std::shared_mutex&gt; lock{registry_lock_};\n            auto                                      result = registered_tables_.find(record_header_.get_id());\n            if (result != registered_tables_.cend()) {\n                return result-&gt;second;\n            }\n        }\n        const std::unique_lock&lt;std::shared_mutex&gt; lock{registry_lock_};\n        auto pair = registered_tables_.try_emplace(record_header_.get_id(), record_header_);\n        return pair.first-&gt;second;\n    }\n\n    std::unordered_map&lt;std::size_t, sqlite_thread&gt; registered_tables_;\n    std::shared_mutex                              registry_lock_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/src_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/src_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name find_package (glfw3 3.3 REQUIRED)"},{"location":"api/src_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/src_2CMakeLists_8txt/#function-find_package","title":"function find_package","text":"<pre><code>find_package (\n    glfw3 3.3 REQUIRED\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/CMakeLists.txt</code></p>"},{"location":"api/src_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>find_package(glfw3 3.3 REQUIRED)\n\nadd_compile_definitions(VK_USE_PLATFORM_XLIB_KHR)\n\nset(VULKAN_FILES\n    src/display/x11_direct.hpp\n    src/display/x11_direct.cpp\n    src/display/glfw_extended.hpp\n    src/display/glfw_extended.cpp\n    src/display/headless.hpp\n    src/display/headless.cpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/vk/vk_extension_request.hpp\n    ${CMAKE_SOURCE_DIR}/include/illixr/vk/vulkan_objects.hpp\n)\n\nadd_executable(main${ILLIXR_BUILD_SUFFIX}.exe\n               src/main.cpp\n               src/illixr.hpp\n               src/cxxopts.hpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/runtime.hpp\n               ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n)\n\nadd_library(plugin.main${ILLIXR_BUILD_SUFFIX} SHARED\n            src/plugin.cpp\n            src/runtime_impl.cpp\n            src/illixr.hpp\n            src/cxxopts.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/runtime.hpp\n            ${CMAKE_SOURCE_DIR}/include/illixr/phonebook.hpp\n            ${VULKAN_FILES}\n)\n\n##############\n# yaml parser\n##############\nif(BUILD_OXR_INTERFACE)\n    target_compile_definitions(plugin.main${ILLIXR_BUILD_SUFFIX} PUBLIC -DOXR_INTERFACE)\nendif()\nmessage(\"plugin.main${ILLIXR_BUILD_SUFFIX}\")\nget_external(Yamlcpp)\n\ntarget_compile_definitions(plugin.main${ILLIXR_BUILD_SUFFIX} PRIVATE \"ILLIXR_VISUALIZERS='${VIS_NAMES}'\")\n\nif(Vulkan_DEP_STR)\n    add_dependencies(plugin.main${ILLIXR_BUILD_SUFFIX} ${Vulkan_DEP_STR})\nendif()\n\ntarget_compile_definitions(plugin.main${ILLIXR_BUILD_SUFFIX} PRIVATE ILLIXR_INSTALL_PATH=\"${CMAKE_INSTALL_PREFIX}\")\ntarget_include_directories(plugin.main${ILLIXR_BUILD_SUFFIX} PUBLIC\n                           ${Boost_INCLUDE_DIR}\n                           ${X11_INCLUDE_DIR}\n                           ${GLEW_INCLUDE_DIR}\n                           ${SQLite3_INCLUDE_DIR}\n                           ${GLU_INCLUDE_DIR}\n                           ${gl_INCLUDE_DIRS}\n                           ${yaml-cpp_INCLUDE_DIRS}\n                           ${CMAKE_SOURCE_DIR}/include\n                           ${Vulkan_INCLUDE_DIRS}\n)\ntarget_link_libraries(plugin.main${ILLIXR_BUILD_SUFFIX} PUBLIC\n                      ${X11_LIBRARIES}\n                      ${GLEW_LIBRARIES}\n                      ${SQLite3_LIBRARIES}\n                      ${glu_LDFLAGS}\n                      ${gl_LIBRARIES}\n                      dl\n                      Threads::Threads\n                      stdc++fs\n                      ${yaml-cpp_LIBRARIES}\n                      spdlog::spdlog\n                      Boost::serialization\n                      illixr_vulkan_utils\n                      glfw\n                      ${Vulkan_LIBRARIES}\n)\n\n\ntarget_include_directories(main${ILLIXR_BUILD_SUFFIX}.exe PUBLIC ${CMAKE_SOURCE_DIR}/include)\ntarget_link_libraries(main${ILLIXR_BUILD_SUFFIX}.exe dl stdc++fs plugin.main${ILLIXR_BUILD_SUFFIX})\n\n\ninstall(TARGETS main${ILLIXR_BUILD_SUFFIX}.exe DESTINATION bin)\ninstall(TARGETS plugin.main${ILLIXR_BUILD_SUFFIX} DESTINATION lib)\n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/","title":"File cxxopts.hpp","text":"<p>FileList &gt; src &gt; cxxopts.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;locale&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> </ul>"},{"location":"api/src_2cxxopts_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cxxopts namespace exceptions namespace values namespace detail namespace parser_tool"},{"location":"api/src_2cxxopts_8hpp/#classes","title":"Classes","text":"Type Name struct HelpGroupDetails struct HelpOptionDetails class KeyValue struct Option class OptionAdder class OptionDetails class OptionParser class OptionValue class Options class ParseResult class Iterator class Value class exception class gratuitous_argument_for_option class incorrect_argument_type class invalid_option_format class invalid_option_syntax class missing_argument class no_such_option class option_already_exists class option_has_no_value class option_requires_argument class parsing class requested_option_not_present class specification class abstract_value &lt;typename T&gt; struct SignedCheck&lt; T, false &gt; &lt;typename T&gt; struct SignedCheck&lt; T, true &gt; &lt;typename T&gt; struct ArguDesc struct IntegerDesc class standard_value &lt;typename T&gt; class standard_value&lt; bool &gt; &lt;&gt; struct type_is_container &lt;typename T&gt; struct type_is_container&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"api/src_2cxxopts_8hpp/#macros","title":"Macros","text":"Type Name define CXXOPTS_DIAGNOSTIC_POP define CXXOPTS_DIAGNOSTIC_PUSH define CXXOPTS_IGNORE_WARNING (x)  define CXXOPTS_LINKONCE define CXXOPTS_LINKONCE_CONST define CXXOPTS_NODISCARD define CXXOPTS_RTTI_CAST <code>dynamic\\_cast</code> define CXXOPTS_VECTOR_DELIMITER <code>','</code> define CXXOPTS__VERSION_MAJOR <code>3</code> define CXXOPTS__VERSION_MINOR <code>1</code> define CXXOPTS__VERSION_PATCH <code>1</code>"},{"location":"api/src_2cxxopts_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_diagnostic_pop","title":"define CXXOPTS_DIAGNOSTIC_POP","text":"<pre><code>#define CXXOPTS_DIAGNOSTIC_POP \n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_diagnostic_push","title":"define CXXOPTS_DIAGNOSTIC_PUSH","text":"<pre><code>#define CXXOPTS_DIAGNOSTIC_PUSH \n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_ignore_warning","title":"define CXXOPTS_IGNORE_WARNING","text":"<pre><code>#define CXXOPTS_IGNORE_WARNING (\n    x\n) \n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_linkonce","title":"define CXXOPTS_LINKONCE","text":"<pre><code>#define CXXOPTS_LINKONCE \n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_linkonce_const","title":"define CXXOPTS_LINKONCE_CONST","text":"<pre><code>#define CXXOPTS_LINKONCE_CONST \n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_nodiscard","title":"define CXXOPTS_NODISCARD","text":"<pre><code>#define CXXOPTS_NODISCARD \n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_rtti_cast","title":"define CXXOPTS_RTTI_CAST","text":"<pre><code>#define CXXOPTS_RTTI_CAST `dynamic_cast`\n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts_vector_delimiter","title":"define CXXOPTS_VECTOR_DELIMITER","text":"<pre><code>#define CXXOPTS_VECTOR_DELIMITER `','`\n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts__version_major","title":"define CXXOPTS__VERSION_MAJOR","text":"<pre><code>#define CXXOPTS__VERSION_MAJOR `3`\n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts__version_minor","title":"define CXXOPTS__VERSION_MINOR","text":"<pre><code>#define CXXOPTS__VERSION_MINOR `1`\n</code></pre>"},{"location":"api/src_2cxxopts_8hpp/#define-cxxopts__version_patch","title":"define CXXOPTS__VERSION_PATCH","text":"<pre><code>#define CXXOPTS__VERSION_PATCH `1`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/cxxopts.hpp</code></p>"},{"location":"api/src_2cxxopts_8hpp_source/","title":"File cxxopts.hpp","text":"<p>File List &gt; src &gt; cxxopts.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n\nCopyright (c) 2014-2022 Jarryd Beck\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// vim: ts=2:sw=2:expandtab\n\n#ifndef CXXOPTS_HPP_INCLUDED\n#define CXXOPTS_HPP_INCLUDED\n\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n#include &lt;exception&gt;\n#include &lt;initializer_list&gt;\n#include &lt;limits&gt;\n#include &lt;locale&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#ifdef CXXOPTS_NO_EXCEPTIONS\n    #include &lt;iostream&gt;\n#endif\n\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n    #if (__GNUC__ * 10 + __GNUC_MINOR__) &lt; 49\n        #define CXXOPTS_NO_REGEX true\n    #endif\n#endif\n#if defined(_MSC_VER) &amp;&amp; !defined(__clang__)\n    #define CXXOPTS_LINKONCE_CONST __declspec(selectany) extern\n    #define CXXOPTS_LINKONCE       __declspec(selectany) extern\n#else\n    #define CXXOPTS_LINKONCE_CONST\n    #define CXXOPTS_LINKONCE\n#endif\n\n#ifndef CXXOPTS_NO_REGEX\n    #include &lt;regex&gt;\n#endif // CXXOPTS_NO_REGEX\n\n// Nonstandard before C++17, which is coincidentally what we also need for &lt;optional&gt;\n#ifdef __has_include\n    #if __has_include(&lt;optional&gt;)\n        #include &lt;optional&gt;\n        #ifdef __cpp_lib_optional\n            #define CXXOPTS_HAS_OPTIONAL\n        #endif\n    #endif\n#endif\n\n#if __cplusplus &gt;= 201603L\n    #define CXXOPTS_NODISCARD [[nodiscard]]\n#else\n    #define CXXOPTS_NODISCARD\n#endif\n\n#ifndef CXXOPTS_VECTOR_DELIMITER\n    #define CXXOPTS_VECTOR_DELIMITER ','\n#endif\n\n#define CXXOPTS__VERSION_MAJOR 3\n#define CXXOPTS__VERSION_MINOR 1\n#define CXXOPTS__VERSION_PATCH 1\n\n#if (__GNUC__ &lt; 10 || (__GNUC__ == 10 &amp;&amp; __GNUC_MINOR__ &lt; 1)) &amp;&amp; __GNUC__ &gt;= 6\n    #define CXXOPTS_NULL_DEREF_IGNORE\n#endif\n\n#if defined(__GNUC__)\n    #define DO_PRAGMA(x)              _Pragma(#x)\n    #define CXXOPTS_DIAGNOSTIC_PUSH   DO_PRAGMA(GCC diagnostic push)\n    #define CXXOPTS_DIAGNOSTIC_POP    DO_PRAGMA(GCC diagnostic pop)\n    #define CXXOPTS_IGNORE_WARNING(x) DO_PRAGMA(GCC diagnostic ignored x)\n#else\n    // define other compilers here if needed\n    #define CXXOPTS_DIAGNOSTIC_PUSH\n    #define CXXOPTS_DIAGNOSTIC_POP\n    #define CXXOPTS_IGNORE_WARNING(x)\n#endif\n\n#ifdef CXXOPTS_NO_RTTI\n    #define CXXOPTS_RTTI_CAST static_cast\n#else\n    #define CXXOPTS_RTTI_CAST dynamic_cast\n#endif\n\nnamespace cxxopts {\nstatic constexpr struct {\n    uint8_t major, minor, patch;\n} version = {CXXOPTS__VERSION_MAJOR, CXXOPTS__VERSION_MINOR, CXXOPTS__VERSION_PATCH};\n} // namespace cxxopts\n\n// when we ask cxxopts to use Unicode, help strings are processed using ICU,\n// which results in the correct lengths being computed for strings when they\n// are formatted for the help output\n// it is necessary to make sure that &lt;unicode/unistr.h&gt; can be found by the\n// compiler, and that icu-uc is linked in to the binary.\n\n#ifdef CXXOPTS_USE_UNICODE\n    #include &lt;unicode/unistr.h&gt;\n\nnamespace cxxopts {\n\nusing String = icu::UnicodeString;\n\ninline String toLocalString(std::string s) {\n    return icu::UnicodeString::fromUTF8(std::move(s));\n}\n\n// GNU GCC with -Weffc++ will issue a warning regarding the upcoming class, we want to silence it:\n// warning: base class 'class std::enable_shared_from_this&lt;cxxopts::Value&gt;' has accessible non-virtual destructor\nCXXOPTS_DIAGNOSTIC_PUSH\nCXXOPTS_IGNORE_WARNING(\"-Wnon-virtual-dtor\")\n\n// This will be ignored under other compilers like LLVM clang.\nclass UnicodeStringIterator {\npublic:\n    using iterator_category = std::forward_iterator_tag;\n    using value_type        = int32_t;\n    using difference_type   = std::ptrdiff_t;\n    using pointer           = value_type*;\n    using reference         = value_type&amp;;\n\n    UnicodeStringIterator(const icu::UnicodeString* string, int32_t pos)\n        : s(string)\n        , i(pos) { }\n\n    value_type operator*() const {\n        return s-&gt;char32At(i);\n    }\n\n    bool operator==(const UnicodeStringIterator&amp; rhs) const {\n        return s == rhs.s &amp;&amp; i == rhs.i;\n    }\n\n    bool operator!=(const UnicodeStringIterator&amp; rhs) const {\n        return !(*this == rhs);\n    }\n\n    UnicodeStringIterator&amp; operator++() {\n        ++i;\n        return *this;\n    }\n\n    UnicodeStringIterator operator+(int32_t v) {\n        return UnicodeStringIterator(s, i + v);\n    }\n\nprivate:\n    const icu::UnicodeString* s;\n    int32_t                   i;\n};\n\nCXXOPTS_DIAGNOSTIC_POP\n\ninline String&amp; stringAppend(String&amp; s, String a) {\n    return s.append(std::move(a));\n}\n\ninline String&amp; stringAppend(String&amp; s, std::size_t n, UChar32 c) {\n    for (std::size_t i = 0; i != n; ++i) {\n        s.append(c);\n    }\n\n    return s;\n}\n\ntemplate&lt;typename Iterator&gt;\nString&amp; stringAppend(String&amp; s, Iterator begin, Iterator end) {\n    while (begin != end) {\n        s.append(*begin);\n        ++begin;\n    }\n\n    return s;\n}\n\ninline size_t stringLength(const String&amp; s) {\n    return static_cast&lt;size_t&gt;(s.length());\n}\n\ninline std::string toUTF8String(const String&amp; s) {\n    std::string result;\n    s.toUTF8String(result);\n\n    return result;\n}\n\ninline bool empty(const String&amp; s) {\n    return s.isEmpty();\n}\n\n} // namespace cxxopts\n\nnamespace std {\n\ninline cxxopts::UnicodeStringIterator begin(const icu::UnicodeString&amp; s) {\n    return cxxopts::UnicodeStringIterator(&amp;s, 0);\n}\n\ninline cxxopts::UnicodeStringIterator end(const icu::UnicodeString&amp; s) {\n    return cxxopts::UnicodeStringIterator(&amp;s, s.length());\n}\n\n} // namespace std\n\n// ifdef CXXOPTS_USE_UNICODE\n#else\n\nnamespace cxxopts {\n\nusing String = std::string;\n\ntemplate&lt;typename T&gt;\nT toLocalString(T&amp;&amp; t) {\n    return std::forward&lt;T&gt;(t);\n}\n\ninline std::size_t stringLength(const String&amp; s) {\n    return s.length();\n}\n\ninline String&amp; stringAppend(String&amp; s, const String&amp; a) {\n    return s.append(a);\n}\n\ninline String&amp; stringAppend(String&amp; s, std::size_t n, char c) {\n    return s.append(n, c);\n}\n\ntemplate&lt;typename Iterator&gt;\nString&amp; stringAppend(String&amp; s, Iterator begin, Iterator end) {\n    return s.append(begin, end);\n}\n\ntemplate&lt;typename T&gt;\nstd::string toUTF8String(T&amp;&amp; t) {\n    return std::forward&lt;T&gt;(t);\n}\n\ninline bool empty(const std::string&amp; s) {\n    return s.empty();\n}\n\n} // namespace cxxopts\n\n// ifdef CXXOPTS_USE_UNICODE\n#endif\n\nnamespace cxxopts {\n\nnamespace {\n    CXXOPTS_LINKONCE_CONST std::string LQUOTE(\"\\'\");\n    CXXOPTS_LINKONCE_CONST std::string RQUOTE(\"\\'\");\n} // namespace\n\n// GNU GCC with -Weffc++ will issue a warning regarding the upcoming class, we\n// want to silence it: warning: base class 'class\n// std::enable_shared_from_this&lt;cxxopts::Value&gt;' has accessible non-virtual\n// destructor This will be ignored under other compilers like LLVM clang.\nCXXOPTS_DIAGNOSTIC_PUSH\nCXXOPTS_IGNORE_WARNING(\"-Wnon-virtual-dtor\")\n\n// some older versions of GCC warn under this warning\nCXXOPTS_IGNORE_WARNING(\"-Weffc++\")\n\nclass Value : public std::enable_shared_from_this&lt;Value&gt; {\npublic:\n    virtual ~Value() = default;\n\n    virtual std::shared_ptr&lt;Value&gt; clone() const = 0;\n\n    virtual void parse(const std::string&amp; text) const = 0;\n\n    virtual void parse() const = 0;\n\n    virtual bool has_default() const = 0;\n\n    virtual bool is_container() const = 0;\n\n    virtual bool has_implicit() const = 0;\n\n    virtual std::string get_default_value() const = 0;\n\n    virtual std::string get_implicit_value() const = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; default_value(const std::string&amp; value) = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; implicit_value(const std::string&amp; value) = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; no_implicit_value() = 0;\n\n    virtual bool is_boolean() const = 0;\n};\n\nCXXOPTS_DIAGNOSTIC_POP\n\nnamespace exceptions {\n\n    class exception : public std::exception {\n    public:\n        explicit exception(std::string message)\n            : m_message(std::move(message)) { }\n\n        CXXOPTS_NODISCARD\n        const char* what() const noexcept override {\n            return m_message.c_str();\n        }\n\n    private:\n        std::string m_message;\n    };\n\n    class specification : public exception {\n    public:\n        explicit specification(const std::string&amp; message)\n            : exception(message) { }\n    };\n\n    class parsing : public exception {\n    public:\n        explicit parsing(const std::string&amp; message)\n            : exception(message) { }\n    };\n\n    class option_already_exists : public specification {\n    public:\n        explicit option_already_exists(const std::string&amp; option)\n            : specification(\"Option \" + LQUOTE + option + RQUOTE + \" already exists\") { }\n    };\n\n    class invalid_option_format : public specification {\n    public:\n        explicit invalid_option_format(const std::string&amp; format)\n            : specification(\"Invalid option format \" + LQUOTE + format + RQUOTE) { }\n    };\n\n    class invalid_option_syntax : public parsing {\n    public:\n        explicit invalid_option_syntax(const std::string&amp; text)\n            : parsing(\"Argument \" + LQUOTE + text + RQUOTE + \" starts with a - but has incorrect syntax\") { }\n    };\n\n    class no_such_option : public parsing {\n    public:\n        explicit no_such_option(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" does not exist\") { }\n    };\n\n    class missing_argument : public parsing {\n    public:\n        explicit missing_argument(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" is missing an argument\") { }\n    };\n\n    class option_requires_argument : public parsing {\n    public:\n        explicit option_requires_argument(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" requires an argument\") { }\n    };\n\n    class gratuitous_argument_for_option : public parsing {\n    public:\n        gratuitous_argument_for_option(const std::string&amp; option, const std::string&amp; arg)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" does not take an argument, but argument \" + LQUOTE + arg +\n                      RQUOTE + \" given\") { }\n    };\n\n    class requested_option_not_present : public parsing {\n    public:\n        explicit requested_option_not_present(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" not present\") { }\n    };\n\n    class option_has_no_value : public exception {\n    public:\n        explicit option_has_no_value(const std::string&amp; option)\n            : exception(!option.empty() ? (\"Option \" + LQUOTE + option + RQUOTE + \" has no value\") : \"Option has no value\") { }\n    };\n\n    class incorrect_argument_type : public parsing {\n    public:\n        explicit incorrect_argument_type(const std::string&amp; arg)\n            : parsing(\"Argument \" + LQUOTE + arg + RQUOTE + \" failed to parse\") { }\n    };\n\n} // namespace exceptions\n\ntemplate&lt;typename T&gt;\nvoid throw_or_mimic(const std::string&amp; text) {\n    static_assert(std::is_base_of&lt;std::exception, T&gt;::value,\n                  \"throw_or_mimic only works on std::exception and \"\n                  \"deriving classes\");\n\n#ifndef CXXOPTS_NO_EXCEPTIONS\n    // If CXXOPTS_NO_EXCEPTIONS is not defined, just throw\n    throw T{text};\n#else\n    // Otherwise manually instantiate the exception, print what() to stderr,\n    // and exit\n    T exception{text};\n    std::cerr &lt;&lt; exception.what() &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n#endif\n}\n\nusing OptionNames = std::vector&lt;std::string&gt;;\n\nnamespace values {\n\n    namespace parser_tool {\n\n        struct IntegerDesc {\n            std::string negative = \"\";\n            std::string base     = \"\";\n            std::string value    = \"\";\n        };\n\n        struct ArguDesc {\n            std::string arg_name  = \"\";\n            bool        grouping  = false;\n            bool        set_value = false;\n            std::string value     = \"\";\n        };\n\n#ifdef CXXOPTS_NO_REGEX\n        inline IntegerDesc SplitInteger(const std::string&amp; text) {\n            if (text.empty()) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n            IntegerDesc desc;\n            const char* pdata = text.c_str();\n            if (*pdata == '-') {\n                pdata += 1;\n                desc.negative = \"-\";\n            }\n            if (strncmp(pdata, \"0x\", 2) == 0) {\n                pdata += 2;\n                desc.base = \"0x\";\n            }\n            if (*pdata != '\\0') {\n                desc.value = std::string(pdata);\n            } else {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n            return desc;\n        }\n\n        inline bool IsTrueText(const std::string&amp; text) {\n            const char* pdata = text.c_str();\n            if (*pdata == 't' || *pdata == 'T') {\n                pdata += 1;\n                if (strncmp(pdata, \"rue\\0\", 4) == 0) {\n                    return true;\n                }\n            } else if (strncmp(pdata, \"1\\0\", 2) == 0) {\n                return true;\n            }\n            return false;\n        }\n\n        inline bool IsFalseText(const std::string&amp; text) {\n            const char* pdata = text.c_str();\n            if (*pdata == 'f' || *pdata == 'F') {\n                pdata += 1;\n                if (strncmp(pdata, \"alse\\0\", 5) == 0) {\n                    return true;\n                }\n            } else if (strncmp(pdata, \"0\\0\", 2) == 0) {\n                return true;\n            }\n            return false;\n        }\n\n        inline OptionNames split_option_names(const std::string&amp; text) {\n            OptionNames split_names;\n\n            std::string::size_type token_start_pos = 0;\n            auto                   length          = text.length();\n\n            if (length == 0) {\n                throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n            }\n\n            while (token_start_pos &lt; length) {\n                const auto&amp; npos               = std::string::npos;\n                auto        next_non_space_pos = text.find_first_not_of(' ', token_start_pos);\n                if (next_non_space_pos == npos) {\n                    throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                }\n                token_start_pos         = next_non_space_pos;\n                auto next_delimiter_pos = text.find(',', token_start_pos);\n                if (next_delimiter_pos == token_start_pos) {\n                    throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                }\n                if (next_delimiter_pos == npos) {\n                    next_delimiter_pos = length;\n                }\n                auto token_length = next_delimiter_pos - token_start_pos;\n                // validate the token itself matches the regex /([:alnum:][-_[:alnum:]]*/\n                {\n                    const char* option_name_valid_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                                                          \"abcdefghijklmnopqrstuvwxyz\"\n                                                          \"0123456789\"\n                                                          \"_-.?\";\n\n                    if (!std::isalnum(text[token_start_pos], std::locale::classic()) ||\n                        text.find_first_not_of(option_name_valid_chars, token_start_pos) &lt; next_delimiter_pos) {\n                        throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                    }\n                }\n                split_names.emplace_back(text.substr(token_start_pos, token_length));\n                token_start_pos = next_delimiter_pos + 1;\n            }\n            return split_names;\n        }\n\n        inline ArguDesc ParseArgument(const char* arg, bool&amp; matched) {\n            ArguDesc    argu_desc;\n            const char* pdata = arg;\n            matched           = false;\n            if (strncmp(pdata, \"--\", 2) == 0) {\n                pdata += 2;\n                if (isalnum(*pdata, std::locale::classic())) {\n                    argu_desc.arg_name.push_back(*pdata);\n                    pdata += 1;\n                    while (isalnum(*pdata, std::locale::classic()) || *pdata == '-' || *pdata == '_') {\n                        argu_desc.arg_name.push_back(*pdata);\n                        pdata += 1;\n                    }\n                    if (argu_desc.arg_name.length() &gt; 1) {\n                        if (*pdata == '=') {\n                            argu_desc.set_value = true;\n                            pdata += 1;\n                            if (*pdata != '\\0') {\n                                argu_desc.value = std::string(pdata);\n                            }\n                            matched = true;\n                        } else if (*pdata == '\\0') {\n                            matched = true;\n                        }\n                    }\n                }\n            } else if (strncmp(pdata, \"-\", 1) == 0) {\n                pdata += 1;\n                argu_desc.grouping = true;\n                while (isalnum(*pdata, std::locale::classic())) {\n                    argu_desc.arg_name.push_back(*pdata);\n                    pdata += 1;\n                }\n                matched = !argu_desc.arg_name.empty() &amp;&amp; *pdata == '\\0';\n            }\n            return argu_desc;\n        }\n\n#else // CXXOPTS_NO_REGEX\n\n        namespace {\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; integer_pattern(\"(-)?(0x)?([0-9a-zA-Z]+)|((0x)?0)\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; truthy_pattern(\"(t|T)(rue)?|1\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; falsy_pattern(\"(f|F)(alse)?|0\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_matcher(\"--([[:alnum:]][-_[:alnum:]\\\\.]+)(=(.*))?|-([[:alnum:]].*)\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_specifier(\"([[:alnum:]][-_[:alnum:]\\\\.]*)(,[ ]*[[:alnum:]][-_[:alnum:]]*)*\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_specifier_separator(\", *\");\n\n        } // namespace\n\n        inline IntegerDesc SplitInteger(const std::string&amp; text) {\n            std::smatch match;\n            std::regex_match(text, match, integer_pattern);\n\n            if (match.length() == 0) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            IntegerDesc desc;\n            desc.negative = match[1];\n            desc.base     = match[2];\n            desc.value    = match[3];\n\n            if (match.length(4) &gt; 0) {\n                desc.base  = match[5];\n                desc.value = \"0\";\n                return desc;\n            }\n\n            return desc;\n        }\n\n        inline bool IsTrueText(const std::string&amp; text) {\n            std::smatch result;\n            std::regex_match(text, result, truthy_pattern);\n            return !result.empty();\n        }\n\n        inline bool IsFalseText(const std::string&amp; text) {\n            std::smatch result;\n            std::regex_match(text, result, falsy_pattern);\n            return !result.empty();\n        }\n\n        // Gets the option names specified via a single, comma-separated string,\n        // and returns the separate, space-discarded, non-empty names\n        // (without considering which or how many are single-character)\n        inline OptionNames split_option_names(const std::string&amp; text) {\n            if (!std::regex_match(text.c_str(), option_specifier)) {\n                throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n            }\n\n            OptionNames split_names;\n\n            constexpr int use_non_matches{-1};\n            auto          token_iterator =\n                std::sregex_token_iterator(text.begin(), text.end(), option_specifier_separator, use_non_matches);\n            std::copy(token_iterator, std::sregex_token_iterator(), std::back_inserter(split_names));\n            return split_names;\n        }\n\n        inline ArguDesc ParseArgument(const char* arg, bool&amp; matched) {\n            std::match_results&lt;const char*&gt; result;\n            std::regex_match(arg, result, option_matcher);\n            matched = !result.empty();\n\n            ArguDesc argu_desc;\n            if (matched) {\n                argu_desc.arg_name  = result[1].str();\n                argu_desc.set_value = result[2].length() &gt; 0;\n                argu_desc.value     = result[3].str();\n                if (result[4].length() &gt; 0) {\n                    argu_desc.grouping = true;\n                    argu_desc.arg_name = result[4].str();\n                }\n            }\n\n            return argu_desc;\n        }\n\n#endif // CXXOPTS_NO_REGEX\n#undef CXXOPTS_NO_REGEX\n    } // namespace parser_tool\n\n    namespace detail {\n\n        template&lt;typename T, bool B&gt;\n        struct SignedCheck;\n\n        template&lt;typename T&gt;\n        struct SignedCheck&lt;T, true&gt; {\n            template&lt;typename U&gt;\n            void operator()(bool negative, U u, const std::string&amp; text) {\n                if (negative) {\n                    if (u &gt; static_cast&lt;U&gt;((std::numeric_limits&lt;T&gt;::min)())) {\n                        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n                    }\n                } else {\n                    if (u &gt; static_cast&lt;U&gt;((std::numeric_limits&lt;T&gt;::max)())) {\n                        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n                    }\n                }\n            }\n        };\n\n        template&lt;typename T&gt;\n        struct SignedCheck&lt;T, false&gt; {\n            template&lt;typename U&gt;\n            void operator()(bool, U, const std::string&amp;) const { }\n        };\n\n        template&lt;typename T, typename U&gt;\n        void check_signed_range(bool negative, U value, const std::string&amp; text) {\n            SignedCheck&lt;T, std::numeric_limits&lt;T&gt;::is_signed&gt;()(negative, value, text);\n        }\n\n    } // namespace detail\n\n    template&lt;typename R, typename T&gt;\n    void checked_negate(R&amp; r, T&amp;&amp; t, const std::string&amp;, std::true_type) {\n        // if we got to here, then `t` is a positive number that fits into\n        // `R`. So to avoid MSVC C4146, we first cast it to `R`.\n        // See https://github.com/jarro2783/cxxopts/issues/62 for more details.\n        r = static_cast&lt;R&gt;(-static_cast&lt;R&gt;(t - 1) - 1);\n    }\n\n    template&lt;typename R, typename T&gt;\n    void checked_negate(R&amp;, T&amp;&amp;, const std::string&amp; text, std::false_type) {\n        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n    }\n\n    template&lt;typename T&gt;\n    void integer_parser(const std::string&amp; text, T&amp; value) {\n        parser_tool::IntegerDesc int_desc = parser_tool::SplitInteger(text);\n\n        using US                 = typename std::make_unsigned&lt;T&gt;::type;\n        constexpr bool is_signed = std::numeric_limits&lt;T&gt;::is_signed;\n\n        const bool         negative    = int_desc.negative.length() &gt; 0;\n        const uint8_t      base        = int_desc.base.length() &gt; 0 ? 16 : 10;\n        const std::string&amp; value_match = int_desc.value;\n\n        US result = 0;\n\n        for (char ch : value_match) {\n            US digit = 0;\n\n            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {\n                digit = static_cast&lt;US&gt;(ch - '0');\n            } else if (base == 16 &amp;&amp; ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') {\n                digit = static_cast&lt;US&gt;(ch - 'a' + 10);\n            } else if (base == 16 &amp;&amp; ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') {\n                digit = static_cast&lt;US&gt;(ch - 'A' + 10);\n            } else {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            const US next = static_cast&lt;US&gt;(result * base + digit);\n            if (result &gt; next) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            result = next;\n        }\n\n        detail::check_signed_range&lt;T&gt;(negative, result, text);\n\n        if (negative) {\n            checked_negate&lt;T&gt;(value, result, text, std::integral_constant&lt;bool, is_signed&gt;());\n        } else {\n            value = static_cast&lt;T&gt;(result);\n        }\n    }\n\n    template&lt;typename T&gt;\n    void stringstream_parser(const std::string&amp; text, T&amp; value) {\n        std::stringstream in(text);\n        in &gt;&gt; value;\n        if (!in) {\n            throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n        }\n    }\n\n    template&lt;typename T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;\n    void parse_value(const std::string&amp; text, T&amp; value) {\n        integer_parser(text, value);\n    }\n\n    inline void parse_value(const std::string&amp; text, bool&amp; value) {\n        if (parser_tool::IsTrueText(text)) {\n            value = true;\n            return;\n        }\n\n        if (parser_tool::IsFalseText(text)) {\n            value = false;\n            return;\n        }\n\n        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n    }\n\n    inline void parse_value(const std::string&amp; text, std::string&amp; value) {\n        value = text;\n    }\n\n    // The fallback parser. It uses the stringstream parser to parse all types\n    // that have not been overloaded explicitly.  It has to be placed in the\n    // source code before all other more specialized templates.\n    template&lt;typename T, typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;\n    void parse_value(const std::string&amp; text, T&amp; value) {\n        stringstream_parser(text, value);\n    }\n\n    template&lt;typename T&gt;\n    void parse_value(const std::string&amp; text, std::vector&lt;T&gt;&amp; value) {\n        if (text.empty()) {\n            T v;\n            parse_value(text, v);\n            value.emplace_back(std::move(v));\n            return;\n        }\n        std::stringstream in(text);\n        std::string       token;\n        while (!in.eof() &amp;&amp; std::getline(in, token, CXXOPTS_VECTOR_DELIMITER)) {\n            T v;\n            parse_value(token, v);\n            value.emplace_back(std::move(v));\n        }\n    }\n\n#ifdef CXXOPTS_HAS_OPTIONAL\n    template&lt;typename T&gt;\n    void parse_value(const std::string&amp; text, std::optional&lt;T&gt;&amp; value) {\n        T result;\n        parse_value(text, result);\n        value = std::move(result);\n    }\n#endif\n\n    inline void parse_value(const std::string&amp; text, char&amp; c) {\n        if (text.length() != 1) {\n            throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n        }\n\n        c = text[0];\n    }\n\n    template&lt;typename T&gt;\n    struct type_is_container {\n        static constexpr bool value = false;\n    };\n\n    template&lt;typename T&gt;\n    struct type_is_container&lt;std::vector&lt;T&gt;&gt; {\n        static constexpr bool value = true;\n    };\n\n    template&lt;typename T&gt;\n    class abstract_value : public Value {\n        using Self = abstract_value&lt;T&gt;;\n\n    public:\n        abstract_value()\n            : m_result(std::make_shared&lt;T&gt;())\n            , m_store(m_result.get()) { }\n\n        explicit abstract_value(T* t)\n            : m_store(t) { }\n\n        ~abstract_value() override = default;\n\n        abstract_value&amp; operator=(const abstract_value&amp;) = default;\n\n        abstract_value(const abstract_value&amp; rhs) {\n            if (rhs.m_result) {\n                m_result = std::make_shared&lt;T&gt;();\n                m_store  = m_result.get();\n            } else {\n                m_store = rhs.m_store;\n            }\n\n            m_default        = rhs.m_default;\n            m_implicit       = rhs.m_implicit;\n            m_default_value  = rhs.m_default_value;\n            m_implicit_value = rhs.m_implicit_value;\n        }\n\n        void parse(const std::string&amp; text) const override {\n            parse_value(text, *m_store);\n        }\n\n        bool is_container() const override {\n            return type_is_container&lt;T&gt;::value;\n        }\n\n        void parse() const override {\n            parse_value(m_default_value, *m_store);\n        }\n\n        bool has_default() const override {\n            return m_default;\n        }\n\n        bool has_implicit() const override {\n            return m_implicit;\n        }\n\n        std::shared_ptr&lt;Value&gt; default_value(const std::string&amp; value) override {\n            m_default       = true;\n            m_default_value = value;\n            return shared_from_this();\n        }\n\n        std::shared_ptr&lt;Value&gt; implicit_value(const std::string&amp; value) override {\n            m_implicit       = true;\n            m_implicit_value = value;\n            return shared_from_this();\n        }\n\n        std::shared_ptr&lt;Value&gt; no_implicit_value() override {\n            m_implicit = false;\n            return shared_from_this();\n        }\n\n        std::string get_default_value() const override {\n            return m_default_value;\n        }\n\n        std::string get_implicit_value() const override {\n            return m_implicit_value;\n        }\n\n        bool is_boolean() const override {\n            return std::is_same&lt;T, bool&gt;::value;\n        }\n\n        const T&amp; get() const {\n            if (m_store == nullptr) {\n                return *m_result;\n            }\n            return *m_store;\n        }\n\n    protected:\n        std::shared_ptr&lt;T&gt; m_result{};\n        T*                 m_store{};\n\n        bool m_default  = false;\n        bool m_implicit = false;\n\n        std::string m_default_value{};\n        std::string m_implicit_value{};\n    };\n\n    template&lt;typename T&gt;\n    class standard_value : public abstract_value&lt;T&gt; {\n    public:\n        using abstract_value&lt;T&gt;::abstract_value;\n\n        CXXOPTS_NODISCARD\n        std::shared_ptr&lt;Value&gt; clone() const override {\n            return std::make_shared&lt;standard_value&lt;T&gt;&gt;(*this);\n        }\n    };\n\n    template&lt;&gt;\n    class standard_value&lt;bool&gt; : public abstract_value&lt;bool&gt; {\n    public:\n        ~standard_value() override = default;\n\n        standard_value() {\n            set_default_and_implicit();\n        }\n\n        explicit standard_value(bool* b)\n            : abstract_value(b) {\n            m_implicit       = true;\n            m_implicit_value = \"true\";\n        }\n\n        std::shared_ptr&lt;Value&gt; clone() const override {\n            return std::make_shared&lt;standard_value&lt;bool&gt;&gt;(*this);\n        }\n\n    private:\n        void set_default_and_implicit() {\n            m_default        = true;\n            m_default_value  = \"false\";\n            m_implicit       = true;\n            m_implicit_value = \"true\";\n        }\n    };\n\n} // namespace values\n\ntemplate&lt;typename T&gt;\nstd::shared_ptr&lt;Value&gt; value() {\n    return std::make_shared&lt;values::standard_value&lt;T&gt;&gt;();\n}\n\ntemplate&lt;typename T&gt;\nstd::shared_ptr&lt;Value&gt; value(T&amp; t) {\n    return std::make_shared&lt;values::standard_value&lt;T&gt;&gt;(&amp;t);\n}\n\nclass OptionAdder;\n\nCXXOPTS_NODISCARD\ninline const std::string&amp; first_or_empty(const OptionNames&amp; long_names) {\n    static const std::string empty{\"\"};\n    return long_names.empty() ? empty : long_names.front();\n}\n\nclass OptionDetails {\npublic:\n    OptionDetails(std::string short_, OptionNames long_, String desc, std::shared_ptr&lt;const Value&gt; val)\n        : m_short(std::move(short_))\n        , m_long(std::move(long_))\n        , m_desc(std::move(desc))\n        , m_value(std::move(val))\n        , m_count(0) {\n        m_hash = std::hash&lt;std::string&gt;{}(first_long_name() + m_short);\n    }\n\n    OptionDetails(const OptionDetails&amp; rhs)\n        : m_desc(rhs.m_desc)\n        , m_value(rhs.m_value-&gt;clone())\n        , m_count(rhs.m_count) { }\n\n    OptionDetails(OptionDetails&amp;&amp; rhs) = default;\n\n    CXXOPTS_NODISCARD\n    const String&amp; description() const {\n        return m_desc;\n    }\n\n    CXXOPTS_NODISCARD\n    const Value&amp; value() const {\n        return *m_value;\n    }\n\n    CXXOPTS_NODISCARD\n    std::shared_ptr&lt;Value&gt; make_storage() const {\n        return m_value-&gt;clone();\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; short_name() const {\n        return m_short;\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; first_long_name() const {\n        return first_or_empty(m_long);\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; essential_name() const {\n        return m_long.empty() ? m_short : m_long.front();\n    }\n\n    CXXOPTS_NODISCARD\n    const OptionNames&amp; long_names() const {\n        return m_long;\n    }\n\n    std::size_t hash() const {\n        return m_hash;\n    }\n\nprivate:\n    std::string                  m_short{};\n    OptionNames                  m_long{};\n    String                       m_desc{};\n    std::shared_ptr&lt;const Value&gt; m_value{};\n    int                          m_count;\n\n    std::size_t m_hash{};\n};\n\nstruct HelpOptionDetails {\n    std::string s;\n    OptionNames l;\n    String      desc;\n    bool        has_default;\n    std::string default_value;\n    bool        has_implicit;\n    std::string implicit_value;\n    std::string arg_help;\n    bool        is_container;\n    bool        is_boolean;\n};\n\nstruct HelpGroupDetails {\n    std::string                    name{};\n    std::string                    description{};\n    std::vector&lt;HelpOptionDetails&gt; options{};\n};\n\nclass OptionValue {\npublic:\n    void parse(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details, const std::string&amp; text) {\n        ensure_value(details);\n        ++m_count;\n        m_value-&gt;parse(text);\n        m_long_names = &amp;details-&gt;long_names();\n    }\n\n    void parse_default(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        ensure_value(details);\n        m_default    = true;\n        m_long_names = &amp;details-&gt;long_names();\n        m_value-&gt;parse();\n    }\n\n    void parse_no_value(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        m_long_names = &amp;details-&gt;long_names();\n    }\n\n#if defined(CXXOPTS_NULL_DEREF_IGNORE)\n    CXXOPTS_DIAGNOSTIC_PUSH\n    CXXOPTS_IGNORE_WARNING(\"-Wnull-dereference\")\n#endif\n\n    CXXOPTS_NODISCARD\n    std::size_t count() const noexcept {\n        return m_count;\n    }\n\n#if defined(CXXOPTS_NULL_DEREF_IGNORE)\n    CXXOPTS_DIAGNOSTIC_POP\n#endif\n\n    // TODO: maybe default options should count towards the number of arguments\n    CXXOPTS_NODISCARD\n    bool has_default() const noexcept {\n        return m_default;\n    }\n\n    template&lt;typename T&gt;\n    const T&amp; as() const {\n        if (m_value == nullptr) {\n            throw_or_mimic&lt;exceptions::option_has_no_value&gt;(m_long_names == nullptr ? \"\" : first_or_empty(*m_long_names));\n        }\n\n        return CXXOPTS_RTTI_CAST&lt;const values::standard_value&lt;T&gt;&amp;&gt;(*m_value).get();\n    }\n\nprivate:\n    void ensure_value(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        if (m_value == nullptr) {\n            m_value = details-&gt;make_storage();\n        }\n    }\n\n    const OptionNames* m_long_names = nullptr;\n    // Holding this pointer is safe, since OptionValue's only exist in key-value pairs,\n    // where the key has the string we point to.\n    std::shared_ptr&lt;Value&gt; m_value{};\n    std::size_t            m_count   = 0;\n    bool                   m_default = false;\n};\n\nclass KeyValue {\npublic:\n    KeyValue(std::string key_, std::string value_) noexcept\n        : m_key(std::move(key_))\n        , m_value(std::move(value_)) { }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; key() const {\n        return m_key;\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; value() const {\n        return m_value;\n    }\n\n    template&lt;typename T&gt;\n    T as() const {\n        T result;\n        values::parse_value(m_value, result);\n        return result;\n    }\n\nprivate:\n    std::string m_key;\n    std::string m_value;\n};\n\nusing ParsedHashMap = std::unordered_map&lt;std::size_t, OptionValue&gt;;\nusing NameHashMap   = std::unordered_map&lt;std::string, std::size_t&gt;;\n\nclass ParseResult {\npublic:\n    class Iterator {\n    public:\n        using iterator_category = std::forward_iterator_tag;\n        using value_type        = KeyValue;\n        using difference_type   = void;\n        using pointer           = const KeyValue*;\n        using reference         = const KeyValue&amp;;\n\n        Iterator()                = default;\n        Iterator(const Iterator&amp;) = default;\n\n        // GCC complains about m_iter not being initialised in the member\n        // initializer list\n        CXXOPTS_DIAGNOSTIC_PUSH\n        CXXOPTS_IGNORE_WARNING(\"-Weffc++\")\n\n        Iterator(const ParseResult* pr, bool end = false)\n            : m_pr(pr) {\n            if (end) {\n                m_sequential = false;\n                m_iter       = m_pr-&gt;m_defaults.end();\n            } else {\n                m_sequential = true;\n                m_iter       = m_pr-&gt;m_sequential.begin();\n\n                if (m_iter == m_pr-&gt;m_sequential.end()) {\n                    m_sequential = false;\n                    m_iter       = m_pr-&gt;m_defaults.begin();\n                }\n            }\n        }\n\n        CXXOPTS_DIAGNOSTIC_POP\n\n        Iterator&amp; operator++() {\n            ++m_iter;\n            if (m_sequential &amp;&amp; m_iter == m_pr-&gt;m_sequential.end()) {\n                m_sequential = false;\n                m_iter       = m_pr-&gt;m_defaults.begin();\n                return *this;\n            }\n            return *this;\n        }\n\n        Iterator operator++(int) {\n            Iterator retval = *this;\n            ++(*this);\n            return retval;\n        }\n\n        bool operator==(const Iterator&amp; other) const {\n            return (m_sequential == other.m_sequential) &amp;&amp; (m_iter == other.m_iter);\n        }\n\n        bool operator!=(const Iterator&amp; other) const {\n            return !(*this == other);\n        }\n\n        const KeyValue&amp; operator*() {\n            return *m_iter;\n        }\n\n        const KeyValue* operator-&gt;() {\n            return m_iter.operator-&gt;();\n        }\n\n    private:\n        const ParseResult*                    m_pr;\n        std::vector&lt;KeyValue&gt;::const_iterator m_iter;\n        bool                                  m_sequential = true;\n    };\n\n    ParseResult()                   = default;\n    ParseResult(const ParseResult&amp;) = default;\n\n    ParseResult(NameHashMap&amp;&amp; keys, ParsedHashMap&amp;&amp; values, std::vector&lt;KeyValue&gt; sequential,\n                std::vector&lt;KeyValue&gt; default_opts, std::vector&lt;std::string&gt;&amp;&amp; unmatched_args)\n        : m_keys(std::move(keys))\n        , m_values(std::move(values))\n        , m_sequential(std::move(sequential))\n        , m_defaults(std::move(default_opts))\n        , m_unmatched(std::move(unmatched_args)) { }\n\n    ParseResult&amp; operator=(ParseResult&amp;&amp;)      = default;\n    ParseResult&amp; operator=(const ParseResult&amp;) = default;\n\n    Iterator begin() const {\n        return Iterator(this);\n    }\n\n    Iterator end() const {\n        return Iterator(this, true);\n    }\n\n    std::size_t count(const std::string&amp; o) const {\n        auto iter = m_keys.find(o);\n        if (iter == m_keys.end()) {\n            return 0;\n        }\n\n        auto viter = m_values.find(iter-&gt;second);\n\n        if (viter == m_values.end()) {\n            return 0;\n        }\n\n        return viter-&gt;second.count();\n    }\n\n    const OptionValue&amp; operator[](const std::string&amp; option) const {\n        auto iter = m_keys.find(option);\n\n        if (iter == m_keys.end()) {\n            throw_or_mimic&lt;exceptions::requested_option_not_present&gt;(option);\n        }\n\n        auto viter = m_values.find(iter-&gt;second);\n\n        if (viter == m_values.end()) {\n            throw_or_mimic&lt;exceptions::requested_option_not_present&gt;(option);\n        }\n\n        return viter-&gt;second;\n    }\n\n    const std::vector&lt;KeyValue&gt;&amp; arguments() const {\n        return m_sequential;\n    }\n\n    const std::vector&lt;std::string&gt;&amp; unmatched() const {\n        return m_unmatched;\n    }\n\n    const std::vector&lt;KeyValue&gt;&amp; defaults() const {\n        return m_defaults;\n    }\n\n    const std::string arguments_string() const {\n        std::string result;\n        for (const auto&amp; kv : m_sequential) {\n            result += kv.key() + \" = \" + kv.value() + \"\\n\";\n        }\n        for (const auto&amp; kv : m_defaults) {\n            result += kv.key() + \" = \" + kv.value() + \" \" + \"(default)\" + \"\\n\";\n        }\n        return result;\n    }\n\nprivate:\n    NameHashMap              m_keys{};\n    ParsedHashMap            m_values{};\n    std::vector&lt;KeyValue&gt;    m_sequential{};\n    std::vector&lt;KeyValue&gt;    m_defaults{};\n    std::vector&lt;std::string&gt; m_unmatched{};\n};\n\nstruct Option {\n    Option(std::string opts, std::string desc, std::shared_ptr&lt;const Value&gt; value = ::cxxopts::value&lt;bool&gt;(),\n           std::string arg_help = \"\")\n        : opts_(std::move(opts))\n        , desc_(std::move(desc))\n        , value_(std::move(value))\n        , arg_help_(std::move(arg_help)) { }\n\n    std::string                  opts_;\n    std::string                  desc_;\n    std::shared_ptr&lt;const Value&gt; value_;\n    std::string                  arg_help_;\n};\n\nusing OptionMap              = std::unordered_map&lt;std::string, std::shared_ptr&lt;OptionDetails&gt;&gt;;\nusing PositionalList         = std::vector&lt;std::string&gt;;\nusing PositionalListIterator = PositionalList::const_iterator;\n\nclass OptionParser {\npublic:\n    OptionParser(const OptionMap&amp; options, const PositionalList&amp; positional, bool allow_unrecognised)\n        : m_options(options)\n        , m_positional(positional)\n        , m_allow_unrecognised(allow_unrecognised) { }\n\n    ParseResult parse(int argc, const char* const* argv);\n\n    bool consume_positional(const std::string&amp; a, PositionalListIterator&amp; next);\n\n    void checked_parse_arg(int argc, const char* const* argv, int&amp; current, const std::shared_ptr&lt;OptionDetails&gt;&amp; value,\n                           const std::string&amp; name);\n\n    void add_to_option(OptionMap::const_iterator iter, const std::string&amp; option, const std::string&amp; arg);\n\n    void parse_option(const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; name, const std::string&amp; arg = \"\");\n\n    void parse_default(const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\n    void parse_no_value(const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\nprivate:\n    void finalise_aliases();\n\n    const OptionMap&amp;      m_options;\n    const PositionalList&amp; m_positional;\n\n    std::vector&lt;KeyValue&gt; m_sequential{};\n    std::vector&lt;KeyValue&gt; m_defaults{};\n    bool                  m_allow_unrecognised;\n\n    ParsedHashMap m_parsed{};\n    NameHashMap   m_keys{};\n};\n\nclass Options {\npublic:\n    explicit Options(std::string program_name, std::string help_string = \"\")\n        : m_program(std::move(program_name))\n        , m_help_string(toLocalString(std::move(help_string)))\n        , m_custom_help(\"[OPTION...]\")\n        , m_positional_help(\"positional parameters\")\n        , m_show_positional(false)\n        , m_allow_unrecognised(false)\n        , m_width(76)\n        , m_tab_expansion(false)\n        , m_options(std::make_shared&lt;OptionMap&gt;()) { }\n\n    Options&amp; positional_help(std::string help_text) {\n        m_positional_help = std::move(help_text);\n        return *this;\n    }\n\n    Options&amp; custom_help(std::string help_text) {\n        m_custom_help = std::move(help_text);\n        return *this;\n    }\n\n    Options&amp; show_positional_help() {\n        m_show_positional = true;\n        return *this;\n    }\n\n    Options&amp; allow_unrecognised_options() {\n        m_allow_unrecognised = true;\n        return *this;\n    }\n\n    Options&amp; set_width(std::size_t width) {\n        m_width = width;\n        return *this;\n    }\n\n    Options&amp; set_tab_expansion(bool expansion = true) {\n        m_tab_expansion = expansion;\n        return *this;\n    }\n\n    ParseResult parse(int argc, const char* const* argv);\n\n    OptionAdder add_options(std::string group = \"\");\n\n    void add_options(const std::string&amp; group, std::initializer_list&lt;Option&gt; options);\n\n    void add_option(const std::string&amp; group, const Option&amp; option);\n\n    void add_option(const std::string&amp; group, const std::string&amp; s, const OptionNames&amp; l, std::string desc,\n                    const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help);\n\n    void add_option(const std::string&amp; group, const std::string&amp; short_name, const std::string&amp; single_long_name,\n                    std::string desc, const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n        OptionNames long_names;\n        long_names.emplace_back(single_long_name);\n        add_option(group, short_name, long_names, desc, value, arg_help);\n    }\n\n    // parse positional arguments into the given option\n    void parse_positional(std::string option);\n\n    void parse_positional(std::vector&lt;std::string&gt; options);\n\n    void parse_positional(std::initializer_list&lt;std::string&gt; options);\n\n    template&lt;typename Iterator&gt;\n    void parse_positional(Iterator begin, Iterator end) {\n        parse_positional(std::vector&lt;std::string&gt;{begin, end});\n    }\n\n    std::string help(const std::vector&lt;std::string&gt;&amp; groups = {}, bool print_usage = true) const;\n\n    std::vector&lt;std::string&gt; groups() const;\n\n    const HelpGroupDetails&amp; group_help(const std::string&amp; group) const;\n\n    const std::string&amp; program() const {\n        return m_program;\n    }\n\nprivate:\n    void add_one_option(const std::string&amp; option, const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\n    String help_one_group(const std::string&amp; group) const;\n\n    void generate_group_help(String&amp; result, const std::vector&lt;std::string&gt;&amp; groups) const;\n\n    void generate_all_groups_help(String&amp; result) const;\n\n    std::string m_program{};\n    String      m_help_string{};\n    std::string m_custom_help{};\n    std::string m_positional_help{};\n    bool        m_show_positional;\n    bool        m_allow_unrecognised;\n    std::size_t m_width;\n    bool        m_tab_expansion;\n\n    std::shared_ptr&lt;OptionMap&gt;      m_options;\n    std::vector&lt;std::string&gt;        m_positional{};\n    std::unordered_set&lt;std::string&gt; m_positional_set{};\n\n    // mapping from groups to help options\n    std::map&lt;std::string, HelpGroupDetails&gt; m_help{};\n};\n\nclass OptionAdder {\npublic:\n    OptionAdder(Options&amp; options, std::string group)\n        : m_options(options)\n        , m_group(std::move(group)) { }\n\n    OptionAdder&amp; operator()(const std::string&amp; opts, const std::string&amp; desc,\n                            const std::shared_ptr&lt;const Value&gt;&amp; value = ::cxxopts::value&lt;bool&gt;(), std::string arg_help = \"\");\n\nprivate:\n    Options&amp;    m_options;\n    std::string m_group;\n};\n\nnamespace {\n    constexpr std::size_t OPTION_LONGEST  = 30;\n    constexpr std::size_t OPTION_DESC_GAP = 2;\n\n    String format_option(const HelpOptionDetails&amp; o) {\n        const auto&amp; s = o.s;\n        const auto&amp; l = first_or_empty(o.l);\n\n        String result = \"  \";\n\n        if (!s.empty()) {\n            result += \"-\" + toLocalString(s);\n            if (!l.empty()) {\n                result += \",\";\n            }\n        } else {\n            result += \"   \";\n        }\n\n        if (!l.empty()) {\n            result += \" --\" + toLocalString(l);\n        }\n\n        auto arg = !o.arg_help.empty() ? toLocalString(o.arg_help) : \"arg\";\n\n        if (!o.is_boolean) {\n            if (o.has_implicit) {\n                result += \" [=\" + arg + \"(=\" + toLocalString(o.implicit_value) + \")]\";\n            } else {\n                result += \" \" + arg;\n            }\n        }\n\n        return result;\n    }\n\n    String format_description(const HelpOptionDetails&amp; o, std::size_t start, std::size_t allowed, bool tab_expansion) {\n        auto desc = o.desc;\n\n        if (o.has_default &amp;&amp; (!o.is_boolean || o.default_value != \"false\")) {\n            if (!o.default_value.empty()) {\n                desc += toLocalString(\" (default: \" + o.default_value + \")\");\n            } else {\n                desc += toLocalString(\" (default: \\\"\\\")\");\n            }\n        }\n\n        String result;\n\n        if (tab_expansion) {\n            String desc2;\n            auto   size = std::size_t{0};\n            for (auto c = std::begin(desc); c != std::end(desc); ++c) {\n                if (*c == '\\n') {\n                    desc2 += *c;\n                    size = 0;\n                } else if (*c == '\\t') {\n                    auto skip = 8 - size % 8;\n                    stringAppend(desc2, skip, ' ');\n                    size += skip;\n                } else {\n                    desc2 += *c;\n                    ++size;\n                }\n            }\n            desc = desc2;\n        }\n\n        desc += \" \";\n\n        auto current   = std::begin(desc);\n        auto previous  = current;\n        auto startLine = current;\n        auto lastSpace = current;\n\n        auto size = std::size_t{};\n\n        bool appendNewLine;\n        bool onlyWhiteSpace = true;\n\n        while (current != std::end(desc)) {\n            appendNewLine = false;\n            if (*previous == ' ' || *previous == '\\t') {\n                lastSpace = current;\n            }\n            if (*current != ' ' &amp;&amp; *current != '\\t') {\n                onlyWhiteSpace = false;\n            }\n\n            while (*current == '\\n') {\n                previous = current;\n                ++current;\n                appendNewLine = true;\n            }\n\n            if (!appendNewLine &amp;&amp; size &gt;= allowed) {\n                if (lastSpace != startLine) {\n                    current  = lastSpace;\n                    previous = current;\n                }\n                appendNewLine = true;\n            }\n\n            if (appendNewLine) {\n                stringAppend(result, startLine, current);\n                startLine = current;\n                lastSpace = current;\n\n                if (*previous != '\\n') {\n                    stringAppend(result, \"\\n\");\n                }\n\n                stringAppend(result, start, ' ');\n\n                if (*previous != '\\n') {\n                    stringAppend(result, lastSpace, current);\n                }\n\n                onlyWhiteSpace = true;\n                size           = 0;\n            }\n\n            previous = current;\n            ++current;\n            ++size;\n        }\n\n        // append whatever is left but ignore whitespace\n        if (!onlyWhiteSpace) {\n            stringAppend(result, startLine, previous);\n        }\n\n        return result;\n    }\n\n} // namespace\n\ninline void Options::add_options(const std::string&amp; group, std::initializer_list&lt;Option&gt; options) {\n    OptionAdder option_adder(*this, group);\n    for (const auto&amp; option : options) {\n        option_adder(option.opts_, option.desc_, option.value_, option.arg_help_);\n    }\n}\n\ninline OptionAdder Options::add_options(std::string group) {\n    return OptionAdder(*this, std::move(group));\n}\n\ninline OptionAdder&amp; OptionAdder::operator()(const std::string&amp; opts, const std::string&amp; desc,\n                                            const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n    OptionNames option_names = values::parser_tool::split_option_names(opts);\n    // Note: All names will be non-empty; but we must separate the short\n    // (length-1) and longer names\n    std::string short_name{\"\"};\n    auto        first_short_name_iter = std::partition(option_names.begin(), option_names.end(), [&amp;](const std::string&amp; name) {\n        return name.length() &gt; 1;\n    });\n    auto        num_length_1_names    = (option_names.end() - first_short_name_iter);\n    switch (num_length_1_names) {\n    case 1:\n        short_name = *first_short_name_iter;\n        option_names.erase(first_short_name_iter);\n    case 0:\n        break;\n    default:\n        throw_or_mimic&lt;exceptions::invalid_option_format&gt;(opts);\n    };\n\n    m_options.add_option(m_group, short_name, option_names, desc, value, std::move(arg_help));\n\n    return *this;\n}\n\ninline void OptionParser::parse_default(const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    // TODO: remove the duplicate code here\n    auto&amp; store = m_parsed[details-&gt;hash()];\n    store.parse_default(details);\n    m_defaults.emplace_back(details-&gt;essential_name(), details-&gt;value().get_default_value());\n}\n\ninline void OptionParser::parse_no_value(const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    auto&amp; store = m_parsed[details-&gt;hash()];\n    store.parse_no_value(details);\n}\n\ninline void OptionParser::parse_option(const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; /*name*/,\n                                       const std::string&amp;                    arg) {\n    auto  hash   = value-&gt;hash();\n    auto&amp; result = m_parsed[hash];\n    result.parse(value, arg);\n\n    m_sequential.emplace_back(value-&gt;essential_name(), arg);\n}\n\ninline void OptionParser::checked_parse_arg(int argc, const char* const* argv, int&amp; current,\n                                            const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; name) {\n    if (current + 1 &gt;= argc) {\n        if (value-&gt;value().has_implicit()) {\n            parse_option(value, name, value-&gt;value().get_implicit_value());\n        } else {\n            throw_or_mimic&lt;exceptions::missing_argument&gt;(name);\n        }\n    } else {\n        if (value-&gt;value().has_implicit()) {\n            parse_option(value, name, value-&gt;value().get_implicit_value());\n        } else {\n            parse_option(value, name, argv[current + 1]);\n            ++current;\n        }\n    }\n}\n\ninline void OptionParser::add_to_option(OptionMap::const_iterator iter, const std::string&amp; option, const std::string&amp; arg) {\n    parse_option(iter-&gt;second, option, arg);\n}\n\ninline bool OptionParser::consume_positional(const std::string&amp; a, PositionalListIterator&amp; next) {\n    while (next != m_positional.end()) {\n        auto iter = m_options.find(*next);\n        if (iter != m_options.end()) {\n            if (!iter-&gt;second-&gt;value().is_container()) {\n                auto&amp; result = m_parsed[iter-&gt;second-&gt;hash()];\n                if (result.count() == 0) {\n                    add_to_option(iter, *next, a);\n                    ++next;\n                    return true;\n                }\n                ++next;\n                continue;\n            }\n            add_to_option(iter, *next, a);\n            return true;\n        }\n        throw_or_mimic&lt;exceptions::no_such_option&gt;(*next);\n    }\n\n    return false;\n}\n\ninline void Options::parse_positional(std::string option) {\n    parse_positional(std::vector&lt;std::string&gt;{std::move(option)});\n}\n\ninline void Options::parse_positional(std::vector&lt;std::string&gt; options) {\n    m_positional = std::move(options);\n\n    m_positional_set.insert(m_positional.begin(), m_positional.end());\n}\n\ninline void Options::parse_positional(std::initializer_list&lt;std::string&gt; options) {\n    parse_positional(std::vector&lt;std::string&gt;(options));\n}\n\ninline ParseResult Options::parse(int argc, const char* const* argv) {\n    OptionParser parser(*m_options, m_positional, m_allow_unrecognised);\n\n    return parser.parse(argc, argv);\n}\n\ninline ParseResult OptionParser::parse(int argc, const char* const* argv) {\n    int  current           = 1;\n    bool consume_remaining = false;\n    auto next_positional   = m_positional.begin();\n\n    std::vector&lt;std::string&gt; unmatched;\n\n    while (current != argc) {\n        if (strcmp(argv[current], \"--\") == 0) {\n            consume_remaining = true;\n            ++current;\n            break;\n        }\n        bool                          matched   = false;\n        values::parser_tool::ArguDesc argu_desc = values::parser_tool::ParseArgument(argv[current], matched);\n\n        if (!matched) {\n            // not a flag\n\n            // but if it starts with a `-`, then it's an error\n            if (argv[current][0] == '-' &amp;&amp; argv[current][1] != '\\0') {\n                if (!m_allow_unrecognised) {\n                    throw_or_mimic&lt;exceptions::invalid_option_syntax&gt;(argv[current]);\n                }\n            }\n\n            // if true is returned here then it was consumed, otherwise it is\n            // ignored\n            if (consume_positional(argv[current], next_positional)) {\n            } else {\n                unmatched.emplace_back(argv[current]);\n            }\n            // if we return from here then it was parsed successfully, so continue\n        } else {\n            // short or long option?\n            if (argu_desc.grouping) {\n                const std::string&amp; s = argu_desc.arg_name;\n\n                for (std::size_t i = 0; i != s.size(); ++i) {\n                    std::string name(1, s[i]);\n                    auto        iter = m_options.find(name);\n\n                    if (iter == m_options.end()) {\n                        if (m_allow_unrecognised) {\n                            unmatched.push_back(std::string(\"-\") + s[i]);\n                            continue;\n                        }\n                        // error\n                        throw_or_mimic&lt;exceptions::no_such_option&gt;(name);\n                    }\n\n                    auto value = iter-&gt;second;\n\n                    if (i + 1 == s.size()) {\n                        // it must be the last argument\n                        checked_parse_arg(argc, argv, current, value, name);\n                    } else if (value-&gt;value().has_implicit()) {\n                        parse_option(value, name, value-&gt;value().get_implicit_value());\n                    } else if (i + 1 &lt; s.size()) {\n                        std::string arg_value = s.substr(i + 1);\n                        parse_option(value, name, arg_value);\n                        break;\n                    } else {\n                        // error\n                        throw_or_mimic&lt;exceptions::option_requires_argument&gt;(name);\n                    }\n                }\n            } else if (argu_desc.arg_name.length() != 0) {\n                const std::string&amp; name = argu_desc.arg_name;\n\n                auto iter = m_options.find(name);\n\n                if (iter == m_options.end()) {\n                    if (m_allow_unrecognised) {\n                        // keep unrecognised options in argument list, skip to next argument\n                        unmatched.emplace_back(argv[current]);\n                        ++current;\n                        continue;\n                    }\n                    // error\n                    throw_or_mimic&lt;exceptions::no_such_option&gt;(name);\n                }\n\n                auto opt = iter-&gt;second;\n\n                // equals provided for long option?\n                if (argu_desc.set_value) {\n                    // parse the option given\n\n                    parse_option(opt, name, argu_desc.value);\n                } else {\n                    // parse the next argument\n                    checked_parse_arg(argc, argv, current, opt, name);\n                }\n            }\n        }\n\n        ++current;\n    }\n\n    for (auto&amp; opt : m_options) {\n        auto&amp;       detail = opt.second;\n        const auto&amp; value  = detail-&gt;value();\n\n        auto&amp; store = m_parsed[detail-&gt;hash()];\n\n        if (value.has_default()) {\n            if (!store.count() &amp;&amp; !store.has_default()) {\n                parse_default(detail);\n            }\n        } else {\n            parse_no_value(detail);\n        }\n    }\n\n    if (consume_remaining) {\n        while (current &lt; argc) {\n            if (!consume_positional(argv[current], next_positional)) {\n                break;\n            }\n            ++current;\n        }\n\n        // adjust argv for any that couldn't be swallowed\n        while (current != argc) {\n            unmatched.emplace_back(argv[current]);\n            ++current;\n        }\n    }\n\n    finalise_aliases();\n\n    ParseResult parsed(std::move(m_keys), std::move(m_parsed), std::move(m_sequential), std::move(m_defaults),\n                       std::move(unmatched));\n    return parsed;\n}\n\ninline void OptionParser::finalise_aliases() {\n    for (auto&amp; option : m_options) {\n        auto&amp; detail                = *option.second;\n        auto  hash                  = detail.hash();\n        m_keys[detail.short_name()] = hash;\n        for (const auto&amp; long_name : detail.long_names()) {\n            m_keys[long_name] = hash;\n        }\n\n        m_parsed.emplace(hash, OptionValue());\n    }\n}\n\ninline void Options::add_option(const std::string&amp; group, const Option&amp; option) {\n    add_options(group, {option});\n}\n\ninline void Options::add_option(const std::string&amp; group, const std::string&amp; s, const OptionNames&amp; l, std::string desc,\n                                const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n    auto stringDesc = toLocalString(std::move(desc));\n    auto option     = std::make_shared&lt;OptionDetails&gt;(s, l, stringDesc, value);\n\n    if (!s.empty()) {\n        add_one_option(s, option);\n    }\n\n    for (const auto&amp; long_name : l) {\n        add_one_option(long_name, option);\n    }\n\n    // add the help details\n    auto&amp; options = m_help[group];\n\n    options.options.emplace_back(HelpOptionDetails{s, l, stringDesc, value-&gt;has_default(), value-&gt;get_default_value(),\n                                                   value-&gt;has_implicit(), value-&gt;get_implicit_value(), std::move(arg_help),\n                                                   value-&gt;is_container(), value-&gt;is_boolean()});\n}\n\ninline void Options::add_one_option(const std::string&amp; option, const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    auto in = m_options-&gt;emplace(option, details);\n\n    if (!in.second) {\n        throw_or_mimic&lt;exceptions::option_already_exists&gt;(option);\n    }\n}\n\ninline String Options::help_one_group(const std::string&amp; g) const {\n    using OptionHelp = std::vector&lt;std::pair&lt;String, String&gt;&gt;;\n\n    auto group = m_help.find(g);\n    if (group == m_help.end()) {\n        return \"\";\n    }\n\n    OptionHelp format;\n\n    std::size_t longest = 0;\n\n    String result;\n\n    if (!g.empty()) {\n        result += toLocalString(\" \" + g + \" options:\\n\");\n    }\n\n    for (const auto&amp; o : group-&gt;second.options) {\n        if (o.l.size() &amp;&amp; m_positional_set.find(o.l.front()) != m_positional_set.end() &amp;&amp; !m_show_positional) {\n            continue;\n        }\n\n        auto s  = format_option(o);\n        longest = (std::max)(longest, stringLength(s));\n        format.push_back(std::make_pair(s, String()));\n    }\n    longest = (std::min)(longest, OPTION_LONGEST);\n\n    // widest allowed description -- min 10 chars for helptext/line\n    std::size_t allowed = 10;\n    if (m_width &gt; allowed + longest + OPTION_DESC_GAP) {\n        allowed = m_width - longest - OPTION_DESC_GAP;\n    }\n\n    auto fiter = format.begin();\n    for (const auto&amp; o : group-&gt;second.options) {\n        if (o.l.size() &amp;&amp; m_positional_set.find(o.l.front()) != m_positional_set.end() &amp;&amp; !m_show_positional) {\n            continue;\n        }\n\n        auto d = format_description(o, longest + OPTION_DESC_GAP, allowed, m_tab_expansion);\n\n        result += fiter-&gt;first;\n        if (stringLength(fiter-&gt;first) &gt; longest) {\n            result += '\\n';\n            result += toLocalString(std::string(longest + OPTION_DESC_GAP, ' '));\n        } else {\n            result += toLocalString(std::string(longest + OPTION_DESC_GAP - stringLength(fiter-&gt;first), ' '));\n        }\n        result += d;\n        result += '\\n';\n\n        ++fiter;\n    }\n\n    return result;\n}\n\ninline void Options::generate_group_help(String&amp; result, const std::vector&lt;std::string&gt;&amp; print_groups) const {\n    for (std::size_t i = 0; i != print_groups.size(); ++i) {\n        const String&amp; group_help_text = help_one_group(print_groups[i]);\n        if (empty(group_help_text)) {\n            continue;\n        }\n        result += group_help_text;\n        if (i &lt; print_groups.size() - 1) {\n            result += '\\n';\n        }\n    }\n}\n\ninline void Options::generate_all_groups_help(String&amp; result) const {\n    std::vector&lt;std::string&gt; all_groups;\n\n    std::transform(m_help.begin(), m_help.end(), std::back_inserter(all_groups),\n                   [](const std::map&lt;std::string, HelpGroupDetails&gt;::value_type&amp; group) {\n                       return group.first;\n                   });\n\n    generate_group_help(result, all_groups);\n}\n\ninline std::string Options::help(const std::vector&lt;std::string&gt;&amp; help_groups, bool print_usage) const {\n    String result = m_help_string;\n    if (print_usage) {\n        result += \"\\nUsage:\\n  \" + toLocalString(m_program);\n    }\n\n    if (!m_custom_help.empty()) {\n        result += \" \" + toLocalString(m_custom_help);\n    }\n\n    if (!m_positional.empty() &amp;&amp; !m_positional_help.empty()) {\n        result += \" \" + toLocalString(m_positional_help);\n    }\n\n    result += \"\\n\\n\";\n\n    if (help_groups.empty()) {\n        generate_all_groups_help(result);\n    } else {\n        generate_group_help(result, help_groups);\n    }\n\n    return toUTF8String(result);\n}\n\ninline std::vector&lt;std::string&gt; Options::groups() const {\n    std::vector&lt;std::string&gt; g;\n\n    std::transform(m_help.begin(), m_help.end(), std::back_inserter(g),\n                   [](const std::map&lt;std::string, HelpGroupDetails&gt;::value_type&amp; pair) {\n                       return pair.first;\n                   });\n\n    return g;\n}\n\ninline const HelpGroupDetails&amp; Options::group_help(const std::string&amp; group) const {\n    return m_help.at(group);\n}\n\n} // namespace cxxopts\n\n#endif // CXXOPTS_HPP_INCLUDED\n</code></pre>"},{"location":"api/src_2plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; src &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;boost/algorithm/string/join.hpp&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;pwd.h&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;unistd.h&gt;</code></li> <li><code>#include &lt;yaml-cpp/yaml.h&gt;</code></li> </ul>"},{"location":"api/src_2plugin_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace YAML"},{"location":"api/src_2plugin_8cpp/#classes","title":"Classes","text":"Type Name struct Dependency struct convert&lt; ILLIXR::Dependency &gt; &lt;&gt;"},{"location":"api/src_2plugin_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name ILLIXR::runtime * runtime_   = <code>nullptr</code>"},{"location":"api/src_2plugin_8cpp/#public-functions","title":"Public Functions","text":"Type Name void check_plugins (std::vector&lt; std::string &gt; &amp; plugins, const std::vector&lt; ILLIXR::Dependency &gt; &amp; dep_map)  std::string get_home_dir ()"},{"location":"api/src_2plugin_8cpp/#macros","title":"Macros","text":"Type Name define BOOST_DATE_TIME_NO_LIB"},{"location":"api/src_2plugin_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/src_2plugin_8cpp/#variable-runtime_","title":"variable runtime_","text":"<pre><code>ILLIXR::runtime* runtime_;\n</code></pre>"},{"location":"api/src_2plugin_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/src_2plugin_8cpp/#function-check_plugins","title":"function check_plugins","text":"<pre><code>void check_plugins (\n    std::vector&lt; std::string &gt; &amp; plugins,\n    const std::vector&lt; ILLIXR::Dependency &gt; &amp; dep_map\n) \n</code></pre>"},{"location":"api/src_2plugin_8cpp/#function-get_home_dir","title":"function get_home_dir","text":"<pre><code>std::string get_home_dir () \n</code></pre>"},{"location":"api/src_2plugin_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/src_2plugin_8cpp/#define-boost_date_time_no_lib","title":"define BOOST_DATE_TIME_NO_LIB","text":"<pre><code>#define BOOST_DATE_TIME_NO_LIB \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/plugin.cpp</code></p>"},{"location":"api/src_2plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; src &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#ifndef ILLIXR_INSTALL_PATH\n    #error \"ILLIXR_INSTALL_PATH must be defined\"\n#endif\n#ifndef BOOST_DATE_TIME_NO_LIB\n    #define BOOST_DATE_TIME_NO_LIB\n#endif\n#include &lt;algorithm&gt;\n#include &lt;boost/algorithm/string/join.hpp&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;pwd.h&gt;\n#include &lt;sstream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;unistd.h&gt;\n#include &lt;yaml-cpp/yaml.h&gt;\n\nnamespace ILLIXR {\nstruct Dependency {\n    std::string                                     name;\n    std::map&lt;std::string, std::vector&lt;std::string&gt;&gt; deps;\n\n    bool operator==(const Dependency&amp; rhs) const {\n        return name == rhs.name;\n    }\n\n    bool operator==(const std::string&amp; rhs) const {\n        return name == rhs;\n    }\n};\n} // namespace ILLIXR\n\nnamespace YAML {\ntemplate&lt;&gt;\nstruct convert&lt;ILLIXR::Dependency&gt; {\n    static Node encode(const ILLIXR::Dependency&amp; rhs) {\n        Node node;\n        node[\"plugin\"] = rhs.name;\n        for (const auto&amp; [key, value] : rhs.deps) {\n            Node dep_node;\n            dep_node[\"needs\"] = key;\n            for (const auto&amp; v : value) {\n                dep_node[\"provided_by\"].push_back(v);\n            }\n            node[\"dependencies\"].push_back(dep_node);\n        }\n        return node;\n    }\n\n    static bool decode(const Node&amp; node, ILLIXR::Dependency&amp; rhs) {\n        if (node.size() != 2) {\n            return false;\n        }\n        rhs.name  = node[\"plugin\"].as&lt;std::string&gt;();\n        Node deps = node[\"dependencies\"];\n        if (!deps.IsSequence()) {\n            return false;\n        }\n        for (const auto&amp; nd : deps) {\n            if (nd.size() != 2) {\n                return false;\n            }\n            auto dep_name = nd[\"needs\"].as&lt;std::string&gt;();\n            auto prov     = nd[\"provided_by\"].as&lt;std::vector&lt;std::string&gt;&gt;();\n\n            rhs.deps[dep_name] = prov;\n        }\n        return true;\n    }\n};\n} // namespace YAML\n\nILLIXR::runtime* runtime_ = nullptr;\n\nusing namespace ILLIXR;\n\n/*std::string get_exec_path() {\n    char        result[PATH_MAX];\n    ssize_t     count = readlink(\"/proc/self/exe\", result, PATH_MAX);\n    std::string exe_dir(result, (count &gt; 0) ? count : 0);\n    return exe_dir.substr(0, exe_dir.find_last_of(\"/\\\\\"));\n}*/\n\nstd::string get_home_dir() {\n    struct passwd* pw = getpwuid(getuid());\n    return {pw-&gt;pw_dir};\n}\n\nvoid check_plugins(std::vector&lt;std::string&gt;&amp; plugins, const std::vector&lt;ILLIXR::Dependency&gt;&amp; dep_map) {\n    std::vector&lt;std::string&gt; ordered_plugins;\n    ordered_plugins.reserve(plugins.size());\n\n    auto resolve = [&amp;dep_map, &amp;ordered_plugins, &amp;plugins](std::vector&lt;std::string&gt;::iterator it, auto&amp;&amp; resolve) {\n        auto find_it = std::find(dep_map.begin(), dep_map.end(), *it);\n        // if the plugin does not have any dependencies, then just add it to the list\n        if (find_it == dep_map.end()) {\n            if (std::find(ordered_plugins.begin(), ordered_plugins.end(), *it) == ordered_plugins.end())\n                ordered_plugins.push_back(*it);\n            return false;\n        }\n        bool mod = false;\n        // go through each dependency and see if it is specified\n        for (const auto&amp; [item, needs] : find_it-&gt;deps) {\n            bool dep_found = false;\n            // first check plugins which are already in the list, if found, then we are good.\n            for (const auto&amp; provided_by : needs) {\n                if (std::find(ordered_plugins.begin(), ordered_plugins.end(), provided_by) != ordered_plugins.end()) {\n                    dep_found = true;\n                    break;\n                }\n            }\n            // try finding it in the rest of the list\n            if (!dep_found) {\n                bool rdep_found = false;\n                for (const auto&amp; provided_by : needs) {\n                    auto r_find_it = std::find(plugins.begin(), plugins.end(), provided_by);\n                    if (r_find_it != plugins.end()) {\n                        rdep_found = true;\n                        mod        = true;\n                        resolve(r_find_it, resolve);\n                        if (std::find(ordered_plugins.begin(), ordered_plugins.end(), provided_by) == ordered_plugins.end())\n                            ordered_plugins.push_back(provided_by);\n                        break;\n                    }\n                }\n                if (!rdep_found) {\n                    spdlog::get(\"illixr\")-&gt;warn(\n                        \"Potential missing plugin dependency. Plugin \" + *it + \" requests a provider of \" + item +\n                        \" to be included in the plugin list. This can be provided by one of the following plugins: \" +\n                        boost::algorithm::join(needs, \", \"));\n                }\n            }\n        }\n        return mod;\n    };\n\n    bool modified = false;\n    for (auto iter = plugins.begin(); iter != plugins.end(); iter++) {\n        std::string input = *iter;\n        modified |= resolve(iter, resolve);\n\n        if (std::find(ordered_plugins.begin(), ordered_plugins.end(), *iter) == ordered_plugins.end())\n            ordered_plugins.push_back(*iter);\n    }\n    if (modified)\n        plugins = ordered_plugins;\n}\n\nint ILLIXR::run(const cxxopts::ParseResult&amp; options) {\n    std::chrono::seconds     run_duration;\n    std::vector&lt;std::string&gt; plugins;\n    try {\n        runtime_ = ILLIXR::runtime_factory();\n        // set internal env_vars\n        // const std::shared_ptr&lt;switchboard&gt; sb = r-&gt;get_switchboard();\n\n        // set internal env_vars\n        std::shared_ptr&lt;switchboard&gt; switchboard_ = runtime_-&gt;get_switchboard();\n\n        // read in yaml config file\n        YAML::Node config;\n        // std::string exec_path = get_exec_path();\n        // setenv(\"ILLIXR_BINARY_PATH\", exec_path.c_str(), 1);\n        setenv(\"ILLIXR_BINARY_PATH\", ILLIXR_INSTALL_PATH, 1);\n        std::string home_dir = get_home_dir();\n        if (options.count(\"yaml\")) {\n            std::cout &lt;&lt; \"Reading \" &lt;&lt; options[\"yaml\"].as&lt;std::string&gt;() &lt;&lt; std::endl;\n            auto                     config_file_full = options[\"yaml\"].as&lt;std::string&gt;();\n            std::string              config_file      = config_file_full.substr(config_file_full.find_last_of(\"/\\\\\") + 1);\n            std::vector&lt;std::string&gt; config_list      = {config_file,\n                                                         config_file_full,\n                                                         home_dir + \"/.illixr/profiles/\" + config_file_full,\n                                                         home_dir + \"/.illixr/profiles/\" + config_file,\n                                                         home_dir + \"/\" + config_file_full,\n                                                         home_dir + \"/\" + config_file,\n                                                         std::string(ILLIXR_INSTALL_PATH) + \"/share/illixr/profiles/\" +\n                                                             config_file_full,\n                                                         std::string(ILLIXR_INSTALL_PATH) + \"/share/illixr/profiles/\" + config_file};\n            for (auto&amp; filepath : config_list) {\n                try {\n                    config = YAML::LoadFile(filepath);\n                    break;\n                } catch (YAML::BadFile&amp;) { }\n            }\n            if (config.size() == 0) {\n                spdlog::get(\"illixr\")-&gt;error(\"Could not load given config file: \" + config_file_full);\n                throw std::runtime_error(\"Could not load given config file: \" + config_file_full);\n            }\n            config_list.clear();\n        }\n\n        // set env vars from config file first, as command line args will override\n        for (const auto&amp; item : config[\"env_vars\"]) {\n            const auto val = item.first.as&lt;std::string&gt;();\n            if (std::find(ignore_vars.begin(), ignore_vars.end(), val) == ignore_vars.end())\n                switchboard_-&gt;set_env(val, item.second.as&lt;std::string&gt;());\n        }\n        // command line specified env_vars\n        for (auto&amp; item : options.unmatched()) {\n            bool                                   matched = false;\n            cxxopts::values::parser_tool::ArguDesc ad      = cxxopts::values::parser_tool::ParseArgument(item.c_str(), matched);\n\n            if (switchboard_-&gt;get_env(ad.arg_name, \"\").empty()) {\n                if (!ad.set_value)\n                    ad.value = \"True\";\n                switchboard_-&gt;set_env(ad.arg_name, ad.value);\n                setenv(ad.arg_name.c_str(), ad.value.c_str(), 1); // env vars from command line take precedence\n            }\n        }\n\n#ifndef NDEBUG\n        const bool enable_pre_sleep = switchboard_-&gt;get_env_bool(\"ILLIXR_ENABLE_PRE_SLEEP\", \"False\");\n        if (enable_pre_sleep) {\n            const pid_t pid = getpid();\n            spdlog::get(\"illixr\")-&gt;info(\"[main] Pre-sleep enabled.\");\n            spdlog::get(\"illixr\")-&gt;info(\"[main] PID: {}\", pid);\n            spdlog::get(\"illixr\")-&gt;info(\"[main] Sleeping for {} seconds...\", ILLIXR_PRE_SLEEP_DURATION);\n            sleep(ILLIXR_PRE_SLEEP_DURATION);\n            spdlog::get(\"illixr\")-&gt;info(\"[main] Resuming...\");\n        }\n#endif \n\n        if (options.count(\"duration\")) {\n            run_duration = std::chrono::seconds{options[\"duration\"].as&lt;long&gt;()};\n        } else if (config[\"env_vars\"][\"duration\"]) {\n            run_duration = std::chrono::seconds{config[\"env_vars\"][\"duration\"].as&lt;long&gt;()};\n        } else {\n            run_duration = (!switchboard_-&gt;get_env(\"ILLIXR_RUN_DURATION\").empty())\n                ? std::chrono::seconds{std::stol(std::string{switchboard_-&gt;get_env(\"ILLIXR_RUN_DURATION\")})}\n                : ILLIXR_RUN_DURATION_DEFAULT;\n        }\n        GET_STRING(data, ILLIXR_DATA)\n        GET_STRING(demo_data, ILLIXR_DEMO_DATA)\n        GET_BOOL(enable_offload, ILLIXR_OFFLOAD_ENABLE)\n        GET_BOOL(alignment_enable, ILLIXR_ALIGNMENT_ENABLE)\n        GET_BOOL(enable_verbose_errors, ILLIXR_ENABLE_VERBOSE_ERRORS)\n        GET_BOOL(enable_pre_sleep, ILLIXR_ENABLE_PRE_SLEEP)\n        GET_BOOL(openxr, ILLIXR_OPENXR)\n        GET_STRING(realsense_cam, REALSENSE_CAM)\n\n        if (switchboard_-&gt;get_env_char(\"ILLIXR_DISPLAY_MODE\") == nullptr) {\n            spdlog::get(\"illixr\")-&gt;info(\"[main] Display mode not selected, defaulting to GLFW.\");\n            switchboard_-&gt;set_env(\"ILLIXR_DISPLAY_MODE\", \"glfw\");\n        }\n\n        setenv(\"__GL_MaxFramesAllowed\", \"1\", false);\n        setenv(\"__GL_SYNC_TO_VBLANK\", \"1\", false);\n\n        std::vector&lt;ILLIXR::Dependency&gt; dep_map;\n        std::vector&lt;std::string&gt;        dep_list   = {\"plugin_deps.yaml\", home_dir + \"/.illixr/profiles/plugin_deps.yaml\",\n                                                      std::string(ILLIXR_INSTALL_PATH) + \"/share/illixr/profiles/plugin_deps.yaml\"\n\n        };\n        bool                            dep_loaded = false;\n        for (auto&amp; dep_file : dep_list) {\n            try {\n                YAML::Node plugin_deps = YAML::LoadFile(dep_file);\n#ifndef NDEBUG\n                spdlog::get(\"illixr\")-&gt;info(\"Located plugin dependency map file (\" + dep_file +\n                                            \"), verifying plugin dependencies.\");\n#endif\n                dep_map.reserve(plugin_deps[\"dep_map\"].size());\n                for (const auto&amp; node : plugin_deps[\"dep_map\"])\n                    dep_map.push_back(node.as&lt;ILLIXR::Dependency&gt;());\n                dep_loaded = true;\n                break;\n            } catch (YAML::BadFile&amp; bf) { }\n        }\n\n        if (!dep_loaded)\n            spdlog::get(\"illixr\")-&gt;info(\"Could not load plugin dependency map file, cannot verify plugin dependencies.\");\n\n        bool have_plugins = false;\n        // run entry supersedes plugins entry\n        for (auto item : {\"plugins\"}) {\n            if (options.count(item)) {\n                plugins      = options[item].as&lt;std::vector&lt;std::string&gt;&gt;();\n                have_plugins = true;\n            } else if (config[item]) {\n                std::stringstream tss(config[item].as&lt;std::string&gt;());\n                while (tss.good()) {\n                    std::string substr;\n                    getline(tss, substr, ',');\n                    plugins.push_back(substr);\n                }\n                have_plugins = true;\n            }\n        }\n\n        if (!have_plugins) {\n            std::cout &lt;&lt; \"No plugins specified.\" &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"A list of plugins must be given on the command line or in a YAML file\" &lt;&lt; std::endl;\n            return EXIT_FAILURE;\n        }\n\n        check_plugins(plugins, dep_map);\n        if (config[\"install_prefix\"]) {\n            std::string temp_path(switchboard_-&gt;get_env(\"LD_LIBRARY_PATH\"));\n            temp_path = config[\"install_prefix\"].as&lt;std::string&gt;() + \":\" + temp_path;\n            setenv(\"LD_LIBRARY_PATH\", temp_path.c_str(), true);\n        }\n\n        // prevent double free\n        switchboard_.reset();\n\n        RAC_ERRNO_MSG(\"main after creating runtime\");\n\n        std::vector&lt;std::string&gt; lib_paths;\n        std::transform(plugins.begin(), plugins.end(), std::back_inserter(lib_paths), [](const std::string&amp; arg) {\n            return \"libplugin.\" + arg + STRINGIZE(ILLIXR_BUILD_SUFFIX) + \".so\";\n        });\n\n        RAC_ERRNO_MSG(\"main before loading dynamic libraries\");\n        runtime_-&gt;load_so(lib_paths);\n\n        cancellable_sleep cs;\n        std::thread       th{[&amp;] {\n            cs.sleep(run_duration);\n            runtime_-&gt;stop();\n        }};\n\n        runtime_-&gt;wait(); // blocks until shutdown is runtime_-&gt;stop()\n\n        // cancel our sleep, so we can join the other thread\n        cs.cancel();\n        th.join();\n\n        delete runtime_;\n    } catch (...) {\n        delete runtime_;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"api/stdout__record__logger_8hpp/","title":"File stdout_record_logger.hpp","text":"<p>FileList &gt; src &gt; stdout_record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/record_logger.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"api/stdout__record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/stdout__record__logger_8hpp/#classes","title":"Classes","text":"Type Name class stdout_record_logger <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/stdout_record_logger.hpp</code></p>"},{"location":"api/stdout__record__logger_8hpp_source/","title":"File stdout_record_logger.hpp","text":"<p>File List &gt; src &gt; stdout_record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/record_logger.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\nnamespace ILLIXR {\nclass stdout_record_logger : public record_logger {\nprotected:\n    virtual void log(const record&amp; r) override {\n        const record_header&amp; rh = r.get_record_header();\n        for (unsigned i = 0; i &lt; rh.get_columns(); ++i) {\n            std::cout &lt;&lt; rh.get_column_name(i) &lt;&lt; ',';\n            if (false) {\n            } else if (rh.get_column_type(i) == typeid(std::size_t)) {\n                std::cout &lt;&lt; r.get_value&lt;std::size_t&gt;(i);\n            } else if (rh.get_column_type(i) == typeid(bool)) {\n                std::cout &lt;&lt; std::boolalpha &lt;&lt; r.get_value&lt;bool&gt;(i);\n            } else if (rh.get_column_type(i) == typeid(double)) {\n                std::cout &lt;&lt; r.get_value&lt;double&gt;(i);\n            } else if (rh.get_column_type(i) == typeid(duration)) {\n                auto val = r.get_value&lt;duration&gt;(i);\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(time_point)) {\n                auto val = r.get_value&lt;time_point&gt;(i).time_since_epoch();\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(std::chrono::nanoseconds)) {\n                auto val = r.get_value&lt;std::chrono::nanoseconds&gt;(i);\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(std::chrono::high_resolution_clock::time_point)) {\n                auto val = r.get_value&lt;std::chrono::high_resolution_clock::time_point&gt;(i).time_since_epoch();\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(std::string)) {\n                std::cout &lt;&lt; r.get_value&lt;std::string&gt;(i);\n            } else {\n                std::ostringstream ss;\n                ss &lt;&lt; \"type \" &lt;&lt; rh.get_column_type(i).name() &lt;&lt; \" (used in \" &lt;&lt; rh.get_name() &lt;&lt; \") is not implemented.\\n\";\n                throw std::runtime_error{ss.str()};\n            }\n            std::cout &lt;&lt; ',';\n        }\n        std::cout &lt;&lt; '\\n';\n    }\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/stoplight_8hpp/","title":"File stoplight.hpp","text":"<p>FileList &gt; illixr &gt; stoplight.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"api/stoplight_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/stoplight_8hpp/#classes","title":"Classes","text":"Type Name class event A boolean condition-variable. class stoplight Start/stop synchronization for the whole application. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/stoplight.hpp</code></p>"},{"location":"api/stoplight_8hpp_source/","title":"File stoplight.hpp","text":"<p>File List &gt; illixr &gt; stoplight.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;condition_variable&gt;\n#include &lt;mutex&gt;\n\nnamespace ILLIXR {\n\nclass event {\npublic:\n    void set(bool new_value = true) {\n        {\n            std::lock_guard lock{mutex_};\n            value_ = new_value;\n        }\n        if (new_value) {\n            cv_.notify_all();\n        }\n    }\n\n    void clear() {\n        set(false);\n    }\n\n    bool is_set() const {\n        return value_;\n    }\n\n    void wait() const {\n        std::unique_lock&lt;std::mutex&gt; lock{mutex_};\n        // Check if we even need to wait\n        if (value_) {\n            return;\n        }\n        cv_.wait(lock, [this] {\n            return value_.load();\n        });\n    }\n\n    template&lt;class Clock, class Rep, class Period&gt;\n    [[maybe_unused]] bool wait_timeout(const std::chrono::duration&lt;Rep, Period&gt;&amp; duration) const {\n        auto timeout_time = Clock::now() + duration;\n        if (value_) {\n            return true;\n        }\n        std::unique_lock&lt;std::mutex&gt; lock{mutex_};\n        while (cv_.wait_until(lock, timeout_time) != std::cv_status::timeout) {\n            if (value_) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nprivate:\n    mutable std::mutex              mutex_;\n    mutable std::condition_variable cv_;\n    std::atomic&lt;bool&gt;               value_ = false;\n};\n\nclass stoplight : public phonebook::service {\npublic:\n    void wait_for_ready() const {\n        ready_.wait();\n    }\n\n    void signal_ready() {\n        ready_.set();\n    }\n\n    bool check_should_stop() const {\n        return should_stop_.is_set();\n    }\n\n    void signal_should_stop() {\n        should_stop_.set();\n    }\n\n    void wait_for_shutdown_complete() const {\n        shutdown_complete_.wait();\n    }\n\n    bool check_shutdown_complete() const {\n        return shutdown_complete_.is_set();\n    }\n\n    void signal_shutdown_complete() {\n        shutdown_complete_.set();\n    }\n\nprivate:\n    event ready_;\n    event should_stop_;\n    event shutdown_complete_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/","title":"Struct HMD::hmd_info_t","text":"<p>ClassList &gt; HMD &gt; hmd_info_t</p>"},{"location":"api/structHMD_1_1hmd__info__t/#public-attributes","title":"Public Attributes","text":"Type Name float K float chromatic_aberration int display_pixels_high int display_pixels_wide int eye_tiles_high int eye_tiles_wide float lens_separation_in_meters float meters_per_tan_angle_at_center int num_knots int tile_pixels_high int tile_pixels_wide float visible_meters_high float visible_meters_wide int visible_pixels_high int visible_pixels_wide"},{"location":"api/structHMD_1_1hmd__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structHMD_1_1hmd__info__t/#variable-k","title":"variable K","text":"<pre><code>float HMD::hmd_info_t::K;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-chromatic_aberration","title":"variable chromatic_aberration","text":"<pre><code>float HMD::hmd_info_t::chromatic_aberration;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-display_pixels_high","title":"variable display_pixels_high","text":"<pre><code>int HMD::hmd_info_t::display_pixels_high;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-display_pixels_wide","title":"variable display_pixels_wide","text":"<pre><code>int HMD::hmd_info_t::display_pixels_wide;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-eye_tiles_high","title":"variable eye_tiles_high","text":"<pre><code>int HMD::hmd_info_t::eye_tiles_high;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-eye_tiles_wide","title":"variable eye_tiles_wide","text":"<pre><code>int HMD::hmd_info_t::eye_tiles_wide;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-lens_separation_in_meters","title":"variable lens_separation_in_meters","text":"<pre><code>float HMD::hmd_info_t::lens_separation_in_meters;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-meters_per_tan_angle_at_center","title":"variable meters_per_tan_angle_at_center","text":"<pre><code>float HMD::hmd_info_t::meters_per_tan_angle_at_center;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-num_knots","title":"variable num_knots","text":"<pre><code>int HMD::hmd_info_t::num_knots;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-tile_pixels_high","title":"variable tile_pixels_high","text":"<pre><code>int HMD::hmd_info_t::tile_pixels_high;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-tile_pixels_wide","title":"variable tile_pixels_wide","text":"<pre><code>int HMD::hmd_info_t::tile_pixels_wide;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-visible_meters_high","title":"variable visible_meters_high","text":"<pre><code>float HMD::hmd_info_t::visible_meters_high;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-visible_meters_wide","title":"variable visible_meters_wide","text":"<pre><code>float HMD::hmd_info_t::visible_meters_wide;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-visible_pixels_high","title":"variable visible_pixels_high","text":"<pre><code>int HMD::hmd_info_t::visible_pixels_high;\n</code></pre>"},{"location":"api/structHMD_1_1hmd__info__t/#variable-visible_pixels_wide","title":"variable visible_pixels_wide","text":"<pre><code>int HMD::hmd_info_t::visible_pixels_wide;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/hmd.hpp</code></p>"},{"location":"api/structHMD_1_1mesh__coord2d__t/","title":"Struct HMD::mesh_coord2d_t","text":"<p>ClassList &gt; HMD &gt; mesh_coord2d_t</p>"},{"location":"api/structHMD_1_1mesh__coord2d__t/#public-attributes","title":"Public Attributes","text":"Type Name FLOAT x FLOAT y"},{"location":"api/structHMD_1_1mesh__coord2d__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structHMD_1_1mesh__coord2d__t/#variable-x","title":"variable x","text":"<pre><code>FLOAT HMD::mesh_coord2d_t::x;\n</code></pre>"},{"location":"api/structHMD_1_1mesh__coord2d__t/#variable-y","title":"variable y","text":"<pre><code>FLOAT HMD::mesh_coord2d_t::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/hmd.hpp</code></p>"},{"location":"api/structHMD_1_1mesh__coord3d__t/","title":"Struct HMD::mesh_coord3d_t","text":"<p>ClassList &gt; HMD &gt; mesh_coord3d_t</p>"},{"location":"api/structHMD_1_1mesh__coord3d__t/#public-attributes","title":"Public Attributes","text":"Type Name FLOAT x FLOAT y FLOAT z"},{"location":"api/structHMD_1_1mesh__coord3d__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structHMD_1_1mesh__coord3d__t/#variable-x","title":"variable x","text":"<pre><code>FLOAT HMD::mesh_coord3d_t::x;\n</code></pre>"},{"location":"api/structHMD_1_1mesh__coord3d__t/#variable-y","title":"variable y","text":"<pre><code>FLOAT HMD::mesh_coord3d_t::y;\n</code></pre>"},{"location":"api/structHMD_1_1mesh__coord3d__t/#variable-z","title":"variable z","text":"<pre><code>FLOAT HMD::mesh_coord3d_t::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/hmd.hpp</code></p>"},{"location":"api/structHMD_1_1uv__coord__t/","title":"Struct HMD::uv_coord_t","text":"<p>ClassList &gt; HMD &gt; uv_coord_t</p>"},{"location":"api/structHMD_1_1uv__coord__t/#public-attributes","title":"Public Attributes","text":"Type Name FLOAT u FLOAT v"},{"location":"api/structHMD_1_1uv__coord__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structHMD_1_1uv__coord__t/#variable-u","title":"variable u","text":"<pre><code>FLOAT HMD::uv_coord_t::u;\n</code></pre>"},{"location":"api/structHMD_1_1uv__coord__t/#variable-v","title":"variable v","text":"<pre><code>FLOAT HMD::uv_coord_t::v;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/hmd.hpp</code></p>"},{"location":"api/structILLIXR_1_1Dependency/","title":"Struct ILLIXR::Dependency","text":"<p>ClassList &gt; ILLIXR &gt; Dependency</p>"},{"location":"api/structILLIXR_1_1Dependency/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; std::string, std::vector&lt; std::string &gt; &gt; deps std::string name"},{"location":"api/structILLIXR_1_1Dependency/#public-functions","title":"Public Functions","text":"Type Name bool operator== (const Dependency &amp; rhs) const bool operator== (const std::string &amp; rhs) const"},{"location":"api/structILLIXR_1_1Dependency/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1Dependency/#variable-deps","title":"variable deps","text":"<pre><code>std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; ILLIXR::Dependency::deps;\n</code></pre>"},{"location":"api/structILLIXR_1_1Dependency/#variable-name","title":"variable name","text":"<pre><code>std::string ILLIXR::Dependency::name;\n</code></pre>"},{"location":"api/structILLIXR_1_1Dependency/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1Dependency/#function-operator","title":"function operator==","text":"<pre><code>inline bool ILLIXR::Dependency::operator== (\n    const Dependency &amp; rhs\n) const\n</code></pre>"},{"location":"api/structILLIXR_1_1Dependency/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool ILLIXR::Dependency::operator== (\n    const std::string &amp; rhs\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/plugin.cpp</code></p>"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/","title":"Struct ILLIXR::DistortionCorrectionVertex","text":"<p>ClassList &gt; ILLIXR &gt; DistortionCorrectionVertex</p>"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 pos glm::vec2 uv0 glm::vec2 uv1 glm::vec2 uv2"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#public-static-functions","title":"Public Static Functions","text":"Type Name std::array&lt; VkVertexInputAttributeDescription, 4 &gt; get_attribute_descriptions ()  VkVertexInputBindingDescription get_binding_description ()"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#variable-pos","title":"variable pos","text":"<pre><code>glm::vec3 ILLIXR::DistortionCorrectionVertex::pos;\n</code></pre>"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#variable-uv0","title":"variable uv0","text":"<pre><code>glm::vec2 ILLIXR::DistortionCorrectionVertex::uv0;\n</code></pre>"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#variable-uv1","title":"variable uv1","text":"<pre><code>glm::vec2 ILLIXR::DistortionCorrectionVertex::uv1;\n</code></pre>"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#variable-uv2","title":"variable uv2","text":"<pre><code>glm::vec2 ILLIXR::DistortionCorrectionVertex::uv2;\n</code></pre>"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#function-get_attribute_descriptions","title":"function get_attribute_descriptions","text":"<pre><code>static inline std::array&lt; VkVertexInputAttributeDescription, 4 &gt; ILLIXR::DistortionCorrectionVertex::get_attribute_descriptions () \n</code></pre>"},{"location":"api/structILLIXR_1_1DistortionCorrectionVertex/#function-get_binding_description","title":"function get_binding_description","text":"<pre><code>static inline VkVertexInputBindingDescription ILLIXR::DistortionCorrectionVertex::get_binding_description () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/openwarp_vk.hpp</code></p>"},{"location":"api/structILLIXR_1_1DistortionMatrix/","title":"Struct ILLIXR::DistortionMatrix","text":"<p>ClassList &gt; ILLIXR &gt; DistortionMatrix</p>"},{"location":"api/structILLIXR_1_1DistortionMatrix/#public-attributes","title":"Public Attributes","text":"Type Name glm::mat4 transform"},{"location":"api/structILLIXR_1_1DistortionMatrix/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1DistortionMatrix/#variable-transform","title":"variable transform","text":"<pre><code>glm::mat4 ILLIXR::DistortionMatrix::transform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/openwarp_vk.hpp</code></p>"},{"location":"api/structILLIXR_1_1OpenWarpVertex/","title":"Struct ILLIXR::OpenWarpVertex","text":"<p>ClassList &gt; ILLIXR &gt; OpenWarpVertex</p>"},{"location":"api/structILLIXR_1_1OpenWarpVertex/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 pos glm::vec2 uv"},{"location":"api/structILLIXR_1_1OpenWarpVertex/#public-static-functions","title":"Public Static Functions","text":"Type Name std::array&lt; VkVertexInputAttributeDescription, 2 &gt; get_attribute_descriptions ()  VkVertexInputBindingDescription get_binding_description ()"},{"location":"api/structILLIXR_1_1OpenWarpVertex/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1OpenWarpVertex/#variable-pos","title":"variable pos","text":"<pre><code>glm::vec3 ILLIXR::OpenWarpVertex::pos;\n</code></pre>"},{"location":"api/structILLIXR_1_1OpenWarpVertex/#variable-uv","title":"variable uv","text":"<pre><code>glm::vec2 ILLIXR::OpenWarpVertex::uv;\n</code></pre>"},{"location":"api/structILLIXR_1_1OpenWarpVertex/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structILLIXR_1_1OpenWarpVertex/#function-get_attribute_descriptions","title":"function get_attribute_descriptions","text":"<pre><code>static inline std::array&lt; VkVertexInputAttributeDescription, 2 &gt; ILLIXR::OpenWarpVertex::get_attribute_descriptions () \n</code></pre>"},{"location":"api/structILLIXR_1_1OpenWarpVertex/#function-get_binding_description","title":"function get_binding_description","text":"<pre><code>static inline VkVertexInputBindingDescription ILLIXR::OpenWarpVertex::get_binding_description () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/openwarp_vk.hpp</code></p>"},{"location":"api/structILLIXR_1_1WarpMatrices/","title":"Struct ILLIXR::WarpMatrices","text":"<p>ClassList &gt; ILLIXR &gt; WarpMatrices</p>"},{"location":"api/structILLIXR_1_1WarpMatrices/#public-attributes","title":"Public Attributes","text":"Type Name glm::mat4 render_inv_projection glm::mat4 render_inv_view glm::mat4 warp_view_projection"},{"location":"api/structILLIXR_1_1WarpMatrices/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1WarpMatrices/#variable-render_inv_projection","title":"variable render_inv_projection","text":"<pre><code>glm::mat4 ILLIXR::WarpMatrices::render_inv_projection[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1WarpMatrices/#variable-render_inv_view","title":"variable render_inv_view","text":"<pre><code>glm::mat4 ILLIXR::WarpMatrices::render_inv_view[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1WarpMatrices/#variable-warp_view_projection","title":"variable warp_view_projection","text":"<pre><code>glm::mat4 ILLIXR::WarpMatrices::warp_view_projection[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/openwarp_vk/openwarp_vk.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/","title":"Struct ILLIXR::data_format::binocular_cam_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; binocular_cam_type</p> <p>More...</p> <ul> <li><code>#include &lt;opencv_data_types.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::cam_base_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/#public-attributes-inherited-from-illixrdata_formatcam_base_type","title":"Public Attributes inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name std::map&lt; image::image_type, cv::Mat &gt; images   = <code>{}</code>Mapping of the images with their types. time_point time Time associated with the image(s) camera::cam_type type What type of camera is this."},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/#public-functions","title":"Public Functions","text":"Type Name binocular_cam_type (time_point _time, cv::Mat _img0, cv::Mat _img1)"},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/#public-functions-inherited-from-illixrdata_formatcam_base_type","title":"Public Functions inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name cv::Mat at (const image::image_type idx) const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator begin () const cam_base_type (time_point _time, std::map&lt; image::image_type, cv::Mat &gt; imgs, camera::cam_type _type)  std::map&lt; image::image_type, cv::Mat &gt;::const_iterator end () const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator find (const image::image_type idx) const int format (image::image_type idx)  cv::Mat &amp; operator[] (image::image_type idx)  size_t size () const"},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/#detailed-description","title":"Detailed Description","text":"<p>For binocular images (left and right eyes). </p>"},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1binocular__cam__type/#function-binocular_cam_type","title":"function binocular_cam_type","text":"<pre><code>inline ILLIXR::data_format::binocular_cam_type::binocular_cam_type (\n    time_point _time,\n    cv::Mat _img0,\n    cv::Mat _img1\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/","title":"Struct ILLIXR::data_format::cam_base_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; cam_base_type</p> <p>More...</p> <ul> <li><code>#include &lt;opencv_data_types.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p> <p>Inherited by the following classes: ILLIXR::data_format::binocular_cam_type,  ILLIXR::data_format::cam_type_zed,  ILLIXR::data_format::depth_type,  ILLIXR::data_format::ht::ht_frame,  ILLIXR::data_format::monocular_cam_type,  ILLIXR::data_format::rgb_depth_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; image::image_type, cv::Mat &gt; images   = <code>{}</code>Mapping of the images with their types. time_point time Time associated with the image(s) camera::cam_type type What type of camera is this."},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#public-functions","title":"Public Functions","text":"Type Name cv::Mat at (const image::image_type idx) const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator begin () const cam_base_type (time_point _time, std::map&lt; image::image_type, cv::Mat &gt; imgs, camera::cam_type _type)  std::map&lt; image::image_type, cv::Mat &gt;::const_iterator end () const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator find (const image::image_type idx) const int format (image::image_type idx)  cv::Mat &amp; operator[] (image::image_type idx)  size_t size () const"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#detailed-description","title":"Detailed Description","text":"<p>Base struct for all camera classes </p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#variable-images","title":"variable images","text":"<p>Mapping of the images with their types. <pre><code>std::map&lt;image::image_type, cv::Mat&gt; ILLIXR::data_format::cam_base_type::images;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#variable-time","title":"variable time","text":"<p>Time associated with the image(s) <pre><code>time_point ILLIXR::data_format::cam_base_type::time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#variable-type","title":"variable type","text":"<p>What type of camera is this. <pre><code>camera::cam_type ILLIXR::data_format::cam_base_type::type;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-at","title":"function at","text":"<pre><code>inline cv::Mat ILLIXR::data_format::cam_base_type::at (\n    const image::image_type idx\n) const\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-begin","title":"function begin","text":"<pre><code>inline std::map&lt; image::image_type, cv::Mat &gt;::const_iterator ILLIXR::data_format::cam_base_type::begin () const\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-cam_base_type","title":"function cam_base_type","text":"<pre><code>inline ILLIXR::data_format::cam_base_type::cam_base_type (\n    time_point _time,\n    std::map&lt; image::image_type, cv::Mat &gt; imgs,\n    camera::cam_type _type\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-end","title":"function end","text":"<pre><code>inline std::map&lt; image::image_type, cv::Mat &gt;::const_iterator ILLIXR::data_format::cam_base_type::end () const\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-find","title":"function find","text":"<pre><code>inline std::map&lt; image::image_type, cv::Mat &gt;::const_iterator ILLIXR::data_format::cam_base_type::find (\n    const image::image_type idx\n) const\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-format","title":"function format","text":"<pre><code>inline int ILLIXR::data_format::cam_base_type::format (\n    image::image_type idx\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-operator","title":"function operator[]","text":"<pre><code>inline cv::Mat &amp; ILLIXR::data_format::cam_base_type::operator[] (\n    image::image_type idx\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__base__type/#function-size","title":"function size","text":"<pre><code>inline size_t ILLIXR::data_format::cam_base_type::size () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/","title":"Struct ILLIXR::data_format::cam_type_zed","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; cam_type_zed</p> <p>More...</p> <ul> <li><code>#include &lt;zed_cam.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::cam_base_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#public-attributes","title":"Public Attributes","text":"Type Name multi_pose_map poses std::size_t serial_no"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#public-attributes-inherited-from-illixrdata_formatcam_base_type","title":"Public Attributes inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name std::map&lt; image::image_type, cv::Mat &gt; images   = <code>{}</code>Mapping of the images with their types. time_point time Time associated with the image(s) camera::cam_type type What type of camera is this."},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#public-functions","title":"Public Functions","text":"Type Name cam_type_zed (time_point _time, cv::Mat _img0, cv::Mat _img1, cv::Mat _rgb, cv::Mat _depth, cv::Mat _confidence, std::size_t _serial_no, multi_pose_map _poses)"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#public-functions-inherited-from-illixrdata_formatcam_base_type","title":"Public Functions inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name cv::Mat at (const image::image_type idx) const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator begin () const cam_base_type (time_point _time, std::map&lt; image::image_type, cv::Mat &gt; imgs, camera::cam_type _type)  std::map&lt; image::image_type, cv::Mat &gt;::const_iterator end () const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator find (const image::image_type idx) const int format (image::image_type idx)  cv::Mat &amp; operator[] (image::image_type idx)  size_t size () const"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#detailed-description","title":"Detailed Description","text":"<p>camera type for ZED, can hold images for left eye, eight eye, rgb image, and pose </p>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#variable-poses","title":"variable poses","text":"<pre><code>multi_pose_map ILLIXR::data_format::cam_type_zed::poses;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#variable-serial_no","title":"variable serial_no","text":"<pre><code>std::size_t ILLIXR::data_format::cam_type_zed::serial_no;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1cam__type__zed/#function-cam_type_zed","title":"function cam_type_zed","text":"<pre><code>inline ILLIXR::data_format::cam_type_zed::cam_type_zed (\n    time_point _time,\n    cv::Mat _img0,\n    cv::Mat _img1,\n    cv::Mat _rgb,\n    cv::Mat _depth,\n    cv::Mat _confidence,\n    std::size_t _serial_no,\n    multi_pose_map _poses\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/zed_cam.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/","title":"Struct ILLIXR::data_format::camera_data","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; camera_data</p> <p>Data structure to hold information about the full camera system. This information is mostly constant. </p> <ul> <li><code>#include &lt;camera_data.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#public-attributes","title":"Public Attributes","text":"Type Name float baseline distance between left and right eye center pixels ccd_map ccds camera specific information float fps frames per second being used size_t height height of the output image(s) in pixels units::measurement_unit units units of distance being used size_t width width of the output image(s) in pixels"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#public-functions","title":"Public Functions","text":"Type Name camera_data ()  camera_data (const size_t width_, const size_t height_, const float fps_, const float baseline_, units::measurement_unit units_, ccd_map ccds_)  ccd_data operator[] (const units::eyes idx) const"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#variable-baseline","title":"variable baseline","text":"<p>distance between left and right eye center pixels <pre><code>float ILLIXR::data_format::camera_data::baseline;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#variable-ccds","title":"variable ccds","text":"<p>camera specific information <pre><code>ccd_map ILLIXR::data_format::camera_data::ccds;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#variable-fps","title":"variable fps","text":"<p>frames per second being used <pre><code>float ILLIXR::data_format::camera_data::fps;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#variable-height","title":"variable height","text":"<p>height of the output image(s) in pixels <pre><code>size_t ILLIXR::data_format::camera_data::height;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#variable-units","title":"variable units","text":"<p>units of distance being used <pre><code>units::measurement_unit ILLIXR::data_format::camera_data::units;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#variable-width","title":"variable width","text":"<p>width of the output image(s) in pixels <pre><code>size_t ILLIXR::data_format::camera_data::width;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#function-camera_data-12","title":"function camera_data [1/2]","text":"<pre><code>inline ILLIXR::data_format::camera_data::camera_data () \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#function-camera_data-22","title":"function camera_data [2/2]","text":"<pre><code>inline ILLIXR::data_format::camera_data::camera_data (\n    const size_t width_,\n    const size_t height_,\n    const float fps_,\n    const float baseline_,\n    units::measurement_unit units_,\n    ccd_map ccds_\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1camera__data/#function-operator","title":"function operator[]","text":"<pre><code>inline ccd_data ILLIXR::data_format::camera_data::operator[] (\n    const units::eyes idx\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/camera_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/","title":"Struct ILLIXR::data_format::ccd_data","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; ccd_data</p> <p>A data structure to hold relevant camera information. This information is constant (per camera) </p> <ul> <li><code>#include &lt;camera_data.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#public-attributes","title":"Public Attributes","text":"Type Name const float center_x center pixel along x axis const float center_y center pixel along y axis const double horizontal_fov horizontal field of view in radians const double vertical_fov vertical field of view, in radians"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#public-functions","title":"Public Functions","text":"Type Name ccd_data () = delete ccd_data (const float cx, const float cy, const double vf, const double hf)"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#variable-center_x","title":"variable center_x","text":"<p>center pixel along x axis <pre><code>const float ILLIXR::data_format::ccd_data::center_x;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#variable-center_y","title":"variable center_y","text":"<p>center pixel along y axis <pre><code>const float ILLIXR::data_format::ccd_data::center_y;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#variable-horizontal_fov","title":"variable horizontal_fov","text":"<p>horizontal field of view in radians <pre><code>const double ILLIXR::data_format::ccd_data::horizontal_fov;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#variable-vertical_fov","title":"variable vertical_fov","text":"<p>vertical field of view, in radians <pre><code>const double ILLIXR::data_format::ccd_data::vertical_fov;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#function-ccd_data-12","title":"function ccd_data [1/2]","text":"<pre><code>ILLIXR::data_format::ccd_data::ccd_data () = delete\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1ccd__data/#function-ccd_data-22","title":"function ccd_data [2/2]","text":"<pre><code>inline ILLIXR::data_format::ccd_data::ccd_data (\n    const float cx,\n    const float cy,\n    const double vf,\n    const double hf\n) \n</code></pre> <p>Constructor </p> <p>Parameters:</p> <ul> <li><code>cx</code> center pixel along x axis </li> <li><code>cy</code> center pixel along y axis </li> <li><code>vf</code> vertical field of view, should be in radians, but will auto-convert </li> <li><code>hf</code> vertical field of view, should be in radians, but will auto-convert </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/camera_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/","title":"Struct ILLIXR::data_format::compressed_frame","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; compressed_frame</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#public-attributes","title":"Public Attributes","text":"Type Name char * left_color_nalu   = <code>nullptr</code> int left_color_nalu_size char * left_depth_nalu   = <code>nullptr</code> int left_depth_nalu_size long magic   = <code>0</code> bool nalu_only fast_pose_type pose char * right_color_nalu   = <code>nullptr</code> int right_color_nalu_size char * right_depth_nalu   = <code>nullptr</code> int right_depth_nalu_size uint64_t sent_time bool use_depth"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#public-functions","title":"Public Functions","text":"Type Name compressed_frame () = default void load (Archive &amp; ar, const unsigned int version)  void save (Archive &amp; ar, const unsigned int version) const ~compressed_frame ()"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-left_color_nalu","title":"variable left_color_nalu","text":"<pre><code>char* ILLIXR::data_format::compressed_frame::left_color_nalu;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-left_color_nalu_size","title":"variable left_color_nalu_size","text":"<pre><code>int ILLIXR::data_format::compressed_frame::left_color_nalu_size;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-left_depth_nalu","title":"variable left_depth_nalu","text":"<pre><code>char* ILLIXR::data_format::compressed_frame::left_depth_nalu;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-left_depth_nalu_size","title":"variable left_depth_nalu_size","text":"<pre><code>int ILLIXR::data_format::compressed_frame::left_depth_nalu_size;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-magic","title":"variable magic","text":"<pre><code>long ILLIXR::data_format::compressed_frame::magic;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-nalu_only","title":"variable nalu_only","text":"<pre><code>bool ILLIXR::data_format::compressed_frame::nalu_only;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-pose","title":"variable pose","text":"<pre><code>fast_pose_type ILLIXR::data_format::compressed_frame::pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-right_color_nalu","title":"variable right_color_nalu","text":"<pre><code>char* ILLIXR::data_format::compressed_frame::right_color_nalu;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-right_color_nalu_size","title":"variable right_color_nalu_size","text":"<pre><code>int ILLIXR::data_format::compressed_frame::right_color_nalu_size;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-right_depth_nalu","title":"variable right_depth_nalu","text":"<pre><code>char* ILLIXR::data_format::compressed_frame::right_depth_nalu;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-right_depth_nalu_size","title":"variable right_depth_nalu_size","text":"<pre><code>int ILLIXR::data_format::compressed_frame::right_depth_nalu_size;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-sent_time","title":"variable sent_time","text":"<pre><code>uint64_t ILLIXR::data_format::compressed_frame::sent_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#variable-use_depth","title":"variable use_depth","text":"<pre><code>bool ILLIXR::data_format::compressed_frame::use_depth;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#function-compressed_frame","title":"function compressed_frame","text":"<pre><code>ILLIXR::data_format::compressed_frame::compressed_frame () = default\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#function-load","title":"function load","text":"<pre><code>template&lt;class Archive&gt;\ninline void ILLIXR::data_format::compressed_frame::load (\n    Archive &amp; ar,\n    const unsigned int version\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#function-save","title":"function save","text":"<pre><code>template&lt;class Archive&gt;\ninline void ILLIXR::data_format::compressed_frame::save (\n    Archive &amp; ar,\n    const unsigned int version\n) const\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#function-compressed_frame_1","title":"function ~compressed_frame","text":"<pre><code>inline ILLIXR::data_format::compressed_frame::~compressed_frame () \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#friends-documentation","title":"Friends Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1compressed__frame/#friend-access","title":"friend access","text":"<pre><code>class ILLIXR::data_format::compressed_frame::access (\n    boost::serialization::access\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/frame.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/","title":"Struct ILLIXR::data_format::connection_signal","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; connection_signal</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/#public-attributes","title":"Public Attributes","text":"Type Name bool start"},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/#public-functions","title":"Public Functions","text":"Type Name connection_signal (bool start_)"},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/#variable-start","title":"variable start","text":"<pre><code>bool ILLIXR::data_format::connection_signal::start;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1connection__signal/#function-connection_signal","title":"function connection_signal","text":"<pre><code>inline explicit ILLIXR::data_format::connection_signal::connection_signal (\n    bool start_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/misc.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/","title":"Struct ILLIXR::data_format::depth_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; depth_type</p> <p>More...</p> <ul> <li><code>#include &lt;opencv_data_types.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::cam_base_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#public-attributes","title":"Public Attributes","text":"Type Name units::measurement_unit units"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#public-attributes-inherited-from-illixrdata_formatcam_base_type","title":"Public Attributes inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name std::map&lt; image::image_type, cv::Mat &gt; images   = <code>{}</code>Mapping of the images with their types. time_point time Time associated with the image(s) camera::cam_type type What type of camera is this."},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#public-functions","title":"Public Functions","text":"Type Name depth_type (time_point _time, cv::Mat _depth, units::measurement_unit units_)"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#public-functions-inherited-from-illixrdata_formatcam_base_type","title":"Public Functions inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name cv::Mat at (const image::image_type idx) const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator begin () const cam_base_type (time_point _time, std::map&lt; image::image_type, cv::Mat &gt; imgs, camera::cam_type _type)  std::map&lt; image::image_type, cv::Mat &gt;::const_iterator end () const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator find (const image::image_type idx) const int format (image::image_type idx)  cv::Mat &amp; operator[] (image::image_type idx)  size_t size () const"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#detailed-description","title":"Detailed Description","text":"<p>For \"grey-scale\" depth images </p>"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#variable-units","title":"variable units","text":"<pre><code>units::measurement_unit ILLIXR::data_format::depth_type::units;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1depth__type/#function-depth_type","title":"function depth_type","text":"<pre><code>inline ILLIXR::data_format::depth_type::depth_type (\n    time_point _time,\n    cv::Mat _depth,\n    units::measurement_unit units_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/","title":"Struct ILLIXR::data_format::fast_pose_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; fast_pose_type</p> <p>More...</p> <ul> <li><code>#include &lt;pose.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#public-attributes","title":"Public Attributes","text":"Type Name pose_type pose The pose data. time_point predict_computed_time Time at which the prediction was computed. time_point predict_target_time Time that prediction targeted."},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#public-functions","title":"Public Functions","text":"Type Name fast_pose_type ()  fast_pose_type (pose_type pose_, time_point predict_computed_time_, time_point predict_target_time_)"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#detailed-description","title":"Detailed Description","text":"<p>Fast pose </p>"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#variable-pose","title":"variable pose","text":"<p>The pose data. <pre><code>pose_type ILLIXR::data_format::fast_pose_type::pose;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#variable-predict_computed_time","title":"variable predict_computed_time","text":"<p>Time at which the prediction was computed. <pre><code>time_point ILLIXR::data_format::fast_pose_type::predict_computed_time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#variable-predict_target_time","title":"variable predict_target_time","text":"<p>Time that prediction targeted. <pre><code>time_point ILLIXR::data_format::fast_pose_type::predict_target_time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#function-fast_pose_type-12","title":"function fast_pose_type [1/2]","text":"<pre><code>inline ILLIXR::data_format::fast_pose_type::fast_pose_type () \n</code></pre> <p>Basic constructor </p>"},{"location":"api/structILLIXR_1_1data__format_1_1fast__pose__type/#function-fast_pose_type-22","title":"function fast_pose_type [2/2]","text":"<pre><code>inline ILLIXR::data_format::fast_pose_type::fast_pose_type (\n    pose_type pose_,\n    time_point predict_computed_time_,\n    time_point predict_target_time_\n) \n</code></pre> <p>Construct an instance using the given data </p> <p>Parameters:</p> <ul> <li><code>pose_</code> The pose to use </li> <li><code>predict_computed_time_</code> The computed time </li> <li><code>predict_target_time_</code> The target time </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/","title":"Struct ILLIXR::data_format::hmd_physical_info","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; hmd_physical_info</p>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#public-attributes","title":"Public Attributes","text":"Type Name float K float chromaticAberration int displayPixelsHigh int displayPixelsWide float ipd float lensSeparationInMeters float metersPerTanAngleAtCenter float visibleMetersHigh float visibleMetersWide int visiblePixelsHigh int visiblePixelsWide"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-k","title":"variable K","text":"<pre><code>float ILLIXR::data_format::hmd_physical_info::K[11];\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-chromaticaberration","title":"variable chromaticAberration","text":"<pre><code>float ILLIXR::data_format::hmd_physical_info::chromaticAberration[4];\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-displaypixelshigh","title":"variable displayPixelsHigh","text":"<pre><code>int ILLIXR::data_format::hmd_physical_info::displayPixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-displaypixelswide","title":"variable displayPixelsWide","text":"<pre><code>int ILLIXR::data_format::hmd_physical_info::displayPixelsWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-ipd","title":"variable ipd","text":"<pre><code>float ILLIXR::data_format::hmd_physical_info::ipd;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-lensseparationinmeters","title":"variable lensSeparationInMeters","text":"<pre><code>float ILLIXR::data_format::hmd_physical_info::lensSeparationInMeters;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-meterspertanangleatcenter","title":"variable metersPerTanAngleAtCenter","text":"<pre><code>float ILLIXR::data_format::hmd_physical_info::metersPerTanAngleAtCenter;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-visiblemetershigh","title":"variable visibleMetersHigh","text":"<pre><code>float ILLIXR::data_format::hmd_physical_info::visibleMetersHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-visiblemeterswide","title":"variable visibleMetersWide","text":"<pre><code>float ILLIXR::data_format::hmd_physical_info::visibleMetersWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-visiblepixelshigh","title":"variable visiblePixelsHigh","text":"<pre><code>int ILLIXR::data_format::hmd_physical_info::visiblePixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hmd__physical__info/#variable-visiblepixelswide","title":"variable visiblePixelsWide","text":"<pre><code>int ILLIXR::data_format::hmd_physical_info::visiblePixelsWide;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/misc.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/","title":"Struct ILLIXR::data_format::hologram_input","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; hologram_input</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#public-attributes","title":"Public Attributes","text":"Type Name uint seq   = <code>{}</code>"},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#public-functions","title":"Public Functions","text":"Type Name hologram_input () = default hologram_input (uint seq_)"},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#variable-seq","title":"variable seq","text":"<pre><code>uint ILLIXR::data_format::hologram_input::seq;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#function-hologram_input-12","title":"function hologram_input [1/2]","text":"<pre><code>ILLIXR::data_format::hologram_input::hologram_input () = default\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1hologram__input/#function-hologram_input-22","title":"function hologram_input [2/2]","text":"<pre><code>inline explicit ILLIXR::data_format::hologram_input::hologram_input (\n    uint seq_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/misc.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/","title":"Struct ILLIXR::data_format::ht::hand_points","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; ht &gt; hand_points</p> <p>More...</p> <ul> <li><code>#include &lt;hand_tracking_data.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::points_with_units</p> <p>Inherited by the following classes: ILLIXR::data_format::ht::velocity</p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#public-functions","title":"Public Functions","text":"Type Name void check ()  void clear ()  void flip_y (const uint im_height=0)  hand_points (units::measurement_unit unit_=units::UNSET)  hand_points (std::vector&lt; point_with_validity &gt; &amp; pnts, units::measurement_unit unit_=units::UNSET)  hand_points (std::vector&lt; point &gt; &amp; pnts, units::measurement_unit unit_=units::UNSET, bool valid_=true)"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#detailed-description","title":"Detailed Description","text":"<p>Listing of each hand point's coordinates </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#function-check","title":"function check","text":"<pre><code>inline void ILLIXR::data_format::ht::hand_points::check () \n</code></pre> <p>Verify the size of the input data, resizing as necessary </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#function-clear","title":"function clear","text":"<pre><code>inline void ILLIXR::data_format::ht::hand_points::clear () \n</code></pre> <p>Clear the internal storage </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#function-flip_y","title":"function flip_y","text":"<pre><code>inline void ILLIXR::data_format::ht::hand_points::flip_y (\n    const uint im_height=0\n) \n</code></pre> <p>Flip the y-coordinate over the central axis </p> <p>Parameters:</p> <ul> <li><code>im_height</code> The height of the bounding box, only used if units != PERCENT </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#function-hand_points-13","title":"function hand_points [1/3]","text":"<pre><code>inline explicit ILLIXR::data_format::ht::hand_points::hand_points (\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Constructor, creates list of 21 empty points </p> <p>Parameters:</p> <ul> <li><code>unit_</code> The unit of the points, default is UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#function-hand_points-23","title":"function hand_points [2/3]","text":"<pre><code>inline explicit ILLIXR::data_format::ht::hand_points::hand_points (\n    std::vector&lt; point_with_validity &gt; &amp; pnts,\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Constructor, with existing points </p> <p>Parameters:</p> <ul> <li><code>pnts</code> The points to use </li> <li><code>unit_</code> The unit of the points, default is UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1hand__points/#function-hand_points-33","title":"function hand_points [3/3]","text":"<pre><code>inline explicit ILLIXR::data_format::ht::hand_points::hand_points (\n    std::vector&lt; point &gt; &amp; pnts,\n    units::measurement_unit unit_=units::UNSET,\n    bool valid_=true\n) \n</code></pre> <p>Constructor, with existing points and validity </p> <p>Parameters:</p> <ul> <li><code>pnts</code> The points to use </li> <li><code>unit_</code> The unit of the points, default is UNSET </li> <li><code>valid_</code> Flag indicating the validity of all points, will be true if at least one point is valid </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/","title":"Struct ILLIXR::data_format::ht::ht_detection","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; ht &gt; ht_detection</p> <p>More...</p> <ul> <li><code>#include &lt;hand_tracking_data.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; hand, float &gt; confidence confidence of the hand detection 0..1, where 0 means no confidence std::map&lt; hand, rect &gt; hands left hand detection std::map&lt; hand, rect &gt; palms left palm detection std::map&lt; hand, hand_points &gt; points the points detected for each hand size_t proc_time nanoseconds of processing time"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#public-functions","title":"Public Functions","text":"Type Name ht_detection ()  ht_detection (size_t ptime, rect * lp, rect * rp, rect * lh, rect * rh, float lc, float rc, hand_points * lhp, hand_points * rhp)"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#detailed-description","title":"Detailed Description","text":"<p>Struct containing all the data from a hand detection </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#variable-confidence","title":"variable confidence","text":"<p>confidence of the hand detection 0..1, where 0 means no confidence <pre><code>std::map&lt;hand, float&gt; ILLIXR::data_format::ht::ht_detection::confidence;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#variable-hands","title":"variable hands","text":"<p>left hand detection <pre><code>std::map&lt;hand, rect&gt; ILLIXR::data_format::ht::ht_detection::hands;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#variable-palms","title":"variable palms","text":"<p>left palm detection <pre><code>std::map&lt;hand, rect&gt; ILLIXR::data_format::ht::ht_detection::palms;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#variable-points","title":"variable points","text":"<p>the points detected for each hand <pre><code>std::map&lt;hand, hand_points&gt; ILLIXR::data_format::ht::ht_detection::points;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#variable-proc_time","title":"variable proc_time","text":"<p>nanoseconds of processing time <pre><code>size_t ILLIXR::data_format::ht::ht_detection::proc_time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#function-ht_detection-12","title":"function ht_detection [1/2]","text":"<pre><code>inline ILLIXR::data_format::ht::ht_detection::ht_detection () \n</code></pre> <p>Basic constructor </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__detection/#function-ht_detection-22","title":"function ht_detection [2/2]","text":"<pre><code>inline ILLIXR::data_format::ht::ht_detection::ht_detection (\n    size_t ptime,\n    rect * lp,\n    rect * rp,\n    rect * lh,\n    rect * rh,\n    float lc,\n    float rc,\n    hand_points * lhp,\n    hand_points * rhp\n) \n</code></pre> <p>Create an instance from the given inputs </p> <p>Parameters:</p> <ul> <li><code>ptime</code> Time associated with these data </li> <li><code>lp</code> Rectangle enclosing the left palm </li> <li><code>rp</code> Rectangle enclosing the right palm </li> <li><code>lh</code> Rectangle enclosing the entire left hand </li> <li><code>rh</code> Rectangle enclosing the entire right hand </li> <li><code>lc</code> Left hand confidence (0..1, where 0 means no confidence) </li> <li><code>rc</code> Right hand confidence (0..1, where 0 means no confidence) </li> <li><code>lhp</code> Left hand points </li> <li><code>rhp</code> Right hand points </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/","title":"Struct ILLIXR::data_format::ht::ht_frame","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; ht &gt; ht_frame</p> <p>More...</p> <ul> <li><code>#include &lt;hand_tracking_data.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::cam_base_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; units::eyes, ht_detection &gt; detections The raw detection data. std::map&lt; ht::hand, hand_points &gt; hand_positions The hand points in real world coordinates. std::map&lt; ht::hand, velocity &gt; hand_velocities The velocity of each hand point. coordinates::reference_space reference The coordinate system being used. units::measurement_unit unit The unit being used for this frame. pose_data wcs_offset The offset between the current pose and the origin."},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#public-attributes-inherited-from-illixrdata_formatcam_base_type","title":"Public Attributes inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name std::map&lt; image::image_type, cv::Mat &gt; images   = <code>{}</code>Mapping of the images with their types. time_point time Time associated with the image(s) camera::cam_type type What type of camera is this."},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#public-functions","title":"Public Functions","text":"Type Name ht_frame (time_point time, std::map&lt; image::image_type, cv::Mat &gt; images, std::map&lt; units::eyes, ht_detection &gt; _detections, std::map&lt; ht::hand, hand_points &gt; points, std::map&lt; ht::hand, velocity &gt; velocities={}, pose_data _pose={}, coordinates::reference_space ref_sp=coordinates::VIEWER, units::measurement_unit _unit=units::measurement_unit::UNSET)"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#public-functions-inherited-from-illixrdata_formatcam_base_type","title":"Public Functions inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name cv::Mat at (const image::image_type idx) const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator begin () const cam_base_type (time_point _time, std::map&lt; image::image_type, cv::Mat &gt; imgs, camera::cam_type _type)  std::map&lt; image::image_type, cv::Mat &gt;::const_iterator end () const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator find (const image::image_type idx) const int format (image::image_type idx)  cv::Mat &amp; operator[] (image::image_type idx)  size_t size () const"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#detailed-description","title":"Detailed Description","text":"<p>Representation of all hand data for a frame </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#variable-detections","title":"variable detections","text":"<p>The raw detection data. <pre><code>std::map&lt;units::eyes, ht_detection&gt; ILLIXR::data_format::ht::ht_frame::detections;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#variable-hand_positions","title":"variable hand_positions","text":"<p>The hand points in real world coordinates. <pre><code>std::map&lt;ht::hand, hand_points&gt; ILLIXR::data_format::ht::ht_frame::hand_positions;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#variable-hand_velocities","title":"variable hand_velocities","text":"<p>The velocity of each hand point. <pre><code>std::map&lt;ht::hand, velocity&gt; ILLIXR::data_format::ht::ht_frame::hand_velocities;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#variable-reference","title":"variable reference","text":"<p>The coordinate system being used. <pre><code>coordinates::reference_space ILLIXR::data_format::ht::ht_frame::reference;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#variable-unit","title":"variable unit","text":"<p>The unit being used for this frame. <pre><code>units::measurement_unit ILLIXR::data_format::ht::ht_frame::unit;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#variable-wcs_offset","title":"variable wcs_offset","text":"<p>The offset between the current pose and the origin. <pre><code>pose_data ILLIXR::data_format::ht::ht_frame::wcs_offset;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1ht__frame/#function-ht_frame","title":"function ht_frame","text":"<pre><code>inline ILLIXR::data_format::ht::ht_frame::ht_frame (\n    time_point time,\n    std::map&lt; image::image_type, cv::Mat &gt; images,\n    std::map&lt; units::eyes, ht_detection &gt; _detections,\n    std::map&lt; ht::hand, hand_points &gt; points,\n    std::map&lt; ht::hand, velocity &gt; velocities={},\n    pose_data _pose={},\n    coordinates::reference_space ref_sp=coordinates::VIEWER,\n    units::measurement_unit _unit=units::measurement_unit::UNSET\n) \n</code></pre> <p>Construct an instance from the given data </p> <p>Parameters:</p> <ul> <li><code>time</code> Time associated with these data </li> <li><code>images</code> The images associated with these data </li> <li><code>_detections</code> The hand detections </li> <li><code>points</code> The real-world points of the hands </li> <li><code>velocities</code> The velocities of the hands </li> <li><code>_pose</code> Offset pose between the current location and the world coordinate origin </li> <li><code>ref_sp</code> The reference space being used, default is VIEWER </li> <li><code>_unit</code> The units for all data, default is UNSET </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/","title":"Struct ILLIXR::data_format::ht::position","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; ht &gt; position</p> <p>More...</p> <ul> <li><code>#include &lt;hand_tracking_data.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; ht::hand, ht::hand_points &gt; points Hand points for each hand. uint64_t time Associated time stamp. units::measurement_unit unit The units the points are in. bool valid   = <code>false</code>Validity flag, false = not valid."},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#public-functions","title":"Public Functions","text":"Type Name position ()  position (const std::map&lt; ht::hand, ht::hand_points &gt; &amp; pnts, units::measurement_unit unit_, uint64_t time_)"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#detailed-description","title":"Detailed Description","text":"<p>Representation of hand points from both hands, including units </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#variable-points","title":"variable points","text":"<p>Hand points for each hand. <pre><code>std::map&lt;ht::hand, ht::hand_points&gt; ILLIXR::data_format::ht::position::points;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#variable-time","title":"variable time","text":"<p>Associated time stamp. <pre><code>uint64_t ILLIXR::data_format::ht::position::time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#variable-unit","title":"variable unit","text":"<p>The units the points are in. <pre><code>units::measurement_unit ILLIXR::data_format::ht::position::unit;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#variable-valid","title":"variable valid","text":"<p>Validity flag, false = not valid. <pre><code>bool ILLIXR::data_format::ht::position::valid;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#function-position-12","title":"function position [1/2]","text":"<pre><code>inline ILLIXR::data_format::ht::position::position () \n</code></pre> <p>Raw constructor </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1position/#function-position-22","title":"function position [2/2]","text":"<pre><code>inline ILLIXR::data_format::ht::position::position (\n    const std::map&lt; ht::hand, ht::hand_points &gt; &amp; pnts,\n    units::measurement_unit unit_,\n    uint64_t time_\n) \n</code></pre> <p>Construct the position object with the given data </p> <p>Parameters:</p> <ul> <li><code>pnts</code> The points to use </li> <li><code>unit_</code> The units for this object </li> <li><code>time_</code> Timestamp associated with the data </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/","title":"Struct ILLIXR::data_format::ht::raw_ht_data","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; ht &gt; raw_ht_data</p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#public-attributes","title":"Public Attributes","text":"Type Name coordinates::frame frame   = <code>coordinates::RIGHT\\_HANDED\\_Y\\_UP</code>the coordinate system for all data raw_point h_points list of points for each hand raw_point h_velocities list of velocities for each hand bool hp_valid   = <code>{false, false}</code>validity of hand points bool hv_valid   = <code>{false, false}</code>validity of hand velocities coordinates::reference_space reference   = <code>coordinates::VIEWER</code>the reference space uint64_t time Time associated with these data. units::measurement_unit unit   = <code>units::measurement\\_unit::UNSET</code>the units of all data bool valid   = <code>false</code>validity of all data raw_pose wcs_origin the offset pose"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#public-functions","title":"Public Functions","text":"Type Name void copy (const ht_frame &amp; frame_)  raw_ht_data ()  raw_ht_data (const time_point time, const std::map&lt; ht::hand, hand_points &gt; &amp; points, const std::map&lt; ht::hand, velocity &gt; &amp; velocities, const pose_data &amp; pose, coordinates::reference_space ref_sp=coordinates::VIEWER, units::measurement_unit _unit=units::measurement_unit::UNSET)  raw_ht_data (const ht_frame &amp; frame_)"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-frame","title":"variable frame","text":"<p>the coordinate system for all data <pre><code>coordinates::frame ILLIXR::data_format::ht::raw_ht_data::frame;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-h_points","title":"variable h_points","text":"<p>list of points for each hand <pre><code>raw_point ILLIXR::data_format::ht::raw_ht_data::h_points[2][NUM_LANDMARKS];\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-h_velocities","title":"variable h_velocities","text":"<p>list of velocities for each hand <pre><code>raw_point ILLIXR::data_format::ht::raw_ht_data::h_velocities[2][NUM_LANDMARKS];\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-hp_valid","title":"variable hp_valid","text":"<p>validity of hand points <pre><code>bool ILLIXR::data_format::ht::raw_ht_data::hp_valid[2];\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-hv_valid","title":"variable hv_valid","text":"<p>validity of hand velocities <pre><code>bool ILLIXR::data_format::ht::raw_ht_data::hv_valid[2];\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-reference","title":"variable reference","text":"<p>the reference space <pre><code>coordinates::reference_space ILLIXR::data_format::ht::raw_ht_data::reference;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-time","title":"variable time","text":"<p>Time associated with these data. <pre><code>uint64_t ILLIXR::data_format::ht::raw_ht_data::time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-unit","title":"variable unit","text":"<p>the units of all data <pre><code>units::measurement_unit ILLIXR::data_format::ht::raw_ht_data::unit;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-valid","title":"variable valid","text":"<p>validity of all data <pre><code>bool ILLIXR::data_format::ht::raw_ht_data::valid;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#variable-wcs_origin","title":"variable wcs_origin","text":"<p>the offset pose <pre><code>raw_pose ILLIXR::data_format::ht::raw_ht_data::wcs_origin;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#function-copy","title":"function copy","text":"<pre><code>inline void ILLIXR::data_format::ht::raw_ht_data::copy (\n    const ht_frame &amp; frame_\n) \n</code></pre> <p>Copy the data from an <code>ht_frame</code> instance into this structure </p> <p>Parameters:</p> <ul> <li><code>frame_</code> The frame to copy </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#function-raw_ht_data-13","title":"function raw_ht_data [1/3]","text":"<pre><code>inline ILLIXR::data_format::ht::raw_ht_data::raw_ht_data () \n</code></pre> <p>Basic constructor </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#function-raw_ht_data-23","title":"function raw_ht_data [2/3]","text":"<pre><code>inline ILLIXR::data_format::ht::raw_ht_data::raw_ht_data (\n    const time_point time,\n    const std::map&lt; ht::hand, hand_points &gt; &amp; points,\n    const std::map&lt; ht::hand, velocity &gt; &amp; velocities,\n    const pose_data &amp; pose,\n    coordinates::reference_space ref_sp=coordinates::VIEWER,\n    units::measurement_unit _unit=units::measurement_unit::UNSET\n) \n</code></pre> <p>Create an instance from the given data </p> <p>Parameters:</p> <ul> <li><code>time</code> Time associated with these data </li> <li><code>points</code> The points for each hand </li> <li><code>velocities</code> The velocities for each hand </li> <li><code>pose</code> The offset pose </li> <li><code>ref_sp</code> The reference space, default is VIEWER </li> <li><code>_unit</code> The units for all data, defaults to UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1raw__ht__data/#function-raw_ht_data-33","title":"function raw_ht_data [3/3]","text":"<pre><code>inline explicit ILLIXR::data_format::ht::raw_ht_data::raw_ht_data (\n    const ht_frame &amp; frame_\n) \n</code></pre> <p>Create an instance from the given <code>ht_frame</code> </p> <p>Parameters:</p> <ul> <li><code>frame_</code> The data to use </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/","title":"Struct ILLIXR::data_format::ht::velocity","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; ht &gt; velocity</p> <p>More...</p> <ul> <li><code>#include &lt;hand_tracking_data.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::ht::hand_points</p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/#public-functions","title":"Public Functions","text":"Type Name velocity ()  velocity (units::measurement_unit unit)  velocity (const hand_points &amp; h1, const hand_points &amp; h2, const float time)"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/#public-functions-inherited-from-illixrdata_formaththand_points","title":"Public Functions inherited from ILLIXR::data_format::ht::hand_points","text":"<p>See ILLIXR::data_format::ht::hand_points</p> Type Name void check ()  void clear ()  void flip_y (const uint im_height=0)  hand_points (units::measurement_unit unit_=units::UNSET)  hand_points (std::vector&lt; point_with_validity &gt; &amp; pnts, units::measurement_unit unit_=units::UNSET)  hand_points (std::vector&lt; point &gt; &amp; pnts, units::measurement_unit unit_=units::UNSET, bool valid_=true)"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/#detailed-description","title":"Detailed Description","text":"<p>Representation of current velocity of head hand point. </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/#function-velocity-13","title":"function velocity [1/3]","text":"<pre><code>inline ILLIXR::data_format::ht::velocity::velocity () \n</code></pre> <p>Constructor, creates list of 21 empty points </p>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/#function-velocity-23","title":"function velocity [2/3]","text":"<pre><code>inline explicit ILLIXR::data_format::ht::velocity::velocity (\n    units::measurement_unit unit\n) \n</code></pre> <p>Constructor, creates list of 21 empty points </p> <p>Parameters:</p> <ul> <li><code>unit</code> The unit of the points, default is UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1ht_1_1velocity/#function-velocity-33","title":"function velocity [3/3]","text":"<pre><code>inline ILLIXR::data_format::ht::velocity::velocity (\n    const hand_points &amp; h1,\n    const hand_points &amp; h2,\n    const float time\n) \n</code></pre> <p>Constructor, calculates the velocities from the given points. Both sets of points must be the same size and have the same units. </p> <p>Parameters:</p> <ul> <li><code>h1</code> The initial position of the points </li> <li><code>h2</code> The final position of the points </li> <li><code>time</code> The time difference between <code>h1</code> and <code>h2</code> in seconds </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/hand_tracking_data.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/","title":"Struct ILLIXR::data_format::image_handle","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; image_handle</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#public-attributes","title":"Public Attributes","text":"Type Name union ILLIXR::data_format::image_handle image_handle GLuint gl_handle   = <code>{}</code> uint32_t num_images graphics_api type swapchain_usage usage vk_image_handle vk_handle"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#public-functions","title":"Public Functions","text":"Type Name image_handle ()  image_handle (GLuint gl_handle_, uint32_t num_images_, swapchain_usage usage_)  image_handle (int vk_fd_, int64_t format, size_t alloc_size, uint32_t width_, uint32_t height_, uint32_t num_images_, swapchain_usage usage_)"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#variable-image_handle","title":"variable image_handle","text":"<pre><code>union ILLIXR::data_format::image_handle ILLIXR::data_format::image_handle;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#variable-gl_handle","title":"variable gl_handle","text":"<pre><code>GLuint ILLIXR::data_format::image_handle::gl_handle;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#variable-num_images","title":"variable num_images","text":"<pre><code>uint32_t ILLIXR::data_format::image_handle::num_images;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#variable-type","title":"variable type","text":"<pre><code>graphics_api ILLIXR::data_format::image_handle::type;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#variable-usage","title":"variable usage","text":"<pre><code>swapchain_usage ILLIXR::data_format::image_handle::usage;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#variable-vk_handle","title":"variable vk_handle","text":"<pre><code>vk_image_handle ILLIXR::data_format::image_handle::vk_handle;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#function-image_handle-13","title":"function image_handle [1/3]","text":"<pre><code>inline ILLIXR::data_format::image_handle::image_handle () \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#function-image_handle-23","title":"function image_handle [2/3]","text":"<pre><code>inline ILLIXR::data_format::image_handle::image_handle (\n    GLuint gl_handle_,\n    uint32_t num_images_,\n    swapchain_usage usage_\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1image__handle/#function-image_handle-33","title":"function image_handle [3/3]","text":"<pre><code>inline ILLIXR::data_format::image_handle::image_handle (\n    int vk_fd_,\n    int64_t format,\n    size_t alloc_size,\n    uint32_t width_,\n    uint32_t height_,\n    uint32_t num_images_,\n    swapchain_usage usage_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/misc.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/","title":"Struct ILLIXR::data_format::imu_integrator_input","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; imu_integrator_input</p> <p>More...</p> <ul> <li><code>#include &lt;imu.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3d bias_acc Eigen::Vector3d bias_gyro time_point last_cam_integration_time imu_params params Eigen::Matrix&lt; double, 3, 1 &gt; position Eigen::Quaterniond quat duration t_offset Eigen::Matrix&lt; double, 3, 1 &gt; velocity"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#public-functions","title":"Public Functions","text":"Type Name imu_integrator_input (time_point last_cam_integration_time_, duration t_offset_, imu_params params_, Eigen::Vector3d biasAcc_, Eigen::Vector3d biasGyro_, Eigen::Matrix&lt; double, 3, 1 &gt; position_, Eigen::Matrix&lt; double, 3, 1 &gt; velocity_, Eigen::Quaterniond quat_)"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#detailed-description","title":"Detailed Description","text":"<p>IMU biases, initialization params, and slow pose needed by the IMU integrator </p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-bias_acc","title":"variable bias_acc","text":"<pre><code>Eigen::Vector3d ILLIXR::data_format::imu_integrator_input::bias_acc;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-bias_gyro","title":"variable bias_gyro","text":"<pre><code>Eigen::Vector3d ILLIXR::data_format::imu_integrator_input::bias_gyro;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-last_cam_integration_time","title":"variable last_cam_integration_time","text":"<pre><code>time_point ILLIXR::data_format::imu_integrator_input::last_cam_integration_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-params","title":"variable params","text":"<pre><code>imu_params ILLIXR::data_format::imu_integrator_input::params;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-position","title":"variable position","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_integrator_input::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-quat","title":"variable quat","text":"<pre><code>Eigen::Quaterniond ILLIXR::data_format::imu_integrator_input::quat;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-t_offset","title":"variable t_offset","text":"<pre><code>duration ILLIXR::data_format::imu_integrator_input::t_offset;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#variable-velocity","title":"variable velocity","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_integrator_input::velocity;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1imu__integrator__input/#function-imu_integrator_input","title":"function imu_integrator_input","text":"<pre><code>inline ILLIXR::data_format::imu_integrator_input::imu_integrator_input (\n    time_point last_cam_integration_time_,\n    duration t_offset_,\n    imu_params params_,\n    Eigen::Vector3d biasAcc_,\n    Eigen::Vector3d biasGyro_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; position_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; velocity_,\n    Eigen::Quaterniond quat_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/imu.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/","title":"Struct ILLIXR::data_format::imu_params","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; imu_params</p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#public-attributes","title":"Public Attributes","text":"Type Name double acc_noise double acc_walk double gyro_noise double gyro_walk double imu_integration_sigma Eigen::Matrix&lt; double, 3, 1 &gt; n_gravity double nominal_rate"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#variable-acc_noise","title":"variable acc_noise","text":"<pre><code>double ILLIXR::data_format::imu_params::acc_noise;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#variable-acc_walk","title":"variable acc_walk","text":"<pre><code>double ILLIXR::data_format::imu_params::acc_walk;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#variable-gyro_noise","title":"variable gyro_noise","text":"<pre><code>double ILLIXR::data_format::imu_params::gyro_noise;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#variable-gyro_walk","title":"variable gyro_walk","text":"<pre><code>double ILLIXR::data_format::imu_params::gyro_walk;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#variable-imu_integration_sigma","title":"variable imu_integration_sigma","text":"<pre><code>double ILLIXR::data_format::imu_params::imu_integration_sigma;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#variable-n_gravity","title":"variable n_gravity","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_params::n_gravity;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__params/#variable-nominal_rate","title":"variable nominal_rate","text":"<pre><code>double ILLIXR::data_format::imu_params::nominal_rate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/imu.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/","title":"Struct ILLIXR::data_format::imu_raw_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; imu_raw_type</p> <p>More...</p> <ul> <li><code>#include &lt;imu.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Matrix&lt; double, 3, 1 &gt; a_hat Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2 time_point imu_time Eigen::Matrix&lt; double, 3, 1 &gt; pos Eigen::Quaterniond quat Eigen::Matrix&lt; double, 3, 1 &gt; vel Eigen::Matrix&lt; double, 3, 1 &gt; w_hat Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#public-functions","title":"Public Functions","text":"Type Name imu_raw_type (Eigen::Matrix&lt; double, 3, 1 &gt; w_hat_, Eigen::Matrix&lt; double, 3, 1 &gt; a_hat_, Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2_, Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2_, Eigen::Matrix&lt; double, 3, 1 &gt; pos_, Eigen::Matrix&lt; double, 3, 1 &gt; vel_, Eigen::Quaterniond quat_, time_point imu_time_)"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#detailed-description","title":"Detailed Description","text":"<p>Output of the IMU integrator to be used by pose prediction </p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-a_hat","title":"variable a_hat","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_raw_type::a_hat;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-a_hat2","title":"variable a_hat2","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_raw_type::a_hat2;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-imu_time","title":"variable imu_time","text":"<pre><code>time_point ILLIXR::data_format::imu_raw_type::imu_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-pos","title":"variable pos","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_raw_type::pos;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-quat","title":"variable quat","text":"<pre><code>Eigen::Quaterniond ILLIXR::data_format::imu_raw_type::quat;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-vel","title":"variable vel","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_raw_type::vel;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-w_hat","title":"variable w_hat","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_raw_type::w_hat;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#variable-w_hat2","title":"variable w_hat2","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::data_format::imu_raw_type::w_hat2;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1imu__raw__type/#function-imu_raw_type","title":"function imu_raw_type","text":"<pre><code>inline ILLIXR::data_format::imu_raw_type::imu_raw_type (\n    Eigen::Matrix&lt; double, 3, 1 &gt; w_hat_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; a_hat_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; pos_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; vel_,\n    Eigen::Quaterniond quat_,\n    time_point imu_time_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/imu.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/","title":"Struct ILLIXR::data_format::imu_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; imu_type</p> <p>More...</p> <ul> <li><code>#include &lt;imu.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3d angular_v Eigen::Vector3d linear_a time_point time"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#public-functions","title":"Public Functions","text":"Type Name imu_type (time_point time_, Eigen::Vector3d angular_v_, Eigen::Vector3d linear_a_)"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#detailed-description","title":"Detailed Description","text":"<p>Inertial Measurement Unit representation </p>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#variable-angular_v","title":"variable angular_v","text":"<pre><code>Eigen::Vector3d ILLIXR::data_format::imu_type::angular_v;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#variable-linear_a","title":"variable linear_a","text":"<pre><code>Eigen::Vector3d ILLIXR::data_format::imu_type::linear_a;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#variable-time","title":"variable time","text":"<pre><code>time_point ILLIXR::data_format::imu_type::time;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1imu__type/#function-imu_type","title":"function imu_type","text":"<pre><code>inline ILLIXR::data_format::imu_type::imu_type (\n    time_point time_,\n    Eigen::Vector3d angular_v_,\n    Eigen::Vector3d linear_a_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/imu.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/","title":"Struct ILLIXR::data_format::monocular_cam_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; monocular_cam_type</p> <p>More...</p> <ul> <li><code>#include &lt;opencv_data_types.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::cam_base_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#public-attributes-inherited-from-illixrdata_formatcam_base_type","title":"Public Attributes inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name std::map&lt; image::image_type, cv::Mat &gt; images   = <code>{}</code>Mapping of the images with their types. time_point time Time associated with the image(s) camera::cam_type type What type of camera is this."},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#public-functions","title":"Public Functions","text":"Type Name cv::Mat img () const monocular_cam_type (time_point _time, cv::Mat _img)"},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#public-functions-inherited-from-illixrdata_formatcam_base_type","title":"Public Functions inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name cv::Mat at (const image::image_type idx) const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator begin () const cam_base_type (time_point _time, std::map&lt; image::image_type, cv::Mat &gt; imgs, camera::cam_type _type)  std::map&lt; image::image_type, cv::Mat &gt;::const_iterator end () const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator find (const image::image_type idx) const int format (image::image_type idx)  cv::Mat &amp; operator[] (image::image_type idx)  size_t size () const"},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#detailed-description","title":"Detailed Description","text":"<p>For monocular (single) images, like from a webcam. </p>"},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#function-img","title":"function img","text":"<pre><code>inline cv::Mat ILLIXR::data_format::monocular_cam_type::img () const\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1monocular__cam__type/#function-monocular_cam_type","title":"function monocular_cam_type","text":"<pre><code>inline ILLIXR::data_format::monocular_cam_type::monocular_cam_type (\n    time_point _time,\n    cv::Mat _img\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1point/","title":"Struct ILLIXR::data_format::point","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; point</p> <p>Inherits the following classes: Eigen::Vector3f</p> <p>Inherited by the following classes: ILLIXR::data_format::point_with_validity</p>"},{"location":"api/structILLIXR_1_1data__format_1_1point/#public-functions","title":"Public Functions","text":"Type Name point &amp; operator+= (const Eigen::Vector3f &amp; other)  point &amp; operator-= (const Eigen::Vector3f &amp; other)  point &amp; operator= (const Eigen::Vector3f &amp; other)  point &amp; operator= (const Eigen::Product&lt; T, U, Option &gt; &amp; pr)  point ()  point (const float x, const float y, const float z=0.)  void set (const float x_, const float y_, const float z_=0.)"},{"location":"api/structILLIXR_1_1data__format_1_1point/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1point/#function-operator","title":"function operator+=","text":"<pre><code>inline point &amp; ILLIXR::data_format::point::operator+= (\n    const Eigen::Vector3f &amp; other\n) \n</code></pre> <p>Addition operator for adding two points </p> <p>Parameters:</p> <ul> <li><code>other</code> the point to add to this one </li> </ul> <p>Returns:</p> <p>reference to the updated point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point/#function-operator-","title":"function operator-=","text":"<pre><code>inline point &amp; ILLIXR::data_format::point::operator-= (\n    const Eigen::Vector3f &amp; other\n) \n</code></pre> <p>Subtraction operator for adding two points </p> <p>Parameters:</p> <ul> <li><code>other</code> the point to subtract from this one </li> </ul> <p>Returns:</p> <p>reference to the updated point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point/#function-operator_1","title":"function operator=","text":"<pre><code>inline point &amp; ILLIXR::data_format::point::operator= (\n    const Eigen::Vector3f &amp; other\n) \n</code></pre> <p>Assignment operator </p> <p>Parameters:</p> <ul> <li><code>other</code> The point to copy </li> </ul> <p>Returns:</p> <p>A reference to the updated point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point/#function-operator_2","title":"function operator=","text":"<pre><code>template&lt;typename T, typename U, int Option&gt;\ninline point &amp; ILLIXR::data_format::point::operator= (\n    const Eigen::Product&lt; T, U, Option &gt; &amp; pr\n) \n</code></pre> <p>Assignment operator when dealing with multiplication products </p> <p>Template parameters:</p> <ul> <li><code>T</code> the type of the left hand side expression </li> <li><code>U</code> the type of the right hand side expression </li> <li><code>Option</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>pr</code> the multiplication product </li> </ul> <p>Returns:</p> <p>a reference to the updated point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point/#function-point-12","title":"function point [1/2]","text":"<pre><code>inline ILLIXR::data_format::point::point () \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1point/#function-point-22","title":"function point [2/2]","text":"<pre><code>inline ILLIXR::data_format::point::point (\n    const float x,\n    const float y,\n    const float z=0.\n) \n</code></pre> <p>Initial point based on the given x, y, and z coordinates </p> <p>Parameters:</p> <ul> <li><code>x</code> The x coordinate in arbitrary units </li> <li><code>y</code> The y coordinate in arbitrary units </li> <li><code>z</code> The z coordinate in arbitrary units, default is 0, indicating a point in 2-D space </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1point/#function-set","title":"function set","text":"<pre><code>inline void ILLIXR::data_format::point::set (\n    const float x_,\n    const float y_,\n    const float z_=0.\n) \n</code></pre> <p>Set the coordinates based on the given x, y, and z coordinates </p> <p>Parameters:</p> <ul> <li><code>x</code> The x coordinate in arbitrary units </li> <li><code>y</code> The y coordinate in arbitrary units </li> <li><code>z</code> The z coordinate in arbitrary units, default is 0, indicating a point in 2-D space </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/point.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/","title":"Struct ILLIXR::data_format::point_with_units","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; point_with_units</p> <p>Inherits the following classes: ILLIXR::data_format::point_with_validity</p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#public-attributes","title":"Public Attributes","text":"Type Name units::measurement_unit unit The units this point is in."},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#public-functions","title":"Public Functions","text":"Type Name point_with_units operator* (const float val) const point_with_units operator+ (const point_with_units &amp; pnt) const point_with_units operator+ (const Eigen::Vector3f &amp; pnt) const point_with_units operator- (const point_with_units &amp; pnt) const point_with_units operator- (const Eigen::Vector3f &amp; pnt) const point_with_units operator/ (const float val) const point_with_units (units::measurement_unit unit_=units::UNSET)  point_with_units (const float x, const float y, const float z, units::measurement_unit unit_=units::UNSET, bool valid_=true, const float confidence_=0.)  point_with_units (const point &amp; pnt, units::measurement_unit unit_=units::UNSET, bool valid_=true, const float confidence_=0.)  point_with_units (const point_with_validity &amp; pnt, units::measurement_unit unit_=units::UNSET)  void set (const float x_, const float y_, const float z_, units::measurement_unit unit_, bool valid_=true)  void set (const Eigen::Vector3f &amp; vec)  void set (const point_with_units &amp; pnt)"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#variable-unit","title":"variable unit","text":"<p>The units this point is in. <pre><code>units::measurement_unit ILLIXR::data_format::point_with_units::unit;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-operator","title":"function operator*","text":"<pre><code>inline point_with_units ILLIXR::data_format::point_with_units::operator* (\n    const float val\n) const\n</code></pre> <p>Multiplication operator to multiply a point_with_units by a constant value </p> <p>Parameters:</p> <ul> <li><code>val</code> The value to multiply by </li> </ul> <p>Returns:</p> <p>The new point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-operator_1","title":"function operator+","text":"<pre><code>inline point_with_units ILLIXR::data_format::point_with_units::operator+ (\n    const point_with_units &amp; pnt\n) const\n</code></pre> <p>Addition operator between two points_with_units, units are not checked, but the validity flag is an AND of the two flags </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to add to this one </li> </ul> <p>Returns:</p> <p>The new point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-operator_2","title":"function operator+","text":"<pre><code>inline point_with_units ILLIXR::data_format::point_with_units::operator+ (\n    const Eigen::Vector3f &amp; pnt\n) const\n</code></pre> <p>Addition operator between a points_with_units and Eigen::Vector </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to add to this one </li> </ul> <p>Returns:</p> <p>The new point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-operator-","title":"function operator-","text":"<pre><code>inline point_with_units ILLIXR::data_format::point_with_units::operator- (\n    const point_with_units &amp; pnt\n) const\n</code></pre> <p>Subtraction operator between two points_with_units, units are not checked, but the validity flag is an AND of the two flags </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to subtract from this one </li> </ul> <p>Returns:</p> <p>The new point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-operator-_1","title":"function operator-","text":"<pre><code>inline point_with_units ILLIXR::data_format::point_with_units::operator- (\n    const Eigen::Vector3f &amp; pnt\n) const\n</code></pre> <p>Subtraction operator between a points_with_units and Eigen::Vector </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to subtract from this one </li> </ul> <p>Returns:</p> <p>The new point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-operator_3","title":"function operator/","text":"<pre><code>inline point_with_units ILLIXR::data_format::point_with_units::operator/ (\n    const float val\n) const\n</code></pre> <p>Division operator to divide a point_with_units by a constant value </p> <p>Parameters:</p> <ul> <li><code>val</code> The value to divide by </li> </ul> <p>Returns:</p> <p>The new point </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-point_with_units-14","title":"function point_with_units [1/4]","text":"<pre><code>inline explicit ILLIXR::data_format::point_with_units::point_with_units (\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Default constructor, places point at the origin </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-point_with_units-24","title":"function point_with_units [2/4]","text":"<pre><code>inline ILLIXR::data_format::point_with_units::point_with_units (\n    const float x,\n    const float y,\n    const float z,\n    units::measurement_unit unit_=units::UNSET,\n    bool valid_=true,\n    const float confidence_=0.\n) \n</code></pre> <p>Initial point based on the given x, y, and z coordinates </p> <p>Parameters:</p> <ul> <li><code>x</code> The x coordinate in arbitrary units </li> <li><code>y</code> The y coordinate in arbitrary units </li> <li><code>z</code> The z coordinate in arbitrary units </li> <li><code>unit_</code> The units of the point, default is UNSET </li> <li><code>valid_</code> Whether the point contains valid data, default is true </li> <li><code>confidence_</code> Confidence level of the point's value, default is 0. </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-point_with_units-34","title":"function point_with_units [3/4]","text":"<pre><code>inline ILLIXR::data_format::point_with_units::point_with_units (\n    const point &amp; pnt,\n    units::measurement_unit unit_=units::UNSET,\n    bool valid_=true,\n    const float confidence_=0.\n) \n</code></pre> <p>Construct a point_with_units from another point </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to construct it from </li> <li><code>unit_</code> The units of the point, default is UNSET </li> <li><code>valid_</code> Whether the point contains valid data, default is true </li> <li><code>confidence_</code> Confidence level of the point's value, default is 0. </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-point_with_units-44","title":"function point_with_units [4/4]","text":"<pre><code>inline explicit ILLIXR::data_format::point_with_units::point_with_units (\n    const point_with_validity &amp; pnt,\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Construct a point_with_units from a point_with_validity </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to construct it from </li> <li><code>unit_</code> The units of the point, default is UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-set-13","title":"function set [1/3]","text":"<pre><code>inline void ILLIXR::data_format::point_with_units::set (\n    const float x_,\n    const float y_,\n    const float z_,\n    units::measurement_unit unit_,\n    bool valid_=true\n) \n</code></pre> <p>Set the coordinates based on the given x, y, and z coordinates </p> <p>Parameters:</p> <ul> <li><code>x</code> The x coordinate in arbitrary units </li> <li><code>y</code> The y coordinate in arbitrary units </li> <li><code>z</code> The z coordinate in arbitrary units </li> <li><code>unit_</code> The units of the point </li> <li><code>valid_</code> Whether the point contains valid data, default is true </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-set-23","title":"function set [2/3]","text":"<pre><code>inline void ILLIXR::data_format::point_with_units::set (\n    const Eigen::Vector3f &amp; vec\n) \n</code></pre> <p>Set the coordinates based on the given Eigen::Vector </p> <p>Parameters:</p> <ul> <li><code>vec</code> The vector to set the point from </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__units/#function-set-33","title":"function set [3/3]","text":"<pre><code>inline void ILLIXR::data_format::point_with_units::set (\n    const point_with_units &amp; pnt\n) \n</code></pre> <p>Set the coordinates from another point_with_units </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to set this one to </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/point.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/","title":"Struct ILLIXR::data_format::point_with_validity","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; point_with_validity</p> <p>Inherits the following classes: ILLIXR::data_format::point</p> <p>Inherited by the following classes: ILLIXR::data_format::point_with_units</p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#public-attributes","title":"Public Attributes","text":"Type Name float confidence   = <code>0.</code>confidence level of the point's value (0. - 1., with 1. indicating 100% confidence) bool valid   = <code>false</code>indicates whether the point contains valid data"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#public-functions","title":"Public Functions","text":"Type Name point_with_validity ()  point_with_validity (const float x, const float y, const float z, bool valid_=true, const float confidence_=0.)  point_with_validity (const point &amp; pnt, bool valid_=true, const float confidence_=0.)"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#variable-confidence","title":"variable confidence","text":"<p>confidence level of the point's value (0. - 1., with 1. indicating 100% confidence) <pre><code>float ILLIXR::data_format::point_with_validity::confidence;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#variable-valid","title":"variable valid","text":"<p>indicates whether the point contains valid data <pre><code>bool ILLIXR::data_format::point_with_validity::valid;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#function-point_with_validity-13","title":"function point_with_validity [1/3]","text":"<pre><code>inline ILLIXR::data_format::point_with_validity::point_with_validity () \n</code></pre> <p>Default constructor, places point at the origin </p>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#function-point_with_validity-23","title":"function point_with_validity [2/3]","text":"<pre><code>inline ILLIXR::data_format::point_with_validity::point_with_validity (\n    const float x,\n    const float y,\n    const float z,\n    bool valid_=true,\n    const float confidence_=0.\n) \n</code></pre> <p>Initial point based on the given x, y, and z coordinates </p> <p>Parameters:</p> <ul> <li><code>x</code> The x coordinate in arbitrary units </li> <li><code>y</code> The y coordinate in arbitrary units </li> <li><code>z</code> The z coordinate in arbitrary units </li> <li><code>valid_</code> Whether the point contains valid data, default is true </li> <li><code>confidence_</code> Confidence level of the point's value, default is 0. </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1point__with__validity/#function-point_with_validity-33","title":"function point_with_validity [3/3]","text":"<pre><code>inline ILLIXR::data_format::point_with_validity::point_with_validity (\n    const point &amp; pnt,\n    bool valid_=true,\n    const float confidence_=0.\n) \n</code></pre> <p>Construct a point_with_validity from another point </p> <p>Parameters:</p> <ul> <li><code>pnt</code> The point to construct it from </li> <li><code>valid_</code> Whether the point contains valid data, default is true </li> <li><code>confidence_</code> Confidence level of the point's value, default is 0. </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/point.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/","title":"Struct ILLIXR::data_format::points_with_units","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; points_with_units</p> <p>Inherited by the following classes: ILLIXR::data_format::ht::hand_points</p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#public-attributes","title":"Public Attributes","text":"Type Name bool fixed   = <code>false</code>indicates whther the size of the vector has been set std::vector&lt; point_with_units &gt; points The points. units::measurement_unit unit The unit of all points. bool valid"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#public-functions","title":"Public Functions","text":"Type Name point_with_units &amp; at (const size_t idx)  const point_with_units &amp; at (const size_t idx) const void check_validity ()  void enforce_bounds (const float x_lim=-1., const float y_lim=-1, const float z_lim=-1)  void mult (const Eigen::Matrix3f &amp; ref_frm)  points_with_units &amp; operator= (const points_with_units &amp; other)  point_with_units &amp; operator[] (const size_t idx)  points_with_units (units::measurement_unit unit_=units::UNSET)  points_with_units (const int size, units::measurement_unit unit_=units::UNSET)  points_with_units (std::vector&lt; point_with_units &gt; points_)  points_with_units (const points_with_units &amp; points_)  points_with_units (std::vector&lt; point_with_validity &gt; &amp; points_, units::measurement_unit unit_=units::UNSET)  points_with_units (std::vector&lt; point &gt; &amp; points_, units::measurement_unit unit_=units::UNSET, bool valid_=true)  size_t size () const void transform (const pose_data &amp; pose)"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#variable-fixed","title":"variable fixed","text":"<p>indicates whther the size of the vector has been set <pre><code>bool ILLIXR::data_format::points_with_units::fixed;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#variable-points","title":"variable points","text":"<p>The points. <pre><code>std::vector&lt;point_with_units&gt; ILLIXR::data_format::points_with_units::points;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#variable-unit","title":"variable unit","text":"<p>The unit of all points. <pre><code>units::measurement_unit ILLIXR::data_format::points_with_units::unit;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#variable-valid","title":"variable valid","text":"<pre><code>bool ILLIXR::data_format::points_with_units::valid;\n</code></pre> <p>Indicates the validity of all points, will be true if any point is valid, false indicates no points are valid </p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-at-12","title":"function at [1/2]","text":"<pre><code>inline point_with_units &amp; ILLIXR::data_format::points_with_units::at (\n    const size_t idx\n) \n</code></pre> <p>Get the point_with_unit at the given index </p> <p>Parameters:</p> <ul> <li><code>idx</code> The index of the requested point_with_units </li> </ul> <p>Returns:</p> <p>A reference to requested point_with_units </p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-at-22","title":"function at [2/2]","text":"<pre><code>inline const point_with_units &amp; ILLIXR::data_format::points_with_units::at (\n    const size_t idx\n) const\n</code></pre> <p>Get a const version of the point_with_unit at the given index </p> <p>Parameters:</p> <ul> <li><code>idx</code> The index of the requested point_with_units </li> </ul> <p>Returns:</p> <p>A const reference to requested point_with_units </p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-check_validity","title":"function check_validity","text":"<pre><code>inline void ILLIXR::data_format::points_with_units::check_validity () \n</code></pre> <p>Update the struct validity flag based on the point's flags </p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-enforce_bounds","title":"function enforce_bounds","text":"<pre><code>inline void ILLIXR::data_format::points_with_units::enforce_bounds (\n    const float x_lim=-1.,\n    const float y_lim=-1,\n    const float z_lim=-1\n) \n</code></pre> <p>Enforce point bounds to be valid for an image (e.g. no negative values </p> <p>Parameters:</p> <ul> <li><code>x_lim</code> upper limit of x values </li> <li><code>y_lim</code> upper limit of y values </li> <li><code>z_lim</code> upper limit of z values </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-mult","title":"function mult","text":"<pre><code>inline void ILLIXR::data_format::points_with_units::mult (\n    const Eigen::Matrix3f &amp; ref_frm\n) \n</code></pre> <p>Multiply all points by a matrix </p> <p>Parameters:</p> <ul> <li><code>ref_frm</code> The matrix to multiply all points by </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-operator","title":"function operator=","text":"<pre><code>inline points_with_units &amp; ILLIXR::data_format::points_with_units::operator= (\n    const points_with_units &amp; other\n) \n</code></pre> <p>Copy operator </p> <p>Parameters:</p> <ul> <li><code>other</code> The object to copy into this one </li> </ul> <p>Returns:</p> <p>A reference to the updated points_with_units </p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-operator_1","title":"function operator[]","text":"<pre><code>inline point_with_units &amp; ILLIXR::data_format::points_with_units::operator[] (\n    const size_t idx\n) \n</code></pre> <p>Indexing operator to get a specific point_with_units based on index </p> <p>Parameters:</p> <ul> <li><code>idx</code> The index of the requested point_with_units </li> </ul> <p>Returns:</p> <p>A reference to requested point_with_units </p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-points_with_units-16","title":"function points_with_units [1/6]","text":"<pre><code>inline explicit ILLIXR::data_format::points_with_units::points_with_units (\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Construct a points_with_units with an empty list </p> <p>Parameters:</p> <ul> <li><code>unit_</code> The units for the points, default is UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-points_with_units-26","title":"function points_with_units [2/6]","text":"<pre><code>inline explicit ILLIXR::data_format::points_with_units::points_with_units (\n    const int size,\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Construct a points_with_units with a list of points with the given size </p> <p>Parameters:</p> <ul> <li><code>size</code> The number of points to initialize </li> <li><code>unit_</code> The units for the points, default is UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-points_with_units-36","title":"function points_with_units [3/6]","text":"<pre><code>inline explicit ILLIXR::data_format::points_with_units::points_with_units (\n    std::vector&lt; point_with_units &gt; points_\n) \n</code></pre> <p>Construct a points_with_units from a vector of point_with_units objects, units are determined from the points, as is validity </p> <p>Parameters:</p> <ul> <li><code>points_</code> The points to move into this object </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-points_with_units-46","title":"function points_with_units [4/6]","text":"<pre><code>inline ILLIXR::data_format::points_with_units::points_with_units (\n    const points_with_units &amp; points_\n) \n</code></pre> <p>Copy constructor </p> <p>Parameters:</p> <ul> <li><code>points_</code> </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-points_with_units-56","title":"function points_with_units [5/6]","text":"<pre><code>inline explicit ILLIXR::data_format::points_with_units::points_with_units (\n    std::vector&lt; point_with_validity &gt; &amp; points_,\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Construct a points_with_units from a vector of point_with_validity objects, validity is determined from the points </p> <p>Parameters:</p> <ul> <li><code>points_</code> The points to move into this object </li> <li><code>unit_</code> The units for the points, default is UNSET </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-points_with_units-66","title":"function points_with_units [6/6]","text":"<pre><code>inline explicit ILLIXR::data_format::points_with_units::points_with_units (\n    std::vector&lt; point &gt; &amp; points_,\n    units::measurement_unit unit_=units::UNSET,\n    bool valid_=true\n) \n</code></pre> <p>Construct a points_with_units from a vector of point objects </p> <p>Parameters:</p> <ul> <li><code>points_</code> The points to move into this object </li> <li><code>unit_</code> The units for the points, default is UNSET </li> <li><code>valid_</code> The validity of all points, default is true </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-size","title":"function size","text":"<pre><code>inline size_t ILLIXR::data_format::points_with_units::size () const\n</code></pre> <p>Get the size of the internal vector </p> <p>Returns:</p> <p>The number of points stored </p>"},{"location":"api/structILLIXR_1_1data__format_1_1points__with__units/#function-transform","title":"function transform","text":"<pre><code>inline void ILLIXR::data_format::points_with_units::transform (\n    const pose_data &amp; pose\n) \n</code></pre> <p>Transform (move) all points by the given pose </p> <p>Parameters:</p> <ul> <li><code>pose</code> The pose to apply to the points </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/point.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/","title":"Struct ILLIXR::data_format::pose_data","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; pose_data</p> <p>More...</p> <ul> <li><code>#include &lt;pose.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::data_format::pose_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#public-attributes","title":"Public Attributes","text":"Type Name coordinates::frame co_frame the coordinate reference frame (e.g. left handed y up) float confidence confidence rating of the pose data 0. - 1. with 1. being 100% Eigen::Quaternionf orientation quaternion representing the rotation of the pose from the reference frame origin Eigen::Vector3f position x, y, and z of the translation coordinates::reference_space ref_space the reference space (VIEWER = origin is camera, WORLD = origin is specified at startup of system units::measurement_unit unit units for the translation portion of the pose bool valid whether the pose contains valid data"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#public-functions","title":"Public Functions","text":"Type Name pose_data ()  pose_data (Eigen::Vector3f position_, Eigen::Quaternionf orientation_, units::measurement_unit unit_=units::UNSET, coordinates::frame frm=coordinates::RIGHT_HANDED_Y_UP, coordinates::reference_space ref=coordinates::VIEWER, const float confidence_=0., bool valid_=true)"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#detailed-description","title":"Detailed Description","text":"<p>struct containing basic pose data </p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#variable-co_frame","title":"variable co_frame","text":"<p>the coordinate reference frame (e.g. left handed y up) <pre><code>coordinates::frame ILLIXR::data_format::pose_data::co_frame;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#variable-confidence","title":"variable confidence","text":"<p>confidence rating of the pose data 0. - 1. with 1. being 100% <pre><code>float ILLIXR::data_format::pose_data::confidence;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#variable-orientation","title":"variable orientation","text":"<p>quaternion representing the rotation of the pose from the reference frame origin <pre><code>Eigen::Quaternionf ILLIXR::data_format::pose_data::orientation;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#variable-position","title":"variable position","text":"<p>x, y, and z of the translation <pre><code>Eigen::Vector3f ILLIXR::data_format::pose_data::position;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#variable-ref_space","title":"variable ref_space","text":"<p>the reference space (VIEWER = origin is camera, WORLD = origin is specified at startup of system <pre><code>coordinates::reference_space ILLIXR::data_format::pose_data::ref_space;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#variable-unit","title":"variable unit","text":"<p>units for the translation portion of the pose <pre><code>units::measurement_unit ILLIXR::data_format::pose_data::unit;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#variable-valid","title":"variable valid","text":"<p>whether the pose contains valid data <pre><code>bool ILLIXR::data_format::pose_data::valid;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#function-pose_data-12","title":"function pose_data [1/2]","text":"<pre><code>inline ILLIXR::data_format::pose_data::pose_data () \n</code></pre> <p>Basic constructor </p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__data/#function-pose_data-22","title":"function pose_data [2/2]","text":"<pre><code>inline ILLIXR::data_format::pose_data::pose_data (\n    Eigen::Vector3f position_,\n    Eigen::Quaternionf orientation_,\n    units::measurement_unit unit_=units::UNSET,\n    coordinates::frame frm=coordinates::RIGHT_HANDED_Y_UP,\n    coordinates::reference_space ref=coordinates::VIEWER,\n    const float confidence_=0.,\n    bool valid_=true\n) \n</code></pre> <p>Create an instance based on the given data </p> <p>Parameters:</p> <ul> <li><code>position_</code> The positional part of the pose </li> <li><code>orientation_</code> RThe rotational part of the pose </li> <li><code>unit_</code> The units for the pose, default is UNSET </li> <li><code>frm</code> The reference frame, default is RIGHT_HANDED_Y_UP </li> <li><code>ref</code> The reference space, default is VIEWER </li> <li><code>confidence_</code> The confidence of the pose (0..1, where 0 means no confidence) </li> <li><code>valid_</code> The validity of the pose </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/","title":"Struct ILLIXR::data_format::pose_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; pose_type</p> <p>More...</p> <ul> <li><code>#include &lt;pose.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event,  ILLIXR::data_format::pose_data</p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#public-attributes","title":"Public Attributes","text":"Type Name time_point sensor_time Recorded time of sensor data ingestion."},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#public-attributes-inherited-from-illixrdata_formatpose_data","title":"Public Attributes inherited from ILLIXR::data_format::pose_data","text":"<p>See ILLIXR::data_format::pose_data</p> Type Name coordinates::frame co_frame the coordinate reference frame (e.g. left handed y up) float confidence confidence rating of the pose data 0. - 1. with 1. being 100% Eigen::Quaternionf orientation quaternion representing the rotation of the pose from the reference frame origin Eigen::Vector3f position x, y, and z of the translation coordinates::reference_space ref_space the reference space (VIEWER = origin is camera, WORLD = origin is specified at startup of system units::measurement_unit unit units for the translation portion of the pose bool valid whether the pose contains valid data"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#public-functions","title":"Public Functions","text":"Type Name pose_type ()  pose_type (time_point sensor_time_, Eigen::Vector3f &amp; position_, Eigen::Quaternionf &amp; orientation_, units::measurement_unit unit_=units::UNSET, coordinates::frame frm=coordinates::RIGHT_HANDED_Y_UP, coordinates::reference_space ref=coordinates::VIEWER, const float confidence_=0.)  pose_type (time_point sensor_time_, const Eigen::Vector3f &amp; position_, const Eigen::Quaternionf &amp; orientation_, units::measurement_unit unit_=units::UNSET, coordinates::frame frm=coordinates::RIGHT_HANDED_Y_UP, coordinates::reference_space ref=coordinates::VIEWER, const float confidence_=0.)  pose_type (time_point sensor_time_, pose_data &amp; other)"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#public-functions-inherited-from-illixrdata_formatpose_data","title":"Public Functions inherited from ILLIXR::data_format::pose_data","text":"<p>See ILLIXR::data_format::pose_data</p> Type Name pose_data ()  pose_data (Eigen::Vector3f position_, Eigen::Quaternionf orientation_, units::measurement_unit unit_=units::UNSET, coordinates::frame frm=coordinates::RIGHT_HANDED_Y_UP, coordinates::reference_space ref=coordinates::VIEWER, const float confidence_=0., bool valid_=true)"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#detailed-description","title":"Detailed Description","text":"<p>struct of a pose_data along with a timestamp </p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#variable-sensor_time","title":"variable sensor_time","text":"<p>Recorded time of sensor data ingestion. <pre><code>time_point ILLIXR::data_format::pose_type::sensor_time;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#function-pose_type-14","title":"function pose_type [1/4]","text":"<pre><code>inline ILLIXR::data_format::pose_type::pose_type () \n</code></pre> <p>Basic constructor </p>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#function-pose_type-24","title":"function pose_type [2/4]","text":"<pre><code>inline ILLIXR::data_format::pose_type::pose_type (\n    time_point sensor_time_,\n    Eigen::Vector3f &amp; position_,\n    Eigen::Quaternionf &amp; orientation_,\n    units::measurement_unit unit_=units::UNSET,\n    coordinates::frame frm=coordinates::RIGHT_HANDED_Y_UP,\n    coordinates::reference_space ref=coordinates::VIEWER,\n    const float confidence_=0.\n) \n</code></pre> <p>Construct an instance based on the given data </p> <p>Parameters:</p> <ul> <li><code>sensor_time_</code> Time associated with htese data </li> <li><code>position_</code> The positional part of the pose </li> <li><code>orientation_</code> RThe rotational part of the pose </li> <li><code>unit_</code> The units for the pose, default is UNSET </li> <li><code>frm</code> The reference frame, default is RIGHT_HANDED_Y_UP </li> <li><code>ref</code> The reference space, default is VIEWER </li> <li><code>confidence_</code> The confidence of the pose (0..1, where 0 means no confidence) </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#function-pose_type-34","title":"function pose_type [3/4]","text":"<pre><code>inline ILLIXR::data_format::pose_type::pose_type (\n    time_point sensor_time_,\n    const Eigen::Vector3f &amp; position_,\n    const Eigen::Quaternionf &amp; orientation_,\n    units::measurement_unit unit_=units::UNSET,\n    coordinates::frame frm=coordinates::RIGHT_HANDED_Y_UP,\n    coordinates::reference_space ref=coordinates::VIEWER,\n    const float confidence_=0.\n) \n</code></pre> <p>Construct an instance based on the given data </p> <p>Parameters:</p> <ul> <li><code>sensor_time_</code> Time associated with htese data </li> <li><code>position_</code> The positional part of the pose </li> <li><code>orientation_</code> RThe rotational part of the pose </li> <li><code>unit_</code> The units for the pose, default is UNSET </li> <li><code>frm</code> The reference frame, default is RIGHT_HANDED_Y_UP </li> <li><code>ref</code> The reference space, default is VIEWER </li> <li><code>confidence_</code> The confidence of the pose (0..1, where 0 means no confidence) </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1pose__type/#function-pose_type-44","title":"function pose_type [4/4]","text":"<pre><code>inline ILLIXR::data_format::pose_type::pose_type (\n    time_point sensor_time_,\n    pose_data &amp; other\n) \n</code></pre> <p>Construct an instance using the given pose </p> <p>Parameters:</p> <ul> <li><code>sensor_time_</code> The timne associated with the pose </li> <li><code>other</code> The pose to use </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/","title":"Struct ILLIXR::data_format::raw_point","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; raw_point</p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#public-attributes","title":"Public Attributes","text":"Type Name bool valid float x float y float z"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#public-functions","title":"Public Functions","text":"Type Name void copy (const point_with_units &amp; pnt)  void de_transform (const pose_data &amp; pose)  void mult (const Eigen::Matrix3f &amp; ref_frm)  raw_point ()  raw_point (const point_with_units &amp; pnt)  void transform (const pose_data &amp; pose)"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#variable-valid","title":"variable valid","text":"<pre><code>bool ILLIXR::data_format::raw_point::valid;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#variable-x","title":"variable x","text":"<pre><code>float ILLIXR::data_format::raw_point::x;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#variable-y","title":"variable y","text":"<pre><code>float ILLIXR::data_format::raw_point::y;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#variable-z","title":"variable z","text":"<pre><code>float ILLIXR::data_format::raw_point::z;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#function-copy","title":"function copy","text":"<pre><code>inline void ILLIXR::data_format::raw_point::copy (\n    const point_with_units &amp; pnt\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#function-de_transform","title":"function de_transform","text":"<pre><code>inline void ILLIXR::data_format::raw_point::de_transform (\n    const pose_data &amp; pose\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#function-mult","title":"function mult","text":"<pre><code>inline void ILLIXR::data_format::raw_point::mult (\n    const Eigen::Matrix3f &amp; ref_frm\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#function-raw_point-12","title":"function raw_point [1/2]","text":"<pre><code>inline ILLIXR::data_format::raw_point::raw_point () \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#function-raw_point-22","title":"function raw_point [2/2]","text":"<pre><code>inline explicit ILLIXR::data_format::raw_point::raw_point (\n    const point_with_units &amp; pnt\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__point/#function-transform","title":"function transform","text":"<pre><code>inline void ILLIXR::data_format::raw_point::transform (\n    const pose_data &amp; pose\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/point.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/","title":"Struct ILLIXR::data_format::raw_pose","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; raw_pose</p> <p>More...</p> <ul> <li><code>#include &lt;pose.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#public-attributes","title":"Public Attributes","text":"Type Name bool valid validity flag float w quaternion w float wx quaternion x float wy quaternion y float wz quaternion z float x x-coordinate float y y-coordinate float z z-coordinate"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#public-functions","title":"Public Functions","text":"Type Name void copy (const pose_data &amp; pd)  raw_pose ()  raw_pose (const pose_data &amp; pd)"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#detailed-description","title":"Detailed Description","text":"<p>This struct is utilized when working with OpenXR. The internal variables are in a basic form since OpenXR uses C, rather than C++ (e.g. pose contains just floats, instead of Eigen::Vector and Eigen::Quaternion) </p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-valid","title":"variable valid","text":"<p>validity flag <pre><code>bool ILLIXR::data_format::raw_pose::valid;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-w","title":"variable w","text":"<p>quaternion w <pre><code>float ILLIXR::data_format::raw_pose::w;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-wx","title":"variable wx","text":"<p>quaternion x <pre><code>float ILLIXR::data_format::raw_pose::wx;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-wy","title":"variable wy","text":"<p>quaternion y <pre><code>float ILLIXR::data_format::raw_pose::wy;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-wz","title":"variable wz","text":"<p>quaternion z <pre><code>float ILLIXR::data_format::raw_pose::wz;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-x","title":"variable x","text":"<p>x-coordinate <pre><code>float ILLIXR::data_format::raw_pose::x;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-y","title":"variable y","text":"<p>y-coordinate <pre><code>float ILLIXR::data_format::raw_pose::y;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#variable-z","title":"variable z","text":"<p>z-coordinate <pre><code>float ILLIXR::data_format::raw_pose::z;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#function-copy","title":"function copy","text":"<pre><code>inline void ILLIXR::data_format::raw_pose::copy (\n    const pose_data &amp; pd\n) \n</code></pre> <p>Copy a pose into this structure </p> <p>Parameters:</p> <ul> <li><code>pd</code> The pose to copy </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#function-raw_pose-12","title":"function raw_pose [1/2]","text":"<pre><code>inline ILLIXR::data_format::raw_pose::raw_pose () \n</code></pre> <p>Basic constructor </p>"},{"location":"api/structILLIXR_1_1data__format_1_1raw__pose/#function-raw_pose-22","title":"function raw_pose [2/2]","text":"<pre><code>inline explicit ILLIXR::data_format::raw_pose::raw_pose (\n    const pose_data &amp; pd\n) \n</code></pre> <p>Create an instance using the given pose </p> <p>Parameters:</p> <ul> <li><code>pd</code> The pose to use </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/","title":"Struct ILLIXR::data_format::rect","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; rect</p> <p>More...</p> <ul> <li><code>#include &lt;shape.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#public-attributes","title":"Public Attributes","text":"Type Name double height height of the rectangle (parallel to y-axis when rotation angle is 0) double rotation rotation angle of the rectangle in radians units::measurement_unit unit bool valid if the rectangle is valid double width width of the rectangle (parallel to x-axis when rotation angle is 0) double x_center x-coordinate of the rectangle's center double y_center y-coordinate of the rectangle's center"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#public-functions","title":"Public Functions","text":"Type Name void flip_y (const uint im_height=0)  rect ()  rect (rect * other)  rect (const double xc, const double yc, const double w, const double h, const double r, units::measurement_unit unit_=units::UNSET)  void set (const double xc, const double yc, const double w, const double h, const double r, units::measurement_unit unit_=units::UNSET)"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#detailed-description","title":"Detailed Description","text":"<p>Struct which defines a representation of a rectangle </p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1rect/#variable-height","title":"variable height","text":"<p>height of the rectangle (parallel to y-axis when rotation angle is 0) <pre><code>double ILLIXR::data_format::rect::height;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#variable-rotation","title":"variable rotation","text":"<p>rotation angle of the rectangle in radians <pre><code>double ILLIXR::data_format::rect::rotation;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#variable-unit","title":"variable unit","text":"<pre><code>units::measurement_unit ILLIXR::data_format::rect::unit;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#variable-valid","title":"variable valid","text":"<p>if the rectangle is valid <pre><code>bool ILLIXR::data_format::rect::valid;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#variable-width","title":"variable width","text":"<p>width of the rectangle (parallel to x-axis when rotation angle is 0) <pre><code>double ILLIXR::data_format::rect::width;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#variable-x_center","title":"variable x_center","text":"<p>x-coordinate of the rectangle's center <pre><code>double ILLIXR::data_format::rect::x_center;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#variable-y_center","title":"variable y_center","text":"<p>y-coordinate of the rectangle's center <pre><code>double ILLIXR::data_format::rect::y_center;\n</code></pre></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1rect/#function-flip_y","title":"function flip_y","text":"<pre><code>inline void ILLIXR::data_format::rect::flip_y (\n    const uint im_height=0\n) \n</code></pre> <p>Flip the y-coordinate about the center axis </p> <p>Parameters:</p> <ul> <li><code>im_height</code> </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#function-rect-13","title":"function rect [1/3]","text":"<pre><code>inline ILLIXR::data_format::rect::rect () \n</code></pre> <p>Generic constructor which sets all values to 0 </p>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#function-rect-23","title":"function rect [2/3]","text":"<pre><code>inline explicit ILLIXR::data_format::rect::rect (\n    rect * other\n) \n</code></pre> <p>Copy constructor </p> <p>Parameters:</p> <ul> <li><code>other</code> The rect to copy </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#function-rect-33","title":"function rect [3/3]","text":"<pre><code>inline ILLIXR::data_format::rect::rect (\n    const double xc,\n    const double yc,\n    const double w,\n    const double h,\n    const double r,\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>General constructor </p> <p>Parameters:</p> <ul> <li><code>xc</code> the x-coordinate </li> <li><code>yc</code> the y-coordinate </li> <li><code>w</code> the width </li> <li><code>h</code> the height </li> <li><code>r</code> rotation angle </li> </ul>"},{"location":"api/structILLIXR_1_1data__format_1_1rect/#function-set","title":"function set","text":"<pre><code>inline void ILLIXR::data_format::rect::set (\n    const double xc,\n    const double yc,\n    const double w,\n    const double h,\n    const double r,\n    units::measurement_unit unit_=units::UNSET\n) \n</code></pre> <p>Set the rect's values after construction </p> <p>Parameters:</p> <ul> <li><code>xc</code> the x-coordinate </li> <li><code>yc</code> the y-coordinate </li> <li><code>w</code> the width </li> <li><code>h</code> the height </li> <li><code>r</code> rotation angle </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/shape.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/","title":"Struct ILLIXR::data_format::rendered_frame","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; rendered_frame</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#public-attributes","title":"Public Attributes","text":"Type Name fast_pose_type render_pose time_point render_time   = <code>{}</code> time_point sample_time   = <code>{}</code> std::array&lt; GLuint, 2 &gt; swap_indices   = <code>{}</code> std::array&lt; GLuint, 2 &gt; swapchain_indices   = <code>{}</code>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#public-functions","title":"Public Functions","text":"Type Name rendered_frame () = default rendered_frame (std::array&lt; GLuint, 2 &gt; &amp;&amp; swapchain_indices_, std::array&lt; GLuint, 2 &gt; &amp;&amp; swap_indices_, fast_pose_type render_pose_, time_point sample_time_, time_point render_time_)"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#variable-render_pose","title":"variable render_pose","text":"<pre><code>fast_pose_type ILLIXR::data_format::rendered_frame::render_pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#variable-render_time","title":"variable render_time","text":"<pre><code>time_point ILLIXR::data_format::rendered_frame::render_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#variable-sample_time","title":"variable sample_time","text":"<pre><code>time_point ILLIXR::data_format::rendered_frame::sample_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#variable-swap_indices","title":"variable swap_indices","text":"<pre><code>std::array&lt;GLuint, 2&gt; ILLIXR::data_format::rendered_frame::swap_indices;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#variable-swapchain_indices","title":"variable swapchain_indices","text":"<pre><code>std::array&lt;GLuint, 2&gt; ILLIXR::data_format::rendered_frame::swapchain_indices;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#function-rendered_frame-12","title":"function rendered_frame [1/2]","text":"<pre><code>ILLIXR::data_format::rendered_frame::rendered_frame () = default\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rendered__frame/#function-rendered_frame-22","title":"function rendered_frame [2/2]","text":"<pre><code>inline ILLIXR::data_format::rendered_frame::rendered_frame (\n    std::array&lt; GLuint, 2 &gt; &amp;&amp; swapchain_indices_,\n    std::array&lt; GLuint, 2 &gt; &amp;&amp; swap_indices_,\n    fast_pose_type render_pose_,\n    time_point sample_time_,\n    time_point render_time_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/frame.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/","title":"Struct ILLIXR::data_format::rgb_depth_type","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; rgb_depth_type</p> <p>More...</p> <ul> <li><code>#include &lt;opencv_data_types.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::data_format::cam_base_type</p>"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#public-attributes","title":"Public Attributes","text":"Type Name units::measurement_unit units"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#public-attributes-inherited-from-illixrdata_formatcam_base_type","title":"Public Attributes inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name std::map&lt; image::image_type, cv::Mat &gt; images   = <code>{}</code>Mapping of the images with their types. time_point time Time associated with the image(s) camera::cam_type type What type of camera is this."},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#public-functions","title":"Public Functions","text":"Type Name rgb_depth_type (time_point _time, cv::Mat _rgb, cv::Mat _depth, units::measurement_unit units_=units::UNSET)"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#public-functions-inherited-from-illixrdata_formatcam_base_type","title":"Public Functions inherited from ILLIXR::data_format::cam_base_type","text":"<p>See ILLIXR::data_format::cam_base_type</p> Type Name cv::Mat at (const image::image_type idx) const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator begin () const cam_base_type (time_point _time, std::map&lt; image::image_type, cv::Mat &gt; imgs, camera::cam_type _type)  std::map&lt; image::image_type, cv::Mat &gt;::const_iterator end () const std::map&lt; image::image_type, cv::Mat &gt;::const_iterator find (const image::image_type idx) const int format (image::image_type idx)  cv::Mat &amp; operator[] (image::image_type idx)  size_t size () const"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#detailed-description","title":"Detailed Description","text":"<p>For RGB based depth images </p>"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#variable-units","title":"variable units","text":"<pre><code>units::measurement_unit ILLIXR::data_format::rgb_depth_type::units;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1rgb__depth__type/#function-rgb_depth_type","title":"function rgb_depth_type","text":"<pre><code>inline ILLIXR::data_format::rgb_depth_type::rgb_depth_type (\n    time_point _time,\n    cv::Mat _rgb,\n    cv::Mat _depth,\n    units::measurement_unit units_=units::UNSET\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/opencv_data_types.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/","title":"Struct ILLIXR::data_format::signal_to_quad","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; signal_to_quad</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/#public-attributes","title":"Public Attributes","text":"Type Name ullong seq"},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/#public-functions","title":"Public Functions","text":"Type Name signal_to_quad (ullong seq_)"},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/#variable-seq","title":"variable seq","text":"<pre><code>ullong ILLIXR::data_format::signal_to_quad::seq;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1signal__to__quad/#function-signal_to_quad","title":"function signal_to_quad","text":"<pre><code>inline explicit ILLIXR::data_format::signal_to_quad::signal_to_quad (\n    ullong seq_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/misc.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/","title":"Struct ILLIXR::data_format::texture_pose","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; texture_pose</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#public-attributes","title":"Public Attributes","text":"Type Name unsigned char * image   = <code>{}</code> Eigen::Quaternionf latest_quaternion duration offload_duration   = <code>{}</code> time_point pose_time   = <code>{}</code> Eigen::Vector3f position Eigen::Quaternionf render_quaternion"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#public-functions","title":"Public Functions","text":"Type Name texture_pose () = default texture_pose (duration offload_duration_, unsigned char * image_, time_point pose_time_, Eigen::Vector3f position_, Eigen::Quaternionf latest_quaternion_, Eigen::Quaternionf render_quaternion_)"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name void serialize (Archive &amp; ar, const unsigned int version)  virtual ~event () = default"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#variable-image","title":"variable image","text":"<pre><code>unsigned char* ILLIXR::data_format::texture_pose::image;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#variable-latest_quaternion","title":"variable latest_quaternion","text":"<pre><code>Eigen::Quaternionf ILLIXR::data_format::texture_pose::latest_quaternion;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#variable-offload_duration","title":"variable offload_duration","text":"<pre><code>duration ILLIXR::data_format::texture_pose::offload_duration;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#variable-pose_time","title":"variable pose_time","text":"<pre><code>time_point ILLIXR::data_format::texture_pose::pose_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3f ILLIXR::data_format::texture_pose::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#variable-render_quaternion","title":"variable render_quaternion","text":"<pre><code>Eigen::Quaternionf ILLIXR::data_format::texture_pose::render_quaternion;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#function-texture_pose-12","title":"function texture_pose [1/2]","text":"<pre><code>ILLIXR::data_format::texture_pose::texture_pose () = default\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1texture__pose/#function-texture_pose-22","title":"function texture_pose [2/2]","text":"<pre><code>inline ILLIXR::data_format::texture_pose::texture_pose (\n    duration offload_duration_,\n    unsigned char * image_,\n    time_point pose_time_,\n    Eigen::Vector3f position_,\n    Eigen::Quaternionf latest_quaternion_,\n    Eigen::Quaternionf render_quaternion_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/pose.hpp</code></p>"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/","title":"Struct ILLIXR::data_format::vk_image_handle","text":"<p>ClassList &gt; ILLIXR &gt; data_format &gt; vk_image_handle</p>"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#public-attributes","title":"Public Attributes","text":"Type Name size_t allocation_size int file_descriptor int64_t format uint32_t height uint32_t width"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#public-functions","title":"Public Functions","text":"Type Name vk_image_handle (int fd_, int64_t format_, size_t alloc_size, uint32_t width_, uint32_t height_)"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#variable-allocation_size","title":"variable allocation_size","text":"<pre><code>size_t ILLIXR::data_format::vk_image_handle::allocation_size;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#variable-file_descriptor","title":"variable file_descriptor","text":"<pre><code>int ILLIXR::data_format::vk_image_handle::file_descriptor;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#variable-format","title":"variable format","text":"<pre><code>int64_t ILLIXR::data_format::vk_image_handle::format;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#variable-height","title":"variable height","text":"<pre><code>uint32_t ILLIXR::data_format::vk_image_handle::height;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#variable-width","title":"variable width","text":"<pre><code>uint32_t ILLIXR::data_format::vk_image_handle::width;\n</code></pre>"},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1data__format_1_1vk__image__handle/#function-vk_image_handle","title":"function vk_image_handle","text":"<pre><code>inline ILLIXR::data_format::vk_image_handle::vk_image_handle (\n    int fd_,\n    int64_t format_,\n    size_t alloc_size,\n    uint32_t width_,\n    uint32_t height_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/misc.hpp</code></p>"},{"location":"api/structILLIXR_1_1display__params/","title":"Struct ILLIXR::display_params","text":"<p>ClassList &gt; ILLIXR &gt; display_params</p> <p>Display parameters. </p> <ul> <li><code>#include &lt;global_module_defs.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1display__params/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float aberration   = <code>{-0.016f, 0.0f, 0.024f, 0.0f}</code> constexpr float fov_x   = <code>108.06f</code> constexpr float fov_y   = <code>109.16f</code> constexpr float frequency   = <code>144.0f</code> constexpr float height_meters   = <code>0.06214f</code> constexpr unsigned height_pixels   = <code>1600</code> constexpr float ipd   = <code>0.064f</code> constexpr float lens_separation   = <code>0.05</code> constexpr float lens_vertical_position   = <code>height\\_meters / 2.0f</code> constexpr float meters_per_tan_angle   = <code>width\\_meters / (2 \\* (fov\\_x \\* M\\_PI / 180.0f))</code> constexpr duration period   = <code>freq\\_to\\_period(frequency)</code> constexpr float width_meters   = <code>0.11047f</code> constexpr unsigned width_pixels   = <code>2880</code>"},{"location":"api/structILLIXR_1_1display__params/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1display__params/#variable-aberration","title":"variable aberration","text":"<pre><code>constexpr float ILLIXR::display_params::aberration[4];\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-fov_x","title":"variable fov_x","text":"<pre><code>constexpr float ILLIXR::display_params::fov_x;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-fov_y","title":"variable fov_y","text":"<pre><code>constexpr float ILLIXR::display_params::fov_y;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-frequency","title":"variable frequency","text":"<pre><code>constexpr float ILLIXR::display_params::frequency;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-height_meters","title":"variable height_meters","text":"<pre><code>constexpr float ILLIXR::display_params::height_meters;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-height_pixels","title":"variable height_pixels","text":"<pre><code>constexpr unsigned ILLIXR::display_params::height_pixels;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-ipd","title":"variable ipd","text":"<pre><code>constexpr float ILLIXR::display_params::ipd;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-lens_separation","title":"variable lens_separation","text":"<pre><code>constexpr float ILLIXR::display_params::lens_separation;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-lens_vertical_position","title":"variable lens_vertical_position","text":"<pre><code>constexpr float ILLIXR::display_params::lens_vertical_position;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-meters_per_tan_angle","title":"variable meters_per_tan_angle","text":"<pre><code>constexpr float ILLIXR::display_params::meters_per_tan_angle;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-period","title":"variable period","text":"<pre><code>constexpr duration ILLIXR::display_params::period;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-width_meters","title":"variable width_meters","text":"<pre><code>constexpr float ILLIXR::display_params::width_meters;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-width_pixels","title":"variable width_pixels","text":"<pre><code>constexpr unsigned ILLIXR::display_params::width_pixels;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/structILLIXR_1_1index__params/","title":"Struct ILLIXR::index_params","text":"<p>ClassList &gt; ILLIXR &gt; index_params</p>"},{"location":"api/structILLIXR_1_1index__params/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float fov_down   = <code>{-0.953628, -0.952802}</code> constexpr float fov_left   = <code>{-0.907341, -0.897566}</code> constexpr float fov_right   = <code>{0.897500, 0.907700}</code> constexpr float fov_up   = <code>{0.953644, 0.954293}</code>"},{"location":"api/structILLIXR_1_1index__params/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1index__params/#variable-fov_down","title":"variable fov_down","text":"<pre><code>constexpr float ILLIXR::index_params::fov_down[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1index__params/#variable-fov_left","title":"variable fov_left","text":"<pre><code>constexpr float ILLIXR::index_params::fov_left[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1index__params/#variable-fov_right","title":"variable fov_right","text":"<pre><code>constexpr float ILLIXR::index_params::fov_right[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1index__params/#variable-fov_up","title":"variable fov_up","text":"<pre><code>constexpr float ILLIXR::index_params::fov_up[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/structILLIXR_1_1model/","title":"Struct ILLIXR::model","text":"<p>ClassList &gt; ILLIXR &gt; model</p>"},{"location":"api/structILLIXR_1_1model/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t index_count uint32_t index_offset int texture_index uint32_t vertex_offset"},{"location":"api/structILLIXR_1_1model/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1model/#variable-index_count","title":"variable index_count","text":"<pre><code>uint32_t ILLIXR::model::index_count;\n</code></pre>"},{"location":"api/structILLIXR_1_1model/#variable-index_offset","title":"variable index_offset","text":"<pre><code>uint32_t ILLIXR::model::index_offset;\n</code></pre>"},{"location":"api/structILLIXR_1_1model/#variable-texture_index","title":"variable texture_index","text":"<pre><code>int ILLIXR::model::texture_index;\n</code></pre>"},{"location":"api/structILLIXR_1_1model/#variable-vertex_offset","title":"variable vertex_offset","text":"<pre><code>uint32_t ILLIXR::model::vertex_offset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.hpp</code></p>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/","title":"Struct ILLIXR::network::topic_config","text":"<p>ClassList &gt; ILLIXR &gt; network &gt; topic_config</p>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#public-types","title":"Public Types","text":"Type Name enum SerializationMethod enum packetization_type enum priority_type"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#public-attributes","title":"Public Attributes","text":"Type Name bool allow_out_of_order   = <code>false</code> std::optional&lt; std::chrono::duration&lt; long, std::nano &gt; &gt; latency packetization_type packetization   = <code>DEFAULT</code> priority_type priority   = <code>MEDIUM</code> bool retransmit   = <code>false</code> enum ILLIXR::network::topic_config::SerializationMethod serialization_method"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structILLIXR_1_1network_1_1topic__config/#enum-serializationmethod","title":"enum SerializationMethod","text":"<pre><code>enum ILLIXR::network::topic_config::SerializationMethod {\n    BOOST,\n    PROTOBUF\n};\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#enum-packetization_type","title":"enum packetization_type","text":"<pre><code>enum ILLIXR::network::topic_config::packetization_type {\n    IMMEDIATE,\n    DEFAULT,\n    SUGGEST_LATENCY\n};\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#enum-priority_type","title":"enum priority_type","text":"<pre><code>enum ILLIXR::network::topic_config::priority_type {\n    LOWEST,\n    LOW,\n    MEDIUM,\n    HIGH,\n    HIGHEST\n};\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1network_1_1topic__config/#variable-allow_out_of_order","title":"variable allow_out_of_order","text":"<pre><code>bool ILLIXR::network::topic_config::allow_out_of_order;\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#variable-latency","title":"variable latency","text":"<pre><code>std::optional&lt;std::chrono::duration&lt;long, std::nano&gt; &gt; ILLIXR::network::topic_config::latency;\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#variable-packetization","title":"variable packetization","text":"<pre><code>packetization_type ILLIXR::network::topic_config::packetization;\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#variable-priority","title":"variable priority","text":"<pre><code>priority_type ILLIXR::network::topic_config::priority;\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#variable-retransmit","title":"variable retransmit","text":"<pre><code>bool ILLIXR::network::topic_config::retransmit;\n</code></pre>"},{"location":"api/structILLIXR_1_1network_1_1topic__config/#variable-serialization_method","title":"variable serialization_method","text":"<pre><code>enum ILLIXR::network::topic_config::SerializationMethod ILLIXR::network::topic_config::serialization_method;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/topic_config.hpp</code></p>"},{"location":"api/structILLIXR_1_1raw__imu__type/","title":"Struct ILLIXR::raw_imu_type","text":"<p>ClassList &gt; ILLIXR &gt; raw_imu_type</p>"},{"location":"api/structILLIXR_1_1raw__imu__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3d angular_v Eigen::Vector3d linear_a"},{"location":"api/structILLIXR_1_1raw__imu__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1raw__imu__type/#variable-angular_v","title":"variable angular_v","text":"<pre><code>Eigen::Vector3d ILLIXR::raw_imu_type::angular_v;\n</code></pre>"},{"location":"api/structILLIXR_1_1raw__imu__type/#variable-linear_a","title":"variable linear_a","text":"<pre><code>Eigen::Vector3d ILLIXR::raw_imu_type::linear_a;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_imu/plugin.hpp</code></p>"},{"location":"api/structILLIXR_1_1realsense_1_1accel__type/","title":"Struct ILLIXR::realsense::accel_type","text":"<p>ClassList &gt; accel_type</p>"},{"location":"api/structILLIXR_1_1realsense_1_1accel__type/#public-attributes","title":"Public Attributes","text":"Type Name rs2_vector data int iteration"},{"location":"api/structILLIXR_1_1realsense_1_1accel__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1realsense_1_1accel__type/#variable-data","title":"variable data","text":"<pre><code>rs2_vector ILLIXR::realsense::accel_type::data;\n</code></pre>"},{"location":"api/structILLIXR_1_1realsense_1_1accel__type/#variable-iteration","title":"variable iteration","text":"<pre><code>int ILLIXR::realsense::accel_type::iteration;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/realsense/plugin.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendering__params/","title":"Struct ILLIXR::rendering_params","text":"<p>ClassList &gt; ILLIXR &gt; rendering_params</p> <p>Rendering parameters. </p> <ul> <li><code>#include &lt;global_module_defs.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1rendering__params/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float far_z   = <code>20.0f</code> constexpr float near_z   = <code>0.1f</code> constexpr bool reverse_z   = <code>true</code>"},{"location":"api/structILLIXR_1_1rendering__params/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendering__params/#variable-far_z","title":"variable far_z","text":"<pre><code>constexpr float ILLIXR::rendering_params::far_z;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendering__params/#variable-near_z","title":"variable near_z","text":"<pre><code>constexpr float ILLIXR::rendering_params::near_z;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendering__params/#variable-reverse_z","title":"variable reverse_z","text":"<pre><code>constexpr bool ILLIXR::rendering_params::reverse_z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/structILLIXR_1_1sensor__types/","title":"Struct ILLIXR::sensor_types","text":"<p>ClassList &gt; ILLIXR &gt; sensor_types</p>"},{"location":"api/structILLIXR_1_1sensor__types/#public-attributes","title":"Public Attributes","text":"Type Name lazy_load_image cam0 lazy_load_image cam1 raw_imu_type imu0"},{"location":"api/structILLIXR_1_1sensor__types/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1sensor__types/#variable-cam0","title":"variable cam0","text":"<pre><code>lazy_load_image ILLIXR::sensor_types::cam0;\n</code></pre>"},{"location":"api/structILLIXR_1_1sensor__types/#variable-cam1","title":"variable cam1","text":"<pre><code>lazy_load_image ILLIXR::sensor_types::cam1;\n</code></pre>"},{"location":"api/structILLIXR_1_1sensor__types/#variable-imu0","title":"variable imu0","text":"<pre><code>raw_imu_type ILLIXR::sensor_types::imu0;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offline_cam/plugin.hpp</code></p>"},{"location":"api/structILLIXR_1_1server__params/","title":"Struct ILLIXR::server_params","text":"<p>ClassList &gt; ILLIXR &gt; server_params</p>"},{"location":"api/structILLIXR_1_1server__params/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float fov_down   = <code>{-0.953628, -0.952802}</code> constexpr float fov_left   = <code>{-0.907341, -0.897566}</code> constexpr float fov_right   = <code>{0.897500, 0.907700}</code> constexpr float fov_up   = <code>{0.953644, 0.954293}</code>"},{"location":"api/structILLIXR_1_1server__params/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1server__params/#variable-fov_down","title":"variable fov_down","text":"<pre><code>constexpr float ILLIXR::server_params::fov_down[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1server__params/#variable-fov_left","title":"variable fov_left","text":"<pre><code>constexpr float ILLIXR::server_params::fov_left[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1server__params/#variable-fov_right","title":"variable fov_right","text":"<pre><code>constexpr float ILLIXR::server_params::fov_right[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1server__params/#variable-fov_up","title":"variable fov_up","text":"<pre><code>constexpr float ILLIXR::server_params::fov_up[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/structILLIXR_1_1state__plus/","title":"Struct ILLIXR::state_plus","text":"<p>ClassList &gt; ILLIXR &gt; state_plus</p> <p>More...</p> <ul> <li><code>#include &lt;runge-kutta.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1state__plus/#public-attributes","title":"Public Attributes","text":"Type Name data_format::proper_quaterniond orientation Eigen::Vector3d position Eigen::Vector3d velocity"},{"location":"api/structILLIXR_1_1state__plus/#public-functions","title":"Public Functions","text":"Type Name state_plus (const data_format::proper_quaterniond &amp; pq, const Eigen::Vector3d &amp; vel, const Eigen::Vector3d &amp; pos)  state_plus (const Eigen::Quaterniond &amp; pq, const Eigen::Vector3d &amp; vel, const Eigen::Vector3d &amp; pos)  state_plus () = default"},{"location":"api/structILLIXR_1_1state__plus/#detailed-description","title":"Detailed Description","text":"<p>Convenience struct </p>"},{"location":"api/structILLIXR_1_1state__plus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1state__plus/#variable-orientation","title":"variable orientation","text":"<pre><code>data_format::proper_quaterniond ILLIXR::state_plus::orientation;\n</code></pre>"},{"location":"api/structILLIXR_1_1state__plus/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3d ILLIXR::state_plus::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1state__plus/#variable-velocity","title":"variable velocity","text":"<pre><code>Eigen::Vector3d ILLIXR::state_plus::velocity;\n</code></pre>"},{"location":"api/structILLIXR_1_1state__plus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1state__plus/#function-state_plus-13","title":"function state_plus [1/3]","text":"<pre><code>inline ILLIXR::state_plus::state_plus (\n    const data_format::proper_quaterniond &amp; pq,\n    const Eigen::Vector3d &amp; vel,\n    const Eigen::Vector3d &amp; pos\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1state__plus/#function-state_plus-23","title":"function state_plus [2/3]","text":"<pre><code>inline ILLIXR::state_plus::state_plus (\n    const Eigen::Quaterniond &amp; pq,\n    const Eigen::Vector3d &amp; vel,\n    const Eigen::Vector3d &amp; pos\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1state__plus/#function-state_plus-33","title":"function state_plus [3/3]","text":"<pre><code>ILLIXR::state_plus::state_plus () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/runge-kutta.hpp</code></p>"},{"location":"api/structILLIXR_1_1texture/","title":"Struct ILLIXR::texture","text":"<p>ClassList &gt; ILLIXR &gt; texture</p>"},{"location":"api/structILLIXR_1_1texture/#public-attributes","title":"Public Attributes","text":"Type Name VkImage image VmaAllocation image_memory VkImageView image_view"},{"location":"api/structILLIXR_1_1texture/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1texture/#variable-image","title":"variable image","text":"<pre><code>VkImage ILLIXR::texture::image;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture/#variable-image_memory","title":"variable image_memory","text":"<pre><code>VmaAllocation ILLIXR::texture::image_memory;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture/#variable-image_view","title":"variable image_view","text":"<pre><code>VkImageView ILLIXR::texture::image_view;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.hpp</code></p>"},{"location":"api/structILLIXR_1_1vertex/","title":"Struct ILLIXR::vertex","text":"<p>ClassList &gt; ILLIXR &gt; vertex</p>"},{"location":"api/structILLIXR_1_1vertex/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 pos glm::vec2 uv"},{"location":"api/structILLIXR_1_1vertex/#public-functions","title":"Public Functions","text":"Type Name bool operator== (const vertex &amp; other) const"},{"location":"api/structILLIXR_1_1vertex/#public-static-functions","title":"Public Static Functions","text":"Type Name std::array&lt; VkVertexInputAttributeDescription, 2 &gt; get_attribute_descriptions ()  VkVertexInputBindingDescription get_binding_description ()"},{"location":"api/structILLIXR_1_1vertex/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vertex/#variable-pos","title":"variable pos","text":"<pre><code>glm::vec3 ILLIXR::vertex::pos;\n</code></pre>"},{"location":"api/structILLIXR_1_1vertex/#variable-uv","title":"variable uv","text":"<pre><code>glm::vec2 ILLIXR::vertex::uv;\n</code></pre>"},{"location":"api/structILLIXR_1_1vertex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1vertex/#function-operator","title":"function operator==","text":"<pre><code>inline bool ILLIXR::vertex::operator== (\n    const vertex &amp; other\n) const\n</code></pre>"},{"location":"api/structILLIXR_1_1vertex/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structILLIXR_1_1vertex/#function-get_attribute_descriptions","title":"function get_attribute_descriptions","text":"<pre><code>static inline std::array&lt; VkVertexInputAttributeDescription, 2 &gt; ILLIXR::vertex::get_attribute_descriptions () \n</code></pre>"},{"location":"api/structILLIXR_1_1vertex/#function-get_binding_description","title":"function get_binding_description","text":"<pre><code>static inline VkVertexInputBindingDescription ILLIXR::vertex::get_binding_description () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.hpp</code></p>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/","title":"Struct ILLIXR::vulkan::buffer_pool","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; ILLIXR &gt; vulkan &gt; buffer_pool</p>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#public-types","title":"Public Types","text":"Type Name enum image_state"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; std::array&lt; vk_image, 2 &gt; &gt; depth_image_pool std::vector&lt; T &gt; image_data   = <code>{}</code> std::vector&lt; std::array&lt; vk_image, 2 &gt; &gt; image_pool std::mutex image_state_mutex   = <code>{}</code> std::vector&lt; image_state &gt; image_states   = <code>{}</code> image_index_t latest_decoded_image   = <code>-1</code>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#public-functions","title":"Public Functions","text":"Type Name buffer_pool (const std::vector&lt; std::array&lt; vk_image, 2 &gt; &gt; &amp; image_pool, const std::vector&lt; std::array&lt; vk_image, 2 &gt; &gt; &amp; depth_image_pool)  std::pair&lt; image_index_t, T &gt; post_processing_acquire_image (image_index_t last_image_index=-1)  void post_processing_release_image (image_index_t image_index)  image_index_t src_acquire_image ()  void src_release_image (image_index_t image_index, T &amp;&amp; data) Release the image after it has been decoded."},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#enum-image_state","title":"enum image_state","text":"<pre><code>enum ILLIXR::vulkan::buffer_pool::image_state {\n    FREE,\n    SRC_IN_FLIGHT,\n    AVAILABLE,\n    POST_PROCESSING_IN_FLIGHT\n};\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#variable-depth_image_pool","title":"variable depth_image_pool","text":"<pre><code>std::vector&lt;std::array&lt;vk_image, 2&gt; &gt; ILLIXR::vulkan::buffer_pool&lt; T &gt;::depth_image_pool;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#variable-image_data","title":"variable image_data","text":"<pre><code>std::vector&lt;T&gt; ILLIXR::vulkan::buffer_pool&lt; T &gt;::image_data;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#variable-image_pool","title":"variable image_pool","text":"<pre><code>std::vector&lt;std::array&lt;vk_image, 2&gt; &gt; ILLIXR::vulkan::buffer_pool&lt; T &gt;::image_pool;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#variable-image_state_mutex","title":"variable image_state_mutex","text":"<pre><code>std::mutex ILLIXR::vulkan::buffer_pool&lt; T &gt;::image_state_mutex;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#variable-image_states","title":"variable image_states","text":"<pre><code>std::vector&lt;image_state&gt; ILLIXR::vulkan::buffer_pool&lt; T &gt;::image_states;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#variable-latest_decoded_image","title":"variable latest_decoded_image","text":"<pre><code>image_index_t ILLIXR::vulkan::buffer_pool&lt; T &gt;::latest_decoded_image;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#function-buffer_pool","title":"function buffer_pool","text":"<pre><code>inline explicit ILLIXR::vulkan::buffer_pool::buffer_pool (\n    const std::vector&lt; std::array&lt; vk_image, 2 &gt; &gt; &amp; image_pool,\n    const std::vector&lt; std::array&lt; vk_image, 2 &gt; &gt; &amp; depth_image_pool\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#function-post_processing_acquire_image","title":"function post_processing_acquire_image","text":"<pre><code>inline std::pair&lt; image_index_t, T &gt; ILLIXR::vulkan::buffer_pool::post_processing_acquire_image (\n    image_index_t last_image_index=-1\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#function-post_processing_release_image","title":"function post_processing_release_image","text":"<pre><code>inline void ILLIXR::vulkan::buffer_pool::post_processing_release_image (\n    image_index_t image_index\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#function-src_acquire_image","title":"function src_acquire_image","text":"<pre><code>inline image_index_t ILLIXR::vulkan::buffer_pool::src_acquire_image () \n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1buffer__pool/#function-src_release_image","title":"function src_release_image","text":"<p>Release the image after it has been decoded. <pre><code>inline void ILLIXR::vulkan::buffer_pool::src_release_image (\n    image_index_t image_index,\n    T &amp;&amp; data\n) \n</code></pre></p> <p>It is the caller's responsibility to ensure that the image is in the DECODE_IN_FLIGHT state. Images must be released in order. If an image is released out of order, the previous images will be marked as free. </p> <p>Parameters:</p> <ul> <li><code>image_index</code> The index of the image to release. </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/vulkan_objects.hpp</code></p>"},{"location":"api/structILLIXR_1_1vulkan_1_1ffmpeg__utils_1_1ffmpeg__vk__frame/","title":"Struct ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; ffmpeg_utils &gt; ffmpeg_vk_frame</p>"},{"location":"api/structILLIXR_1_1vulkan_1_1ffmpeg__utils_1_1ffmpeg__vk__frame/#public-attributes","title":"Public Attributes","text":"Type Name AVFrame * frame   = <code>nullptr</code> AVVkFrame * vk_frame   = <code>nullptr</code>"},{"location":"api/structILLIXR_1_1vulkan_1_1ffmpeg__utils_1_1ffmpeg__vk__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1ffmpeg__utils_1_1ffmpeg__vk__frame/#variable-frame","title":"variable frame","text":"<pre><code>AVFrame* ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame::frame;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1ffmpeg__utils_1_1ffmpeg__vk__frame/#variable-vk_frame","title":"variable vk_frame","text":"<pre><code>AVVkFrame* ILLIXR::vulkan::ffmpeg_utils::ffmpeg_vk_frame::vk_frame;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/ffmpeg_utils.hpp</code></p>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/","title":"Struct ILLIXR::vulkan::queue","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; queue</p>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#public-types","title":"Public Types","text":"Type Name enum queue_type enum queue_type"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t family std::shared_ptr&lt; std::mutex &gt; mutex queue_type type VkQueue vk_queue"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#enum-queue_type-12","title":"enum queue_type [1/2]","text":"<pre><code>enum ILLIXR::vulkan::queue::queue_type {\n    GRAPHICS,\n    DEDICATED_TRANSFER,\n    PRESENT,\n    ENCODE,\n    DECODE,\n    COMPUTE,\n    GRAPHICS,\n    DEDICATED_TRANSFER,\n    PRESENT,\n    ENCODE,\n    DECODE,\n    COMPUTE\n};\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#enum-queue_type-12_1","title":"enum queue_type [1/2]","text":"<pre><code>enum ILLIXR::vulkan::queue::queue_type {\n    GRAPHICS,\n    DEDICATED_TRANSFER,\n    PRESENT,\n    ENCODE,\n    DECODE,\n    COMPUTE,\n    GRAPHICS,\n    DEDICATED_TRANSFER,\n    PRESENT,\n    ENCODE,\n    DECODE,\n    COMPUTE\n};\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#variable-family","title":"variable family","text":"<pre><code>uint32_t ILLIXR::vulkan::queue::family;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#variable-mutex","title":"variable mutex","text":"<pre><code>std::shared_ptr&lt; std::mutex &gt; ILLIXR::vulkan::queue::mutex;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#variable-type","title":"variable type","text":"<pre><code>queue_type ILLIXR::vulkan::queue::type;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue/#variable-vk_queue","title":"variable vk_queue","text":"<pre><code>VkQueue ILLIXR::vulkan::queue::vk_queue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/vulkan_utils.hpp</code></p>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/","title":"Struct ILLIXR::vulkan::queue_families","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; queue_families</p>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#public-attributes","title":"Public Attributes","text":"Type Name std::optional&lt; uint32_t &gt; compute_family std::optional&lt; uint32_t &gt; decode_family std::optional&lt; uint32_t &gt; dedicated_transfer std::optional&lt; uint32_t &gt; encode_family std::optional&lt; uint32_t &gt; graphics_family std::optional&lt; uint32_t &gt; present_family"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#public-functions","title":"Public Functions","text":"Type Name bool has_compression () const bool has_compression () const bool has_presentation () const bool has_presentation () const"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#variable-compute_family","title":"variable compute_family","text":"<pre><code>std::optional&lt; uint32_t &gt; ILLIXR::vulkan::queue_families::compute_family;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#variable-decode_family","title":"variable decode_family","text":"<pre><code>std::optional&lt; uint32_t &gt; ILLIXR::vulkan::queue_families::decode_family;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#variable-dedicated_transfer","title":"variable dedicated_transfer","text":"<pre><code>std::optional&lt; uint32_t &gt; ILLIXR::vulkan::queue_families::dedicated_transfer;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#variable-encode_family","title":"variable encode_family","text":"<pre><code>std::optional&lt; uint32_t &gt; ILLIXR::vulkan::queue_families::encode_family;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#variable-graphics_family","title":"variable graphics_family","text":"<pre><code>std::optional&lt; uint32_t &gt; ILLIXR::vulkan::queue_families::graphics_family;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#variable-present_family","title":"variable present_family","text":"<pre><code>std::optional&lt; uint32_t &gt; ILLIXR::vulkan::queue_families::present_family;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#function-has_compression-12","title":"function has_compression [1/2]","text":"<pre><code>inline bool ILLIXR::vulkan::queue_families::has_compression () const\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#function-has_compression-12_1","title":"function has_compression [1/2]","text":"<pre><code>inline bool ILLIXR::vulkan::queue_families::has_compression () const\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#function-has_presentation-12","title":"function has_presentation [1/2]","text":"<pre><code>inline bool ILLIXR::vulkan::queue_families::has_presentation () const\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1queue__families/#function-has_presentation-12_1","title":"function has_presentation [1/2]","text":"<pre><code>inline bool ILLIXR::vulkan::queue_families::has_presentation () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/vulkan_utils.hpp</code></p>"},{"location":"api/structILLIXR_1_1vulkan_1_1swapchain__details/","title":"Struct ILLIXR::vulkan::swapchain_details","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; swapchain_details</p>"},{"location":"api/structILLIXR_1_1vulkan_1_1swapchain__details/#public-attributes","title":"Public Attributes","text":"Type Name VkSurfaceCapabilitiesKHR capabilities   = <code>{}</code> std::vector&lt; VkSurfaceFormatKHR &gt; formats std::vector&lt; VkPresentModeKHR &gt; present_modes"},{"location":"api/structILLIXR_1_1vulkan_1_1swapchain__details/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1swapchain__details/#variable-capabilities","title":"variable capabilities","text":"<pre><code>VkSurfaceCapabilitiesKHR ILLIXR::vulkan::swapchain_details::capabilities;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1swapchain__details/#variable-formats","title":"variable formats","text":"<pre><code>std::vector&lt; VkSurfaceFormatKHR &gt; ILLIXR::vulkan::swapchain_details::formats;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1swapchain__details/#variable-present_modes","title":"variable present_modes","text":"<pre><code>std::vector&lt; VkPresentModeKHR &gt; ILLIXR::vulkan::swapchain_details::present_modes;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/vulkan_utils.hpp</code></p>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/","title":"Struct ILLIXR::vulkan::vk_image","text":"<p>ClassList &gt; ILLIXR &gt; vulkan &gt; vk_image</p>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#public-attributes","title":"Public Attributes","text":"Type Name VmaAllocation allocation VmaAllocationInfo allocation_info VkExternalMemoryImageCreateInfo export_image_info int fd VkImage image VkImageCreateInfo image_info VkImageView image_view"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#variable-allocation","title":"variable allocation","text":"<pre><code>VmaAllocation ILLIXR::vulkan::vk_image::allocation;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#variable-allocation_info","title":"variable allocation_info","text":"<pre><code>VmaAllocationInfo ILLIXR::vulkan::vk_image::allocation_info;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#variable-export_image_info","title":"variable export_image_info","text":"<pre><code>VkExternalMemoryImageCreateInfo ILLIXR::vulkan::vk_image::export_image_info;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#variable-fd","title":"variable fd","text":"<pre><code>int ILLIXR::vulkan::vk_image::fd;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#variable-image","title":"variable image","text":"<pre><code>VkImage ILLIXR::vulkan::vk_image::image;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#variable-image_info","title":"variable image_info","text":"<pre><code>VkImageCreateInfo ILLIXR::vulkan::vk_image::image_info;\n</code></pre>"},{"location":"api/structILLIXR_1_1vulkan_1_1vk__image/#variable-image_view","title":"variable image_view","text":"<pre><code>VkImageView ILLIXR::vulkan::vk_image::image_view;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/vulkan_objects.hpp</code></p>"},{"location":"api/structYAML_1_1convert_3_01ILLIXR_1_1Dependency_01_4/","title":"Struct YAML::convert&lt; ILLIXR::Dependency &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; YAML &gt; convert&lt; ILLIXR::Dependency &gt;</p>"},{"location":"api/structYAML_1_1convert_3_01ILLIXR_1_1Dependency_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name bool decode (const Node &amp; node, ILLIXR::Dependency &amp; rhs)  Node encode (const ILLIXR::Dependency &amp; rhs)"},{"location":"api/structYAML_1_1convert_3_01ILLIXR_1_1Dependency_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structYAML_1_1convert_3_01ILLIXR_1_1Dependency_01_4/#function-decode","title":"function decode","text":"<pre><code>static inline bool YAML::convert&lt; ILLIXR::Dependency &gt;::decode (\n    const Node &amp; node,\n    ILLIXR::Dependency &amp; rhs\n) \n</code></pre>"},{"location":"api/structYAML_1_1convert_3_01ILLIXR_1_1Dependency_01_4/#function-encode","title":"function encode","text":"<pre><code>static inline Node YAML::convert&lt; ILLIXR::Dependency &gt;::encode (\n    const ILLIXR::Dependency &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/plugin.cpp</code></p>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/","title":"Struct cxxopts::HelpGroupDetails","text":"<p>ClassList &gt; cxxopts &gt; HelpGroupDetails</p>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#public-attributes","title":"Public Attributes","text":"Type Name std::string description   = <code>{}</code> std::string name   = <code>{}</code> std::vector&lt; HelpOptionDetails &gt; options   = <code>{}</code>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1HelpGroupDetails/#variable-description","title":"variable description","text":"<pre><code>std::string cxxopts::HelpGroupDetails::description;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#variable-name","title":"variable name","text":"<pre><code>std::string cxxopts::HelpGroupDetails::name;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#variable-options","title":"variable options","text":"<pre><code>std::vector&lt; HelpOptionDetails &gt; cxxopts::HelpGroupDetails::options;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/","title":"Struct cxxopts::HelpOptionDetails","text":"<p>ClassList &gt; cxxopts &gt; HelpOptionDetails</p>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#public-attributes","title":"Public Attributes","text":"Type Name std::string arg_help std::string default_value String desc bool has_default bool has_implicit std::string implicit_value bool is_boolean bool is_container OptionNames l std::string s"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-arg_help","title":"variable arg_help","text":"<pre><code>std::string cxxopts::HelpOptionDetails::arg_help;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-default_value","title":"variable default_value","text":"<pre><code>std::string cxxopts::HelpOptionDetails::default_value;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-desc","title":"variable desc","text":"<pre><code>String cxxopts::HelpOptionDetails::desc;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-has_default","title":"variable has_default","text":"<pre><code>bool cxxopts::HelpOptionDetails::has_default;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-has_implicit","title":"variable has_implicit","text":"<pre><code>bool cxxopts::HelpOptionDetails::has_implicit;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-implicit_value","title":"variable implicit_value","text":"<pre><code>std::string cxxopts::HelpOptionDetails::implicit_value;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-is_boolean","title":"variable is_boolean","text":"<pre><code>bool cxxopts::HelpOptionDetails::is_boolean;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-is_container","title":"variable is_container","text":"<pre><code>bool cxxopts::HelpOptionDetails::is_container;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-l","title":"variable l","text":"<pre><code>OptionNames cxxopts::HelpOptionDetails::l;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-s","title":"variable s","text":"<pre><code>std::string cxxopts::HelpOptionDetails::s;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1Option/","title":"Struct cxxopts::Option","text":"<p>ClassList &gt; cxxopts &gt; Option</p>"},{"location":"api/structcxxopts_1_1Option/#public-attributes","title":"Public Attributes","text":"Type Name std::string arg_help_ std::string desc_ std::string opts_ std::shared_ptr&lt; const Value &gt; value_"},{"location":"api/structcxxopts_1_1Option/#public-functions","title":"Public Functions","text":"Type Name Option (std::string opts, std::string desc, std::shared_ptr&lt; const Value &gt; value=::cxxopts::value&lt; bool &gt;(), std::string arg_help=\"\")  Option (std::string opts, std::string desc, std::shared_ptr&lt; const Value &gt; value=::cxxopts::value&lt; bool &gt;(), std::string arg_help=\"\")"},{"location":"api/structcxxopts_1_1Option/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1Option/#variable-arg_help_","title":"variable arg_help_","text":"<pre><code>std::string cxxopts::Option::arg_help_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#variable-desc_","title":"variable desc_","text":"<pre><code>std::string cxxopts::Option::desc_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#variable-opts_","title":"variable opts_","text":"<pre><code>std::string cxxopts::Option::opts_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#variable-value_","title":"variable value_","text":"<pre><code>std::shared_ptr&lt; const Value &gt; cxxopts::Option::value_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structcxxopts_1_1Option/#function-option-12","title":"function Option [1/2]","text":"<pre><code>inline cxxopts::Option::Option (\n    std::string opts,\n    std::string desc,\n    std::shared_ptr&lt; const Value &gt; value=::cxxopts::value&lt; bool &gt;(),\n    std::string arg_help=\"\"\n) \n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#function-option-12_1","title":"function Option [1/2]","text":"<pre><code>inline cxxopts::Option::Option (\n    std::string opts,\n    std::string desc,\n    std::shared_ptr&lt; const Value &gt; value=::cxxopts::value&lt; bool &gt;(),\n    std::string arg_help=\"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck/","title":"Struct cxxopts::values::detail::SignedCheck","text":"<p>template &lt;typename T, bool B&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; detail &gt; SignedCheck</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/","title":"Struct cxxopts::values::detail::SignedCheck&lt; T, false &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; detail &gt; SignedCheck&lt; T, false &gt;</p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/#public-functions","title":"Public Functions","text":"Type Name void operator() (bool, U, const std::string &amp;) const void operator() (bool, U, const std::string &amp;) const"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/#function-operator-12","title":"function operator() [1/2]","text":"<pre><code>template&lt;typename U&gt;\ninline void cxxopts::values::detail::SignedCheck&lt; T, false &gt;::operator() (\n    bool,\n    U,\n    const std::string &amp;\n) const\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/#function-operator-12_1","title":"function operator() [1/2]","text":"<pre><code>template&lt;typename U&gt;\ninline void cxxopts::values::detail::SignedCheck&lt; T, false &gt;::operator() (\n    bool,\n    U,\n    const std::string &amp;\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/","title":"Struct cxxopts::values::detail::SignedCheck&lt; T, true &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; detail &gt; SignedCheck&lt; T, true &gt;</p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/#public-functions","title":"Public Functions","text":"Type Name void operator() (bool negative, U u, const std::string &amp; text)  void operator() (bool negative, U u, const std::string &amp; text)"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/#function-operator-12","title":"function operator() [1/2]","text":"<pre><code>template&lt;typename U&gt;\ninline void cxxopts::values::detail::SignedCheck&lt; T, true &gt;::operator() (\n    bool negative,\n    U u,\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/#function-operator-12_1","title":"function operator() [1/2]","text":"<pre><code>template&lt;typename U&gt;\ninline void cxxopts::values::detail::SignedCheck&lt; T, true &gt;::operator() (\n    bool negative,\n    U u,\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/","title":"Struct cxxopts::values::parser_tool::ArguDesc","text":"<p>ClassList &gt; cxxopts &gt; values &gt; parser_tool &gt; ArguDesc</p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#public-attributes","title":"Public Attributes","text":"Type Name std::string arg_name   = <code>\"\"</code> bool grouping   = <code>false</code> bool set_value   = <code>false</code> std::string value   = <code>\"\"</code>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-arg_name","title":"variable arg_name","text":"<pre><code>std::string cxxopts::values::parser_tool::ArguDesc::arg_name;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-grouping","title":"variable grouping","text":"<pre><code>bool cxxopts::values::parser_tool::ArguDesc::grouping;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-set_value","title":"variable set_value","text":"<pre><code>bool cxxopts::values::parser_tool::ArguDesc::set_value;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-value","title":"variable value","text":"<pre><code>std::string cxxopts::values::parser_tool::ArguDesc::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/","title":"Struct cxxopts::values::parser_tool::IntegerDesc","text":"<p>ClassList &gt; cxxopts &gt; values &gt; parser_tool &gt; IntegerDesc</p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#public-attributes","title":"Public Attributes","text":"Type Name std::string base   = <code>\"\"</code> std::string negative   = <code>\"\"</code> std::string value   = <code>\"\"</code>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#variable-base","title":"variable base","text":"<pre><code>std::string cxxopts::values::parser_tool::IntegerDesc::base;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#variable-negative","title":"variable negative","text":"<pre><code>std::string cxxopts::values::parser_tool::IntegerDesc::negative;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#variable-value","title":"variable value","text":"<pre><code>std::string cxxopts::values::parser_tool::IntegerDesc::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container/","title":"Struct cxxopts::values::type_is_container","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; type_is_container</p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr bool value   = <code>false</code>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1type__is__container/#variable-value","title":"variable value","text":"<pre><code>static constexpr bool cxxopts::values::type_is_container&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/","title":"Struct cxxopts::values::type_is_container&lt; std::vector&lt; T &gt; &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; type_is_container&lt; std::vector&lt; T &gt; &gt;</p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr bool value   = <code>true</code>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/#variable-value","title":"variable value","text":"<pre><code>static constexpr bool cxxopts::values::type_is_container&lt; std::vector&lt; T &gt; &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/cxxopts.hpp</code></p>"},{"location":"api/structmodel__push__constant/","title":"Struct model_push_constant","text":"<p>ClassList &gt; model_push_constant</p>"},{"location":"api/structmodel__push__constant/#public-attributes","title":"Public Attributes","text":"Type Name int texture_index"},{"location":"api/structmodel__push__constant/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structmodel__push__constant/#variable-texture_index","title":"variable texture_index","text":"<pre><code>int model_push_constant::texture_index;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.cpp</code></p>"},{"location":"api/structstd_1_1hash_3_01vertex_01_4/","title":"Struct std::hash&lt; vertex &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; std &gt; hash&lt; vertex &gt;</p>"},{"location":"api/structstd_1_1hash_3_01vertex_01_4/#public-functions","title":"Public Functions","text":"Type Name size_t operator() (vertex const &amp; vertex) const"},{"location":"api/structstd_1_1hash_3_01vertex_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01vertex_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline size_t std::hash&lt; vertex &gt;::operator() (\n    vertex const &amp; vertex\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.cpp</code></p>"},{"location":"api/structuniform__buffer__object/","title":"Struct uniform_buffer_object","text":"<p>ClassList &gt; uniform_buffer_object</p>"},{"location":"api/structuniform__buffer__object/#public-attributes","title":"Public Attributes","text":"Type Name glm::mat4 model_view glm::mat4 proj glm::mat4 timewarp_end_transform glm::mat4 timewarp_start_transform"},{"location":"api/structuniform__buffer__object/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structuniform__buffer__object/#variable-model_view","title":"variable model_view","text":"<pre><code>glm::mat4 uniform_buffer_object::model_view;\n</code></pre>"},{"location":"api/structuniform__buffer__object/#variable-proj","title":"variable proj","text":"<pre><code>glm::mat4 uniform_buffer_object::proj;\n</code></pre>"},{"location":"api/structuniform__buffer__object/#variable-timewarp_end_transform","title":"variable timewarp_end_transform","text":"<pre><code>glm::mat4 uniform_buffer_object::timewarp_end_transform[2];\n</code></pre>"},{"location":"api/structuniform__buffer__object/#variable-timewarp_start_transform","title":"variable timewarp_start_transform","text":"<pre><code>glm::mat4 uniform_buffer_object::timewarp_start_transform[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/timewarp_vk.cpp</code></p>"},{"location":"api/structvertex/","title":"Struct vertex","text":"<p>ClassList &gt; vertex</p>"},{"location":"api/structvertex/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 pos glm::vec2 uv0 glm::vec2 uv1 glm::vec2 uv2"},{"location":"api/structvertex/#public-static-functions","title":"Public Static Functions","text":"Type Name std::array&lt; VkVertexInputAttributeDescription, 4 &gt; get_attribute_descriptions ()  VkVertexInputBindingDescription get_binding_description ()"},{"location":"api/structvertex/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structvertex/#variable-pos","title":"variable pos","text":"<pre><code>glm::vec3 vertex::pos;\n</code></pre>"},{"location":"api/structvertex/#variable-uv0","title":"variable uv0","text":"<pre><code>glm::vec2 vertex::uv0;\n</code></pre>"},{"location":"api/structvertex/#variable-uv1","title":"variable uv1","text":"<pre><code>glm::vec2 vertex::uv1;\n</code></pre>"},{"location":"api/structvertex/#variable-uv2","title":"variable uv2","text":"<pre><code>glm::vec2 vertex::uv2;\n</code></pre>"},{"location":"api/structvertex/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structvertex/#function-get_attribute_descriptions","title":"function get_attribute_descriptions","text":"<pre><code>static inline std::array&lt; VkVertexInputAttributeDescription, 4 &gt; vertex::get_attribute_descriptions () \n</code></pre>"},{"location":"api/structvertex/#function-get_binding_description","title":"function get_binding_description","text":"<pre><code>static inline VkVertexInputBindingDescription vertex::get_binding_description () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/timewarp_vk.cpp</code></p>"},{"location":"api/switchboard_8hpp/","title":"File switchboard.hpp","text":"<p>FileList &gt; illixr &gt; switchboard.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"concurrentqueue/blockingconcurrentqueue.hpp\"</code></li> <li><code>#include \"managed_thread.hpp\"</code></li> <li><code>#include \"network/network_backend.hpp\"</code></li> <li><code>#include \"network/topic_config.hpp\"</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Geometry&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;boost/archive/binary_iarchive.hpp&gt;</code></li> <li><code>#include &lt;boost/archive/binary_oarchive.hpp&gt;</code></li> <li><code>#include &lt;boost/iostreams/device/back_inserter.hpp&gt;</code></li> <li><code>#include &lt;boost/iostreams/stream.hpp&gt;</code></li> <li><code>#include &lt;boost/serialization/shared_ptr.hpp&gt;</code></li> </ul>"},{"location":"api/switchboard_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/switchboard_8hpp/#classes","title":"Classes","text":"Type Name class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class buffered_reader &lt;typename Specific_event&gt; class event Virtual class for event types. class event_wrapper &lt;typename Underlying_type&gt;Helper class for making event types. class network_writer &lt;typename Serializable_event&gt; class reader &lt;typename Specific_event&gt;A handle which can read the latest event on a topic. class writer &lt;typename Specific_event&gt;A handle which can publish events to a topic."},{"location":"api/switchboard_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::nanoseconds thread_cpu_time ()"},{"location":"api/switchboard_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/switchboard_8hpp/#function-thread_cpu_time","title":"function thread_cpu_time","text":"<pre><code>static std::chrono::nanoseconds thread_cpu_time () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/switchboard.hpp</code></p>"},{"location":"api/switchboard_8hpp_source/","title":"File switchboard.hpp","text":"<p>File List &gt; illixr &gt; switchboard.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"concurrentqueue/blockingconcurrentqueue.hpp\"\n#include \"managed_thread.hpp\"\n#include \"network/network_backend.hpp\"\n#include \"network/topic_config.hpp\"\n#include \"phonebook.hpp\"\n#include \"record_logger.hpp\"\n\n#ifdef Success\n    #undef Success // For 'Success' conflict\n#endif\n\n#include &lt;eigen3/Eigen/Core&gt;\n#include &lt;eigen3/Eigen/Geometry&gt;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;mutex&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;utility&gt;\n\n#ifndef NDEBUG\n    #include &lt;spdlog/spdlog.h&gt;\n#endif\n\n#if __has_include(\"cpu_timer.hpp\")\n    #include \"cpu_timer.hpp\"\n#else\nstatic std::chrono::nanoseconds thread_cpu_time() {\n    return {};\n}\n#endif\n\n#include &lt;boost/archive/binary_iarchive.hpp&gt;\n#include &lt;boost/archive/binary_oarchive.hpp&gt;\n#include &lt;boost/iostreams/device/back_inserter.hpp&gt;\n#include &lt;boost/iostreams/stream.hpp&gt;\n#include &lt;boost/serialization/shared_ptr.hpp&gt;\n\nnamespace ILLIXR {\n\nusing plugin_id_t = std::size_t;\n\nconst std::vector&lt;std::string&gt; ignore_vars = {\"plugins\"};\nconst std::vector&lt;std::string&gt; ENV_VARS    = {\n    \"ILLIXR_ENABLE_PRE_SLEEP\",\n    \"ILLIXR_LOG_LEVEL\",\n    \"ILLIXR_RUN_DURATION\",\n};\nconst record_header _switchboard_callback_header{\n    \"switchboard_callback\",\n    {\n        {\"plugin_id\", typeid(plugin_id_t)},\n        {\"topic_name\", typeid(std::string)},\n        {\"iteration_no\", typeid(std::size_t)},\n        {\"cpu_time_start\", typeid(std::chrono::nanoseconds)},\n        {\"cpu_time_stop\", typeid(std::chrono::nanoseconds)},\n        {\"wall_time_start\", typeid(std::chrono::high_resolution_clock::time_point)},\n        {\"wall_time_stop\", typeid(std::chrono::high_resolution_clock::time_point)},\n    }};\n\nconst record_header _switchboard_topic_stop_header{\"switchboard_topic_stop\",\n                                                   {\n                                                       {\"plugin_id\", typeid(plugin_id_t)},\n                                                       {\"topic_name\", typeid(std::string)},\n                                                       {\"enqueued\", typeid(std::size_t)},\n                                                       {\"dequeued\", typeid(std::size_t)},\n                                                       {\"idle_cycles\", typeid(std::size_t)},\n                                                   }};\n\nclass switchboard : public phonebook::service {\npublic:\n    template&lt;typename Specific_event&gt;\n    using ptr = std::shared_ptr&lt;Specific_event&gt;;\n\n    class event {\n    public:\n        template&lt;typename Archive&gt;\n        [[maybe_unused]] void serialize(Archive&amp; ar, const unsigned int version) {\n            (void) ar;\n            (void) version;\n        }\n\n        virtual ~event() = default;\n    };\n\n    template&lt;typename Underlying_type&gt;\n    class event_wrapper : public event {\n    public:\n        event_wrapper() = default;\n\n        explicit event_wrapper(Underlying_type underlying_data)\n            : underlying_data_{std::move(underlying_data)} { }\n\n        explicit operator Underlying_type() const {\n            return underlying_data_;\n        }\n\n        Underlying_type&amp; operator*() {\n            return underlying_data_;\n        }\n\n        const Underlying_type&amp; operator*() const {\n            return underlying_data_;\n        }\n\n    private:\n        Underlying_type underlying_data_;\n    };\n\nprivate:\n    class topic_subscription {\n    public:\n        topic_subscription(const std::string&amp; topic_name, plugin_id_t plugin_id,\n                           std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt; callback,\n                           const std::shared_ptr&lt;record_logger&gt;&amp;                record_logger_)\n            : topic_name_{topic_name}\n            , plugin_id_{plugin_id}\n            , callback_{std::move(callback)}\n            , record_logger_{record_logger_}\n            , cb_log_{record_logger_}\n            , thread_{[this] {\n                          this-&gt;thread_body();\n                      },\n                      [] {\n                          thread_on_start();\n                      },\n                      [this] {\n                          this-&gt;thread_on_stop();\n                      }} {\n            thread_.start();\n        }\n\n        void enqueue(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            if (thread_.get_state() == managed_thread::state::running) {\n                [[maybe_unused]] bool ret = queue_.enqueue(std::move(this_event));\n                assert(ret);\n                enqueued_++;\n            }\n        }\n\n    private:\n        static void thread_on_start() {\n#ifndef NDEBUG\n            // spdlog::get(\"illixr\")-&gt;set_pattern(\"[%Y-%m-%d %H:%M:%S.%e] [%n] [%^%l%$] [switchboard] thread %t %v\");\n            // spdlog::get(\"illixr\")-&gt;debug(\"start\");\n            // spdlog::get(\"illixr\")-&gt;set_pattern(\"%+\");\n#endif\n        }\n\n        void thread_body() {\n            // Try to pull event off of queue\n            ptr&lt;const event&gt; this_event;\n            std::int64_t     timeout_usecs = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(queue_timeout_).count();\n            // Note the use of timed blocking wait\n            if (queue_.wait_dequeue_timed(token_, this_event, timeout_usecs)) {\n                // Process event\n                // Also, record and log the time\n                dequeued_++;\n                auto cb_start_cpu_time  = thread_cpu_time();\n                auto cb_start_wall_time = std::chrono::high_resolution_clock::now();\n                // std::cerr &lt;&lt; \"deq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get_ro())) &lt;&lt; \" \" &lt;&lt;\n                // this_event.use_count() &lt;&lt; \" v\\n\";\n                callback_(std::move(this_event), dequeued_);\n                if (cb_log_) {\n                    cb_log_.log(record{_switchboard_callback_header,\n                                       {\n                                           {plugin_id_},\n                                           {topic_name_},\n                                           {dequeued_},\n                                           {cb_start_cpu_time},\n                                           {thread_cpu_time()},\n                                           {cb_start_wall_time},\n                                           {std::chrono::high_resolution_clock::now()},\n                                       }});\n                }\n            } else {\n                // Nothing to do.\n                idle_cycles_++;\n            }\n        }\n\n        void thread_on_stop() {\n            // Drain queue\n            std::size_t unprocessed = enqueued_ - dequeued_;\n            {\n                ptr&lt;const event&gt; this_event;\n                for (std::size_t i = 0; i &lt; unprocessed; ++i) {\n                    [[maybe_unused]] bool ret = queue_.try_dequeue(token_, this_event);\n                    assert(ret);\n                    // std::cerr &lt;&lt; \"deq (stopping) \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get_ro())) &lt;&lt; \" \"\n                    // &lt;&lt; this_event.use_count() &lt;&lt; \" v\\n\";\n                    this_event.reset();\n                }\n            }\n\n            // Log stats\n            if (record_logger_) {\n                record_logger_-&gt;log(record{_switchboard_topic_stop_header,\n                                           {\n                                               {plugin_id_},\n                                               {topic_name_},\n                                               {dequeued_},\n                                               {unprocessed},\n                                               {idle_cycles_},\n                                           }});\n            }\n        }\n\n        const std::string&amp;                                    topic_name_;\n        plugin_id_t                                           plugin_id_;\n        std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt;  callback_;\n        const std::shared_ptr&lt;record_logger&gt;                  record_logger_;\n        record_coalescer                                      cb_log_;\n        moodycamel::BlockingConcurrentQueue&lt;ptr&lt;const event&gt;&gt; queue_{8 /*max size estimate*/};\n        moodycamel::ConsumerToken                             token_{queue_};\n        static constexpr std::chrono::milliseconds            queue_timeout_{100};\n        std::size_t                                           enqueued_{0};\n        std::size_t                                           dequeued_{0};\n        std::size_t                                           idle_cycles_{0};\n\n        // This needs to be last,\n        // so it is destructed before the data it uses.\n        managed_thread thread_;\n    };\n\n    class topic_buffer {\n    public:\n        topic_buffer() {\n#ifndef NDEBUG\n            spdlog::get(\"illixr\")-&gt;info(\"[switchboard] topic buffer created\");\n#endif\n        }\n\n        void enqueue(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            queue_size_++;\n            [[maybe_unused]] bool ret = queue_.enqueue(std::move(this_event));\n            assert(ret);\n        }\n\n        [[nodiscard]] size_t size() const {\n            return queue_size_;\n        }\n\n        ptr&lt;const event&gt; dequeue() {\n            ptr&lt;const event&gt; obj;\n            queue_size_--;\n            queue_.wait_dequeue(token_, obj);\n            return obj;\n        }\n\n    private:\n        moodycamel::BlockingConcurrentQueue&lt;ptr&lt;const event&gt;&gt; queue_{8 /*max size estimate*/};\n        moodycamel::ConsumerToken                             token_{queue_};\n        std::atomic&lt;size_t&gt;                                   queue_size_{0};\n    };\n\n    class topic {\n    public:\n        topic(std::string name, const std::type_info&amp; ty, std::shared_ptr&lt;record_logger&gt; record_logger_)\n            : name_{std::move(name)}\n            , type_info_{ty}\n            , record_logger_{std::move(record_logger_)}\n            , latest_index_{0} { }\n\n        const std::string&amp; name() {\n            return name_;\n        }\n\n        const std::type_info&amp; ty() {\n            return type_info_;\n        }\n\n        [[nodiscard]] ptr&lt;const event&gt; get() const {\n            size_t           idx        = latest_index_.load() % latest_buffer_size_;\n            ptr&lt;const event&gt; this_event = latest_buffer_[idx];\n            // if (this_event) {\n            //  std::cerr &lt;&lt; \"get \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get())) &lt;&lt; \" \" &lt;&lt;\n            // this_event.use_count() &lt;&lt; \"v \\n\";\n            // }\n            return this_event;\n        }\n\n        void put(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            assert(this_event != nullptr);\n            assert(this_event.unique() ||\n                   this_event.use_count() &lt;= 2); \n\n            /* The pointer that this gets exchanged with needs to get dropped. */\n            size_t index          = (latest_index_.load() + 1) % latest_buffer_size_;\n            latest_buffer_[index] = this_event;\n            latest_index_++;\n\n            // Read/write on subscriptions_.\n            // Must acquire shared state on subscriptions_lock_\n            std::unique_lock lock{subscriptions_lock_};\n            for (topic_subscription&amp; ts : subscriptions_) {\n                // std::cerr &lt;&lt; \"enq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt;\n                // this_event-&gt;use_count() &lt;&lt; \" ^\\n\";\n                ptr&lt;const event&gt; event_ptr_copy{this_event};\n                ts.enqueue(std::move(event_ptr_copy));\n            }\n\n            for (topic_buffer&amp; ts : buffers_) {\n                // std::cerr &lt;&lt; \"enq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt;\n                // this_event-&gt;use_count() &lt;&lt; \" ^\\n\";\n                ptr&lt;const event&gt; event_ptr_copy{this_event};\n                ts.enqueue(std::move(event_ptr_copy));\n            }\n            // std::cerr &lt;&lt; \"put done \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt;\n            // this_event-&gt;use_count() &lt;&lt; \" (= 1 + len(sub)) \\n\";\n        }\n\n        [[maybe_unused]] void deserialize_and_put(std::vector&lt;char&gt;&amp; buffer, network::topic_config&amp; config) {\n            if (config.serialization_method == network::topic_config::SerializationMethod::BOOST) {\n                // TODO: Need to differentiate and support protobuf deserialization\n                boost::iostreams::stream&lt;boost::iostreams::array_source&gt; stream{buffer.data(), buffer.size()};\n                boost::archive::binary_iarchive                          ia{stream};\n                ptr&lt;event&gt;                                               this_event;\n                ia &gt;&gt; this_event;\n                put(std::move(this_event));\n            } else {\n                ptr&lt;event&gt; message = std::make_shared&lt;event_wrapper&lt;std::string&gt;&gt;((std::string(buffer.begin(), buffer.end())));\n                put(std::move(message));\n            }\n        }\n\n        void schedule(plugin_id_t plugin_id, const std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt;&amp; callback) {\n            // Write on subscriptions_.\n            // Must acquire unique state on subscriptions_lock_\n            const std::unique_lock lock{subscriptions_lock_};\n            subscriptions_.emplace_back(name_, plugin_id, callback, record_logger_);\n        }\n\n        topic_buffer&amp; get_buffer() {\n            const std::unique_lock lock{subscriptions_lock_};\n            buffers_.emplace_back();\n            return buffers_.back();\n        }\n\n        void stop() {\n            // Write on subscriptions_.\n            // Must acquire unique state on subscriptions_lock_\n            const std::unique_lock lock{subscriptions_lock_};\n            subscriptions_.clear();\n        }\n\n    private:\n        static constexpr std::size_t latest_buffer_size_ = 256;\n\n        const std::string                                 name_;\n        const std::type_info&amp;                             type_info_;\n        const std::shared_ptr&lt;record_logger&gt;              record_logger_;\n        std::atomic&lt;size_t&gt;                               latest_index_;\n        std::array&lt;ptr&lt;const event&gt;, latest_buffer_size_&gt; latest_buffer_;\n        std::list&lt;topic_subscription&gt;                     subscriptions_;\n        std::list&lt;topic_buffer&gt;                           buffers_;\n        std::shared_mutex                                 subscriptions_lock_;\n    };\n\npublic:\n    template&lt;typename Specific_event&gt;\n    class reader {\n    public:\n        explicit reader(topic&amp; topic)\n            : topic_{topic} {\n#ifndef NDEBUG\n            if (typeid(Specific_event) != topic_.ty()) {\n                spdlog::get(\"illixr\")-&gt;error(\"[switchboard] topic '{}' holds type {}, but caller used type {}\", topic_.name(),\n                                             topic_.ty().name(), typeid(Specific_event).name());\n                abort();\n            }\n#endif\n        }\n\n        ptr&lt;const Specific_event&gt; get_ro_nullable() const noexcept {\n            ptr&lt;const event&gt;          this_event          = topic_.get();\n            ptr&lt;const Specific_event&gt; this_specific_event = std::dynamic_pointer_cast&lt;const Specific_event&gt;(this_event);\n\n            if (this_event != nullptr) {\n                assert(this_specific_event /* Otherwise, dynamic cast failed; dynamic type information could be wrong*/);\n                return this_specific_event;\n            } else {\n                return ptr&lt;const Specific_event&gt;{nullptr};\n            }\n        }\n\n        ptr&lt;const Specific_event&gt; get_ro() const {\n            ptr&lt;const Specific_event&gt; this_specific_event = get_ro_nullable();\n            if (this_specific_event != nullptr) {\n                return this_specific_event;\n            } else {\n                throw std::runtime_error(\"No event on topic\");\n            }\n        }\n\n        [[maybe_unused]] ptr&lt;Specific_event&gt; get_rw() const {\n            /*\n              This method is currently not more efficient than calling get_ro() and making a copy,\n              but in the future it could be.\n             */\n            ptr&lt;const Specific_event&gt; this_specific_event = get_ro();\n            return std::make_shared&lt;Specific_event&gt;(*this_specific_event);\n        }\n\n    private:\n        topic&amp; topic_;\n    };\n\n    template&lt;typename Specific_event&gt;\n    class buffered_reader {\n    public:\n        explicit buffered_reader(topic&amp; topic)\n            : topic_{topic}\n            , topic_buffer_{topic_.get_buffer()} { }\n\n        [[nodiscard]] size_t size() const {\n            return topic_buffer_.size();\n        }\n\n        virtual ptr&lt;const Specific_event&gt; dequeue() {\n            // CPU_TIMER_TIME_EVENT_INFO(true, false, \"callback\", cpu_timer::make_type_eraser&lt;FrameInfo&gt;(\"\", topic_.name(),\n            // serial_no_));\n            serial_no_++;\n            ptr&lt;const event&gt;          this_event          = topic_buffer_.dequeue();\n            ptr&lt;const Specific_event&gt; this_specific_event = std::dynamic_pointer_cast&lt;const Specific_event&gt;(this_event);\n            return this_specific_event;\n        }\n\n    private:\n        topic&amp;        topic_;\n        size_t        serial_no_ = 0;\n        topic_buffer&amp; topic_buffer_;\n    };\n\n    template&lt;typename Specific_event&gt;\n    class writer {\n    public:\n        explicit writer(topic&amp; topic)\n            : topic_{topic} { }\n\n        template&lt;class... Args&gt;\n        ptr&lt;Specific_event&gt; allocate(Args&amp;&amp;... args) {\n            return std::make_shared&lt;Specific_event&gt;(std::forward&lt;Args&gt;(args)...);\n        }\n\n        virtual void put(ptr&lt;Specific_event&gt;&amp;&amp; this_specific_event) {\n            assert(typeid(Specific_event) == topic_.ty());\n            assert(this_specific_event != nullptr);\n            assert(this_specific_event.unique());\n            ptr&lt;const event&gt; this_event =\n                std::const_pointer_cast&lt;const event&gt;(std::static_pointer_cast&lt;event&gt;(std::move(this_specific_event)));\n            assert(this_event.unique() ||\n                   this_event.use_count() &lt;= 2); \n            topic_.put(std::move(this_event));\n        }\n\n    protected:\n        // Reference to the underlying topic\n        topic&amp; topic_;\n    };\n\n    template&lt;typename Serializable_event&gt;\n    class network_writer : public writer&lt;Serializable_event&gt; {\n    public:\n        explicit network_writer(topic&amp; topic, ptr&lt;network::network_backend&gt; backend = nullptr,\n                                const network::topic_config&amp; config = {})\n            : writer&lt;Serializable_event&gt;{topic}\n            , backend_{std::move(backend)}\n            , config_{config} { }\n\n        void put(ptr&lt;Serializable_event&gt;&amp;&amp; this_specific_event) override {\n            if (backend_-&gt;is_topic_networked(this-&gt;topic_.name())) {\n                if (config_.serialization_method == network::topic_config::SerializationMethod::BOOST) {\n                    auto base_event = std::dynamic_pointer_cast&lt;event&gt;(std::move(this_specific_event));\n                    assert(base_event &amp;&amp; \"Event is not derived from switchboard::event\");\n                    // Default serialization method - Boost\n                    std::vector&lt;char&gt;                                                                        buffer;\n                    boost::iostreams::back_insert_device&lt;std::vector&lt;char&gt;&gt;                                  inserter{buffer};\n                    boost::iostreams::stream_buffer&lt;boost::iostreams::back_insert_device&lt;std::vector&lt;char&gt;&gt;&gt; stream{inserter};\n                    boost::archive::binary_oarchive                                                          oa{stream};\n                    oa &lt;&lt; base_event;\n                    // flush\n                    stream.pubsync();\n                    backend_-&gt;topic_send(this-&gt;topic_.name(), std::move(std::string(buffer.begin(), buffer.end())));\n                } else {\n                    // PROTOBUF - this_specific_event will be a string\n                    auto        message_ptr = std::dynamic_pointer_cast&lt;event_wrapper&lt;std::string&gt;&gt;(this_specific_event);\n                    std::string message     = **message_ptr;\n                    backend_-&gt;topic_send(this-&gt;topic_.name(), std::move(message));\n                }\n            } else {\n                writer&lt;Serializable_event&gt;::put(std::move(this_specific_event));\n            }\n        }\n\n    private:\n        ptr&lt;network::network_backend&gt; backend_;\n        network::topic_config         config_;\n    };\n\npublic:\n    explicit switchboard(const phonebook* pb)\n        : phonebook_{pb}\n        , record_logger_{pb ? pb-&gt;lookup_impl&lt;record_logger&gt;() : nullptr} {\n        for (const auto&amp; item : ENV_VARS) {\n            char* value = getenv(item.c_str());\n            if (value) {\n                env_vars_[item] = value;\n            } else {\n                env_vars_[item] = \"\";\n            }\n        }\n    }\n\n    [[maybe_unused]] bool topic_exists(const std::string&amp; topic_name) {\n        const std::shared_lock lock{registry_lock_};\n        auto                   found = registry_.find(topic_name);\n        return found != registry_.end();\n    }\n\n    [[maybe_unused]] topic&amp; get_topic(const std::string&amp; topic_name) {\n        const std::shared_lock lock{registry_lock_};\n        auto                   found = registry_.find(topic_name);\n        if (found != registry_.end()) {\n            return found-&gt;second;\n        } else {\n            throw std::runtime_error(\"Topic not found\");\n        }\n    }\n\n    void set_env(const std::string&amp; var, const std::string&amp; val) {\n        env_vars_[var] = val;\n        setenv(var.c_str(), val.c_str(), 1);\n    }\n\n    std::vector&lt;std::string&gt; env_names() const {\n        std::vector&lt;std::string&gt; keys(env_vars_.size());\n        std::transform(env_vars_.begin(), env_vars_.end(), keys.begin(), [](auto pair) {\n            return pair.first;\n        });\n        return keys;\n    }\n\n    std::string get_env(const std::string&amp; var, std::string _default = \"\") {\n        try {\n            if (!env_vars_.at(var).empty())\n                return env_vars_.at(var);\n            env_vars_.at(var) = _default;\n            return _default;\n        } catch (std::out_of_range&amp;) {\n            char* val = std::getenv(var.c_str());\n            if (val) {\n                set_env(var, val); // store it locally for faster retrieval\n                return {val};\n            }\n            return _default;\n        }\n    }\n\n    bool get_env_bool(const std::string&amp; var, const std::string&amp; def = \"false\") {\n        std::string val = get_env(var, def);\n        // see if we are dealing with an int value\n        try {\n            const int i_val = std::stoi(val);\n            if (i_val &lt;= 0)\n                return false;\n            return true;\n        } catch (...) { }\n\n        const std::vector&lt;std::string&gt; affirmative{\"yes\", \"y\", \"true\", \"on\"};\n        for (auto s : affirmative) {\n            if (std::equal(val.begin(), val.end(), s.begin(), s.end(), [](char a, char b) {\n                    return std::tolower(a) == std::tolower(b);\n                }))\n                return true;\n        }\n        return false;\n    }\n\n    const char* get_env_char(const std::string&amp; var, const std::string _default = \"\") {\n        std::string val = get_env(var, _default);\n        if (val.empty())\n            return nullptr;\n        return strdup(val.c_str());\n    }\n\n    template&lt;typename Specific_event&gt;\n    void schedule(plugin_id_t plugin_id, std::string topic_name,\n                  std::function&lt;void(ptr&lt;const Specific_event&gt;&amp;&amp;, std::size_t)&gt; fn) {\n        try_register_topic&lt;Specific_event&gt;(topic_name)\n            .schedule(plugin_id, [=](ptr&lt;const event&gt;&amp;&amp; this_event, std::size_t it_no) {\n                assert(this_event);\n                ptr&lt;const Specific_event&gt; this_specific_event =\n                    std::dynamic_pointer_cast&lt;const Specific_event&gt;(std::move(this_event));\n                assert(this_specific_event);\n                fn(std::move(this_specific_event), it_no);\n            });\n    }\n\n    template&lt;typename Specific_event&gt;\n    writer&lt;Specific_event&gt; get_writer(const std::string&amp; topic_name) {\n        return writer&lt;Specific_event&gt;{try_register_topic&lt;Specific_event&gt;(topic_name)};\n    }\n\n    template&lt;typename Specific_event&gt;\n    network_writer&lt;Specific_event&gt; get_network_writer(const std::string&amp; topic_name, network::topic_config config = {}) {\n        auto backend = phonebook_-&gt;lookup_impl&lt;network::network_backend&gt;();\n        if (registry_.find(topic_name) == registry_.end()) {\n            backend-&gt;topic_create(topic_name, config);\n        }\n        return network_writer&lt;Specific_event&gt;{try_register_topic&lt;Specific_event&gt;(topic_name), backend, config};\n    }\n\n    template&lt;typename Specific_event&gt;\n    reader&lt;Specific_event&gt; get_reader(const std::string&amp; topic_name) {\n        return reader&lt;Specific_event&gt;{try_register_topic&lt;Specific_event&gt;(topic_name)};\n    }\n\n    template&lt;typename Specific_event&gt;\n    buffered_reader&lt;Specific_event&gt; get_buffered_reader(const std::string&amp; topic_name) {\n        return buffered_reader&lt;Specific_event&gt;{try_register_topic&lt;Specific_event&gt;(topic_name)};\n    }\n\n    void stop() {\n        const std::shared_lock lock{registry_lock_};\n        for (auto&amp; pair : registry_) {\n            pair.second.stop();\n        }\n    }\n\nprivate:\n    const phonebook*                             phonebook_;\n    std::unordered_map&lt;std::string, topic&gt;       registry_;\n    std::shared_mutex                            registry_lock_;\n    std::shared_ptr&lt;record_logger&gt;               record_logger_;\n    std::unordered_map&lt;std::string, std::string&gt; env_vars_;\n\n    template&lt;typename Specific_event&gt;\n    topic&amp; try_register_topic(const std::string&amp; topic_name) {\n        {\n            const std::shared_lock lock{registry_lock_};\n            auto                   found = registry_.find(topic_name);\n            if (found != registry_.end()) {\n                topic&amp; _topic = found-&gt;second;\n#ifndef NDEBUG\n                if (typeid(Specific_event) != _topic.ty()) {\n                    spdlog::get(\"illixr\")-&gt;error(\"[switchboard] topic '{}' holds type {}, but caller used type {}\", topic_name,\n                                                 _topic.ty().name(), typeid(Specific_event).name());\n                    abort();\n                }\n#endif\n                return _topic;\n            }\n        }\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[switchboard] Creating: {} for {}\", topic_name, typeid(Specific_event).name());\n#endif\n        // Topic not found. Need to create it here.\n        const std::unique_lock lock{registry_lock_};\n        return registry_.try_emplace(topic_name, topic_name, typeid(Specific_event), record_logger_).first-&gt;second;\n    }\n\n    class coordinate_system {\n    private:\n        Eigen::Vector3f    position_;\n        Eigen::Quaternionf orientation_;\n\n    public:\n        coordinate_system()\n            : position_{0., 0., 0.}\n            , orientation_{1., 0., 0., 0.} {\n            const char* ini_pose = getenv(\"WCS_ORIGIN\");\n            // =\n            // if (!ini_pose.empty()) {\n            if (ini_pose) {\n                std::string        ini_pose_str(ini_pose);\n                std::stringstream  iss(ini_pose_str);\n                std::string        token;\n                std::vector&lt;float&gt; ip;\n                while (!iss.eof() &amp;&amp; std::getline(iss, token, ',')) {\n                    ip.emplace_back(std::stof(token));\n                }\n                if (ip.size() == 3) {\n                    position_.x() = ip[0];\n                    position_.y() = ip[1];\n                    position_.z() = ip[2];\n                } else if (ip.size() == 4) {\n                    orientation_.w() = ip[0];\n                    orientation_.x() = ip[1];\n                    orientation_.y() = ip[2];\n                    orientation_.z() = ip[3];\n                } else if (ip.size() == 7) {\n                    position_.x()    = ip[0];\n                    position_.y()    = ip[1];\n                    position_.z()    = ip[2];\n                    orientation_.w() = ip[3];\n                    orientation_.x() = ip[4];\n                    orientation_.y() = ip[5];\n                    orientation_.z() = ip[6];\n                }\n            }\n        }\n\n        [[nodiscard]] const Eigen::Vector3f&amp; position() const {\n            return position_;\n        }\n\n        [[nodiscard]] const Eigen::Quaternionf&amp; orientation() const {\n            return orientation_;\n        }\n    };\n\npublic:\n    coordinate_system root_coordinates; \n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/tcpsocket_8hpp/","title":"File tcpsocket.hpp","text":"<p>FileList &gt; illixr &gt; network &gt; tcpsocket.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;arpa/inet.h&gt;</code></li> <li><code>#include &lt;netinet/in.h&gt;</code></li> <li><code>#include &lt;netinet/tcp.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;sys/socket.h&gt;</code></li> <li><code>#include &lt;unistd.h&gt;</code></li> </ul>"},{"location":"api/tcpsocket_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace network"},{"location":"api/tcpsocket_8hpp/#classes","title":"Classes","text":"Type Name class TCPSocket <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/tcpsocket.hpp</code></p>"},{"location":"api/tcpsocket_8hpp_source/","title":"File tcpsocket.hpp","text":"<p>File List &gt; illixr &gt; network &gt; tcpsocket.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;netinet/tcp.h&gt;\n#include &lt;string&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\nusing namespace std;\n\nnamespace ILLIXR::network {\n\nclass TCPSocket {\npublic:\n    TCPSocket() {\n        fd_ = socket(AF_INET, SOCK_STREAM, 0);\n    }\n\n    [[maybe_unused]] explicit TCPSocket(int fd) {\n        fd_ = fd;\n    }\n\n    // Destructor\n    // Close the file descriptor\n    ~TCPSocket() {\n        close(fd_);\n    }\n\n    // Bind socket to a specified local ip and port\n    void socket_bind(const string&amp; ip, int port) const {\n        sockaddr_in local_addr;\n        local_addr.sin_family      = AF_INET;\n        local_addr.sin_port        = htons(port);\n        local_addr.sin_addr.s_addr = inet_addr(ip.c_str());\n        bind(fd_, (struct sockaddr*) &amp;local_addr, sizeof(local_addr));\n    }\n\n    // Listen for a connection. It is typically called from the server socket.\n    void socket_listen(const int backlog = 16) const {\n        listen(fd_, backlog);\n    }\n\n    // Connect the socket to a specified peer addr\n    void socket_connect(const string&amp; ip, int port) const {\n        sockaddr_in peer_addr;\n        peer_addr.sin_family      = AF_INET;\n        peer_addr.sin_port        = htons(port);\n        peer_addr.sin_addr.s_addr = inet_addr(ip.c_str());\n        connect(fd_, (struct sockaddr*) &amp;peer_addr, sizeof(peer_addr));\n    }\n\n    // Accept connect from the client. It is typically called from the server socket.\n    int socket_accept() const {\n        int fd = accept(fd_, nullptr, nullptr);\n        return fd;\n    }\n\n    // Allow the reuse of local addresses\n    void socket_set_reuseaddr() const {\n        const int enable = 1;\n        setsockopt(fd_, SOL_SOCKET, SO_REUSEADDR, &amp;enable, sizeof(int));\n    }\n\n    // Read data from the socket\n    [[nodiscard]] string read_data(const size_t limit = BUFFER_SIZE) const {\n        char    buffer[BUFFER_SIZE];\n        ssize_t bytes_read = read(fd_, buffer, min(BUFFER_SIZE, limit));\n        return string(buffer, bytes_read);\n    }\n\n    // Write data to the socket\n    void write_data(const string&amp; buffer) {\n        auto it = buffer.begin();\n        do {\n            it = write_helper(it, buffer.end());\n        } while (it != buffer.end());\n    }\n\n    // Disable naggle algorithm. This allows socket to flush data immediately after calling write().\n    void enable_no_delay() const {\n        const int enable = 1;\n        setsockopt(fd_, IPPROTO_TCP, TCP_NODELAY, &amp;enable, sizeof(int));\n    }\n\n    /* accessors */\n    [[maybe_unused]] [[nodiscard]] string local_address() const {\n        struct sockaddr_in local_address;\n        socklen_t          size = sizeof(local_address);\n        getsockname(fd_, (struct sockaddr*) &amp;local_address, &amp;size);\n        char* local_ip   = inet_ntoa(local_address.sin_addr);\n        int   local_port = ntohs(local_address.sin_port);\n        return string(local_ip) + \":\" + to_string(local_port);\n    }\n\n    [[nodiscard]] string peer_address() const {\n        struct sockaddr_in peer_address;\n        socklen_t          size = sizeof(peer_address);\n        getpeername(fd_, (struct sockaddr*) &amp;peer_address, &amp;size);\n        char* peer_ip   = inet_ntoa(peer_address.sin_addr);\n        int   peer_port = ntohs(peer_address.sin_port);\n        return string(peer_ip) + \":\" + to_string(peer_port);\n    }\n\nprivate:\n    [[nodiscard]] string::const_iterator write_helper(const string::const_iterator&amp; begin,\n                                                      const string::const_iterator&amp; end) const {\n        ssize_t bytes_written = write(fd_, &amp;*begin, end - begin);\n        return begin + bytes_written;\n    }\n\n    int fd_;\n    /* maximum size of a read */\n    static constexpr size_t BUFFER_SIZE = 1024 * 1024;\n};\n\n} // namespace ILLIXR::network\n</code></pre>"},{"location":"api/template_8hpp/","title":"File template.hpp","text":"<p>FileList &gt; data_format &gt; template.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include \"illixr/data_format/unit.hpp\"</code></li> </ul>"},{"location":"api/template_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/template.hpp</code></p>"},{"location":"api/template_8hpp_source/","title":"File template.hpp","text":"<p>File List &gt; data_format &gt; template.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifndef NDEBUG\n    #include &lt;spdlog/spdlog.h&gt;\n#endif\n\n#include \"illixr/data_format/unit.hpp\"\n\nnamespace ILLIXR::data_format {\n/*\n * Normalize the coordinates, using the input size as reference\n */\ntemplate&lt;typename T&gt;\ninline void normalize(T&amp; obj, const float width, const float height, const float depth) {\n    if (obj.unit == units::PERCENT) {\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;info(\"[normalize] already normalized\");\n#endif\n        return;\n    }\n    obj.x() /= width;\n    obj.y() /= height;\n    obj.z() /= depth;\n    obj.unit = units::PERCENT;\n}\n\ntemplate&lt;typename T&gt;\ninline void normalize(T&amp; obj, const float width, const float height) {\n    normalize&lt;T&gt;(obj, width, height, 1.);\n}\n\n/*\n * Denormalize the coordinates, using the input size as reference\n */\ntemplate&lt;typename T&gt;\ninline void denormalize(T&amp; obj, const float width, const float height, const float depth,\n                        units::measurement_unit unit_ = units::PIXEL) {\n    if (!obj.valid)\n        return;\n    if (obj.unit != units::PERCENT) {\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;info(\"[denormalize] already denormalized\");\n#endif\n        return;\n    }\n    if (unit_ == units::PERCENT || unit_ == units::UNSET)\n        throw std::runtime_error(\"Cannot denormalize to PERCENT\");\n\n    obj.x() *= width;\n    obj.y() *= height;\n    obj.z() *= depth;\n    obj.unit = unit_;\n}\n\ntemplate&lt;typename T&gt;\ninline void denormalize(T&amp; obj, const float width, const float height, units::measurement_unit unit_ = units::PIXEL) {\n    denormalize&lt;T&gt;(obj, width, height, 1., unit_);\n}\n} // namespace ILLIXR::data_format\n</code></pre>"},{"location":"api/threadloop_8hpp/","title":"File threadloop.hpp","text":"<p>FileList &gt; illixr &gt; threadloop.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cpu_timer.hpp\"</code></li> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> <li><code>#include \"stoplight.hpp\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/threadloop_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/threadloop_8hpp/#classes","title":"Classes","text":"Type Name class threadloop A reusable threadloop for plugins. <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/threadloop.hpp</code></p>"},{"location":"api/threadloop_8hpp_source/","title":"File threadloop.hpp","text":"<p>File List &gt; illixr &gt; threadloop.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"cpu_timer.hpp\"\n#include \"error_util.hpp\"\n#include \"phonebook.hpp\"\n#include \"plugin.hpp\"\n#include \"record_logger.hpp\"\n#include \"stoplight.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n\nnamespace ILLIXR {\n\nconst record_header _threadloop_iteration_header{\n    \"threadloop_iteration\",\n    {\n        {\"plugin_id\", typeid(std::size_t)},\n        {\"iteration_no\", typeid(std::size_t)},\n        {\"skips\", typeid(std::size_t)},\n        {\"cpu_time_start\", typeid(std::chrono::nanoseconds)},\n        {\"cpu_time_stop\", typeid(std::chrono::nanoseconds)},\n        {\"wall_time_start\", typeid(std::chrono::high_resolution_clock::time_point)},\n        {\"wall_time_stop\", typeid(std::chrono::high_resolution_clock::time_point)},\n    }};\n\nclass threadloop : public plugin {\npublic:\n    threadloop(const std::string&amp; name, phonebook* pb)\n        : plugin{name, pb}\n        , stoplight_{pb-&gt;lookup_impl&lt;stoplight&gt;()} { }\n\n    void start() override {\n        plugin::start();\n        thread_ = std::thread([this] {\n            thread_main();\n        });\n        assert(!stoplight_-&gt;check_should_stop());\n        assert(thread_.joinable());\n    }\n\n    void stop() override {\n        assert(stoplight_-&gt;check_should_stop());\n        // only join if it has been started\n        if (thread_.joinable())\n            thread_.join();\n        plugin::stop();\n    }\n\n    virtual void internal_stop() {\n        internal_stop_.store(true);\n    }\n\n    ~threadloop() override {\n        assert(stoplight_-&gt;check_should_stop());\n        assert(!thread_.joinable());\n    }\n\nprotected:\n    enum class skip_option {\n        run,\n\n        skip_and_spin,\n\n        skip_and_yield,\n\n        stop,\n    };\n\n    virtual skip_option _p_should_skip() {\n        return skip_option::run;\n    }\n\n    virtual void _p_thread_setup() { }\n\n    virtual void _p_one_iteration() = 0;\n\n    bool should_terminate() {\n        return internal_stop_.load();\n    }\n\n    std::size_t iteration_no = 0;\n    std::size_t skip_no      = 0;\n\nprivate:\n    void thread_main() {\n        record_coalescer it_log{record_logger_};\n\n        // TODO: In the future, synchronize the main loop instead of the setup.\n        // This is currently not possible because relative_clock is required in\n        // some setup functions, and relative_clock is only guaranteed to be\n        // available once `wait_for_ready()` unblocks.\n        stoplight_-&gt;wait_for_ready();\n        _p_thread_setup();\n\n        while (!stoplight_-&gt;check_should_stop() &amp;&amp; !should_terminate()) {\n            skip_option s = _p_should_skip();\n\n            switch (s) {\n            case skip_option::skip_and_yield:\n                std::this_thread::yield();\n                ++skip_no;\n                break;\n            case skip_option::skip_and_spin:\n                ++skip_no;\n                break;\n            case skip_option::run: {\n                auto iteration_start_cpu_time  = thread_cpu_time();\n                auto iteration_start_wall_time = std::chrono::high_resolution_clock::now();\n\n                RAC_ERRNO();\n                _p_one_iteration();\n                RAC_ERRNO();\n\n                it_log.log(record{_threadloop_iteration_header,\n                                  {\n                                      {id_},\n                                      {iteration_no},\n                                      {skip_no},\n                                      {iteration_start_cpu_time},\n                                      {thread_cpu_time()},\n                                      {iteration_start_wall_time},\n                                      {std::chrono::high_resolution_clock::now()},\n                                  }});\n                ++iteration_no;\n                skip_no = 0;\n                break;\n            }\n            case skip_option::stop:\n                // Break out of the switch AND the loop\n                // See https://stackoverflow.com/questions/27788326/breaking-out-of-nested-loop-c\n                goto break_loop;\n            }\n        }\n    break_loop:\n        [[maybe_unused]] int cpp_requires_a_statement_after_a_label_plz_optimize_me_away;\n    }\n\n    std::atomic&lt;bool&gt;                internal_stop_{false};\n    std::thread                      thread_;\n    std::shared_ptr&lt;const stoplight&gt; stoplight_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/timewarp__vk_8cpp/","title":"File timewarp_vk.cpp","text":"<p>FileList &gt; plugins &gt; timewarp_vk &gt; timewarp_vk.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"timewarp_vk.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/math_util.hpp\"</code></li> <li><code>#include \"illixr/vk/vulkan_utils.hpp\"</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/matrix_transform.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/hash.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"api/timewarp__vk_8cpp/#classes","title":"Classes","text":"Type Name struct uniform_buffer_object struct vertex"},{"location":"api/timewarp__vk_8cpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL define GLM_FORCE_DEPTH_ZERO_TO_ONE define GLM_FORCE_RADIANS"},{"location":"api/timewarp__vk_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/timewarp__vk_8cpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre>"},{"location":"api/timewarp__vk_8cpp/#define-glm_force_depth_zero_to_one","title":"define GLM_FORCE_DEPTH_ZERO_TO_ONE","text":"<pre><code>#define GLM_FORCE_DEPTH_ZERO_TO_ONE \n</code></pre>"},{"location":"api/timewarp__vk_8cpp/#define-glm_force_radians","title":"define GLM_FORCE_RADIANS","text":"<pre><code>#define GLM_FORCE_RADIANS \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/timewarp_vk.cpp</code></p>"},{"location":"api/timewarp__vk_8cpp_source/","title":"File timewarp_vk.cpp","text":"<p>File List &gt; plugins &gt; timewarp_vk &gt; timewarp_vk.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"timewarp_vk.hpp\"\n\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/math_util.hpp\"\n#include \"illixr/vk/vulkan_utils.hpp\"\n\n#define GLM_FORCE_RADIANS\n#define GLM_FORCE_DEPTH_ZERO_TO_ONE\n#define GLM_ENABLE_EXPERIMENTAL\n#include &lt;future&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;glm/gtc/matrix_transform.hpp&gt;\n#include &lt;glm/gtx/hash.hpp&gt;\n#include &lt;mutex&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nstruct vertex {\n    glm::vec3 pos;\n    glm::vec2 uv0;\n    glm::vec2 uv1;\n    glm::vec2 uv2;\n\n    static VkVertexInputBindingDescription get_binding_description() {\n        VkVertexInputBindingDescription binding_description = {};\n        binding_description.binding                         = 0;              // index of the binding in the array of bindings\n        binding_description.stride                          = sizeof(vertex); // number of bytes from one entry to the next\n        binding_description.inputRate                       = VK_VERTEX_INPUT_RATE_VERTEX; // no instancing\n\n        return binding_description;\n    }\n\n    static std::array&lt;VkVertexInputAttributeDescription, 4&gt; get_attribute_descriptions() {\n        std::array&lt;VkVertexInputAttributeDescription, 4&gt; attribute_descriptions = {};\n\n        // position\n        attribute_descriptions[0].binding  = 0;                          // which binding the per-vertex data comes from\n        attribute_descriptions[0].location = 0;                          // location directive of the input in the vertex shader\n        attribute_descriptions[0].format   = VK_FORMAT_R32G32B32_SFLOAT; // format of the data\n        attribute_descriptions[0].offset =\n            offsetof(vertex, pos); // number of bytes since the start of the per-vertex data to read from\n\n        // uv0\n        attribute_descriptions[1].binding  = 0;\n        attribute_descriptions[1].location = 1;\n        attribute_descriptions[1].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[1].offset   = offsetof(vertex, uv0);\n\n        // uv1\n        attribute_descriptions[2].binding  = 0;\n        attribute_descriptions[2].location = 2;\n        attribute_descriptions[2].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[2].offset   = offsetof(vertex, uv1);\n\n        // uv2\n        attribute_descriptions[3].binding  = 0;\n        attribute_descriptions[3].location = 3;\n        attribute_descriptions[3].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[3].offset   = offsetof(vertex, uv2);\n\n        return attribute_descriptions;\n    }\n};\n\nstruct uniform_buffer_object {\n    glm::mat4 timewarp_start_transform[2];\n    glm::mat4 timewarp_end_transform[2];\n};\n\ntimewarp_vk::timewarp_vk(const phonebook* const pb)\n    : phonebook_{pb}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , pose_prediction_{phonebook_-&gt;lookup_impl&lt;pose_prediction&gt;()}\n    , vsync_{switchboard_-&gt;get_reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\")}\n    , disable_warp_{switchboard_-&gt;get_env_bool(\"ILLIXR_TIMEWARP_DISABLE\", \"False\")} { }\n\nvoid timewarp_vk::initialize() {\n    if (display_provider_-&gt;vma_allocator_) {\n        this-&gt;vma_allocator_ = display_provider_-&gt;vma_allocator_;\n    } else {\n        this-&gt;vma_allocator_ = vulkan::create_vma_allocator(\n            display_provider_-&gt;vk_instance_, display_provider_-&gt;vk_physical_device_, display_provider_-&gt;vk_device_);\n        deletion_queue_.emplace([=]() {\n            vmaDestroyAllocator(vma_allocator_);\n        });\n    }\n\n    command_pool_   = vulkan::create_command_pool(display_provider_-&gt;vk_device_,\n                                                  display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS].family);\n    command_buffer_ = vulkan::create_command_buffer(display_provider_-&gt;vk_device_, command_pool_);\n    deletion_queue_.emplace([=]() {\n        vkDestroyCommandPool(display_provider_-&gt;vk_device_, command_pool_, nullptr);\n    });\n\n    create_descriptor_set_layout();\n    create_uniform_buffer();\n    create_texture_sampler();\n}\n\nvoid timewarp_vk::setup(VkRenderPass render_pass, uint32_t subpass,\n                        std::shared_ptr&lt;vulkan::buffer_pool&lt;fast_pose_type&gt;&gt; buffer_pool, bool input_texture_external_in) {\n    std::lock_guard&lt;std::mutex&gt; lock{setup_mutex_};\n\n    display_provider_ = phonebook_-&gt;lookup_impl&lt;vulkan::display_provider&gt;();\n\n    swapchain_width_  = display_provider_-&gt;swapchain_extent_.width == 0 ? display_params::width_pixels\n                                                                        : display_provider_-&gt;swapchain_extent_.width;\n    swapchain_height_ = display_provider_-&gt;swapchain_extent_.height == 0 ? display_params::height_pixels\n                                                                         : display_provider_-&gt;swapchain_extent_.height;\n\n    HMD::get_default_hmd_info(static_cast&lt;int&gt;(swapchain_width_), static_cast&lt;int&gt;(swapchain_height_),\n                              display_params::width_meters, display_params::height_meters, display_params::lens_separation,\n                              display_params::meters_per_tan_angle, display_params::aberration, hmd_info_);\n\n    this-&gt;input_texture_external_ = input_texture_external_in;\n    if (!initialized_) {\n        initialize();\n        initialized_ = true;\n    } else {\n        partial_destroy();\n    }\n\n    generate_distortion_data();\n\n    create_vertex_buffer();\n    create_index_buffer();\n\n    this-&gt;buffer_pool_ = std::move(buffer_pool);\n\n    create_descriptor_pool();\n    create_descriptor_sets();\n    create_pipeline(render_pass, subpass);\n    timewarp_render_pass_ = render_pass;\n\n    clamp_edge_ = switchboard_-&gt;get_env_bool(\"ILLIXR_TIMEWARP_CLAMP_EDGE\");\n}\n\nvoid timewarp_vk::partial_destroy() {\n    vkDestroyPipeline(display_provider_-&gt;vk_device_, pipeline_, nullptr);\n    pipeline_ = VK_NULL_HANDLE;\n\n    vkDestroyPipelineLayout(display_provider_-&gt;vk_device_, pipeline_layout_, nullptr);\n    pipeline_layout_ = VK_NULL_HANDLE;\n\n    vkDestroyDescriptorPool(display_provider_-&gt;vk_device_, descriptor_pool_, nullptr);\n    descriptor_pool_ = VK_NULL_HANDLE;\n}\n\nvoid timewarp_vk::update_uniforms(const pose_type&amp; render_pose) {\n    num_update_uniforms_calls_++;\n\n    // Generate \"starting\" view matrix, from the pose sampled at the time of rendering the frame\n    Eigen::Matrix4f view_matrix   = Eigen::Matrix4f::Identity();\n    view_matrix.block(0, 0, 3, 3) = render_pose.orientation.toRotationMatrix();\n\n    // We simulate two asynchronous view matrices, one at the beginning of\n    // display refresh, and one at the end of display refresh. The\n    // distortion shader will lerp between these two predictive view\n    // transformations as it renders across the horizontal view,\n    // compensating for display panel refresh delay (wow!)\n    Eigen::Matrix4f view_matrix_begin = Eigen::Matrix4f::Identity();\n    Eigen::Matrix4f view_matrix_end   = Eigen::Matrix4f::Identity();\n\n    auto      next_vsync  = vsync_.get_ro_nullable().get();\n    pose_type latest_pose = disable_warp_\n        ? render_pose\n        : (next_vsync == nullptr ? pose_prediction_-&gt;get_fast_pose().pose : pose_prediction_-&gt;get_fast_pose(**next_vsync).pose);\n\n    view_matrix_begin.block(0, 0, 3, 3) = latest_pose.orientation.toRotationMatrix();\n\n    // TODO: We set the \"end\" pose to the same as the beginning pose, but this really should be the pose for\n    // `display_period` later\n    view_matrix_end = view_matrix_begin;\n\n    auto* ubo = (uniform_buffer_object*) uniform_alloc_info_.pMappedData;\n    for (int eye = 0; eye &lt; 2; eye++) {\n        // Calculate the timewarp transformation matrices. These are a product\n        // of the last-known-good view matrix and the predictive transforms.\n        Eigen::Matrix4f timeWarpStartTransform4x4;\n        Eigen::Matrix4f timeWarpEndTransform4x4;\n\n        // Calculate timewarp transforms using predictive view transforms\n        calculate_timewarp_transform(timeWarpStartTransform4x4, basic_projection_[eye], view_matrix, view_matrix_begin);\n        calculate_timewarp_transform(timeWarpEndTransform4x4, basic_projection_[eye], view_matrix, view_matrix_end);\n\n        memcpy(&amp;ubo-&gt;timewarp_start_transform[eye], timeWarpStartTransform4x4.data(), sizeof(glm::mat4));\n        memcpy(&amp;ubo-&gt;timewarp_end_transform[eye], timeWarpEndTransform4x4.data(), sizeof(glm::mat4));\n    }\n}\n\nvoid timewarp_vk::record_command_buffer(VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) {\n    num_record_calls_++;\n\n    VkDeviceSize offsets = 0;\n\n    if (left)\n        frame_count_++;\n\n    VkClearValue clear_color;\n    clear_color.color = {0.0f, 0.0f, 0.0f, 1.0f};\n\n    // Timewarp handles distortion correction at the same time\n    VkRenderPassBeginInfo tw_render_pass_info{};\n    tw_render_pass_info.sType                    = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;\n    tw_render_pass_info.renderPass               = timewarp_render_pass_;\n    tw_render_pass_info.renderArea.offset.x      = left ? 0 : static_cast&lt;int32_t&gt;(swapchain_width_ / 2);\n    tw_render_pass_info.renderArea.offset.y      = 0;\n    tw_render_pass_info.renderArea.extent.width  = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2);\n    tw_render_pass_info.renderArea.extent.height = static_cast&lt;uint32_t&gt;(swapchain_height_);\n    tw_render_pass_info.framebuffer              = framebuffer;\n    tw_render_pass_info.clearValueCount          = 1;\n    tw_render_pass_info.pClearValues             = &amp;clear_color;\n\n    VkViewport tw_viewport{};\n    tw_viewport.x        = left ? 0.f : static_cast&lt;float&gt;(swapchain_width_) / 2.f;\n    tw_viewport.y        = 0.f;\n    tw_viewport.width    = static_cast&lt;float&gt;(swapchain_width_) / 2.f;\n    tw_viewport.height   = static_cast&lt;float&gt;(swapchain_height_);\n    tw_viewport.minDepth = 0.0f;\n    tw_viewport.maxDepth = 1.0f;\n\n    VkRect2D tw_scissor{};\n    tw_scissor.offset.x      = left ? 0 : static_cast&lt;int32_t&gt;(swapchain_width_ / 2);\n    tw_scissor.offset.y      = 0;\n    tw_scissor.extent.width  = static_cast&lt;uint32_t&gt;(swapchain_width_ / 2);\n    tw_scissor.extent.height = static_cast&lt;uint32_t&gt;(swapchain_height_);\n\n    vkCmdBeginRenderPass(commandBuffer, &amp;tw_render_pass_info, VK_SUBPASS_CONTENTS_INLINE);\n    vkCmdSetViewport(commandBuffer, 0, 1, &amp;tw_viewport);\n    vkCmdSetScissor(commandBuffer, 0, 1, &amp;tw_scissor);\n\n    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_);\n    vkCmdBindVertexBuffers(commandBuffer, 0, 1, &amp;vertex_buffer_, &amp;offsets);\n\n    auto eye = static_cast&lt;uint32_t&gt;(left ? 0 : 1);\n    vkCmdPushConstants(commandBuffer, pipeline_layout_, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(uint32_t), &amp;eye);\n    vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout_, 0, 1,\n                            &amp;descriptor_sets_[!left][buffer_ind], 0, nullptr);\n    vkCmdBindIndexBuffer(commandBuffer, index_buffer_, 0, VK_INDEX_TYPE_UINT32);\n    vkCmdDrawIndexed(commandBuffer, num_distortion_indices_, 1, 0, static_cast&lt;int&gt;(num_distortion_vertices_ * !left), 0);\n    vkCmdEndRenderPass(commandBuffer);\n}\n\nvoid timewarp_vk::destroy() {\n    partial_destroy();\n    // drain deletion_queue_\n    while (!deletion_queue_.empty()) {\n        deletion_queue_.top()();\n        deletion_queue_.pop();\n    }\n}\n\nvoid timewarp_vk::create_vertex_buffer() {\n    VkBufferCreateInfo staging_buffer_info = {\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, // sType\n        nullptr,                              // pNext\n        0,                                    // flags\n        0,                                    // size\n        0,                                    // usage\n        {},                                   // sharingMode\n        0,                                    // queueFamilyIndexCount\n        nullptr                               // pQueueFamilyIndices\n    };\n    staging_buffer_info.size  = sizeof(vertex) * num_distortion_vertices_ * HMD::NUM_EYES;\n    staging_buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;\n\n    VmaAllocationCreateInfo staging_alloc_info = {};\n    staging_alloc_info.usage                   = VMA_MEMORY_USAGE_AUTO;\n    staging_alloc_info.flags                   = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n\n    VkBuffer      staging_buffer;\n    VmaAllocation staging_alloc;\n    VK_ASSERT_SUCCESS(\n        vmaCreateBuffer(vma_allocator_, &amp;staging_buffer_info, &amp;staging_alloc_info, &amp;staging_buffer, &amp;staging_alloc, nullptr))\n\n    VkBufferCreateInfo buffer_info = {\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, // sType\n        nullptr,                              // pNext\n        0,                                    // flags\n        0,                                    // size\n        0,                                    // usage\n        {},                                   // sharingMode\n        0,                                    // queueFamilyIndexCount\n        nullptr                               // pQueueFamilyIndices\n    };\n    buffer_info.size  = sizeof(vertex) * num_distortion_vertices_ * HMD::NUM_EYES;\n    buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;\n\n    VmaAllocationCreateInfo alloc_info = {};\n    alloc_info.usage                   = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VmaAllocation vertex_alloc;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;buffer_info, &amp;alloc_info, &amp;vertex_buffer_, &amp;vertex_alloc, nullptr))\n\n    std::vector&lt;vertex&gt; vertices;\n    vertices.resize(num_distortion_vertices_ * HMD::NUM_EYES);\n    for (size_t i = 0; i &lt; num_distortion_vertices_ * HMD::NUM_EYES; i++) {\n        vertices[i].pos = {distortion_positions_[i].x, distortion_positions_[i].y, distortion_positions_[i].z};\n        vertices[i].uv0 = {distortion_uv0_[i].u, distortion_uv0_[i].v};\n        vertices[i].uv1 = {distortion_uv1_[i].u, distortion_uv1_[i].v};\n        vertices[i].uv2 = {distortion_uv2_[i].u, distortion_uv2_[i].v};\n    }\n\n    void* mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, staging_alloc, &amp;mapped_data))\n    memcpy(mapped_data, vertices.data(), sizeof(vertex) * num_distortion_vertices_ * HMD::NUM_EYES);\n    vmaUnmapMemory(vma_allocator_, staging_alloc);\n\n    VkCommandBuffer command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    copy_region          = {};\n    copy_region.size                     = sizeof(vertex) * num_distortion_vertices_ * HMD::NUM_EYES;\n    vkCmdCopyBuffer(command_buffer_local, staging_buffer, vertex_buffer_, 1, &amp;copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, staging_buffer, staging_alloc);\n\n    deletion_queue_.emplace([=]() {\n        vmaDestroyBuffer(vma_allocator_, vertex_buffer_, vertex_alloc);\n    });\n}\n\nvoid timewarp_vk::create_index_buffer() {\n    VkBufferCreateInfo staging_buffer_info = {\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, // sType\n        nullptr,                              // pNext\n        0,                                    // flags\n        0,                                    // size\n        0,                                    // usage\n        {},                                   // sharingMode\n        0,                                    // queueFamilyIndexCount\n        nullptr                               // pQueueFamilyIndices\n    };\n    staging_buffer_info.size  = sizeof(uint32_t) * num_distortion_indices_;\n    staging_buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;\n\n    VmaAllocationCreateInfo staging_alloc_info = {};\n    staging_alloc_info.usage                   = VMA_MEMORY_USAGE_AUTO;\n    staging_alloc_info.flags                   = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n\n    VkBuffer      staging_buffer;\n    VmaAllocation staging_alloc;\n    VK_ASSERT_SUCCESS(\n        vmaCreateBuffer(vma_allocator_, &amp;staging_buffer_info, &amp;staging_alloc_info, &amp;staging_buffer, &amp;staging_alloc, nullptr))\n\n    VkBufferCreateInfo buffer_info = {\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, // sType\n        nullptr,                              // pNext\n        0,                                    // flags\n        0,                                    // size\n        0,                                    // usage\n        {},                                   // sharingMode\n        0,                                    // queueFamilyIndexCount\n        nullptr                               // pQueueFamilyIndices\n    };\n    buffer_info.size  = sizeof(uint32_t) * num_distortion_indices_;\n    buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT;\n\n    VmaAllocationCreateInfo alloc_info = {};\n    alloc_info.usage                   = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VmaAllocation index_alloc;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;buffer_info, &amp;alloc_info, &amp;index_buffer_, &amp;index_alloc, nullptr))\n\n    void* mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, staging_alloc, &amp;mapped_data))\n    memcpy(mapped_data, distortion_indices_.data(), sizeof(uint32_t) * num_distortion_indices_);\n    vmaUnmapMemory(vma_allocator_, staging_alloc);\n\n    VkCommandBuffer command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    copy_region          = {};\n    copy_region.size                     = sizeof(uint32_t) * num_distortion_indices_;\n    vkCmdCopyBuffer(command_buffer_local, staging_buffer, index_buffer_, 1, &amp;copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::queue_type::GRAPHICS], command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, staging_buffer, staging_alloc);\n\n    deletion_queue_.emplace([=]() {\n        vmaDestroyBuffer(vma_allocator_, index_buffer_, index_alloc);\n    });\n}\n\nvoid timewarp_vk::generate_distortion_data() {\n    // Generate reference HMD and physical body dimensions\n    HMD::get_default_hmd_info(\n        static_cast&lt;int&gt;(display_provider_-&gt;swapchain_extent_.width == 0 ? display_params::width_pixels\n                                                                         : display_provider_-&gt;swapchain_extent_.width),\n        static_cast&lt;int&gt;(display_provider_-&gt;swapchain_extent_.height == 0 ? display_params::height_pixels\n                                                                          : display_provider_-&gt;swapchain_extent_.height),\n        display_params::width_meters, display_params::height_meters, display_params::lens_separation,\n        display_params::meters_per_tan_angle, display_params::aberration, hmd_info_);\n\n    // Construct timewarp meshes and other data\n    build_timewarp(hmd_info_);\n}\n\nvoid timewarp_vk::create_texture_sampler() {\n    VkSamplerCreateInfo sampler_info = {\n        VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, // sType\n        nullptr,                               // pNext\n        0,                                     // flags\n        {},                                    // magFilter\n        {},                                    // minFilter\n        {},                                    // mipmapMode\n        {},                                    // addressModeU\n        {},                                    // addressModeV\n        {},                                    // addressModeW\n        0.f,                                   // mipLodBias\n        0,                                     // anisotropyEnable\n        0.f,                                   // maxAnisotropy\n        0,                                     // compareEnable\n        {},                                    // compareOp\n        0.f,                                   // minLod\n        0.f,                                   // maxLod\n        {},                                    // borderColor\n        0                                      // unnormalizedCoordinates\n    };\n    sampler_info.magFilter = VK_FILTER_LINEAR; // how to interpolate texels that are magnified on screen\n    sampler_info.minFilter = VK_FILTER_LINEAR;\n\n    VkSamplerAddressMode sampler_addressing =\n        clamp_edge_ ? VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE : VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;\n    sampler_info.addressModeU = sampler_addressing;\n    sampler_info.addressModeV = sampler_addressing;\n    sampler_info.addressModeW = sampler_addressing;\n    sampler_info.borderColor  = VK_BORDER_COLOR_INT_OPAQUE_BLACK; // black outside the texture\n\n    sampler_info.anisotropyEnable        = VK_FALSE;\n    sampler_info.unnormalizedCoordinates = VK_FALSE;\n    sampler_info.compareEnable           = VK_FALSE;\n    sampler_info.compareOp               = VK_COMPARE_OP_ALWAYS;\n\n    sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;\n    sampler_info.mipLodBias = 0.f;\n    sampler_info.minLod     = 0.f;\n    sampler_info.maxLod     = 0.f;\n\n    VK_ASSERT_SUCCESS(vkCreateSampler(display_provider_-&gt;vk_device_, &amp;sampler_info, nullptr, &amp;fb_sampler_))\n\n    deletion_queue_.emplace([=]() {\n        vkDestroySampler(display_provider_-&gt;vk_device_, fb_sampler_, nullptr);\n    });\n}\n\nvoid timewarp_vk::create_descriptor_set_layout() {\n    VkDescriptorSetLayoutBinding ubo_layout_binding = {};\n    ubo_layout_binding.binding                      = 0; // binding number in the shader\n    ubo_layout_binding.descriptorType               = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;\n    ubo_layout_binding.descriptorCount              = 1;\n    ubo_layout_binding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT; // shader stages that can access the descriptor\n\n    VkDescriptorSetLayoutBinding sampler_layout_binding = {};\n    sampler_layout_binding.binding                      = 1;\n    sampler_layout_binding.descriptorType               = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n    sampler_layout_binding.descriptorCount              = 1;\n    sampler_layout_binding.stageFlags                   = VK_SHADER_STAGE_FRAGMENT_BIT;\n\n    std::array&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings    = {ubo_layout_binding, sampler_layout_binding};\n    VkDescriptorSetLayoutCreateInfo             layout_info = {};\n    layout_info.sType                                       = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;\n    layout_info.bindingCount                                = static_cast&lt;uint32_t&gt;(bindings.size());\n    layout_info.pBindings                                   = bindings.data(); // array of VkDescriptorSetLayoutBinding structs\n\n    VK_ASSERT_SUCCESS(\n        vkCreateDescriptorSetLayout(display_provider_-&gt;vk_device_, &amp;layout_info, nullptr, &amp;descriptor_set_layout_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyDescriptorSetLayout(display_provider_-&gt;vk_device_, descriptor_set_layout_, nullptr);\n    });\n}\n\nvoid timewarp_vk::create_uniform_buffer() {\n    VkBufferCreateInfo buffer_info = {\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, // sType\n        nullptr,                              // pNext\n        0,                                    // flags\n        0,                                    // size\n        0,                                    // usage\n        {},                                   // sharingMode\n        0,                                    // queueFamilyIndexCount\n        nullptr                               // pQueueFamilyIndices\n    };\n    buffer_info.size  = sizeof(uniform_buffer_object);\n    buffer_info.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;\n\n    VmaAllocationCreateInfo create_info = {};\n    create_info.usage                   = VMA_MEMORY_USAGE_AUTO;\n    create_info.flags         = VMA_ALLOCATION_CREATE_MAPPED_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n    create_info.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;\n\n    VK_ASSERT_SUCCESS(\n        vmaCreateBuffer(vma_allocator_, &amp;buffer_info, &amp;create_info, &amp;uniform_buffer_, &amp;uniform_alloc_, &amp;uniform_alloc_info_))\n    deletion_queue_.emplace([=]() {\n        vmaDestroyBuffer(vma_allocator_, uniform_buffer_, uniform_alloc_);\n    });\n}\n\nvoid timewarp_vk::create_descriptor_pool() {\n    std::array&lt;VkDescriptorPoolSize, 2&gt; pool_sizes = {};\n    pool_sizes[0].type                             = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;\n    pool_sizes[0].descriptorCount                  = buffer_pool_-&gt;image_pool.size() * 2;\n    pool_sizes[1].type                             = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n    pool_sizes[1].descriptorCount                  = buffer_pool_-&gt;image_pool.size() * 2;\n\n    VkDescriptorPoolCreateInfo pool_info = {\n        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, // sType\n        nullptr,                                       // pNext\n        0,                                             // flags\n        0,                                             // maxSets\n        0,                                             // poolSizeCount\n        nullptr                                        // pPoolSizes\n    };\n    pool_info.poolSizeCount = static_cast&lt;uint32_t&gt;(pool_sizes.size());\n    pool_info.pPoolSizes    = pool_sizes.data();\n    pool_info.maxSets       = buffer_pool_-&gt;image_pool.size() * 2;\n\n    VK_ASSERT_SUCCESS(vkCreateDescriptorPool(display_provider_-&gt;vk_device_, &amp;pool_info, nullptr, &amp;descriptor_pool_))\n}\n\nvoid timewarp_vk::create_descriptor_sets() {\n    // single frame in flight for now\n    for (int eye = 0; eye &lt; 2; eye++) {\n        std::vector&lt;VkDescriptorSetLayout&gt; layouts   = {buffer_pool_-&gt;image_pool.size(), descriptor_set_layout_};\n        VkDescriptorSetAllocateInfo        allocInfo = {\n            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, // sType\n            nullptr,                                        // pNext\n            {},                                             // descriptorPool\n            0,                                              // descriptorSetCount\n            nullptr                                         // pSetLayouts\n        };\n        allocInfo.descriptorPool     = descriptor_pool_;\n        allocInfo.descriptorSetCount = buffer_pool_-&gt;image_pool.size();\n        allocInfo.pSetLayouts        = layouts.data();\n\n        descriptor_sets_[eye].resize(buffer_pool_-&gt;image_pool.size());\n        VK_ASSERT_SUCCESS(vkAllocateDescriptorSets(display_provider_-&gt;vk_device_, &amp;allocInfo, descriptor_sets_[eye].data()))\n\n        for (size_t i = 0; i &lt; buffer_pool_-&gt;image_pool.size(); i++) {\n            VkDescriptorBufferInfo buffer_info = {};\n            buffer_info.buffer                 = uniform_buffer_;\n            buffer_info.offset                 = 0;\n            buffer_info.range                  = sizeof(uniform_buffer_object);\n\n            VkDescriptorImageInfo image_info = {};\n            image_info.imageLayout           = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n            image_info.imageView =\n                eye == 0 ? buffer_pool_-&gt;image_pool[i][0].image_view : buffer_pool_-&gt;image_pool[i][1].image_view;\n            image_info.sampler = fb_sampler_;\n\n            std::array&lt;VkWriteDescriptorSet, 2&gt; descriptor_writes = {};\n\n            descriptor_writes[0].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;\n            descriptor_writes[0].dstSet          = descriptor_sets_[eye][i];\n            descriptor_writes[0].dstBinding      = 0;\n            descriptor_writes[0].dstArrayElement = 0;\n            descriptor_writes[0].descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;\n            descriptor_writes[0].descriptorCount = 1;\n            descriptor_writes[0].pBufferInfo     = &amp;buffer_info;\n\n            descriptor_writes[1].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;\n            descriptor_writes[1].dstSet          = descriptor_sets_[eye][i];\n            descriptor_writes[1].dstBinding      = 1;\n            descriptor_writes[1].dstArrayElement = 0;\n            descriptor_writes[1].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n            descriptor_writes[1].descriptorCount = 1;\n            descriptor_writes[1].pImageInfo      = &amp;image_info;\n\n            vkUpdateDescriptorSets(display_provider_-&gt;vk_device_, static_cast&lt;uint32_t&gt;(descriptor_writes.size()),\n                                   descriptor_writes.data(), 0, nullptr);\n        }\n    }\n}\n\nVkPipeline timewarp_vk::create_pipeline(VkRenderPass render_pass, [[maybe_unused]] uint32_t subpass) {\n    if (pipeline_ != VK_NULL_HANDLE) {\n        throw std::runtime_error(\"timewarp_vk::create_pipeline: pipeline already created\");\n    }\n\n    VkDevice device = display_provider_-&gt;vk_device_;\n\n    auto           folder = std::string(SHADER_FOLDER);\n    VkShaderModule vert   = vulkan::create_shader_module(device, vulkan::read_file(folder + \"/tw.vert.spv\"));\n    VkShaderModule frag   = vulkan::create_shader_module(device, vulkan::read_file(folder + \"/tw.frag.spv\"));\n\n    VkPipelineShaderStageCreateInfo vert_stage_info = {};\n    vert_stage_info.sType                           = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;\n    vert_stage_info.stage                           = VK_SHADER_STAGE_VERTEX_BIT;\n    vert_stage_info.module                          = vert;\n    vert_stage_info.pName                           = \"main\";\n\n    VkPipelineShaderStageCreateInfo frag_stage_info = {};\n    frag_stage_info.sType                           = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;\n    frag_stage_info.stage                           = VK_SHADER_STAGE_FRAGMENT_BIT;\n    frag_stage_info.module                          = frag;\n    frag_stage_info.pName                           = \"main\";\n\n    VkPipelineShaderStageCreateInfo shader_stages[] = {vert_stage_info, frag_stage_info};\n\n    auto binding_description    = vertex::get_binding_description();\n    auto attribute_descriptions = vertex::get_attribute_descriptions();\n\n    VkPipelineVertexInputStateCreateInfo vertex_input_info = {};\n    vertex_input_info.sType                                = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;\n    vertex_input_info.vertexBindingDescriptionCount        = 1;\n    vertex_input_info.pVertexBindingDescriptions           = &amp;binding_description;\n    vertex_input_info.vertexAttributeDescriptionCount      = static_cast&lt;uint32_t&gt;(attribute_descriptions.size());\n    vertex_input_info.pVertexAttributeDescriptions         = attribute_descriptions.data();\n\n    VkPipelineInputAssemblyStateCreateInfo input_assembly = {};\n    input_assembly.sType                                  = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;\n    input_assembly.topology                               = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;\n\n    VkPipelineRasterizationStateCreateInfo rasterizer = {};\n    rasterizer.sType                                  = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;\n    rasterizer.polygonMode                            = VK_POLYGON_MODE_FILL;\n    rasterizer.cullMode                               = VK_CULL_MODE_NONE;\n    rasterizer.frontFace                              = VK_FRONT_FACE_COUNTER_CLOCKWISE;\n    rasterizer.lineWidth                              = 1.0f;\n    rasterizer.depthClampEnable                       = VK_FALSE;\n    rasterizer.rasterizerDiscardEnable                = VK_FALSE;\n    rasterizer.depthBiasEnable                        = VK_FALSE;\n\n    // disable multisampling\n    VkPipelineMultisampleStateCreateInfo multisampling = {};\n    multisampling.sType                                = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;\n    multisampling.rasterizationSamples                 = VK_SAMPLE_COUNT_1_BIT;\n    multisampling.sampleShadingEnable                  = VK_FALSE;\n\n    VkPipelineColorBlendAttachmentState color_blend_attachment = {};\n    color_blend_attachment.colorWriteMask =\n        VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;\n    color_blend_attachment.blendEnable = VK_FALSE;\n\n    // disable blending\n    VkPipelineColorBlendStateCreateInfo color_blending = {};\n    color_blending.sType                               = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;\n    color_blending.attachmentCount                     = 1;\n    color_blending.pAttachments                        = &amp;color_blend_attachment;\n\n    // disable depth testing\n    VkPipelineDepthStencilStateCreateInfo depth_stencil = {};\n    depth_stencil.sType                                 = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;\n    depth_stencil.depthTestEnable                       = VK_FALSE;\n\n    // use dynamic state for viewport / scissor\n    std::vector&lt;VkDynamicState&gt; dynamic_states = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};\n\n    VkPipelineDynamicStateCreateInfo dynamic_state_create_info = {};\n    dynamic_state_create_info.sType                            = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;\n    dynamic_state_create_info.dynamicStateCount                = static_cast&lt;uint32_t&gt;(dynamic_states.size());\n    dynamic_state_create_info.pDynamicStates                   = dynamic_states.data();\n\n    VkPipelineViewportStateCreateInfo viewport_state_create_info = {};\n    viewport_state_create_info.sType                             = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;\n    viewport_state_create_info.viewportCount                     = 1;\n    viewport_state_create_info.scissorCount                      = 1;\n\n    VkPipelineLayoutCreateInfo pipeline_layout_info = {};\n    pipeline_layout_info.sType                      = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;\n    pipeline_layout_info.setLayoutCount             = 1;\n    pipeline_layout_info.pSetLayouts                = &amp;descriptor_set_layout_;\n\n    VkPushConstantRange push_constant = {};\n    push_constant.stageFlags          = VK_SHADER_STAGE_VERTEX_BIT;\n    push_constant.offset              = 0;\n    push_constant.size                = sizeof(uint32_t);\n\n    pipeline_layout_info.pushConstantRangeCount = 1;\n    pipeline_layout_info.pPushConstantRanges    = &amp;push_constant;\n\n    VK_ASSERT_SUCCESS(vkCreatePipelineLayout(device, &amp;pipeline_layout_info, nullptr, &amp;pipeline_layout_))\n\n    VkGraphicsPipelineCreateInfo pipeline_info = {};\n    pipeline_info.sType                        = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;\n    pipeline_info.stageCount                   = 2;\n    pipeline_info.pStages                      = shader_stages;\n    pipeline_info.pVertexInputState            = &amp;vertex_input_info;\n    pipeline_info.pInputAssemblyState          = &amp;input_assembly;\n    pipeline_info.pViewportState               = &amp;viewport_state_create_info;\n    pipeline_info.pRasterizationState          = &amp;rasterizer;\n    pipeline_info.pMultisampleState            = &amp;multisampling;\n    pipeline_info.pColorBlendState             = &amp;color_blending;\n    pipeline_info.pDepthStencilState           = nullptr;\n    pipeline_info.pDynamicState                = &amp;dynamic_state_create_info;\n\n    pipeline_info.layout     = pipeline_layout_;\n    pipeline_info.renderPass = render_pass;\n    pipeline_info.subpass    = 0;\n\n    VK_ASSERT_SUCCESS(vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipeline_info, nullptr, &amp;pipeline_))\n\n    vkDestroyShaderModule(device, vert, nullptr);\n    vkDestroyShaderModule(device, frag, nullptr);\n    return pipeline_;\n}\n\nvoid timewarp_vk::build_timewarp(HMD::hmd_info_t&amp; hmd_info) {\n    // Calculate the number of vertices+indices in the distortion mesh.\n    num_distortion_vertices_ = (hmd_info.eye_tiles_high + 1) * (hmd_info.eye_tiles_wide + 1);\n    num_distortion_indices_  = hmd_info.eye_tiles_high * hmd_info.eye_tiles_wide * 6;\n\n    // Allocate memory for the elements/indices array.\n    distortion_indices_.resize(num_distortion_indices_);\n\n    // This is just a simple grid/plane index array, nothing fancy.\n    // Same for both eye distortions, too!\n    for (int y = 0; y &lt; hmd_info.eye_tiles_high; y++) {\n        for (int x = 0; x &lt; hmd_info.eye_tiles_wide; x++) {\n            const int offset = (y * hmd_info.eye_tiles_wide + x) * 6;\n\n            distortion_indices_[offset + 0] = ((y + 0) * (hmd_info.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 1] = ((y + 1) * (hmd_info.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 2] = ((y + 0) * (hmd_info.eye_tiles_wide + 1) + (x + 1));\n\n            distortion_indices_[offset + 3] = ((y + 0) * (hmd_info.eye_tiles_wide + 1) + (x + 1));\n            distortion_indices_[offset + 4] = ((y + 1) * (hmd_info.eye_tiles_wide + 1) + (x + 0));\n            distortion_indices_[offset + 5] = ((y + 1) * (hmd_info.eye_tiles_wide + 1) + (x + 1));\n        }\n    }\n\n    // There are `num_distortion_vertices_` distortion coordinates for each color channel (3) of each eye (2).\n    // These are NOT the coordinates of the distorted vertices. They are *coefficients* that will be used to\n    // offset the UV coordinates of the distortion mesh.\n    std::array&lt;std::array&lt;std::vector&lt;HMD::mesh_coord2d_t&gt;, HMD::NUM_COLOR_CHANNELS&gt;, HMD::NUM_EYES&gt; distort_coords;\n    for (auto&amp; eye_coords : distort_coords) {\n        for (auto&amp; channel_coords : eye_coords) {\n            channel_coords.resize(num_distortion_vertices_);\n        }\n    }\n    HMD::build_distortion_meshes(distort_coords, hmd_info);\n\n    // Allocate memory for position and UV CPU buffers.\n    const std::size_t num_elems_pos_uv = HMD::NUM_EYES * num_distortion_vertices_;\n    distortion_positions_.resize(num_elems_pos_uv);\n    distortion_uv0_.resize(num_elems_pos_uv);\n    distortion_uv1_.resize(num_elems_pos_uv);\n    distortion_uv2_.resize(num_elems_pos_uv);\n\n    for (int eye = 0; eye &lt; HMD::NUM_EYES; eye++) {\n        for (int y = 0; y &lt;= hmd_info.eye_tiles_high; y++) {\n            for (int x = 0; x &lt;= hmd_info.eye_tiles_wide; x++) {\n                const int index = y * (hmd_info.eye_tiles_wide + 1) + x;\n\n                // Set the physical distortion mesh coordinates. These are rectangular/grid-like, not distorted.\n                // The distortion is handled by the UVs, not the actual mesh coordinates!\n                distortion_positions_[eye * num_distortion_vertices_ + index].x =\n                    (-1.0f + 2 * (static_cast&lt;float&gt;(x) / static_cast&lt;float&gt;(hmd_info.eye_tiles_wide)));\n\n                distortion_positions_[eye * num_distortion_vertices_ + index].y = (input_texture_external_ ? -1.0f : 1.0f) *\n                    (-1.0f +\n                     2.0f * (static_cast&lt;float&gt;(hmd_info.eye_tiles_high - y) / static_cast&lt;float&gt;(hmd_info.eye_tiles_high)) *\n                         (static_cast&lt;float&gt;(hmd_info.eye_tiles_high * hmd_info.tile_pixels_high) /\n                          static_cast&lt;float&gt;(hmd_info.display_pixels_high)));\n                distortion_positions_[eye * num_distortion_vertices_ + index].z = 0.0f;\n\n                // Use the previously-calculated distort_coords to set the UVs on the distortion mesh\n                distortion_uv0_[eye * num_distortion_vertices_ + index].u = distort_coords[eye][0][index].x;\n                distortion_uv0_[eye * num_distortion_vertices_ + index].v = distort_coords[eye][0][index].y;\n                distortion_uv1_[eye * num_distortion_vertices_ + index].u = distort_coords[eye][1][index].x;\n                distortion_uv1_[eye * num_distortion_vertices_ + index].v = distort_coords[eye][1][index].y;\n                distortion_uv2_[eye * num_distortion_vertices_ + index].u = distort_coords[eye][2][index].x;\n                distortion_uv2_[eye * num_distortion_vertices_ + index].v = distort_coords[eye][2][index].y;\n            }\n        }\n\n        // Construct perspective projection matrix according to Unreal -- different FOVs not supported here.\n        math_util::unreal_projection(&amp;basic_projection_[eye], index_params::fov_left[eye], index_params::fov_right[eye],\n                                     index_params::fov_up[eye], index_params::fov_down[eye]);\n    }\n}\n\n/* Calculate timewarp transform from projection matrix, view matrix, etc */\nvoid timewarp_vk::calculate_timewarp_transform(Eigen::Matrix4f&amp; transform, const Eigen::Matrix4f&amp; render_projection_matrix,\n                                               const Eigen::Matrix4f&amp; render_view_matrix,\n                                               const Eigen::Matrix4f&amp; new_view_matrix) {\n    // Eigen stores matrices internally in column-major order.\n    // However, the (i,j) accessors are row-major (i.e, the first argument\n    // is which row, and the second argument is which column.)\n    Eigen::Matrix4f tex_coord_projection;\n    tex_coord_projection &lt;&lt; 0.5f * render_projection_matrix(0, 0), 0.0f, 0.5f * render_projection_matrix(0, 2) - 0.5f, 0.0f,\n        0.0f, -0.5f * render_projection_matrix(1, 1), 0.5f * render_projection_matrix(1, 2) - 0.5f, 0.0f, 0.0f, 0.0f, -1.0f,\n        0.0f, 0.0f, 0.0f, 0.0f, 1.0f;\n\n    // Calculate the delta between the view matrix used for rendering and\n    // a more recent or predicted view matrix based on new sensor input.\n    Eigen::Matrix4f inverse_render_view_matrix = render_view_matrix.inverse();\n\n    Eigen::Matrix4f delta_view_matrix = inverse_render_view_matrix * new_view_matrix;\n\n    delta_view_matrix(0, 3) = 0.0f;\n    delta_view_matrix(1, 3) = 0.0f;\n    delta_view_matrix(2, 3) = 0.0f;\n\n    // Accumulate the transforms.\n    transform = tex_coord_projection * delta_view_matrix;\n}\n</code></pre>"},{"location":"api/timewarp__vk_8hpp/","title":"File timewarp_vk.hpp","text":"<p>FileList &gt; plugins &gt; timewarp_vk &gt; timewarp_vk.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/hmd.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include &lt;stack&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"api/timewarp__vk_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/timewarp__vk_8hpp/#classes","title":"Classes","text":"Type Name class timewarp_vk <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/timewarp_vk/timewarp_vk.hpp</code></p>"},{"location":"api/timewarp__vk_8hpp_source/","title":"File timewarp_vk.hpp","text":"<p>File List &gt; plugins &gt; timewarp_vk &gt; timewarp_vk.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/hmd.hpp\"\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n\n#include &lt;stack&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\nnamespace ILLIXR {\n\nclass timewarp_vk : public vulkan::timewarp {\npublic:\n    explicit timewarp_vk(const phonebook* pb);\n    void initialize();\n    void setup(VkRenderPass render_pass, uint32_t subpass,\n               std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool,\n               bool                                                              input_texture_vulkan_coordinates_in) override;\n    void partial_destroy();\n    void update_uniforms(const data_format::pose_type&amp; render_pose) override;\n    void record_command_buffer(VkCommandBuffer commandBuffer, VkFramebuffer framebuffer, int buffer_ind, bool left) override;\n    void destroy() override;\n\nprivate:\n    void create_vertex_buffer();\n    void create_index_buffer();\n    void generate_distortion_data();\n    void create_texture_sampler();\n    void create_descriptor_set_layout();\n    void create_uniform_buffer();\n    void create_descriptor_pool();\n    void create_descriptor_sets();\n\n    bool is_external() override {\n        return false;\n    }\n\n    VkPipeline  create_pipeline(VkRenderPass render_pass, [[maybe_unused]] uint32_t subpass);\n    void        build_timewarp(HMD::hmd_info_t&amp; hmd_info);\n    static void calculate_timewarp_transform(Eigen::Matrix4f&amp; transform, const Eigen::Matrix4f&amp; render_projection_matrix,\n                                             const Eigen::Matrix4f&amp; render_view_matrix, const Eigen::Matrix4f&amp; new_view_matrix);\n\n    const phonebook* const                                      phonebook_;\n    const std::shared_ptr&lt;switchboard&gt;                          switchboard_;\n    const std::shared_ptr&lt;data_format::pose_prediction&gt;         pose_prediction_;\n    switchboard::reader&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_;\n    bool                                                        disable_warp_     = false;\n    std::shared_ptr&lt;vulkan::display_provider&gt;                   display_provider_ = nullptr;\n    std::mutex                                                  setup_mutex_;\n\n    bool initialized_            = false;\n    bool input_texture_external_ = false;\n\n    // Vulkan resources\n    std::stack&lt;std::function&lt;void()&gt;&gt; deletion_queue_;\n    VmaAllocator                      vma_allocator_{};\n\n    uint64_t frame_count_ = 0;\n\n    size_t swapchain_width_  = 0;\n    size_t swapchain_height_ = 0;\n\n    std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; buffer_pool_;\n\n    VkSampler                                   fb_sampler_{};\n    bool                                        clamp_edge_ = false;\n    VkDescriptorPool                            descriptor_pool_{};\n    VkDescriptorSetLayout                       descriptor_set_layout_{};\n    std::array&lt;std::vector&lt;VkDescriptorSet&gt;, 2&gt; descriptor_sets_;\n\n    VkRenderPass timewarp_render_pass_{};\n\n    VkPipelineLayout  pipeline_layout_{};\n    VkBuffer          uniform_buffer_{};\n    VmaAllocation     uniform_alloc_{};\n    VmaAllocationInfo uniform_alloc_info_{};\n\n    VkCommandPool                    command_pool_{};\n    [[maybe_unused]] VkCommandBuffer command_buffer_{};\n\n    VkBuffer vertex_buffer_{};\n    VkBuffer index_buffer_{};\n\n    // distortion data\n    HMD::hmd_info_t hmd_info_{};\n\n    uint32_t                         num_distortion_vertices_{};\n    uint32_t                         num_distortion_indices_{};\n    Eigen::Matrix4f                  basic_projection_[2];\n    std::vector&lt;HMD::mesh_coord3d_t&gt; distortion_positions_;\n    std::vector&lt;HMD::uv_coord_t&gt;     distortion_uv0_;\n    std::vector&lt;HMD::uv_coord_t&gt;     distortion_uv1_;\n    std::vector&lt;HMD::uv_coord_t&gt;     distortion_uv2_;\n\n    std::vector&lt;uint32_t&gt; distortion_indices_;\n\n    // metrics\n    std::atomic&lt;uint32_t&gt; num_record_calls_{0};\n    std::atomic&lt;uint32_t&gt; num_update_uniforms_calls_{0};\n\n    friend class timewarp_vk_plugin;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/topic__config_8hpp/","title":"File topic_config.hpp","text":"<p>FileList &gt; illixr &gt; network &gt; topic_config.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> </ul>"},{"location":"api/topic__config_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace network"},{"location":"api/topic__config_8hpp/#classes","title":"Classes","text":"Type Name struct topic_config <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/network/topic_config.hpp</code></p>"},{"location":"api/topic__config_8hpp_source/","title":"File topic_config.hpp","text":"<p>File List &gt; illixr &gt; network &gt; topic_config.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;optional&gt;\n\nnamespace ILLIXR::network {\n\nstruct topic_config {\n    enum priority_type { LOWEST, LOW, MEDIUM, HIGH, HIGHEST };\n\n    enum packetization_type { IMMEDIATE, DEFAULT, SUGGEST_LATENCY };\n\n    priority_type                                         priority           = MEDIUM;\n    bool                                                  retransmit         = false;\n    bool                                                  allow_out_of_order = false;\n    packetization_type                                    packetization      = DEFAULT;\n    std::optional&lt;std::chrono::duration&lt;long, std::nano&gt;&gt; latency;\n\n    enum SerializationMethod { BOOST, PROTOBUF } serialization_method;\n};\n\n} // namespace ILLIXR::network\n</code></pre>"},{"location":"api/unit_8hpp/","title":"File unit.hpp","text":"<p>FileList &gt; data_format &gt; unit.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/unit_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format namespace units <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/unit.hpp</code></p>"},{"location":"api/unit_8hpp_source/","title":"File unit.hpp","text":"<p>File List &gt; data_format &gt; unit.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nnamespace ILLIXR::data_format::units {\nenum eyes : int { LEFT_EYE = 0, RIGHT_EYE = 1 };\n\nenum measurement_unit : int {\n    MILLIMETER = 0,\n    CENTIMETER = 1,\n    METER      = 2,\n    INCH       = 3,\n    FOOT       = 4,\n    PERCENT    = 5,\n    PIXEL      = 6,\n    UNSET      = 7\n};\n\nconst std::map&lt;measurement_unit, const std::string&gt; unit_str{{MILLIMETER, \"mm\"}, {CENTIMETER, \"cm\"}, {METER, \"m\"},\n                                                             {INCH, \"in\"},       {FOOT, \"ft\"},       {PERCENT, \"%\"},\n                                                             {PIXEL, \"px\"},      {UNSET, \"unitless\"}};\n\nconstexpr int last_convertable_unit = FOOT;\n// mm          cm          m            ft                 in\nconstexpr float conversion_factor[5][5] = {\n    {1., 0.1, .001, 1. / (25.4 * 12.), 1. / 25.4},       // mm\n    {10., 1., .01, 1. / (2.54 * 12.), 1. / 2.54},        // cm\n    {1000., 100., 1., 100. / (2.54 * 12.), 100. / 2.54}, // m\n    {12. * 25.4, 12. * 2.54, 12. * .0254, 1., 12.},      // ft\n    {25.4, 2.54, .0254, 1. / 12., 1.}                    // in\n};\n\ninline float convert(const int from, const int to, float val) {\n    return conversion_factor[from][to] * val;\n}\n\ninline eyes non_primary(eyes eye) {\n    if (eye == LEFT_EYE)\n        return RIGHT_EYE;\n    return LEFT_EYE;\n}\n\n} // namespace ILLIXR::data_format::units\n</code></pre>"},{"location":"api/utils_2CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/utils_2CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name include add_library (illixr_hmd_gl OBJECT hmd.cpp hmd. hpp)  find_package (glfw3 QUIET)  include target_compile_definitions (illixr_hmd_gl PUBLIC USE_GL)  include target_link_libraries (illixr_vulkan_utils PUBLIC spdlog::spdlog)"},{"location":"api/utils_2CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/utils_2CMakeLists_8txt/#function-add_library","title":"function add_library","text":"<pre><code>include add_library (\n    illixr_hmd_gl OBJECT hmd.cpp hmd. hpp\n) \n</code></pre>"},{"location":"api/utils_2CMakeLists_8txt/#function-find_package","title":"function find_package","text":"<pre><code>find_package (\n    glfw3 QUIET\n) \n</code></pre>"},{"location":"api/utils_2CMakeLists_8txt/#function-target_compile_definitions","title":"function target_compile_definitions","text":"<pre><code>include target_compile_definitions (\n    illixr_hmd_gl PUBLIC USE_GL\n) \n</code></pre>"},{"location":"api/utils_2CMakeLists_8txt/#function-target_link_libraries","title":"function target_link_libraries","text":"<pre><code>include target_link_libraries (\n    illixr_vulkan_utils PUBLIC spdlog::spdlog\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/CMakeLists.txt</code></p>"},{"location":"api/utils_2CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>find_package(glfw3 QUIET)\nif (NOT glfw3_FOUND)\n    pkg_search_module(glfw3 REQUIRED glfw3)\nendif ()\n\nfind_package(OpenGL REQUIRED)\n\n\nadd_library(illixr_hmd OBJECT hmd.cpp\n            hmd.hpp\n)\n\ntarget_include_directories(illixr_hmd PUBLIC ${CMAKE_SOURCE_DIR}/include)\n\nadd_library(illixr_hmd_gl OBJECT hmd.cpp\n            hmd.hpp\n)\n\ntarget_include_directories(illixr_hmd_gl PUBLIC ${CMAKE_SOURCE_DIR}/include)\ntarget_compile_definitions(illixr_hmd_gl PUBLIC USE_GL)\n\nadd_library(illixr_vulkan_utils STATIC vulkan_utils.cpp\n            vulkan_utils.hpp\n)\n\ntarget_include_directories(illixr_vulkan_utils PUBLIC ${CMAKE_SOURCE_DIR}/include)\ntarget_link_libraries(illixr_vulkan_utils PUBLIC spdlog::spdlog)\n\nadd_library(illixr_imgui STATIC\n            imgui/imconfig.h\n            imgui/imgui.cpp\n            imgui/imgui_demo.cpp\n            imgui/imgui_draw.cpp\n            imgui/imgui.h\n            imgui/imgui_internal.h\n            imgui/imgui_tables.cpp\n            imgui/imgui_widgets.cpp\n            imgui/imstb_rectpack.h\n            imgui/imstb_textedit.h\n            imgui/imstb_truetype.h\n            imgui/backends/imgui_impl_glfw.cpp\n            imgui/backends/imgui_impl_glfw.h\n            #imgui/backends/imgui_impl_glut.cpp\n            #imgui/backends/imgui_impl_glut.h\n            imgui/backends/imgui_impl_opengl3.cpp\n            imgui/backends/imgui_impl_opengl3.h\n            imgui/backends/imgui_impl_opengl3_loader.h\n            #imgui/backends/imgui_impl_sdl2.cpp\n            #imgui/backends/imgui_impl_sdl2.h\n            #imgui/backends/imgui_impl_sdl3.cpp\n            #imgui/backends/imgui_impl_sdl3.h\n            #imgui/backends/imgui_impl_sdlrenderer2.cpp\n            #imgui/backends/imgui_impl_sdlrenderer2.h\n            #imgui/backends/imgui_impl_sdlrenderer3.cpp\n            #imgui/backends/imgui_impl_sdlrenderer3.h\n            #imgui/backends/imgui_impl_vulkan.cpp\n            #imgui/backends/imgui_impl_vulkan.h\n            imgui/misc/cpp/imgui_stdlib.cpp\n            imgui/misc/cpp/imgui_stdlib.h\n            #imgui/misc/fonts/binary_to_compressed_c.cpp\n            #imgui/misc/freetype/imgui_freetype.cpp\n            #imgui/misc/freetype/imgui_freetype.h\n)\n\ntarget_include_directories(illixr_imgui PUBLIC\n                           ${glfw3_INCLUDE_DIRS}\n                           ${gl_INCLUDE_DIRS}\n                           ${X11_INCLUDE_DIR}\n                           ${GLEW_INCLUDE_DIR}\n                           ${GLU_INCLUDE_DIR}\n)\ntarget_link_libraries(illixr_imgui PUBLIC\n                      ${X11_LIBRARIES}\n                      ${GLEW_LIBRARIES}\n                      ${glu_LDFLAGS}\n                      glfw\n                      OpenGL::GL\n)\n</code></pre>"},{"location":"api/utils_2hmd_8hpp/","title":"File hmd.hpp","text":"<p>FileList &gt; utils &gt; hmd.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/utils_2hmd_8hpp/#classes","title":"Classes","text":"Type Name class HMD struct hmd_info_t struct mesh_coord2d_t struct mesh_coord3d_t struct uv_coord_t"},{"location":"api/utils_2hmd_8hpp/#macros","title":"Macros","text":"Type Name define FLOAT <code>float</code>"},{"location":"api/utils_2hmd_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/utils_2hmd_8hpp/#define-float","title":"define FLOAT","text":"<pre><code>#define FLOAT `float`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/hmd.hpp</code></p>"},{"location":"api/utils_2hmd_8hpp_source/","title":"File hmd.hpp","text":"<p>File List &gt; utils &gt; hmd.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;array&gt;\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#ifdef USE_GL\n    #include &lt;GL/gl.h&gt;\n    #define FLOAT GLfloat\n#else\n    #define FLOAT float\n#endif\n// HMD utility class for warp mesh structs, spline math, etc\nclass HMD {\npublic:\n    static constexpr int NUM_EYES           = 2;\n    static constexpr int NUM_COLOR_CHANNELS = 3;\n\n    struct mesh_coord2d_t {\n        FLOAT x;\n        FLOAT y;\n    };\n\n    struct [[maybe_unused]] mesh_coord3d_t {\n        FLOAT x;\n        FLOAT y;\n        FLOAT z;\n    };\n\n    struct [[maybe_unused]] uv_coord_t {\n        FLOAT u;\n        FLOAT v;\n    };\n\n    struct hmd_info_t {\n        [[maybe_unused]] int display_pixels_wide;\n        int                  display_pixels_high;\n        int                  tile_pixels_wide;\n        int                  tile_pixels_high;\n        int                  eye_tiles_wide;\n        int                  eye_tiles_high;\n        int                  visible_pixels_wide;\n        int                  visible_pixels_high;\n        float                visible_meters_wide;\n        float                visible_meters_high;\n        float                lens_separation_in_meters;\n        float                meters_per_tan_angle_at_center;\n        int                  num_knots;\n        float                K[11];\n        float                chromatic_aberration[4];\n    };\n\n    static float                 max_float(float x, float y);\n    static float                 min_float(float x, float y);\n    static float                 evaluate_catmull_rom_spline(float value, const float* K, int num_knots);\n    [[maybe_unused]] static void get_default_hmd_info(const int display_pixels_wide, const int display_pixels_high,\n                                                      const float display_meters_wide, const float display_meters_high,\n                                                      const float lens_separation, const float meters_per_tan_angle,\n                                                      const float aberration[4], hmd_info_t&amp; hmd_info);\n    [[maybe_unused]] static void\n    build_distortion_meshes(std::array&lt;std::array&lt;std::vector&lt;mesh_coord2d_t&gt;, NUM_COLOR_CHANNELS&gt;, NUM_EYES&gt;&amp; distort_coords,\n                            hmd_info_t&amp;                                                                        hmd_info);\n};\n</code></pre>"},{"location":"api/utils_2serializable__data_8hpp/","title":"File serializable_data.hpp","text":"<p>FileList &gt; utils &gt; serializable_data.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/frame.hpp\"</code></li> <li><code>#include &lt;boost/serialization/binary_object.hpp&gt;</code></li> </ul>"},{"location":"api/utils_2serializable__data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace boost namespace serialization <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/serializable_data.hpp</code></p>"},{"location":"api/utils_2serializable__data_8hpp_source/","title":"File serializable_data.hpp","text":"<p>File List &gt; utils &gt; serializable_data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/frame.hpp\"\n\n#include &lt;boost/serialization/binary_object.hpp&gt;\n\nnamespace boost::serialization {\ntemplate&lt;class Archive&gt;\n[[maybe_unused]] void serialize(Archive&amp; ar, ILLIXR::time_point&amp; tp, const unsigned int version) {\n    (void) version;\n    ar&amp; boost::serialization::make_binary_object(&amp;tp.time_since_epoch_, sizeof(tp.time_since_epoch_));\n}\n\ntemplate&lt;class Archive&gt;\nvoid serialize(Archive&amp; ar, ILLIXR::data_format::pose_type&amp; pose, const unsigned int version) {\n    (void) version;\n    ar&amp; boost::serialization::base_object&lt;ILLIXR::switchboard::event&gt;(pose);\n    ar &amp; pose.sensor_time;\n    ar&amp; boost::serialization::make_array(pose.position.derived().data(), pose.position.size());\n    ar&amp; boost::serialization::make_array(pose.orientation.coeffs().data(), pose.orientation.coeffs().size());\n}\n\ntemplate&lt;class Archive&gt;\n[[maybe_unused]] void serialize(Archive&amp; ar, ILLIXR::data_format::fast_pose_type&amp; pose, const unsigned int version) {\n    (void) version;\n    ar&amp; boost::serialization::base_object&lt;ILLIXR::switchboard::event&gt;(pose);\n    ar &amp; pose.pose;\n    ar &amp; pose.predict_computed_time;\n    ar &amp; pose.predict_target_time;\n}\n} // namespace boost::serialization\n\nBOOST_CLASS_EXPORT_KEY(ILLIXR::switchboard::event)\nBOOST_CLASS_EXPORT_KEY(ILLIXR::data_format::compressed_frame)\nBOOST_CLASS_EXPORT_KEY(ILLIXR::data_format::pose_type)\nBOOST_CLASS_EXPORT_KEY(ILLIXR::data_format::fast_pose_type)\n</code></pre>"},{"location":"api/utils_2vulkan__utils_8hpp/","title":"File vulkan_utils.hpp","text":"<p>FileList &gt; utils &gt; vulkan_utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"api/utils_2vulkan__utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace vulkan"},{"location":"api/utils_2vulkan__utils_8hpp/#classes","title":"Classes","text":"Type Name struct queue struct queue_families struct swapchain_details"},{"location":"api/utils_2vulkan__utils_8hpp/#macros","title":"Macros","text":"Type Name define VK_ASSERT_SUCCESS (x) <code>/* multi line expression */</code> define VK_GET_PROC_ADDR (instance, name) <code>((PFN\\_##name) vkGetInstanceProcAddr(instance, #name))</code>"},{"location":"api/utils_2vulkan__utils_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/utils_2vulkan__utils_8hpp/#define-vk_assert_success","title":"define VK_ASSERT_SUCCESS","text":"<pre><code>#define VK_ASSERT_SUCCESS (\n    x\n) `/* multi line expression */`\n</code></pre>"},{"location":"api/utils_2vulkan__utils_8hpp/#define-vk_get_proc_addr","title":"define VK_GET_PROC_ADDR","text":"<pre><code>#define VK_GET_PROC_ADDR (\n    instance,\n    name\n) `((PFN_##name) vkGetInstanceProcAddr(instance, #name))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/vulkan_utils.hpp</code></p>"},{"location":"api/utils_2vulkan__utils_8hpp_source/","title":"File vulkan_utils.hpp","text":"<p>File List &gt; utils &gt; vulkan_utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\n#define VK_ASSERT_SUCCESS(x)                                                                          \\\n    {                                                                                                 \\\n        VkResult result = (x);                                                                        \\\n        if (result != VK_SUCCESS) {                                                                   \\\n            spdlog::get(\"illixr\")-&gt;debug(\"[Vulkan] error: {}\", ILLIXR::vulkan::error_string(result)); \\\n            throw std::runtime_error(\"Vulkan error: \" + ILLIXR::vulkan::error_string(result));        \\\n        }                                                                                             \\\n    }\n\n#define VK_GET_PROC_ADDR(instance, name) ((PFN_##name) vkGetInstanceProcAddr(instance, #name))\nVK_DEFINE_HANDLE(VmaAllocator)\n\nnamespace ILLIXR::vulkan {\nstruct queue_families {\n    std::optional&lt;uint32_t&gt; graphics_family;\n    std::optional&lt;uint32_t&gt; present_family;\n    std::optional&lt;uint32_t&gt; encode_family;\n    std::optional&lt;uint32_t&gt; decode_family;\n    std::optional&lt;uint32_t&gt; dedicated_transfer;\n    std::optional&lt;uint32_t&gt; compute_family;\n\n    [[maybe_unused]] [[nodiscard]] bool has_presentation() const {\n        return graphics_family.has_value() &amp;&amp; present_family.has_value();\n    }\n\n    [[nodiscard]] bool has_compression() const {\n        return graphics_family &amp;&amp; encode_family.has_value() &amp;&amp; decode_family.has_value();\n    }\n};\n\nstruct queue {\n    enum queue_type {\n        GRAPHICS,\n        DEDICATED_TRANSFER,\n        PRESENT,\n        ENCODE,\n        DECODE,\n        COMPUTE,\n    };\n\n    VkQueue                     vk_queue;\n    uint32_t                    family;\n    queue_type                  type;\n    std::shared_ptr&lt;std::mutex&gt; mutex;\n};\n\nstruct swapchain_details {\n    VkSurfaceCapabilitiesKHR        capabilities{};\n    std::vector&lt;VkSurfaceFormatKHR&gt; formats;\n    std::vector&lt;VkPresentModeKHR&gt;   present_modes;\n};\n\nstd::string error_string(VkResult err_code);\n\nVkShaderModule create_shader_module(VkDevice device, std::vector&lt;char&gt;&amp;&amp; code);\n\nVkSemaphore create_timeline_semaphore(VkDevice device, int initial_value = 0,\n                                      VkExportSemaphoreCreateInfo* export_semaphore_create_info = nullptr);\n\n[[maybe_unused]] void wait_timeline_semaphore(VkDevice device, VkSemaphore semaphore, uint64_t value);\n\nvoid wait_timeline_semaphores(VkDevice device, const std::map&lt;VkSemaphore, uint64_t&gt;&amp; semaphores);\n\nVmaAllocator create_vma_allocator(VkInstance vk_instance, VkPhysicalDevice vk_physical_device, VkDevice vk_device);\n\nVkCommandBuffer begin_one_time_command(VkDevice vk_device, VkCommandPool vk_command_pool);\n\nvoid end_one_time_command(VkDevice vk_device, VkCommandPool vk_command_pool, const queue&amp; q, VkCommandBuffer vk_command_buffer);\n\nVkCommandPool create_command_pool(VkDevice device, uint32_t queue_family_index);\n\nVkCommandBuffer create_command_buffer(VkDevice device, VkCommandPool command_pool);\n\nVkResult locked_queue_submit(queue&amp; q, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);\n\nstd::vector&lt;char&gt; read_file(const std::string&amp; path);\n\nvoid copy_buffer_to_image(VkDevice vk_device, queue q, VkCommandPool vk_command_pool, VkBuffer buffer, VkImage image,\n                          uint32_t width, uint32_t height);\n\nswapchain_details query_swapchain_details(VkPhysicalDevice const&amp; physical_device, VkSurfaceKHR const&amp; vk_surface);\n\nqueue_families find_queue_families(VkPhysicalDevice const&amp; physical_device, VkSurfaceKHR const&amp; vk_surface,\n                                   bool no_present = false);\n\nVkImageView create_image_view(VkDevice device, VkImage image, VkFormat format, VkImageAspectFlags aspect_flags);\n} // namespace ILLIXR::vulkan\n</code></pre>"},{"location":"api/utils_8hpp/","title":"File utils.hpp","text":"<p>FileList &gt; pose_lookup &gt; utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/utils_8hpp/#public-functions","title":"Public Functions","text":"Type Name void assign_matrix (std::deque&lt; float &gt; &amp; parameters, EigenType &amp; eigen_data)  void load_align_parameters (const std::string &amp; path, Eigen::Matrix3f &amp; align_rot, Eigen::Vector3f &amp; align_trans, Eigen::Vector4f &amp; align_quat, double &amp; align_scale)  Eigen::Matrix&lt; float, 4, 1 &gt; ori_inv (Eigen::Matrix&lt; float, 4, 1 &gt; q)  Eigen::Matrix&lt; float, 4, 1 &gt; ori_multiply (const Eigen::Matrix&lt; float, 4, 1 &gt; &amp; q, const Eigen::Matrix&lt; float, 4, 1 &gt; &amp; p)  void read_line (std::string stream, std::deque&lt; float &gt; &amp; parameters)  Eigen::Matrix&lt; float, 3, 3 &gt; skew_x (const Eigen::Matrix&lt; float, 3, 1 &gt; &amp; w)"},{"location":"api/utils_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/utils_8hpp/#function-assign_matrix","title":"function assign_matrix","text":"<pre><code>template&lt;typename EigenType&gt;\nvoid assign_matrix (\n    std::deque&lt; float &gt; &amp; parameters,\n    EigenType &amp; eigen_data\n) \n</code></pre>"},{"location":"api/utils_8hpp/#function-load_align_parameters","title":"function load_align_parameters","text":"<pre><code>void load_align_parameters (\n    const std::string &amp; path,\n    Eigen::Matrix3f &amp; align_rot,\n    Eigen::Vector3f &amp; align_trans,\n    Eigen::Vector4f &amp; align_quat,\n    double &amp; align_scale\n) \n</code></pre>"},{"location":"api/utils_8hpp/#function-ori_inv","title":"function ori_inv","text":"<pre><code>Eigen::Matrix&lt; float, 4, 1 &gt; ori_inv (\n    Eigen::Matrix&lt; float, 4, 1 &gt; q\n) \n</code></pre>"},{"location":"api/utils_8hpp/#function-ori_multiply","title":"function ori_multiply","text":"<pre><code>Eigen::Matrix&lt; float, 4, 1 &gt; ori_multiply (\n    const Eigen::Matrix&lt; float, 4, 1 &gt; &amp; q,\n    const Eigen::Matrix&lt; float, 4, 1 &gt; &amp; p\n) \n</code></pre>"},{"location":"api/utils_8hpp/#function-read_line","title":"function read_line","text":"<pre><code>void read_line (\n    std::string stream,\n    std::deque&lt; float &gt; &amp; parameters\n) \n</code></pre>"},{"location":"api/utils_8hpp/#function-skew_x","title":"function skew_x","text":"<pre><code>Eigen::Matrix&lt; float, 3, 3 &gt; skew_x (\n    const Eigen::Matrix&lt; float, 3, 1 &gt; &amp; w\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/pose_lookup/utils.hpp</code></p>"},{"location":"api/utils_8hpp_source/","title":"File utils.hpp","text":"<p>File List &gt; pose_lookup &gt; utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr/error_util.hpp\"\n\n#include &lt;deque&gt;\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nEigen::Matrix&lt;float, 3, 3&gt; skew_x(const Eigen::Matrix&lt;float, 3, 1&gt;&amp; w) {\n    Eigen::Matrix&lt;float, 3, 3&gt; w_x;\n    w_x &lt;&lt; 0, -w(2), w(1), w(2), 0, -w(0), -w(1), w(0), 0;\n    return w_x;\n}\n\nEigen::Matrix&lt;float, 4, 1&gt; ori_inv(Eigen::Matrix&lt;float, 4, 1&gt; q) {\n    Eigen::Matrix&lt;float, 4, 1&gt; qinv;\n    qinv.block(0, 0, 3, 1) = -q.block(0, 0, 3, 1);\n    qinv(3, 0)             = q(3, 0);\n    return qinv;\n}\n\nEigen::Matrix&lt;float, 4, 1&gt; ori_multiply(const Eigen::Matrix&lt;float, 4, 1&gt;&amp; q, const Eigen::Matrix&lt;float, 4, 1&gt;&amp; p) {\n    Eigen::Matrix&lt;float, 4, 1&gt; q_t;\n    Eigen::Matrix&lt;float, 4, 4&gt; Qm;\n    // Create big L matrix\n    Qm.block(0, 0, 3, 3) = q(3, 0) * Eigen::MatrixXf::Identity(3, 3) - skew_x(q.block(0, 0, 3, 1));\n    Qm.block(0, 3, 3, 1) = q.block(0, 0, 3, 1);\n    Qm.block(3, 0, 1, 3) = -q.block(0, 0, 3, 1).transpose();\n    Qm(3, 3)             = q(3, 0);\n    q_t                  = Qm * p;\n    // Ensure unique by forcing q_4 to be &gt;0\n    if (q_t(3, 0) &lt; 0) {\n        q_t *= -1;\n    }\n    // Normalize and return\n    return q_t / q_t.norm();\n}\n\nvoid read_line(std::string stream, std::deque&lt;float&gt;&amp; parameters) {\n    const char*            split = \" \";\n    std::string::size_type pos   = stream.find(\" \");\n    stream.erase(0, pos + 1);\n\n    char* token = strtok((char*) stream.c_str(), split);\n    while (token != NULL) {\n        parameters.push_back(atof(token));\n        token = strtok(NULL, split);\n    }\n}\n\ntemplate&lt;typename EigenType&gt;\nvoid assign_matrix(std::deque&lt;float&gt;&amp; parameters, EigenType&amp; eigen_data) {\n    for (int row = 0; row &lt; eigen_data.rows(); row++) {\n        for (int col = 0; col &lt; eigen_data.cols(); col++) {\n            float value          = parameters[0];\n            eigen_data(row, col) = value;\n            parameters.pop_front();\n        }\n    }\n}\n\nvoid load_align_parameters(const std::string&amp; path, Eigen::Matrix3f&amp; align_rot, Eigen::Vector3f&amp; align_trans,\n                           Eigen::Vector4f&amp; align_quat, double&amp; align_scale) {\n    std::ifstream infile;\n    infile.open(path);\n    if (!infile.is_open()) {\n        ILLIXR::abort(\"Open alignment file failed !!!\");\n    }\n\n    std::string       in;\n    std::deque&lt;float&gt; parameters;\n    while (std::getline(infile, in)) {\n        parameters.resize(0);\n        read_line(in, parameters);\n\n        if (strstr(in.c_str(), \"Rotation\")) {\n            assign_matrix(parameters, align_rot);\n            continue;\n        }\n\n        if (strstr(in.c_str(), \"Translation\")) {\n            assign_matrix(parameters, align_trans);\n            continue;\n        }\n\n        if (strstr(in.c_str(), \"Quaternion\")) {\n            assign_matrix(parameters, align_quat);\n            continue;\n        }\n\n        if (strstr(in.c_str(), \"Scale\")) {\n            align_scale = parameters[0];\n            continue;\n        }\n    }\n    infile.close();\n}\n</code></pre>"},{"location":"api/variables/","title":"Variables","text":""},{"location":"api/variables/#a","title":"a","text":"<ul> <li>ACCEL_RATE_D4XX (plugin.cpp)</li> </ul>"},{"location":"api/variables/#b","title":"b","text":"<ul> <li>bias_t (plugin.hpp)</li> </ul>"},{"location":"api/variables/#d","title":"d","text":"<ul> <li>d_file (files.cpp)</li> </ul>"},{"location":"api/variables/#e","title":"e","text":"<ul> <li>EXPOSURE_TIME_PERCENT (plugin.cpp, zed_camera.cpp)</li> </ul>"},{"location":"api/variables/#f","title":"f","text":"<ul> <li>FPS_D4XX (plugin.cpp)</li> </ul>"},{"location":"api/variables/#g","title":"g","text":"<ul> <li>glXCreateContextAttribsARBProc (extended_window.hpp)</li> <li>GL_MAX_LOG_LENGTH (shader_util.hpp)</li> <li>GYRO_RATE_D4XX (plugin.cpp)</li> <li>glXSwapIntervalEXTProc (plugin.cpp)</li> </ul>"},{"location":"api/variables/#i","title":"i","text":"<ul> <li>IMU_TTL (plugin.cpp)</li> <li>ImuBias (plugin.cpp, plugin.hpp)</li> <li>imu_int_t (plugin.hpp)</li> <li>imu_t (plugin.hpp)</li> <li>IMAGE_HEIGHT_D4XX (plugin.cpp)</li> <li>IMAGE_HEIGHT_T26X (plugin.cpp)</li> <li>IMAGE_WIDTH_D4XX (plugin.cpp)</li> <li>IMAGE_WIDTH_T26X (plugin.cpp)</li> <li>IMU_SAMPLE_LIFETIME (plugin.cpp)</li> <li>ILLIXR_PRE_SLEEP_DURATION (illixr.hpp)</li> <li>ILLIXR_RUN_DURATION_DEFAULT (illixr.hpp)</li> </ul>"},{"location":"api/variables/#l","title":"l","text":"<ul> <li>lighthouse_instance (plugin.cpp)</li> <li>LEFT_EYE (files.hpp)</li> </ul>"},{"location":"api/variables/#m","title":"m","text":"<ul> <li>mtp_record (plugin.cpp)</li> </ul>"},{"location":"api/variables/#n","title":"n","text":"<ul> <li>nav_t (plugin.hpp)</li> <li>n_monado_t (runtime_impl.cpp)</li> </ul>"},{"location":"api/variables/#p","title":"p","text":"<ul> <li>pim_ptr_t (plugin.hpp)</li> <li>pim_t (plugin.hpp)</li> </ul>"},{"location":"api/variables/#r","title":"r","text":"<ul> <li>RIGHT_EYE (files.hpp)</li> <li>runtime_ (illixr.hpp, plugin.cpp)</li> </ul>"},{"location":"api/variables/#s","title":"s","text":"<ul> <li>should_profile (cpu_timer.hpp)</li> </ul>"},{"location":"api/variables/#t","title":"t","text":"<ul> <li>T_M_PI (camera_data.hpp)</li> <li>TEST_PATTERN_HEIGHT (plugin.hpp)</li> <li>TEST_PATTERN_WIDTH (plugin.hpp)</li> <li>timewarp_gpu_record (plugin.cpp)</li> </ul>"},{"location":"api/variables/#u","title":"u","text":"<ul> <li>ullong (misc.hpp)</li> </ul>"},{"location":"api/variables/#v","title":"v","text":"<ul> <li>VSYNC_SAFETY_DELAY (plugin.cpp)</li> </ul>"},{"location":"api/variables/#_","title":"_","text":"<ul> <li>__imu_cam_record (plugin.cpp)</li> </ul>"},{"location":"api/video__decoder_8cpp/","title":"File video_decoder.cpp","text":"<p>FileList &gt; offload_vio &gt; server_rx &gt; video_decoder.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"video_decoder.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include &lt;gst/app/gstappsrc.h&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/video__decoder_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/video__decoder_8cpp/#macros","title":"Macros","text":"Type Name define IMG_HEIGHT <code>480</code> define IMG_WIDTH <code>752</code>"},{"location":"api/video__decoder_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/video__decoder_8cpp/#define-img_height","title":"define IMG_HEIGHT","text":"<pre><code>#define IMG_HEIGHT `480`\n</code></pre>"},{"location":"api/video__decoder_8cpp/#define-img_width","title":"define IMG_WIDTH","text":"<pre><code>#define IMG_WIDTH `752`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/video_decoder.cpp</code></p>"},{"location":"api/video__decoder_8cpp_source/","title":"File video_decoder.cpp","text":"<p>File List &gt; offload_vio &gt; server_rx &gt; video_decoder.cpp</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by steven on 7/8/22.\n//\n\n#include \"video_decoder.hpp\"\n\n#include \"illixr/error_util.hpp\"\n\n#include &lt;gst/app/gstappsrc.h&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n// #define ZED\n\n#ifdef ZED\n    #define IMG_WIDTH  672\n    #define IMG_HEIGHT 376\n#else\n    #define IMG_WIDTH  752\n    #define IMG_HEIGHT 480\n#endif\n\nGstFlowReturn cb_new_sample(GstElement* appsink, gpointer* user_data) {\n    return reinterpret_cast&lt;video_decoder*&gt;(user_data)-&gt;cb_appsink(appsink);\n}\n\nvoid video_decoder::create_pipelines() {\n    gst_init(nullptr, nullptr);\n\n    appsrc_img0_  = gst_element_factory_make(\"appsrc\", \"appsrc_img0\");\n    appsrc_img1_  = gst_element_factory_make(\"appsrc\", \"appsrc_img1\");\n    appsink_img0_ = gst_element_factory_make(\"appsink\", \"appsink_img0\");\n    appsink_img1_ = gst_element_factory_make(\"appsink\", \"appsink_img1\");\n\n    auto nvvideoconvert_0 = gst_element_factory_make(\"nvvideoconvert\", \"nvvideoconvert0\");\n    auto nvvideoconvert_1 = gst_element_factory_make(\"nvvideoconvert\", \"nvvideoconvert1\");\n\n    auto decoder_img0 = gst_element_factory_make(\"nvv4l2decoder\", \"decoder_img0\");\n    auto decoder_img1 = gst_element_factory_make(\"nvv4l2decoder\", \"decoder_img1\");\n\n    auto caps_filter_0 = gst_element_factory_make(\"capsfilter\", \"caps_filter_0\");\n    auto caps_filter_1 = gst_element_factory_make(\"capsfilter\", \"caps_filter_1\");\n\n    g_object_set(G_OBJECT(caps_filter_0), \"caps\", gst_caps_from_string(\"video/x-raw,format=GRAY8\"), nullptr);\n    g_object_set(G_OBJECT(caps_filter_1), \"caps\", gst_caps_from_string(\"video/x-raw,format=GRAY8\"), nullptr);\n\n    // create caps with width and height\n    auto caps_x265 = gst_caps_new_simple(\"video/x-h264\", \"stream-format\", G_TYPE_STRING, \"byte-stream\", \"alignment\",\n                                         G_TYPE_STRING, \"au\", nullptr);\n    g_object_set(G_OBJECT(appsrc_img0_), \"caps\", caps_x265, nullptr);\n    g_object_set(G_OBJECT(appsrc_img1_), \"caps\", caps_x265, nullptr);\n    gst_caps_unref(caps_x265);\n\n    g_object_set(G_OBJECT(appsrc_img0_), \"stream-type\", 0, \"format\", GST_FORMAT_BYTES, \"is-live\", TRUE, nullptr);\n    g_object_set(G_OBJECT(appsrc_img1_), \"stream-type\", 0, \"format\", GST_FORMAT_BYTES, \"is-live\", TRUE, nullptr);\n\n    g_object_set(G_OBJECT(decoder_img0), \"low-latency-mode\", TRUE, nullptr);\n    g_object_set(G_OBJECT(decoder_img1), \"low-latency-mode\", TRUE, nullptr);\n\n    g_object_set(appsink_img0_, \"emit-signals\", TRUE, \"sync\", FALSE, nullptr);\n    g_object_set(appsink_img1_, \"emit-signals\", TRUE, \"sync\", FALSE, nullptr);\n\n    g_signal_connect(appsink_img0_, \"new-sample\", G_CALLBACK(cb_new_sample), this);\n    g_signal_connect(appsink_img1_, \"new-sample\", G_CALLBACK(cb_new_sample), this);\n\n    pipeline_img0_ = gst_pipeline_new(\"pipeline_img0\");\n    pipeline_img1_ = gst_pipeline_new(\"pipeline_img1\");\n\n    gst_bin_add_many(GST_BIN(pipeline_img0_), appsrc_img0_, decoder_img0, nvvideoconvert_0, caps_filter_0, appsink_img0_,\n                     nullptr);\n    gst_bin_add_many(GST_BIN(pipeline_img1_), appsrc_img1_, decoder_img1, nvvideoconvert_1, caps_filter_1, appsink_img1_,\n                     nullptr);\n\n    // link elements\n    if (!gst_element_link_many(appsrc_img0_, decoder_img0, nvvideoconvert_0, caps_filter_0, appsink_img0_, nullptr) ||\n        !gst_element_link_many(appsrc_img1_, decoder_img1, nvvideoconvert_1, caps_filter_1, appsink_img1_, nullptr)) {\n        abort(\"Failed to link elements\");\n    }\n\n    gst_element_set_state(pipeline_img0_, GST_STATE_PLAYING);\n    gst_element_set_state(pipeline_img1_, GST_STATE_PLAYING);\n}\n\nvideo_decoder::video_decoder(std::function&lt;void(cv::Mat&amp;&amp;, cv::Mat&amp;&amp;)&gt; callback)\n    : callback_(std::move(callback)) { }\n\nvoid video_decoder::init() {\n    create_pipelines();\n}\n\nvoid video_decoder::enqueue(std::string&amp; img0, std::string&amp; img1) {\n    auto buffer_img0 =\n        gst_buffer_new_wrapped_full(GST_MEMORY_FLAG_READONLY, img0.data(), img0.size(), 0, img0.size(), nullptr, nullptr);\n    auto buffer_img1 =\n        gst_buffer_new_wrapped_full(GST_MEMORY_FLAG_READONLY, img1.data(), img1.size(), 0, img1.size(), nullptr, nullptr);\n\n    GST_BUFFER_OFFSET(buffer_img0) = num_samples_;\n    GST_BUFFER_OFFSET(buffer_img1) = num_samples_;\n\n    num_samples_++;\n\n    auto ret_img0 = gst_app_src_push_buffer(reinterpret_cast&lt;GstAppSrc*&gt;(appsrc_img0_), buffer_img0);\n    auto ret_img1 = gst_app_src_push_buffer(reinterpret_cast&lt;GstAppSrc*&gt;(appsrc_img1_), buffer_img1);\n\n    if (ret_img0 != GST_FLOW_OK || ret_img1 != GST_FLOW_OK) {\n        abort(\"Failed to push buffer\");\n    }\n}\n\nGstFlowReturn video_decoder::cb_appsink(GstElement* sink) {\n    GstSample* sample;\n    g_signal_emit_by_name(sink, \"pull-sample\", &amp;sample);\n    if (sample) {\n        GstBuffer* buffer = gst_sample_get_buffer(sample);\n\n        std::unique_lock&lt;std::mutex&gt; lock(pipeline_sync_mutex_); // lock acquired\n        if (sink == appsink_img0_) {\n            gst_buffer_map(buffer, &amp;img0_map_, GST_MAP_READ);\n            img0_ready_ = true;\n        } else {\n            gst_buffer_map(buffer, &amp;img1_map_, GST_MAP_READ);\n            img1_ready_ = true;\n        }\n\n        if (img0_ready_ &amp;&amp; img1_ready_) {\n            callback_(cv::Mat(IMG_HEIGHT, IMG_WIDTH, CV_8UC1, img0_map_.data),\n                      cv::Mat(IMG_HEIGHT, IMG_WIDTH, CV_8UC1, img1_map_.data));\n            img0_ready_ = false;\n            img1_ready_ = false;\n            lock.unlock(); // unlock and notify the waiting thread to clean up\n            pipeline_sync_.notify_one();\n        } else {\n            pipeline_sync_.wait(lock, [&amp;]() {\n                return !img0_ready_ &amp;&amp; !img1_ready_;\n            });            // wait unlocks the mutex if condition is not met\n            lock.unlock(); // wait has acquired the lock. unlock it and start cleaning up\n        }\n\n        if (sink == appsink_img0_) {\n            gst_buffer_unmap(buffer, &amp;img0_map_);\n        } else {\n            gst_buffer_unmap(buffer, &amp;img1_map_);\n        }\n        gst_sample_unref(sample);\n        return GST_FLOW_OK;\n    }\n    return GST_FLOW_ERROR;\n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/video__decoder_8hpp/","title":"File video_decoder.hpp","text":"<p>FileList &gt; offload_vio &gt; server_rx &gt; video_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"gst/gst.h\"</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;opencv2/core/mat.hpp&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/video__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/video__decoder_8hpp/#classes","title":"Classes","text":"Type Name class video_decoder <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/server_rx/video_decoder.hpp</code></p>"},{"location":"api/video__decoder_8hpp_source/","title":"File video_decoder.hpp","text":"<p>File List &gt; offload_vio &gt; server_rx &gt; video_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"gst/gst.h\"\n\n#include &lt;condition_variable&gt;\n#include &lt;functional&gt;\n#include &lt;opencv2/core/mat.hpp&gt;\n#include &lt;queue&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n\nclass video_decoder {\npublic:\n    explicit video_decoder(std::function&lt;void(cv::Mat&amp;&amp;, cv::Mat&amp;&amp;)&gt; callback);\n\n    void init();\n\n    void enqueue(std::string&amp; img0, std::string&amp; img1);\n\n    GstFlowReturn cb_appsink(GstElement* sink);\n\nprivate:\n    void create_pipelines();\n\n    unsigned int                              num_samples_ = 0;\n    std::function&lt;void(cv::Mat&amp;&amp;, cv::Mat&amp;&amp;)&gt; callback_;\n    GstElement*                               pipeline_img0_{};\n    GstElement*                               pipeline_img1_{};\n    GstElement*                               appsrc_img0_{};\n    GstElement*                               appsrc_img1_{};\n    GstElement*                               appsink_img0_{};\n    GstElement*                               appsink_img1_{};\n\n    std::condition_variable pipeline_sync_;\n    std::mutex              pipeline_sync_mutex_;\n    GstMapInfo              img0_map_{};\n    GstMapInfo              img1_map_{};\n    bool                    img0_ready_ = false;\n    bool                    img1_ready_ = false;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/video__encoder_8cpp/","title":"File video_encoder.cpp","text":"<p>FileList &gt; device_tx &gt; video_encoder.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"video_encoder.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;gst/app/gstappsrc.h&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/video__encoder_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/video__encoder_8cpp/#macros","title":"Macros","text":"Type Name define ILLIXR_BITRATE <code>5242880</code> define IMG_HEIGHT <code>480</code> define IMG_WIDTH <code>752</code>"},{"location":"api/video__encoder_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/video__encoder_8cpp/#define-illixr_bitrate","title":"define ILLIXR_BITRATE","text":"<pre><code>#define ILLIXR_BITRATE `5242880`\n</code></pre>"},{"location":"api/video__encoder_8cpp/#define-img_height","title":"define IMG_HEIGHT","text":"<pre><code>#define IMG_HEIGHT `480`\n</code></pre>"},{"location":"api/video__encoder_8cpp/#define-img_width","title":"define IMG_WIDTH","text":"<pre><code>#define IMG_WIDTH `752`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/video_encoder.cpp</code></p>"},{"location":"api/video__encoder_8cpp_source/","title":"File video_encoder.cpp","text":"<p>File List &gt; device_tx &gt; video_encoder.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"video_encoder.hpp\"\n\n#include \"illixr/error_util.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;gst/app/gstappsrc.h&gt;\n#include &lt;thread&gt;\n\nnamespace ILLIXR {\n// #define ZED\n\n#ifdef ZED\n    #define IMG_WIDTH  672\n    #define IMG_HEIGHT 376\n#else\n    #define IMG_WIDTH  752\n    #define IMG_HEIGHT 480\n#endif\n\n#define ILLIXR_BITRATE 5242880\n\n// Alternative encoding bitrates\n// 50Mbps = 52428800\n// 20Mbps = 20971520\n// 10Mbps = 10485760\n// 5Mbps = 5242880\n// 2Mbps = 2097152\n// 0.5Mbps = 524288\n// 0.1Mbps = 104857\n\nGstFlowReturn cb_new_sample(GstElement* appsink, gpointer* user_data) {\n    return reinterpret_cast&lt;video_encoder*&gt;(user_data)-&gt;cb_appsink(appsink);\n}\n\nvideo_encoder::video_encoder(std::function&lt;void(const GstMapInfo&amp;, const GstMapInfo&amp;)&gt; callback)\n    : callback_(std::move(callback)) { }\n\nvoid video_encoder::create_pipelines() {\n    gst_init(nullptr, nullptr);\n\n    appsrc_img0_  = gst_element_factory_make(\"appsrc\", \"appsrc_img0\");\n    appsrc_img1_  = gst_element_factory_make(\"appsrc\", \"appsrc_img1\");\n    appsink_img0_ = gst_element_factory_make(\"appsink\", \"appsink_img0\");\n    appsink_img1_ = gst_element_factory_make(\"appsink\", \"appsink_img1\");\n\n    auto nvvideoconvert_0 = gst_element_factory_make(\"nvvideoconvert\", \"nvvideoconvert0\");\n    auto nvvideoconvert_1 = gst_element_factory_make(\"nvvideoconvert\", \"nvvideoconvert1\");\n\n    auto encoder_img0 = gst_element_factory_make(\"nvv4l2h264enc\", \"encoder_img0\");\n    auto encoder_img1 = gst_element_factory_make(\"nvv4l2h264enc\", \"encoder_img1\");\n\n    auto caps_8uc1 = gst_caps_new_simple(\"video/x-raw\", \"format\", G_TYPE_STRING, \"GRAY8\", \"framerate\", GST_TYPE_FRACTION, 0, 1,\n                                         \"width\", G_TYPE_INT, IMG_WIDTH, \"height\", G_TYPE_INT, IMG_HEIGHT, NULL);\n    g_object_set(G_OBJECT(appsrc_img0_), \"caps\", caps_8uc1, nullptr);\n    g_object_set(G_OBJECT(appsrc_img1_), \"caps\", caps_8uc1, nullptr);\n    gst_caps_unref(caps_8uc1);\n\n    // set bitrate from environment variables\n    // g_object_set(G_OBJECT(encoder_img0), \"bitrate\", std::stoi(sb-&gt;get_env(\"ILLIXR_BITRATE\")), nullptr, 10);\n    // g_object_set(G_OBJECT(encoder_img1), \"bitrate\", std::stoi(sb-&gt;get_env(\"ILLIXR_BITRATE\")), nullptr, 10);\n\n    // set bitrate from defined variables\n    g_object_set(G_OBJECT(encoder_img0), \"bitrate\", ILLIXR_BITRATE, nullptr);\n    g_object_set(G_OBJECT(encoder_img1), \"bitrate\", ILLIXR_BITRATE, nullptr);\n\n    g_object_set(G_OBJECT(appsrc_img0_), \"stream-type\", 0, \"format\", GST_FORMAT_BYTES, \"is-live\", TRUE, nullptr);\n    g_object_set(G_OBJECT(appsrc_img1_), \"stream-type\", 0, \"format\", GST_FORMAT_BYTES, \"is-live\", TRUE, nullptr);\n\n    g_object_set(appsink_img0_, \"emit-signals\", TRUE, \"sync\", FALSE, nullptr);\n    g_object_set(appsink_img1_, \"emit-signals\", TRUE, \"sync\", FALSE, nullptr);\n\n    g_signal_connect(appsink_img0_, \"new-sample\", G_CALLBACK(cb_new_sample), this);\n    g_signal_connect(appsink_img1_, \"new-sample\", G_CALLBACK(cb_new_sample), this);\n\n    pipeline_img0_ = gst_pipeline_new(\"pipeline_img0\");\n    pipeline_img1_ = gst_pipeline_new(\"pipeline_img1\");\n\n    gst_bin_add_many(GST_BIN(pipeline_img0_), appsrc_img0_, nvvideoconvert_0, encoder_img0, appsink_img0_, nullptr);\n    gst_bin_add_many(GST_BIN(pipeline_img1_), appsrc_img1_, nvvideoconvert_1, encoder_img1, appsink_img1_, nullptr);\n\n    // link elements\n    if (!gst_element_link_many(appsrc_img0_, nvvideoconvert_0, encoder_img0, appsink_img0_, nullptr) ||\n        !gst_element_link_many(appsrc_img1_, nvvideoconvert_1, encoder_img1, appsink_img1_, nullptr)) {\n        abort(\"Failed to link elements\");\n    }\n\n    gst_element_set_state(pipeline_img0_, GST_STATE_PLAYING);\n    gst_element_set_state(pipeline_img1_, GST_STATE_PLAYING);\n}\n\nvoid video_encoder::enqueue(cv::Mat&amp; img0, cv::Mat&amp; img1) {\n    // push cv mat into appsrc\n    // print img0 size\n\n    auto data_size      = img0.cols * img0.rows * img0.channels();\n    int  size           = floor(data_size + ceil(img0.cols / 2.0) * ceil(img0.rows / 2.0) * 2);\n    auto fill_zero_size = size - data_size;\n\n    auto buffer_img0 = gst_buffer_new_and_alloc(size);\n    auto buffer_img1 = gst_buffer_new_and_alloc(size);\n\n    gst_buffer_fill(buffer_img0, 0, img0.data, data_size);\n    gst_buffer_fill(buffer_img1, 0, img1.data, data_size);\n\n    gst_buffer_memset(buffer_img0, data_size, 128, fill_zero_size);\n    gst_buffer_memset(buffer_img1, data_size, 0, fill_zero_size);\n\n    GST_BUFFER_OFFSET(buffer_img0) = num_samples_;\n    GST_BUFFER_OFFSET(buffer_img1) = num_samples_;\n\n    num_samples_++;\n\n    auto ret_img0 = gst_app_src_push_buffer(reinterpret_cast&lt;GstAppSrc*&gt;(appsrc_img0_), buffer_img0);\n    auto ret_img1 = gst_app_src_push_buffer(reinterpret_cast&lt;GstAppSrc*&gt;(appsrc_img1_), buffer_img1);\n    if (ret_img0 != GST_FLOW_OK || ret_img1 != GST_FLOW_OK) {\n        abort(\"Failed to push buffer\");\n    }\n}\n\nvoid video_encoder::init() {\n    create_pipelines();\n}\n\nGstFlowReturn video_encoder::cb_appsink(GstElement* sink) {\n    GstSample* sample;\n    g_signal_emit_by_name(sink, \"pull-sample\", &amp;sample);\n    if (sample) {\n        GstBuffer* buffer = gst_sample_get_buffer(sample);\n\n        std::unique_lock&lt;std::mutex&gt; lock(pipeline_sync_mutex_); // lock acquired\n        if (sink == appsink_img0_) {\n            gst_buffer_map(buffer, &amp;img0_map_, GST_MAP_READ);\n            img0_ready_ = true;\n        } else {\n            gst_buffer_map(buffer, &amp;img1_map_, GST_MAP_READ);\n            img1_ready_ = true;\n        }\n\n        if (img0_ready_ &amp;&amp; img1_ready_) {\n            callback_(img0_map_, img1_map_);\n            img0_ready_ = false;\n            img1_ready_ = false;\n            lock.unlock(); // unlock and notify the waiting thread to clean up\n            pipeline_sync_.notify_one();\n        } else {\n            pipeline_sync_.wait(lock, [&amp;]() {\n                return !img0_ready_ &amp;&amp; !img1_ready_;\n            });            // wait unlocks the mutex if condition is not met\n            lock.unlock(); // wait has acquired the lock. unlock it and start cleaning up\n        }\n\n        if (sink == appsink_img0_) {\n            gst_buffer_unmap(buffer, &amp;img0_map_);\n        } else {\n            gst_buffer_unmap(buffer, &amp;img1_map_);\n        }\n        gst_sample_unref(sample);\n        return GST_FLOW_OK;\n    }\n    return GST_FLOW_ERROR;\n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/video__encoder_8hpp/","title":"File video_encoder.hpp","text":"<p>FileList &gt; device_tx &gt; video_encoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"gst/gst.h\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;opencv2/core/mat.hpp&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/video__encoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/video__encoder_8hpp/#classes","title":"Classes","text":"Type Name class video_encoder <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/offload_vio/device_tx/video_encoder.hpp</code></p>"},{"location":"api/video__encoder_8hpp_source/","title":"File video_encoder.hpp","text":"<p>File List &gt; device_tx &gt; video_encoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"gst/gst.h\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;condition_variable&gt;\n#include &lt;functional&gt;\n#include &lt;opencv2/core/mat.hpp&gt;\n#include &lt;queue&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n\nclass video_encoder {\npublic:\n    explicit video_encoder(std::function&lt;void(const GstMapInfo&amp;, const GstMapInfo&amp;)&gt; callback);\n\n    void init();\n\n    void enqueue(cv::Mat&amp; img0, cv::Mat&amp; img1);\n\n    GstFlowReturn cb_appsink(GstElement* sink);\n\nprivate:\n    void create_pipelines();\n\n    // unsigned int _sample_rate = 15;\n    unsigned int num_samples_ = 0;\n    // GstClockTime _last_timestamp = GST_CLOCK_TIME_NONE;\n\n    GstElement* pipeline_img0_{};\n    GstElement* pipeline_img1_{};\n    GstElement* appsrc_img0_{};\n    GstElement* appsrc_img1_{};\n    GstElement* appsink_img0_{};\n    GstElement* appsink_img1_{};\n\n    std::condition_variable pipeline_sync_;\n    std::mutex              pipeline_sync_mutex_;\n    GstMapInfo              img0_map_{};\n    GstMapInfo              img1_map_{};\n    bool                    img0_ready_ = false;\n    bool                    img1_ready_ = false;\n\n    std::function&lt;void(const GstMapInfo&amp;, const GstMapInfo&amp;)&gt; callback_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/vkdemo_2service_8cpp/","title":"File service.cpp","text":"<p>FileList &gt; services &gt; vkdemo &gt; service.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"service.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/math_util.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_core.h&gt;</code></li> <li><code>#include \"illixr/gl_util/lib/tiny_obj_loader.h\"</code></li> <li><code>#include \"illixr/gl_util/lib/stb_image.h\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include \"illixr/vk/vulkan_utils.hpp\"</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"api/vkdemo_2service_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace std"},{"location":"api/vkdemo_2service_8cpp/#classes","title":"Classes","text":"Type Name struct model_push_constant struct hash&lt; vertex &gt; &lt;&gt; struct uniform_buffer_object"},{"location":"api/vkdemo_2service_8cpp/#macros","title":"Macros","text":"Type Name define STB_IMAGE_IMPLEMENTATION define TINYOBJLOADER_IMPLEMENTATION"},{"location":"api/vkdemo_2service_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/vkdemo_2service_8cpp/#define-stb_image_implementation","title":"define STB_IMAGE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_IMPLEMENTATION \n</code></pre>"},{"location":"api/vkdemo_2service_8cpp/#define-tinyobjloader_implementation","title":"define TINYOBJLOADER_IMPLEMENTATION","text":"<pre><code>#define TINYOBJLOADER_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.cpp</code></p>"},{"location":"api/vkdemo_2service_8cpp_source/","title":"File service.cpp","text":"<p>File List &gt; services &gt; vkdemo &gt; service.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"service.hpp\"\n\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/math_util.hpp\"\n\n#include &lt;array&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\n#define TINYOBJLOADER_IMPLEMENTATION\n#include \"illixr/gl_util/lib/tiny_obj_loader.h\"\n\n#define STB_IMAGE_IMPLEMENTATION\n#include \"illixr/gl_util/lib/stb_image.h\"\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n#include \"illixr/vk/vulkan_utils.hpp\"\n\n#include &lt;unordered_map&gt;\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nstruct model_push_constant {\n    [[maybe_unused]] int texture_index;\n};\n\nnamespace std {\ntemplate&lt;&gt;\nstruct hash&lt;vertex&gt; {\n    size_t operator()(vertex const&amp; vertex) const {\n        return ((hash&lt;glm::vec3&gt;()(vertex.pos) ^ (hash&lt;glm::vec2&gt;()(vertex.uv) &lt;&lt; 1)) &gt;&gt; 1);\n    }\n};\n} // namespace std\n\nstruct uniform_buffer_object {\n    glm::mat4 model_view;\n    glm::mat4 proj;\n};\n\nvkdemo::vkdemo(const phonebook* const pb)\n    : switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n    , display_provider_{pb-&gt;lookup_impl&lt;vulkan::display_provider&gt;()}\n    , clock_{pb-&gt;lookup_impl&lt;relative_clock&gt;()} { }\n\nvoid vkdemo::initialize() {\n    if (display_provider_-&gt;vma_allocator_) {\n        this-&gt;vma_allocator_ = display_provider_-&gt;vma_allocator_;\n    } else {\n        this-&gt;vma_allocator_ = vulkan::create_vma_allocator(\n            display_provider_-&gt;vk_instance_, display_provider_-&gt;vk_physical_device_, display_provider_-&gt;vk_device_);\n\n        deletion_queue_.emplace([=]() {\n            vmaDestroyAllocator(vma_allocator_);\n        });\n    }\n\n    command_pool_ =\n        vulkan::create_command_pool(display_provider_-&gt;vk_device_, display_provider_-&gt;queues_[vulkan::queue::GRAPHICS].family);\n    command_buffer_ = vulkan::create_command_buffer(display_provider_-&gt;vk_device_, command_pool_);\n    deletion_queue_.emplace([=]() {\n        vkDestroyCommandPool(display_provider_-&gt;vk_device_, command_pool_, nullptr);\n    });\n\n    load_model();\n    bake_models();\n    create_texture_sampler_();\n    create_descriptor_set_layout();\n    create_uniform_buffers();\n    create_descriptor_pool();\n    create_descriptor_set();\n    create_vertex_buffer();\n    create_index_buffer();\n\n    vertices_.clear();\n    indices_.clear();\n\n    // Construct perspective projection matrix (using the same projection matrix as Unreal Engine, by default).\n    for (int eye = 0; eye &lt; 2; eye++) {\n        math_util::unreal_projection(&amp;basic_projection_[eye], index_params::fov_left[eye], index_params::fov_right[eye],\n                                     index_params::fov_up[eye], index_params::fov_down[eye]);\n    }\n}\n\nvoid vkdemo::setup(VkRenderPass render_pass, uint32_t subpass, std::shared_ptr&lt;vulkan::buffer_pool&lt;fast_pose_type&gt;&gt; _) {\n    create_pipeline(render_pass, subpass);\n}\n\nvoid vkdemo::update_uniforms(const pose_type&amp; fp) {\n    update_uniform(fp, 0);\n    update_uniform(fp, 1);\n}\n\nvoid vkdemo::record_command_buffer(VkCommandBuffer command_buffer, VkFramebuffer frame_buffer, int buffer_ind, bool left) {\n    (void) frame_buffer;\n    (void) buffer_ind;\n    vkCmdBindPipeline(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_);\n    VkBuffer     vertexBuffers[] = {vertex_buffer_};\n    VkDeviceSize offsets[]       = {0};\n    vkCmdBindVertexBuffers(command_buffer, 0, 1, vertexBuffers, offsets);\n    vkCmdBindIndexBuffer(command_buffer, index_buffer_, 0, VK_INDEX_TYPE_UINT32);\n    vkCmdBindDescriptorSets(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout_, 0, 1, &amp;descriptor_sets_[!left],\n                            0, nullptr);\n\n    for (auto&amp; model : models_) {\n        model_push_constant push_constant{};\n        push_constant.texture_index = static_cast&lt;int&gt;(texture_map_[model.texture_index]);\n        vkCmdPushConstants(command_buffer, pipeline_layout_, VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(model_push_constant),\n                           &amp;push_constant);\n        vkCmdDrawIndexed(command_buffer, model.index_count, 1, model.index_offset, 0, 0);\n    }\n}\n\nvoid vkdemo::destroy() {\n    vkDeviceWaitIdle(display_provider_-&gt;vk_device_);\n\n    // drain deletion_queue_\n    while (!deletion_queue_.empty()) {\n        deletion_queue_.top()();\n        deletion_queue_.pop();\n    }\n}\n\nvoid vkdemo::update_uniform(const pose_type&amp; pose, int eye) {\n    Eigen::Matrix4f model_matrix = Eigen::Matrix4f::Identity();\n\n    Eigen::Matrix3f head_rotation_matrix = pose.orientation.toRotationMatrix();\n\n    constexpr int LEFT_EYE = 0;\n\n    // Offset of eyeball from pose\n    auto eyeball = Eigen::Vector3f((eye == LEFT_EYE ? -display_params::ipd / 2.0f : display_params::ipd / 2.0f), 0, 0);\n\n    // Apply head rotation to eyeball offset vector\n    eyeball = head_rotation_matrix * eyeball;\n\n    // Apply head position to eyeball\n    eyeball += pose.position;\n\n    // Build our eye matrix from the pose's position + orientation.\n    Eigen::Matrix4f eye_matrix   = Eigen::Matrix4f::Identity();\n    eye_matrix.block&lt;3, 1&gt;(0, 3) = eyeball; // Set position to eyeball's position\n    eye_matrix.block&lt;3, 3&gt;(0, 0) = pose.orientation.toRotationMatrix();\n\n    // Objects' \"view matrix\" is inverse of eye matrix.\n    auto view_matrix = eye_matrix.inverse();\n\n    Eigen::Matrix4f model_view = view_matrix * model_matrix;\n\n    auto* ubo = (uniform_buffer_object*) uniform_buffer_allocation_infos_[eye].pMappedData;\n    memcpy(&amp;ubo-&gt;model_view, &amp;model_view, sizeof(model_view));\n    memcpy(&amp;ubo-&gt;proj, &amp;basic_projection_[eye], sizeof(basic_projection_[eye]));\n}\n\nvoid vkdemo::bake_models() {\n    for (std::size_t i = 0; i &lt; textures_.size(); i++) {\n        if (textures_[i].image_view == VK_NULL_HANDLE) {\n            continue;\n        }\n        VkDescriptorImageInfo image_info{\n            nullptr,                                  // sampler\n            textures_[i].image_view,                  // imageView\n            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, // imageLayout\n        };\n        texture_map_.insert(std::make_pair(i, image_infos_.size()));\n        image_infos_.push_back(image_info);\n    }\n}\n\nvoid vkdemo::create_descriptor_set_layout() {\n    VkDescriptorSetLayoutBinding ubo_layout_binding{\n        0,                                 // binding\n        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, // descriptorType\n        1,                                 // descriptorCount\n        VK_SHADER_STAGE_VERTEX_BIT,        // stageFlags\n        nullptr                            // pImmutableSamplers\n    };\n\n    VkDescriptorSetLayoutBinding sampler_layout_binding{\n        1,                            // binding\n        VK_DESCRIPTOR_TYPE_SAMPLER,   // descriptorType\n        1,                            // descriptorCount\n        VK_SHADER_STAGE_FRAGMENT_BIT, // stageFlags\n        nullptr                       // pImmutableSamplers\n    };\n\n    VkDescriptorSetLayoutBinding sampled_image_layout_binding{\n        2,                                      // binding\n        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       // descriptorType\n        static_cast&lt;uint&gt;(texture_map_.size()), // descriptorCount\n        VK_SHADER_STAGE_FRAGMENT_BIT,           // stageFlags\n        nullptr                                 // pImmutableSamplers\n    };\n\n    VkDescriptorSetLayoutCreateInfo layout_info{\n        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, // sType\n        nullptr,                                             // pNext\n        0,                                                   // flags\n        3,                                                   // bindingCount\n        nullptr                                              // pBindings\n    };\n    VkDescriptorSetLayoutBinding bindings[]{ubo_layout_binding, sampler_layout_binding, sampled_image_layout_binding};\n    layout_info.pBindings = bindings;\n\n    VK_ASSERT_SUCCESS(\n        vkCreateDescriptorSetLayout(display_provider_-&gt;vk_device_, &amp;layout_info, nullptr, &amp;descriptor_set_layout_))\n\n    deletion_queue_.emplace([=]() {\n        vkDestroyDescriptorSetLayout(display_provider_-&gt;vk_device_, descriptor_set_layout_, nullptr);\n    });\n}\n\nvoid vkdemo::create_uniform_buffers() {\n    for (auto i = 0; i &lt; 2; i++) {\n        VkBufferCreateInfo buffer_info{\n            VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, // sType\n            nullptr,                              // pNext\n            0,                                    // flags\n            sizeof(uniform_buffer_object),        // size\n            VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,   // usage\n            {},                                   // sharingMode\n            0,                                    // queueFamilyIndexCount\n            nullptr                               // pQueueFamilyIndices\n        };\n\n        VmaAllocationCreateInfo alloc_info{};\n        alloc_info.flags         = VMA_ALLOCATION_CREATE_MAPPED_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n        alloc_info.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;\n\n        VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;buffer_info, &amp;alloc_info, &amp;uniform_buffers_[i],\n                                          &amp;uniform_buffer_allocations_[i], &amp;uniform_buffer_allocation_infos_[i]))\n\n        deletion_queue_.emplace([=]() {\n            vmaDestroyBuffer(vma_allocator_, uniform_buffers_[i], uniform_buffer_allocations_[i]);\n        });\n    }\n}\n\nvoid vkdemo::create_descriptor_pool() {\n    std::array&lt;VkDescriptorPoolSize, 3&gt; pool_sizes{{{\n                                                        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, // type\n                                                        2                                  // descriptorCount\n                                                    },\n                                                    {\n                                                        VK_DESCRIPTOR_TYPE_SAMPLER, // type\n                                                        2                           // descriptorCount\n                                                    },\n                                                    {\n                                                        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,              // type\n                                                        static_cast&lt;uint32_t&gt;(2 * texture_map_.size()) // descriptorCount\n                                                    }}};\n    VkDescriptorPoolCreateInfo          pool_info{\n        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, // sType\n        nullptr,                                       // pNext\n        0,                                             // flags\n        2,                                             // maxSets\n        static_cast&lt;uint32_t&gt;(pool_sizes.size()),      // poolSizeCount\n        pool_sizes.data()                              // pPoolSizes\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateDescriptorPool(display_provider_-&gt;vk_device_, &amp;pool_info, nullptr, &amp;descriptor_pool_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyDescriptorPool(display_provider_-&gt;vk_device_, descriptor_pool_, nullptr);\n    });\n}\n\nvoid vkdemo::create_texture_sampler_() {\n    VkSamplerCreateInfo sampler_info{\n        VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, // sType\n        nullptr,                               // pNext\n        0,                                     // flags\n        VK_FILTER_LINEAR,                      // magFilter\n        VK_FILTER_LINEAR,                      // minFilter\n        VK_SAMPLER_MIPMAP_MODE_LINEAR,         // mipmapMode\n        VK_SAMPLER_ADDRESS_MODE_REPEAT,        // addressModeU\n        VK_SAMPLER_ADDRESS_MODE_REPEAT,        // addressModeV\n        VK_SAMPLER_ADDRESS_MODE_REPEAT,        // addressModeW\n        0.f,                                   // mipLodBias\n        VK_FALSE,                              // anisotropyEnable\n        // .maxAnisotropy = 16;\n        0.f,                              // maxAnisotropy\n        VK_FALSE,                         // compareEnable\n        VK_COMPARE_OP_ALWAYS,             // compareOp\n        0.f,                              // minLod\n        0.f,                              // maxLod\n        VK_BORDER_COLOR_INT_OPAQUE_BLACK, // borderColor\n        VK_FALSE                          // unnormalizedCoordinates\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateSampler(display_provider_-&gt;vk_device_, &amp;sampler_info, nullptr, &amp;texture_sampler_))\n    deletion_queue_.emplace([=]() {\n        vkDestroySampler(display_provider_-&gt;vk_device_, texture_sampler_, nullptr);\n    });\n}\n\nvoid vkdemo::create_descriptor_set() {\n    VkDescriptorSetLayout       layouts[] = {descriptor_set_layout_, descriptor_set_layout_};\n    VkDescriptorSetAllocateInfo alloc_info{\n        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, // sType\n        nullptr,                                        // pNext\n        descriptor_pool_,                               // descriptorPool\n        2,                                              // descriptorSetCount\n        layouts                                         // pSetLayouts\n    };\n\n    VK_ASSERT_SUCCESS(vkAllocateDescriptorSets(display_provider_-&gt;vk_device_, &amp;alloc_info, descriptor_sets_.data()))\n\n    std::array&lt;VkDescriptorBufferInfo, 2&gt; buffer_infos = {{{\n                                                               uniform_buffers_[0],          // buffer\n                                                               0,                            // offset\n                                                               sizeof(uniform_buffer_object) // range\n                                                           },\n                                                           {\n                                                               uniform_buffers_[1],          // buffer\n                                                               0,                            // offset\n                                                               sizeof(uniform_buffer_object) // range\n                                                           }}};\n\n    std::array&lt;VkWriteDescriptorSet, 2&gt; descriptor_writes = {{{\n                                                                  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, // sType\n                                                                  nullptr,                                // pNext\n                                                                  descriptor_sets_[0],                    // dstSet\n                                                                  0,                                      // dstBinding\n                                                                  0,                                      // dstArrayElement\n                                                                  1,                                      // descriptorCount\n                                                                  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,      // descriptorType\n                                                                  nullptr,                                // pImageInfo\n                                                                  &amp;buffer_infos[0],                       // pBufferInfo\n                                                                  nullptr                                 // pTexelBufferView\n                                                              },\n                                                              {\n                                                                  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, // sType\n                                                                  nullptr,                                // pNext\n                                                                  descriptor_sets_[1],                    // dstSet\n                                                                  0,                                      // dstBinding\n                                                                  0,                                      // dstArrayElement\n                                                                  1,                                      // descriptorCount\n                                                                  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,      // descriptorType\n                                                                  nullptr,                                // pImageInfo\n                                                                  &amp;buffer_infos[1],                       // pBufferInfo\n                                                                  nullptr                                 // pTexelBufferView\n                                                              }}};\n\n    vkUpdateDescriptorSets(display_provider_-&gt;vk_device_, static_cast&lt;uint32_t&gt;(descriptor_writes.size()),\n                           descriptor_writes.data(), 0, nullptr);\n\n    std::vector&lt;VkWriteDescriptorSet&gt; image_descriptor_writes = {};\n    for (auto i = 0; i &lt; 2; i++) {\n        VkDescriptorImageInfo image_info = {texture_sampler_, nullptr, {}};\n        image_descriptor_writes.push_back({\n            VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, // sType\n            nullptr,                                // pNext\n            descriptor_sets_[i],                    // dstSet\n            1,                                      // dstBinding\n            0,                                      // dstArrayElement\n            1,                                      // descriptorCount\n            VK_DESCRIPTOR_TYPE_SAMPLER,             // descriptorType\n            &amp;image_info,                            // pImageInfo\n            nullptr,                                // pBufferInfo\n            nullptr                                 // pTexelBufferView\n        });\n\n        assert(!image_infos_.empty());\n        image_descriptor_writes.push_back({\n            VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,     // sType\n            nullptr,                                    // pNext\n            descriptor_sets_[i],                        // dstSet\n            2,                                          // dstBinding\n            0,                                          // dstArrayElement\n            static_cast&lt;uint32_t&gt;(image_infos_.size()), // descriptorCount\n            VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,           // descriptorType\n            image_infos_.data(),                        // pImageInfo\n            nullptr,                                    // pBufferInfo\n            nullptr                                     // pTexelBufferView\n        });\n    }\n\n    vkUpdateDescriptorSets(display_provider_-&gt;vk_device_, static_cast&lt;uint32_t&gt;(image_descriptor_writes.size()),\n                           image_descriptor_writes.data(), 0, nullptr);\n}\n\nvoid vkdemo::load_texture(const std::string&amp; path, int i) {\n    int  width, height, channels;\n    auto data = stbi_load(path.c_str(), &amp;width, &amp;height, &amp;channels, 0);\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[vkdemo] Loaded texture {} with dimensions {}x{} and {} channels\", path, width, height,\n                                 channels);\n#endif\n    if (data == nullptr) {\n        throw std::runtime_error(\"Failed to load texture image!\");\n    }\n\n    // add alpha channel if image has no alpha channel\n    if (channels == 3) {\n        auto new_data = new unsigned char[width * height * 4];\n        for (auto y = 0; y &lt; height; y++) {\n            for (auto x = 0; x &lt; width; x++) {\n                new_data[(y * width + x) * 4 + 0] = data[(y * width + x) * 3 + 0];\n                new_data[(y * width + x) * 4 + 1] = data[(y * width + x) * 3 + 1];\n                new_data[(y * width + x) * 4 + 2] = data[(y * width + x) * 3 + 2];\n                new_data[(y * width + x) * 4 + 3] = 255;\n            }\n        }\n        stbi_image_free(data);\n        data     = new_data;\n        channels = 4;\n    }\n\n    VkDeviceSize image_size = width * height * channels;\n\n    VkBuffer          staging_buffer;\n    VmaAllocation     staging_buffer_allocation;\n    VmaAllocationInfo staging_buffer_allocation_info;\n\n    VkBufferCreateInfo buffer_info{\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, // sType\n        nullptr,                              // pNext\n        0,                                    // flags\n        image_size,                           // size\n        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,     // usage\n        {},                                   // sharingMode\n        0,                                    // queueFamilyIndexCount\n        nullptr                               // pQueueFamilyIndices\n    };\n\n    VmaAllocationCreateInfo alloc_info{};\n    alloc_info.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;\n    alloc_info.usage = VMA_MEMORY_USAGE_AUTO;\n\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;buffer_info, &amp;alloc_info, &amp;staging_buffer, &amp;staging_buffer_allocation,\n                                      &amp;staging_buffer_allocation_info))\n\n    memcpy(staging_buffer_allocation_info.pMappedData, data, static_cast&lt;size_t&gt;(image_size));\n\n    stbi_image_free(data);\n\n    VkImageCreateInfo image_info{\n        VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, // sType\n        nullptr,                             // pNext\n        0,                                   // flags\n        VK_IMAGE_TYPE_2D,                    // imageType\n        VK_FORMAT_R8G8B8A8_SRGB,             // format\n        {\n            static_cast&lt;uint32_t&gt;(width),                             // width\n            static_cast&lt;uint32_t&gt;(height),                            // height\n            1,                                                        // depth\n        },                                                            // extent\n        1,                                                            // mipLevels\n        1,                                                            // arrayLayers\n        VK_SAMPLE_COUNT_1_BIT,                                        // samples\n        VK_IMAGE_TILING_OPTIMAL,                                      // tiling\n        VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, // usage\n        VK_SHARING_MODE_EXCLUSIVE,                                    // sharingMode\n        0,                                                            // queueFamilyIndexCount\n        nullptr,                                                      // pQueueFamilyIndices\n        VK_IMAGE_LAYOUT_UNDEFINED                                     // initialLayout\n    };\n\n    VmaAllocationCreateInfo image_alloc_info{};\n    image_alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VK_ASSERT_SUCCESS(vmaCreateImage(vma_allocator_, &amp;image_info, &amp;image_alloc_info, &amp;textures_[i].image,\n                                     &amp;textures_[i].image_memory, nullptr))\n\n    image_layout_transition(textures_[i].image, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED,\n                            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);\n\n    vulkan::copy_buffer_to_image(display_provider_-&gt;vk_device_, display_provider_-&gt;queues_[vulkan::queue::GRAPHICS],\n                                 command_pool_, staging_buffer, textures_[i].image, width, height);\n\n    image_layout_transition(textures_[i].image, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n                            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);\n\n    vmaDestroyBuffer(vma_allocator_, staging_buffer, staging_buffer_allocation);\n\n    deletion_queue_.emplace([=]() {\n        vmaDestroyImage(vma_allocator_, textures_[i].image, textures_[i].image_memory);\n    });\n\n    VkImageViewCreateInfo view_info{\n        VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, // sType\n        nullptr,                                  // pNext\n        0,                                        // flags\n        textures_[i].image,                       // image\n        VK_IMAGE_VIEW_TYPE_2D,                    // viewType\n        VK_FORMAT_R8G8B8A8_SRGB,                  // format\n        {},                                       // components\n        {\n            VK_IMAGE_ASPECT_COLOR_BIT, // aspectMask\n            0,                         // baseMipLevel\n            1,                         // levelCount\n            0,                         // baseArrayLayer\n            1                          // layerCount\n        } // subresourceRange\n    };\n\n    VK_ASSERT_SUCCESS(vkCreateImageView(display_provider_-&gt;vk_device_, &amp;view_info, nullptr, &amp;textures_[i].image_view))\n    deletion_queue_.emplace([=]() {\n        vkDestroyImageView(display_provider_-&gt;vk_device_, textures_[i].image_view, nullptr);\n    });\n}\n\nvoid vkdemo::image_layout_transition(VkImage image, [[maybe_unused]] VkFormat format, VkImageLayout old_layout,\n                                     VkImageLayout new_layout) {\n    VkCommandBuffer command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n\n    VkImageMemoryBarrier barrier{\n        VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, // sType\n        nullptr,                                // pNext\n        {},                                     // srcAccessMask\n        {},                                     // dstAccessMask\n        old_layout,                             // oldLayout\n        new_layout,                             // newLayout\n        VK_QUEUE_FAMILY_IGNORED,                // srcQueueFamilyIndex\n        VK_QUEUE_FAMILY_IGNORED,                // dstQueueFamilyIndex\n        image,                                  // image\n        {\n            (new_layout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) ? VK_IMAGE_ASPECT_DEPTH_BIT\n                                                                             : VK_IMAGE_ASPECT_COLOR_BIT, // aspectMask\n            0,                                                                                            // baseMipLevel\n            1,                                                                                            // levelCount\n            0,                                                                                            // baseArrayLayer\n            1                                                                                             // layerCount\n        } // subresourceRange\n    };\n\n    VkPipelineStageFlags source_stage;\n    VkPipelineStageFlags destination_stage;\n\n    if (old_layout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; new_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {\n        barrier.srcAccessMask = 0;\n        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;\n\n        source_stage      = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;\n        destination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;\n    } else if (old_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; new_layout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {\n        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;\n        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;\n\n        source_stage      = VK_PIPELINE_STAGE_TRANSFER_BIT;\n        destination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;\n    } else if (old_layout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; new_layout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {\n        barrier.srcAccessMask = 0;\n        barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;\n\n        source_stage      = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;\n        destination_stage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;\n    } else {\n        throw std::invalid_argument(\"Unsupported layout transition!\");\n    }\n\n    vkCmdPipelineBarrier(command_buffer_local, source_stage, destination_stage, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier);\n\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], command_buffer_local);\n}\n\nvoid vkdemo::load_model() {\n    tinyobj::attrib_t                attrib;\n    std::vector&lt;tinyobj::shape_t&gt;    shapes;\n    std::vector&lt;tinyobj::material_t&gt; materials;\n    std::string                      warn, err;\n\n    auto path = switchboard_-&gt;get_env(\"ILLIXR_DEMO_DATA\") + \"/scene.obj\";\n    if (!tinyobj::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, path.c_str(),\n                          switchboard_-&gt;get_env_char(\"ILLIXR_DEMO_DATA\"))) {\n        throw std::runtime_error(warn + err);\n    }\n\n    textures_.resize(materials.size());\n\n    for (auto i = 0; i &lt; static_cast&lt;int&gt;(materials.size()); i++) {\n        auto material = materials[i];\n        if (!material.diffuse_texname.empty()) {\n            path = switchboard_-&gt;get_env(\"ILLIXR_DEMO_DATA\") + \"/\" + material.diffuse_texname;\n            load_texture(path, i);\n        }\n    }\n\n#ifndef NDEBUG\n    spdlog::get(\"illixr\")-&gt;debug(\"[vkdemo] Loaded {} textures_\", textures_.size());\n#endif\n\n    std::unordered_map&lt;vertex, uint32_t&gt; unique_vertices{};\n    for (const auto&amp; shape : shapes) {\n        model model{};\n        model.index_offset = static_cast&lt;uint32_t&gt;(indices_.size());\n        for (const auto&amp; index : shape.mesh.indices) {\n            vertex vertex{};\n\n            vertex.pos = {attrib.vertices[3 * index.vertex_index + 0] * 2, attrib.vertices[3 * index.vertex_index + 1] * 2,\n                          attrib.vertices[3 * index.vertex_index + 2] * 2};\n\n            vertex.uv = {attrib.texcoords[2 * index.texcoord_index + 0], 1.0f - attrib.texcoords[2 * index.texcoord_index + 1]};\n\n            if (unique_vertices.count(vertex) == 0) {\n                unique_vertices[vertex] = static_cast&lt;uint32_t&gt;(vertices_.size());\n                vertices_.push_back(vertex);\n            }\n\n            indices_.push_back(unique_vertices[vertex]);\n        }\n        if (!shape.mesh.material_ids.empty()) {\n            model.texture_index = shape.mesh.material_ids[0];\n        } else {\n            model.texture_index = -1;\n        }\n        model.index_count = static_cast&lt;uint32_t&gt;(shape.mesh.indices.size());\n        models_.push_back(model);\n    }\n}\n\nvoid vkdemo::create_vertex_buffer() {\n    VkBufferCreateInfo staging_buffer_info{\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,    // sType\n        nullptr,                                 // pNext\n        0,                                       // flags\n        sizeof(vertices_[0]) * vertices_.size(), // size\n        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,        // usage\n        {},                                      // sharingMode\n        0,                                       // queueFamilyIndexCount\n        nullptr                                  // pQueueFamilyIndices\n    };\n\n    VmaAllocationCreateInfo staging_alloc_info{};\n    staging_alloc_info.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n    staging_alloc_info.usage = VMA_MEMORY_USAGE_AUTO;\n\n    VkBuffer      staging_buffer;\n    VmaAllocation staging_buffer_allocation;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;staging_buffer_info, &amp;staging_alloc_info, &amp;staging_buffer,\n                                      &amp;staging_buffer_allocation, nullptr))\n\n    VkBufferCreateInfo buffer_info{\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,                                 // sType\n        nullptr,                                                              // pNext\n        0,                                                                    // flags\n        sizeof(vertices_[0]) * vertices_.size(),                              // size\n        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, // usage\n        {},                                                                   // sharingMode\n        0,                                                                    // queueFamilyIndexCount\n        nullptr                                                               // pQueueFamilyIndices\n    };\n\n    VmaAllocationCreateInfo alloc_info{};\n    alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VmaAllocation buffer_allocation;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;buffer_info, &amp;alloc_info, &amp;vertex_buffer_, &amp;buffer_allocation, nullptr))\n\n    void* mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, staging_buffer_allocation, &amp;mapped_data))\n    memcpy(mapped_data, vertices_.data(), sizeof(vertices_[0]) * vertices_.size());\n    vmaUnmapMemory(vma_allocator_, staging_buffer_allocation);\n\n    VkCommandBuffer command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    copy_region{\n        0,                                      // srcOffset\n        0,                                      // dstOffset\n        sizeof(vertices_[0]) * vertices_.size() // size\n    };\n    vkCmdCopyBuffer(command_buffer_local, staging_buffer, vertex_buffer_, 1, &amp;copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, staging_buffer, staging_buffer_allocation);\n\n    deletion_queue_.emplace([=]() {\n        vmaDestroyBuffer(vma_allocator_, vertex_buffer_, buffer_allocation);\n    });\n}\n\nvoid vkdemo::create_index_buffer() {\n    VkBufferCreateInfo staging_buffer_info{\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,  // sType\n        nullptr,                               // pNext\n        0,                                     // flags\n        sizeof(indices_[0]) * indices_.size(), // size\n        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,      // usage\n        {},                                    // sharingMode\n        0,                                     // queueFamilyIndexCount\n        nullptr                                // pQueueFamilyIndices\n    };\n\n    VmaAllocationCreateInfo staging_alloc_info{};\n    staging_alloc_info.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;\n    staging_alloc_info.usage = VMA_MEMORY_USAGE_AUTO;\n\n    VkBuffer      staging_buffer;\n    VmaAllocation staging_buffer_allocation;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;staging_buffer_info, &amp;staging_alloc_info, &amp;staging_buffer,\n                                      &amp;staging_buffer_allocation, nullptr))\n\n    VkBufferCreateInfo buffer_info{\n        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,                                // sType\n        nullptr,                                                             // pNext\n        0,                                                                   // flags\n        sizeof(indices_[0]) * indices_.size(),                               // size\n        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, // usage\n        {},                                                                  // sharingMode\n        0,                                                                   // queueFamilyIndexCount\n        nullptr                                                              // pQueueFamilyIndices\n    };\n\n    VmaAllocationCreateInfo alloc_info{};\n    alloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    VmaAllocation buffer_allocation;\n    VK_ASSERT_SUCCESS(vmaCreateBuffer(vma_allocator_, &amp;buffer_info, &amp;alloc_info, &amp;index_buffer_, &amp;buffer_allocation, nullptr))\n\n    void* mapped_data;\n    VK_ASSERT_SUCCESS(vmaMapMemory(vma_allocator_, staging_buffer_allocation, &amp;mapped_data))\n    memcpy(mapped_data, indices_.data(), sizeof(indices_[0]) * indices_.size());\n    vmaUnmapMemory(vma_allocator_, staging_buffer_allocation);\n\n    VkCommandBuffer command_buffer_local = vulkan::begin_one_time_command(display_provider_-&gt;vk_device_, command_pool_);\n    VkBufferCopy    copy_region{\n        0,                                    // srcOffset\n        0,                                    // dstOffset\n        sizeof(indices_[0]) * indices_.size() // size\n    };\n    vkCmdCopyBuffer(command_buffer_local, staging_buffer, index_buffer_, 1, &amp;copy_region);\n    vulkan::end_one_time_command(display_provider_-&gt;vk_device_, command_pool_,\n                                 display_provider_-&gt;queues_[vulkan::queue::GRAPHICS], command_buffer_local);\n\n    vmaDestroyBuffer(vma_allocator_, staging_buffer, staging_buffer_allocation);\n\n    deletion_queue_.emplace([=]() {\n        vmaDestroyBuffer(vma_allocator_, index_buffer_, buffer_allocation);\n    });\n}\n\nvoid vkdemo::create_pipeline(VkRenderPass render_pass, uint32_t subpass) {\n    if (pipeline_ != VK_NULL_HANDLE) {\n        throw std::runtime_error(\"vkdemo::create_pipeline: pipeline already created\");\n    }\n\n    auto           folder = std::string(SHADER_FOLDER);\n    VkShaderModule vert =\n        vulkan::create_shader_module(display_provider_-&gt;vk_device_, vulkan::read_file(folder + \"/demo.vert.spv\"));\n    VkShaderModule frag =\n        vulkan::create_shader_module(display_provider_-&gt;vk_device_, vulkan::read_file(folder + \"/demo.frag.spv\"));\n\n    VkPipelineShaderStageCreateInfo vert_shader_stage_info{\n        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, // sType\n        nullptr,                                             // pNext\n        0,                                                   // flags\n        VK_SHADER_STAGE_VERTEX_BIT,                          // stage\n        vert,                                                // module\n        \"main\",                                              // pName\n        nullptr                                              // pSpecializationInfo\n    };\n\n    VkPipelineShaderStageCreateInfo frag_shader_stage_info{\n        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, // sType\n        nullptr,                                             // pNext\n        0,                                                   // flags\n        VK_SHADER_STAGE_FRAGMENT_BIT,                        // stage\n        frag,                                                // module\n        \"main\",                                              // pName\n        nullptr                                              // pSpecializationInfo\n    };\n\n    VkPipelineShaderStageCreateInfo shader_stages[] = {vert_shader_stage_info, frag_shader_stage_info};\n\n    auto binding_description    = vertex::get_binding_description();\n    auto attribute_descriptions = vertex::get_attribute_descriptions();\n\n    VkPipelineVertexInputStateCreateInfo vertex_input_info{\n        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, // sType\n        nullptr,                                                   // pNext\n        0,                                                         // flags\n        1,                                                         // vertexBindingDescriptionCount\n        &amp;binding_description,                                      // pVertexBindingDescriptions\n        static_cast&lt;uint32_t&gt;(attribute_descriptions.size()),      // vertexAttributeDescriptionCount\n        attribute_descriptions.data()                              // pVertexAttributeDescriptions\n    };\n\n    VkPipelineInputAssemblyStateCreateInfo input_assembly{\n        VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, // sType\n        nullptr,                                                     // pNext\n        0,                                                           // flags\n        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,                         // topology\n        VK_FALSE                                                     // primitiveRestartEnable\n    };\n\n    auto per_eye_extent =\n        VkExtent2D{display_provider_-&gt;swapchain_extent_.width / 2, display_provider_-&gt;swapchain_extent_.height};\n\n    VkViewport viewport{\n        0.0f,                                      // x\n        0.0f,                                      // y\n        static_cast&lt;float&gt;(per_eye_extent.width),  // width\n        static_cast&lt;float&gt;(per_eye_extent.height), // height\n        0.0f,                                      // minDepth\n        1.0f                                       // maxDepth\n    };\n\n    VkRect2D scissor{\n        {0, 0},        // offset\n        per_eye_extent // extent\n    };\n\n    VkPipelineViewportStateCreateInfo viewport_state{\n        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, // sType\n        nullptr,                                               // pNext\n        0,                                                     // flags\n        1,                                                     // viewportCount\n        &amp;viewport,                                             // pViewports\n        1,                                                     // scissorCount\n        &amp;scissor                                               // pScissors\n    };\n\n    VkPipelineRasterizationStateCreateInfo rasterizer{\n        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, // sType\n        nullptr,                                                    // pNext\n        0,                                                          // flags\n        VK_FALSE,                                                   // depthClampEnable\n        VK_FALSE,                                                   // rasterizerDiscardEnable\n        VK_POLYGON_MODE_FILL,                                       // polygonMode\n        VK_CULL_MODE_NONE,                                          // cullMode\n        VK_FRONT_FACE_COUNTER_CLOCKWISE,                            // frontFace\n        VK_FALSE,                                                   // depthBiasEnable\n        0.f,                                                        // depthBiasConstantFactor\n        0.f,                                                        // depthBiasClamp\n        0.f,                                                        // depthBiasSlopeFactor\n        1.0f                                                        // lineWidth\n    };\n\n    VkPipelineMultisampleStateCreateInfo multisampling{\n        VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, // sType\n        nullptr,                                                  // pNext\n        0,                                                        // flags\n        VK_SAMPLE_COUNT_1_BIT,                                    // rasterizationSamples\n        VK_FALSE,                                                 // sampleShadingEnable\n        0.f,                                                      // minSampleShading\n        nullptr,                                                  // pSampleMask\n        0,                                                        // alphaToCoverageEnable\n        0                                                         // alphaToOneEnable\n    };\n\n    VkPipelineColorBlendAttachmentState color_blend_attachment{\n        VK_FALSE, // blendEnable\n        {},       // srcColorBlendFactor\n        {},       // dstColorBlendFactor\n        {},       // colorBlendOp\n        {},       // srcAlphaBlendFactor\n        {},       // dstAlphaBlendFactor\n        {},       // alphaBlendOp\n        VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |\n            VK_COLOR_COMPONENT_A_BIT // colorWriteMask\n    };\n\n    VkPipelineColorBlendAttachmentState depth_blend_attachment{\n        VK_FALSE, // blendEnable\n        {},       // srcColorBlendFactor\n        {},       // dstColorBlendFactor\n        {},       // colorBlendOp\n        {},       // srcAlphaBlendFactor\n        {},       // dstAlphaBlendFactor\n        {},       // alphaBlendOp\n        VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |\n            VK_COLOR_COMPONENT_A_BIT // colorWriteMask\n    };\n\n    VkPipelineColorBlendAttachmentState blend_attachments[2] = {color_blend_attachment, depth_blend_attachment};\n\n    VkPipelineColorBlendStateCreateInfo color_blending{\n        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, // sType\n        nullptr,                                                  // pNext\n        0,                                                        // flags\n        0,                                                        // logicOpEnable\n        {},                                                       // logicOp\n        2,                                                        // attachmentCount\n        blend_attachments,                                        // pAttachments\n        {0.f, 0.f, 0.f, 0.f}                                      // blendConstants\n    };\n\n    VkPushConstantRange push_constant_range{\n        VK_SHADER_STAGE_FRAGMENT_BIT, // stageFlags\n        0,                            // offset\n        sizeof(model_push_constant)   // size\n    };\n\n    VkPipelineLayoutCreateInfo pipeline_layout_info{\n        VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, // sType\n        nullptr,                                       // pNext\n        0,                                             // flags\n        1,                                             // setLayoutCount\n        &amp;descriptor_set_layout_,                       // pSetLayouts\n        1,                                             // pushConstantRangeCount\n        &amp;push_constant_range                           // pPushConstantRanges\n    };\n\n    VK_ASSERT_SUCCESS(vkCreatePipelineLayout(display_provider_-&gt;vk_device_, &amp;pipeline_layout_info, nullptr, &amp;pipeline_layout_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyPipelineLayout(display_provider_-&gt;vk_device_, pipeline_layout_, nullptr);\n    });\n\n    VkPipelineDepthStencilStateCreateInfo depth_stencil{\n        VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,                                 // sType\n        nullptr,                                                                                    // pNext\n        0,                                                                                          // flags\n        VK_TRUE,                                                                                    // depthTestEnable\n        VK_TRUE,                                                                                    // depthWriteEnable\n        rendering_params::reverse_z ? VK_COMPARE_OP_GREATER_OR_EQUAL : VK_COMPARE_OP_LESS_OR_EQUAL, // depthCompareOp\n        VK_FALSE,                                                                                   // depthBoundsTestEnable\n        VK_FALSE,                                                                                   // stencilTestEnable\n        {},                                                                                         // front\n        {},                                                                                         // back\n        0.0f,                                                                                       // minDepthBounds\n        1.0f                                                                                        // maxDepthBounds\n    };\n\n    VkGraphicsPipelineCreateInfo pipeline_info{\n        VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, // sType\n        nullptr,                                         // pNext\n        0,                                               // flags\n        2,                                               // stageCount\n        shader_stages,                                   // pStages\n        &amp;vertex_input_info,                              // pVertexInputState\n        &amp;input_assembly,                                 // pInputAssemblyState\n        nullptr,                                         // pTessellationState\n        &amp;viewport_state,                                 // pViewportState\n        &amp;rasterizer,                                     // pRasterizationState\n        &amp;multisampling,                                  // pMultisampleState\n        &amp;depth_stencil,                                  // pDepthStencilState\n        &amp;color_blending,                                 // pColorBlendState\n        nullptr,                                         // pDynamicState\n        pipeline_layout_,                                // layout\n        render_pass,                                     // renderPass\n        subpass,                                         // subpass\n        {},                                              // basePipelineHandle\n        0                                                // basePipelineIndex\n    };\n\n    VK_ASSERT_SUCCESS(\n        vkCreateGraphicsPipelines(display_provider_-&gt;vk_device_, VK_NULL_HANDLE, 1, &amp;pipeline_info, nullptr, &amp;pipeline_))\n    deletion_queue_.emplace([=]() {\n        vkDestroyPipeline(display_provider_-&gt;vk_device_, pipeline_, nullptr);\n    });\n\n    vkDestroyShaderModule(display_provider_-&gt;vk_device_, vert, nullptr);\n    vkDestroyShaderModule(display_provider_-&gt;vk_device_, frag, nullptr);\n}\n\n[[maybe_unused]] vkdemo_plugin::vkdemo_plugin(const std::string&amp; name, phonebook* pb)\n    : plugin{name, pb}\n    , vkd_{std::make_shared&lt;vkdemo&gt;(pb)} {\n    pb-&gt;register_impl&lt;vulkan::app&gt;(std::static_pointer_cast&lt;vkdemo&gt;(vkd_));\n}\n\nvoid vkdemo_plugin::start() {\n    vkd_-&gt;initialize();\n}\n\nPLUGIN_MAIN(vkdemo_plugin)\n</code></pre>"},{"location":"api/vkdemo_2service_8hpp/","title":"File service.hpp","text":"<p>FileList &gt; services &gt; vkdemo &gt; service.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/pose_prediction.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/render_pass.hpp\"</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;stack&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/matrix_transform.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/hash.hpp&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> </ul>"},{"location":"api/vkdemo_2service_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/vkdemo_2service_8hpp/#classes","title":"Classes","text":"Type Name struct model struct texture struct vertex class vkdemo class vkdemo_plugin"},{"location":"api/vkdemo_2service_8hpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL define GLM_FORCE_DEPTH_ZERO_TO_ONE define GLM_FORCE_RADIANS"},{"location":"api/vkdemo_2service_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/vkdemo_2service_8hpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre>"},{"location":"api/vkdemo_2service_8hpp/#define-glm_force_depth_zero_to_one","title":"define GLM_FORCE_DEPTH_ZERO_TO_ONE","text":"<pre><code>#define GLM_FORCE_DEPTH_ZERO_TO_ONE \n</code></pre>"},{"location":"api/vkdemo_2service_8hpp/#define-glm_force_radians","title":"define GLM_FORCE_RADIANS","text":"<pre><code>#define GLM_FORCE_RADIANS \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/services/vkdemo/service.hpp</code></p>"},{"location":"api/vkdemo_2service_8hpp_source/","title":"File service.hpp","text":"<p>File List &gt; services &gt; vkdemo &gt; service.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/pose_prediction.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/render_pass.hpp\"\n\n#include &lt;functional&gt;\n#include &lt;stack&gt;\n\n#define GLM_FORCE_RADIANS\n#define GLM_FORCE_DEPTH_ZERO_TO_ONE\n#define GLM_ENABLE_EXPERIMENTAL\n#include &lt;glm/glm.hpp&gt;\n#include &lt;glm/gtc/matrix_transform.hpp&gt;\n#include &lt;glm/gtx/hash.hpp&gt;\n#include &lt;map&gt;\n\nnamespace ILLIXR {\nstruct vertex {\n    glm::vec3 pos;\n    glm::vec2 uv;\n\n    static VkVertexInputBindingDescription get_binding_description() {\n        VkVertexInputBindingDescription binding_description{\n            0,                          // binding\n            sizeof(vertex),             // stride\n            VK_VERTEX_INPUT_RATE_VERTEX // inputRate\n        };\n        return binding_description;\n    }\n\n    static std::array&lt;VkVertexInputAttributeDescription, 2&gt; get_attribute_descriptions() {\n        std::array&lt;VkVertexInputAttributeDescription, 2&gt; attribute_descriptions{{{\n                                                                                     0,                          // location\n                                                                                     0,                          // binding\n                                                                                     VK_FORMAT_R32G32B32_SFLOAT, // format\n                                                                                     offsetof(vertex, pos)       // offset\n                                                                                 },\n                                                                                 {\n                                                                                     1,                       // location\n                                                                                     0,                       // binding\n                                                                                     VK_FORMAT_R32G32_SFLOAT, // format\n                                                                                     offsetof(vertex, uv)     // offset\n                                                                                 }}};\n\n        return attribute_descriptions;\n    }\n\n    bool operator==(const vertex&amp; other) const {\n        return pos == other.pos &amp;&amp; uv == other.uv;\n    }\n};\n\nstruct model {\n    int                       texture_index;\n    [[maybe_unused]] uint32_t vertex_offset;\n    uint32_t                  index_offset;\n    uint32_t                  index_count;\n};\n\nstruct texture {\n    VkImage       image;\n    VmaAllocation image_memory;\n    VkImageView   image_view;\n};\n\nclass vkdemo : public vulkan::app {\npublic:\n    explicit vkdemo(const phonebook* const pb);\n    void initialize();\n    void setup(VkRenderPass render_pass, uint32_t subpass,\n               std::shared_ptr&lt;vulkan::buffer_pool&lt;data_format::fast_pose_type&gt;&gt; _) override;\n    void update_uniforms(const data_format::pose_type&amp; fp) override;\n    void record_command_buffer(VkCommandBuffer command_buffer, VkFramebuffer frame_buffer, int buffer_ind, bool left) override;\n    void destroy() override;\n\n    [[maybe_unused]] bool is_external() override {\n        return false;\n    }\n\nprivate:\n    void update_uniform(const data_format::pose_type&amp; pose, int eye);\n    void bake_models();\n    void create_descriptor_set_layout();\n    void create_uniform_buffers();\n    void create_descriptor_pool();\n    void create_texture_sampler_();\n    void create_descriptor_set();\n    void load_texture(const std::string&amp; path, int i);\n    void image_layout_transition(VkImage image, [[maybe_unused]] VkFormat format, VkImageLayout old_layout,\n                                 VkImageLayout new_layout);\n    void load_model();\n    void create_vertex_buffer();\n    void create_index_buffer();\n    void create_pipeline(VkRenderPass render_pass, uint32_t subpass);\n\n    const std::shared_ptr&lt;switchboard&gt;                  switchboard_;\n    const std::shared_ptr&lt;data_format::pose_prediction&gt; pose_prediction_;\n    const std::shared_ptr&lt;vulkan::display_provider&gt;     display_provider_ = nullptr;\n    const std::shared_ptr&lt;const relative_clock&gt;         clock_;\n\n    Eigen::Matrix4f       basic_projection_[2];\n    std::vector&lt;model&gt;    models_;\n    std::vector&lt;vertex&gt;   vertices_;\n    std::vector&lt;uint32_t&gt; indices_;\n\n    std::array&lt;std::vector&lt;VkImageView&gt;, 2&gt; buffer_pool_;\n\n    std::stack&lt;std::function&lt;void()&gt;&gt; deletion_queue_;\n    VmaAllocator                      vma_allocator_{};\n    VkCommandPool                     command_pool_{};\n    [[maybe_unused]] VkCommandBuffer  command_buffer_{};\n\n    VkDescriptorSetLayout          descriptor_set_layout_{};\n    VkDescriptorPool               descriptor_pool_{};\n    std::array&lt;VkDescriptorSet, 2&gt; descriptor_sets_{};\n\n    std::array&lt;VkBuffer, 2&gt;          uniform_buffers_{};\n    std::array&lt;VmaAllocation, 2&gt;     uniform_buffer_allocations_{};\n    std::array&lt;VmaAllocationInfo, 2&gt; uniform_buffer_allocation_infos_{};\n\n    VkBuffer vertex_buffer_{};\n    VkBuffer index_buffer_{};\n\n    VkPipelineLayout pipeline_layout_{};\n\n    std::vector&lt;VkDescriptorImageInfo&gt; image_infos_;\n    std::vector&lt;texture&gt;               textures_;\n    VkSampler                          texture_sampler_{};\n    std::map&lt;uint32_t, uint32_t&gt;       texture_map_;\n};\n\nclass vkdemo_plugin : public plugin {\npublic:\n    [[maybe_unused]] vkdemo_plugin(const std::string&amp; name, phonebook* pb);\n    void start() override;\n\nprivate:\n    std::shared_ptr&lt;vkdemo&gt; vkd_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/vulkan__display_8hpp/","title":"File vulkan_display.hpp","text":"<p>FileList &gt; src &gt; vulkan_display.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"display/glfw_extended.hpp\"</code></li> <li><code>#include \"display/headless.hpp\"</code></li> <li><code>#include \"display/x11_direct.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"illixr/vk/display_provider.hpp\"</code></li> <li><code>#include \"illixr/vk/third_party/vk_mem_alloc.h\"</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"api/vulkan__display_8hpp/#classes","title":"Classes","text":"Type Name class display_vk <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/vulkan_display.hpp</code></p>"},{"location":"api/vulkan__display_8hpp_source/","title":"File vulkan_display.hpp","text":"<p>File List &gt; src &gt; vulkan_display.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"display/glfw_extended.hpp\"\n#include \"display/headless.hpp\"\n#include \"display/x11_direct.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"illixr/vk/display_provider.hpp\"\n#include \"illixr/vk/third_party/vk_mem_alloc.h\"\n\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\nusing namespace ILLIXR;\n\nclass display_vk : public vulkan::display_provider {\npublic:\n    explicit display_vk(const phonebook* const pb)\n        : switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n        , clock_{pb-&gt;lookup_impl&lt;relative_clock&gt;()} { }\n\n    ~display_vk() override {\n        running_ = false;\n        if (main_thread_.joinable()) {\n            main_thread_.join();\n        }\n        cleanup();\n    }\n\n    void start(std::set&lt;const char*&gt; instance_extensions, std::set&lt;const char*&gt; device_extensions) {\n        auto manual_device_selection = switchboard_-&gt;get_env_char(\"ILLIXR_VULKAN_SELECT_GPU\");\n        selected_gpu_                = manual_device_selection ? std::stoi(manual_device_selection) : -1;\n\n        // ILLIXR_DISPLAY_MODE defaults to GLFW if not specified.\n        const char* env_var = switchboard_-&gt;get_env_char(\"ILLIXR_DISPLAY_MODE\");\n        if (!strcmp(env_var, \"glfw\")) {\n            spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Selected GLFW for display backend\");\n            backend_type_ = display::display_backend::GLFW;\n        } else if (!strcmp(env_var, \"headless\")) {\n            spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Selected headless for display backend\");\n            backend_type_ = display::display_backend::HEADLESS;\n        } else if (!strcmp(env_var, \"x11_direct\")) {\n            spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Selected X11 direct mode for display backend\");\n            backend_type_ = display::display_backend::X11_DIRECT;\n            direct_mode_  = true;\n        } else {\n            throw std::runtime_error(\"Invalid display mode: \" + std::string(env_var));\n        }\n\n        setup(std::move(instance_extensions), std::move(device_extensions));\n\n        if (backend_type_ == display::display_backend::GLFW /* || backend_type_ == display::display_backend::X11_DIRECT*/) {\n            main_thread_ = std::thread(&amp;display_vk::main_loop, this);\n            while (!ready_) {\n                // yield\n                std::this_thread::yield();\n            }\n        }\n    }\n\n    void setup(std::set&lt;const char*&gt; instance_extensions, std::set&lt;const char*&gt; device_extensions) {\n        if (backend_type_ == display::display_backend::GLFW) {\n            backend_ = std::make_shared&lt;display::glfw_extended&gt;();\n        } else if (backend_type_ == display::display_backend::X11_DIRECT) {\n            backend_ = std::make_shared&lt;display::x11_direct&gt;(\n                clock_, switchboard_-&gt;get_writer&lt;switchboard::event_wrapper&lt;time_point&gt;&gt;(\"vsync_estimate\"));\n        } else {\n            backend_ = std::make_shared&lt;display::headless&gt;();\n        }\n\n        if (backend_type_ != display::display_backend::HEADLESS) {\n            required_device_extensions_.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME);\n        }\n\n        create_vk_instance(std::move(instance_extensions));\n        if (backend_type_ == display::display_backend::GLFW) {\n            backend_-&gt;setup_display(switchboard_, vk_instance_, nullptr);\n            vk_surface_ = backend_-&gt;create_surface();\n            select_physical_device();\n        } else {\n            select_physical_device();\n            backend_-&gt;setup_display(switchboard_, vk_instance_, vk_physical_device_);\n            vk_surface_ = backend_-&gt;create_surface();\n        }\n\n        auto backend_device_extensions = backend_-&gt;get_required_device_extensions();\n        device_extensions.insert(backend_device_extensions.begin(), backend_device_extensions.end());\n        create_logical_device(std::move(device_extensions));\n\n        if (backend_type_ != display::display_backend::HEADLESS) {\n            create_swapchain();\n        }\n    }\n\n    void recreate_swapchain() override {\n        if (backend_type_ == display::display_backend::HEADLESS) {\n            throw std::runtime_error(\"Cannot recreate swapchain in headless mode!\");\n        }\n\n        vkDeviceWaitIdle(vk_device_);\n\n        destroy_swapchain();\n\n        create_swapchain();\n    }\n\n    void poll_window_events() override {\n        should_poll_ = true;\n    }\n\nprivate:\n    void create_vk_instance(const std::set&lt;const char*&gt;&amp; instance_extensions) {\n        // Enable validation layers if ILLIXR_VULKAN_VALIDATION_LAYERS is set to true.\n        bool enable_validation_layers = switchboard_-&gt;get_env_bool(\"ILLIXR_VULKAN_VALIDATION_LAYERS\");\n        if (enable_validation_layers)\n            spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Vulkan validation layers enabled\");\n\n        VkApplicationInfo app_info{};\n        app_info.sType              = VK_STRUCTURE_TYPE_APPLICATION_INFO;\n        app_info.pApplicationName   = \"ILLIXR Vulkan Display\";\n        app_info.applicationVersion = VK_MAKE_VERSION(1, 0, 0);\n        app_info.pEngineName        = \"ILLIXR\";\n        app_info.engineVersion      = VK_MAKE_VERSION(1, 0, 0);\n        app_info.apiVersion         = VK_API_VERSION_1_2;\n\n        auto                     backend_required_instance_extensions = backend_-&gt;get_required_instance_extensions();\n        std::vector&lt;const char*&gt; backend_required_instance_extensions_vec(backend_required_instance_extensions.begin(),\n                                                                          backend_required_instance_extensions.end());\n        if (enable_validation_layers) {\n            backend_required_instance_extensions_vec.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);\n        }\n        backend_required_instance_extensions_vec.insert(backend_required_instance_extensions_vec.end(),\n                                                        instance_extensions.begin(), instance_extensions.end());\n\n        this-&gt;enabled_instance_extensions_ = backend_required_instance_extensions_vec;\n\n        VkInstanceCreateInfo create_info{};\n        create_info.sType                   = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n        create_info.pApplicationInfo        = &amp;app_info;\n        create_info.enabledExtensionCount   = static_cast&lt;uint32_t&gt;(backend_required_instance_extensions_vec.size());\n        create_info.ppEnabledExtensionNames = backend_required_instance_extensions_vec.data();\n\n        // print enabled instance extensions\n        spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Enabled instance extensions:\");\n        for (const auto&amp; extension : backend_required_instance_extensions_vec) {\n            spdlog::get(\"illixr\")-&gt;info(\"\\t {}\", extension);\n        }\n\n        // enable validation layers\n        std::vector&lt;const char*&gt; validation_layers = {\"VK_LAYER_KHRONOS_validation\"};\n\n        if (enable_validation_layers) {\n            create_info.enabledLayerCount   = static_cast&lt;uint32_t&gt;(validation_layers.size());\n            create_info.ppEnabledLayerNames = validation_layers.data();\n\n            // debug messenger\n            VkDebugUtilsMessengerCreateInfoEXT debug_messenger_create_info{};\n            debug_messenger_create_info.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;\n            debug_messenger_create_info.messageSeverity =\n                VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;\n            debug_messenger_create_info.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |\n                VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;\n            debug_messenger_create_info.pfnUserCallback =\n                [](VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType,\n                   const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) -&gt; VkBool32 {\n                (void) pUserData;\n                // convert severity flag to string\n                const char* severity = \"???\";\n                if (messageSeverity &amp; VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) {\n                    severity = \"VERBOSE\";\n                } else if (messageSeverity &amp; VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) {\n                    severity = \"INFO\";\n                } else if (messageSeverity &amp; VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {\n                    severity = \"WARNING\";\n                } else if (messageSeverity &amp; VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) {\n                    severity = \"ERROR\";\n                }\n\n                // convert message type flag to string\n                const char* type = \"???\";\n                if (messageType &amp; VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT) {\n                    type = \"GENERAL\";\n                } else if (messageType &amp; VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT) {\n                    type = \"VALIDATION\";\n                } else if (messageType &amp; VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) {\n                    type = \"PERFORMANCE\";\n                }\n                spdlog::get(\"illixr\")-&gt;warn(\"[display_vk] [{}: {}] {}\", severity, type, pCallbackData-&gt;pMessage);\n                return VK_FALSE;\n            };\n\n            create_info.pNext = &amp;debug_messenger_create_info;\n        } else {\n            create_info.enabledLayerCount = 0;\n        }\n\n        if (vkCreateInstance(&amp;create_info, nullptr, &amp;vk_instance_) != VK_SUCCESS) {\n            ILLIXR::abort(\"Failed to create Vulkan instance!\");\n        }\n    }\n\n    bool is_physical_device_suitable(VkPhysicalDevice const&amp; physical_device) {\n        VkPhysicalDeviceProperties device_properties;\n        vkGetPhysicalDeviceProperties(physical_device, &amp;device_properties);\n\n        VkPhysicalDeviceFeatures device_features;\n        vkGetPhysicalDeviceFeatures(physical_device, &amp;device_features);\n\n        // check if the device supports the extensions we need\n        std::set&lt;std::string&gt; unmet_extensions(required_device_extensions_.begin(), required_device_extensions_.end());\n\n        uint32_t extension_count;\n        vkEnumerateDeviceExtensionProperties(physical_device, nullptr, &amp;extension_count, nullptr);\n        std::vector&lt;VkExtensionProperties&gt; available_extensions(extension_count);\n        vkEnumerateDeviceExtensionProperties(physical_device, nullptr, &amp;extension_count, available_extensions.data());\n\n        for (const auto&amp; extension : available_extensions) {\n            unmet_extensions.erase(extension.extensionName);\n        }\n\n        if (!unmet_extensions.empty()) {\n            return false;\n        }\n\n        if (backend_type_ == display::display_backend::GLFW) {\n            // check if the device supports the swapchain we need\n            auto swapchain_details = vulkan::query_swapchain_details(physical_device, vk_surface_);\n            if (swapchain_details.formats.empty() || swapchain_details.present_modes.empty()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    void select_physical_device() {\n        uint32_t device_count = 0;\n        vkEnumeratePhysicalDevices(vk_instance_, &amp;device_count, nullptr);\n\n        if (device_count == 0) {\n            ILLIXR::abort(\"No Vulkan devices found!\");\n        }\n\n        std::vector&lt;VkPhysicalDevice&gt; devices(device_count);\n        vkEnumeratePhysicalDevices(vk_instance_, &amp;device_count, devices.data());\n\n        std::vector&lt;VkPhysicalDevice&gt; suitable_devices;\n        std::vector&lt;VkPhysicalDevice&gt; unsuitable_devices;\n        for (const auto&amp; device : devices) {\n            if (is_physical_device_suitable(device)) {\n                suitable_devices.push_back(device);\n            } else {\n                unsuitable_devices.push_back(device);\n            }\n        }\n\n        spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Found {} Vulkan devices\", device_count);\n        int index = 0;\n        for (const auto&amp; device : suitable_devices) {\n            VkPhysicalDeviceProperties device_properties;\n            vkGetPhysicalDeviceProperties(device, &amp;device_properties);\n            spdlog::get(\"illixr\")-&gt;info(\"\\t[{}] {}\", index, device_properties.deviceName);\n            index++;\n        }\n        if (!unsuitable_devices.empty()) {\n            spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Found {} unsuitable Vulkan devices\", unsuitable_devices.size());\n            for (const auto&amp; device : unsuitable_devices) {\n                VkPhysicalDeviceProperties device_properties;\n                vkGetPhysicalDeviceProperties(device, &amp;device_properties);\n                spdlog::get(\"illixr\")-&gt;info(\"\\t{}\", device_properties.deviceName);\n            }\n        }\n\n        if (selected_gpu_ == -1) {\n            // select the first suitable device\n            vk_physical_device_ = suitable_devices[0];\n        } else {\n            // select the device specified by the user\n            vk_physical_device_ = suitable_devices[selected_gpu_];\n        }\n\n        VkPhysicalDeviceProperties device_properties;\n        vkGetPhysicalDeviceProperties(vk_physical_device_, &amp;device_properties);\n        spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Selected device: {}\", device_properties.deviceName);\n    }\n\n    void create_logical_device(const std::set&lt;const char*&gt;&amp; device_extensions) {\n        vulkan::queue_families indices =\n            vulkan::find_queue_families(vk_physical_device_, vk_surface_, backend_type_ == display::display_backend::HEADLESS);\n\n        std::vector&lt;VkDeviceQueueCreateInfo&gt; queue_create_infos;\n        std::set&lt;uint32_t&gt;                   unique_queue_families = {indices.graphics_family.value()};\n\n        if (indices.present_family.has_value()) {\n            unique_queue_families.insert(indices.present_family.value());\n        }\n\n        if (indices.has_compression()) {\n            unique_queue_families.insert(indices.encode_family.value());\n            unique_queue_families.insert(indices.decode_family.value());\n        }\n\n        if (indices.dedicated_transfer.has_value()) {\n            unique_queue_families.insert(indices.dedicated_transfer.value());\n        }\n\n        if (indices.compute_family.has_value()) {\n            unique_queue_families.insert(indices.compute_family.value());\n        }\n\n        float queue_priority = 1.0f;\n        for (uint32_t queue_family : unique_queue_families) {\n            VkDeviceQueueCreateInfo queue_create_info{};\n            queue_create_info.sType            = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;\n            queue_create_info.queueFamilyIndex = queue_family;\n            queue_create_info.queueCount       = 1;\n            queue_create_info.pQueuePriorities = &amp;queue_priority;\n            queue_create_infos.push_back(queue_create_info);\n        }\n\n        VkPhysicalDeviceFeatures device_features{};\n        device_features.samplerAnisotropy = VK_TRUE;\n\n        VkPhysicalDeviceSynchronization2FeaturesKHR synchronization_2_features = {\n            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES, nullptr, true};\n\n        VkPhysicalDeviceTimelineSemaphoreFeatures timeline_semaphore_features{\n            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,\n            &amp;synchronization_2_features, // pNext\n            VK_TRUE                      // timelineSemaphore\n        };\n\n        features_ = VkPhysicalDeviceFeatures2{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, &amp;timeline_semaphore_features,\n                                              device_features};\n\n        required_device_extensions_.insert(required_device_extensions_.end(), device_extensions.begin(),\n                                           device_extensions.end());\n\n        this-&gt;enabled_device_extensions_ = required_device_extensions_;\n\n        VkDeviceCreateInfo create_info{};\n        create_info.sType                   = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;\n        create_info.pQueueCreateInfos       = queue_create_infos.data();\n        create_info.queueCreateInfoCount    = static_cast&lt;uint32_t&gt;(queue_create_infos.size());\n        create_info.enabledExtensionCount   = static_cast&lt;uint32_t&gt;(required_device_extensions_.size());\n        create_info.ppEnabledExtensionNames = required_device_extensions_.data();\n        create_info.pNext                   = &amp;features_;\n\n        // print enabled device extensions\n        spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Enabled instance extensions:\");\n        for (const auto&amp; extension : required_device_extensions_) {\n            spdlog::get(\"illixr\")-&gt;info(\"\\t {}\", extension);\n        }\n\n        VK_ASSERT_SUCCESS(vkCreateDevice(vk_physical_device_, &amp;create_info, nullptr, &amp;vk_device_));\n\n        vulkan::queue graphics_queue{};\n        vkGetDeviceQueue(vk_device_, indices.graphics_family.value(), 0, &amp;graphics_queue.vk_queue);\n        graphics_queue.family        = indices.graphics_family.value();\n        graphics_queue.type          = vulkan::queue::GRAPHICS;\n        graphics_queue.mutex         = std::make_shared&lt;std::mutex&gt;();\n        queues_[graphics_queue.type] = graphics_queue;\n\n        if (indices.present_family.has_value()) {\n            vulkan::queue present_queue{};\n            vkGetDeviceQueue(vk_device_, indices.present_family.value(), 0, &amp;present_queue.vk_queue);\n            present_queue.family        = indices.present_family.value();\n            present_queue.type          = vulkan::queue::PRESENT;\n            present_queue.mutex         = std::make_shared&lt;std::mutex&gt;();\n            queues_[present_queue.type] = present_queue;\n        }\n\n        if (indices.has_compression()) {\n            vulkan::queue encode_queue{};\n            vkGetDeviceQueue(vk_device_, indices.encode_family.value(), 0, &amp;encode_queue.vk_queue);\n            encode_queue.family        = indices.encode_family.value();\n            encode_queue.type          = vulkan::queue::ENCODE;\n            encode_queue.mutex         = std::make_shared&lt;std::mutex&gt;();\n            queues_[encode_queue.type] = encode_queue;\n\n            vulkan::queue decode_queue{};\n            vkGetDeviceQueue(vk_device_, indices.decode_family.value(), 0, &amp;decode_queue.vk_queue);\n            decode_queue.family        = indices.decode_family.value();\n            decode_queue.type          = vulkan::queue::DECODE;\n            decode_queue.mutex         = std::make_shared&lt;std::mutex&gt;();\n            queues_[decode_queue.type] = decode_queue;\n        }\n\n        if (indices.compute_family.has_value()) {\n            vulkan::queue compute_queue{};\n            vkGetDeviceQueue(vk_device_, indices.compute_family.value(), 0, &amp;compute_queue.vk_queue);\n            compute_queue.family        = indices.compute_family.value();\n            compute_queue.type          = vulkan::queue::COMPUTE;\n            compute_queue.mutex         = std::make_shared&lt;std::mutex&gt;();\n            queues_[compute_queue.type] = compute_queue;\n        }\n\n        if (indices.dedicated_transfer.has_value()) {\n            vulkan::queue transfer_queue{};\n            vkGetDeviceQueue(vk_device_, indices.dedicated_transfer.value(), 0, &amp;transfer_queue.vk_queue);\n            transfer_queue.family        = indices.dedicated_transfer.value();\n            transfer_queue.type          = vulkan::queue::DEDICATED_TRANSFER;\n            transfer_queue.mutex         = std::make_shared&lt;std::mutex&gt;();\n            queues_[transfer_queue.type] = transfer_queue;\n        }\n\n        vma_allocator_ = vulkan::create_vma_allocator(vk_instance_, vk_physical_device_, vk_device_);\n    }\n\n    void create_swapchain() {\n        // create surface\n        vulkan::swapchain_details swapchain_details = vulkan::query_swapchain_details(vk_physical_device_, vk_surface_);\n\n        // choose surface format\n        for (const auto&amp; available_format : swapchain_details.formats) {\n            if (available_format.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp;\n                available_format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {\n                spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Using VK_FORMAT_B8G8R8A8_SRGB\");\n                swapchain_image_format_ = available_format;\n                break;\n            } else if (available_format.format == VK_FORMAT_B8G8R8A8_UNORM &amp;&amp;\n                       available_format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {\n                spdlog::get(\"illixr\")-&gt;info(\"[vulkan_display] Using VK_FORMAT_B8G8R8A8_UNORM (direct mode)\");\n                swapchain_image_format_ = available_format;\n                break;\n            }\n        }\n\n        // choose present mode\n        VkPresentModeKHR swapchain_present_mode = VK_PRESENT_MODE_FIFO_KHR;\n        for (const auto&amp; available_present_mode : swapchain_details.present_modes) {\n            if (available_present_mode == VK_PRESENT_MODE_MAILBOX_KHR) {\n                swapchain_present_mode = available_present_mode;\n                break;\n            }\n        }\n\n        // choose swapchain extent\n        if (swapchain_details.capabilities.currentExtent.width != UINT32_MAX) {\n            swapchain_extent_ = swapchain_details.capabilities.currentExtent;\n        } else if (std::dynamic_pointer_cast&lt;display::glfw_extended&gt;(backend_) != nullptr) {\n            auto fb_size             = std::dynamic_pointer_cast&lt;display::glfw_extended&gt;(backend_)-&gt;get_framebuffer_size();\n            swapchain_extent_.width  = std::clamp(fb_size.first, swapchain_details.capabilities.minImageExtent.width,\n                                                  swapchain_details.capabilities.maxImageExtent.width);\n            swapchain_extent_.height = std::clamp(fb_size.second, swapchain_details.capabilities.minImageExtent.height,\n                                                  swapchain_details.capabilities.maxImageExtent.height);\n        }\n\n        uint32_t image_count = std::max(swapchain_details.capabilities.minImageCount, 2u); // double buffering\n        if (swapchain_details.capabilities.maxImageCount &gt; 0 &amp;&amp; image_count &gt; swapchain_details.capabilities.maxImageCount) {\n            image_count = swapchain_details.capabilities.maxImageCount;\n        }\n\n        VkSwapchainCreateInfoKHR create_info{}; //{VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR};\n        create_info.sType            = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;\n        create_info.surface          = vk_surface_;\n        create_info.minImageCount    = image_count;\n        create_info.imageFormat      = swapchain_image_format_.format;\n        create_info.imageColorSpace  = swapchain_image_format_.colorSpace;\n        create_info.imageExtent      = swapchain_extent_;\n        create_info.imageArrayLayers = 1;\n        create_info.imageUsage       = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;\n\n        vulkan::queue_families indices                = vulkan::find_queue_families(vk_physical_device_, vk_surface_);\n        uint32_t               queue_family_indices[] = {indices.graphics_family.value(), indices.present_family.value()};\n\n        if (indices.graphics_family != indices.present_family) {\n            create_info.imageSharingMode      = VK_SHARING_MODE_CONCURRENT;\n            create_info.queueFamilyIndexCount = 2;\n            create_info.pQueueFamilyIndices   = queue_family_indices;\n        } else {\n            create_info.imageSharingMode      = VK_SHARING_MODE_EXCLUSIVE;\n            create_info.queueFamilyIndexCount = 0;\n            create_info.pQueueFamilyIndices   = nullptr;\n        }\n\n        create_info.preTransform   = swapchain_details.capabilities.currentTransform;\n        create_info.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;\n        create_info.presentMode    = swapchain_present_mode;\n        create_info.clipped        = VK_TRUE;\n        create_info.oldSwapchain   = VK_NULL_HANDLE;\n\n        auto create_shared_swapchains =\n            (PFN_vkCreateSharedSwapchainsKHR) vkGetInstanceProcAddr(vk_instance_, \"vkCreateSharedSwapchainsKHR\");\n\n        if (vkCreateSwapchainKHR(vk_device_, &amp;create_info, nullptr, &amp;vk_swapchain_) != VK_SUCCESS) {\n            ILLIXR::abort(\"Failed to create Vulkan swapchain!\");\n        }\n\n        // get swapchain images\n        vkGetSwapchainImagesKHR(vk_device_, vk_swapchain_, &amp;image_count, nullptr);\n        swapchain_images_.resize(image_count);\n        vkGetSwapchainImagesKHR(vk_device_, vk_swapchain_, &amp;image_count, swapchain_images_.data());\n\n        swapchain_image_views_.resize(swapchain_images_.size());\n        for (size_t i = 0; i &lt; swapchain_images_.size(); i++) {\n            swapchain_image_views_[i] = vulkan::create_image_view(vk_device_, swapchain_images_[i],\n                                                                  swapchain_image_format_.format, VK_IMAGE_ASPECT_COLOR_BIT);\n        }\n    }\n\n    void destroy_swapchain() {\n        for (auto&amp; image_view : swapchain_image_views_) {\n            vkDestroyImageView(vk_device_, image_view, nullptr);\n        }\n        vkDestroySwapchainKHR(vk_device_, vk_swapchain_, nullptr);\n    }\n\n    void cleanup() {\n        vkDeviceWaitIdle(vk_device_);\n        destroy_swapchain();\n\n        vmaDestroyAllocator(vma_allocator_);\n\n        vkDestroyDevice(vk_device_, nullptr);\n\n        if (!direct_mode_) {\n            vkDestroySurfaceKHR(vk_instance_, vk_surface_, nullptr);\n        }\n\n        vkDestroyInstance(vk_instance_, nullptr);\n\n        backend_-&gt;cleanup();\n    }\n\n    void main_loop() {\n        ready_ = true;\n\n        while (running_) {\n            if (!direct_mode_) {\n                if (should_poll_.exchange(false)) {\n                    auto glfw_backend = std::dynamic_pointer_cast&lt;display::glfw_extended&gt;(backend_);\n                    glfw_backend-&gt;poll_window_events();\n                }\n            } else {\n                auto x11_backend = std::dynamic_pointer_cast&lt;display::x11_direct&gt;(backend_);\n                if (!x11_backend-&gt;display_timings_event_registered_) {\n                    x11_backend-&gt;register_display_timings_event(vk_device_);\n                } else {\n                    x11_backend-&gt;tick();\n                }\n            }\n        }\n    }\n\nprivate:\n    std::vector&lt;const char*&gt; required_device_extensions_ = {VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME};\n\n    std::thread       main_thread_;\n    std::atomic&lt;bool&gt; ready_{false};\n    std::atomic&lt;bool&gt; running_{true};\n\n    display::display_backend::display_backend_type backend_type_;\n    bool                                           direct_mode_{false};\n    int                                            selected_gpu_{-1};\n\n    std::shared_ptr&lt;display::display_backend&gt; backend_;\n\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n\n    std::atomic&lt;bool&gt; should_poll_{true};\n\n    std::shared_ptr&lt;relative_clock&gt; clock_;\n};\n</code></pre>"},{"location":"api/vulkan__objects_8hpp/","title":"File vulkan_objects.hpp","text":"<p>FileList &gt; illixr &gt; vk &gt; vulkan_objects.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/vk/third_party/vk_mem_alloc.h\"</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> </ul>"},{"location":"api/vulkan__objects_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace vulkan"},{"location":"api/vulkan__objects_8hpp/#classes","title":"Classes","text":"Type Name struct buffer_pool &lt;typename T&gt; struct vk_image <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/vk/vulkan_objects.hpp</code></p>"},{"location":"api/vulkan__objects_8hpp_source/","title":"File vulkan_objects.hpp","text":"<p>File List &gt; illixr &gt; vk &gt; vulkan_objects.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/vk/third_party/vk_mem_alloc.h\"\n\n#include &lt;vulkan/vulkan.h&gt;\n\nnamespace ILLIXR::vulkan {\n\ntypedef int8_t image_index_t;\n\nstruct vk_image {\n    VkImageCreateInfo               image_info;\n    VkExternalMemoryImageCreateInfo export_image_info;\n    VkImage                         image;\n    VkImageView                     image_view;\n    VmaAllocation                   allocation;\n    VmaAllocationInfo               allocation_info;\n    int                             fd;\n};\n\ntemplate&lt;typename T&gt;\nstruct buffer_pool {\n    enum image_state { FREE, SRC_IN_FLIGHT, AVAILABLE, POST_PROCESSING_IN_FLIGHT };\n\n    std::vector&lt;std::array&lt;vk_image, 2&gt;&gt; image_pool;\n    std::vector&lt;std::array&lt;vk_image, 2&gt;&gt; depth_image_pool;\n\n    std::vector&lt;image_state&gt; image_states{};\n    std::vector&lt;T&gt;           image_data{};\n    std::mutex               image_state_mutex{};\n\n    image_index_t latest_decoded_image = -1;\n\n    explicit buffer_pool(const std::vector&lt;std::array&lt;vk_image, 2&gt;&gt;&amp; image_pool,\n                         const std::vector&lt;std::array&lt;vk_image, 2&gt;&gt;&amp; depth_image_pool)\n        : image_pool(image_pool)\n        , depth_image_pool(depth_image_pool) {\n        image_states.resize(image_pool.size());\n        image_data.resize(image_pool.size());\n    }\n\n    image_index_t src_acquire_image() {\n        std::lock_guard&lt;std::mutex&gt; lock(image_state_mutex);\n        for (image_index_t i = 0; i &lt; image_states.size(); i++) {\n            if (image_states[i] == FREE) {\n                image_states[i] = SRC_IN_FLIGHT;\n                // std::cout &lt;&lt; \"Src acquire image \" &lt;&lt; (int) i &lt;&lt; std::endl;\n                return i;\n            }\n        }\n        assert(false &amp;&amp; \"No free images in buffer pool\");\n        return -1;\n    }\n\n    void src_release_image(image_index_t image_index, T&amp;&amp; data) {\n        std::lock_guard&lt;std::mutex&gt; lock(image_state_mutex);\n        // Mark the previous images as free\n        for (image_index_t i = 0; i &lt; image_states.size(); i++) {\n            if (image_states[i] == AVAILABLE) {\n                image_states[i] = FREE;\n            }\n        }\n        assert(image_states[image_index] == SRC_IN_FLIGHT);\n        image_states[image_index]     = AVAILABLE;\n        this-&gt;image_data[image_index] = std::move(data);\n        latest_decoded_image          = image_index;\n\n        // std::cout &lt;&lt; \"Src release image \" &lt;&lt; (int) image_index &lt;&lt; std::endl;\n    }\n\n    std::pair&lt;image_index_t, T&gt; post_processing_acquire_image(image_index_t last_image_index = -1) {\n        std::lock_guard&lt;std::mutex&gt; lock(image_state_mutex);\n        if (latest_decoded_image == -1) {\n            return {-1, {}};\n        }\n        if (latest_decoded_image == last_image_index) {\n            return {-1, {}};\n        }\n        assert(latest_decoded_image != -1);\n        assert(image_states[latest_decoded_image] == AVAILABLE);\n        image_states[latest_decoded_image] = POST_PROCESSING_IN_FLIGHT;\n\n        // std::cout &lt;&lt; \"Post processing acquire image \" &lt;&lt; (int) latest_decoded_image &lt;&lt; std::endl;\n        return {latest_decoded_image, image_data[latest_decoded_image]};\n    }\n\n    void post_processing_release_image(image_index_t image_index) {\n        std::lock_guard&lt;std::mutex&gt; lock(image_state_mutex);\n        assert(image_states[image_index] == POST_PROCESSING_IN_FLIGHT);\n        if (image_index != latest_decoded_image) {\n            image_states[image_index] = FREE;\n        } else {\n            image_states[image_index] = AVAILABLE;\n        }\n\n        // std::cout &lt;&lt; \"Post processing release image \" &lt;&lt; (int) image_index &lt;&lt; std::endl;\n    }\n};\n\n} // namespace ILLIXR::vulkan\n</code></pre>"},{"location":"api/vulkan__utils_8cpp/","title":"File vulkan_utils.cpp","text":"<p>FileList &gt; utils &gt; vulkan_utils.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/vk/vulkan_utils.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/vk/third_party/vk_mem_alloc.h\"</code></li> </ul>"},{"location":"api/vulkan__utils_8cpp/#macros","title":"Macros","text":"Type Name define VMA_DYNAMIC_VULKAN_FUNCTIONS <code>1</code> define VMA_IMPLEMENTATION define VMA_STATIC_VULKAN_FUNCTIONS <code>0</code>"},{"location":"api/vulkan__utils_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/vulkan__utils_8cpp/#define-vma_dynamic_vulkan_functions","title":"define VMA_DYNAMIC_VULKAN_FUNCTIONS","text":"<pre><code>#define VMA_DYNAMIC_VULKAN_FUNCTIONS `1`\n</code></pre>"},{"location":"api/vulkan__utils_8cpp/#define-vma_implementation","title":"define VMA_IMPLEMENTATION","text":"<pre><code>#define VMA_IMPLEMENTATION \n</code></pre>"},{"location":"api/vulkan__utils_8cpp/#define-vma_static_vulkan_functions","title":"define VMA_STATIC_VULKAN_FUNCTIONS","text":"<pre><code>#define VMA_STATIC_VULKAN_FUNCTIONS `0`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/utils/vulkan_utils.cpp</code></p>"},{"location":"api/vulkan__utils_8cpp_source/","title":"File vulkan_utils.cpp","text":"<p>File List &gt; utils &gt; vulkan_utils.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#define VMA_IMPLEMENTATION\n#include \"illixr/vk/vulkan_utils.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;vulkan/vulkan.h&gt;\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Weverything\"\n#define VMA_STATIC_VULKAN_FUNCTIONS  0\n#define VMA_DYNAMIC_VULKAN_FUNCTIONS 1\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/vk/third_party/vk_mem_alloc.h\"\n#pragma clang diagnostic pop\n\nusing namespace ILLIXR::vulkan;\n\nstd::string ILLIXR::vulkan::error_string(VkResult err_code) {\n    switch (err_code) {\n    case VK_NOT_READY:\n        return \"VK_NOT_READY\";\n    case VK_TIMEOUT:\n        return \"VK_TIMEOUT\";\n    case VK_EVENT_SET:\n        return \"VK_EVENT_SET\";\n    case VK_EVENT_RESET:\n        return \"VK_EVENT_RESET\";\n    case VK_INCOMPLETE:\n        return \"VK_INCOMPLETE\";\n    case VK_ERROR_OUT_OF_HOST_MEMORY:\n        return \"VK_ERROR_OUT_OF_HOST_MEMORY\";\n    case VK_ERROR_OUT_OF_DEVICE_MEMORY:\n        return \"VK_ERROR_OUT_OF_DEVICE_MEMORY\";\n    case VK_ERROR_INITIALIZATION_FAILED:\n        return \"VK_ERROR_INITIALIZATION_FAILED\";\n    case VK_ERROR_DEVICE_LOST:\n        return \"VK_ERROR_DEVICE_LOST\";\n    case VK_ERROR_MEMORY_MAP_FAILED:\n        return \"VK_ERROR_MEMORY_MAP_FAILED\";\n    case VK_ERROR_LAYER_NOT_PRESENT:\n        return \"VK_ERROR_LAYER_NOT_PRESENT\";\n    case VK_ERROR_EXTENSION_NOT_PRESENT:\n        return \"VK_ERROR_EXTENSION_NOT_PRESENT\";\n    case VK_ERROR_FEATURE_NOT_PRESENT:\n        return \"VK_ERROR_FEATURE_NOT_PRESENT\";\n    case VK_ERROR_INCOMPATIBLE_DRIVER:\n        return \"VK_ERROR_INCOMPATIBLE_DRIVER\";\n    case VK_ERROR_TOO_MANY_OBJECTS:\n        return \"VK_ERROR_TOO_MANY_OBJECTS\";\n    case VK_ERROR_FORMAT_NOT_SUPPORTED:\n        return \"VK_ERROR_FORMAT_NOT_SUPPORTED\";\n    case VK_ERROR_FRAGMENTED_POOL:\n        return \"VK_ERROR_FRAGMENTED_POOL\";\n    case VK_ERROR_UNKNOWN:\n        return \"VK_ERROR_UNKNOWN\";\n    case VK_ERROR_OUT_OF_POOL_MEMORY:\n        return \"VK_ERROR_OUT_OF_POOL_MEMORY\";\n    case VK_ERROR_INVALID_EXTERNAL_HANDLE:\n        return \"VK_ERROR_INVALID_EXTERNAL_HANDLE\";\n    case VK_ERROR_FRAGMENTATION:\n        return \"VK_ERROR_FRAGMENTATION\";\n    case VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS:\n        return \"VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS\";\n    case VK_ERROR_SURFACE_LOST_KHR:\n        return \"VK_ERROR_SURFACE_LOST_KHR\";\n    case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:\n        return \"VK_ERROR_NATIVE_WINDOW_IN_USE_KHR\";\n    case VK_SUBOPTIMAL_KHR:\n        return \"VK_SUBOPTIMAL_KHR\";\n    case VK_ERROR_OUT_OF_DATE_KHR:\n        return \"VK_ERROR_OUT_OF_DATE_KHR\";\n    case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:\n        return \"VK_ERROR_INCOMPATIBLE_DISPLAY_KHR\";\n    case VK_ERROR_VALIDATION_FAILED_EXT:\n        return \"VK_ERROR_VALIDATION_FAILED_EXT\";\n    case VK_ERROR_INVALID_SHADER_NV:\n        return \"VK_ERROR_INVALID_SHADER_NV\";\n    case VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT:\n        return \"VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT\";\n    case VK_ERROR_NOT_PERMITTED_EXT:\n        return \"VK_ERROR_NOT_PERMITTED_EXT\";\n    case VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT:\n        return \"VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT\";\n    default:\n        return \"UNKNOWN_ERROR\";\n    }\n}\n\nVkShaderModule ILLIXR::vulkan::create_shader_module(VkDevice device, std::vector&lt;char&gt;&amp;&amp; code) {\n    VkShaderModuleCreateInfo createInfo{\n        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,   // sType\n        nullptr,                                       // pNext\n        0,                                             // flags\n        code.size(),                                   // codeSize\n        reinterpret_cast&lt;const uint32_t*&gt;(code.data()) // pCode\n    };\n\n    VkShaderModule shaderModule;\n    VK_ASSERT_SUCCESS(vkCreateShaderModule(device, &amp;createInfo, nullptr, &amp;shaderModule))\n\n    return shaderModule;\n}\n\nVkSemaphore ILLIXR::vulkan::create_timeline_semaphore(VkDevice device, int initial_value,\n                                                      VkExportSemaphoreCreateInfo* export_semaphore_create_info) {\n    VkSemaphoreTypeCreateInfo timeline_create_info{};\n    timeline_create_info.sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;\n    timeline_create_info.pNext         = export_semaphore_create_info;\n    timeline_create_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;\n    timeline_create_info.initialValue  = initial_value;\n\n    VkSemaphoreCreateInfo semaphore_create_info{};\n    semaphore_create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;\n    semaphore_create_info.pNext = &amp;timeline_create_info;\n    semaphore_create_info.flags = 0;\n\n    VkSemaphore semaphore;\n    auto        ret = vkCreateSemaphore(device, &amp;semaphore_create_info, nullptr, &amp;semaphore);\n    VK_ASSERT_SUCCESS(ret);\n\n    return semaphore;\n}\n\n[[maybe_unused]] void ILLIXR::vulkan::wait_timeline_semaphore(VkDevice device, VkSemaphore semaphore, uint64_t value) {\n    VkSemaphoreWaitInfo wait_info{};\n    wait_info.sType          = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;\n    wait_info.pNext          = nullptr;\n    wait_info.flags          = 0;\n    wait_info.semaphoreCount = 1;\n    wait_info.pSemaphores    = &amp;semaphore;\n    wait_info.pValues        = &amp;value;\n\n    auto ret = vkWaitSemaphores(device, &amp;wait_info, UINT64_MAX);\n    VK_ASSERT_SUCCESS(ret);\n}\n\nvoid ILLIXR::vulkan::wait_timeline_semaphores(VkDevice device, const std::map&lt;VkSemaphore, uint64_t&gt;&amp; semaphores) {\n    VkSemaphoreWaitInfo wait_info{};\n    wait_info.sType          = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;\n    wait_info.pNext          = nullptr;\n    wait_info.flags          = 0;\n    wait_info.semaphoreCount = semaphores.size();\n    std::vector&lt;VkSemaphore&gt; semaphore_vec;\n    std::vector&lt;uint64_t&gt;    value_vec;\n    for (auto&amp; [semaphore, value] : semaphores) {\n        semaphore_vec.push_back(semaphore);\n        value_vec.push_back(value);\n    }\n    wait_info.pSemaphores = semaphore_vec.data();\n    wait_info.pValues     = value_vec.data();\n\n    auto ret = vkWaitSemaphores(device, &amp;wait_info, UINT64_MAX);\n    VK_ASSERT_SUCCESS(ret);\n}\n\nVmaAllocator ILLIXR::vulkan::create_vma_allocator(VkInstance vk_instance, VkPhysicalDevice vk_physical_device,\n                                                  VkDevice vk_device) {\n    VmaVulkanFunctions vulkanFunctions{};\n    vulkanFunctions.vkGetInstanceProcAddr = &amp;vkGetInstanceProcAddr;\n    vulkanFunctions.vkGetDeviceProcAddr   = &amp;vkGetDeviceProcAddr;\n\n    VmaAllocatorCreateInfo allocatorCreateInfo{};\n    allocatorCreateInfo.physicalDevice   = vk_physical_device;\n    allocatorCreateInfo.device           = vk_device;\n    allocatorCreateInfo.pVulkanFunctions = &amp;vulkanFunctions;\n    allocatorCreateInfo.instance         = vk_instance;\n    allocatorCreateInfo.vulkanApiVersion = VK_API_VERSION_1_2;\n\n    VmaAllocator allocator;\n    VK_ASSERT_SUCCESS(vmaCreateAllocator(&amp;allocatorCreateInfo, &amp;allocator))\n    return allocator;\n}\n\nVkCommandBuffer ILLIXR::vulkan::begin_one_time_command(VkDevice vk_device, VkCommandPool vk_command_pool) {\n    VkCommandBufferAllocateInfo allocInfo{\n        VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, // sType\n        nullptr,                                        // pNext\n        vk_command_pool,                                // commandPool\n        VK_COMMAND_BUFFER_LEVEL_PRIMARY,                // level\n        1                                               // commandBufferCount\n    };\n\n    VkCommandBuffer commandBuffer;\n    VK_ASSERT_SUCCESS(vkAllocateCommandBuffers(vk_device, &amp;allocInfo, &amp;commandBuffer))\n\n    VkCommandBufferBeginInfo beginInfo{\n        VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, // sType\n        nullptr,                                     // pNext\n        VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, // flags\n        nullptr                                      // pInheritanceInfo\n    };\n    VK_ASSERT_SUCCESS(vkBeginCommandBuffer(commandBuffer, &amp;beginInfo))\n\n    return commandBuffer;\n}\n\nvoid ILLIXR::vulkan::end_one_time_command(VkDevice vk_device, VkCommandPool vk_command_pool, const queue&amp; q,\n                                          VkCommandBuffer vk_command_buffer) {\n    VK_ASSERT_SUCCESS(vkEndCommandBuffer(vk_command_buffer))\n\n    VkSubmitInfo submitInfo{\n        VK_STRUCTURE_TYPE_SUBMIT_INFO, // sType\n        nullptr,                       // pNext\n        0,                             // waitSemaphoreCount\n        nullptr,                       // pWaitSemaphores\n        nullptr,                       // pWaitDstStageMask\n        1,                             // commandBufferCount\n        &amp;vk_command_buffer,            // pCommandBuffers\n        0,                             // signalSemaphoreCount\n        nullptr                        // pSignalSemaphores\n    };\n\n    std::lock_guard&lt;std::mutex&gt; lock(*q.mutex);\n    VK_ASSERT_SUCCESS(vkQueueSubmit(q.vk_queue, 1, &amp;submitInfo, VK_NULL_HANDLE))\n    VK_ASSERT_SUCCESS(vkQueueWaitIdle(q.vk_queue))\n\n    vkFreeCommandBuffers(vk_device, vk_command_pool, 1, &amp;vk_command_buffer);\n}\n\nVkCommandPool ILLIXR::vulkan::create_command_pool(VkDevice device, uint32_t queue_family_index) {\n    VkCommandPoolCreateInfo poolInfo = {\n        VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,      // sType\n        nullptr,                                         // pNext\n        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT, // flags\n        queue_family_index                               // queueFamilyIndex\n    };\n\n    VkCommandPool command_pool;\n    VK_ASSERT_SUCCESS(vkCreateCommandPool(device, &amp;poolInfo, nullptr, &amp;command_pool))\n    return command_pool;\n}\n\nVkCommandBuffer ILLIXR::vulkan::create_command_buffer(VkDevice device, VkCommandPool command_pool) {\n    VkCommandBufferAllocateInfo allocInfo = {\n        VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, // sType\n        nullptr,                                        // pNext\n        command_pool,                                   // commandPool\n        VK_COMMAND_BUFFER_LEVEL_PRIMARY,                // level\n        1                                               // commandBufferCount\n    };\n\n    VkCommandBuffer command_buffer;\n    VK_ASSERT_SUCCESS(vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;command_buffer))\n    return command_buffer;\n}\n\nVkResult ILLIXR::vulkan::locked_queue_submit(queue&amp; q, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence) {\n    std::lock_guard&lt;std::mutex&gt; lock(*q.mutex);\n    return vkQueueSubmit(q.vk_queue, submitCount, pSubmits, fence);\n}\n\nstd::vector&lt;char&gt; ILLIXR::vulkan::read_file(const std::string&amp; path) {\n    std::ifstream file(path, std::ios::ate | std::ios::binary);\n\n    if (!file.is_open()) {\n        throw std::runtime_error(\"failed to open file!\");\n    }\n\n    size_t            fileSize = (size_t) file.tellg();\n    std::vector&lt;char&gt; buffer(fileSize);\n\n    file.seekg(0);\n    file.read(buffer.data(), static_cast&lt;long&gt;(fileSize));\n\n    file.close();\n    return buffer;\n}\n\nvoid ILLIXR::vulkan::copy_buffer_to_image(VkDevice vk_device, queue q, VkCommandPool vk_command_pool, VkBuffer buffer,\n                                          VkImage image, uint32_t width, uint32_t height) {\n    VkCommandBuffer command_buffer = begin_one_time_command(vk_device, vk_command_pool);\n\n    VkBufferImageCopy region{\n        0, // bufferOffset\n        0, // bufferRowLength\n        0, // bufferImageHeight\n        {\n            // imageSubresource\n            VK_IMAGE_ASPECT_COLOR_BIT, // aspectMask\n            0,                         // mipLevel\n            0,                         // baseArrayLayer\n            1,                         // layerCount\n        },\n        {0, 0, 0},         // imageOffset\n        {width, height, 1} // imageExtent\n    };\n    vkCmdCopyBufferToImage(command_buffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region);\n\n    end_one_time_command(vk_device, vk_command_pool, std::move(q), command_buffer);\n}\n\nswapchain_details ILLIXR::vulkan::query_swapchain_details(VkPhysicalDevice const&amp; physical_device,\n                                                          VkSurfaceKHR const&amp;     vk_surface) {\n    swapchain_details details;\n\n    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, vk_surface, &amp;details.capabilities);\n\n    uint32_t format_count;\n    vkGetPhysicalDeviceSurfaceFormatsKHR(physical_device, vk_surface, &amp;format_count, nullptr);\n\n    if (format_count != 0) {\n        details.formats.resize(format_count);\n        vkGetPhysicalDeviceSurfaceFormatsKHR(physical_device, vk_surface, &amp;format_count, details.formats.data());\n    }\n\n    uint32_t present_mode_count;\n    vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, vk_surface, &amp;present_mode_count, nullptr);\n\n    if (present_mode_count != 0) {\n        details.present_modes.resize(present_mode_count);\n        vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, vk_surface, &amp;present_mode_count,\n                                                  details.present_modes.data());\n    }\n\n    return details;\n}\n\nqueue_families ILLIXR::vulkan::find_queue_families(VkPhysicalDevice const&amp; physical_device, VkSurfaceKHR const&amp; vk_surface,\n                                                   bool no_present) {\n    queue_families indices;\n\n    uint32_t queue_family_count = 0;\n    vkGetPhysicalDeviceQueueFamilyProperties(physical_device, &amp;queue_family_count, nullptr);\n\n    std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queue_family_count);\n    vkGetPhysicalDeviceQueueFamilyProperties(physical_device, &amp;queue_family_count, queueFamilies.data());\n\n    int i = 0;\n    for (const auto&amp; queue_family : queueFamilies) {\n        if (queue_family.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {\n            indices.graphics_family = i;\n        }\n\n#if defined(VK_ENABLE_BETA_EXTENSIONS)\n#endif\n        if (queue_family.queueFlags &amp; VK_QUEUE_COMPUTE_BIT) {\n            indices.compute_family = i;\n        }\n\n        // if (queue_family.queueFlags &amp; VK_QUEUE_TRANSFER_BIT) {\n        //     if (!(queue_family.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &amp;&amp; !(queue_family.queueFlags &amp; VK_QUEUE_COMPUTE_BIT)) {\n        //         indices.dedicated_transfer = i;\n        //     }\n        // }\n\n        if (!no_present) {\n            VkBool32 present_support = false;\n            vkGetPhysicalDeviceSurfaceSupportKHR(physical_device, i, vk_surface, &amp;present_support);\n\n            if (present_support) {\n                indices.present_family = i;\n            }\n        }\n\n        if (indices.has_compression()) {\n            break;\n        }\n\n        i++;\n    }\n\n    return indices;\n}\n\nVkImageView ILLIXR::vulkan::create_image_view(VkDevice device, VkImage image, VkFormat format,\n                                              VkImageAspectFlags aspect_flags) {\n    VkImageViewCreateInfo vk_image_view_create_info{};\n    vk_image_view_create_info.sType                           = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;\n    vk_image_view_create_info.image                           = image;\n    vk_image_view_create_info.viewType                        = VK_IMAGE_VIEW_TYPE_2D;\n    vk_image_view_create_info.format                          = format;\n    vk_image_view_create_info.subresourceRange.aspectMask     = aspect_flags;\n    vk_image_view_create_info.subresourceRange.baseMipLevel   = 0;\n    vk_image_view_create_info.subresourceRange.levelCount     = 1;\n    vk_image_view_create_info.subresourceRange.baseArrayLayer = 0;\n    vk_image_view_create_info.subresourceRange.layerCount     = 1;\n    vk_image_view_create_info.pNext                           = nullptr;\n\n    VkImageView vk_image_view;\n    VK_ASSERT_SUCCESS(vkCreateImageView(device, &amp;vk_image_view_create_info, nullptr, &amp;vk_image_view))\n    return vk_image_view;\n}\n</code></pre>"},{"location":"api/x11__direct_8cpp/","title":"File x11_direct.cpp","text":"<p>FileList &gt; display &gt; x11_direct.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"x11_direct.hpp\"</code></li> <li><code>#include \"illixr/vk/vulkan_utils.hpp\"</code></li> <li><code>#include \"X11/extensions/Xrandr.h\"</code></li> <li><code>#include &lt;vulkan/vulkan.h&gt;</code></li> <li><code>#include &lt;vulkan/vulkan_xlib_xrandr.h&gt;</code></li> <li><code>#include &lt;X11/Xlib.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/x11_direct.cpp</code></p>"},{"location":"api/x11__direct_8cpp_source/","title":"File x11_direct.cpp","text":"<p>File List &gt; display &gt; x11_direct.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"x11_direct.hpp\"\n\n#include \"illixr/vk/vulkan_utils.hpp\"\n#include \"X11/extensions/Xrandr.h\"\n\n#include &lt;vulkan/vulkan.h&gt;\n#include &lt;vulkan/vulkan_xlib_xrandr.h&gt;\n#include &lt;X11/Xlib.h&gt;\n\nusing namespace ILLIXR::display;\n\nvoid x11_direct::setup_display(const std::shared_ptr&lt;switchboard&gt; switchboard_, VkInstance vk_instance,\n                               VkPhysicalDevice vk_physical_device) {\n    this-&gt;vk_instance_        = vk_instance;\n    this-&gt;vk_physical_device_ = vk_physical_device;\n\n    Display* dpy = XOpenDisplay(nullptr);\n    if (dpy == nullptr) {\n        ILLIXR::abort(\"Failed to open X display\");\n        return;\n    }\n\n    uint32_t display_count;\n    VK_ASSERT_SUCCESS(vkGetPhysicalDeviceDisplayPropertiesKHR(vk_physical_device, &amp;display_count, nullptr));\n    std::vector&lt;VkDisplayPropertiesKHR&gt; display_properties(display_count);\n    VK_ASSERT_SUCCESS(vkGetPhysicalDeviceDisplayPropertiesKHR(vk_physical_device, &amp;display_count, display_properties.data()));\n\n    std::cout &lt;&lt; \"Found \" &lt;&lt; display_count &lt;&lt; \" displays:\" &lt;&lt; std::endl;\n    int index = 0;\n    for (const auto&amp; display : display_properties) {\n        std::cout &lt;&lt; \"\\t[\" &lt;&lt; index++ &lt;&lt; \"] \" &lt;&lt; display.displayName &lt;&lt; std::endl;\n    }\n\n    auto display_select_str = switchboard_-&gt;get_env_char(\"ILLIXR_DIRECT_MODE_DISPLAY\");\n    int  display_select     = 0;\n    if (display_select_str == nullptr) {\n        std::cout &lt;&lt; \"ILLIXR_DIRECT_MODE_DISPLAY not set, defaulting to the first display (\"\n                  &lt;&lt; display_properties[0].displayName &lt;&lt; \")\" &lt;&lt; std::endl;\n    } else {\n        display_select = std::stoi(display_select_str);\n    }\n\n    if (display_select &gt;= (int) display_count) {\n        ILLIXR::abort(\"Invalid display selection\");\n        return;\n    }\n\n    display_ = display_properties[display_select].display;\n\n    // Now we acquire the Xlib display\n    auto acquire_xlib_display = (PFN_vkAcquireXlibDisplayEXT) vkGetInstanceProcAddr(vk_instance, \"vkAcquireXlibDisplayEXT\");\n    if (acquire_xlib_display == nullptr) {\n        ILLIXR::abort(\"Failed to load vkAcquireXlibDisplayEXT\");\n        return;\n    }\n\n    auto ret = acquire_xlib_display(vk_physical_device, dpy, display_);\n    if (ret != VK_SUCCESS) {\n        ILLIXR::abort(\"Failed to acquire Xlib display\");\n        return;\n    }\n    std::cout &lt;&lt; \"Acquired Xlib display\" &lt;&lt; std::endl;\n}\n\nVkSurfaceKHR x11_direct::create_surface() {\n    uint32_t plane_count;\n    VK_ASSERT_SUCCESS(vkGetPhysicalDeviceDisplayPlanePropertiesKHR(vk_physical_device_, &amp;plane_count, nullptr));\n    std::vector&lt;VkDisplayPlanePropertiesKHR&gt; plane_properties(plane_count);\n    VK_ASSERT_SUCCESS(vkGetPhysicalDeviceDisplayPlanePropertiesKHR(vk_physical_device_, &amp;plane_count, plane_properties.data()));\n\n    uint32_t plane_index = 0;\n    for (const auto&amp; plane : plane_properties) {\n        if (plane.currentDisplay == nullptr) {\n            break;\n        }\n        plane_index++;\n    }\n\n    if (plane_index == plane_count) {\n        ILLIXR::abort(\"Failed to find display plane\");\n        return nullptr;\n    }\n\n    uint32_t mode_count;\n    VK_ASSERT_SUCCESS(vkGetDisplayModePropertiesKHR(vk_physical_device_, display_, &amp;mode_count, nullptr));\n    std::vector&lt;VkDisplayModePropertiesKHR&gt; mode_properties(mode_count);\n    VK_ASSERT_SUCCESS(vkGetDisplayModePropertiesKHR(vk_physical_device_, display_, &amp;mode_count, mode_properties.data()));\n\n    selected_mode_ = select_display_mode(mode_properties);\n\n    VkDisplayPlaneCapabilitiesKHR plane_capabilities;\n    VK_ASSERT_SUCCESS(\n        vkGetDisplayPlaneCapabilitiesKHR(vk_physical_device_, selected_mode_.displayMode, plane_index, &amp;plane_capabilities));\n\n    VkDisplaySurfaceCreateInfoKHR surface_create_info = {\n        .sType           = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,\n        .pNext           = nullptr,\n        .flags           = 0,\n        .displayMode     = selected_mode_.displayMode,\n        .planeIndex      = plane_index,\n        .planeStackIndex = plane_properties[plane_index].currentStackIndex,\n        .transform       = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,\n        .globalAlpha     = 1.0f,\n        .alphaMode       = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,\n        .imageExtent     = selected_mode_.parameters.visibleRegion,\n    };\n\n    VkSurfaceKHR surface;\n    VK_ASSERT_SUCCESS(vkCreateDisplayPlaneSurfaceKHR(vk_instance_, &amp;surface_create_info, nullptr, &amp;surface));\n\n    return surface;\n}\n\nvoid x11_direct::cleanup() { }\n\nstd::set&lt;const char*&gt; x11_direct::get_required_instance_extensions() {\n    std::set&lt;const char*&gt; extensions;\n    extensions.insert(VK_KHR_SURFACE_EXTENSION_NAME);\n    extensions.insert(VK_KHR_DISPLAY_EXTENSION_NAME);\n    extensions.insert(VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME);\n    extensions.insert(VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME);\n    extensions.insert(VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME);\n    return extensions;\n}\n\nVkDisplayModePropertiesKHR x11_direct::select_display_mode(std::vector&lt;VkDisplayModePropertiesKHR&gt; modes) {\n    // select mode with the highest refresh rate\n    VkDisplayModePropertiesKHR selected_mode = modes[0];\n    for (const auto&amp; mode : modes) {\n        if (mode.parameters.refreshRate &gt; selected_mode.parameters.refreshRate) {\n            selected_mode = mode;\n        }\n    }\n    std::cout &lt;&lt; \"Selected display mode: \" &lt;&lt; selected_mode.parameters.visibleRegion.width &lt;&lt; \"x\"\n              &lt;&lt; selected_mode.parameters.visibleRegion.height &lt;&lt; \"@\" &lt;&lt; selected_mode.parameters.refreshRate / 1000 &lt;&lt; \"Hz\"\n              &lt;&lt; std::endl;\n    return selected_mode;\n}\n\nvoid x11_direct::tick() {\n    if (!display_timings_event_registered_) {\n        // yield\n        std::this_thread::yield();\n        return;\n    }\n    vkWaitForFences(vk_device_, 1, &amp;display_event_fence_, VK_TRUE, UINT64_MAX);\n    auto now = clock_-&gt;now();\n    vkDestroyFence(vk_device_, display_event_fence_, nullptr);\n    register_display_timings_event(vk_device_);\n\n    now += std::chrono::nanoseconds(1000000000 / selected_mode_.parameters.refreshRate);\n    vsync_topic_.put(vsync_topic_.allocate(now));\n}\n\nbool x11_direct::register_display_timings_event(VkDevice vk_device) {\n    this-&gt;vk_device_ = vk_device;\n    auto register_display_event =\n        (PFN_vkRegisterDisplayEventEXT) vkGetInstanceProcAddr(vk_instance_, \"vkRegisterDisplayEventEXT\");\n    if (register_display_event == nullptr) {\n        ILLIXR::abort(\"Failed to load vkRegisterDisplayEventEXT\");\n        return false;\n    }\n\n    auto display_event_info = (VkDisplayEventInfoEXT) {\n        .sType        = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,\n        .pNext        = nullptr,\n        .displayEvent = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,\n    };\n\n    auto ret = (register_display_event(vk_device, display_, &amp;display_event_info, nullptr, &amp;display_event_fence_));\n    if (ret != VK_SUCCESS) {\n        display_event_fence_ = VK_NULL_HANDLE;\n    } else {\n        display_timings_event_registered_ = true;\n    }\n    return ret == VK_SUCCESS;\n}\n\nstd::set&lt;const char*&gt; x11_direct::get_required_device_extensions() {\n    auto extensions = std::set&lt;const char*&gt;();\n    extensions.insert(VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME);\n    return extensions;\n}\n\ndisplay_backend::display_backend_type x11_direct::get_type() {\n    return X11_DIRECT;\n}\n</code></pre>"},{"location":"api/x11__direct_8hpp/","title":"File x11_direct.hpp","text":"<p>FileList &gt; display &gt; x11_direct.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"display_backend.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/x11__direct_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace display"},{"location":"api/x11__direct_8hpp/#classes","title":"Classes","text":"Type Name class x11_direct <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/src/display/x11_direct.hpp</code></p>"},{"location":"api/x11__direct_8hpp_source/","title":"File x11_direct.hpp","text":"<p>File List &gt; display &gt; x11_direct.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"display_backend.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;utility&gt;\n\nnamespace ILLIXR::display {\n\nclass x11_direct : public display_backend {\npublic:\n    x11_direct(std::shared_ptr&lt;relative_clock&gt; _rc, switchboard::writer&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; _vsync_topic)\n        : clock_{std::move(_rc)}\n        , vsync_topic_{_vsync_topic} { };\n    void                              setup_display(const std::shared_ptr&lt;switchboard&gt; sb, VkInstance vk_instance,\n                                                    VkPhysicalDevice vk_physical_device_) override;\n    VkSurfaceKHR                      create_surface() override;\n    void                              cleanup() override;\n    std::set&lt;const char*&gt;             get_required_instance_extensions() override;\n    std::set&lt;const char*&gt;             get_required_device_extensions() override;\n    static VkDisplayModePropertiesKHR select_display_mode(std::vector&lt;VkDisplayModePropertiesKHR&gt; modes);\n    void                              tick();\n    bool                              register_display_timings_event(VkDevice vk_device_);\n    display_backend_type              get_type() override;\n\n    VkDisplayKHR               display_;\n    std::atomic&lt;bool&gt;          display_timings_event_registered_ = false;\n    VkDevice                   vk_device_;\n    VkDisplayModePropertiesKHR selected_mode_;\n\nprivate:\n    std::shared_ptr&lt;relative_clock&gt;                             clock_;\n    switchboard::writer&lt;switchboard::event_wrapper&lt;time_point&gt;&gt; vsync_topic_;\n    VkFence                                                     display_event_fence_ = VK_NULL_HANDLE;\n    VkPhysicalDevice                                            vk_physical_device_;\n};\n\n} // namespace ILLIXR::display\n</code></pre>"},{"location":"api/zed__cam_8hpp/","title":"File zed_cam.hpp","text":"<p>FileList &gt; data_format &gt; zed_cam.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/camera_data.hpp\"</code></li> <li><code>#include \"illixr/data_format/opencv_data_types.hpp\"</code></li> <li><code>#include \"illixr/data_format/pose.hpp\"</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/zed__cam_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace data_format"},{"location":"api/zed__cam_8hpp/#classes","title":"Classes","text":"Type Name struct cam_type_zed <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/include/illixr/data_format/zed_cam.hpp</code></p>"},{"location":"api/zed__cam_8hpp_source/","title":"File zed_cam.hpp","text":"<p>File List &gt; data_format &gt; zed_cam.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef HAVE_ZED\n    #include \"illixr/data_format/camera_data.hpp\"\n    #include \"illixr/data_format/opencv_data_types.hpp\"\n    #include \"illixr/data_format/pose.hpp\"\n\n    #include &lt;utility&gt;\n\nnamespace ILLIXR::data_format {\nstruct [[maybe_unused]] cam_type_zed : cam_base_type {\n    std::size_t    serial_no;\n    multi_pose_map poses;\n\n    cam_type_zed(time_point _time, cv::Mat _img0, cv::Mat _img1, cv::Mat _rgb, cv::Mat _depth, cv::Mat _confidence,\n                 std::size_t _serial_no, multi_pose_map _poses)\n        : cam_base_type(_time,\n                        {{image::LEFT_EYE, _img0},\n                         {image::RIGHT_EYE, _img1},\n                         {image::RGB, _rgb},\n                         {image::DEPTH, _depth},\n                         {image::CONFIDENCE, _confidence}},\n                        camera::ZED)\n        , serial_no{_serial_no}\n        , poses{std::move(_poses)} { }\n};\n\n} // namespace ILLIXR::data_format\n#endif\n</code></pre>"},{"location":"api/zed__camera_8cpp/","title":"File zed_camera.cpp","text":"<p>FileList &gt; plugins &gt; zed &gt; zed_camera.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"zed_camera.hpp\"</code></li> </ul>"},{"location":"api/zed__camera_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr unsigned EXPOSURE_TIME_PERCENT   = <code>40</code>"},{"location":"api/zed__camera_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/zed__camera_8cpp/#variable-exposure_time_percent","title":"variable EXPOSURE_TIME_PERCENT","text":"<pre><code>constexpr unsigned EXPOSURE_TIME_PERCENT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/zed_camera.cpp</code></p>"},{"location":"api/zed__camera_8cpp_source/","title":"File zed_camera.cpp","text":"<p>File List &gt; plugins &gt; zed &gt; zed_camera.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"zed_camera.hpp\"\n\n// Set exposure to 8% of camera frame time. This is an empirically determined number\nstatic constexpr unsigned EXPOSURE_TIME_PERCENT = 40;\n\nusing namespace ILLIXR;\n\nsl::ERROR_CODE zed_camera::open(const sl::InitParameters&amp; params) {\n    sl::ERROR_CODE err = sl::Camera::open(params);\n    if (err != sl::ERROR_CODE::SUCCESS) {\n        return err;\n    }\n    auto trans  = switchboard_-&gt;root_coordinates.position();\n    auto orient = switchboard_-&gt;root_coordinates.orientation();\n\n    initial_position_.setTranslation(sl::Translation(trans.x(), trans.y(), trans.z()));\n    initial_position_.setOrientation(sl::Orientation({orient.x(), orient.y(), orient.z(), orient.w()}));\n\n    auto                 cam_conf  = getCameraInformation().camera_configuration;\n    sl::CameraParameters left_cam  = cam_conf.calibration_parameters.left_cam;\n    sl::CameraParameters right_cam = cam_conf.calibration_parameters.right_cam;\n    config_                        = {cam_conf.resolution.width,\n                                      cam_conf.resolution.height,\n                                      cam_conf.fps,\n                                      cam_conf.calibration_parameters.getCameraBaseline(),\n                                      data_format::units::UNITS,\n                                      {{data_format::units::eyes::LEFT_EYE,\n                                        {left_cam.cx, left_cam.cy, left_cam.v_fov * (M_PI / 180.), left_cam.h_fov * (M_PI / 180.)}},\n                                       {data_format::units::eyes::RIGHT_EYE,\n                                        {right_cam.cx, right_cam.cy, right_cam.v_fov * (M_PI / 180.), right_cam.h_fov * (M_PI / 180.)}}}};\n\n    sl::PositionalTrackingParameters tracking_params(initial_position_);\n    err = enablePositionalTracking(tracking_params);\n    if (err != sl::ERROR_CODE::SUCCESS) {\n        spdlog::get(\"illixr\")-&gt;info(\"[zed] {}\", toString(err).c_str());\n        close();\n    }\n\n    return err;\n}\n</code></pre>"},{"location":"api/zed__camera_8hpp/","title":"File zed_camera.hpp","text":"<p>FileList &gt; plugins &gt; zed &gt; zed_camera.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/camera_data.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;sl/Camera.hpp&gt;</code></li> </ul>"},{"location":"api/zed__camera_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/zed__camera_8hpp/#classes","title":"Classes","text":"Type Name class zed_camera"},{"location":"api/zed__camera_8hpp/#macros","title":"Macros","text":"Type Name define UNITS <code>MILLIMETER</code>"},{"location":"api/zed__camera_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/zed__camera_8hpp/#define-units","title":"define UNITS","text":"<pre><code>#define UNITS `MILLIMETER`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/zed_camera.hpp</code></p>"},{"location":"api/zed__camera_8hpp_source/","title":"File zed_camera.hpp","text":"<p>File List &gt; plugins &gt; zed &gt; zed_camera.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format/camera_data.hpp\"\n#include \"illixr/switchboard.hpp\"\n\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;sl/Camera.hpp&gt;\n\n#define UNITS MILLIMETER\n\nnamespace ILLIXR {\nclass zed_camera : public sl::Camera {\npublic:\n    explicit zed_camera(const std::shared_ptr&lt;switchboard&gt;&amp; sb)\n        : sl::Camera()\n        , switchboard_{sb}\n        , frame_{sl::REFERENCE_FRAME::WORLD} {\n    } //(switchboard_-&gt;get_env_bool(\"USE_WCS\")) ? sl::REFERENCE_FRAME::WORLD : sl::REFERENCE_FRAME::CAMERA} { }\n\n    sl::ERROR_CODE open(const sl::InitParameters&amp; params);\n\n    [[nodiscard]] const sl::Transform&amp; get_initial_position() const {\n        return initial_position_;\n    }\n\n    [[nodiscard]] const data_format::camera_data&amp; get_config() const {\n        return config_;\n    };\n\n    [[nodiscard]] Eigen::Vector3f get_translation() const {\n        auto temp = initial_position_.getTranslation();\n        return {temp[0], temp[1], temp[2]};\n    }\n\n    [[nodiscard]] Eigen::Quaternionf get_orientation() const {\n        auto temp = initial_position_.getOrientation();\n        return {temp[0], temp[1], temp[2], temp[3]};\n    }\n\n    sl::POSITIONAL_TRACKING_STATE getPosition(sl::Pose&amp; pose) {\n        return sl::Camera::getPosition(pose, frame_);\n    }\n\n    [[nodiscard]] float getBaseline() const {\n        return config_.baseline;\n    }\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n    sl::Transform                      initial_position_;\n    data_format::camera_data           config_;\n    sl::REFERENCE_FRAME                frame_;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/zed__camera__thread_8cpp/","title":"File zed_camera_thread.cpp","text":"<p>FileList &gt; plugins &gt; zed &gt; zed_camera_thread.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"zed_camera_thread.hpp\"</code></li> <li><code>#include \"include/zed_opencv.hpp\"</code></li> </ul>"},{"location":"api/zed__camera__thread_8cpp/#public-functions","title":"Public Functions","text":"Type Name void transform_zed_pose (sl::Transform &amp; from_pose, sl::Transform &amp; to_pose, float ty)"},{"location":"api/zed__camera__thread_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/zed__camera__thread_8cpp/#function-transform_zed_pose","title":"function transform_zed_pose","text":"<pre><code>void transform_zed_pose (\n    sl::Transform &amp; from_pose,\n    sl::Transform &amp; to_pose,\n    float ty\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/zed_camera_thread.cpp</code></p>"},{"location":"api/zed__camera__thread_8cpp_source/","title":"File zed_camera_thread.cpp","text":"<p>File List &gt; plugins &gt; zed &gt; zed_camera_thread.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"zed_camera_thread.hpp\"\n\n#include \"include/zed_opencv.hpp\"\n\nusing namespace ILLIXR;\nusing namespace ILLIXR::data_format;\n\nvoid transform_zed_pose(sl::Transform&amp; from_pose, sl::Transform&amp; to_pose, float ty) {\n    sl::Transform transform_;\n    transform_.setIdentity();\n    transform_.ty = ty;\n    to_pose       = sl::Transform::inverse(transform_) * from_pose * transform_;\n}\n\nzed_camera_thread::zed_camera_thread(const std::string&amp; name_, phonebook* pb_, std::shared_ptr&lt;zed_camera&gt; zed_cam)\n    : threadloop{name_, pb_}\n    , switchboard_{phonebook_-&gt;lookup_impl&lt;switchboard&gt;()}\n    , clock_{phonebook_-&gt;lookup_impl&lt;relative_clock&gt;()}\n    , cam_{switchboard_-&gt;get_writer&lt;cam_type_zed&gt;(\"cam_zed\")}\n    , zed_cam_{std::move(zed_cam)}\n    , image_size_{zed_cam_-&gt;getCameraInformation().camera_configuration.resolution} {\n    // runtime_parameters.sensing_mode = SENSING_MODE::STANDARD;\n    // Image setup\n    imageL_zed_.alloc(image_size_.width, image_size_.height, sl::MAT_TYPE::U8_C4, sl::MEM::CPU);\n    imageR_zed_.alloc(image_size_.width, image_size_.height, sl::MAT_TYPE::U8_C4, sl::MEM::CPU);\n    rgb_zed_.alloc(image_size_.width, image_size_.height, sl::MAT_TYPE::U8_C4, sl::MEM::CPU);\n    depth_zed_.alloc(image_size_.width, image_size_.height, sl::MAT_TYPE::F32_C1, sl::MEM::CPU);\n    confidence_zed_.alloc(image_size_.width, image_size_.height, sl::MAT_TYPE::F32_C1, sl::MEM::CPU);\n\n    imageL_ocv_     = slMat_to_cvMat(imageL_zed_);\n    imageR_ocv_     = slMat_to_cvMat(imageR_zed_);\n    rgb_ocv_        = slMat_to_cvMat(rgb_zed_);\n    depth_ocv_      = slMat_to_cvMat(depth_zed_);\n    confidence_ocv_ = slMat_to_cvMat(confidence_zed_);\n}\n\nthreadloop::skip_option zed_camera_thread::_p_should_skip() {\n    if (zed_cam_-&gt;grab(runtime_parameters_) == sl::ERROR_CODE::SUCCESS) {\n        return skip_option::run;\n    } else {\n        return skip_option::skip_and_spin;\n    }\n}\n\nvoid zed_camera_thread::stop() {\n    zed_cam_-&gt;close();\n    threadloop::stop();\n}\n\nvoid zed_camera_thread::_p_one_iteration() {\n    RAC_ERRNO_MSG(\"zed at start of _p_one_iteration\");\n\n    // Time as ullong (nanoseconds)\n    // ullong cam_time = static_cast&lt;ullong&gt;(zedm-&gt;getTimestamp(TIME_REFERENCE::IMAGE).getNanoseconds());\n\n    // Retrieve images\n    zed_cam_-&gt;retrieveImage(imageL_zed_, sl::VIEW::LEFT, sl::MEM::CPU, image_size_);\n    zed_cam_-&gt;retrieveImage(imageR_zed_, sl::VIEW::RIGHT, sl::MEM::CPU, image_size_);\n    zed_cam_-&gt;retrieveMeasure(depth_zed_, sl::MEASURE::DEPTH, sl::MEM::CPU, image_size_);\n    zed_cam_-&gt;retrieveImage(rgb_zed_, sl::VIEW::LEFT, sl::MEM::CPU, image_size_);\n    zed_cam_-&gt;retrieveMeasure(confidence_zed_, sl::MEASURE::CONFIDENCE);\n\n    multi_pose_map poses;\n    if (zed_cam_-&gt;grab() == sl::ERROR_CODE::SUCCESS) {\n        sl::Pose zed_pose_left;\n        // Get the pose of the camera relative to the world frame\n        sl::POSITIONAL_TRACKING_STATE state = zed_cam_-&gt;getPosition(zed_pose_left);\n        // if (state != sl::POSITIONAL_TRACKING_STATE::OK)\n        //     throw std::runtime_error(\"Tracking failed\");\n        sl::Pose zed_pose_right{zed_pose_left};\n        transform_zed_pose(zed_pose_left.pose_data, zed_pose_right.pose_data, zed_cam_-&gt;getBaseline());\n        pose_type left_eye_pose{\n            time_point(clock_duration_(zed_pose_left.timestamp.getNanoseconds())),\n            {zed_pose_left.getTranslation().tx, zed_pose_left.getTranslation().ty, zed_pose_left.getTranslation().tz},\n            {zed_pose_left.getOrientation().w, zed_pose_left.getOrientation().x, zed_pose_left.getOrientation().y,\n             zed_pose_left.getOrientation().z},\n            units::UNITS};\n        pose_type right_eye_pose{\n            time_point(clock_duration_(zed_pose_right.timestamp.getNanoseconds())),\n            {zed_pose_right.getTranslation().tx, zed_pose_right.getTranslation().ty, zed_pose_right.getTranslation().tz},\n            {zed_pose_right.getOrientation().w, zed_pose_right.getOrientation().x, zed_pose_right.getOrientation().y,\n             zed_pose_right.getOrientation().z},\n            units::UNITS};\n        poses = {{units::LEFT_EYE, left_eye_pose}, {units::RIGHT_EYE, right_eye_pose}};\n    }\n\n    clock_duration_ ts = clock_duration_(zed_cam_-&gt;getTimestamp(sl::TIME_REFERENCE::IMAGE).getNanoseconds());\n    cam_.put(cam_.allocate&lt;cam_type_zed&gt;({time_point{ts}, imageL_ocv_.clone(), imageR_ocv_.clone(), rgb_ocv_.clone(),\n                                          depth_ocv_.clone(), confidence_ocv_.clone(), ++serial_no_, poses}));\n\n    RAC_ERRNO_MSG(\"zed_cam at end of _p_one_iteration\");\n}\n</code></pre>"},{"location":"api/zed__camera__thread_8hpp/","title":"File zed_camera_thread.hpp","text":"<p>FileList &gt; plugins &gt; zed &gt; zed_camera_thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format/misc.hpp\"</code></li> <li><code>#include \"illixr/data_format/zed_cam.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"illixr/threadloop.hpp\"</code></li> <li><code>#include \"zed_camera.hpp\"</code></li> </ul>"},{"location":"api/zed__camera__thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/zed__camera__thread_8hpp/#classes","title":"Classes","text":"Type Name class zed_camera_thread"},{"location":"api/zed__camera__thread_8hpp/#macros","title":"Macros","text":"Type Name define DOUBLE_INCLUDE"},{"location":"api/zed__camera__thread_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/zed__camera__thread_8hpp/#define-double_include","title":"define DOUBLE_INCLUDE","text":"<pre><code>#define DOUBLE_INCLUDE \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/zed_camera_thread.hpp</code></p>"},{"location":"api/zed__camera__thread_8hpp_source/","title":"File zed_camera_thread.hpp","text":"<p>File List &gt; plugins &gt; zed &gt; zed_camera_thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#define DOUBLE_INCLUDE\n#ifndef HAVE_ZED\n    #define HAVE_ZED\n#endif\n#include \"illixr/data_format/misc.hpp\"\n#include \"illixr/data_format/zed_cam.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"zed_camera.hpp\"\n\n#undef DOUBLE_INCLUDE\n\nnamespace ILLIXR {\nclass zed_camera_thread : public threadloop {\npublic:\n    zed_camera_thread(const std::string&amp; name, phonebook* pb, std::shared_ptr&lt;zed_camera&gt; zed_cam);\n    void stop() override;\n\nprotected:\n    skip_option _p_should_skip() override;\n    void        _p_one_iteration() override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt;             switchboard_;\n    const std::shared_ptr&lt;const relative_clock&gt;    clock_;\n    switchboard::writer&lt;data_format::cam_type_zed&gt; cam_;\n    std::shared_ptr&lt;zed_camera&gt;                    zed_cam_;\n    sl::Resolution                                 image_size_;\n    sl::RuntimeParameters                          runtime_parameters_;\n    std::size_t                                    serial_no_{0};\n\n    sl::Mat imageL_zed_;\n    sl::Mat imageR_zed_;\n    sl::Mat depth_zed_;\n    sl::Mat rgb_zed_;\n    sl::Mat confidence_zed_;\n\n    cv::Mat               imageL_ocv_;\n    cv::Mat               imageR_ocv_;\n    cv::Mat               depth_ocv_;\n    cv::Mat               rgb_ocv_;\n    cv::Mat               confidence_ocv_;\n    std::optional&lt;ullong&gt; first_imu_time_;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/zed__opencv_8hpp/","title":"File zed_opencv.hpp","text":"<p>FileList &gt; capture &gt; zed_opencv.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include &lt;sl/Camera.hpp&gt;</code></li> </ul>"},{"location":"api/zed__opencv_8hpp/#public-functions","title":"Public Functions","text":"Type Name cv::Mat slMat_to_cvMat (sl::Mat &amp; input)"},{"location":"api/zed__opencv_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/zed__opencv_8hpp/#function-slmat_to_cvmat","title":"function slMat_to_cvMat","text":"<pre><code>cv::Mat slMat_to_cvMat (\n    sl::Mat &amp; input\n) \n</code></pre> <p>Conversion function between sl::Mat and cv::Mat </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR/plugins/zed/capture/zed_opencv.hpp</code></p>"},{"location":"api/zed__opencv_8hpp_source/","title":"File zed_opencv.hpp","text":"<p>File List &gt; capture &gt; zed_opencv.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;sl/Camera.hpp&gt;\n\ncv::Mat slMat_to_cvMat(sl::Mat&amp; input) {\n    // Mapping between MAT_TYPE and CV_TYPE\n    int cv_type = -1;\n    switch (input.getDataType()) {\n    case sl::MAT_TYPE::F32_C1:\n        cv_type = CV_32FC1;\n        break;\n    case sl::MAT_TYPE::F32_C2:\n        cv_type = CV_32FC2;\n        break;\n    case sl::MAT_TYPE::F32_C3:\n        cv_type = CV_32FC3;\n        break;\n    case sl::MAT_TYPE::F32_C4:\n        cv_type = CV_32FC4;\n        break;\n    case sl::MAT_TYPE::U8_C1:\n        cv_type = CV_8UC1;\n        break;\n    case sl::MAT_TYPE::U8_C2:\n        cv_type = CV_8UC2;\n        break;\n    case sl::MAT_TYPE::U8_C3:\n        cv_type = CV_8UC3;\n        break;\n    case sl::MAT_TYPE::U8_C4:\n        cv_type = CV_8UC4;\n        break;\n    default:\n        break;\n    }\n\n    // Since cv::Mat data requires an uchar* pointer, we get the uchar1 pointer from sl::Mat (getPtr&lt;T&gt;())\n    // cv::Mat and sl::Mat will share a single memory structure\n    return {static_cast&lt;int&gt;(input.getHeight()), static_cast&lt;int&gt;(input.getWidth()), cv_type,\n            input.getPtr&lt;sl::uchar1&gt;(sl::MEM::CPU)};\n}\n</code></pre>"},{"location":"contributing/","title":"How to contribute to ILLIXR","text":"<p>We welcome contributions to ILLIXR! This document outlines the process for contributing to ILLIXR.</p>"},{"location":"contributing/#contents","title":"Contents","text":"<ul> <li>Code of Conduct</li> <li>Asking Questions</li> <li>Reporting Bugs</li> <li>Suggesting a Feature/Improvement</li> <li>Programming Style Guide</li> <li>Using 3rd Party Code/Libraries</li> <li>Licenses</li> <li>Creating a Pull Request</li> <li>Code Review Guidelines</li> </ul>"},{"location":"contributing/asking_questions/","title":"Asking Questions and Getting Help","text":"<p>There are several ways to get help with ILLIXR.</p> <ul> <li>Read through the documentation and see if you can find the answer you need.</li> <li>Search through issues and see if anyone has had the same issue before.</li> <li>Join our Discord server and ask questions there</li> </ul> <p>Please do not contact contributors/authors directly, use one of the public forums above.</p>"},{"location":"contributing/code_of_conduct/","title":"ILLIXR Code of Conduct","text":""},{"location":"contributing/code_of_conduct/#purpose","title":"Purpose","text":"<p>Our contributors come from all around the world with diverse skill sets, personalities, experiences, and points of view. All of these differences work together to make ILLIXR a success, and continue to grow. When working with members of this community the code of conduct will help guide your interactions and make this a positive experience for all.</p>"},{"location":"contributing/code_of_conduct/#pledge","title":"Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"contributing/code_of_conduct/#standards","title":"Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Attempting collaboration before conflict</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>Violence, threats of violence, or inciting others to commit self-harm</li> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, intentionally spreading misinformation, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Abuse of the reporting process to intentionally harass or exclude others</li> <li>Advocating for, or encouraging, any of the above behavior</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within ILLIXR project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting us anonymously through this form. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p> <p>If you are unsure whether an incident is a violation, or whether the space where the incident took place is covered by our Code of Conduct, we encourage you to still report it. We would prefer to have a few extra reports where we decide to take no action, rather than to leave an incident go unnoticed and unresolved that may result in an individual or group to feel like they can no longer participate in the community. Reports deemed as not a violation will also allow us to improve our Code of Conduct and processes surrounding it. If you witness a dangerous situation or someone in distress, we encourage you to report even if you are only an observer.</p>"},{"location":"contributing/code_of_conduct/#acknowledgements","title":"Acknowledgements","text":"<p>This code is adapted from the open source template of auth0.</p>"},{"location":"contributing/code_review/","title":"Code Review Guidelines","text":"<p>The point of code reviews is to make sure changes to ILLIXR are compatible with the vision of the project, are well coded</p> <p>If you are asked to review code for a pull request please:</p> <ul> <li>Review the code not the author</li> <li>Critique the code in a constructive format</li> <li>If possible offer suggestions/examples for changes or specific points, do not just say <code>this doesn't work</code></li> <li>If any questions are asked, be specific, feel free to ask several questions</li> <li>If critiques/questions deal with a specific section of code, start a conversation in that part of the code by clicking   on the <code>+</code> for the line of code in question</li> </ul> <p></p> <p>If your code is being reviewed:</p> <ul> <li>Every pull request must have reviews done by two people who are not the author of the pull request</li> <li>Don't take criticisms personally</li> <li>Please respond to any conversations, don't just close them</li> <li>Remember the review process is to improve your code</li> </ul>"},{"location":"contributing/feature_request/","title":"Making a Feature Request","text":"<p>Do you have a new feature or improvement in mind for ILLIXR? We'd love to hear about it! Please follow the steps below to submit a feature request.</p> <ul> <li>Ensure the feature, or something very similar, was not already requested by searching on GitHub under Issues.</li> <li>If an issue request for the feature/improvement already exists, feel free to add a comment to the existing issue with   any additional ideas or insights you think are relevant.</li> <li>If you're unable to find one that covers your idea, open a new one. Be sure to include a title, clear   description, and as much relevant information as possible. Please be descriptive as possible so that the developers   can fully understand what you are requesting.</li> <li>Once the issue is created a team member will review it, and it will be discussed for inclusion in the future as   resources allow.</li> <li>If you already have a solution in mind, consider submitting a pull request with the new feature or improvement. See   the Creating a Pull Request documentation for more information.</li> </ul>"},{"location":"contributing/licenses/","title":"Licenses","text":"<p>ILLIXR is licensed under the MIT License. This means that you are free to use, modify, and distribute the software as long as you include the original license and copyright notice in any copy of the software or substantial portion of the software.</p>"},{"location":"contributing/licenses/#third-party-licenses","title":"Third Party Licenses","text":"<p>ILLIXR uses many third-party libraries and codes, each with their own licenses. In order to be included in the core ILLIXR repository, each of these licenses must be compatible with the main ILLIXR license. Most open source licenses are compatible, however copy-left licenses such as the GNU General Public License(GPL) are not compatible. The Lesser General Public License (LGPL), however, is compatible with the MIT license. Other acceptable licenses include, but are not limited to:</p> <ul> <li>Apache License 2.0</li> <li>BSD 2-Clause License</li> <li>BSD 3-Clause License</li> <li>Boost Software License 1.0</li> <li>Most Creative Commons licenses</li> <li>Simplified BSD License</li> <li>Zlib License</li> </ul>"},{"location":"contributing/opening_an_issue/","title":"Reporting a Bug/Issue","text":"<p>If you have come across a bug, or have an issue building or running ILLIXR, please try the following:</p> <ul> <li>Ensure the bug was not already reported by searching on GitHub under Issues.</li> <li>If you're unable to find an open issue addressing the problem, open a new one. Be sure to include a title, clear description, and as much relevant information as possible. This may include:</li> <li>Steps to reproduce the bug.</li> <li>Command line arguments.</li> <li>Any data sets being used.</li> <li>Expected behavior.</li> <li>Actual behavior.</li> <li>Which plugins are being used.</li> <li>The contents of any configuration files.</li> <li>Any relevant environment variables.</li> <li>Build commands and arguments.</li> <li>Screenshots or error messages.</li> <li>System information (OS, hardware, etc.).</li> <li>Any other relevant information.</li> <li>If the issue regards running ILLIXR, please try doing a <code>Debug</code> build, if you have not already. This build will output more information and may help narrow down where the problem is arising from.</li> <li>Once the issue is created a team member will review it and work to resolve the issue.</li> </ul>"},{"location":"contributing/pull_request/","title":"Pull Requests","text":"<p>Please follow these steps when making pull requests (PRs):</p> <ol> <li> <p>First, create an issue describing the problem that needs to be fixed. If an issue already exists, skip this step. If    you are looking for an issue to fix, see the \"good first issue\" label.</p> </li> <li> <p>Assign the issue to yourself and add appropriate labels. If you are an external contributor, comment on the issue so    one of the ILLIXR team members can assign the issue to you.</p> </li> <li> <p>Before you start making changes, make a new branch. The branch MUST be named    <code>issue-&lt;issue number&gt;-&lt;some descriptive name&gt;</code>. For instance, <code>issue-32-fix-mem-leak</code> addresses the memory leak    described in Issue #32.</p> </li> <li> <p>Fix the issue.</p> </li> <li> <p>Add your name to <code>ILLIXR/CONTRIBUTORS</code>.</p> </li> <li> <p>Push commits up to GitHub.</p> </li> <li> <p>Open a PR, and link it to the issue that the PR aims to resolve. Please give the PR a descriptive name.</p> </li> <li> <p>Once you have your PR number, create a PR documentation file. See here for instructions.</p> </li> <li> <p>As you make progress on your PR, keep your branch up-to-date with the <code>master</code> branch which may have been updated    after starting your PR. Your PR MUST be updated to reflect changes to <code>master</code> in order to be merged. Use the    following procedure for updating your branch and when you are ready to commit your changes:</p> <pre><code>## While on your PR branch &lt;issue-branch&gt; hosted at &lt;your-remote&gt; repository:\ngit commit # or git stash                                  ## Line A\ngit checkout master\n\ngit pull &lt;illixr-remote&gt; master --rebase &amp;&amp; git fetch &lt;illixr-remote&gt;   ## Line B\n\ngit checkout &lt;issue-branch&gt;\ngit rebase master                                          ## Line C\n\n## If you stashed your changes on 'Line A':\ngit stash apply &lt;stash-number&gt; &amp;&amp; git commit\n\ngit push &lt;your-remote&gt; &lt;issue-branch&gt; --force-with-lease   ## Line D\n</code></pre> <p>For ILLIXR team members (others jump here):</p> <ul> <li> <p>In the example above, <code>&lt;illixr-remote&gt;</code> and <code>&lt;your-remote&gt;</code> are the same.</p> </li> <li> <p>When collaborating on branches in our repository, <code>Line B</code> may pull in changes that overwrite the git commit   history when performing <code>Line C</code>. Subsequently, performing <code>Line D</code> will rewrite the history in the public branch.   To preserve branch commit histories in the case that a rollback is needed, we will employ a checkpointing process   for force updated branches. This process will be manually performed, but may be automated in the future.</p> </li> </ul> <p>If <code>Line B</code> shows an update to master, the following example illustrates your local repository just after performing <code>Line B</code>:</p> <pre><code>A -- B -- C -- P -- Q -- R       ## master\n           \\\n            D -- E -- F          ## issue-123-fixing-bug\n</code></pre> <p>In this example, commits <code>P</code>, <code>Q</code>, and <code>R</code> have been merged to <code>master</code> (from feature branches not shown) after feature branch <code>issue-123-fixing-bug</code> was forked from <code>master</code>.</p> <p>To checkpoint the <code>issue-123-fixing-bug</code> branch while it is checked out:</p> <pre><code>git branch issue-123.0-fixing-bug                                   ## Make alias for old issue-123-fixing-bug\ngit checkout -b issue-123.1-fixing-bug                              ## Make new branch to rebase with master\ngit rebase master                                                   ## Replay issue-123-fixing-bug onto master\ngit branch -D issue-123-fixing-bug                                  ## Remove old issue-123-fixing-bug\ngit branch issue-123-fixing-bug                                     ## Make issue-123-fixing-bug an alias of new branch\ngit push &lt;illixr-remote&gt; issue-123.{0,1}-fixing-bug                 ## Push new checkpointed branches to remote\ngit push &lt;illixr-remote&gt; issue-123-fixing-bug --force-with-lease    ## Force update issue-123-fixing-bug\n</code></pre> <p>Note</p> <p>The term alias here is used to refer to branches which point to the same commit. This usage is different from standard Git Aliases used for git command shortcuts.</p> <p>After checkpointing, your local repository should look as follows:</p> <pre><code>                           D' -- E' -- F'   ## issue-123.1-fixing-bug, issue-123-fixing-bug\n                          /\nA -- B -- C -- P -- Q -- R                  ## master\n           \\\n            D -- E -- F                     ## issue-123.0-fixing-bug\n</code></pre> <p>Commits <code>D</code>, <code>E</code>, and <code>F</code> have been added to a new branch starting from <code>R</code>, but now have been given new hashes. This new branch is our up-to-date copy of the feature branch <code>issue-123-fixing-bug</code>.</p> <p>While working on a checkpointed branch, keep aliases up-to-date using <code>git rebase</code>:</p> <pre><code>git commit                               ## Add changes to issue-123.1-fixing-bug\ngit checkout issue-123-fixing-bug        ## Switch to main issue-123-fixing-bug branch\ngit rebase issue-123.1-fixing-bug        ## Fast-forward issue-123-fixing-bug to issue-123.1-fixing-bug\n</code></pre> <p>Conflicts are possible when two or more collaborators push changes concurrently to the same branch. As long as each collaborator ensures that the branch update process starts at <code>Line A</code>, conflicts can be detected and handled locally. In other words, every call to <code>git-push</code> should be preceded by a call to <code>git-pull</code>, following the process from <code>Line A</code> to <code>Line D</code> (or equivalent; git's CLI allows many ways to achieve the same results).</p> <p>Note</p> <p><code>Line B</code> rebases the <code>master</code> branch assuming that we have checked out <code>master</code>. Forgetting to specify <code>master</code> in <code>Line B</code> may result in a lossy forced update in the example below. Forgetting to checkout <code>master</code> will immediately apply your checked out feature branch's changes, possibly also resulting in a lossy forced update.</p> <p>The output of <code>Line B</code> for a collaborator after the checkpointing process may contain something like this:</p> <pre><code>From github.com:ILLIXR/ILLIXR\n  A..R          master                  -&gt; &lt;illixr-remote&gt;/master\n+ A..F'         issue-123-fixing-bug    -&gt; &lt;illixr-remote&gt;/issue-123-fixing-bug  (forced update)\n* [new branch]  issue-123.0-fixing-bug  -&gt; &lt;illixr-remote&gt;/issue-123.0-fixing-bug\n* [new branch]  issue-123.1-fixing-bug  -&gt; &lt;illixr-remote&gt;/issue-123.1-fixing-bug\n</code></pre> <p>Conflicts which do not involve updates to the <code>master</code> branch can be resolved simply by rebasing the current feature branch with the updated feature branch, applying new changes on top of the updated feature branch:</p> <pre><code>## For the latest checkpoint X (local) and Y (remote), let Z := Y + 1 in\ngit checkout issue-123.X-fixing-bug -b issue-123.Z-fixing-bug       ## Make new branch issue-123.Z-fixing-bug\ngit rebase &lt;illixr-remote&gt;/issue-123.Y-fixing-bug                   ## Replay updates from issue-123.X-fixing-bug\ngit push &lt;illixr-remote&gt; issue-123.Z-fixing-bug                     ## Make sure to update issue-123-fixing-bug after\n</code></pre> <p>The <code>--force-with-lease</code> argument in <code>Line D</code> is not required for our new checkpoint branch, since a new branch should not conflict with a non-existing remote branch. We expect the subversion number for a new branch resulting from our checkpoint conflict resolution to be new and unique. If the push fails, another conflict has occurred, and checkpoint conflict resolution should be repeated. <code>Line D</code> should be safe to perform for the main feature branch now that we have replayed our commits on top of the updated feature branch.</p> <p>Note</p> <p>In the above example, the <code>git-rebase</code> is performed using the remote copy of the checkpointed branch. We do this because <code>Line B</code> will not fast-forward or force update our local branches (with the same subversion number as a conflicting remote branch, if any).</p> <p>In the case of a conflict with updates to <code>master</code>, <code>Line A</code> should show updates to both the <code>master</code> branch and the feature branch to be pushed in <code>Line D</code>. A checkpointed version of the feature branch may also appear. This is because a feature branch should only be checkpointed in the presence of a change to the <code>master</code> branch. Forced pushes should generally not be used for any other purpose. If multiple updates to <code>master</code> and the feature branch have occurred, additional checkpointed versions of the feature branch may also appear. In this scenario, we need to rebase our latest version of the feature branch with the latest version of the feature branch pulled from <code>&lt;illixr-remote&gt;</code>.</p> </li> </ol>"},{"location":"contributing/pull_request/#pr-documentation","title":"PR Documentation","text":"<p>Each PR should create one or more documentation files. These files are used to automatically generate the bulk of the release notes for each release. The documentation files should go in the directories below <code>changes</code>.</p> <ul> <li>infrastructure: this directory is for PRs which deal with changes to base classes (plugin, switchboard, etc.),   changes to the locations of header files, or other similar system-level changes</li> <li>plugins: this directory is for major updates to, or creation of, plugins</li> <li>misc: this directory is for any PR that does not fit into the above two</li> <li>The issues and notes directories are reserved for work at release time and should not be generally used.</li> </ul> <p>The files should be named <code>pr.XYZ.md</code> where <code>XYZ</code> is replaced by your PR number. For example, <code>pr.400.md</code> would refer to PR #400. The style of the files is markdown. The top of the file has a special format</p> <pre><code>---\n- author.&lt;your_github_name&gt;\n---\n</code></pre> <p>Where <code>&lt;your_github_name&gt;</code> should be your GitHub username. This will ensure proper attribution of your work in the release notes. If there are multiple authors, just add them one, after another, on separate lines.</p> <pre><code>---\n- author.author1\n- author.author2\n---\n</code></pre> <p>Giving each GitHub username. The rest of the file should be a short description of the PR, generally one or two sentences at most. If the changes are breaking changes (e.g. restructuring of headers) please start the text with</p> <pre><code>**Breaking**\n</code></pre>"},{"location":"contributing/pull_request/#philosophy","title":"Philosophy","text":"<p>Why are the above steps necessary?</p> <ol> <li> <p>Assigning the issue to yourself ensures that multiple people don't work on the same thing in parallel.</p> </li> <li> <p>The branch naming scheme organizes things a bit for us, and also makes it easy to find branches.</p> </li> <li> <p>Linking the issue to the PR ensures that we know which issue is being resolved, and also automatically closes the    issue when the PR gets merged.</p> </li> <li> <p>Using rebases keeps the <code>master</code> and feature branch histories streamlined (minimizing branching), thus making it    easier to compose feature branches for integration testing. See this article on rebasing public branches for    more information.</p> </li> </ol> <p>If your PR has not seen activity from the ILLIXR team after a long period of time (e.g., 2 weeks), feel free to contact the team directly on the GitHub Issue Conversation tab or at the Gitter forum linked below.</p>"},{"location":"contributing/style_guide/","title":"Programming Style Guide","text":"<p>Consistency is the most important. Following the existing style, formatting, and naming conventions of the file you are modifying and of the overall ILLIXR project. Failure to do so will result in a prolonged review process that has to focus on updating the superficial aspects of your code, rather than improving its functionality and performance. Below are some general guidelines to follow. We also use a pre-commit bot that runs after pushes to GitHub. It enforces some general formatting rules, so don't be surprised if you see minor updates to your code. In general ILLIXR uses the Google C++ Style Guide with a few minor changes.</p>"},{"location":"contributing/style_guide/#directory-structure","title":"Directory Structure","text":"<p>Here is the basic directory structure used by ILLIXR (some files/directories have been omitted for brevity)</p> <pre><code>\u251c\u2500\u2500 cmake\n\u2502   \u251c\u2500\u2500 ConfigurationSummary.cmake    # functions to generate a summary after a cmake configuration run\n\u2502   \u251c\u2500\u2500 *.patch                       # patch files for any 3rd party code\n\u2502   \u251c\u2500\u2500 do_patch.sh                   # script for applying the patches\n\u2502   \u251c\u2500\u2500 Find*.cmake                   # cmake files for locating packages that do not have one installed by a repo\n\u2502   \u251c\u2500\u2500 Get*.cmake                    # cmake files used to build 3rd party packages\n\u2502   \u2514\u2500\u2500 HelperFunctions.cmake         # general helper functions\n\u251c\u2500\u2500 CMakeLists.txt                    # main cmake file for ILLIXR, edit with caution\n\u251c\u2500\u2500 CONTRIBUTORS                      # list of contributors to ILLIXR\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 docs\n\u2502   \u2502   \u251c\u2500\u2500 contributing\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.md                  # markdown files containing documentation on how to contribute to ILLIXR\n\u2502   \u2502   \u251c\u2500\u2500 css\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.css                 # css files used in the generated HTML documentation\n\u2502   \u2502   \u251c\u2500\u2500 images\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 *.png                 # images used in the generated documentation\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.svg\n\u2502   \u2502   \u251c\u2500\u2500 js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.js                  # javascript files used in the generated HTML documentation\n\u2502   \u2502   \u251c\u2500\u2500 plugin_README\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.md                  # readme files for individual plugins\n\u2502   \u2502   \u251c\u2500\u2500 policies\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 *.md                  # general policy documents\n\u2502   \u2502   \u251c\u2500\u2500 getting_started.md.in     # processed into markdown during cmake documentation build\n\u2502   \u2502   \u251c\u2500\u2500 modules.json              # json style file listing plugins and any 3rd party dependencies\n\u2502   \u2502   \u2514\u2500\u2500 *.md                      # general documentation\n\u2502   \u251c\u2500\u2500 doxygen\n\u2502   \u2502   \u2514\u2500\u2500 Doxyfile.in               # file to control doxygen, processed during cmake configuration\n\u2502   \u2514\u2500\u2500 mkdocs\n\u2502       \u2514\u2500\u2500 mkdocs.yaml.in            # file to control mkdocs, processed during cmake configuration\n\u251c\u2500\u2500 include\n\u2502   \u2514\u2500\u2500 illixr\n\u2502       \u251c\u2500\u2500 data_format               # header files for commonly used data structures \n\u2502       \u2514\u2500\u2500 *                         # header files used my multiple plugins or the main binary\n\u251c\u2500\u2500 plugins\n\u2502   \u251c\u2500\u2500 &lt;plugin_name&gt;                 # each plugin has its own subdirectory\n\u2502   \u2502   \u2514\u2500\u2500 CMakeLists.txt            # if the plugin is from another repository, then only this file is needed\n\u2502   \u251c\u2500\u2500 &lt;plugin_name&gt;\n\u2502   \u2502   \u251c\u2500\u2500 CMakeLists.txt            # cmake file which configures the build for this plugin\n\u2502   \u2502   \u251c\u2500\u2500 plugin.hpp                # header file for the plugin, defining the class\n\u2502   \u2502   \u251c\u2500\u2500 *.hpp                     # additional header files, if any, for the plugin\n\u2502   \u2502   \u251c\u2500\u2500 *.cpp                     # additional source files, if any, for the plugin\n\u2502   \u2502   \u2514\u2500\u2500 plugin.cpp                # every plugin must have this file which contains the code for the plugin\n\u2502   \u2514\u2500\u2500 plugins.yaml                  # yaml style file listing configurations, plugins, and services\n\u251c\u2500\u2500 profiles\n\u2502   \u2514\u2500\u2500 *.yaml                        # yaml style files for each profile, these are auto-generated\n\u251c\u2500\u2500 services\n\u2502   \u251c\u2500\u2500 &lt;service_name&gt;\n\u2502   \u2502   \u251c\u2500\u2500 CMakeLists.txt            # cmake file which configures the build for this plugin\n\u2502   \u2502   \u251c\u2500\u2500 service.hpp               # header file for the plugin, defining the class\n\u2502   \u2502   \u251c\u2500\u2500 *.hpp                     # additional header files, if any, for the service\n\u2502   \u2502   \u251c\u2500\u2500 *.cpp                     # additional source files, if any, for the service\n\u2502   \u2502   \u2514\u2500\u2500 service.cpp               # every plugin must have this file which contains the code for the plugin\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 display\n\u2502   \u2502   \u251c\u2500\u2500 *.hpp                     # header files for display back ends\n\u2502   \u2502   \u2514\u2500\u2500 *.cpp                     # source files for display back ends\n\u2502   \u251c\u2500\u2500 sqlite3pp\n\u2502   \u2502   \u2514\u2500\u2500 *.hpp                     # header files for the sqlite interface\n\u2502   \u251c\u2500\u2500 CMakeLists.txt                # cmake file for configuring the build of the main binary\n\u2502   \u251c\u2500\u2500 *.hpp                         # header files for the main binary\n\u2502   \u2514\u2500\u2500 *.cpp                         # source files for the main binary\n\u2514\u2500\u2500 utils\n    \u251c\u2500\u2500 imgui\n    \u2502   \u2514\u2500\u2500 *                         # header and source files for the ImGui library\n    \u251c\u2500\u2500 CMakeLists.txt                # cmake file for configuring the build of the utility static libraries\n    \u251c\u2500\u2500 *.hpp                         # header files for the utility libraries\n    \u2514\u2500\u2500 *.cpp                         # source files for the utility libraries\n</code></pre> <p>In addition to the above, if any individual plugin relies on third party code, this code should be placed in a directory named <code>third_party</code> inside the plugin directory. Files inside the <code>third_party</code> directory can be organized in any fashion. For example:</p> <pre><code>plugins\n\u2514\u2500\u2500 myplugin\n    \u251c\u2500\u2500 third_party\n    \u2502   \u251c\u2500\u2500 vk_mapper.c        # third party code\n    \u2502   \u2514\u2500\u2500 vk_mapper.h\n    \u251c\u2500\u2500 plugin.hpp             # plugin header\n    \u251c\u2500\u2500 plugin.cpp             # plugin code\n    \u2514\u2500\u2500 CMakeLists.txt         # plugin CMake file\n</code></pre>"},{"location":"contributing/style_guide/#file-naming","title":"File Naming","text":"<p>Illixr has adopted the following file naming conventions:</p> <ul> <li>files and directories are all lower case</li> <li>the <code>_</code> should be used as a word seperator</li> <li>header files should have the <code>.hpp</code> suffix</li> <li>code files should have the <code>.cpp</code> suffix</li> <li>documentation files should have the <code>.md</code> suffix</li> <li>each plugin must have its own header file called <code>plugin.hpp</code> which defines the class, this is to make it easier to see all the variables, etc. which could become buried in code otherwise </li> <li>each service must have its own header file called <code>service.hpp</code> which defines the class, this is to make it easier to see all the variables, etc. which could become buried in code otherwise</li> <li>any third party code used in ILLIXR is not subject to the above rules and can keep their original naming conventions</li> </ul> <p>Exceptions</p> <p>Files which must have a specific naming convention that is expected by outside code (e.g. CMakeLists.txt, Doxyfile, etc.), can use any case needed.</p>"},{"location":"contributing/style_guide/#header-files","title":"Header Files","text":"<p>ILLIXR has adopted the <code>#pragma once</code> include guard for all header files.</p>"},{"location":"contributing/style_guide/#includes","title":"Includes","text":"<p>Header files used via the <code>#include</code> pre-processor directive should be at the top of the code and header files, and ordered in the following fashion:</p> <ul> <li>any <code>plugin.hpp</code> or <code>service.hpp</code> associated with the plugin/service</li> <li>any headers from inside the ILLIXR codebase</li> <li>blank line</li> <li>system headers (those in angle brackets, e.g. <code>&lt;stdlib.h&gt;</code> <code>&lt;string&gt;</code>)</li> </ul> <p>Not every file will have includes from each group. Any missing group can just be skipped. Header files in each group should be listed in alphabetical order. Some headers will only be included under certain conditions, by using <code>#ifdef</code> statements. These headers, and their conditionals, should be added below all other header files. This is an example:</p> <pre><code>#include \"illixr/data_format.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string&gt;\n#include &lt;vulkan/vulkan_core.h&gt;\n\n#ifdef ZED\n#include \"zed.h\"\n#endif\n</code></pre> <p>Comments may be added between the groups as long as there is a blank line after each grouping. <code>#define</code> and <code>#undef</code> directives can be used at any place inside, before, or after any header grouping as needed.</p>"},{"location":"contributing/style_guide/#namespace","title":"Namespace","text":"<p>All ILLIXR code is inside the ILLIXR namespace. The use of additional namespaces below ILLIXR (e.g. <code>ILLIXR::data_format</code>)</p>"},{"location":"contributing/style_guide/#classes","title":"Classes","text":"<p>We have adopted the Google style for <code>class</code> declaration order:</p> <pre><code>class XYZ {\npublic:\n    # types and aliases (including enums)\n    # static constants\n    # factory functions (not widely used in ILLIXR)\n    # constructor(s) and assignment operators (if any)\n    # destructor\n    # all other functions\n    # data members\nprotected:\n    # types and aliases\n    # static constants\n    # factory functions (not widely used in ILLIXR)\n    # all other functions\n    # data members\nprivate:\n    # types and aliases\n    # static constants\n    # factory functions (not widely used in ILLIXR)\n    # all other functions\n    # data members\n};\n</code></pre> <p>For <code>struct</code>s, the order should be:</p> <pre><code>struct XYZ {\n    # all data members\n    # constructor(s)\n    # all other functions\n};\n</code></pre> <p>If a class constructor and/or destructor has no functionality it should be defined with <code>= default</code> rather than <code>{}</code>. For example</p> <pre><code>class XYZ {\npublic:\n    XYZ() {}\n    ~XYZ() {}\n};\n</code></pre> <p>should be</p> <pre><code>class XYZ{\npublic:\n    XYZ() = default;\n    ~XYZ() = default;\n};\n</code></pre> <p>Single argument constructors should be marked <code>explicit</code> in order to avoid unintentional implicit conversions.</p>"},{"location":"contributing/style_guide/#naming","title":"Naming","text":"<p>Names (file, variable, class, arguments, etc.) should be readable and clear, even to those unfamiliar to the project. Names should be descriptive of the purpose of the item. Shorter names (e.g. <code>n</code>, <code>i</code>) are acceptable for iterators, indexes, etc. Common abbreviations are also acceptable (e.g. <code>no</code> or <code>num</code> for number; <code>attr</code> or <code>attrib</code> for attribute; <code>l</code> or <code>L</code> for left, etc.). ILLIXR has adopted the snake case naming convention. Names (variables, class names, files, etc.) start with a lower case letter and use the underscore <code>_</code> in place of spaces. Additionally, there should be no prefixes like <code>_</code>, <code>m_</code>, or <code>_M_</code> on any class member variable names. All class data members should be suffixed with a single underscore <code>_</code>. </p>"},{"location":"contributing/style_guide/#templates","title":"Templates","text":"<p>In order to make reading the code clearer, template parameters should either be a single capital letter (<code>T</code>, <code>H</code>, etc.) or be a descriptive name that starts with a capital letter.</p>"},{"location":"contributing/style_guide/#cmake","title":"CMake","text":"<p>We currently require a minimum version of 3.22 for CMake. If you use any CMake features that have changed their default behavior over timeE17, we request you use CMake's <code>POLICY</code> directives to quiet any spurious warning messages. For example:</p> <p><pre><code>if (POLICY CMP0135)\n    cmake_policy(SET CMP0135 NEW)\nendif()\n</code></pre> will quiet warnings about download timestamps when using ExternalProject_Add or FetchContent_Declare calls. ILLIXR also prefers the use of ExternalProject_Add over FetchContent_Declare to bring in external projects, as prefer this work to be carries out at compilation, rather than configuration, time.</p>"},{"location":"contributing/third_party/","title":"Using Third Party Code","text":"<p>ILLIXR is an open-source project that uses third-party code and libraries. This document outlines the process and licensing constraints for using these inside ILLIXR.</p>"},{"location":"contributing/third_party/#precompiled-libraries","title":"Precompiled Libraries","text":""},{"location":"contributing/third_party/#provided-by-os-package-managers","title":"Provided by OS Package Managers","text":"<p>If the third party library being used is provided by a package manager (yum, dnf, apt, etc.) then there are no licensing issues, as it is not being provided by ILLIXR. Any library that is used this way needs to be added to the <code>docs/docs/modules.json</code> file. See the documentation for more information on how to do this.</p> <p>To include the library in the build, add the library to the appropriate <code>CMakeLists.txt</code> file. If the package (or CMake itself) provides a <code>Find&lt;package&gt;.cmake</code> or <code>&lt;package&gt;Config.cmake</code> file, then use</p> <pre><code>find_package(&lt;package&gt; REQUIRED)\n</code></pre> <p>to ensure the library exists on the build system. If the <code>*.cmake</code> file is in a non-standard location you may need to update the <code>CMAKE_PREFIX_PATH</code> variable to include the directory containing the <code>*.cmake</code> file.</p> <pre><code>set(CMAKE_PREFIX_PATH \"/path/to/file ${CMAKE_PREFIX_PATH}\")\n</code></pre> <p>If the package does not have a <code>Find&lt;package&gt;.cmake</code> file, but provides a <code>pkg-config</code> (.pc) file, then use <pre><code>find_package(PkgConfig REQUIRED)\npkg_check_modules(&lt;package&gt; REQUIRED &lt;package&gt;)\n</code></pre> <p>to ensure the library exists on the build system. If the <code>*.pc</code> file is in a non-standard location you may need to update the <code>PKG_CONFIG_PATH</code> environment variable to include the directory containing the <code>*.pc</code> file.</p> <pre><code>set(ENV{PKG_CONFIG_PATH} \"/path/to/file:$ENV{PKG_CONFIG_PATH}\")\n</code></pre> <p>If neither of these are provided you may need to use the <code>find_library</code> command to locate the library on the build system.</p>"},{"location":"contributing/third_party/#provided-by-third-party","title":"Provided by Third Party","text":"<p>If the precompiled library is provided as a download or via a third-party installer, then the library must be licensed under a compatible license. See the license documentation for more information. To use a third-party installer in ILLIXR, you will need to add directives in the appropriate <code>CMakeLists.txt</code> file to download and install the library. Commands such as <code>file(DOWNLOAD ...)</code>, <code>execute_process(COMMAND ...)</code>, and <code>add_custom_command</code> can be used to accomplish this. You will need to be aware that CMake will not automatically associate the installation of the library with its use in your code. You will likely need to add targets to the <code>DEPENDS</code> list of your code's CMake target.</p>"},{"location":"contributing/third_party/#built-from-source","title":"Built From Source","text":"<p>Any third-party code that is built from source must be licensed under a compatible license. See the license documentation for more information. To use this code in ILLIXR it is recommended to create a <code>cmake/Get&lt;package&gt;.cmake</code> file that will download and build the library. See files in the <code>cmake</code> directory for examples. Then, in the appropriate <code>CMakeLists.txt</code> file for the code that depends on the library, use either the <code>get_external_for_plugin</code> (if your code is a plugin) or <code>get_external</code> macros to include the library in the build. Also, be sure to add the library to the <code>DEPENDS</code> list of your code's CMake target.</p>"},{"location":"contributing/third_party/#linking-to-the-library","title":"Linking to the Library","text":"<p>Once the library has been made available to the build system (see the above sections), you will need to ensure that the system can find any relevant headers and link to and locate the library at build and runtime. This is accomplished with the <code>target_include_directories</code> and <code>target_link_libraries</code> commands in the appropriate <code>CMakeLists.txt</code> file. See any of the existing <code>CMakeLists.txt</code> files in <code>plugins/*</code> for examples.</p>"},{"location":"contributing/third_party/#helpful-cmake-links","title":"Helpful CMake Links","text":"<ul> <li>CMAKE_PREFIX_PATH The path that CMake will search for <code>Find&lt;package&gt;.cmake</code> files.</li> <li>find_package The CMake command to search the system for the given package and populate variables with the   results.</li> <li>find_library The CMake command to search for a library on the system.</li> <li>Using pkg-config with CMake</li> <li>file The CMake command for numerous file operations.</li> <li>execute_process The CMake command to execute a process.</li> <li>add_custom_command The CMake command to add a custom command to the build system.</li> <li>target_include_directories The CMake command to add include directories to a target.</li> <li>target_link_libraries The CMake command to add libraries to link to, to a target.</li> </ul>"},{"location":"plugin_README/README_debugview/","title":"debugview","text":""},{"location":"plugin_README/README_debugview/#summary","title":"Summary","text":"<p><code>debugview</code> is a simple debugging view for the ILLIXR system. By subscribing to several Switchboard endpoints, many important datapoints can be observed to help debug issues with the runtime. The debug view shows the current calculated SLAM pose and the (optional) ground truth pose read from the ground truth dataset as 3D headset models drawn on a backdrop scene. In addition, camera and IMU data is also visible, with the stereoscopic onboard camera views shown in one of the windows. Various offsets can be applied to the generated poses to aid in viewing. Dear ImGUI is used for displaying data and providing an interactive interface.</p>"},{"location":"plugin_README/README_debugview/#switchboard-connection","title":"Switchboard connection","text":"<ul> <li><code>debugview</code> subscribes to the slow-pose, which represents the latest pose published by the SLAM/IMU system.</li> <li>In the future, <code>debugview</code> will also query for the most up-to-date predicted pose through an RPC-like query system.   This is not currently in our release version; but is in development and will be added soon. The \"fast pose\" referenced   in this plugin just samples the <code>slow_pose</code> instead.</li> <li><code>debugview</code> also is synchronously dependent on the <code>imu_cam</code> topic, as the stereoscopic camera views are displayed in   the debug window. In ILLIXR, \"synchronous dependencies\" are implemented as scheduled \"handlers\" that are executed from   a shared thread pool; this handler is executed every time a fresh \"packet\" is available from the <code>imu_cam</code> topic.   Given that this is a separate thread from the main graphics thread, this <code>imu_cam</code> packet must be saved/cached for   later, when the graphics thread renders the next frame. This is a good example to follow when writing your own   multithreaded components that use both synchronous and asynchronous dependencies, and need to share information across   dependency boundaries.</li> </ul>"},{"location":"plugin_README/README_debugview/#environment-variables","title":"Environment Variables","text":"<p>DEBUGVIEW_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p>"},{"location":"plugin_README/README_debugview/#notes","title":"Notes","text":"<p><code>debugview</code> will be under heavy development in the near-term. Pull requests may or may not be accepted, due to the frequency of rapid internal changes.</p>"},{"location":"plugin_README/README_debugview/#known-issues","title":"Known Issues","text":"<p>Currently, the poses returned from the SLAM system have an incorrect initial rotation, as the poses are returned in an incorrect frame of reference. Thus, the headsets may appear to be tilted incorrectly; the button \"calculate new orientation offset\" will reset the orientation, such that the current orientation is considered the \"neutral\" orientation. In a future update, the correct frame of reference/transform matrix will be applied and the pose will accurately reflect the actual head position.</p>"},{"location":"plugin_README/README_debugview/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_fauxpose/","title":"FauxPose ILLIXR plugin","text":""},{"location":"plugin_README/README_fauxpose/#summary","title":"Summary","text":"<p>The <code>FauxPose</code> ILLIXR plugin generates \"fast_pose\" data from a simple mathematical algorithm (circular movement). The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking.</p> <p>The movement is hard-coded to be on the Y=center.y plane, with the X and Z values set to rotate in a circle. The period and amplitude of the movement are have default values (0.5, and 2.0 respectively) that can be changed through environment variables.</p> <pre><code>Topic details:\n-   *Publishes* `pose_position` on `fast_pose` topic.\n</code></pre>"},{"location":"plugin_README/README_fauxpose/#usage","title":"Usage","text":"<p>The \"FauxPose\" plugin must be included in the YAML configuration file prior to any rendering plugin (such as  <code>debugview</code> or <code>gldemo</code>). Also, no other pose-generating plugin should be included.</p> <p>An example <code>profiles/fauxpose.yaml</code> configuration file is included as an example.</p> <p>By default, the \"orbit\" of the tracked position will be about the point (0.0, 1.5, 0.0), with a default amplitude of \" 2.0\", and period of \"0.5\" seconds, with the orientation facing the negative-X direction. The first three of these values can be overridden through environment variables:</p> <pre><code>- FAUXPOSE_PERIOD=&lt;n&gt;\n- FAUXPOSE_AMPLITUDE=&lt;n&gt;\n- FAUXPOSE_CENTER=&lt;x,y,z&gt;\n</code></pre>"},{"location":"plugin_README/README_gldemo/","title":"gldemo","text":""},{"location":"plugin_README/README_gldemo/#summary","title":"Summary","text":"<p>The <code>gldemo</code> plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>gldemo</code> will subscribe to several switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the Switchboard API. <code>gldemo</code> is intended to be as lightweight as possible, serving as a baseline debug \" dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; <code>gldemo</code> fills this requirement. As an important note, <code>gldemo</code> does not render stereoscopically; the two eye renders are rendered from the same position. This may be updated to render stereoscopically in the future, but is not seen as a critical feature as this is generally intended as a debugging tool.</p>"},{"location":"plugin_README/README_gldemo/#switchboard-connection","title":"Switchboard connection","text":"<p><code>gldemo</code> subscribes to and publishes to several switchboard plugs. Most notably, <code>gldemo</code> subscribes to the <code>fast_pose</code> plug, which (ideally) represents the most recent extrapolated pose. This connection represents an area of active development in ILLIXR, as we are replacing the pose subscription with an RPC-like proper pose prediction system. As of the time of writing, <code>fast_pose</code> is functionally identical to the <code>slow_pose</code> published by the SLAM system, but this will change when proper pose extrapolation is implemented. <code>gldemo</code> also pulls the correct graphics context from Phonebook.</p> <p><code>gldemo</code> publishes the rendered eyebuffers to the Switchboard system as well, using whichever eyebuffer format has been selected with the <code>USE_ALT_EYE_FORMAT</code> compile-time macro. The alternative eye format is more similar to the format used by Monado/OpenXR, and is more fully explained by the code comments.</p>"},{"location":"plugin_README/README_gldemo/#environment-variables","title":"Environment Variables","text":"<p>GLDEMO_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p>"},{"location":"plugin_README/README_gldemo/#notes","title":"Notes","text":"<p><code>gldemo</code> does not pretend to be an OpenXR application; it does not use the OpenXR API, nor does it follow typical OpenXR patterns. It hooks directly into the Switchboard system and is intended as a debug/visualization tool. For more accurate and representative testing, consider running ILLIXR with an actual OpenXR application.</p>"},{"location":"plugin_README/README_gldemo/#known-issues","title":"Known Issues","text":"<p>As noted above, <code>gldemo</code> does not actually render stereoscopically, and the two eye buffers are rendered from the same eye location. (This is not to say that the two eye buffers are not rendered separately; they are actually two separate draw calls.) In addition, the quality of the pose used by <code>gldemo</code> is dependent on the upstream pose, which is currently not extrapolated/predicted and is subject to change.</p>"},{"location":"plugin_README/README_gldemo/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and are a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_hand_tracking/","title":"Hand Tracking","text":""},{"location":"plugin_README/README_hand_tracking/#summary","title":"Summary","text":"<p><code>hand_tracking</code> and <code>hand_tracking_gpu</code> are plugins which detects hands in an image. The plugins integrate the Mediapipe hand landmark detectionE11 algorithm into the ILLIXR framework. The only difference between <code>hand_tracking</code> and <code>hand_tracking_gpu</code> are where the data are processed: CPU vs GPU. Their operation and interface are identical. ( Currently the GPU version is a work in progress.)</p>"},{"location":"plugin_README/README_hand_tracking/#switchboard-connection","title":"Switchboard connection","text":"<p>The <code>hand_tracking</code> plugin subscribes to the webcam to get the input images to process. Future development will allow this plugin to subscribe to other input types dynamically, depending on the users' needs. The plugin utilizes the following data structures</p> <ul> <li>rect: representation of a rectangle<ul> <li>x_center: x-coordinate of the rectangle center</li> <li>y_center: y-coordinate of the rectangle center</li> <li>width: width of the rectangle</li> <li>height: height of the rectangle</li> <li>rotation: rotation angle of the rectangle in radians</li> <li>normalized: boolean indicating the units; <code>true</code> indicates normalized units [0..1] of the input image, <code>false</code>   indicates pixel units</li> <li>valid: boolean indicating whther the object is valid</li> </ul> </li> <li>point: representation of a 3D point<ul> <li>x: x-coordinate</li> <li>y: y-coordinate</li> <li>z: z-coordinate (not an absolute distance, but a measure of the point's depth relative to other points)</li> <li>normalized: boolean indicating the units; <code>true</code> indicates normalized units [0..1] of the input image, <code>false</code>   indicates pixel units</li> <li>valid: boolean indicating whther the object is valid</li> </ul> </li> </ul> <p>Note</p> <p>All coordinates in these data are normalized to the input image size</p> <p>The plugin published an <code>ht_frame</code> which contains the following data</p> <ul> <li>detections: the raw information produced by the mediapipe code, x and y coordinates are normalized to the input   image size, and z has no meaning<ul> <li>left_palm: rect which encloses the left palm, if detected</li> <li>right_palm: rect which encloses the right palm, if detected</li> <li>left_hand: rect which encloses the entire left hand, if detected</li> <li>right_hand: rect which encloses the entire right hand, if detected</li> <li>left_confidence: float indicating the detection confidence of the left hand [0..1]</li> <li>right_confidence: float indicating the detection confidence of the right hand [0..1]</li> <li>left_hand_points: vector of the 21 point objects, one for each hand landmark, from the left hand, if detected</li> <li>right_hand_points: vector of the 21 point objects, one for each hand landmark, from the right hand, if detected</li> <li>img: cv::Mat in <code>CV_8UC4</code> format (RGBA), representing the detection results</li> </ul> </li> <li>hand_positions: map of detected points for each hand, if depth cannot be determined then the value for that axis   will have no meaning (axis will depend on the coordinate reference frame), coordinate origin is defined by the user at   startup</li> <li>hand_velocities: map of velocities for each detected point for each hand, requires that depth is known or   calculated, and the last iteration of the code produced valid results, the units unit per second</li> <li>offset_pose: a pose, that when removed from each point, will give coordinates relative to the camera</li> <li>reference: the coordinate reference space (e.g. left hand y up)</li> <li>unit: the units of the coordinate system</li> </ul> <p>Info</p> <p>The detections may be removed or re-worked in future releases </p> <p>Each vector of hand points contains 21 items which reference the following ( from https://ai.google.dev/edge/mediapipe/solutions/vision/hand_landmarker)</p> <p></p> <p>The <code>landmark_points</code> <code>enum</code> can be used to reference the individual points in each vector</p> <pre><code>ht.left_hand_points[THUMB_TIP]\n</code></pre> <p>will get the <code>point</code> for the tip of the left thumb.</p>"},{"location":"plugin_README/README_hand_tracking/#environment-variables","title":"Environment Variables","text":"<p>The hand tracking utilizes the following environment/yaml file variables to control its processing:</p> <ul> <li>HT_INPUT: the type of images to be fed to the plugin. Values are<ul> <li>zed</li> <li>cam (for typical cam_type/binocular images)</li> <li>webcam (single image)</li> </ul> </li> <li>HT_INPUT_TYPE: descriptor of what image(s) to use. Values are<ul> <li>LEFT - only use the left eye image from an input pair</li> <li>SINGLE - same as LEFT</li> <li>RIGHT - only use the right eye image from an input pair</li> <li>MULTI - use both input images</li> <li>BOTH - same as MULTI</li> <li>RGB - only a single input image</li> </ul> </li> <li>WCF_ORIGIN: the origin pose of the world coordinate system as a string of three, four, or seven numbers. The   numbers should be comma separated with no spaces.<ul> <li>x,y,z - three coordinate version, representing the position of the origin pose (quaternion will be 1,0,0,0)</li> <li>w,wx,wy,wz - four coordinate version, representing the quaternion of the origin pose (position will be 0,0,0)</li> <li>x,y,z,w,wx,wy,wz - seven coordinate version, representing the full origin pose</li> </ul> </li> </ul>"},{"location":"plugin_README/README_hand_tracking/#helper-plugins","title":"Helper plugins","text":"<p>There are two additional plugins which are designed to aid in debugging the <code>hand_tracking</code> plugin.</p>"},{"location":"plugin_README/README_hand_tracking/#viewer","title":"Viewer","text":"<p>The <code>hand_tracking.viewer</code> plugin subscribes to the output of the <code>hand_tracking</code> plugin and displays the results, both graphically and in tabular format.</p>"},{"location":"plugin_README/README_hand_tracking/#webcam","title":"Webcam","text":"<p>The <code>webcam</code> plugin can feed single frame images to the hand tracking plugin.</p>"},{"location":"plugin_README/README_hand_tracking/#openxr","title":"OpenXR","text":"<p>The hand tracking plugin can be built with an OpenXR interface. To build the interface add <code>-DBUILD_OXR_INTERFACE=ON</code> to your cmake command line. The interface itself is in libopenxr_illixr_ht.so and is designed to be an API Layer. It installs a json file in the user's <code>.local</code> directory and is automatically detected by libopenxr_loader.so To use the layer you will need both an OpenXR application and runtime. This code is known to be compatible with the Monado runtime, and should be compatible with others. Currently, the hand tracking must receive that data from ILLIXR, but as an API Layer the resulting calculations can be retrieved via OpenXR API calls.</p>"},{"location":"plugin_README/README_hand_tracking/#api","title":"API","text":"<p>The hand tracking API can be found here.</p>"},{"location":"plugin_README/README_lighthouse/","title":"Lighthouse","text":""},{"location":"plugin_README/README_lighthouse/#summary","title":"Summary","text":"<p>The <code>lighthouse</code> plugin supports lighthouse tracking using the libsurvive library. To use this plugin, libsurvive should first be built, installed, and calibrated according to their documentation. Running ILLIXR's CMake to build the <code>lighthouse</code> plugin should automatically build and install <code>libsurvive</code>, but the steps to calibrate the lighthouses should still be followed.</p>"},{"location":"plugin_README/README_lighthouse/#note","title":"Note","text":"<p>If the <code>lighthouse</code> plugin is being used, make sure to set the environment variable <code>ILLIXR_LIGHTHOUSE</code> to true, as the <code>pose_prediction</code> relies on it.</p>"},{"location":"plugin_README/README_native_renderer/","title":"native_renderer","text":""},{"location":"plugin_README/README_native_renderer/#summary","title":"Summary","text":"<p><code>native_renderer</code> utilizes <code>vkdemo</code> and <code>timewarp_vk</code> to construct a full rendering pipeline.  <code>vkdemo</code> is used to render the scene, and <code>timewarp_vk</code> is used to perform rotational reprojection. This plugin creates the necessary Vulkan resources and targets for <code>vkdemo</code> and <code>timewarp_vk</code> to render to, and then composites the results into a single image. The resulting image is presented using the Vulkan swapchain provided by <code>display_vk</code>.</p>"},{"location":"plugin_README/README_native_renderer/#environment-variables","title":"Environment Variables","text":"<p>NATIVE_RENDERER_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \" error\", \"critical\", or \"off\"</p>"},{"location":"plugin_README/README_offload_rendering_client/","title":"offload_rendering_client","text":""},{"location":"plugin_README/README_offload_rendering_client/#summary","title":"Summary","text":"<p><code>offload_rendering_client</code> receives encoded frames from the network, and uses a mix of NPPI and FFMPEG to decode the frames before updating the buffer pool. Setting the environment variable <code>ILLIXR_USE_DEPTH_IMAGES</code> to a non-zero value indicates that depth images are being received, and should thus also be decoded.</p> <p>Note that there is a known color shift issue (to be fixed), where the decoded frame's colors are slightly different from the original frame (likely due to the many conversions between YUV and RGBA). </p>"},{"location":"plugin_README/README_offload_rendering_server/","title":"offload_rendering_server","text":""},{"location":"plugin_README/README_offload_rendering_server/#summary","title":"Summary","text":"<p><code>offload_rendering_server</code> encodes frames using FFMPEG and transmits them to the client with the network_backend from switchboard. In addition to the frame, some additional information is also transmitted, e.g., the pose used for the rendered frame so that the client can reprojected the decoded frame accordingly.</p> <p>Relevant environment variables include:   - <code>ILLIXR_USE_DEPTH_IMAGES</code> set to non-zero will encode/transmit depth images.   - <code>ILLIXR_OFFLOAD_RENDERING_BITRATE</code> sets the encoding bitrate.   - <code>ILLIXR_OFFLOAD_RENDERING_FRAMERATE</code> sets the encoding framerate.   - <code>ILLIXR_OFFLOAD_RENDERING_NALU_ONLY</code> set to non-zero indicates a Jetson client.</p> <p>Note</p> <p>Note that at the moment, the <code>offload_rendering_server</code> only supports Monado + OpenXR apps, and does not offload the native demos.</p>"},{"location":"plugin_README/README_offload_vio/","title":"Offload VIO","text":""},{"location":"plugin_README/README_offload_vio/#summary","title":"Summary","text":"<p><code>offload_vio</code> implements the functionality of moving VIO (Visual Inertial Odometry) to some server. There are four plugins that handle transmission (<code>_tx</code>) and reception (<code>_rx</code>) of data on the client (<code>device</code>) and server (<code>server</code>) respectively.</p>"},{"location":"plugin_README/README_offload_vio/#usage","title":"Usage","text":"<p>In order to run offloading vio, you need the following extra dependecies</p> <pre><code>sudo add-apt-repository ppa:ecal/ecal-latest\nsudo apt-get update\nsudo apt-get install ecal\nsudo apt-get install libprotobuf-dev protobuf-compiler\n</code></pre> <p>Please refer to the README in <code>tcp_network_backend</code> for setting the server and client IP address and port number.</p> <p>The most simple example is running the offloaded setup on one machine with the server running in one terminal and the device running in a different terminal. Each terminal must be running from separate ILLIXR repositories (clone ILLIXR twice to different locations; running both the server and device from the same ILLIR repository will cause lock issues).</p> <p>Start the server using</p> <pre><code>main.opt.exe --yaml=profiles/offload_vio_server.yaml --data=&lt;&gt; --demo_data=&lt;&gt;\n</code></pre> <p>in one terminal and</p> <pre><code>main.opt.exe --yaml=profiles/offload_vio_device.yaml --data=&lt;&gt; --demo_data=&lt;&gt;\n</code></pre> <p>in the other terminal for the client. This will run OpenVINS on the server and will feed it with the EuRoC dataset ( replace &lt;&gt; in --data with <code>data</code>) from the device.</p> <p>To run the client and server on different machines, please again refer to the README in <code>tcp_network_backend</code> for setting appropriate server IP address and port number.</p>"},{"location":"plugin_README/README_offload_vio/#compression","title":"Compression","text":"<p>H.264 codec is supported for compressing the camera images to save bandwidth. To enable compression, define <code>USE_COMPRESSION</code> in <code>device_tx/plugin.cpp</code> and <code>server_rx/plugin.cpp</code> (defaulted to not enabled). In <code>device_tx/video_encoder.cpp</code> and <code>server_rx/video_decoder.cpp</code>, define appropriate image dimensions and desired target bitrate (defaults to 5Mbps). The codec library is implemented based on GStreamer and DeepStream. Please follow the instructions here to install GStreamer and DeepStream SDK. You don't have to reinstall CUDA and NVIDIA Driver if you have a relatively new version. TensorRT and librdkafka are not required either.</p>"},{"location":"plugin_README/README_openni/","title":"OpenNI","text":""},{"location":"plugin_README/README_openni/#set-camera-mode","title":"Set Camera Mode","text":"<p>If you wish to switch up the video modes of OpenNI, update these two macros in <code>openni/plugin.cpp</code> accordingly: <pre><code>#define RGB_MODE 0\n#define DEPTH_MODE 0\n</code></pre></p> <p>You can see the list of available modes once you run ILLIXR the first time. </p>"},{"location":"plugin_README/README_openni/#debugging","title":"Debugging","text":"<p><pre><code>Device open failed:     DeviceOpen using default: no devices found\n</code></pre> Solution: No OpenNI compatible device is plugged in. So plug one in</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": USB transfer timeout!\n</code></pre> Solution: This is usually fixed by unplug and plug back in.</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": Failed to open the USB device!\n</code></pre> Solution: Fix by running with sudo </p>"},{"location":"plugin_README/README_openni/#environment-variables","title":"Environment Variables","text":"<p>OPENNI_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"critical\", or \"off\"</p>"},{"location":"plugin_README/README_openwarp_vk/","title":"openwarp_vk","text":""},{"location":"plugin_README/README_openwarp_vk/#summary","title":"Summary","text":"<p><code>openwarp_vk</code> is a Vulkan-based translational reprojection service intended for use in the ILLIXR architecture.</p>"},{"location":"plugin_README/README_openwarp_vk/#phonebook-service","title":"Phonebook Service","text":"<p><code>openwarp_vk</code> is registered as a service in phonebook, conforming to the <code>timewarp</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a   specific render pass and subpass, to which <code>openwarp_vk</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> calculates the reprojection matrix given the current pose and the pose   used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before   <code>record_command_buffer</code> is called</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int left)</code> records the commands into a given command buffer that   would perform the reprojection for one eye, for which 1 is left and 0 is right</li> </ul> <p>Note</p> <p>Note that at the moment, OpenWarp assumes that a reverse depth buffer is being used (as in Unreal Engine, Godot, and our native demo). If you're using an application that uses forward depth, the projection matrices and Vulkan pipeline configuration should be updated accordingly.</p>"},{"location":"plugin_README/README_orb_slam3/","title":"ORB-SLAM","text":"<p>This plugin uses the ORB-SLAM3 library for real-time VIO.</p>"},{"location":"plugin_README/README_record_imu_cam/","title":"Record IMU Cam","text":"<p>The purpose of this plugin is to record a dataset, similar to the EuRoC MAV dataset that includes the IMU data and Cam images.</p>"},{"location":"plugin_README/README_record_imu_cam/#how-to-record-a-dataset","title":"How to record a dataset","text":"<p>Add <code>record_imu_cam</code> to either your input yaml file or to your <code>--plugins</code> argument when invoking the ILLIXR executable.</p> <p>After recording, the dataset will be stored in the ILLIXR project directory, with the following structure:</p> <pre><code>ILLIXR/data_record\n    \\_ cam0/\n        \\_ data/ \n            \\_ timestamp.png\n            \\_ ...\n        \\_ data.csv\n    \\_ cam1/\n        \\_ data/\n            \\_ timestamp.png\n            \\_ ...\n        \\_ data.csv\n    \\_ imu0\n        \\_ data.csv\n</code></pre>"},{"location":"plugin_README/README_record_imu_cam/#format","title":"Format","text":"<ol> <li><code>cam0/data.csv</code> and <code>cam1/data.csv</code> are both formatted as<pre><code>timestamp [ns], timestamp.png\n</code></pre> <ol> <li> <p><code>imu0/data.csv</code> is formatted as</p> <p>timestamp [ns],w_x [rad s^-1],w_y [rad s^-1],w_z [rad s^-1],a_x [m s^-2],a_y [m s^-2],a_z [m s^-2]</p> </li> </ol> </li> </ol>"},{"location":"plugin_README/README_record_imu_cam/#how-to-rerun-recorded-dataset","title":"How to rerun recorded dataset","text":"<ol> <li> <p>(IMPORTANT) Do not specify <code>record_imu_cam</code> in either your input yaml file or to your <code>--plugins</code> argument when    invoking the ILLIXR executable.</p> </li> <li> <p>When running the ILLIXR executable do one of the following:</p> <ul> <li>In the input yaml file add a line to the <code>env_vars</code> section: <code>data: &lt;PATH_TO_ILLIXR&gt;/data_record</code></li> <li>Add <code>--data=&lt;PATH_TO_ILLIXR&gt;/data_record</code> to the command line arguments</li> <li>Set the environment variable <code>ILLIXR_DATA</code> to <code>&lt;PATH_TO_ILLIXR&gt;/data_record</code></li> </ul> </li> <li> <p>Make sure other plugins that feed images and IMU are not being used, such as <code>offline_cam</code>,     <code>offline_imu</code>, <code>zed</code>, and <code>realsense</code>.</p> </li> </ol>"},{"location":"plugin_README/README_timewarp_gl/","title":"timewarp_gl","text":""},{"location":"plugin_README/README_timewarp_gl/#summary","title":"Summary","text":"<p><code>timewarp_gl</code> is an OpenGL-based asynchronous rotational reprojection plugin intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).</p>"},{"location":"plugin_README/README_timewarp_gl/#switchboard-connection","title":"Switchboard connection","text":"<p><code>timewarp_gl</code> subscribes to and publishes to several Switchboard plugs and Phonebook resources.</p> <ul> <li>The plugin grabs the GL context from Phonebook. This is necessary to share the eyebuffers with the rendering   application (or <code>gldemo</code>). As this is an OpenGL-based reprojection plugin, it relies on OpenGL   resources for the eyebuffers.</li> <li><code>timewarp_gl</code> subscribes to the most recent pose published by the system. Currently, as our pose-prediction system is   still under development, this is not technically accurate; the final, intended functionality is that the timewarp   plugin will sample a pose prediction algorithm through an RPC-like mechanism. As we complete our work on our pose   prediction system, this plugin will be modified to use this mechanism.</li> <li><code>timewarp_gl</code> also subscribes to the most recent frame published by the system. This frame data also includes the pose   that was used to render the frame; this is how the timewarp algorithm calculates the \"diff\" to be used to reproject   the frame.</li> </ul>"},{"location":"plugin_README/README_timewarp_gl/#environment-variables","title":"Environment Variables","text":"<p>TIMEWARP_GL_LOG_LEVEL: logging level for this plugin, values can be \"trace\", \"debug\", \"info\", \"warning\", \"error\", \" critical\", or \"off\"</p> <p>ILLIXR_TIMEWARP_DISABLE: whether to disable warping, values can be \"True\" or \"False\" (default)</p> <p>ILLIXR_OFFLOAD_ENABLE: whether to enable offloading, values can be \"True\" or \"False\" (default)</p>"},{"location":"plugin_README/README_timewarp_gl/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.</p>"},{"location":"plugin_README/README_timewarp_gl/#known-issues","title":"Known Issues","text":"<p>As noted above, this plugin currently samples <code>slow_pose</code>. This will be changed to sample a <code>fast_pose</code> topic through an RPC mechanism. In addition, JMP Van Waveren's algorithm includes a method for warping between two reprojection matrices based on the actual progress of the display controller's \"scanline\"; this is simply commented out in our code, but can be re-enabled when our pose prediction system comes online.</p>"},{"location":"plugin_README/README_timewarp_gl/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_timewarp_vk/","title":"timewarp_vk","text":""},{"location":"plugin_README/README_timewarp_vk/#summary","title":"Summary","text":"<p><code>timewarp_vk</code> is a Vulkan-based rotational reprojection service intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation).</p>"},{"location":"plugin_README/README_timewarp_vk/#phonebook-service","title":"Phonebook Service","text":"<p><code>timewarp_vk</code> is registered as a service in phonebook, conforming to the <code>timewarp</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a   specific render pass and subpass, to which <code>timewarp_vk</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> calculates the reprojection matrix given the current pose and the pose   used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before   <code>record_command_buffer</code> is called</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int left)</code> records the commands into a given command buffer that   would perform the reprojection for one eye, for which 1 is left and 0 is right</li> </ul>"},{"location":"plugin_README/README_timewarp_vk/#environment-variables","title":"Environment Variables","text":"<p>ILLIXR_TIMEWARP_DISABLE: whether to disable the warping, values can be \"True\" or \"False\"(default)</p>"},{"location":"plugin_README/README_timewarp_vk/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.</p>"},{"location":"plugin_README/README_vkdemo/","title":"vkdemo","text":""},{"location":"plugin_README/README_vkdemo/#summary","title":"Summary","text":"<p>The <code>vkdemo</code> service serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>vkdemo</code> will subscribe to several switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the switchboard API. <code>vkdemo</code> is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the  HMD display without needing to use the full OpenXR interface; <code>vkdemo</code> fills this requirement.</p>"},{"location":"plugin_README/README_vkdemo/#phonebook-service","title":"Phonebook Service","text":"<p><code>vkdemo</code> is registered as a service in phonebook, conforming to the <code>app</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a   specific render pass and subpass, to which <code>vkdemo</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> updates the uniform buffer with the given pose, which is used to render   the scene. This must be called before <code>record_command_buffer</code> is called.</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int eye)</code> records the commands into a given command buffer that   would perform the rendering for one eye, for which 0 is left and 1 is right. To achieve stereoscopic rendering, the   function is called twice, once for each eye.</li> <li><code>virtual void destroy()</code> cleans up the resources allocated by <code>vkdemo</code>. Currently, this part is not yet implemented.</li> </ul>"},{"location":"plugin_README/README_webcam/","title":"Webcam","text":""},{"location":"plugin_README/README_webcam/#webcam","title":"Webcam","text":"<p>The <code>webcam</code> plugin opens the attached webcam, captures images at 30 frames per second, and publishes them on the <code>webcam</code> topic as <code>monocular_cam_type</code>. The images are in cv::Mat format with color order RGB. Depending on your needs, you may  need to flip the images over the vertical axis. This plugin is intended mostly for testing and debugging other plugins.</p> <pre><code>    cv::flip(image, image, 1);\n</code></pre>"},{"location":"plugin_README/README_zed/","title":"ZED Mini","text":""},{"location":"plugin_README/README_zed/#getting-started","title":"Getting started","text":"<ul> <li>First, download the latest version of the ZED SDK on stereolabs.com.</li> <li>For more information, read the ZED API documentation.</li> </ul>"},{"location":"plugin_README/README_zed/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ubuntu 22.04 or 24.04</li> <li>CUDA</li> <li>ZED SDK</li> <li>OpenCV 4</li> </ul>"},{"location":"plugin_README/README_zed_data_injection/","title":"ZED Data Injection","text":"<p>This plugin reads in binocular images and pose information from files on disk and publishes them to ILLIXR. It is designed to feed data recorded by the zed_capture binary into the ILLIXR system. The root directory of the data must be specified in the <code>ILLIXR_TEST_DATA</code> environment variable.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/","title":"Monado Integration Overview","text":"<p>ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to force developers to write their whole application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR, so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado, an existing, open-source implementation of the standard.</p> <ul> <li> <p>When running ILLIXR without Monado, the ILLIXR runtime is the entry-point.     Phonebook and switchboard are initialized and plugins are loaded, among which is the vkdemo app.</p> </li> <li> <p>When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a   result, the ILLIXR runtime system is loaded at a later point as a shared library. This page documents the changes to   the ILLIXR runtime when an OpenXR application is used.</p> </li> </ul>"},{"location":"plugin_README/monado_illixr_runtime_overview/#openxr-application-launch","title":"OpenXR Application Launch","text":"<p>As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronos Group for more details.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#monado-device-probe-and-illixr-initialization","title":"Monado Device Probe and ILLIXR Initialization","text":"<p>During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as <code>xdev</code>s. Our ILLIXR driver will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The driver obtains the path to the ILLIXR runtime <code>.so</code> file and a list of plugins from environment variables.</p> <p>After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the ILLIXR driver. At this moment, all necessary data is ready and ILLIXR will be launched.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#illixr-runtime-launch","title":"ILLIXR Runtime Launch","text":"<p>When used with Monado, the ILLIXR Runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing the switchboard and phonebook, and loading plugins.</p> <p>The driver starts to load the runtime by loading the shared library into the current     (application's) address space and calls the Switchboard and Phonebook initialization. Then, it calls the plugin loading for each ILLIXR plugin     (except [<code>vkdemo</code>][28], which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path     to load a Translation Plugin into ILLIXR as the application. If the plugin implements a long-running computation, it may block the main ILLIXR thread     which drives the entire application. To remedy this, a plugin should implement long-running processing in its own thread. This way, the driver will be able to reacquire control and return to Monado     and the application efficiently.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#translation-plugin","title":"Translation Plugin","text":"<p>When the application and all ILLIXR plugins are up and running, the translation plugin handles the connection between Monado and ILLIXR. It might be confusing to see that this plugin is part of the ILLIXR driver which is part of Monado while at the same time also part of ILLIXR as a plugin. However, Monado and ILLIXR are running in different threads in the same address space. The translation plugin is the interface of these two parallel systems.</p> <p>The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, the translation plugin is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of ILLIXR, the translation plugin behaves the same as the <code>vkdemo</code> application: reading pose and submitting frames.</p> <p>For implementation details regarding the representation of poses and frames in Monado and in ILLIXR, please see ILLIXR's Monado Integration Dataflow.</p>"},{"location":"plugin_README/monado_integration_dataflow/","title":"Monado Integration Dataflow","text":"<p>The dataflow for the ILLIXR Monado integration comprises two steps:</p> <ol> <li>getting pose data from ILLIXR,</li> <li>sending a user rendered frame back to ILLIXR.</li> </ol> <p>In Monado, ILLIXR is recognized as an HMD for Monado, while in ILLIXR, Monado looks like a user application ( such as <code>vkdemo</code>). After ILLIXR is initialized from Monado, and Monado is registered as a plugin for ILLIXR, the most recent pose information can be easily obtained via the switchboard.</p> <p>The compositor side of Monado integration with ILLIXR is implemented more subtly. The original Monado compositor primarily performs distortion correction and aberration correction in a Vulkan back-end compositor. The compositor also has one, Vulkan based,  client compositor which passes frame data to the back-end compositor.</p> <p>The current ILLIXR integration for Monado is a temporary solution and has some drawbacks caused by the concurrent and continued development from both the Monado and ILLIXR projects. The integration:</p> <ol> <li> <p>Does not use the pose that user application declares to use at rendering (using the OpenXR specification). This is    due to incongruence with Monado's internal interfaces and representations. The pose difference used by     <code>timewarp_vk</code> is computed using the most recent query for a pose update.</p> </li> <li> <p>Cannot submit frame data with a depth buffer.</p> </li> <li> <p>Cannot have poses that make use of OpenXR Spaces. Raw pose data is instead retrieved from the application's     SLAM algorithms.</p> </li> <li> <p>Does not support controller action.</p> </li> <li> <p>User-space applications cannot acquire more than one swap chain buffer for each eye         during the processing of a frame.</p> </li> <li> <p>Must initialize ILLIXR during the session initialization.</p> </li> </ol>"},{"location":"plugin_README/zed_capture/","title":"zed_capture","text":"<p>The <code>zed_capture</code> binary is used to generate test data for injection into ILLIXR. The binary is a stand-alone feature and does not interact with the rest of ILLIXR. It takes the following command line arguments.</p> Argument Description Default -d, --duration The duration to run for in seconds 10 -f, --fps Frames per second 30 --wc The origin of the world coordinate system in relation to the camera. Must be 7 comma separated values x, y, z, w, wx, wy, wz. 0., 0., 0., 1., 0., 0., 0. -p --path The root path to write the data to. Current working directory <p><code>zed_capture</code> will write out the left and right camera images and the current pose at each frame. Note that it may not work at the requested fps due to overheads of writing files. This will be addressed in future updates. Note that the depth information is also not captured currently as OpenCV does not properly write out cv::Mat objects with float formats. This will also be addressed in future updates.</p> <p>Data are written to /'fps' +  + 'dur' +  (e.g. /fps30_dur10 will contain data  taken at 30 frames per second with a total run time of 10 seconds, or 300 frames, it will always contain 300 frames regardless of any slow down due to overheads). This format is compatible with the zed.data_injection plugin."},{"location":"policies/branch_retention/","title":"Branch Retention","text":"GitHub Branch Retention Policy   Version 1.0<p>  March 1, 2024"},{"location":"policies/branch_retention/#history","title":"History","text":"Version Date Who Notes 1.0 03/01/2024 ILLIXR Team Initial version"},{"location":"policies/branch_retention/#introduction","title":"Introduction","text":"<p>The purpose of this document is to outline the policy for retaining, combining, and pruning (deleting) branches in the ILLIXR GitHub repository.</p>"},{"location":"policies/branch_retention/#definitions","title":"Definitions","text":"<ul> <li> <p>stale: GitHub\u2019s definition is a branch that has not had any commits in at least 3 months. Since this is an active   research project that includes students who may not be active for several months at a time (breaks, internships,   etc.), we will take a looser time definition of 12 months. Note: the master branch can never be considered stale.</p> </li> <li> <p>active: The inverse of \u2018stale\u2019. We will consider a branch to be active if it has had any commits within the last   12 months.</p> </li> </ul>"},{"location":"policies/branch_retention/#policy","title":"Policy","text":"<p>To keep the repository manageable , we will occasionally prune stale branches according to the following:</p> <ul> <li>Any branch that has been stale for at least 24 months is subject to pruning at any time</li> <li>Any branch that is part of an open pull request will be retained, regardless of age/status</li> <li>Any branch that is part of an open issue will be retained, regardless of age/status</li> <li>Any branch that is part of an official release will be retained until at least the next release</li> <li>After an official release, any branches from previous releases should be discussed for pruning</li> </ul> <p>Exceptions</p> <p>There are instances where someone may want to retain a stale branch indefinitely for research, reference, or other purposes. In these instances, it will be our policy to tag the branch as an archived branch, and then delete the stale branch. The tagged branch will be available indefinitely, but will no longer appear on a listing of branches, thus satisfying the desire to keep a manageable repository and the availability of the code from the branch. The following commands (or their equivalent on the GitHub web interface) will be used:  <pre><code>git tag archive/&lt;branch_name&gt; &lt;branch_name&gt;\ngit branch -D &lt;branch_name&gt;\n</code></pre>  To checkout the archived branch:  <pre><code>git checkout -b &lt;branch_name&gt; archive/&lt;branch_name&gt;\n</code></pre></p> <p>Note</p> <p>The branch name for the tag does not have to match the actual branch name, but should be descriptive of what the branch is for.</p> <p>In addition to pruning old branches, an active effort should be made to minimize the number of branches used for a specific development project/plugin (e.g. adding a new capability, handling updates to a 3rd party library, etc.). As a rule of thumb, each research project and issue should only have a single branch associated with it. Additional branches can be added for testing/implementing specific details of the project/issue, but should not last more than a few weeks before being merged back into the primary branch for the project/issue.</p> <p>Divergent branches will be pruned/merged at release time.</p>"},{"location":"working_with/adding_mediapipe/","title":"Adding Mediapipe Based Plugins","text":"<p>There are several tools from Mediapipe which a may be of use to the ILLIXR project as a plugin. This page documents the process for converting these tools to plugins, following the experience of converting the hand landmark detection tool.</p>"},{"location":"working_with/adding_mediapipe/#steps","title":"Steps","text":"<ol> <li>Clone the repo</li> <li>Find the root file</li> <li>Understanding bazel BUILD files<ul> <li>Select Statements</li> <li>Descriptors<ul> <li>Binary</li> <li>Library</li> <li>Protobuf</li> <li>Pbtxt</li> <li>External Libraries</li> <li>Data Files</li> </ul> </li> <li>Parsing Dependencies<ul> <li>Local</li> <li>In another file</li> <li>External</li> </ul> </li> </ul> </li> <li>Find the necessary code files<ul> <li>C++</li> <li>Protobuf</li> <li>Pbtxt</li> <li>Data</li> <li>Move the Files</li> </ul> </li> <li>Package Dependencies<ul> <li>Common</li> <li>Custom</li> </ul> </li> <li>Plugin CMakeLists.txt<ul> <li>Header</li> <li>Command Line Options</li> <li>CMAKE_MODULE_PATH</li> <li>Dependencies</li> <li>Protobuf Helpers</li> <li>Special Operations</li> <li>The Plugin Itself</li> </ul> </li> <li>Adapting the Tool for ILLIXR<ul> <li>protobuf.cmake Files</li> <li>build.cmake Files</li> <li>Handling pbtxt Files</li> </ul> </li> <li>Writing Your Plugin<ul> <li>Understanding Graph Files</li> <li>Sending Data to the Tool</li> <li>Getting Data From the Tool</li> <li>Adding a Calculator<ul> <li>Changing Graph Files</li> <li>Data Structures</li> <li>Calculator Code<ul> <li>Common Function Calls</li> <li>GetContract</li> <li>Open</li> <li>Process</li> </ul> </li> </ul> </li> <li>plugin.hpp</li> <li>plugin.cpp<ul> <li>Input</li> <li>Publisher</li> </ul> </li> <li>CMakeLists.txt</li> </ul> </li> </ol>"},{"location":"working_with/adding_mediapipe/#clone-the-repo","title":"Clone the repo","text":"<p>These tools are provided by Mediapipe in a single git repo (https://github.com/google-ai-edge/mediapipe.git). So clone the repo to your workspace. Since these tools share a number of dependencies and components in some cases it is best for all the wrapped tool to come from the same version of the Mediapipe codebase (currently v0.10.14).</p> <pre><code>git clone https://github.com/google-ai-edge/mediapipe.git\ngit checkout v0.10.14\n</code></pre> <p>or</p> <pre><code>wget https://github.com/google-ai-edge/mediapipe/archive/refs/tags/v0.10.14.tar.gz\ntar xf v0.10.14.tar.gz\n</code></pre> <p>For purposes of this tutorial the term <code>file root</code> will refer to the root directory of the clone or unpacked tarball.</p>"},{"location":"working_with/adding_mediapipe/#find-the-root-file","title":"Find the root file","text":"<p>Mediapipe tools use the bazel build system which is not compatible with the CMake build system ILLIXR uses. The bazel build system relies on files named BUILD and WORKSPACE as the primary building blocks to define what is to be built. You will need to locate the BUILD file associated with the tool you want to work with. These are located in mediapipe/example/desktop/. For example the hand tracking BUILD file is mediapipe/examples/desktop/hand_tracking/BUILD"},{"location":"working_with/adding_mediapipe/#understanding-bazel-build-files","title":"Understanding bazel BUILD files","text":"<p>Bazel BUILD (and WORKSPACE) files are written in a dialect of Python called Starlark. Most of the content of these files describe libraries and binaries which can be built, similar to a TARGET in Cmake. Unlike CMake where most TARGETS are complete libraries or binaries with numerous source files, libraries and binaries in bazel typically have a few, or only one source file. Each of these items also has a list of other items that it depends on. Thus, starting with the main binary descriptor, you can walk your way through each of the dependencies to find all source files that are needed. A bazel project may consist of hundreds, or even thousands, of individual libraries, described in dozens of files scattered around the source tree.</p> <p>There are only a few object types we need to concern ourselves with for wrapping a tool.</p> <ul> <li>cc_binary: describes what is needed to build an executable</li> <li>cc_library: describes what is needed to build a library component (usually produces a single object file)</li> <li>cc_library_with_tflite: specialized version of cc_library which links to tensorflow lite components</li> <li>mediapipe_proto_library: describes what is needed to build a library component from a protobuf file</li> <li>http_archive: describes where to find and build an external library, similar to CMake's ExternalProject or   Fetchcontent functionality</li> <li>mediapipe_simple_subgraph: describes a workflow, or sub-workflow, for a tool</li> <li>http_file: describes where to find a single file on the web, typically a precompiled data file</li> </ul>"},{"location":"working_with/adding_mediapipe/#select-statements","title":"Select Statements","text":"<p>In the bazel build system the keyword <code>select</code> is used to denote an if/then/else syntax when constructing a list of source files or dependencies. The syntax is similar to a python dictionary where each key is a condition to test, and the value is a list of descriptors to include in whatever list the select statement is attached to. The <code>//conditions:default</code> is used to indicate what to use if none of the other options are true. For example</p> <pre><code>deps = [\n   \"inference_calculator_cpu\"\n] + select({\n   \"//conditions:default\": [\"infer_calc_gl\", \"infer_shader\"],\n   \":platform_apple\": [\"infer_calc_metal\"],\n})\n</code></pre> <p>This statement would add the infer_calc_metal descriptor to the deps list if the build platform is apple, otherwise the infer_calc_gl and infer_shader are added. When these statements are encountered you will need to decide which descriptors need to be added to the appropriate list. In some instances you may need to set up similar logic in CMake syntax (e.g. include certain files if OpenCV is detected).</p>"},{"location":"working_with/adding_mediapipe/#example-descriptors","title":"Example Descriptors","text":""},{"location":"working_with/adding_mediapipe/#binary-executable","title":"Binary (executable)","text":"<pre><code>cc_binary(\n    name = \"hand_tracking_cpu\",\n    data = [\n        \"//mediapipe/modules/hand_landmark:hand_landmark_full.tflite\",\n        \"//mediapipe/modules/palm_detection:palm_detection_full.tflite\",\n    ],\n    deps = [\n        \"//mediapipe/examples/desktop:demo_run_graph_main\",\n        \"//mediapipe/graphs/hand_tracking:desktop_tflite_calculators\",\n    ],\n)\n</code></pre> <ul> <li>name: the name of the executable to be built</li> <li>data: data files which are used by the executable; these files can be downloaded from the web, and in CMake we   treat them like a source file</li> <li>deps: dependencies that this binary has</li> </ul> <p>!!!! note</p> <pre><code> The cc_binary descriptor does not give any source files, all source files come from the dependency listings.\n</code></pre>"},{"location":"working_with/adding_mediapipe/#library-component","title":"Library component","text":"<pre><code>cc_library(\n   name = \"landmarks_to_render_data_calculator\",\n   srcs = [\"landmarks_to_render_data_calculator.cc\"],\n   hdrs = [\"landmarks_to_render_data_calculator.h\"],\n   deps = [\n      \":landmarks_to_render_data_calculator_cc_proto\",\n      \"//mediapipe/framework:calculator_framework\",\n      \"//mediapipe/framework:calculator_options_cc_proto\",\n      \"//mediapipe/framework/formats:landmark_cc_proto\",\n      \"//mediapipe/framework/formats:location_data_cc_proto\",\n      \"//mediapipe/framework/port:ret_check\",\n      \"//mediapipe/util:color_cc_proto\",\n      \"//mediapipe/util:render_data_cc_proto\",\n      \"@com_google_absl//absl/memory\",\n      \"@com_google_absl//absl/strings\",\n   ],\n   alwayslink = 1,\n)\n</code></pre> <ul> <li>name: name of the library component (think of it like a TARGET in CMake)</li> <li>srcs: list of source files for this component</li> <li>hdrs: list of header files for this component</li> <li>deps: list of dependencies for this component (think of them as libraries to link against)</li> </ul> <p>Both the src and hdrs are optional, and often only one is present in a descriptor. The <code>alwayslink</code> and <code>visibility</code> items can be safely ignored.</p>"},{"location":"working_with/adding_mediapipe/#protobuf-library-component","title":"Protobuf library component","text":"<pre><code>mediapipe_proto_library(\n    name = \"annotation_overlay_calculator_proto\",\n    srcs = [\"annotation_overlay_calculator.proto\"],\n    deps = [\n        \"//mediapipe/framework:calculator_options_proto\",\n        \"//mediapipe/framework:calculator_proto\",\n        \"//mediapipe/util:color_proto\",\n    ],\n)\n</code></pre> <ul> <li>name: name of the library component (think of it like a TARGET in CMake)</li> <li>srcs: list of protobuf source files for this component</li> <li>deps: list of dependencies for this component (think of them a libraries to link against)</li> </ul>"},{"location":"working_with/adding_mediapipe/#pbtxt-files","title":"Pbtxt Files","text":"<p>There are two signatures for this type of file.</p> <pre><code>mediapipe_simple_subgraph(\n    name = \"hand_landmark_model_loader\",\n    graph = \"hand_landmark_model_loader.pbtxt\",\n    register_as = \"HandLandmarkModelLoader\",\n    deps = [\n        \"//mediapipe/calculators/core:constant_side_packet_calculator\",\n        \"//mediapipe/calculators/tflite:tflite_model_calculator\",\n        \"//mediapipe/calculators/util:local_file_contents_calculator\",\n        \"//mediapipe/framework/tool:switch_container\",\n    ],\n)\n</code></pre> <ul> <li>name: name of the component</li> <li>graph: the name of the file that describes the graph</li> <li>register_as: alias for the component name</li> <li>deps: list of dependencies for this component</li> </ul> <pre><code>mediapipe_binary_graph(\n    name = \"hand_tracking_desktop_live_binary_graph\",\n    graph = \"hand_tracking_desktop_live.pbtxt\",\n    output_name = \"hand_tracking_desktop_live.binarypb\",\n    deps = [\":desktop_tflite_calculators\"],\n)\n</code></pre> <ul> <li>name: name of the component</li> <li>graph: the name of the file that describes the graph</li> <li>output_name: name of the output files after processing</li> <li>deps: list of dependencies for this component</li> </ul>"},{"location":"working_with/adding_mediapipe/#external-library","title":"External library","text":"<pre><code># Load Zlib before initializing TensorFlow and the iOS build rules to guarantee\n# that the target @zlib//:mini_zlib is available\nhttp_archive(\n    name = \"zlib\",\n    build_file = \"@//third_party:zlib.BUILD\",\n    sha256 = \"b3a24de97a8fdbc835b9833169501030b8977031bcb54b3b3ac13740f846ab30\",\n    strip_prefix = \"zlib-1.2.13\",\n    url = \"http://zlib.net/fossils/zlib-1.2.13.tar.gz\",\n    patches = [\n        \"@//third_party:zlib.diff\",\n    ],\n    patch_args = [\n        \"-p1\",\n    ],\n)\n</code></pre> <ul> <li>name: name of the external package</li> <li>build_file: the location of the build file for the package</li> <li>sha256: hash to check the integrity of the downloaded file</li> <li>url: the full url of the package sources</li> <li>patches: any patch files to be applied</li> <li>patch_args: any additional command line arguments to send to the patch command</li> </ul>"},{"location":"working_with/adding_mediapipe/#individual-file","title":"Individual file","text":"<pre><code>http_file(\n    name = \"com_google_mediapipe_hand_landmark_full_tflite\",\n    sha256 = \"11c272b891e1a99ab034208e23937a8008388cf11ed2a9d776ed3d01d0ba00e3\",\n    urls = [\"https://storage.googleapis.com/mediapipe-assets/hand_landmark_full.tflite?generation=1661875760968579\"],\n)\n</code></pre> <ul> <li>name: name of the file description (for internal reference, is not necessarily the name of the actual file)</li> <li>sha256: hash to check the integrity of the downloaded file</li> <li>urls: list of urls where the file can be downloaded from</li> </ul>"},{"location":"working_with/adding_mediapipe/#parsing-the-dependencies","title":"Parsing the dependencies","text":"<p>As you may have noted, there are numerous formats that a dep entry can take. Let's take a look at them, so we can understand what they are saying.</p>"},{"location":"working_with/adding_mediapipe/#local","title":"Local","text":"<p>Local dependencies are those which are described in the same BUILD file in which they are referenced. For example, in the <code>cc_library</code> descriptor above, the first dep is local. It starts with a <code>:</code>, followed by a name</p> <pre><code>:landmarks_to_render_data_calculator_cc_proto\n</code></pre> <p>This means that there is a descriptor in this file with the name <code>landmarks_to_render_data_calculator_cc_proto</code>, and it is a dependency of <code>landmarks_to_render_data_calculator</code>.</p>"},{"location":"working_with/adding_mediapipe/#in-another-file","title":"In another file","text":"<p>Most of the dependencies in the <code>cc_library</code> example are described in other BUILD files. These entries start with <code>//</code> and have the following format</p> <pre><code>//&lt;path to build file&gt;:&lt;name of the dependency in that file&gt;\n</code></pre> <p>So in the second dependency in the <code>cc_library</code> example (<code>//mediapipe/framework:calculator_framework</code>), the descriptor is named <code>calculator_framework</code> and can be found in <code>mediapipe/framework/BUILD</code> (relative to the file root). The Local dependency format is really a specialized version of this format, where the path to the build file is absent, indicating the current file.</p>"},{"location":"working_with/adding_mediapipe/#external","title":"External","text":"<p>The remaining dependencies come from external libraries, this is really a list of libraries to link against, but which are also built along with this code. The entries start with <code>@</code> followed by the name of the external package, followed by the library path and name. So, <code>@com_google_absl//absl/memory</code> refers to the absl memory library described by an <code>http_archive</code> object with the name <code>com_google_absl</code>. As we refactor the code, and the build structure these types of references will be converted to something like</p> <pre><code>target_link_library(landmarks_to_render_data_calculator PUBLIC absl::memory)\n</code></pre>"},{"location":"working_with/adding_mediapipe/#find-the-necessary-code-files","title":"Find the necessary code files","text":"<p>Now that we have a handle on the basic structure of the files we will be going through, we can start to construct a list of the files we actually need to build our tool. Starting with the dependencies in the <code>cc_binary</code> descriptor we will need to locate each dependency, then find all of their dependencies, and so on until the only descriptors left have no internal dependencies (external ones are ok, as these libraries will be built beforehand and do not contribute source files).</p> <p>Note</p> <p>Some objects will be the dependency of many other objects.</p>"},{"location":"working_with/adding_mediapipe/#c","title":"C++","text":"<p>Create a list of every src and hdr file found in each descriptor.</p> <p>Note</p> <p>The descriptors only give the file name, you will need to add the path to each of these items, so we can keep track of them. </p>"},{"location":"working_with/adding_mediapipe/#protobuf","title":"Protobuf","text":"<p>Create a separate list of the source files of the <code>mediapipe_proto_library</code> items you need.</p>"},{"location":"working_with/adding_mediapipe/#pbtxt","title":"Pbtxt","text":"<p>Create a list of all files listed in graph elements of <code>mediapipe_simple_subgraph</code> items you need. Additionally, keep a list of all the dependencies for each of these, including the dependencies of those dependencies.</p>"},{"location":"working_with/adding_mediapipe/#data","title":"Data","text":"<p>Create a list of all data files that are listed in any descriptors. These are mainly tflite files.</p>"},{"location":"working_with/adding_mediapipe/#move-the-files","title":"Move the Files","text":"<p>Now that you have a list of the necessary file to build the tool you should create a separate GitHub repository for your plugin. Once that is done, create files and directories in the repo as follows:</p> <pre><code>&lt;root directory&gt;\n\u251c\u2500\u2500 CMakeLists.txt      # Main cmake file\n\u251c\u2500\u2500 cmake               # empty directory for cmake helper files\n\u251c\u2500\u2500 mediapipe           # empty directory to hold all the mediapipe files\n\u251c\u2500\u2500 plugin.cpp          # main plugin code file\n\u2514\u2500\u2500 plugin.hpp          # plugion header file\n</code></pre> <p>Copy/move all the needed files from your src, hdr, protobuf, pbtxt, and data file lists into the <code>mediapipe</code> directory, maintaining their relative paths. You should also create CMakeLists.txt and protobuf.cmake files in the mediapipe directory. Additionally, you should copy encoder.cmake, make_pb_binary.cmake, and protoc_generate_obj.cmake from the ILLIXR hand tracking repository. These files contain helper functions for processing the protobuf files and should go in a directory called <code>cmake</code>. Now you should have a directory structure something like this:</p> <pre><code>&lt;root directory&gt;\n\u251c\u2500\u2500 CMakeLists.txt      # Main cmake file\n\u251c\u2500\u2500 cmake\n\u2502   \u251c\u2500\u2500 encoder.cmake\n\u2502   \u251c\u2500\u2500 make_pb_binary.cmake\n\u2502   \u2514\u2500\u2500 protoc_generate_obj.cmake\n\u251c\u2500\u2500 mediapipe           \n\u2502   \u251c\u2500\u2500 calculators\n\u2502   \u251c\u2500\u2500 example\n\u2502   \u251c\u2500\u2500 framework\n\u2502   \u251c\u2500\u2500 gpu\n\u2502   \u251c\u2500\u2500 graphs\n\u2502   \u251c\u2500\u2500 module\n\u2502   \u2514\u2500\u2500 utils\n\u251c\u2500\u2500 plugin.cpp          # main plugin code file\n\u2514\u2500\u2500 plugin.hpp          # plugion header file\n</code></pre>"},{"location":"working_with/adding_mediapipe/#package-dependencies","title":"Package Dependencies","text":""},{"location":"working_with/adding_mediapipe/#common","title":"Common","text":"<p>Common dependencies are those that can be via OS package managers, like boost. There is generally no need to install these directly. We will just add them as <code>find_package</code> commands in the CMakeLists.txt file. There are however, exceptions to this rule. An example of this is the Protobuf package. The Mediapipe package requires a Protobuf version of at least 3.19, which may not be directly available on all OS versions. In this case, the dependency should be treated like a Custom dependency.</p>"},{"location":"working_with/adding_mediapipe/#custom","title":"Custom","text":"<p>Custom dependencies are those which are not readily available via OS package managers, or a specific version which cannot be installed this way. In these cases will add some code to the CMakeLists.txt file to make sure the dependency is met. The CMakeLists.txt should first do a version check (in case the needed version already exists on the system), and then download and install the needed version if required. Below is an example for the Protobuf package</p> <pre><code>find_package(protobuf 3.19 QUIET CONFIG)\nif(protobuf_FOUND)\n   report_found(protobuf \"${protobuf_VERSION}\")\nelse()\n   ExternalProject_Add(\n           protobuf\n           GIT_REPOSITORY https://github.com/protocolbuffers/protobuf.git\n           GIT_TAG v3.19.1\n           GIT_PROGRESS TRUE\n           PREFIX \"${CMAKE_BINARY_DIR}/protobuf\"\n           DOWNLOAD_EXTRACT_TIMESTAMP TRUE\n           CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=\"-fPIC\"\n           SOURCE_SUBDIR cmake\n           GIT_SUBMODULES_RECURSE TRUE\n   )\nendif()\n</code></pre> <p>As with the Hand Tracking plugin, there will likely be a good number of external package dependencies. So that all of the <code>find_package</code> calls in the plugin work as expected, a separate repo was created. This allows for the dependencies to be built and installed before the plugin tries to find its dependencies. You may need a similar mechanism for your tool (or even just use the hand tracking one)</p>"},{"location":"working_with/adding_mediapipe/#plugin-cmakeliststxt","title":"Plugin CMakeLists.txt","text":"<p>In this section we will use the adaption of the Hand Tracking tool as an example. This file will be presented in sections below.</p>"},{"location":"working_with/adding_mediapipe/#header","title":"Header","text":"<pre><code>cmake_minimum_required(VERSION 3.22)\nproject(ILLIXR_hand_tracking)\nset(CMAKE_VERBOSE_MAKEFILE True)\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\nset(CMAKE_PREFIX_PATH \"${CMAKE_INSTALL_PREFIX}/lib/cmake\")\nset(ENV{PKG_CONFIG_PATH} \"${CMAKE_INSTALL_PREFIX}/lib/pkgconfig\")\n</code></pre> <p>Here the name of the plugin/project is declared along with some global variables.</p>"},{"location":"working_with/adding_mediapipe/#command-line-options","title":"Command Line Options","text":"<pre><code>include(CMakeDependentOption)\n\noption(HT_ENABLE_GPU \"Whether to enable GPU based codes vs CPU based\" OFF)\noption(HT_ENABLE_GRAPH_PROFILER \"Whether to enable the graph profiler\" OFF)\ncmake_dependent_option(HT_ENABLE_WEB_PROFILING \"Whether to enable web profiling\" ON HT_ENABLE_GRAPH_PROFILER OFF)\n\nif(HT_ENABLE_GPU)\n    add_definitions(-DMEDIAPIPE_DISABLE_GPU=0)\nelse()\n    add_definitions(-DMEDIAPIPE_DISABLE_GPU=1)\nendif()\nadd_compile_options(-Wno-deprecated-declarations)\nif(HT_ENABLE_GRAPH_PROFILER)\n    add_definitions(-DMEDIAPIPE_PROFILER_AVAILABLE=1)\n    if(HT_ENABLE_WEB_PROFILING)\n        add_definitions(-DMEDIAPIPE_WEB_PROFILING_ENABLED=1)\n    endif()\nendif()\n</code></pre> <p>Here any command line options/flags are declared, and if needed, compile definitions are set.</p>"},{"location":"working_with/adding_mediapipe/#cmake_module_path","title":"CMAKE_MODULE_PATH","text":"<pre><code>set(CMAKE_MODULE_PATH\n    ${CMAKE_SOURCE_DIR}/cmake\n    ${CMAKE_MODULE_PATH}\n    ${CMAKE_INSTALL_PREFIX}/lib/cmake\n)\n</code></pre> <p>This section tells CMake where to look first for cmake files for external packages.</p>"},{"location":"working_with/adding_mediapipe/#dependencies","title":"Dependencies","text":"<pre><code>find_package(PkgConfig)\n\nif(ILLIXR_ROOT)\n    set(ILLIXR_HDR_PATH ${ILLIXR_ROOT} CACHE PATH \"Location of ILLIXR headers\")\n    #add_definitions(-DBUILD_ILLIXR)\nelse()\n    message(FATAL_ERROR \"ILLIXR_ROOT must be specified\")\nendif()\n\nset(protobuf_MODULE_COMPATIBLE ON)\nfind_package(ZLIB REQUIRED)\nfind_package(Protobuf 3.19 REQUIRED CONFIG)\npkg_check_modules(glog REQUIRED libglog)\npkg_check_modules(egl REQUIRED egl)\npkg_check_modules(glesv2 REQUIRED glesv2)\nfind_package(Eigen3 REQUIRED)\nfind_package(OpenCV 4 REQUIRED)\nset(ENABLE_OPENCV ON)\n\nset(PROTOBUF_DESCRIPTORS \"\" CACHE INTERNAL \"\")\npkg_check_modules(cpuinfo REQUIRED libcpuinfo)\n\nfind_package(tfl-XNNPACK REQUIRED CONFIG)\nfind_package(pthreadpool REQUIRED CONFIG)\nfind_package(tensorflow-lite REQUIRED CONFIG)\n\nif(tfl-XNNPACK_BINARY_DIR)\n    add_link_options(-L${tfl-XNNPACK_BINARY_DIR})\nendif()\n</code></pre> <p>Here we search for any dependencies.</p>"},{"location":"working_with/adding_mediapipe/#protobuf-helpers","title":"Protobuf Helpers","text":"<pre><code>include(mediapipe/protobuf.cmake)\ninclude(cmake/encoder.cmake)\n</code></pre> <p>The protobuf files from Mediapipe need some special processing. These files define functions which properly handle this.</p>"},{"location":"working_with/adding_mediapipe/#special-operations","title":"Special Operations","text":"<pre><code>file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor)\nforeach(ITEM ${PROTOBUF_DESCRIPTORS})\n    get_filename_component(_FILE ${ITEM} NAME_WE)\n    add_custom_target(${_FILE}_desc\n                      ALL\n                      COMMAND cat ${ITEM} &gt;&gt; ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin_temp\n                      DEPENDS encode_as_c_string ${ITEM}\n    )\n    list(APPEND FILE_DEPS ${_FILE}_desc)\nendforeach()\nadd_custom_target(move_temp_bin ALL\n                  COMMAND mv ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin_temp ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin\n                  DEPENDS ${FILE_DEPS}\n                  BYPRODUCTS ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin\n)\n\nadd_custom_target(encode_descriptor_sets ALL\n                  COMMAND ${CMAKE_COMMAND} -E env \"LD_LIBRARY_PATH=${CMAKE_INSTALL_PREFIX}/lib\" ${CMAKE_BINARY_DIR}/encode_as_c_string\n                  ${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin &gt; ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_proto_descriptors.inc\n                  DEPENDS encode_as_c_string move_temp_bin\n                  BYPRODUCTS ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_proto_descriptors.inc\n)\n\ninclude(cmake/message_util.cmake)\nadd_custom_target(make_message_type\n                  COMMAND message_type_util\n                  --input_path=${CMAKE_BINARY_DIR}/inference_calculator_proto_transitive-transitive-descriptor-set.proto.bin --root_type_macro_output_path=${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_options_lib_type_name.h\n                  DEPENDS message_type_util\n                  BYPRODUCTS ${CMAKE_BINARY_DIR}/mediapipe/calculators/tensor/inference_calculator_options_lib_type_name.h\n)\n</code></pre> <p>One of the steps required files to be concatenated together. This code replicates that functionality. See the protobuf.cmake section for more details.</p>"},{"location":"working_with/adding_mediapipe/#the-plugin-itself","title":"The Plugin Itself","text":"<pre><code>set(PLUGIN_NAME plugin.hand_tracking${ILLIXR_BUILD_SUFFIX})\nadd_library(${PLUGIN_NAME} SHARED plugin.cpp)\n\nadd_subdirectory(mediapipe)\n\ntarget_link_libraries(${PLUGIN_NAME} PUBLIC\n                      ${OpenCV_LIBRARIES}\n                      absl::base\n                      absl::flags_parse\n                      fmt\n)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE\n                           ${ILLIXR_HDR_PATH}\n                           ${OpenCV_INCLUDE_DIRS}\n                           ${CMAKE_BINARY_DIR}\n                           ${CMAKE_SOURCE_DIR}\n)\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> <p>The plugin itself is declared as a library. All the hand tracking code is inside the mediapipe subdirectory.</p>"},{"location":"working_with/adding_mediapipe/#adapting-the-tool-for-illixr","title":"Adapting the Tool for ILLIXR","text":"<p>Now that you have the code in place we will put together the build files needed.</p> <ol> <li>In the mediapipe directory create files called <code>CMakeLists.txt</code> and <code>protobuf.cmake</code></li> <li>In each subdirectory that contains source or header files (or whose subdirectories contain such files) create a    <code>build.cmake</code> file</li> <li>In each subdirectory that contains a protobuf file (or whose subdirectories contain such files) create a    <code>protobuf.cmake</code> file</li> </ol> <p>The <code>build.cmake</code> files will list all source files needed to build the tool, while the <code>protobuf.cmake</code> files will be used to process the protobuf files.</p>"},{"location":"working_with/adding_mediapipe/#protobufcmake-files","title":"protobuf.cmake Files","text":"<p>There are three types of <code>protobuf.cmake</code> files. The first are those in directories which contain protobuf files, while the second are those whose subdirectories contain protobuf files, and the third is a combination of the previous two types. For the second type, all the lines in the file will be including <code>protobuf.cmake</code> files from subdirectories. For example</p> <pre><code>include(${CMAKE_CURRENT_LIST_DIR}/core/protobuf.cmake)\n</code></pre> <p>For the first type, they will have an include file at the top, and then a function call for each protobuf file in the directory.</p> <pre><code>include(${CMAKE_SOURCE_DIR}/cmake/protoc_generate_obj.cmake)\n\nprotobuf_generate_obj(PROTO_PATH calculators/util OBJ_NAME annotation_overlay_calculator)\n</code></pre> <p>The <code>protobuf_generate_obj</code> function generates a CMake TARGET which can be used to link against when compiling the code. The signature for the function is:</p> <ul> <li>PROTO_PATH - the path to the protobuf file (not including the file name), relative to the mediapipe directory</li> <li>OBJ_NAME - the name of the protobuf file (without the extension)</li> <li>DESCRIPTORS - A flag that will append descriptor files to the master list in CACHE</li> </ul> <p>In the above example the CMake TARGET will be named calculators.util.annotation_overlay_calculator_proto. At the current time, there is no easy way to determine which protos need to have the DESCRIPTORS flag set. The easiest way may be to build the mediapipe tool with bazel and then search the build tree for files that end in <code>.proto.bin</code>. This will indicate which protos need to have the DESCRIPTORS flag set. These files will be treated specially in the main <code>CMakeLists.txt</code> for combining and processing.</p>"},{"location":"working_with/adding_mediapipe/#buildcmake-files","title":"build.cmake Files","text":"<p>Like the <code>protobuf.cmake</code> files, the <code>build.cmake</code> files also have three types, one for directories that only contain source/header files, one that contains only other directories, and one that is a combination of the previous two. For the second type, each of the lines of the file will be including other <code>build.cmake</code> files from subdirectories. For example</p> <pre><code>include(${CMAKE_CURRENT_LIST_DIR}/core/build.cmake)\n</code></pre> <p>For the first type the file will add all the source files in the directory to the main target.</p> <pre><code>set(UTIL_SOURCES\n    ${CMAKE_CURRENT_LIST_DIR}/annotation_overlay_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/association_norm_rect_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/collection_has_min_size_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/detection_letterbox_removal_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/detections_to_rects_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/detections_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/filter_collection_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/illixr_output_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/labels_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/landmark_letterbox_removal_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/landmark_projection_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/landmarks_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/local_file_contents_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/non_max_suppression_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/rect_to_render_data_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/rect_transformation_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/thresholding_calculator.cc\n    ${CMAKE_CURRENT_LIST_DIR}/world_landmark_projection_calculator.cc\n)\n\nset(UTIL_HEADERS\n    ${CMAKE_CURRENT_LIST_DIR}/association_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/collection_has_min_size_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/detections_to_rects_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/filter_collection_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/landmarks_to_render_data_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/illixr_output_calculator.h\n    ${CMAKE_CURRENT_LIST_DIR}/illixr_data.h\n)\n\ntarget_sources(${PLUGIN_NAME} PRIVATE\n               ${UTIL_SOURCES}\n               ${UTIL_HEADERS}\n)\n</code></pre>"},{"location":"working_with/adding_mediapipe/#handling-pbtxt-files","title":"Handling pbtxt Files","text":"<p>In the <code>graph</code> and <code>modules</code> directories the <code>build.cmake</code> files will call functions to compile the subgraph files into a binary format. The main input pbtxt file will need to be installed as a text file, it will be labeled <code>mediapipe_binary_graph</code> in the <code>BUILD</code> file. Some pbtxt files carry information about where tflite files are installed. These will need to be modified to contain the proper installed location, via <code>configure_file</code> calls in cmake.</p> <p><code>Pbtxt</code> files which have been labeled <code>mediapipe_simple_subgraph</code> in their respective <code>BUILD</code> files will need to be specially compiled. There is a function <code>make_proto_binary</code> in <code>cmake/make_pb_binary.cmake</code>. For each of these pbtxt files you should have a list of dependencies. The only ones we need now are the protobuf ones, as they need to be handled like libraries. Here is a sample code snippet from a <code>build.cmake</code> file.</p> <pre><code>include(${CMAKE_SOURCE_DIR}/cmake/make_pb_binary.cmake)\n\n# make a list of all protobuf dependencies for this pbtxt file \nset(HLLR_LIBRARIES\n    $&lt;TARGET_OBJECTS:calculators.internal.callback_packet_calculator_proto&gt;\n    $&lt;TARGET_OBJECTS:calculators.util.rect_transformation_calculator_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.calculator_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.calculator_options_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.calculator_profile_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.mediapipe_options_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.packet_factory_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.packet_generator_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.status_handler_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.stream_handler_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.thread_pool_executor_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.deps.proto_descriptor_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.formats.landmark_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.formats.rect_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.stream_handler.default_input_stream_handler_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.tool.calculator_graph_template_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.tool.field_data_proto&gt;\n    $&lt;TARGET_OBJECTS:framework.tool.packet_generator_wrapper_calculator_proto&gt;\n)\n\n# compile the pbtxt file\nmake_proto_binary(BINARY_NAME hand_landmark_landmarks_to_roi_graph_text_to_binary_graph\n                  FILE_ROOT modules/hand_landmark\n                  FILE_BASE_NAME hand_landmark_landmarks_to_roi\n                  CLASS_NAME HandLandmarkLandmarksToRoi\n                  PROTO_LIBRARIES ${HLLR_LIBRARIES}\n)\n</code></pre> <p>The inputs to <code>make_proto_binary</code> are</p> <ul> <li>BINARY_NAME: name of the binary to create</li> <li>FILE_ROOT: the path to the pbtxt file (relative to root directory)</li> <li>FILE_BASE_NAME: the name of the pbtxt file (no path, no suffix)</li> <li>CLASS_NAME: the name to register this as, this will be what is specified by the <code>register_as</code> key in the <code>BUILD</code>   file</li> <li>PROTO_LIBRARIES: the protobuf libraries to link against</li> </ul>"},{"location":"working_with/adding_mediapipe/#writing-your-plugin","title":"Writing Your Plugin","text":"<p>In this guide we will refer to the entire mediapipe code as the tool. The workflow of the tool is defined by graph files. The individual calculators communicate with each other via packets.</p>"},{"location":"working_with/adding_mediapipe/#understanding-graph-files","title":"Understanding Graph Files","text":"<p>The graph files (those with a pbtxt suffix) are the real drivers of the tool's workflow. They define what calculators are run in what order, and what their inputs and outputs are. In mediapipe, calculators are roughly equivalent to ILLIXR plugins. There are several levels of these graph files. The topmost one will be read as a text file by the tool's initializing code, and lives in mediapipe/graph/ and are usually small compared to others. They also will link to other graph files (also called calculators in this context). All the other pbtxt files will be compiled into the tool library. <p>Let's look at the hand tracking main graph file (hand_tracking_desktop_live.pbtxt) in snippets.</p> <pre><code># CPU image. (ImageFrame)\ninput_stream: \"input_video\"\ninput_stream: \"image_data\"\n# CPU image. (ImageFrame)\noutput_stream: \"illixr_data\"\n</code></pre> <p>The <code>input_stream</code> keyword defines what data will be sent to the tool as input. The <code>output_stream</code> keyword defines what data will be sent out of the tool. As far as I know, there is no limit on the number of each. The value of both of these keywords is a string value which names the stream, these streams will be referred to by these names in the C++ code. At this level, there is no typing of the data, just labelling the streams.</p> <pre><code>node {\n  calculator: \"HandLandmarkTrackingCpu\"\n  input_stream: \"IMAGE:input_video\"\n  input_side_packet: \"NUM_HANDS:num_hands\"\n  output_stream: \"LANDMARKS:landmarks\"\n  output_stream: \"HANDEDNESS:handedness\"\n  output_stream: \"PALM_DETECTIONS:multi_palm_detections\"\n  output_stream: \"HAND_ROIS_FROM_LANDMARKS:multi_hand_rects\"\n  output_stream: \"HAND_ROIS_FROM_PALM_DETECTIONS:multi_palm_rects\"\n}\n</code></pre> <p>The <code>node</code> defines a single calculator/subgraph. The name of the calculator/subgraph is defined in the <code>calculator</code> entry. This will match a class which has already bee compiled in the code (case-sensitive).</p> <p>As above, the <code>input_stream</code> and <code>output_stream</code> define the inputs and outputs to/from the calculator.</p> <p>Note</p> <p>The names of the streams are different from above. They have a format of <code>NAME:stream_name</code>. </p> <p>The first, all caps, name acts as a reference to the second name. When the streams are referenced in the C++ code, the name used will be the first (or as above, only name). Thus using the two name scheme allows you to change the actual stream (second name) in the graph files, without having to change the C++ code, which uses the first name reference.</p> <p>For a more complete guide on the graph file format see this guide. You can also visualize and error check graphs with this useful online tool</p>"},{"location":"working_with/adding_mediapipe/#sending-data-to-the-tool","title":"Sending Data To the Tool","text":"<p>Sending data to the tool is straight forward. Take the following code snippet as an example</p> <pre><code>auto img_ptr = absl::make_unique&lt;mediapipe::ImageData&gt;(image_data);\nauto img_status = _graph.AddPacketToInputStream(kImageDataTag,\n                                                mediapipe::Adopt(img_ptr.release()).At(\n                                                       mediapipe::Timestamp(frame_timestamp_us)));\n\nif (!img_status.ok())\n    throw std::runtime_error(std::string(img_status.message()));\n</code></pre> <p>The first line creates a unique pointer which wraps the data we want to send to the tool. The second line stages the packet to the graph with a call to <code>AddPacketToInputStream</code>. The first argument is the name of the stream to add the packet to (will be one of the names from the graph file), the second argument is the data being sent (it is fully adopted by the stream) along with the current timestamp. The last two lines check that there was no error in adding the packet, and throw an exception if there was.</p> <p>Note</p> <p>The timestamp values do not have to match any specific timing convention, but must increase with each call to add a packet to a specific stream. </p>"},{"location":"working_with/adding_mediapipe/#getting-data-from-the-tool","title":"Getting Data From the Tool","text":"<p>Getting the data from the tool is also straight forward. Take the following code snippet as an example</p> <pre><code>if (_poller-&gt;Next(&amp;_packet))\n    auto &amp;output_frame = _packet.Get&lt;mediapipe::ILLIXR::illixr_ht_frame&gt;();\n    ...\nelse\n    ...\n</code></pre> <p>The if statement checks to see if there is a packet available. The <code>Next</code> function returns a boolean (true if a packet is available), and puts the packet, if any, in the <code>_packet</code> variable. The following line extracts and casts the packet to the appropriate type. The following lines can use the data <code>output_frame</code> in this example, as needed.</p>"},{"location":"working_with/adding_mediapipe/#adding-a-calculator","title":"Adding a Calculator","text":"<p>In some instances you may want to manipulate the output stream from a tool to better suit your needs. The original version of the hand tracking tool only returned an image with the hand tracking results visually represented. For ILLIXR, we wanted to have the actual hand tracking data available (points on each hand, what hand(s) were detected, etc.). So a calculator was added to the end of the tool which gathered the relevant data together into a single structure. On of the other calculators was also modified so that the output image was transparent, so that the visual representation could be used as an overlay. Here we will look at how to create a new calculator from scratch.</p>"},{"location":"working_with/adding_mediapipe/#changing-graph-files","title":"Changing Graph Files","text":"<p>The first thing to do is to add a new <code>node</code> to the appropriate graph file. The name you give your calculator is case-sensitive and must match the calculator class name in your code. Be sure to add whatever input and output streams you will need.</p>"},{"location":"working_with/adding_mediapipe/#data-structures","title":"Data Structures","text":"<p>Since whatever data the tool originally produced did not meet your needs, you will need to create a new data type which encapsulates all that you want. This data structure will be the packet you get from the graph at the end, and does not need to be the same data that your plugin publishes to ILLIXR. The file for this should be put in <code>mediapipe/calculators/util</code>. The following file is for the hand tracking tool, in <code>illixr_data.h</code>.</p> <pre><code>#pragma once\n#include &lt;vector&gt;\n\n#include \"mediapipe/framework/port/opencv_core_inc.h\"\n#include \"illixr/hand_tracking_data.hpp\"\n\nnamespace mediapipe::ILLIXR {\nstruct illixr_ht_frame {\n    cv::Mat* image = nullptr;\n\n    size_t image_id;\n    ::ILLIXR::image::image_type type;\n    ::ILLIXR::rect* left_palm = nullptr;\n    ::ILLIXR::rect* right_palm = nullptr;\n    ::ILLIXR::rect* left_hand = nullptr;\n    ::ILLIXR::rect* right_hand = nullptr;\n\n    float left_confidence = 0.;\n    float right_confidence = 0.;\n    ::ILLIXR::hand_points* left_hand_points = nullptr;\n    ::ILLIXR::hand_points* right_hand_points = nullptr;\n\n    ~illixr_ht_frame() {\n        delete image;\n        delete left_palm;\n        delete right_palm;\n        delete left_hand;\n        delete right_hand;\n        delete left_hand_points;\n        delete right_hand_points;\n    }\n};\n}\n</code></pre> <p>It is just a <code>struct</code> that holds the needed data.</p> <p>If this struct will be different from what your plugin will publish to ILLIXR, you should also add a header to <code>include/illixr</code> in your ILLIXR code base which defines that data structure. One main reason for having two different data structures is if the one for the tool has members whose data type is only defined in the mediapipe code. We don't want any other part of ILLIXR to need to depend on these external data types, so defining one inside ILLIXR (even if it is nearly identical), will alleviate this issue.</p> <p>You will also need to add a protobuf file for defining the options used by your calculator. This guide won't go into the details of this, as it is likely that you will just need a basic one.</p> <pre><code>syntax = \"proto2\";\n\npackage mediapipe;\n\nimport \"mediapipe/framework/calculator.proto\";\n\nmessage MyCalculatorOptions {\n   extend CalculatorOptions {\n      optional MyCalculatorOptions ext = 123456789;\n   }\n}\n</code></pre> <p>The number after ext must be unique withing the tool. Just grep for <code>ext</code> in the proto files and look for the largest one and add something like 10 to get your number. This file will also go in <code>mediapipe/calculators/util</code>.</p>"},{"location":"working_with/adding_mediapipe/#calculator-code","title":"Calculator Code","text":"<p>Mediapipe calculators are class based objects that inherit from <code>CalculatorBase</code>. You should name your calculator something useful and put the header and code files in <code>mediapipe/calculators/util</code>. The code below is a minimum outline of what you will need.</p> <pre><code>#include \"mediapipe/framework/calculator_base.h\"\n\nclass MyCalulator : public CalculatorBase {\npublic:\n    MyCalculator() = default;\n    ~MyCalculator() override;\n\n    MyCalculator(const MyCalculator&amp;) = delete;\n    MyCalculator&amp; operator=(const MyCalculator&amp;) = delete;\n\n    static absl::Status GetContract(CalculatorContract* cc);\n    absl::Status Open(CalculatorContext* cc) override;\n    absl::Status Process(CalculatorContext* cc) override;\nprotected:\n    ::mediapipe::MyCalculatorOptions options_;\n};\n</code></pre> <p>You can add any additional functions and data members you need. The sections below will cover the three required functions.</p>"},{"location":"working_with/adding_mediapipe/#common-function-calls","title":"Common Function Calls","text":"<p>There are several functions that are used multiple times throughout a calculator. These deal with checking inputs and outputs, getting input streams, publishing to output streams, and setting data types for these streams. In each of the snippets below <code>cc</code> refers to either a <code>CalculatorContract</code> or <code>CalculatorContext</code>, which for these functions we can treat as identical.</p> <pre><code>constexpr char kInputTag[] = \"INPUT_TAG\";\n\ncc-&gt;Inputs().HasTag(kInputTag);\n\n\ncc-&gt;Outputs().HasTag(kInputTag);\n</code></pre> <p>This code checks that the input stream named \"INPUT_TAG\" (in the graph), is being supplied by the graph. This allows for a calculator to be fed different input streams. The function <code>HasTag</code> returns a boolean, and is often used in <code>if</code> statements. There is also a similar call for checking output streams.</p> <pre><code>cc-&gt;Inputs().Tag(kInputTag).Set&lt;std::vector&lt;Points&gt; &gt;();\n\n\ncc-&gt;Ouputs().Tag(kInputTag).Set&lt;std::vector&lt;Points&gt; &gt;();\n</code></pre> <p>This code sets the expected data type for the given tag. This call should be after a <code>HasTag</code> call to ensure that the input stream is available first.</p> <pre><code>img_data_ = cc-&gt;Inputs().Tag(kInputTag).Get&lt;std::vector&lt;Points&gt; &gt;();\n</code></pre> <p>This code will retrieve the current data from the specified stream. This code also specifies the data type, and should only be made after a call to <code>Set</code>.</p> <pre><code>cc-&gt;Outputs().Tag(kInputTag).Add(frame_data.release(), cc-&gt;InputTimestamp());\n</code></pre> <p>This code adds the given data to the specified stream, along with the timestamp. This should only be called after a call to <code>Set</code>.</p> <p>Many mediapipe functions return an object of type <code>absl::Status</code>. This type of object encapsulates the status of the function call, along with any error information.</p> <pre><code>absl::Status stat = myfunc();\n\nif(!stat.ok())   // returns a boolean: true = success\n    throw std::runtime_error(std::string(stat.message()));  // throws an exception with the contents of any error messages\n</code></pre>"},{"location":"working_with/adding_mediapipe/#getcontract","title":"GetContract","text":"<p>Calculator authors can specify the expected types of inputs and outputs of a calculator in GetContract(). When a graph is initialized, the framework calls a static method to verify if the packet types of the connected inputs and outputs match the information in this specification. source</p> <p>Function calls like the following are common here.</p> <pre><code>// See which input stream is being supplied by the graph\nif (cc-&gt;Inputs().HasTag(kImageFrameTag)) {\n    cc-&gt;Inputs().Tag(kImageFrameTag).Set&lt;ImageFrame&gt;();\n} else if (cc-&gt;Inputs().HasTag(kImageTag)) {\n    cc-&gt;Inputs().Tag(kImageTag).Set&lt;mediapipe::Image&gt;();\n}\n\n\n// Ensure that only one of these streams is available\nRET_CHECK(cc-&gt;Inputs().HasTag(kNormPalmRectTag) +\n          cc-&gt;Inputs().HasTag(kRectPalmTag) +\n          cc-&gt;Inputs().HasTag(kNormPalmRectsTag) +\n          cc-&gt;Inputs().HasTag(kRectsPalmTag) &lt;=\n          1);\n</code></pre>"},{"location":"working_with/adding_mediapipe/#open","title":"Open","text":"<p>After a graph starts, the framework calls Open(). The input side packets are available to the calculator at this point. Open() interprets the node configuration operations (see Graphs) and prepares the calculator's per-graph-run state. This function may also write packets to calculator outputs. An error during Open() can terminate the graph run. source</p>"},{"location":"working_with/adding_mediapipe/#process","title":"Process","text":"<p>For a calculator with inputs, the framework calls Process() repeatedly whenever at least one input stream has a packet available. The framework by default guarantees that all inputs have the same timestamp (see Synchronization for more information). Multiple Process() calls can be invoked simultaneously when parallel execution is enabled. If an error occurs during Process(), the framework calls Close() and the graph run terminates. source</p> <p>This is where the bulk of the calculator's work is done. Inputs are read, calculations are done, and the results are added to the output streams.</p>"},{"location":"working_with/adding_mediapipe/#close","title":"Close","text":"<p>After all calls to Process() finish or when all input streams close, the framework calls Close(). This function is always called if Open() was called and succeeded and even if the graph run terminated because of an error. No inputs are available via any input streams during Close(), but it still has access to input side packets and therefore may write outputs. After Close() returns, the calculator should be considered a dead node. The calculator object is destroyed as soon as the graph finishes running. source</p> <p>In general, the default version of this function will suffice, and there is little need to implement an overloaded version.</p>"},{"location":"working_with/adding_mediapipe/#pluginhpp","title":"plugin.hpp","text":"<p>The actual plugin should be split into two files, to aid in readability, a header and the code itself. The plugin should follow the general guidelines. Due to the way the mediapipe graphs work you may find it necessary to create two plugins: one for sending the input to the graph, and one to get the results once the graph has run. To aid in understanding, we will refer to the plugin that sends the input to the graph as Input and the other as Publish. In this instance both plugins can be defined in the same header and code files. There are other plugins that use this style as well, which you can use for reference (zed, and hand_tracking).</p> <p>In the two plugin case Input can inherit from plugin or threadloop, depending on your needs. However, Publish should inherit from threadloop. Below is some stub code for the headers.</p> <pre><code>class MyPublisher : public threadloop {\npublic:\n    MyPublisher(const std::string&amp; name_, phonebook* pb_);\n    ~MyPublisher() override;\n\n    void set_poller(mediapipe::OutputStreamPoller* plr) {_poller = plr;}\n    void stop() override;\nprotected:\n    skip_option _p_should_skip() override;\n    void _p_one_iterarion() override;\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; _switchboard;\n    switchboard::writer&lt;my_data&gt;       _my_publisher;\n    mediapipe::OutputStreamPoller*     _poller = nullptr;\n    mediapipe::Packet                  _packet;\n};\n\nclass MyInput : public plugin {\npublic:\n    MyInput(const std::string&amp; name_, phonebook* pb_);\n    ~MyInput() override;\n\n    void start() override;\n    void process(const switchboard::ptr&lt;data_type&gt;&amp; frame);  // this is the function that is called when an result from the graph is available \n    void stop() override;\nprivate:\n    const std::shared_ptr&lt;switchbaord&gt; _switchboard;\n    mediapipe::CalculatorGraph _graph;\n    MyPublisher _publisher;    // this plugin will control the publisher\n};\n</code></pre>"},{"location":"working_with/adding_mediapipe/#plugincpp","title":"plugin.cpp","text":"<p>Here we will go through the basic code needed to interface with the graph, based on the header code from above. At the top you should define the streams that the plugin will send and receive from. These names must match those in the graph file.</p> <pre><code>constexpr char kInputStream[] = \"input_video\";     // stream the Input will write to\nconstexpr char kImageDataTag[] = \"image_data\";     // stream the Input will write to\nconstexpr char kOutputStream[] = \"illixr_data\";    // stream the Publish will read from\n</code></pre>"},{"location":"working_with/adding_mediapipe/#input","title":"Input","text":"<p>The constructor should initialize the normal plugin stuff as well as the graph and Publish class.</p> <pre><code>MyInput::MyInput(const std::string&amp; name_, phonebook* pb_) \n        : plugin{name_, pb_}\n        , _switchbaord{pb_-&gt;lookup_impl&lt;switchboard&gt;()}\n        , _graph{mediapipe::CalculatorGraph()}\n        , _publisher{\"my_publisher\", pb_} {\n    &lt;any other code you need&gt;\n}\n</code></pre> <p>The <code>start</code> function should configure the graph, and start the PUBLISH plugin.</p> <pre><code>void MyInput::start() {\n    // start the plugin\n    plugin::start();\n    // read the environment variable which holds the graph configuration file name\n    const std::string calculator_graph_config_contents =\n#include \"mediapipe/hand_tracking_desktop_live.pbtxt\"\n            ;  // NOLINT(whitespace/semicolon)\n    auto config = mediapipe::ParseTextProtoOrDie&lt;mediapipe::CalculatorGraphConfig&gt;(calculator_graph_config_contents);\n    absl::Status status;\n    // initialize the graph\n    status = _graph.Initialize(config);\n    if (!status.ok())\n        throw std::runtime_error(std::string(status.message()));\n\n    // get a poller for the output stream\n    auto status_or_poller = _graph.AddOutputStreamPoller(kOutputStream);\n    if (!status_or_poller.ok())\n        throw std::runtime_error(\"Error with output poller\");\n    // pass the poller to the publisher\n    _publisher.set_poller(new mediapipe::OutputStreamPoller(std::move(status_or_poller).value()));\n\n    // start the graph\n    status = _graph.StartRun({});\n    if (!status.ok())\n        throw std::runtime_error(\"Error starting graph\");}\n\n    // register  the process funtion to be called any time there is input from ILLIXR to be added to the graph stream\n    //  here \"data_type\" is the type of data expected from ILLIXR and \"input_name\" is the registered name of the topic (data source) \n    _switchboard-&gt;schedule&lt;data type&gt;(id, \"input_name\",\n                                      [this](const switchboard::ptr&lt;const&lt;data_type&gt; &amp;inp, std::size_t) {\n                                             this-&gt;process(inp);\n                                      });\n\n    // start the publisher thread\n    _publisher.start();\n</code></pre> <p>Note the way <code>calculator_graph_config_contents</code> is constructed. This takes the needed config file, which in mediapipe was specified as an environment variable, and changes it to be hard coded, as the plugin will have a specific purpose, it should not need to change. To be sure the included file is properly specified, the following will need to be done.</p> <ol> <li>edit the original config file to escape all existing quotation marks    <pre><code>input_stream: \"image_data\"\n</code></pre></li> </ol> <p>becomes</p> <p><pre><code>input_stream: \\\"image_data\\\"\n</code></pre> 2. edit the original config file to enclose every line in quotation marks, adding a newline character to the end    <pre><code># mediapipe/examples/desktop/hand_tracking:hand_tracking_cpu.\n\n# CPU image. (ImageFrame)\ninput_stream: \\\"input_video\\\"\ninput_stream: \\\"image_data\\\"\n# CPU image. (ImageFrame)\noutput_stream: \\\"illixr_data\\\"\n</code></pre></p> <p>becomes</p> <p><pre><code>\"# mediapipe/examples/desktop/hand_tracking:hand_tracking_cpu.\\n\"\n\"\\n\"\n\"# CPU image. (ImageFrame)\\n\"\n\"input_stream: \\\"input_video\\\"\\n\"\n\"input_stream: \\\"image_data\\\"\\n\"\n\"# CPU image. (ImageFrame)\\n\"\n\"output_stream: \\\"illixr_data\\\"\\n\"\n\"\\n\"\n</code></pre> 3. modify the <code>mediapipe/graphs/&lt;pipeline&gt;/build.cmake</code> to copy the file to the build directory    <pre><code>file(COPY ${CMAKE_CURRENT_LIST_DIR}/hand_tracking_desktop_live.pbtxt\n     DESTINATION ${CMAKE_BINARY_DIR}/mediapipe\n)\n</code></pre></p> <p>The <code>stop</code> function should also stop the publisher thread.</p> <pre><code>void MyInput::stop() {\n    // Close any open mediapipe::CalculatorGraph instances\n    // with CloseAllPacketSources();\n    // and delete if necessary\n    _publisher.stop();\n    plugin::stop();\n}\n</code></pre> <p>The <code>process</code> function will be called by the <code>switchboard</code> any time data of the expected type <code>data type</code> from topic <code>input_name</code> is available.</p> <pre><code>void MyInput::process(const switchboard::ptr&lt;const data_type&gt;&amp; frame) {\n    // read from the input and do whatever is needed to convert it to the input type for the graph\n    // in this example we are assuming that it can be simply converted\n    auto in_data = mediapipe_data_type(frame);\n\n    // generate a timestamp for the mediapipe packet\n    size_t frame_timestamp_us = std::chrono::high_resolution_clock::now().time_since_epoch().count() / 1000;\n    // wrap the data in a unique pointer\n    auto data_ptr = absl::make_unique&lt;mediapipe_data_type&gt;(in_data);\n    // add the data to the input stream of the graph\n    auto stat = _graph.AddPacketToInputStream(kOutputStream,\n                                              mediapipe::Adopt(img_ptr.release()).At(\n                                                  mediapipe::Timestamp(frame_timestamp_us)));\n    // raise an exception if something went wrong\n    if (!stat.ok())\n        throw std::runtime_error(std::string(stat.message()));\n}\n</code></pre>"},{"location":"working_with/adding_mediapipe/#publisher","title":"Publisher","text":"<p>The Publish constructor should initialize the writer which is used to put data into ILLIXR.</p> <pre><code>MyPublisher::MyPublisher(const std::string&amp; name_ phonebook* pb_)\n        : threadloop{name_, pb_}\n        , _switchboard{pb_-&gt;lookup_impl&lt;switchboard&gt;()}\n        , _my_publisher{_switchboard-&gt;get_writer&lt;my_data&gt;(\"data\")} {}\n</code></pre> <p>Here <code>my_data</code> is the data type being written out and <code>data</code> is the name of the topic doing the writing.</p> <p>The stop function should clean up any poller instances</p> <pre><code>void MyPublisher::stop() {\n    delete _poller;\n    _poller = nullptr;\n}\n</code></pre> <p>The destructor should at least get rid of the poller.</p> <pre><code>MyPublisher::~MyPublisher() {\n    delete _poller;  // ok to delete even if nullptr\n}\n</code></pre> <p>We use the <code>_p_should_skip</code> to see if there is an output packet from the graph.</p> <pre><code>skip_option MyPublisher::_p_should_skip() {\n    // check to see if there is a new packet, and if so put it in the class variable and signal that _p_one_iteration should be run\n    if (_poller-&gt;Next(&amp;_packet))\n        return threadloop::skip_option::run;\n    return threadloop::skip_option::skip_and_spin;   // no new packet\n}\n</code></pre> <p>The <code>_p_one_iteration</code> function will be called every time <code>_p_should_skip</code> returns <code>run</code>. This function will get the output packet from the graph, manipulate the data if necessary, and write the results to ILLIXR.</p> <pre><code>void MyPublisher::_p_one_iterarion() {\n    // get the graph output\n    auto &amp;new_data = _packet.Get&lt;mediapipe_output&gt;();\n\n    // manipulate the data\n    // in this example we are assuming the data can be converted via constructor\n\n    // write the data to ILLIXR\n    _my_publisher.put(_my_publisher.allocate&lt;my_data&gt;(my_data{new_data}));\n}\n</code></pre> <p>That is the basic code for what is needed to connect ILLIXR to a mediapipe tool.</p>"},{"location":"working_with/adding_mediapipe/#cmakeliststxt","title":"CMakeLists.txt","text":"<p>Now we will bring it all together in the <code>CMakeLists.txt</code> file in the mediapipe directory. This file will generate a list of all source files and protobuf targets needed to compile the mediapipe part of the plugin. This file is called by <code>add_subdirectory</code> from the main <code>CMakeLists.txt</code> file. The first section of this file will list all the protobuf targets we need (those we generated via <code>protobuf_generate_obj</code> in <code>protobuf.cmake</code> files).</p> <pre><code>target_sources(${PLUGIN_NAME} PUBLIC\n               # list every protobuf target, one on each line\n               $&lt;TARGET_OBJECTS:calculators.util.annotation_overlay_calculator_proto&gt;\n               .\n               .\n               .\n)\n</code></pre> <p>Next we add targets that were generated by turning graph files into binary.</p> <pre><code>target_sources(${PLUGIN_NAME} PUBLIC\n               $&lt;TARGET_OBJECTS:hand_renderer_cpu_linked&gt;\n               .\n               .\n               .\n)\n</code></pre> <p>Next <code>include</code> each of the subdirectories.</p> <pre><code>include(${CMAKE_CURRENT_LIST_DIR}/calculators/build.cmake)\ninclude(${CMAKE_CURRENT_LIST_DIR}/framework/build.cmake)\n.\n.\n.\n</code></pre> <p>Next add any include directories. In case there are multiple versions of protobuf on the system, we want to make sure that the correct one is picked up by the compiler, so we prepend it to the includes.</p> <pre><code>target_include_directories(${PLUGIN_NAME} BEFORE PUBLIC ${Protobuf_INCLUDE_DIRS})\ntarget_include_directories(${PLUGIN_NAME} PUBLIC\n                           ${CMAKE_BINARY_DIR}  # picks up protobuf generated headers\n                           ${CMAKE_SOURCE_DIR}  # picks up any normal mediapipe headers\n                           .                    # any other includes\n                           .\n                           .\n                           ${CMAKE_INSTALL_PREFIX}/include  # any headers installed by ILLIXR\n)\n</code></pre> <p>Lastly, add the libraries to link against.</p> <pre><code>target_link_libraries(${PLUGIN_NAME} PUBLIC\n                      protobuf::libprotobuf\n                      absl::base            # there will likely be a lot of absl libraries\n                      .\n                      .\n                      .\n)\n</code></pre>"},{"location":"working_with/debugging_illixr/","title":"ILLIXR Debugging Tips","text":""},{"location":"working_with/debugging_illixr/#debugging-locally","title":"Debugging Locally","text":"<p>The config described in Getting Started supports running the runtime with arbitrary commands like <code>gdb</code>. When debugging locally, we recommend using either <code>gdb</code> or <code>valgrind</code> in this way. You can use the <code>ENABLE_PRE_SLEEP</code> environment variable or <code>enable_pre_sleep</code> command line argument to set a sleep time before ILLIXR fully starts. This gives you time to attach a debugger.</p>"},{"location":"working_with/display_backend/","title":"Display Backends","text":"<p>ILLIXR supports multiple display backends for rendering output. Each backend is designed for different use cases and can be configured through environment variables.</p>"},{"location":"working_with/display_backend/#available-display-backends","title":"Available Display Backends","text":"<p>ILLIXR supports three display backends:</p> <ol> <li> <p>GLFW (Default)</p> <ul> <li>Standard windowed display using GLFW</li> <li>Best for desktop development and debugging</li> <li>Provides a resizable window interface</li> </ul> </li> <li> <p>X11 Direct Mode</p> <ul> <li>Direct display mode using X11</li> <li>Provides lower latency by bypassing the window manager</li> <li>Useful for tethered headsets directly connected to the GPU using DisplayPort or HDMI</li> </ul> </li> <li> <p>Headless</p> <ul> <li>No display output</li> <li>Useful for testing and benchmarking</li> <li>Can be used in environments without display hardware</li> </ul> </li> </ol>"},{"location":"working_with/display_backend/#configuration","title":"Configuration","text":"<p>The display backend and its behavior can be configured using the following environment variables:</p>"},{"location":"working_with/display_backend/#illixr_display_mode","title":"ILLIXR_DISPLAY_MODE","text":"<p>Controls which display backend to use.</p> <p>Possible values:</p> <ul> <li><code>glfw</code> (Default) - Use GLFW windowed mode</li> <li><code>x11_direct</code> - Use X11 direct mode</li> <li><code>headless</code> - Use headless mode</li> </ul> <p>Example:</p> <pre><code>export ILLIXR_DISPLAY_MODE=glfw\n</code></pre>"},{"location":"working_with/display_backend/#illixr_vulkan_select_gpu","title":"ILLIXR_VULKAN_SELECT_GPU","text":"<p>Allows manual selection of the GPU device when multiple are available. By default, the first available GPU is used. No need to set this if you only have one GPU.</p> <ul> <li>Value: Integer index of the GPU for Vulkan to use (0-based)</li> <li>Default: -1 (automatic selection of first suitable device)</li> </ul> <p>The available GPUs and their indices will be printed during startup.</p> <p>Example:</p> <pre><code>export ILLIXR_VULKAN_SELECT_GPU=1 # Select the second GPU\n</code></pre>"},{"location":"working_with/display_backend/#illixr_direct_mode_display","title":"ILLIXR_DIRECT_MODE_DISPLAY","text":"<p>Required when using X11 direct mode (<code>ILLIXR_DISPLAY_MODE=x11_direct</code>). Specifies which display to use. No need to set this if you only have one display output connected to the GPU.</p> <p>Note</p> <p>Currently, this backend is only tested with NVIDIA GPUs.</p> <ul> <li>Value: Integer index of the display to use (0-based)</li> <li>Must be set when using X11 direct mode</li> <li>Available displays and their indices will be printed during startup</li> </ul> <p>Example:</p> <pre><code>export ILLIXR_DIRECT_MODE_DISPLAY=0  # Use the first display\n</code></pre>"},{"location":"working_with/display_backend/#display-selection-process","title":"Display Selection Process","text":"<ol> <li>The system will enumerate available displays and GPUs during startup</li> <li> <p>For GPU selection:</p> <ul> <li>If <code>ILLIXR_VULKAN_SELECT_GPU</code> is not set, the first suitable GPU is selected</li> <li>If set, the specified GPU index is used</li> <li>The system will print available GPUs and their capabilities</li> </ul> </li> <li> <p>For X11 direct mode:</p> <ul> <li>The system will list available displays</li> <li><code>ILLIXR_DIRECT_MODE_DISPLAY</code> must be set to a valid display index</li> <li>The selected display will be acquired for direct mode access</li> <li>The highest refresh rate mode will be automatically selected</li> </ul> </li> </ol>"},{"location":"working_with/external_switchboard_and_phonebook/","title":"Using Switchboard and Phonebook Externally","text":"<p>Switchboard was designed as a self-contained entity from ILLIXR that one can reuse in other projects. The relevant API is here for Switchboard and here for Phonebook.</p> <p>One simply needs to copy these files, maintaining directory structure.</p> <pre><code>illixr/switchboard.hpp\nillixr/phonebook.hpp\nillixr/record_logger.hpp\nillixr/managed_thread.hpp\nillixr/concurrentqueue/blockingconcurrentqueue.hpp\nillixr/concurrentqueue/concurrentqueue.hpp\nillixr/concurrentqueue/lightweightsemaphore.hpp\n</code></pre> <p>This will serve as our <code>main.cpp</code>:</p> <pre><code>#include &lt;iostream&gt;\n#include \"illixr/switchboard.hpp\"\n\nclass service : public ILLIXR::phonebook::service {\npublic:\n    void act() { std::cout &lt;&lt; \"Hello from service\\n\"; };\n};\n\nclass data : public ILLIXR::switchboard::event {\npublic:\n    data(size_t id_) : id{id_} { }\n    size_t id;\n};\n\nint main() {\n    ILLIXR::phonebook main_pb;\n    main_pb.register_impl&lt;service&gt;(std::make_shared&lt;service&gt;());\n    main_pb.lookup_impl&lt;service&gt;()-&gt;act();\n\n    // From docs of Switchboard: if first arg is null, logging is disabled.\n    // Logging should be disabled if we are running externally.\n    ILLIXR::switchboard main_sb {nullptr};\n    auto writer = main_sb.get_writer&lt;data&gt;(\"topic\");\n    auto reader = main_sb.get_reader&lt;data&gt;(\"topic\");\n    writer.put(writer.allocate&lt;data&gt;(42));\n    std::cout &lt;&lt; \"The answer to life... is \" &lt;&lt; reader.get_ro()-&gt;id &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Switchboard and Phonebook will only work with compilers that support C++17 or better.</p> <p>For example:</p> <pre><code># Must copy with directory structure\nmkdir -p illixr/concurrentqueue\ncp path/to/ILLIXR/illixr/switchboard.hpp illixr\ncp path/to/ILLIXR/illixr/phonebook.hpp illixr\ncp path/to/ILLIXR/illixr/record_logger.hpp illixr\ncp path/to/ILLIXR/illixr/managed_thread.hpp illixr\ncp path/to/ILLIXR/illixr/concurrentqueue/blockingconcurrentqueue.hpp illixr/concurrentqueue/blockingconcurrentqueue.hpp\ncp path/to/ILLIXR/illixr/concurrentqueue/concurrentqueue.hpp illixr/concurrentqueue/concurrentqueue.hpp\ncp path/to/ILLIXR/illixr/concurrentqueue/lightweightsemaphore.hpp illixr/concurrentqueue/lightweightsemaphore.hpp\nemacs main.cpp # copy and paste from this doc\n\n# This will *probbaly* work with any C++-17 compatible compiler, but I've tested with clang-10.\n# Nix is my preferred package manager, but you can use whichever you like.\n# This command will not affect system packages, just create a temporary environment with the right clang.\nnix-shell -p clang_10\n\n# Compile\nclang++ -Wextra -pthread -std=c++17 main.cpp\n\n# Run\n./a.out\n</code></pre> <p>The output is:</p> <pre><code>Register 7service\nHello from service\nCreating: topic for 4data\nThe answer to life... is 42\n</code></pre>"},{"location":"working_with/logging_and_metrics/","title":"Logging and Metrics","text":"<p>The ILLIXR project supports several ways for an ILLIXR application to log and report details about its execution.</p>"},{"location":"working_with/logging_and_metrics/#logging","title":"Logging","text":"<p>ILLIXR uses the spdlog library for logging. Logging goes to both <code>STDOUT</code> and one or more log files in <code>$ILLIXR_ROOT/logs/</code></p> <p>Available levels, from low to high are: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>critical</code>, <code>off</code>.</p> <p>If <code>NDEBUG</code> is not defined, then the default logging level is <code>warn</code>, otherwise it is <code>debug</code>.</p> <p>Logging is activated by exporting environment variables to a particular level before running ILLIXR. These take the form of <code>&lt;PLUGIN_NAME&gt;_LOG_LEVEL</code>, e.g.,</p> <pre><code># Activate logging for both the ground_truth_slam plugin and the ILLIXR app\n# Each will log to the console, with color (actual colors dependent on the terminal settings)\n# Each log will write to $ILLIXR_ROOT/logs/&lt;plugin_name&gt;.log\n# Each log can have a different level.\n\nexport GROUND_TRUTH_SLAM_LOG_LEVEL=debug\nexport ILLIXR_LOG_LEVEL=warn\n\nmain.dbg.exe -yaml=profiles/native_gl.yaml\n</code></pre> <p>When writing a new plugin, the <code>plugin.spdlogger(std::string log_level)</code> method should be called, e.g., using <code>switchboard-&gt;get_env(\"&lt;PLUGIN_NAME&gt;_LOG_LEVEL\")</code> This creates a logger with two sinks (console and file). This logger is then registered in the global spdlog registry.</p> <p>To log inside a plugin method, use the plugin's name attribute to get the particular logger from the registry and call the desired log level method, e.g.</p> <pre><code>spdlog::get(name)-&gt;info(\"informative message\");\n</code></pre> <p>Outside the plugin class hierarchy, one can use the global ILLIXR logger which is registered under \"illixr\", e.g., <code>spdlog::get(\"illixr\")</code>. It will look for <code>$ILLIXR_LOG_LEVEL</code> in the environment or use <code>warn</code> by default. This usage requires explicitly adding the name of the component or file to the output message, if desired.</p> <p>Log files are appended. To merge to a single log do <code>$ cat *log | sort &gt; combined.log</code> This will sort correctly because the entries start with an ISO-8601 timestamp. For this reason, if a plugin uses <code>spdlog::set_pattern()</code> to create a custom log pattern, it is highly recommended that the custom pattern start with an ISO-8601 timestamp and it is required to reset to the default log message pattern after use.</p>"},{"location":"working_with/logging_and_metrics/#note-about-ifndef-ndebugendif-blocks","title":"Note about #ifndef NDEBUG/#endif blocks","text":"<p>Many of the plugins contain their logging statements inside of blocks which are only active when doing a debug build. This is a historical artifact. New plugins should carefully consider the difference between logging a debug message and conditionally compiling blocks of code based on build type.</p>"},{"location":"working_with/logging_and_metrics/#metrics","title":"Metrics","text":"<p>ILLIXR allows users to generate higher order statistics from logged results called Metrics.</p>"},{"location":"working_with/modifying_a_plugin/","title":"Modifying a plugin","text":""},{"location":"working_with/modifying_a_plugin/#tutorial","title":"Tutorial","text":"<p>This is how you can modify an existing ILLIXR plugin. This example uses the Audio Pipeline plugin, but the steps can be applied to any plugin.</p> <ol> <li> <p>Fork the repository for the component you want to modify into your own repo using the GitHub     web interface, then pull your repo to your computer. For example, using the Audio Pipeline plugin:</p> <pre><code>git clone https://github.com/&lt;YOUR_USER_NAME&gt;/audio_pipeline.git\n</code></pre> </li> <li> <p>Modify the associated <code>cmake/GetAudioPipeline.cmake</code>     original</p> <pre><code>get_external(PortAudio)\nget_external(SpatialAudio)\n\nset(AUDIO_PIPELINE_CMAKE_ARGS \"\")\nExternalProject_Add(Audio_Pipeline\n                    GIT_REPOSITORY https://github.com/ILLIXR/audio_pipeline.git\n                    GIT_TAG 714c3541378ece7b481804e4a504e23b49c2bdbe\n                    PREFIX ${CMAKE_BINARY_DIR}/_deps/audio_pipeline\n                    DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR}\n                    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS}\n)\n</code></pre> <p>which becomes <code>cmake/GetMyAudioPipeline.cmake</code></p> <pre><code>get_external(PortAudio)\nget_external(SpatialAudio)\n\nset(AUDIO_PIPELINE_CMAKE_ARGS \"\")\nExternalProject_Add(Audio_Pipeline\n                    GIT_REPOSITORY https://github.com/&lt;YOUR_USER_NAME&gt;/audio_pipeline.git\n                    PREFIX ${CMAKE_BINARY_DIR}/_deps/myaudio_pipeline\n                    DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR}\n                    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS}\n)\n</code></pre> </li> <li> <p>Make whatever changes to the plugin code you want and be sure to push them to your forked repo.</p> </li> <li> <p>See the instructions on Getting Started to learn how to build and run ILLIXR.</p> </li> <li> <p>To push the modification to upstream ILLIXR, create a PR to the original repository.</p> </li> </ol>"},{"location":"working_with/modules/","title":"Modules","text":""},{"location":"working_with/modules/#modulesjson-documentation","title":"modules.json Documentation","text":"<p>The modules.json file contains information necessary to generate lists of 3rd party dependencies for each plugin. This list is used by the getting_started page to produce yum/dnf/apt command lines for the user to cut and paste to install any necessary dependencies.</p> <p>There are three primary entries in the file:</p> <ul> <li>systems - supported operating systems</li> <li>plugins - listing of plugins and their dependencies</li> <li>dependencies - listing of 3rd party dependencies and OS specific install information</li> </ul>"},{"location":"working_with/modules/#systems","title":"Systems","text":"<p>The systems section lists each supported operating system and the supported versions in the following format:</p> <pre><code>{\n  \"name\": \"&lt;OS NAME&gt;\",          # the name of the operating system (e.g. Ubuntu, Fedora, etc.)\n  \"versions\": [\"&lt;V1&gt;\", \"&lt;V2&gt;\"]  # json array containing the supported version(s) (e.g. 22, 9, 37)\n}\n</code></pre>"},{"location":"working_with/modules/#plugins","title":"Plugins","text":"<p>The plugins section lists each plugin and any 3rd party dependencies (packages) in the following format:</p> <pre><code>{\n  \"name\": \"&lt;plugin_name\"&gt;,               # name of the plugin (same as the name of the plugin subdirectory\n  \"cmake_flag\": \"USE_&lt;PLUGIN_NAME&gt;=ON\",  # name of the plugin in all caps\n  \"dependencies\": [\"&lt;d1&gt;\", \"&lt;d2&gt;\"]       # json array listing the dependency names, which must match the name in the dependencies section\n}\n</code></pre>"},{"location":"working_with/modules/#dependencies","title":"Dependencies","text":"<p>The dependencies section lists every possible ILLIXR dependency along with how to install each on the different supported operating systems. The entries are in the following format and assumes the supported operating systems as of March 2025:</p> <pre><code>{\n  \"&lt;dependency&gt;\": {      # the name of the dependency, must match any uses in the plugins section\n    \"pkg\": {\n      \"Ubuntu\": {\n        \"pkg\": \"&lt;package name&gt;\",  # the name of the apt package(s) to install to get this dependency, can be a space seperated list, leave as an empty string if this OS does not supply it\n        \"postnotes\": \"\",          # for any post-installation instructions to properly configure things\n        \"notes\": \"\"               # for any installation notes or instructions, specifically if the package needs to be manually installed\n      },\n      \"Fedora\": {\n        \"pkg\": \"&lt;package name&gt;\",  # the name of the dnf package(s) to install to get this dependency, can be a space seperated list, leave as an empty string if this OS does not supply it\n        \"postnotes\": \"\",          # for any post-installation instructions to properly configure things\n        \"notes\": \"\"               # for any installation notes or instructions, specifically if the package needs to be manually installed\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"working_with/updating_tags_and_docs/","title":"Updating Tags and Documentation","text":""},{"location":"working_with/updating_tags_and_docs/#updating-tags","title":"Updating Tags","text":"<p>For releases, perform these steps from <code>master</code> once the desired features have been merged in.</p> <ol> <li> <p>Get latest tags:</p> <pre><code>git pull --tags -f\n</code></pre> </li> <li> <p>Tag your branch. Please use semantic versioning to name the tag; i.e., <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>:</p> <pre><code>git tag -f &lt;tag-name&gt; ## `-f` is required if updating an existing tag\n</code></pre> </li> <li> <p>Push your tag upstream:</p> <p><code>{ .bash .copy }</code> git push origin --tags ```</p> </li> </ol>"},{"location":"working_with/updating_tags_and_docs/#updating-documentation","title":"Updating Documentation","text":"<p>To generate the documentation (will pick up any changes) be sure to add <code>-DBUILD_DOCS=ON</code> to your cmake flags. Then from the build directory run:</p> <pre><code>```  { .bash .copy }\ncmake --build . -t docs  # this will put the generated documentation in &lt;build_path&gt;/docs/docs\ncmake --install .        # this will install the generated docs in your install directory under 'share/doc/ILLIXR/docs'\n```\n</code></pre>"},{"location":"working_with/using_cameras/","title":"Using Cameras with ILLIXR","text":"<p>ILLIXR supports a wide range of cameras, most of which are for the purpose of feeding images and IMU measurements to the system.  To learn more about how it works, checkout Getting Started. If you are interested in what topics these cameras feed into, checkout ILLIXR plugins.</p> <p>Info</p> <p>Before running any of these plugins below, it is important to not have <code>offline_cam</code> and <code>offline_imu</code> in your plugin list for the executable (either via yaml file or command line).</p>"},{"location":"working_with/using_cameras/#add-calibration-parameters","title":"Add Calibration Parameters","text":"<p>In order to add your camera's calibration extrinsics, you need to modify your choice of SLAM/VIO plugin. Follow these instructions to modify a plugin.</p> <ul> <li> <p><code>OpenVINS</code>:</p> <p>Navigate to <code>ov_msckf/src</code>. Uncomment this line out in <code>slam2.cpp</code> in order to use ZED's calibration parameter for OpenVins.  You can add your own calibration parameters in the same file.     </p> </li> </ul>"},{"location":"working_with/using_cameras/#zed-mini","title":"ZED Mini","text":"<ol> <li> <p>Install ZED SDK </p> <p>Install the latest version of the ZED SDK on stereolabs.com. For more information, checkout the ZED API documentation.</p> </li> <li> <p>Get ZED's calibration parameters</p> <p>Both OpenVINS have a decent calibration parameters for ZED. But if you wish to add your own: </p> <pre><code>/usr/local/zed/tools/ZED_Calibration\n</code></pre> <p>Your original factory calibration file is stored here</p> <pre><code>/usr/local/zed/settings/\n</code></pre> <p>Or download it from calib.stereolabs.com.</p> </li> <li> <p>Enable ZED in OpenVINS plugin</p> <p>This step is only required if using OpenVINS. Uncomment this line in the OpenVINS plugin. </p> </li> <li> <p>Run ILLIXR with ZED: </p> <p>Add <code>zed</code> to the plugins list in any yaml profile file and run ILLIXR normally.</p> </li> </ol>"},{"location":"working_with/using_cameras/#intel-realsense","title":"Intel Realsense","text":"<p>ILLIXR has been tested with Intel RealSense D455, but it should work with any D or T series RealSense Camera. </p> <ol> <li> <p>Install librealsense (if you haven't already):</p> <p>Instruction on how to install can be found here.</p> </li> <li> <p>Get RealSense calibration parameters:</p> <p>Navigate to <code>enumerate-devices</code></p> <pre><code>./PATH/TO/LIBREALSENSE/build/tools/enumerate-devices\n</code></pre> <p>Run this command to obtain the calibration parameters</p> <pre><code>./rs-enumerate-devices -c\n</code></pre> </li> <li> <p>Run ILLIXR with RealSense: </p> <p>Add <code>realsense</code> to the plugins list in any yaml profile file and run ILLIXR normally.</p> <p>Note</p> <p>We will release the corresponding <code>#define realsense</code> soon for OpenVINS + Realsense</p> </li> </ol>"},{"location":"working_with/virtualization/","title":"Setting up ILLIXR in QEMU","text":""},{"location":"working_with/virtualization/#install-qemu","title":"Install QEMU","text":"<p>Use you package manager (<code>apt</code> for Ubuntu) to install <code>qemu</code></p>"},{"location":"working_with/virtualization/#setup-ubuntu-in-the-vm","title":"Setup Ubuntu in the VM","text":"<p>Run <code>ILLIXR/qemu/qemu.sh</code> to download Ubuntu 22.04, create a virtual hard drive     (<code>illixr.qcow2</code>), and launch <code>qemu</code>.</p> <p>Your VM image will be created at <code>ILLIXR/qemu/illixr.qcow2</code>. Ubuntu will be downloaded and saved at <code>ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso</code>.</p> <p>You will be prompted to install Ubuntu;     follow the instructions and install Ubuntu to the virtual hard drive.</p> <p></p> <p>Choose the \"erase all\" option and confirm:</p> <p> </p> <p>Pick any account name and password you like.</p> <p></p> <p>Once Ubuntu is installed you will be asked to reboot. Close <code>qemu</code> and then run <code>ILLIXR/qemu/qeum.sh</code> again to boot into your brand-new Ubuntu install!</p>"},{"location":"working_with/virtualization/#booting-the-vm","title":"Booting the VM","text":"<p>To launch the VM from now on, just use <code>ILLIXR/qemu/qemu.sh</code>. This will boot from the Ubuntu image we created earlier (<code>illixr.qcow2</code>). Once Ubuntu is installed, it is safe to delete <code>ubuntu-22.04.2-desktop-amd64.iso</code>.</p>"},{"location":"working_with/virtualization/#setting-up-the-vm","title":"Setting up the VM","text":"<p>Once inside the VM, set up and run ILLIXR as found on the Getting Started page.</p>"},{"location":"working_with/virtualization/#uninstalling","title":"Uninstalling","text":"<p>To delete your local VM, just delete <code>ILLIXR/qemu/illixr.qcow2</code>.</p> <p><code>ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso</code> can be deleted anytime you want after Ubuntu     is installed to your VM.</p> <p>If you've deleted <code>illixr.qcow2</code>, you can run <code>ILLIXR/qemu/qemu.sh</code> to recreate it and reinstall everything.</p>"},{"location":"working_with/writing_your_plugin/","title":"Writing Your Plugin","text":""},{"location":"working_with/writing_your_plugin/#adding-a-new-plugin","title":"Adding a New Plugin","text":"<p>To add a new plugin</p> <ol> <li>create a new subdirectory in the <code>plugins</code> directory named for your plugin (no spaces)</li> <li>put your code in this new subdirectory (additional subdirectories containing parts of your code are allowed)</li> <li>create a CMakeLists.txt file in this new subdirectory. See the template below</li> <li>add the plugin to the <code>profiles/plugins.yaml</code> file, the name must match the subdirectory you created; it should go in    the <code>all_plugins</code> entry</li> </ol> <p>For the examples below is for a plugin called tracker, so just replace any instance of tracker with the name of your plugin.</p>"},{"location":"working_with/writing_your_plugin/#simple-example","title":"Simple Example","text":"<pre><code>set(TRACKER_SOURCES plugin.cpp\n                    plugin.hpp\n                    src/tracker.cpp\n                    src/tracker.hpp)\n\nset(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n\nadd_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include)\n\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> Line # Notes 1-4 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 6 Put the plugin name into a variable (will also be the name of the library). 8 Tell the system we are building a shared library with the name  <code>PLUGIN_NAME</code> from the specified source files. 10 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR_SOURCE_DIR/include</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 12 Any compile options specific to this plugin. Usually this will be left as is. 14 Add the install directive. This should not need to change."},{"location":"working_with/writing_your_plugin/#more-complex-example","title":"More Complex Example","text":"<p>In this example the plugin has external dependencies provided by OS repos, specifically glfw3, x11, glew, glu, opencv, and eigen3.</p> <pre><code>set(TRACKER_SOURCES plugin.cpp\n                    plugin.hpp\n                    src/tracker.cpp\n                    src/tracker.hpp)\n\nset(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n\nfind_package(glfw3 REQUIRED)\n\nadd_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} dl pthread)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> Line# Notes 1-4 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 6 Put the plugin name into a variable (will also be the name of the library). 8 Use the <code>find_package</code> directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. <code>find_package</code> assumes that there is an appropriate .cmake config file for the dependency on your system. If not the <code>pkg_check_module</code> function will perform the same task, but for dependencies which have associated .pc files on your system. 10 Tell the system we are building a shared library with the name   <code>PLUGIN_NAME</code>  from the specified source files. 12 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR _SOURCE_DIR</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 13 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 14 Any compile options specific to this plugin. Usually this will be left as is. 16 Add the install directive. This should not need to change. <p>Note</p> <p>Not all the dependencies were searched for by <code>find_package</code> in this example. This is because there is a set of dependencies which are very common to many plugins and their <code>find_package</code> calls are in the main ILLIXR CMakeLists.txt file and do not need to be searched for again. These packages are</p> <ul> <li>Glew</li> <li>Glu</li> <li>SQLite3</li> <li>X11</li> <li>Eigen3</li> <li>OpenCV</li> </ul>"},{"location":"working_with/writing_your_plugin/#very-complex-example","title":"Very Complex Example","text":"<p>In this example the plugin has dependencies provided by OS repos, and a third party dependency provided by a git repo.</p> <pre><code>set(TRACKER_SOURCES plugin.cpp\n                    src/tracker.cpp\n                    src/tracker.hpp)\n\nset(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n\nfind_package(glfw3 REQUIRED)\n\nadd_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n\nget_external(Plotter)\n\nadd_dependencies(${PLUGIN_NAME} Plotter)\n\ntarget_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS} ${Plotter_INCLUDE_DIRS})\ntarget_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} ${Plotter_LIBRARIES} dl pthread)\ntarget_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n\ninstall(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> Line# Notes 1-3 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the <code>find_package</code> directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. <code>find_package</code> assumes that there is an appropriate .cmake config file for the dependency on your system. If not the <code>pkg_check_module</code> function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name   <code>PLUGIN_NAME</code>  from the specified source files. 11 Get the external project called Plotter. 13 Add the external package as a build dependency, this ensures that this plugin won't be built until after the dependency is. 15 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR _SOURCE_DIR</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 16 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 17 Any compile options specific to this plugin. Usually this will be left as is. 19 Add the install directive. This should not need to change. <p>Additionally, to build and install the Plotter dependency you will need to create a cmake file in the <code>cmake</code> directory named <code>GetPlotter.cmake</code> (case matters, it must match the call to <code>get_external</code>) with the following content.</p> <pre><code>find_package(Plotter QUIET)\n\nif(Plotter_FOUND)\n    set(Plotter_VERSION \"${Plotter_VERSION_MAJOR}\")\nelse()\n    EXTERNALPROJECT_ADD(Plotter\n            GIT_REPOSITORY https://github.com/mygit/Plotter.git\n            GIT_TAG 4ff860838726a5e8ac0cbe59128c58a8f6143c6c\n            PREFIX ${CMAKE_BINARY_DIR}/_deps/plotter\n            CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=Release\n            )\n    set(Plotter_EXTERNAL Yes)\n    set(Plotter_INCLUDE_DIRS ${CMAKE_INSTALL_PREFIX}/include)\n    set(Plotter_LIBRARIES plotter;alt_plotter)\nendif()\n</code></pre> Line # Notes 1 See if the package has been previously installed, quietly fail if not. 4 If it was found, just record the installed version for reporting. 6-11 Add the Plotter package as a project called <code>Plotter</code> (also case sensitive) 7 The git repo where the Plotter package is located. 8 The git tag to use (can be a tag name or sha5 from a commit). 9 The build directory for the package. 10 Any camke arguments to pass to the Plotter build. The ones specified here are required, but any others can be added. 12 Denote that this is an external package (this is used for internal tracking). 13 Set where the Plotter include files will land. Usually this will not need to change. 14 Set which libraries are built by the Plotter package. In this example <code>libplotter.so</code> and <code>libalt_plotter.so</code> are being built."},{"location":"working_with/writing_your_plugin/#external-plugins","title":"External Plugins","text":"<p>For plugins that are external packages (e.g. Audio_Pipeline) you need only create a <code>GetX.cmake</code> file as above and add the plugin name to the <code>all_plugins</code> list in <code>profiles/plugins.yaml</code>.</p> <p>External plugins with external dependencies are a bit more work, but are straight forward. See how Audio Pipeline is handled.</p> <p>For a plugin which uses the mediapipe framework (e.g. hand_tracking) see Mediapipe Based Plugins for additional information.</p>"},{"location":"working_with/writing_your_plugin/#tutorial","title":"Tutorial","text":"<p>You can extend ILLIXR for your own purposes. To add your own functionality via the plugin interface:</p> <ol> <li> <p>Create a new directory for your plugin in one of these ways</p> <ol> <li>in the plugins directory of the main ILLIXR tree, then follow these instructions</li> <li>anywhere for your new plugin so it can be pushed as a git repository, the    follow these instructions focussing on external plugins</li> </ol> </li> <li> <p>You must decide if your plugin should inherit the standardized <code>threadloop</code>    or <code>plugin</code>.</p> <ul> <li> <p>If your plugin just needs to run one computation repeatedly, then your   plugin class should extend <code>threadloop</code>. Your code goes in   <code>_p_one_iteration</code>, which gets called in a hot loop. <code>threadloop</code>   inherits from plugin, but adds threading functionality. If you don't   use <code>_p_one_iteration</code>, inheriting from <code>threadloop</code> is superfluous;   Inherit from plugin directly instead.</p> </li> <li> <p>If you need custom concurrency (more complicated than a loop), triggered   concurrency (by events fired in other plugins), or no concurrency   then your plugin class should extend <code>plugin</code>. Your code goes   in the <code>start</code> method.</p> </li> <li> <p>If you want to schedule data-driven work in either case, call   <code>sb-&gt;schedule(...)</code>.</p> </li> <li> <p>If you spin your own threads, they must wait for   <code>pb-&gt;lookup_impl&lt;stoplight&gt;()-&gt;wait_for_ready()</code> the first time they   run. This allows the start of all threads in ILLIXR to be   synchronized.</p> </li> <li> <p>They must be joined-or-disowned at-or-before   <code>plugin::stop()</code>. This allows ILLIXR to shut down cleanly.</p> </li> </ul> </li> <li> <p>Write a file called <code>plugin.hpp</code> with this body, replacing every instance of <code>basic_plugin</code>:</p> <pre><code>#pragma once\n// A minimal/no-op ILLIXR plugin\n\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nnamespace ILLIXR {\n\n// Inherit from plugin if you don't need the threadloop\n// Inherit from threadloop to provide a new thread to perform the task\nclass basic_plugin : public threadloop {\npublic:\n    basic_plugin(std::string name_, phonebook* pb_);\n\n    ~basic_plugin() override;\nprotected:\n    // For `threadloop` style plugins, do not override the start() method unless you know what you're doing.\n    // _p_one_iteration() is called in a thread created by threadloop::start()\n    void        _p_one_iteration() override;\n    skip_option _p_should_skip() override;\n\n};\n}\n</code></pre> </li> <li> <p>Write a file called <code>plugin.cpp</code> which contains the implementations of which of the above functions.</p> <pre><code>// A minimal/no-op ILLIXR plugin\n\n#include \"plugin.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\nusing namespace ILLIXR;\n\n basic_plugin::basic_plugin(std::string name_, phonebook* pb_)\n       : threadloop{name_, pb_} {\n        std::cout &lt;&lt; \"Constructing basic_plugin.\" &lt;&lt; std::endl;\n }\n\n basic_plugin::~basic_plugin() {\n     std::cout &lt;&lt; \"Deconstructing basic_plugin.\" &lt;&lt; std::endl;\n }\n\n void basic_plugin::_p_one_iteration() {\n     std::cout &lt;&lt; \"This goes to the log when `log` is set in the config.\" &lt;&lt; std::endl;\n     std::cerr &lt;&lt; \"This goes to the console.\" &lt;&lt; std::endl;\n     std::this_thread::sleep_for(std::chrono::milliseconds{100});\n }\n\nthreadloop::skip_option _p_should_skip() {\n    if (&lt;CONDITION WHEN _p_one_iteration SHOULD RUN&gt;)\n        return skip_option::run;\n    return skip_option::skip_and_spin;\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(basic_plugin);\n</code></pre> </li> <li> <p>At this point, you should be able to build your plugin with ILLIXR using <code>-DUSE&lt;YOUR_PLUGIN_NAME&gt;=ON</code> as a command line    argument to cmake.    See Getting Started for more details.</p> </li> <li> <p>Finally, run ILLIXR with your new plugin following the instructions in Getting Started:</p> </li> <li> <p>This is all that is required to be a plugin which can be loaded by Spindle in    the ILLIXR runtime.    Reading and writing from Phonebook and Switchboard is optional,    but nearly every plugin does it.</p> <p>First, we can query the <code>phonebook</code> to get various services including <code>switchboard</code>. Then we query <code>switchboard</code> for event-streams (topics). We will read <code>topic1</code>, write to <code>topic2</code>, and schedule computation on <code>topic 3</code>. See the API documentation for <code>phonebook</code> and <code>switchboard</code> for more details.</p> <p>plugin.hpp <pre><code>#pragma once\n\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/threadloop.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(std::string name_, phonebook* pb_);\n\nprotected:\n    void _p_one_iteration() override;\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; switchboard_;\n    switchboard::reader&lt;topic1_type&gt; topic1_;\n    switchboard::writer&lt;topic2&gt; topic2_;\n};\n</code></pre></p> <p>plugin.cpp <pre><code>#include \"plugin.hpp\"\n\n#include &lt;iostream&gt;\n\n/* After the constructor, C++ permits a list of member-constructors.\n * We use uniform initialization (curly-braces) [1] instead of parens to\n *     avoid ambiguity [2].\n * We put the comma at the start of the line, so that lines can be copied around\n *     or deleted freely (except for the first).\n *\n * [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n * [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n */\nplugin_name::plugin_name(std::string name_, phonebook* pb_)\n   : threadloop{name_, pb_}\n   , switchboard_{pb-&gt;lookup_impl&lt;switchboard&gt;()}             // Find the switchboard in phonebook\n   , topic1_{switchboard_-&gt;get_reader&lt;topic1_type&gt;(\"topic1\")}  // Create a handle to a topic in switchboard for subscribing\n   , topic2_{switchboard_-&gt;get_writer&lt;topic2_type&gt;(\"topic2\")}  // Create a handle to a topic in switchboard for publishing\n    {\n    // Read topic 1\n    switchboard::ptr&lt;const topic1_type&gt; event1 = topic1_.get_ro();\n\n    // Write to topic 2\n    topic2_.put(\n        topic2_.allocate&lt;topic2_type&gt;(\n            arg_1, // topic2_type::topic2_type() arg_type_1\n            ...,   // ...\n            arg_k  // topic2_type::topic2_type() arg_type_k\n        )\n    );\n\n    /// Read topic 3 synchronously\n    switchboard_-&gt;schedule&lt;topic3_type&gt;(\n        get_name(),\n        \"topic3\",\n        [&amp;](switchboard::ptr&lt;const topic3_type&gt; event3, std::size_t) {\n            /* This is a [lambda expression][1]\n             *\n             * [1]: https://en.cppreference.com/w/cpp/language/lambda\n             */\n            std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n            callback(event3);\n        }\n    );\n}\n\nvoid _p_one_iteration() {\n    std::cout &lt;&lt; \"Running\" &lt;&lt; std::endl;\n    auto target = std::chrono::system_clock::now()\n                + std::chrono::milliseconds{10};\n    reliable_sleep(target);\n}\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n</code></pre></p> </li> </ol>"}]}