{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ILLIXR","text":"<p>Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains standalone state-of-the-art components representative of a generic XR workflow, as well as a runtime framework that integrates these components into an XR system. ILLIXR's runtime integration framework is modular, extensible, and OpenXR-compatible.</p> <p>We use the term components and not kernels or computations because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in the v1-latest release of ILLIXR.</p> <ol> <li>Simultaneous Localization and Mapping</li> <li>Scene reconstruction</li> <li>Eye tracking</li> <li>Ambisonic encoding</li> <li>Ambisonic manipulation and binauralization</li> <li>Lens distortion correction</li> <li>Chromatic aberration correction</li> <li>Time warp</li> <li>Computational holography for adaptive multi-focal displays</li> </ol> <p>We plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications.</p> <p>Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors.</p> <p>Detailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our paper.</p>"},{"location":"#publications","title":"Publications","text":"<p>We request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.</p> <pre><code>@misc{HuzaifaDesai2020,\n    title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research},\n    author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve},\n    year={2020},\n    eprint={2004.04643},\n    primaryClass={cs.DC}\n}\n</code></pre>"},{"location":"#getting-started-and-documentation","title":"Getting Started and Documentation","text":"<p>For more information, see our getting started page.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Muhammad Huzaifa led the development of ILLIXR in Sarita Adve\u2019s research group at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang.</p> <p>ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.</p> <p>Our OpenXR implementation is derived from Monado. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.</p> <p>The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset.</p> <p>Wesley Darvin came up with the name for ILLIXR.</p>"},{"location":"#licensing-structure","title":"Licensing Structure","text":"<p>ILLIXR is available as open-source software under the University of Illinois/NCSA Open Source License. As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software. The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses:</p> <ul> <li>Open-VINS - GNU General Public License v3.0</li> <li>ElasticFusion - ElasticFusion license</li> <li>RITnet - MIT License</li> <li>libspatialaudio - GNU Lesser General Public License v2.1</li> <li>HOTlab - GNU Lesser General Public License v3.0</li> <li>Monado - Boost Software License 1.0</li> </ul>"},{"location":"#get-in-touch","title":"Get In Touch","text":"<p>Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living testbed and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at illixr at cs dot illinois dot edu or visit us on Gitter or just send us a pull request!</p>"},{"location":"building_ILLIXR/","title":"Building ILLIXR","text":""},{"location":"building_ILLIXR/#basic-usage","title":"Basic usage","text":"<ul> <li> <p>Edit <code>config.yaml</code>. See <code>runner/config_schema.yaml</code> for the schema definition.</p> </li> <li> <p>Make sure you have defined all of the plugins you want with paths that exist.</p> </li> <li> <p>Currently we support the following loaders: <code>native</code> (which runs ILLIXR in standalone mode),     <code>gdb</code> (which runs standalone mode in GDB for debugging purposes), and <code>monado</code> (which runs an     OpenXR application in Monado using ILLIXR as a backend)</p> <ul> <li>If you want to run with Monado, make sure you define Monado and an OpenXR application in the   loader (see <code>runner/config_schema.yaml</code> for specifics).</li> </ul> </li> <li> <p>Paths are resolved relative to the project root.</p> </li> <li> <p>You can <code>!include</code> other YAML files (documentation). Consider separating the site-specific     configuration options into its own file.</p> </li> <li> <p>Run <code>./runner.sh config.yaml</code>.</p> </li> <li> <p>This compiles whatever plugins and runtime code is necessary and runs the result.</p> </li> <li> <p>This also sets the environment variables properly.</p> </li> </ul>"},{"location":"building_ILLIXR/#rationale","title":"Rationale","text":"<ul> <li> <p>Previously, we would have to specify which plugins to build and which to run separately, violating   DRY principle.</p> </li> <li> <p>Previously, configuration had to be hard-coded into the component source code, or passed as   parsed/unparsed as strings in env-vars on a per-component basis. This gives us a consistent way to   deal with all configurations.</p> </li> <li> <p>Currently, plugins are specificed by a path to the directory containing their source code and   build system. In the future, the same config file could support HTTP URLs Git URLs   (<code>git+https://github.com/username/repo@rev?path=optional/path/within/repo</code>), or Zip URLs   (<code>zip+http://path/to/archive.zip?path=optional/path/within/zip</code>), or even Nix URLs (TBD).</p> </li> </ul>"},{"location":"building_ILLIXR/#adding-a-new-plugin-common-case","title":"Adding a new plugin (common case)","text":"<p>In the common case, one need only define a <code>Makefile</code> with the line <code>include common/common.mk</code> and symlink common (<code>ln -s ../common common</code>). This provides the necessary targets and uses the compiler <code>$(CXX)</code>, which is defined in Make based on the OS and environment variables.</p> <ul> <li> <p>It compiles <code>plugin.cpp</code> and any other <code>*.cpp</code> files into the plugin.</p> </li> <li> <p>It will invoke a recompile the target any time any <code>*.hpp</code> or <code>*.cpp</code> file changes.</p> </li> <li> <p>It compiles with C++17. You can change this in your plugin by defining <code>STDCXX = ...</code> before the   <code>include</code>. This change will not affect other plugins; just yours.</p> </li> <li> <p>Libraries can be added by appending to <code>LDFLAGS</code> and <code>CFLAGS</code>, for example</p> <pre><code>LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3)\nCFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3)\n</code></pre> </li> <li> <p>See the source for the exact flags.</p> </li> <li> <p>Inserted the path of your directory into the <code>plugin</code>-list in <code>config.yaml</code>.</p> </li> </ul>"},{"location":"building_ILLIXR/#adding-a-plugin-general-case","title":"Adding a plugin (general case)","text":"<p>Each plugin can have a completely independent build system, as long as: - It defines a <code>Makefile</code> with targets for <code>plugin.dbg.so</code>, <code>plugin.opt.so</code>, and <code>clean</code>. Inside   this <code>Makefile</code>, one can defer to another build system.</p> <ul> <li> <p>It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using   the same version of Clang or GCC on the same architecture is sufficient for this.</p> </li> <li> <p>It's path is inserted in the root <code>config.yaml</code>, in the <code>plugins</code> list.</p> </li> </ul>"},{"location":"building_ILLIXR/#philosophy","title":"Philosophy","text":"<ul> <li> <p>Each plugin should not have to know or care how the others are compiled. In the future, they may   even be distributed separately, just as SOs. Therefore, each plugin needs its own build system.</p> </li> <li> <p>Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be   extremely easy.</p> </li> <li> <p>It should be easy to build in parallel.</p> </li> <li> <p>Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when   experimenting. However, this implies that rebuilding must be fast when not much has changed.</p> </li> <li> <p>Make is the de facto standard for building C/C++ programs. GNU Make, and the   makefile language begets no shortage of problems [1,2,3,4,5], but we choose   Make for its tradeoff of between simplicity and functionality. What it lacks in functionality   (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the   build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to   have a <code>common.mk</code> included in each plugin. This decision to use Make should be revisited, when   this project outgrows its ability, but for now, Make remains, in our judgement, the best tool for   the job.</p> </li> </ul>"},{"location":"default_plugins/","title":"Default Plugins","text":"<ul> <li> <p><code>offline_imu_cam</code>: Reads IMU data and images from files on disk, emulating a real sensor on the   headset (feeds input measurements with timing similar to an actual IMU).</p> </li> <li> <p><code>ground_truth_slam</code>: Reads the ground-truth from the same dataset to compare our output against   (uses timing from <code>offline_imu_cam</code>).</p> </li> <li> <p><code>open_vins</code>: Runs OpenVINS (upstream) on the input, and outputs a the headset's pose. In practice, this   publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet   have pose prediction, so we say <code>open_vins</code> also publishes a fast pose.</p> </li> <li> <p><code>gldemo</code>: Renders a static scene (into left and right eyebuffers) given the pose from <code>open_vins</code>.</p> </li> <li> <p><code>timewarp_gl</code>: Asynchronous reprojection of the eyebuffers.</p> </li> <li> <p><code>debugview</code>: Renders a frame for debug information.</p> </li> <li> <p><code>audio</code>: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.</p> </li> <li> <p><code>hologram</code>: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.</p> </li> </ul> <p>Below this point, we will use Switchboard terminology. Read the API documentation on <code>switchboard</code> for definitions.</p> <p></p> <ul> <li> <p>In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned   between these two gorups).</p> </li> <li> <p>Solid arrows from plugins to topics represent publishing.</p> </li> <li> <p>Solid arrows from topics to plugins represent synchronous reading. They take some action for   every event which gets published on the topic.</p> </li> <li> <p>Solid arrows from topics to plugins represent asynchronous reading. They need to know just the   latest event on their topic.</p> </li> <li> <p>Imagine the topic as a trough filing with events from its publisher, being drained by its   synchronous readers (AKA subscribers), while asynchronous readres just skim from the top.</p> </li> </ul> <p>See Writing Your Plugin to extend ILLIXR.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#illixr-runtime","title":"ILLIXR Runtime","text":"<p>These instructions have been tested with Ubuntu 18.10.</p> <ol> <li> <p>Clone the repository:</p> <pre><code>git clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR\n</code></pre> </li> <li> <p>Update the submodules. Submodules are git repositories inside a git repository that need to be    pulled down separately:</p> <pre><code>git submodule update --init --recursive\n</code></pre> </li> <li> <p>Install dependencies. This script installs some Ubuntu/Debian packages and builds a specific    version of OpenCV from source:</p> <pre><code>./install_deps.sh\n</code></pre> </li> <li> <p>Inspect <code>config.yaml</code>. The schema definition (with documentation inline) is in <code>runner/config_schema.yaml</code>.</p> </li> <li> <p>Build and run ILLIXR standalone:</p> <pre><code>./runner.sh config.yaml\n</code></pre> </li> </ol>"},{"location":"getting_started/#illixr-runtime-with-monado-supports-openxr","title":"ILLIXR Runtime with Monado (supports OpenXR)","text":"<p>ILLIXR leverages Monado, an open-source implementation of OpenXR, to support a wide range of applications.  Monado only supports Ubuntu 18.10, because of a low-level driver issue.</p> <ol> <li> <p>Clone Monado:</p> <pre><code>git clone https://github.com/ILLIXR/monado_integration.git\n</code></pre> </li> <li> <p>Clone our application example:</p> <pre><code>git clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example\n</code></pre> </li> <li> <p>Clone ILLIXR:</p> <pre><code>git clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR\ngit submodule update --init --recursive\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>cd ILLIXR\n./install_deps.sh\n</code></pre> </li> <li> <p>Edit the <code>conig.yaml</code>, using this for the loader:</p> </li> </ol> <pre><code>loader:\n  name: monado\n  monado:\n    path: ../monado_integration\n  openxr_app:\n    path: ../Monado_OpenXR_Simple_Example\n</code></pre> <ol> <li>Compile and run:<pre><code>./runner.sh config.yaml\n</code></pre> </li> </ol>"},{"location":"getting_started/#illixr-standalone","title":"ILLIXR Standalone","text":"<p>ILLIXR can also benchmark each component in isolation.</p> <ol> <li> <p>Clone the repository.</p> <pre><code>git clone --recursive --branch v1-latest https://github.com/ILLIXR/ILLIXR\n</code></pre> </li> <li> <p>Update the submodules. Submodules are git repositories inside a git repository that need to be    pulled down separately.</p> <pre><code>git submodule update --init --recursive\n</code></pre> </li> <li> <p>Each component is a directory in <code>benchmark</code>. See those components for their documentation.</p> </li> </ol>"},{"location":"getting_started/#next-steps","title":"Next steps","text":"<p>The source code is divided into the following directories: - <code>runtime</code>: create a runnable binary that loads every plugin.     * This contains Spindle, which is responsible for loading plugins.</p> <ul> <li> <p><code>common</code>: resources one might use in each plugin. Most plugins symlink this directory into theirs.</p> <ul> <li>Contains the interface for Switchboard, which maintains event-streams (implementation is in <code>runtime</code>).</li> <li>Contains the interface for Phonebook, which is a service-directory (implementation is in <code>runtime</code>).</li> </ul> </li> <li> <p>a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See   Default Components for more details.</p> </li> </ul> <p>Try browsing the source of plugins.  If you edit any of the source files, this make commend will detect and rebuild the respective binary. If you want to add your own, see Writing Your Plugin.</p>"},{"location":"monado_illixr_runtime_overview/","title":"Monado Integration Overview","text":"<p>ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to force developers to write their wohle application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR, so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado, an existing, open-source implementation.</p> <ul> <li> <p>When running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and   switchboard are initialized and plugins are loaded, among which is the gldemo app.</p> </li> <li> <p>When running from Monado, however, as mandated by OpenXR specifications, the application is the   entry point. As a result, the Illixr runtime system is loaded at a later point as a shared   library. This article documents the changes to the Illixr runtime when an OpenXR application is   used.</p> </li> </ul>"},{"location":"monado_illixr_runtime_overview/#1-app-launches-and-brings-up-monado","title":"1. App launches and brings up Monado","text":"<p>As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronous Group for more details.</p>"},{"location":"monado_illixr_runtime_overview/#2-monado-probes-hmd-devices-and-illixr-initializes","title":"2.  Monado probes HMD devices and Illixr Initializes","text":"<p>During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as <code>xdev</code>s.  We have an Illixr driver, which will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from environment variables.</p> <p>After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.</p>"},{"location":"monado_illixr_runtime_overview/#3-illixr-runtime-launch","title":"3. Illixr Runtime Launch","text":"<p>When used with Monado, the Illixr runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing switchboard and phonebook, and load plugins.</p> <p>The drivers starts to load the runtime by loading the shared library into the current (the app's) address space and calls the switchboard and phonebook initialization. Then, it calls the plugin loading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a translation plugin into Illixr as the application. The translation plugin will be in the next section. Each plugin should either not block or start its own thread, so the driver will be able to reacquire control and return to Monado and the app shortly.</p>"},{"location":"monado_illixr_runtime_overview/#4-the-translation-plugin","title":"4. The translation plugin","text":"<p>When the app and all Illixr plugins are up and running, the translation plugin handles the connection between Monado and Illixr. It might be confusing to see that this plugin is part of the Illixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But Monado and Illixr are running in different threads in the same address space. The translation plugin is the intersection of these two parallel systems serving as a bridge between the two.</p> <p>The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, it is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames.</p> <p>For implementation details regarding the representation of poses and frames in Monado and in Illixr, please see Monado Integration Dataflow.</p>"},{"location":"monado_integration_dataflow/","title":"Monado Integration Dataflow","text":""},{"location":"monado_integration_dataflow/#monado-integration-dataflow","title":"Monado Integration Dataflow","text":"<p>The integration for monado in terms of dataflow can be divided into two parts, getting pose from illixr, and sending user rendered frame to illixr.</p> <p>In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user application as <code>gldemo</code>. After illixr is initialized from monado, and monado is registered as a plugin for illixr, most recent pose information is easy to get from switchboard.</p> <p>The compositor side of monado integration with illixr is done in more subtle way. Original monado compositor mostly does distortion correction and aberration correction in a vulkan back-end compositor. It also has two client compositor, one for opengl app, the other for vulkan app, which pass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client compositor and sends it to switchboard of illixr, which is then used by <code>timewarp_gl</code> component.</p> <p>In order to get a opengl frame and use it without copying pixels, illixr needs to get the user application gl context. It is done at OpenXR session creation time, where illixr is initialized. Note that logically illixr is initialized during OpenXR instance creation, or running at the background all the time. But, since illixr only supports single session at this time, and requires a user application gl context upon initialization, illixr is initialized at session creation time.</p> <p>Current illixr integration for monado is a temporary solution and has some downsides because of the progress from both monado and illixr.</p> <ol> <li> <p>It does not use the pose that user application declares to use at rendering (OpenXR    specification) because of monado internal interfaces. The pose difference used by timewarp comes    from the last pose query call.</p> </li> <li> <p>It cannot submit frame with depth buffer.</p> </li> <li> <p>The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam    algorithms.</p> </li> <li> <p>No controller action support at all.</p> </li> <li> <p>It only supports gl user applications.</p> </li> <li> <p>User application cannot acquire more than one swapchain image (for each eye) in one frame.</p> </li> <li> <p>Illixr is initialized during session creation time.</p> </li> </ol>"},{"location":"visualizer_logger/","title":"Visualizer & Logger","text":""},{"location":"visualizer_logger/#visualizer-logger","title":"Visualizer &amp; Logger","text":"<p>There is a utility header file <code>common/logger.hpp</code>, which is a logger for recording process starting and ending time, with respect to the component initialization time. Currently, only <code>audio_pipeline</code> and <code>hologram</code>use this logger. Please create a <code>log</code> directory in your running binary directory to let those log files correctly appear.</p> <p><code>log/visualizer.py</code>is a script to create visual timeline according to the log files in the same directory. It is not convenient to use or precisely correct right now.</p>"},{"location":"writing_your_plugin/","title":"Writing your plugin","text":"<p>With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way.</p> <ol> <li> <p>We suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere.</p> </li> <li> <p>Add this directory to <code>plugins</code> in ILLIXR's root <code>Makefile</code>. The order in this list determines    the order of initialization in the program. <code>phonebook</code>, for example, is order-sensitive.</p> </li> <li> <p>In your plugin directory, we suggest symlinking common (<code>ln -s ../common common</code>).</p> </li> <li> <p>Create a <code>Makefile</code> with the following contents. See Building ILLIXR for more details and alternative setups.</p> <pre><code>include common.mk\n</code></pre> </li> <li> <p>You must decide if your plugin should inherit the standardized <code>threadloop</code> or     <code>plugin</code>.</p> </li> <li> <p>If your plugin just needs to run one computation repeatedly, then your plugin class should     extend <code>threadloop</code>.</p> </li> <li> <p>If you need custom concurrency (more complicated than a loop), triggered concurrency (by     events fired in other plugins), or no concurrency then your plugin class should extend     <code>plugin</code>.</p> </li> <li> <p>Write a file called <code>plugin.cpp</code> with this body, replacing every instance of <code>plugin_name</code>:</p> <pre><code>#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\nusing namespace ILLIXR;\n\n// Inherit from `plugin` if you don't need the threadloop\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n        { }\n    virtual void start() override { }\n    virtual ~plugin_name() override { }\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n</code></pre> </li> <li> <p>At this point, you should be able to go to the ILLIXR root and <code>make dbg</code>. If you edit a source     file and then <code>make dbg</code>, it should trigger a rebuild of your plugin.</p> </li> <li> <p>This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR     runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin     does it. See <code>default_plugins.md</code> for more details.</p> <p>First, we can query the <code>phonebook</code> to get various services including <code>switchboard</code>. Then we query <code>switchboard</code> for event-streams (topics). We will read <code>topic1</code>, write to <code>topic2</code>, and schedule computation on <code>topic 3</code>. See the API documentation for <code>phonebook</code> and <code>switchboard</code> for more details.</p> <pre><code>#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\n/* When datatypes have to be common across plugins\n  (e.g. a phonebook service or switchboard topic),\n   they are defined in this header,\n   which is accessible to all plugins. */\n#include \"common/data_format.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    /*\n        After the constructor, C++ permits a list of member-constructors.\n        We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2].\n        We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first).\n\n        [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n        [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n    */\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n          // find the switchboard in phonebook\n        , sb{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n          // create a handle to a topic in switchboard for subscribing\n        , topic1{sb-&gt;subscribe_latest&lt;topic1_type&gt;(\"topic1\")}\n          // create a handle to a topic in switchboard for publishing\n        , topic2{sb-&gt;publish&lt;topic2_type&gt;(\"topic2\")}\n    {\n        // Read topic 1\n        topic1_type* event1 = topic1.get_latest_ro();\n\n        // Write to topic 2\n        topic2_type* event2 = new topic2_type;\n        topic2.put(event2);\n\n        // Read topic 3 synchronously\n        sb-&gt;schedule&lt;topic3_type&gt;(get_name(), \"topic3\", [&amp;](const topic3_type *event3) {\n            /*\n            This is a [lambda expression][1]\n            [1]: https://en.cppreference.com/w/cpp/language/lambda\n            */\n            std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n        });\n    }\n\n    virtual void _p_one_iteration override() {\n        std::cout &lt;&lt; \"Running\" &lt;&lt; std::endl;\n        auto target = std::chrono::high_resolution_clock::now() +  std::chrono::milliseconds{10};\n        reliable_sleep(target);\n    }\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; pb;\n    std::unique_ptr&lt;reader_latest&lt;topic1_type&gt;&gt; topic1;\n    std::unique_ptr&lt;writer&lt;topic2&gt;&gt; topic2;\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n</code></pre> </li> </ol>"},{"location":"api/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace ILLIXR <ul> <li>struct accel </li> <li>struct camera_frame </li> <li>class data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>class dynamic_lib </li> <li>class gen_guid This class generates unique IDs. </li> <li>struct hmd_physical_info </li> <li>struct hologram_input </li> <li>struct hologram_output </li> <li>struct imu_cam_type </li> <li>class phonebook A service locator for ILLIXR. <ul> <li>class service A 'service' that can be registered in the phonebook. </li> </ul> </li> <li>class plugin A dynamically-loadable plugin for Spindle. </li> <li>struct pose_type </li> <li>class reader_latest A handle which can read the latest event on a topic. </li> <li>class record This class represents a tuple of fields which get logged by <code>record_logger</code> . </li> <li>class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class record_header Schema of each record. </li> <li>class record_logger The ILLIXR logging service for structured records. </li> <li>struct rendered_frame </li> <li>struct rendered_frame_alt </li> <li>struct rgb_depth_type </li> <li>class runtime </li> <li>class start_end_logger a utility for logging to start and end times to a file </li> <li>class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). </li> <li>class threadloop A reusable threadloop for plugins. </li> <li>class writer A handle which can publish events to a topic. </li> <li>class xlib_gl_extended_window </li> </ul> </li> <li>namespace linalg <ul> <li>namespace aliases </li> <li>struct converter </li> <li>struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; </li> <li>struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; </li> <li>namespace detail <ul> <li>struct any_compare </li> <li>struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct apply </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; </li> <li>struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; </li> <li>struct clamp </li> <li>struct empty </li> <li>struct getter </li> <li>struct getter&lt; 0 &gt; </li> <li>struct getter&lt; 1 &gt; </li> <li>struct getter&lt; 2 &gt; </li> <li>struct getter&lt; 3 &gt; </li> <li>struct lerp </li> <li>struct make_seq_impl </li> <li>struct make_seq_impl&lt; A, 0 &gt; </li> <li>struct make_seq_impl&lt; A, 1 &gt; </li> <li>struct make_seq_impl&lt; A, 2 &gt; </li> <li>struct make_seq_impl&lt; A, 3 &gt; </li> <li>struct make_seq_impl&lt; A, 4 &gt; </li> <li>struct max </li> <li>struct min </li> <li>struct op_add </li> <li>struct op_and </li> <li>struct op_cmp </li> <li>struct op_div </li> <li>struct op_eq </li> <li>struct op_ge </li> <li>struct op_gt </li> <li>struct op_int </li> <li>struct op_le </li> <li>struct op_lsh </li> <li>struct op_lt </li> <li>struct op_mod </li> <li>struct op_mul </li> <li>struct op_ne </li> <li>struct op_neg </li> <li>struct op_not </li> <li>struct op_or </li> <li>struct op_pos </li> <li>struct op_rsh </li> <li>struct op_sub </li> <li>struct op_un </li> <li>struct op_xor </li> <li>struct ord </li> <li>struct scalar_type </li> <li>struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; </li> <li>struct scalar_type&lt; vec&lt; T, M &gt; &gt; </li> <li>struct scalars </li> <li>struct scalars&lt; T, U... &gt; </li> <li>struct scalars&lt;&gt; </li> <li>struct select </li> <li>struct seq </li> <li>struct std_abs </li> <li>struct std_acos </li> <li>struct std_asin </li> <li>struct std_atan </li> <li>struct std_atan2 </li> <li>struct std_ceil </li> <li>struct std_copysign </li> <li>struct std_cos </li> <li>struct std_cosh </li> <li>struct std_exp </li> <li>struct std_floor </li> <li>struct std_fmod </li> <li>struct std_log </li> <li>struct std_log10 </li> <li>struct std_pow </li> <li>struct std_round </li> <li>struct std_sin </li> <li>struct std_sinh </li> <li>struct std_sqrt </li> <li>struct std_tan </li> <li>struct std_tanh </li> </ul> </li> <li>struct identity_t </li> <li>struct mat </li> <li>struct mat&lt; T, M, 1 &gt; </li> <li>struct mat&lt; T, M, 2 &gt; </li> <li>struct mat&lt; T, M, 3 &gt; </li> <li>struct mat&lt; T, M, 4 &gt; </li> <li>namespace ostream_overloads </li> <li>struct vec </li> <li>struct vec&lt; T, 1 &gt; </li> <li>struct vec&lt; T, 2 &gt; </li> <li>struct vec&lt; T, 3 &gt; </li> <li>struct vec&lt; T, 4 &gt; </li> </ul> </li> <li>class pose_prediction </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_in_destructor </li> <li>class should_profile_class </li> <li>namespace std <ul> <li>namespace conditional </li> <li>struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; </li> </ul> </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> </ul>"},{"location":"api/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir common <ul> <li>file cpu_timer.hpp </li> <li>file data_format.hpp </li> <li>file dynamic_lib.hpp </li> <li>file extended_window.hpp </li> <li>file linalg.hpp </li> <li>file logger.hpp </li> <li>file phonebook.hpp </li> <li>file plugin.hpp </li> <li>file pose_prediction.hpp </li> <li>file record_logger.hpp </li> <li>file runtime.hpp </li> <li>file shader_util.hpp </li> <li>file switchboard.hpp </li> <li>file threadloop.hpp </li> </ul> </li> </ul>"},{"location":"api/namespaceILLIXR/","title":"Namespace ILLIXR","text":"<p>Namespace List &gt; ILLIXR</p>"},{"location":"api/namespaceILLIXR/#classes","title":"Classes","text":"Type Name struct accel struct camera_frame class data_use_indicator A helper class that lets one dynamically determine if some data gets used. class dynamic_lib class gen_guid This class generates unique IDs. struct hmd_physical_info struct hologram_input struct hologram_output struct imu_cam_type class phonebook A service locator for ILLIXR. class plugin A dynamically-loadable plugin for Spindle. struct pose_type class reader_latest &lt;typename event&gt;A handle which can read the latest event on a topic. class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_logger The ILLIXR logging service for structured records. struct rendered_frame struct rendered_frame_alt struct rgb_depth_type class runtime class start_end_logger a utility for logging to start and end times to a file class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class threadloop A reusable threadloop for plugins. class writer &lt;typename event&gt;A handle which can publish events to a topic. class xlib_gl_extended_window"},{"location":"api/namespaceILLIXR/#public-types","title":"Public Types","text":"Type Name typedef plugin *(* plugin_factory typedef std::chrono::time_point&lt; std::chrono::system_clock &gt; time_type typedef unsigned long long ullong typedef std::unique_ptr&lt; void, std::function&lt; void(void *)&gt; &gt; void_ptr"},{"location":"api/namespaceILLIXR/#public-attributes","title":"Public Attributes","text":"Type Name const record_header __plugin_start_header   = <code>/* multi line expression */</code> const record_header __threadloop_iteration_header   = <code>/* multi line expression */</code>"},{"location":"api/namespaceILLIXR/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::chrono::milliseconds LOG_BUFFER_DELAY   = <code>{1000}</code>"},{"location":"api/namespaceILLIXR/#public-functions","title":"Public Functions","text":"Type Name runtime * runtime_factory (GLXContext appGLCtx)"},{"location":"api/namespaceILLIXR/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR/#typedef-plugin_factory","title":"typedef plugin_factory","text":"<pre><code>typedef plugin *(* ILLIXR::plugin_factory) (phonebook *);\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-time_type","title":"typedef time_type","text":"<pre><code>typedef std::chrono::time_point&lt;std::chrono::system_clock&gt; ILLIXR::time_type;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-ullong","title":"typedef ullong","text":"<pre><code>typedef unsigned long long ILLIXR::ullong;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-void_ptr","title":"typedef void_ptr","text":"<pre><code>using ILLIXR::void_ptr = typedef std::unique_ptr&lt;void, std::function&lt;void(void*)&gt; &gt;;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-__plugin_start_header","title":"variable __plugin_start_header","text":"<pre><code>const record_header ILLIXR::__plugin_start_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-__threadloop_iteration_header","title":"variable __threadloop_iteration_header","text":"<pre><code>const record_header ILLIXR::__threadloop_iteration_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-log_buffer_delay","title":"variable LOG_BUFFER_DELAY","text":"<pre><code>std::chrono::milliseconds ILLIXR::LOG_BUFFER_DELAY;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR/#function-runtime_factory","title":"function runtime_factory","text":"<pre><code>runtime * ILLIXR::runtime_factory (\n    GLXContext appGLCtx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1accel/","title":"Struct ILLIXR::accel","text":"<p>ClassList &gt; ILLIXR &gt; accel</p> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1camera__frame/","title":"Struct ILLIXR::camera_frame","text":"<p>ClassList &gt; ILLIXR &gt; camera_frame</p>"},{"location":"api/structILLIXR_1_1camera__frame/#public-attributes","title":"Public Attributes","text":"Type Name int pixel"},{"location":"api/structILLIXR_1_1camera__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1camera__frame/#variable-pixel","title":"variable pixel","text":"<pre><code>int ILLIXR::camera_frame::pixel[1];\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1data__use__indicator/","title":"Class ILLIXR::data_use_indicator","text":"<p>ClassList &gt; ILLIXR &gt; data_use_indicator</p> <p>A helper class that lets one dynamically determine if some data gets used. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions","title":"Public Functions","text":"Type Name data_use_indicator ()  data_use_indicator (const data_use_indicator &amp; other)  bool is_used () const void mark_unused () const void mark_used () const data_use_indicator &amp; operator= (const data_use_indicator &amp; other)"},{"location":"api/classILLIXR_1_1data__use__indicator/#detailed-description","title":"Detailed Description","text":"<p>When a data_use_indicator gets copied, the original is considered used and the new one is considered unused. </p>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-12","title":"function data_use_indicator [1/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator () \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-22","title":"function data_use_indicator [2/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator (\n    const data_use_indicator &amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-is_used","title":"function is_used","text":"<pre><code>inline bool ILLIXR::data_use_indicator::is_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_unused","title":"function mark_unused","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_unused () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-operator","title":"function operator=","text":"<pre><code>inline data_use_indicator &amp; ILLIXR::data_use_indicator::operator= (\n    const data_use_indicator &amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1dynamic__lib/","title":"Class ILLIXR::dynamic_lib","text":"<p>ClassList &gt; ILLIXR &gt; dynamic_lib</p>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions","title":"Public Functions","text":"Type Name dynamic_lib (dynamic_lib &amp;&amp; other)  const T get (const std::string &amp; symbol_name) const dynamic_lib &amp; operator= (dynamic_lib &amp;&amp; other)  const void * operator[] (const std::string &amp; symbol_name) const"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions","title":"Public Static Functions","text":"Type Name dynamic_lib create (const std::string_view &amp; path)"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-dynamic_lib-22","title":"function dynamic_lib [2/2]","text":"<pre><code>inline ILLIXR::dynamic_lib::dynamic_lib (\n    dynamic_lib &amp;&amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-get","title":"function get","text":"<pre><code>template&lt;typename T&gt;\ninline const T ILLIXR::dynamic_lib::get (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator","title":"function operator=","text":"<pre><code>inline dynamic_lib &amp; ILLIXR::dynamic_lib::operator= (\n    dynamic_lib &amp;&amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const void * ILLIXR::dynamic_lib::operator[] (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-create","title":"function create","text":"<pre><code>static inline dynamic_lib ILLIXR::dynamic_lib::create (\n    const std::string_view &amp; path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/dynamic_lib.hpp</code></p>"},{"location":"api/classILLIXR_1_1gen__guid/","title":"Class ILLIXR::gen_guid","text":"<p>ClassList &gt; ILLIXR &gt; gen_guid</p> <p>This class generates unique IDs. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions","title":"Public Functions","text":"Type Name std::size_t get (std::size_t namespace_=0, std::size_t subnamespace=0, std::size_t subsubnamespace=0) Generate a number, unique from other calls to the same namespace/subnamespace/subsubnamepsace."},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1gen__guid/#detailed-description","title":"Detailed Description","text":"<p>If you need unique IDs (e.g. for each component), have each component call this class through Phonebook. It returns unique IDs.</p> <p>You can use namespaces to express logical containment. The return value will be unique between other <code>get</code> calls to the same namespace. This is useful for components and sub-components. For example, If component with ID 0 has 3 subcomponents, one might call get(0) to name each of them. Then, suppose component with ID 1 has 2 subcomponents, one might call get(1) twice to name those. The subcomponent IDs could be reused (non-unique), but tuple (component ID, subcomponent ID) will still be unique. You can also just use the global namespace for everything, if you do not care about generating small integers for the IDs. </p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1gen__guid/#function-get","title":"function get","text":"<p>Generate a number, unique from other calls to the same namespace/subnamespace/subsubnamepsace. <pre><code>inline std::size_t ILLIXR::gen_guid::get (\n    std::size_t namespace_=0,\n    std::size_t subnamespace=0,\n    std::size_t subsubnamespace=0\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/","title":"Struct ILLIXR::hmd_physical_info","text":"<p>ClassList &gt; ILLIXR &gt; hmd_physical_info</p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes","title":"Public Attributes","text":"Type Name float K float chromaticAberration int displayPixelsHigh int displayPixelsWide float ipd float lensSeparationInMeters float metersPerTanAngleAtCenter float visibleMetersHigh float visibleMetersWide int visiblePixelsHigh int visiblePixelsWide"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-k","title":"variable K","text":"<pre><code>float ILLIXR::hmd_physical_info::K[11];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-chromaticaberration","title":"variable chromaticAberration","text":"<pre><code>float ILLIXR::hmd_physical_info::chromaticAberration[4];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelshigh","title":"variable displayPixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelswide","title":"variable displayPixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-ipd","title":"variable ipd","text":"<pre><code>float ILLIXR::hmd_physical_info::ipd;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-lensseparationinmeters","title":"variable lensSeparationInMeters","text":"<pre><code>float ILLIXR::hmd_physical_info::lensSeparationInMeters;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-meterspertanangleatcenter","title":"variable metersPerTanAngleAtCenter","text":"<pre><code>float ILLIXR::hmd_physical_info::metersPerTanAngleAtCenter;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemetershigh","title":"variable visibleMetersHigh","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemeterswide","title":"variable visibleMetersWide","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelshigh","title":"variable visiblePixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelswide","title":"variable visiblePixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsWide;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1hologram__input/","title":"Struct ILLIXR::hologram_input","text":"<p>ClassList &gt; ILLIXR &gt; hologram_input</p>"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes","title":"Public Attributes","text":"Type Name int seq"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__input/#variable-seq","title":"variable seq","text":"<pre><code>int ILLIXR::hologram_input::seq;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1hologram__output/","title":"Struct ILLIXR::hologram_output","text":"<p>ClassList &gt; ILLIXR &gt; hologram_output</p>"},{"location":"api/structILLIXR_1_1hologram__output/#public-attributes","title":"Public Attributes","text":"Type Name int dummy"},{"location":"api/structILLIXR_1_1hologram__output/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__output/#variable-dummy","title":"variable dummy","text":"<pre><code>int ILLIXR::hologram_output::dummy;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__cam__type/","title":"Struct ILLIXR::imu_cam_type","text":"<p>ClassList &gt; ILLIXR &gt; imu_cam_type</p>"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3f angular_v ullong dataset_time std::optional&lt; cv::Mat * &gt; img0 std::optional&lt; cv::Mat * &gt; img1 Eigen::Vector3f linear_a time_type time"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-angular_v","title":"variable angular_v","text":"<pre><code>Eigen::Vector3f ILLIXR::imu_cam_type::angular_v;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-dataset_time","title":"variable dataset_time","text":"<pre><code>ullong ILLIXR::imu_cam_type::dataset_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-img0","title":"variable img0","text":"<pre><code>std::optional&lt;cv::Mat*&gt; ILLIXR::imu_cam_type::img0;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-img1","title":"variable img1","text":"<pre><code>std::optional&lt;cv::Mat*&gt; ILLIXR::imu_cam_type::img1;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-linear_a","title":"variable linear_a","text":"<pre><code>Eigen::Vector3f ILLIXR::imu_cam_type::linear_a;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-time","title":"variable time","text":"<pre><code>time_type ILLIXR::imu_cam_type::time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook/","title":"Class ILLIXR::phonebook","text":"<p>ClassList &gt; ILLIXR &gt; phonebook</p> <p>A service locator for ILLIXR.More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#classes","title":"Classes","text":"Type Name class service A 'service' that can be registered in the phonebook."},{"location":"api/classILLIXR_1_1phonebook/#public-functions","title":"Public Functions","text":"Type Name std::shared_ptr&lt; specific_service &gt; lookup_impl () constLook up an implementation of <code>specific_service</code> , which should be registered first. void register_impl (std::shared_ptr&lt; specific_service &gt; impl) Registers an implementation of <code>baseclass</code> for future calls to lookup."},{"location":"api/classILLIXR_1_1phonebook/#detailed-description","title":"Detailed Description","text":"<p>This will be explained through an exmaple: Suppose one dynamically-loaded plugin, <code>A_plugin</code>, needs a service, <code>B_service</code>, provided by another, <code>B_plugin</code>. <code>A_plugin</code> cannot statically construct a <code>B_service</code>, because the implementation <code>B_plugin</code> is dynamically loaded. However, <code>B_plugin</code> can register an implementation of <code>B_service</code> when it is loaded, and <code>A_plugin</code> can lookup that implementation without knowing it.</p> <p><code>B_service.hpp</code> in <code>common</code>:  <pre><code>class B_service {\npublic:\n    virtual void frobnicate(foo data) = 0;\n};\n</code></pre></p> <p><code>B_plugin.hpp</code>:  <pre><code>class B_impl : public B_service {\npublic:\n    virtual void frobnicate(foo data) {\n        // ...\n    }\n};\nvoid blah_blah(phonebook* pb) {\n    // Expose `this` as the \"official\" implementation of `B_service` for this run.\n    pb-&gt;register_impl&lt;B_service&gt;(new B_impl);\n}\n</code></pre></p> <p><code>A_plugin.cpp</code>:  <pre><code>#include \"B_service.hpp\"\nvoid blah_blah(phonebook* pb) {\n    B_service* b = pb-&gt;lookup_impl&lt;B_service&gt;();\n    b-&gt;frobnicate(data);\n}\n</code></pre></p> <p>If the implementation of <code>B_service</code> is not known to <code>A_plugin</code> (the usual case), <code>B_service should be an [abstract class][2]. In either case</code>B_service<code>should be in</code>common`, so both plugins can refer to it.</p> <p>One could even selectively return a different implementation of <code>B_service</code> depending on the caller (through the parameters), but we have not encountered the need for that yet. </p>"},{"location":"api/classILLIXR_1_1phonebook/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook/#function-lookup_impl","title":"function lookup_impl","text":"<p>Look up an implementation of <code>specific_service</code> , which should be registered first. <pre><code>template&lt;typename specific_service&gt;\ninline std::shared_ptr&lt; specific_service &gt; ILLIXR::phonebook::lookup_impl () const\n</code></pre></p> <p>Safe to be called from any thread.</p> <p>Do not call <code>delete</code> on the returned object; it is still managed by phonebook.</p> <p>Exception:</p> <ul> <li><code>if</code> an implementation is not already registered. </li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#function-register_impl","title":"function register_impl","text":"<p>Registers an implementation of <code>baseclass</code> for future calls to lookup. <pre><code>template&lt;typename specific_service&gt;\ninline void ILLIXR::phonebook::register_impl (\n    std::shared_ptr&lt; specific_service &gt; impl\n) \n</code></pre></p> <p>Safe to be called from any thread.</p> <p>The implementation will be owned by phonebook (phonebook calls <code>delete</code>). </p> <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/","title":"Class ILLIXR::phonebook::service","text":"<p>ClassList &gt; ILLIXR &gt; phonebook &gt; service</p> <p>A 'service' that can be registered in the phonebook. More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::gen_guid,  ILLIXR::record_logger,  ILLIXR::switchboard,  ILLIXR::xlib_gl_extended_window,  pose_prediction</p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions","title":"Public Functions","text":"Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#detailed-description","title":"Detailed Description","text":"<p>These must be 'destructible', have a virtual destructor that phonebook can call in its destructor. </p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook_1_1service/#function-service","title":"function ~service","text":"<pre><code>inline virtual ILLIXR::phonebook::service::~service () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1plugin/","title":"Class ILLIXR::plugin","text":"<p>ClassList &gt; ILLIXR &gt; plugin</p> <p>A dynamically-loadable plugin for Spindle. </p> <ul> <li><code>#include &lt;plugin.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1plugin/#public-functions","title":"Public Functions","text":"Type Name std::string get_name ()  plugin (const std::string &amp; name_, phonebook * pb_)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it starts the component. virtual ~plugin ()"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes","title":"Protected Attributes","text":"Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id std::string name const phonebook * pb const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#function-get_name","title":"function get_name","text":"<pre><code>inline std::string ILLIXR::plugin::get_name () \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin","title":"function plugin","text":"<pre><code>inline ILLIXR::plugin::plugin (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-start","title":"function start","text":"<p>A method which Spindle calls when it starts the component. <pre><code>inline virtual void ILLIXR::plugin::start () \n</code></pre></p> <p>This is necessary for actions which have to be started after constructions, such as threads. These cannot be started in the constructor because virtual methods don't work in consturctors. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-stop","title":"function stop","text":"<p>A method which Spindle calls when it starts the component. <pre><code>inline virtual void ILLIXR::plugin::stop () \n</code></pre></p> <p>This is necessary because the parent class might define some actions that need to be taken prior to destructing the derived class. For example, threadloop must halt and join the thread before the derived class can be safely destructed. However, the derived class's destructor is called before its parent (threadloop), so threadloop doesn't get a chance to join the thread before the derived class is destroyed, and the thread accesses freed memory. Instead, we call plugin-&gt;stop manually before destrying anything. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin_1","title":"function ~plugin","text":"<pre><code>inline virtual ILLIXR::plugin::~plugin () \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#variable-gen_guid_","title":"variable gen_guid_","text":"<pre><code>const std::shared_ptr&lt;gen_guid&gt; ILLIXR::plugin::gen_guid_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-id","title":"variable id","text":"<pre><code>const std::size_t ILLIXR::plugin::id;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-name","title":"variable name","text":"<pre><code>std::string ILLIXR::plugin::name;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-pb","title":"variable pb","text":"<pre><code>const phonebook* ILLIXR::plugin::pb;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-record_logger_","title":"variable record_logger_","text":"<pre><code>const std::shared_ptr&lt;record_logger&gt; ILLIXR::plugin::record_logger_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/plugin.hpp</code></p>"},{"location":"api/structILLIXR_1_1pose__type/","title":"Struct ILLIXR::pose_type","text":"<p>ClassList &gt; ILLIXR &gt; pose_type</p>"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Quaternionf orientation Eigen::Vector3f position time_type time"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1pose__type/#variable-orientation","title":"variable orientation","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_type::orientation;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3f ILLIXR::pose_type::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-time","title":"variable time","text":"<pre><code>time_type ILLIXR::pose_type::time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1reader__latest/","title":"Class ILLIXR::reader_latest","text":"<p>template &lt;typename event&gt;</p> <p>ClassList &gt; ILLIXR &gt; reader_latest</p> <p>A handle which can read the latest event on a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1reader__latest/#public-functions","title":"Public Functions","text":"Type Name virtual event * get_latest () const = 0Gets a mutable copy of the latest value. virtual const event * get_latest_ro () const = 0Gets a \"read-only\" copy of the latest value. virtual ~reader_latest ()"},{"location":"api/classILLIXR_1_1reader__latest/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1reader__latest/#function-get_latest","title":"function get_latest","text":"<p>Gets a mutable copy of the latest value. <pre><code>virtual event * ILLIXR::reader_latest::get_latest () const = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1reader__latest/#function-get_latest_ro","title":"function get_latest_ro","text":"<p>Gets a \"read-only\" copy of the latest value. <pre><code>virtual const event * ILLIXR::reader_latest::get_latest_ro () const = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1reader__latest/#function-reader_latest","title":"function ~reader_latest","text":"<pre><code>inline virtual ILLIXR::reader_latest::~reader_latest () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1record/","title":"Class ILLIXR::record","text":"<p>ClassList &gt; ILLIXR &gt; record</p> <p>This class represents a tuple of fields which get logged by <code>record_logger</code> .More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record/#public-functions","title":"Public Functions","text":"Type Name const record_header &amp; get_record_header () const T get_value (unsigned column) const void mark_used () const record (const record_header &amp; rh_, std::vector&lt; std::any &gt; values_)  ~record ()"},{"location":"api/classILLIXR_1_1record/#detailed-description","title":"Detailed Description","text":"<p><code>rh_</code> is a pointer rather than a reference for historical reasons. It should not be null. </p>"},{"location":"api/classILLIXR_1_1record/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record/#function-get_record_header","title":"function get_record_header","text":"<pre><code>inline const record_header &amp; ILLIXR::record::get_record_header () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-get_value","title":"function get_value","text":"<pre><code>template&lt;typename T&gt;\ninline T ILLIXR::record::get_value (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::record::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record","title":"function record","text":"<pre><code>inline ILLIXR::record::record (\n    const record_header &amp; rh_,\n    std::vector&lt; std::any &gt; values_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record_1","title":"function ~record","text":"<pre><code>inline ILLIXR::record::~record () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__coalescer/","title":"Class ILLIXR::record_coalescer","text":"<p>ClassList &gt; ILLIXR &gt; record_coalescer</p> <p>Coalesces logs of the same type to be written back as a single-transaction. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions","title":"Public Functions","text":"Type Name void flush () Flush buffer of logs to the underlying logger. void log (record r) Appends a log to the buffer, which will eventually be written. void maybe_flush () Use internal decision process, and possibly trigger flush. record_coalescer (std::shared_ptr&lt; record_logger &gt; logger_)  ~record_coalescer ()"},{"location":"api/classILLIXR_1_1record__coalescer/#detailed-description","title":"Detailed Description","text":"<p>Records should all be of the same type. TODO: remove this constraint. Use <code>log&lt;record_type&gt;(Args... args)</code> and <code>std::forward</code>.</p> <p>In some backend-implementations, logging many logs of the same type is more efficient than logging them individually; However, the client often wants to produce one log-record at a time. This class resolves this mismatch by buffering logs from the client. Every time a new log is added, an internal decision process determines whether or not to flush the buffer, or keep accumulating and wait unitl later.</p> <p>Currently this internal decision process is \"is the oldest log in the buffer more than 1 second old?\". I chose this because this frequency should have very little overhead, even if every component is also coalescing at 1 per second.</p> <p>At destructor time, any remaining logs are flushed.</p> <p>Use like:</p> <pre><code>log_coalescer(logger);\nlc.log(make_my_record(id, it, skip_it, ...));\n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__coalescer/#function-flush","title":"function flush","text":"<p>Flush buffer of logs to the underlying logger. <pre><code>inline void ILLIXR::record_coalescer::flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-log","title":"function log","text":"<p>Appends a log to the buffer, which will eventually be written. <pre><code>inline void ILLIXR::record_coalescer::log (\n    record r\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-maybe_flush","title":"function maybe_flush","text":"<p>Use internal decision process, and possibly trigger flush. <pre><code>inline void ILLIXR::record_coalescer::maybe_flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer","title":"function record_coalescer","text":"<pre><code>inline ILLIXR::record_coalescer::record_coalescer (\n    std::shared_ptr&lt; record_logger &gt; logger_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer_1","title":"function ~record_coalescer","text":"<pre><code>inline ILLIXR::record_coalescer::~record_coalescer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__header/","title":"Class ILLIXR::record_header","text":"<p>ClassList &gt; ILLIXR &gt; record_header</p> <p>Schema of each record. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__header/#public-functions","title":"Public Functions","text":"Type Name const std::string &amp; get_column_name (unsigned column) const const std::type_info &amp; get_column_type (unsigned column) const unsigned get_columns () const std::size_t get_id () const const std::string &amp; get_name () const bool operator!= (const record_header &amp; other) const bool operator== (const record_header &amp; other) constCompares two schemata. record_header (std::string name_, std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_)  std::string to_string () const"},{"location":"api/classILLIXR_1_1record__header/#detailed-description","title":"Detailed Description","text":"<p>name_ should be globally unique. </p>"},{"location":"api/classILLIXR_1_1record__header/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__header/#function-get_column_name","title":"function get_column_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_column_name (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_column_type","title":"function get_column_type","text":"<pre><code>inline const std::type_info &amp; ILLIXR::record_header::get_column_type (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_columns","title":"function get_columns","text":"<pre><code>inline unsigned ILLIXR::record_header::get_columns () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_id","title":"function get_id","text":"<pre><code>inline std::size_t ILLIXR::record_header::get_id () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_name","title":"function get_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_name () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator","title":"function operator!=","text":"<pre><code>inline bool ILLIXR::record_header::operator!= (\n    const record_header &amp; other\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator_1","title":"function operator==","text":"<p>Compares two schemata. <pre><code>inline bool ILLIXR::record_header::operator== (\n    const record_header &amp; other\n) const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__header/#function-record_header","title":"function record_header","text":"<pre><code>inline ILLIXR::record_header::record_header (\n    std::string name_,\n    std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string ILLIXR::record_header::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__logger/","title":"Class ILLIXR::record_logger","text":"<p>ClassList &gt; ILLIXR &gt; record_logger</p> <p>The ILLIXR logging service for structured records. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions","title":"Public Functions","text":"Type Name virtual void log (const record &amp; r) = 0Writes one log record. virtual void log (const std::vector&lt; record &gt; &amp; rs) Writes many of the same type of log record. virtual ~record_logger ()"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1record__logger/#detailed-description","title":"Detailed Description","text":"<p>This has two advantages over printf logging. It has lower overhead (because it goes into a database), won't result in spliced messages (no stdout race-conditions), and is used uniformly by ILLIXR components. </p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__logger/#function-log-12","title":"function log [1/2]","text":"<p>Writes one log record. <pre><code>virtual void ILLIXR::record_logger::log (\n    const record &amp; r\n) = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__logger/#function-log-22","title":"function log [2/2]","text":"<p>Writes many of the same type of log record. <pre><code>inline virtual void ILLIXR::record_logger::log (\n    const std::vector&lt; record &gt; &amp; rs\n) \n</code></pre></p> <p>This is more efficient than calling log many times. </p>"},{"location":"api/classILLIXR_1_1record__logger/#function-record_logger","title":"function ~record_logger","text":"<pre><code>inline virtual ILLIXR::record_logger::~record_logger () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendered__frame/","title":"Struct ILLIXR::rendered_frame","text":"<p>ClassList &gt; ILLIXR &gt; rendered_frame</p>"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes","title":"Public Attributes","text":"Type Name pose_type render_pose std::chrono::time_point&lt; std::chrono::system_clock &gt; sample_time GLuint texture_handle"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame/#variable-render_pose","title":"variable render_pose","text":"<pre><code>pose_type ILLIXR::rendered_frame::render_pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-sample_time","title":"variable sample_time","text":"<pre><code>std::chrono::time_point&lt;std::chrono::system_clock&gt; ILLIXR::rendered_frame::sample_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-texture_handle","title":"variable texture_handle","text":"<pre><code>GLuint ILLIXR::rendered_frame::texture_handle;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/","title":"Struct ILLIXR::rendered_frame_alt","text":"<p>ClassList &gt; ILLIXR &gt; rendered_frame_alt</p>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#public-attributes","title":"Public Attributes","text":"Type Name pose_type render_pose std::chrono::time_point&lt; std::chrono::system_clock &gt; sample_time GLuint swap_indices GLuint texture_handles"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-render_pose","title":"variable render_pose","text":"<pre><code>pose_type ILLIXR::rendered_frame_alt::render_pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-sample_time","title":"variable sample_time","text":"<pre><code>std::chrono::time_point&lt;std::chrono::system_clock&gt; ILLIXR::rendered_frame_alt::sample_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-swap_indices","title":"variable swap_indices","text":"<pre><code>GLuint ILLIXR::rendered_frame_alt::swap_indices[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-texture_handles","title":"variable texture_handles","text":"<pre><code>GLuint ILLIXR::rendered_frame_alt::texture_handles[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1rgb__depth__type/","title":"Struct ILLIXR::rgb_depth_type","text":"<p>ClassList &gt; ILLIXR &gt; rgb_depth_type</p>"},{"location":"api/structILLIXR_1_1rgb__depth__type/#public-attributes","title":"Public Attributes","text":"Type Name const unsigned short * depth const unsigned char * rgb int64_t time"},{"location":"api/structILLIXR_1_1rgb__depth__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rgb__depth__type/#variable-depth","title":"variable depth","text":"<pre><code>const unsigned short* ILLIXR::rgb_depth_type::depth;\n</code></pre>"},{"location":"api/structILLIXR_1_1rgb__depth__type/#variable-rgb","title":"variable rgb","text":"<pre><code>const unsigned char* ILLIXR::rgb_depth_type::rgb;\n</code></pre>"},{"location":"api/structILLIXR_1_1rgb__depth__type/#variable-time","title":"variable time","text":"<pre><code>int64_t ILLIXR::rgb_depth_type::time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1runtime/","title":"Class ILLIXR::runtime","text":"<p>ClassList &gt; ILLIXR &gt; runtime</p>"},{"location":"api/classILLIXR_1_1runtime/#public-functions","title":"Public Functions","text":"Type Name virtual void load_plugin_factory (plugin_factory plugin) = 0 virtual void load_so (std::string_view so) = 0 virtual void stop () = 0 virtual void wait () = 0 virtual ~runtime ()"},{"location":"api/classILLIXR_1_1runtime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1runtime/#function-load_plugin_factory","title":"function load_plugin_factory","text":"<pre><code>virtual void ILLIXR::runtime::load_plugin_factory (\n    plugin_factory plugin\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_so","title":"function load_so","text":"<pre><code>virtual void ILLIXR::runtime::load_so (\n    std::string_view so\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-stop","title":"function stop","text":"<pre><code>virtual void ILLIXR::runtime::stop () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-wait","title":"function wait","text":"<pre><code>virtual void ILLIXR::runtime::wait () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-runtime","title":"function ~runtime","text":"<pre><code>inline virtual ILLIXR::runtime::~runtime () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/runtime.hpp</code></p>"},{"location":"api/classILLIXR_1_1start__end__logger/","title":"Class ILLIXR::start_end_logger","text":"<p>ClassList &gt; ILLIXR &gt; start_end_logger</p> <p>a utility for logging to start and end times to a file </p> <ul> <li><code>#include &lt;logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1start__end__logger/#public-functions","title":"Public Functions","text":"Type Name int log_end (std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time)  int log_start (std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time)  start_end_logger (std::string component_name)  ~start_end_logger ()"},{"location":"api/classILLIXR_1_1start__end__logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1start__end__logger/#function-log_end","title":"function log_end","text":"<pre><code>inline int ILLIXR::start_end_logger::log_end (\n    std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-log_start","title":"function log_start","text":"<pre><code>inline int ILLIXR::start_end_logger::log_start (\n    std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-start_end_logger","title":"function start_end_logger","text":"<pre><code>inline ILLIXR::start_end_logger::start_end_logger (\n    std::string component_name\n) \n</code></pre> <p>Log apperas in <code>log/$component_name</code>. </p>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-start_end_logger_1","title":"function ~start_end_logger","text":"<pre><code>inline ILLIXR::start_end_logger::~start_end_logger () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard/","title":"Class ILLIXR::switchboard","text":"<p>ClassList &gt; ILLIXR &gt; switchboard</p> <p>A manager for typesafe, threadsafe, named event-streams (called topics). More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1switchboard/#public-functions","title":"Public Functions","text":"Type Name std::unique_ptr&lt; writer&lt; event &gt; &gt; publish (const std::string &amp; topic_name) Gets a handle to publish to the topic <code>topic_name</code> . void schedule (std::string account_name, std::string topic_name, std::function&lt; void(const event *)&gt; fn) Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . virtual void stop () = 0 std::unique_ptr&lt; reader_latest&lt; event &gt; &gt; subscribe_latest (const std::string &amp; topic_name) Gets a handle to read to the latest value from the topic <code>topic_name</code> . virtual ~switchboard ()"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1switchboard/#detailed-description","title":"Detailed Description","text":"<ul> <li>Writing: One can write to a topic (in any thread) through the <code>ILLIXR::writer</code> returned by <code>publish()</code>.</li> <li>There are two ways of reading: asynchronous reading and synchronous reading:</li> <li>Asynchronous reading returns the most-recent event on the topic (idempotently). One can do this through (in any thread) the <code>ILLIXR::reader_latest</code> handle returned by <code>subscribe_latest()</code>.</li> <li>Synchronous reading schedules a callback to be executed on every event which gets published. One can schedule computation by <code>schedule()</code>, which will run the computation in a thread managed by switchboard.</li> </ul> <pre><code>void do_stuff(switchboard* sb) {\n    auto topic1 = sb-&gt;subscribe_latest&lt;topic1_type&gt;(\"topic1\");\n    auto topic2 = sb-&gt;publish&lt;topic2_type&gt;(\"topic2\");\n\n    // Read topic 3 synchronously\n    sb-&gt;schedule&lt;topic3_type&gt;(\"topic3\", [&amp;](const topic3_type *event3) {\n        // This is a lambda expression\n        // https://en.cppreference.com/w/cpp/language/lambda\n        std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n    });\n\n    while (true) {\n        // Read topic 1\n        topic1_type* event1 = topic1.get_latest_ro();\n\n        // Write to topic 2\n        topic2_type* event2 = new topic2_type;\n        topic2.put(event2);\n    }\n}\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#function-publish","title":"function publish","text":"<p>Gets a handle to publish to the topic <code>topic_name</code> . <pre><code>template&lt;typename event&gt;\ninline std::unique_ptr&lt; writer &lt; event &gt; &gt; ILLIXR::switchboard::publish (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-schedule","title":"function schedule","text":"<p>Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . <pre><code>template&lt;typename event&gt;\ninline void ILLIXR::switchboard::schedule (\n    std::string account_name,\n    std::string topic_name,\n    std::function&lt; void(const event *)&gt; fn\n) \n</code></pre></p> <p>Switchboard maintains a threadpool to call <code>fn</code>. It is possible multiple instances of <code>fn</code> will be running concurrently if the event's repetition period is less than the runtime of <code>fn</code>.</p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>if</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-stop","title":"function stop","text":"<pre><code>virtual void ILLIXR::switchboard::stop () = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#function-subscribe_latest","title":"function subscribe_latest","text":"<p>Gets a handle to read to the latest value from the topic <code>topic_name</code> . <pre><code>template&lt;typename event&gt;\ninline std::unique_ptr&lt; reader_latest &lt; event &gt; &gt; ILLIXR::switchboard::subscribe_latest (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-switchboard","title":"function ~switchboard","text":"<pre><code>inline virtual ILLIXR::switchboard::~switchboard () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1threadloop/","title":"Class ILLIXR::threadloop","text":"<p>ClassList &gt; ILLIXR &gt; threadloop</p> <p>A reusable threadloop for plugins. More...</p> <ul> <li><code>#include &lt;threadloop.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions","title":"Public Functions","text":"Type Name virtual void start () overrideStarts the thread. virtual void stop () overrideStops the thread. threadloop (std::string name_, phonebook * pb_)  virtual ~threadloop () override"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name ()  plugin (const std::string &amp; name_, phonebook * pb_)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it starts the component. virtual ~plugin ()"},{"location":"api/classILLIXR_1_1threadloop/#protected-types","title":"Protected Types","text":"Type Name enum skip_option"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes","title":"Protected Attributes","text":"Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id std::string name const phonebook * pb const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions","title":"Protected Functions","text":"Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1threadloop/#detailed-description","title":"Detailed Description","text":"<p>The thread continuously runs <code>_p_one_iteration()</code> and is stopable by <code>stop()</code>.</p> <p>This factors out the common code I noticed in many different plugins. </p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-start","title":"function start","text":"<p>Starts the thread. <pre><code>inline virtual void ILLIXR::threadloop::start () override\n</code></pre></p> <p>Implements ILLIXR::plugin::start</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-stop","title":"function stop","text":"<p>Stops the thread. <pre><code>inline virtual void ILLIXR::threadloop::stop () override\n</code></pre></p> <p>Implements ILLIXR::plugin::stop</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop","title":"function threadloop","text":"<pre><code>inline ILLIXR::threadloop::threadloop (\n    std::string name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop_1","title":"function ~threadloop","text":"<pre><code>inline virtual ILLIXR::threadloop::~threadloop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#enum-skip_option","title":"enum skip_option","text":"<pre><code>enum ILLIXR::threadloop::skip_option {\n    run,\n    skip_and_spin,\n    skip_and_yield,\n    stop\n};\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#variable-iteration_no","title":"variable iteration_no","text":"<pre><code>std::size_t ILLIXR::threadloop::iteration_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#variable-skip_no","title":"variable skip_no","text":"<pre><code>std::size_t ILLIXR::threadloop::skip_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Override with the computation the thread does every loop. <pre><code>virtual void ILLIXR::threadloop::_p_one_iteration () = 0\n</code></pre></p> <p>This gets called in rapid succession. </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_should_skip","title":"function _p_should_skip","text":"<p>Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ <pre><code>inline virtual skip_option ILLIXR::threadloop::_p_should_skip () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<p>Gets called at setup time, from the new thread. <pre><code>inline virtual void ILLIXR::threadloop::_p_thread_setup () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-should_terminate","title":"function should_terminate","text":"<p>Whether the thread has been asked to terminate. <pre><code>inline bool ILLIXR::threadloop::should_terminate () \n</code></pre></p> <p>Check this before doing long-running computation; it makes termination more responsive. </p> <p>The documentation for this class was generated from the following file <code>common/threadloop.hpp</code></p>"},{"location":"api/classILLIXR_1_1writer/","title":"Class ILLIXR::writer","text":"<p>template &lt;typename event&gt;</p> <p>ClassList &gt; ILLIXR &gt; writer</p> <p>A handle which can publish events to a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1writer/#public-functions","title":"Public Functions","text":"Type Name virtual event * allocate () = 0Like <code>new</code> /<code>malloc</code> but more efficient for the specific case. virtual void put (const event * ev) = 0Publish <code>ev</code> to this topic. virtual ~writer ()"},{"location":"api/classILLIXR_1_1writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1writer/#function-allocate","title":"function allocate","text":"<p>Like <code>new</code> /<code>malloc</code> but more efficient for the specific case. <pre><code>virtual event * ILLIXR::writer::allocate () = 0\n</code></pre></p> <p>There is an optimization available which has not yet been implemented: switchboard can memory from old events, like a slab allocator. Suppose module A publishes data for module B. B's deallocation through the destructor, and A's allocation through this method completes the cycle in a double-buffer (AKA swap-chain). </p>"},{"location":"api/classILLIXR_1_1writer/#function-put","title":"function put","text":"<p>Publish <code>ev</code> to this topic. <pre><code>virtual void ILLIXR::writer::put (\n    const event * ev\n) = 0\n</code></pre></p> <p>Currently, nobody is responsible for calling <code>delete</code> on it, but this will change. </p>"},{"location":"api/classILLIXR_1_1writer/#function-writer","title":"function ~writer","text":"<pre><code>inline virtual ILLIXR::writer::~writer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/","title":"Class ILLIXR::xlib_gl_extended_window","text":"<p>ClassList &gt; ILLIXR &gt; xlib_gl_extended_window</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes","title":"Public Attributes","text":"Type Name Display * dpy GLXContext glc int height int width Window win"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions","title":"Public Functions","text":"Type Name xlib_gl_extended_window (int _width, int _height, GLXContext _shared_gl_context)"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-dpy","title":"variable dpy","text":"<pre><code>Display* ILLIXR::xlib_gl_extended_window::dpy;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-glc","title":"variable glc","text":"<pre><code>GLXContext ILLIXR::xlib_gl_extended_window::glc;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-height","title":"variable height","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::height;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-width","title":"variable width","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::width;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-win","title":"variable win","text":"<pre><code>Window ILLIXR::xlib_gl_extended_window::win;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window","title":"function xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::xlib_gl_extended_window (\n    int _width,\n    int _height,\n    GLXContext _shared_gl_context\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/extended_window.hpp</code></p>"},{"location":"api/namespacelinalg/","title":"Namespace linalg","text":"<p>Namespace List &gt; linalg</p>"},{"location":"api/namespacelinalg/#namespaces","title":"Namespaces","text":"Type Name namespace aliases namespace detail namespace ostream_overloads"},{"location":"api/namespacelinalg/#classes","title":"Classes","text":"Type Name struct converter &lt;class T, class U&gt; struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; &lt;class T&gt; struct identity_t struct mat &lt;class T, M, N&gt; struct mat&lt; T, M, 1 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 2 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 3 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 4 &gt; &lt;class T, M&gt; struct vec &lt;class T, M&gt; struct vec&lt; T, 1 &gt; &lt;class T&gt; struct vec&lt; T, 2 &gt; &lt;class T&gt; struct vec&lt; T, 3 &gt; &lt;class T&gt; struct vec&lt; T, 4 &gt; &lt;class T&gt;"},{"location":"api/namespacelinalg/#public-types","title":"Public Types","text":"Type Name typedef typename detail::apply&lt; F, void, A... &gt;::type apply_t enum fwd_axis typedef typename detail::scalar_type&lt; A &gt;::type scalar_t enum z_range"},{"location":"api/namespacelinalg/#public-attributes","title":"Public Attributes","text":"Type Name constexpr identity_t identity   = <code>{1}</code>"},{"location":"api/namespacelinalg/#public-functions","title":"Public Functions","text":"Type Name apply_t&lt; detail::std_abs, A &gt; abs (const A &amp; a)  apply_t&lt; detail::std_acos, A &gt; acos (const A &amp; a)  constexpr mat&lt; T, 1, 1 &gt; adjugate (const mat&lt; T, 1, 1 &gt; &amp;)  constexpr mat&lt; T, 2, 2 &gt; adjugate (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr mat&lt; T, 3, 3 &gt; adjugate (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr mat&lt; T, 4, 4 &gt; adjugate (const mat&lt; T, 4, 4 &gt; &amp; a)  constexpr bool all (const A &amp; a)  T angle (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr bool any (const A &amp; a)  constexpr apply_t&lt; F, A... &gt; apply (F func, const A &amp;... args)  int argmax (const vec&lt; T, M &gt; &amp; a)  int argmin (const vec&lt; T, M &gt; &amp; a)  apply_t&lt; detail::std_asin, A &gt; asin (const A &amp; a)  apply_t&lt; detail::std_atan, A &gt; atan (const A &amp; a)  apply_t&lt; detail::std_atan2, A, B &gt; atan2 (const A &amp; a, const B &amp; b)  T * begin (vec&lt; T, M &gt; &amp; a)  const T * begin (const vec&lt; T, M &gt; &amp; a)  vec&lt; T, M &gt; * begin (mat&lt; T, M, N &gt; &amp; a)  const vec&lt; T, M &gt; * begin (const mat&lt; T, M, N &gt; &amp; a)  apply_t&lt; detail::std_ceil, A &gt; ceil (const A &amp; a)  constexpr apply_t&lt; detail::clamp, X, L, H &gt; clamp (const X &amp; x, const L &amp; l, const H &amp; h)  constexpr mat&lt; T, N, N &gt; comatrix (const mat&lt; T, N, N &gt; &amp; a)  constexpr detail::any_compare&lt; A, B &gt;::type compare (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_copysign, A, B &gt; copysign (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_cos, A &gt; cos (const A &amp; a)  apply_t&lt; detail::std_cosh, A &gt; cosh (const A &amp; a)  constexpr T cross (const vec&lt; T, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, 2 &gt; cross (T a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, 2 &gt; cross (const vec&lt; T, 2 &gt; &amp; a, T b)  constexpr vec&lt; T, 3 &gt; cross (const vec&lt; T, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr T determinant (const mat&lt; T, 1, 1 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 4, 4 &gt; &amp; a)  constexpr vec&lt; T, 1 &gt; diagonal (const mat&lt; T, 1, 1 &gt; &amp; a)  constexpr vec&lt; T, 2 &gt; diagonal (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr vec&lt; T, 3 &gt; diagonal (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr vec&lt; T, 4 &gt; diagonal (const mat&lt; T, 4, 4 &gt; &amp; a)  T distance (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr T distance2 (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr T dot (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  T * end (vec&lt; T, M &gt; &amp; a)  const T * end (const vec&lt; T, M &gt; &amp; a)  vec&lt; T, M &gt; * end (mat&lt; T, M, N &gt; &amp; a)  const vec&lt; T, M &gt; * end (const mat&lt; T, M, N &gt; &amp; a)  constexpr apply_t&lt; detail::op_eq, A, B &gt; equal (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_exp, A &gt; exp (const A &amp; a)  apply_t&lt; detail::std_floor, A &gt; floor (const A &amp; a)  apply_t&lt; detail::std_fmod, A, B &gt; fmod (const A &amp; a, const B &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 1 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 2 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 3 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 4 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 1 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 2 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 3 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 4 &gt; &amp; b)  mat&lt; T, 4, 4 &gt; frustum_matrix (T x0, T x1, T y0, T y1, T n, T f, fwd_axis a=neg_z, z_range z=neg_one_to_one)  constexpr apply_t&lt; detail::op_ge, A, B &gt; gequal (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_gt, A, B &gt; greater (const A &amp; a, const B &amp; b)  constexpr mat&lt; T, N, N &gt; inverse (const mat&lt; T, N, N &gt; &amp; a)  T length (const vec&lt; T, M &gt; &amp; a)  constexpr T length2 (const vec&lt; T, M &gt; &amp; a)  constexpr apply_t&lt; detail::op_le, A, B &gt; lequal (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::lerp, A, B, T &gt; lerp (const A &amp; a, const B &amp; b, const T &amp; t)  constexpr apply_t&lt; detail::op_lt, A, B &gt; less (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_log, A &gt; log (const A &amp; a)  apply_t&lt; detail::std_log10, A &gt; log10 (const A &amp; a)  constexpr apply_t&lt; F, A &gt; map (const A &amp; a, F func)  constexpr apply_t&lt; detail::max, A, B &gt; max (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; maxelem (const A &amp; a)  constexpr apply_t&lt; detail::min, A, B &gt; min (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; minelem (const A &amp; a)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 1 &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  constexpr mat&lt; T, M, 1 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 1 &gt; &amp; b)  constexpr mat&lt; T, M, 2 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 2 &gt; &amp; b)  constexpr mat&lt; T, M, 3 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 3 &gt; &amp; b)  constexpr mat&lt; T, M, 4 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 4 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const vec&lt; T, P &gt; &amp; c)  constexpr mat&lt; T, M, Q &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c, const vec&lt; T, Q &gt; &amp; d)  constexpr mat&lt; T, M, R &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c, const mat&lt; T, Q, R &gt; &amp; d)  constexpr apply_t&lt; detail::op_ne, A, B &gt; nequal (const A &amp; a, const B &amp; b)  vec&lt; T, M &gt; nlerp (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b, T t)  vec&lt; T, M &gt; normalize (const vec&lt; T, M &gt; &amp; a)  constexpr apply_t&lt; detail::op_not, A &gt; operator! (const A &amp; a)  virtual constexpr auto operator!= (const A &amp; a, const B &amp; b) = 0 constexpr apply_t&lt; detail::op_mod, A, B &gt; operator% (const A &amp; a, const B &amp; b)  constexpr auto operator%= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_int, A, B &gt; operator&amp; (const A &amp; a, const B &amp; b)  constexpr auto operator&amp;= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_mul, A, B &gt; operator* (const A &amp; a, const B &amp; b)  constexpr auto operator*= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_pos, A &gt; operator+ (const A &amp; a)  constexpr apply_t&lt; detail::op_add, A, B &gt; operator+ (const A &amp; a, const B &amp; b)  constexpr auto operator+= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_neg, A &gt; operator- (const A &amp; a)  constexpr apply_t&lt; detail::op_sub, A, B &gt; operator- (const A &amp; a, const B &amp; b)  constexpr auto operator-= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_div, A, B &gt; operator/ (const A &amp; a, const B &amp; b)  constexpr auto operator/= (A &amp; a, const B &amp; b)  constexpr auto operator&lt; (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_lsh, A, B &gt; operator&lt;&lt; (const A &amp; a, const B &amp; b)  constexpr auto operator&lt;&lt;= (A &amp; a, const B &amp; b)  virtual constexpr auto operator&lt;= (const A &amp; a, const B &amp; b) = 0 virtual constexpr auto operator== (const A &amp; a, const B &amp; b) = 0 constexpr auto operator&gt; (const A &amp; a, const B &amp; b)  virtual constexpr auto operator&gt;= (const A &amp; a, const B &amp; b) = 0 constexpr apply_t&lt; detail::op_rsh, A, B &gt; operator&gt;&gt; (const A &amp; a, const B &amp; b)  constexpr auto operator&gt;&gt;= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_xor, A, B &gt; operator^ (const A &amp; a, const B &amp; b)  constexpr auto operator^= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_un, A, B &gt; operator| (const A &amp; a, const B &amp; b)  constexpr auto operator|= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_cmp, A &gt; operator~ (const A &amp; a)  constexpr mat&lt; T, M, 1 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b)  constexpr mat&lt; T, M, 2 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr mat&lt; T, M, 3 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr mat&lt; T, M, 4 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  mat&lt; T, 4, 4 &gt; perspective_matrix (T fovy, T aspect, T n, T f, fwd_axis a=neg_z, z_range z=neg_one_to_one)  mat&lt; T, 4, 4 &gt; pose_matrix (const vec&lt; T, 4 &gt; &amp; q, const vec&lt; T, 3 &gt; &amp; p)  apply_t&lt; detail::std_pow, A, B &gt; pow (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; product (const A &amp; a)  T qangle (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 3 &gt; qaxis (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 4 &gt; qconj (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qexp (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qinv (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qlog (const vec&lt; T, 4 &gt; &amp; q)  constexpr mat&lt; T, 3, 3 &gt; qmat (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 4 &gt; qmul (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  constexpr vec&lt; T, 4 &gt; qmul (const vec&lt; T, 4 &gt; &amp; a, R... r)  vec&lt; T, 4 &gt; qnlerp (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b, T t)  vec&lt; T, 4 &gt; qpow (const vec&lt; T, 4 &gt; &amp; q, const T &amp; p)  constexpr vec&lt; T, 3 &gt; qrot (const vec&lt; T, 4 &gt; &amp; q, const vec&lt; T, 3 &gt; &amp; v)  vec&lt; T, 4 &gt; qslerp (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b, T t)  constexpr vec&lt; T, 3 &gt; qxdir (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 3 &gt; qydir (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 3 &gt; qzdir (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 2 &gt; rot (T a, const vec&lt; T, 2 &gt; &amp; v)  mat&lt; T, 4, 4 &gt; rotation_matrix (const vec&lt; T, 4 &gt; &amp; rotation)  vec&lt; T, 4 &gt; rotation_quat (const vec&lt; T, 3 &gt; &amp; axis, T angle)  vec&lt; T, 4 &gt; rotation_quat (const mat&lt; T, 3, 3 &gt; &amp; m)  apply_t&lt; detail::std_round, A &gt; round (const A &amp; a)  mat&lt; T, 4, 4 &gt; scaling_matrix (const vec&lt; T, 3 &gt; &amp; scaling)  constexpr apply_t&lt; detail::select, P, A, B &gt; select (const P &amp; p, const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_sin, A &gt; sin (const A &amp; a)  apply_t&lt; detail::std_sinh, A &gt; sinh (const A &amp; a)  vec&lt; T, M &gt; slerp (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b, T t)  apply_t&lt; detail::std_sqrt, A &gt; sqrt (const A &amp; a)  constexpr mat&lt; T, I1-I0, J1-J0 &gt; submat (const mat&lt; T, M, N &gt; &amp; a)  constexpr vec&lt; T, I1-I0 &gt; subvec (const vec&lt; T, M &gt; &amp; a)  constexpr scalar_t&lt; A &gt; sum (const A &amp; a)  constexpr vec&lt; T, sizeof...(I)&gt; swizzle (const vec&lt; T, M &gt; &amp; a)  apply_t&lt; detail::std_tan, A &gt; tan (const A &amp; a)  apply_t&lt; detail::std_tanh, A &gt; tanh (const A &amp; a)  constexpr T trace (const mat&lt; T, N, N &gt; &amp; a)  mat&lt; T, 4, 4 &gt; translation_matrix (const vec&lt; T, 3 &gt; &amp; translation)  constexpr mat&lt; T, M, 1 &gt; transpose (const mat&lt; T, 1, M &gt; &amp; m)  constexpr mat&lt; T, M, 2 &gt; transpose (const mat&lt; T, 2, M &gt; &amp; m)  constexpr mat&lt; T, M, 3 &gt; transpose (const mat&lt; T, 3, M &gt; &amp; m)  constexpr mat&lt; T, M, 4 &gt; transpose (const mat&lt; T, 4, M &gt; &amp; m)  T uangle (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr apply_t&lt; F, A, B &gt; zip (const A &amp; a, const B &amp; b, F func)"},{"location":"api/namespacelinalg/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg/#typedef-apply_t","title":"typedef apply_t","text":"<pre><code>using linalg::apply_t = typedef typename detail::apply&lt;F,void,A...&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg/#enum-fwd_axis","title":"enum fwd_axis","text":"<pre><code>enum linalg::fwd_axis {\n    neg_z,\n    pos_z\n};\n</code></pre>"},{"location":"api/namespacelinalg/#typedef-scalar_t","title":"typedef scalar_t","text":"<pre><code>using linalg::scalar_t = typedef typename detail::scalar_type&lt;A&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg/#enum-z_range","title":"enum z_range","text":"<pre><code>enum linalg::z_range {\n    neg_one_to_one,\n    zero_to_one\n};\n</code></pre>"},{"location":"api/namespacelinalg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacelinalg/#variable-identity","title":"variable identity","text":"<pre><code>constexpr identity_t linalg::identity;\n</code></pre>"},{"location":"api/namespacelinalg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg/#function-abs","title":"function abs","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_abs, A &gt; linalg::abs (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-acos","title":"function acos","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_acos, A &gt; linalg::acos (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 1, 1 &gt; linalg::adjugate (\n    const mat&lt; T, 1, 1 &gt; &amp;\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_1","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 2, 2 &gt; linalg::adjugate (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_2","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 3, 3 &gt; linalg::adjugate (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_3","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 4, 4 &gt; linalg::adjugate (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-all","title":"function all","text":"<pre><code>template&lt;class A&gt;\nconstexpr bool linalg::all (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-angle","title":"function angle","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::angle (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-any","title":"function any","text":"<pre><code>template&lt;class A&gt;\nconstexpr bool linalg::any (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-apply","title":"function apply","text":"<pre><code>template&lt;class F, class... A&gt;\nconstexpr apply_t&lt; F, A... &gt; linalg::apply (\n    F func,\n    const A &amp;... args\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-argmax","title":"function argmax","text":"<pre><code>template&lt;class T, int M&gt;\nint linalg::argmax (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-argmin","title":"function argmin","text":"<pre><code>template&lt;class T, int M&gt;\nint linalg::argmin (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-asin","title":"function asin","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_asin, A &gt; linalg::asin (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-atan","title":"function atan","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_atan, A &gt; linalg::atan (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-atan2","title":"function atan2","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_atan2, A, B &gt; linalg::atan2 (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin","title":"function begin","text":"<pre><code>template&lt;class T, int M&gt;\nT * linalg::begin (\n    vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_1","title":"function begin","text":"<pre><code>template&lt;class T, int M&gt;\nconst T * linalg::begin (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_2","title":"function begin","text":"<pre><code>template&lt;class T, int M, int N&gt;\nvec&lt; T, M &gt; * linalg::begin (\n    mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_3","title":"function begin","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconst vec&lt; T, M &gt; * linalg::begin (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-ceil","title":"function ceil","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_ceil, A &gt; linalg::ceil (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-clamp","title":"function clamp","text":"<pre><code>template&lt;class X, class L, class H&gt;\nconstexpr apply_t&lt; detail::clamp, X, L, H &gt; linalg::clamp (\n    const X &amp; x,\n    const L &amp; l,\n    const H &amp; h\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-comatrix","title":"function comatrix","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr mat&lt; T, N, N &gt; linalg::comatrix (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-compare","title":"function compare","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr detail::any_compare&lt; A, B &gt;::type linalg::compare (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-copysign","title":"function copysign","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_copysign, A, B &gt; linalg::copysign (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cos","title":"function cos","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_cos, A &gt; linalg::cos (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cosh","title":"function cosh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_cosh, A &gt; linalg::cosh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::cross (\n    const vec&lt; T, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_1","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::cross (\n    T a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_2","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::cross (\n    const vec&lt; T, 2 &gt; &amp; a,\n    T b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_3","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::cross (\n    const vec&lt; T, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 1, 1 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_1","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_2","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_3","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 1 &gt; linalg::diagonal (\n    const mat&lt; T, 1, 1 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_1","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::diagonal (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_2","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::diagonal (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_3","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::diagonal (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-distance","title":"function distance","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::distance (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-distance2","title":"function distance2","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::distance2 (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-dot","title":"function dot","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::dot (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end","title":"function end","text":"<pre><code>template&lt;class T, int M&gt;\nT * linalg::end (\n    vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_1","title":"function end","text":"<pre><code>template&lt;class T, int M&gt;\nconst T * linalg::end (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_2","title":"function end","text":"<pre><code>template&lt;class T, int M, int N&gt;\nvec&lt; T, M &gt; * linalg::end (\n    mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_3","title":"function end","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconst vec&lt; T, M &gt; * linalg::end (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-equal","title":"function equal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_eq, A, B &gt; linalg::equal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-exp","title":"function exp","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_exp, A &gt; linalg::exp (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-floor","title":"function floor","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_floor, A &gt; linalg::floor (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fmod","title":"function fmod","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_fmod, A, B &gt; linalg::fmod (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_1","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_2","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_3","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_4","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_5","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_6","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_7","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-frustum_matrix","title":"function frustum_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::frustum_matrix (\n    T x0,\n    T x1,\n    T y0,\n    T y1,\n    T n,\n    T f,\n    fwd_axis a=neg_z,\n    z_range z=neg_one_to_one\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-gequal","title":"function gequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_ge, A, B &gt; linalg::gequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-greater","title":"function greater","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_gt, A, B &gt; linalg::greater (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-inverse","title":"function inverse","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr mat&lt; T, N, N &gt; linalg::inverse (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-length","title":"function length","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::length (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-length2","title":"function length2","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::length2 (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-lequal","title":"function lequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_le, A, B &gt; linalg::lequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-lerp","title":"function lerp","text":"<pre><code>template&lt;class A, class B, class T&gt;\nconstexpr apply_t&lt; detail::lerp, A, B, T &gt; linalg::lerp (\n    const A &amp; a,\n    const B &amp; b,\n    const T &amp; t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-less","title":"function less","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_lt, A, B &gt; linalg::less (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-log","title":"function log","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_log, A &gt; linalg::log (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-log10","title":"function log10","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_log10, A &gt; linalg::log10 (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-map","title":"function map","text":"<pre><code>template&lt;class A, class F&gt;\nconstexpr apply_t&lt; F, A &gt; linalg::map (\n    const A &amp; a,\n    F func\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-max","title":"function max","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::max, A, B &gt; linalg::max (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-maxelem","title":"function maxelem","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::maxelem (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-min","title":"function min","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::min, A, B &gt; linalg::min (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-minelem","title":"function minelem","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::minelem (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 1 &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_1","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_2","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_3","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_4","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_5","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_6","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_7","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_8","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const vec&lt; T, P &gt; &amp; c\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_9","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q&gt;\nconstexpr mat&lt; T, M, Q &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_10","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c,\n    const vec&lt; T, Q &gt; &amp; d\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_11","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q, int R&gt;\nconstexpr mat&lt; T, M, R &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c,\n    const mat&lt; T, Q, R &gt; &amp; d\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-nequal","title":"function nequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_ne, A, B &gt; linalg::nequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-nlerp","title":"function nlerp","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::nlerp (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-normalize","title":"function normalize","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::normalize (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator","title":"function operator!","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_not, A &gt; linalg::operator! (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_1","title":"function operator!=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator!= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_2","title":"function operator%","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_mod, A, B &gt; linalg::operator% (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_3","title":"function operator%=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator%= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_4","title":"function operator&amp;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_int, A, B &gt; linalg::operator&amp; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_5","title":"function operator&amp;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&amp;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_6","title":"function operator*","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_mul, A, B &gt; linalg::operator* (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_7","title":"function operator*=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator*= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_8","title":"function operator+","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_pos, A &gt; linalg::operator+ (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_9","title":"function operator+","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_add, A, B &gt; linalg::operator+ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_10","title":"function operator+=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator+= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-","title":"function operator-","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_neg, A &gt; linalg::operator- (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-_1","title":"function operator-","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_sub, A, B &gt; linalg::operator- (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-_2","title":"function operator-=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator-= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_11","title":"function operator/","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_div, A, B &gt; linalg::operator/ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_12","title":"function operator/=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator/= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_13","title":"function operator&lt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&lt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_14","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_lsh, A, B &gt; linalg::operator&lt;&lt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_15","title":"function operator&lt;&lt;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&lt;&lt;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_16","title":"function operator&lt;=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator&lt;= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_17","title":"function operator==","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator== (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_18","title":"function operator&gt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&gt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_19","title":"function operator&gt;=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator&gt;= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_20","title":"function operator&gt;&gt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_rsh, A, B &gt; linalg::operator&gt;&gt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_21","title":"function operator&gt;&gt;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&gt;&gt;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_22","title":"function operator^","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_xor, A, B &gt; linalg::operator^ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_23","title":"function operator^=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator^= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_24","title":"function operator|","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_un, A, B &gt; linalg::operator| (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_25","title":"function operator|=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator|= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_26","title":"function operator~","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_cmp, A &gt; linalg::operator~ (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_1","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_2","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_3","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-perspective_matrix","title":"function perspective_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::perspective_matrix (\n    T fovy,\n    T aspect,\n    T n,\n    T f,\n    fwd_axis a=neg_z,\n    z_range z=neg_one_to_one\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-pose_matrix","title":"function pose_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::pose_matrix (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const vec&lt; T, 3 &gt; &amp; p\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-pow","title":"function pow","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_pow, A, B &gt; linalg::pow (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-product","title":"function product","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::product (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qangle","title":"function qangle","text":"<pre><code>template&lt;class T&gt;\nT linalg::qangle (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qaxis","title":"function qaxis","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 3 &gt; linalg::qaxis (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qconj","title":"function qconj","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qconj (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qexp","title":"function qexp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qexp (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qinv","title":"function qinv","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qinv (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qlog","title":"function qlog","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qlog (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmat","title":"function qmat","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 3, 3 &gt; linalg::qmat (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmul","title":"function qmul","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qmul (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmul_1","title":"function qmul","text":"<pre><code>template&lt;class T, class... R&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qmul (\n    const vec&lt; T, 4 &gt; &amp; a,\n    R... r\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qnlerp","title":"function qnlerp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qnlerp (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qpow","title":"function qpow","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qpow (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const T &amp; p\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qrot","title":"function qrot","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qrot (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const vec&lt; T, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qslerp","title":"function qslerp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qslerp (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qxdir","title":"function qxdir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qxdir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qydir","title":"function qydir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qydir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qzdir","title":"function qzdir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qzdir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rot","title":"function rot","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 2 &gt; linalg::rot (\n    T a,\n    const vec&lt; T, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_matrix","title":"function rotation_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::rotation_matrix (\n    const vec&lt; T, 4 &gt; &amp; rotation\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_quat","title":"function rotation_quat","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::rotation_quat (\n    const vec&lt; T, 3 &gt; &amp; axis,\n    T angle\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_quat_1","title":"function rotation_quat","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::rotation_quat (\n    const mat&lt; T, 3, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-round","title":"function round","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_round, A &gt; linalg::round (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-scaling_matrix","title":"function scaling_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::scaling_matrix (\n    const vec&lt; T, 3 &gt; &amp; scaling\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-select","title":"function select","text":"<pre><code>template&lt;class P, class A, class B&gt;\nconstexpr apply_t&lt; detail::select, P, A, B &gt; linalg::select (\n    const P &amp; p,\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sin","title":"function sin","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sin, A &gt; linalg::sin (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sinh","title":"function sinh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sinh, A &gt; linalg::sinh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-slerp","title":"function slerp","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::slerp (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sqrt","title":"function sqrt","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sqrt, A &gt; linalg::sqrt (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-submat","title":"function submat","text":"<pre><code>template&lt;int I0, int J0, int I1, int J1, class T, int M, int N&gt;\nconstexpr mat&lt; T, I1-I0, J1-J0 &gt; linalg::submat (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-subvec","title":"function subvec","text":"<pre><code>template&lt;int I0, int I1, class T, int M&gt;\nconstexpr vec&lt; T, I1-I0 &gt; linalg::subvec (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sum","title":"function sum","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::sum (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-swizzle","title":"function swizzle","text":"<pre><code>template&lt;int... I, class T, int M&gt;\nconstexpr vec&lt; T, sizeof...(I)&gt; linalg::swizzle (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-tan","title":"function tan","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_tan, A &gt; linalg::tan (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-tanh","title":"function tanh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_tanh, A &gt; linalg::tanh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-trace","title":"function trace","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr T linalg::trace (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-translation_matrix","title":"function translation_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::translation_matrix (\n    const vec&lt; T, 3 &gt; &amp; translation\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::transpose (\n    const mat&lt; T, 1, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_1","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::transpose (\n    const mat&lt; T, 2, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_2","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::transpose (\n    const mat&lt; T, 3, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_3","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::transpose (\n    const mat&lt; T, 4, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-uangle","title":"function uangle","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::uangle (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-zip","title":"function zip","text":"<pre><code>template&lt;class A, class B, class F&gt;\nconstexpr apply_t&lt; F, A, B &gt; linalg::zip (\n    const A &amp; a,\n    const B &amp; b,\n    F func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1aliases/","title":"Namespace linalg::aliases","text":"<p>Namespace List &gt; linalg &gt; aliases</p>"},{"location":"api/namespacelinalg_1_1aliases/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; bool, 1 &gt; bool1 typedef mat&lt; bool, 1, 1 &gt; bool1x1 typedef mat&lt; bool, 1, 2 &gt; bool1x2 typedef mat&lt; bool, 1, 3 &gt; bool1x3 typedef mat&lt; bool, 1, 4 &gt; bool1x4 typedef vec&lt; bool, 2 &gt; bool2 typedef mat&lt; bool, 2, 1 &gt; bool2x1 typedef mat&lt; bool, 2, 2 &gt; bool2x2 typedef mat&lt; bool, 2, 3 &gt; bool2x3 typedef mat&lt; bool, 2, 4 &gt; bool2x4 typedef vec&lt; bool, 3 &gt; bool3 typedef mat&lt; bool, 3, 1 &gt; bool3x1 typedef mat&lt; bool, 3, 2 &gt; bool3x2 typedef mat&lt; bool, 3, 3 &gt; bool3x3 typedef mat&lt; bool, 3, 4 &gt; bool3x4 typedef vec&lt; bool, 4 &gt; bool4 typedef mat&lt; bool, 4, 1 &gt; bool4x1 typedef mat&lt; bool, 4, 2 &gt; bool4x2 typedef mat&lt; bool, 4, 3 &gt; bool4x3 typedef mat&lt; bool, 4, 4 &gt; bool4x4 typedef vec&lt; uint8_t, 1 &gt; byte1 typedef vec&lt; uint8_t, 2 &gt; byte2 typedef vec&lt; uint8_t, 3 &gt; byte3 typedef vec&lt; uint8_t, 4 &gt; byte4 typedef vec&lt; double, 1 &gt; double1 typedef mat&lt; double, 1, 1 &gt; double1x1 typedef mat&lt; double, 1, 2 &gt; double1x2 typedef mat&lt; double, 1, 3 &gt; double1x3 typedef mat&lt; double, 1, 4 &gt; double1x4 typedef vec&lt; double, 2 &gt; double2 typedef mat&lt; double, 2, 1 &gt; double2x1 typedef mat&lt; double, 2, 2 &gt; double2x2 typedef mat&lt; double, 2, 3 &gt; double2x3 typedef mat&lt; double, 2, 4 &gt; double2x4 typedef vec&lt; double, 3 &gt; double3 typedef mat&lt; double, 3, 1 &gt; double3x1 typedef mat&lt; double, 3, 2 &gt; double3x2 typedef mat&lt; double, 3, 3 &gt; double3x3 typedef mat&lt; double, 3, 4 &gt; double3x4 typedef vec&lt; double, 4 &gt; double4 typedef mat&lt; double, 4, 1 &gt; double4x1 typedef mat&lt; double, 4, 2 &gt; double4x2 typedef mat&lt; double, 4, 3 &gt; double4x3 typedef mat&lt; double, 4, 4 &gt; double4x4 typedef vec&lt; float, 1 &gt; float1 typedef mat&lt; float, 1, 1 &gt; float1x1 typedef mat&lt; float, 1, 2 &gt; float1x2 typedef mat&lt; float, 1, 3 &gt; float1x3 typedef mat&lt; float, 1, 4 &gt; float1x4 typedef vec&lt; float, 2 &gt; float2 typedef mat&lt; float, 2, 1 &gt; float2x1 typedef mat&lt; float, 2, 2 &gt; float2x2 typedef mat&lt; float, 2, 3 &gt; float2x3 typedef mat&lt; float, 2, 4 &gt; float2x4 typedef vec&lt; float, 3 &gt; float3 typedef mat&lt; float, 3, 1 &gt; float3x1 typedef mat&lt; float, 3, 2 &gt; float3x2 typedef mat&lt; float, 3, 3 &gt; float3x3 typedef mat&lt; float, 3, 4 &gt; float3x4 typedef vec&lt; float, 4 &gt; float4 typedef mat&lt; float, 4, 1 &gt; float4x1 typedef mat&lt; float, 4, 2 &gt; float4x2 typedef mat&lt; float, 4, 3 &gt; float4x3 typedef mat&lt; float, 4, 4 &gt; float4x4 typedef vec&lt; int, 1 &gt; int1 typedef mat&lt; int, 1, 1 &gt; int1x1 typedef mat&lt; int, 1, 2 &gt; int1x2 typedef mat&lt; int, 1, 3 &gt; int1x3 typedef mat&lt; int, 1, 4 &gt; int1x4 typedef vec&lt; int, 2 &gt; int2 typedef mat&lt; int, 2, 1 &gt; int2x1 typedef mat&lt; int, 2, 2 &gt; int2x2 typedef mat&lt; int, 2, 3 &gt; int2x3 typedef mat&lt; int, 2, 4 &gt; int2x4 typedef vec&lt; int, 3 &gt; int3 typedef mat&lt; int, 3, 1 &gt; int3x1 typedef mat&lt; int, 3, 2 &gt; int3x2 typedef mat&lt; int, 3, 3 &gt; int3x3 typedef mat&lt; int, 3, 4 &gt; int3x4 typedef vec&lt; int, 4 &gt; int4 typedef mat&lt; int, 4, 1 &gt; int4x1 typedef mat&lt; int, 4, 2 &gt; int4x2 typedef mat&lt; int, 4, 3 &gt; int4x3 typedef mat&lt; int, 4, 4 &gt; int4x4 typedef vec&lt; int16_t, 1 &gt; short1 typedef vec&lt; int16_t, 2 &gt; short2 typedef vec&lt; int16_t, 3 &gt; short3 typedef vec&lt; int16_t, 4 &gt; short4 typedef vec&lt; unsigned, 1 &gt; uint1 typedef vec&lt; unsigned, 2 &gt; uint2 typedef vec&lt; unsigned, 3 &gt; uint3 typedef vec&lt; unsigned, 4 &gt; uint4 typedef vec&lt; uint16_t, 1 &gt; ushort1 typedef vec&lt; uint16_t, 2 &gt; ushort2 typedef vec&lt; uint16_t, 3 &gt; ushort3 typedef vec&lt; uint16_t, 4 &gt; ushort4"},{"location":"api/namespacelinalg_1_1aliases/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1","title":"typedef bool1","text":"<pre><code>typedef vec&lt;bool,1&gt; linalg::aliases::bool1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x1","title":"typedef bool1x1","text":"<pre><code>typedef mat&lt;bool,1,1&gt; linalg::aliases::bool1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x2","title":"typedef bool1x2","text":"<pre><code>typedef mat&lt;bool,1,2&gt; linalg::aliases::bool1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x3","title":"typedef bool1x3","text":"<pre><code>typedef mat&lt;bool,1,3&gt; linalg::aliases::bool1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x4","title":"typedef bool1x4","text":"<pre><code>typedef mat&lt;bool,1,4&gt; linalg::aliases::bool1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2","title":"typedef bool2","text":"<pre><code>typedef vec&lt;bool,2&gt; linalg::aliases::bool2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x1","title":"typedef bool2x1","text":"<pre><code>typedef mat&lt;bool,2,1&gt; linalg::aliases::bool2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x2","title":"typedef bool2x2","text":"<pre><code>typedef mat&lt;bool,2,2&gt; linalg::aliases::bool2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x3","title":"typedef bool2x3","text":"<pre><code>typedef mat&lt;bool,2,3&gt; linalg::aliases::bool2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x4","title":"typedef bool2x4","text":"<pre><code>typedef mat&lt;bool,2,4&gt; linalg::aliases::bool2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3","title":"typedef bool3","text":"<pre><code>typedef vec&lt;bool,3&gt; linalg::aliases::bool3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x1","title":"typedef bool3x1","text":"<pre><code>typedef mat&lt;bool,3,1&gt; linalg::aliases::bool3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x2","title":"typedef bool3x2","text":"<pre><code>typedef mat&lt;bool,3,2&gt; linalg::aliases::bool3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x3","title":"typedef bool3x3","text":"<pre><code>typedef mat&lt;bool,3,3&gt; linalg::aliases::bool3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x4","title":"typedef bool3x4","text":"<pre><code>typedef mat&lt;bool,3,4&gt; linalg::aliases::bool3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4","title":"typedef bool4","text":"<pre><code>typedef vec&lt;bool,4&gt; linalg::aliases::bool4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x1","title":"typedef bool4x1","text":"<pre><code>typedef mat&lt;bool,4,1&gt; linalg::aliases::bool4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x2","title":"typedef bool4x2","text":"<pre><code>typedef mat&lt;bool,4,2&gt; linalg::aliases::bool4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x3","title":"typedef bool4x3","text":"<pre><code>typedef mat&lt;bool,4,3&gt; linalg::aliases::bool4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x4","title":"typedef bool4x4","text":"<pre><code>typedef mat&lt;bool,4,4&gt; linalg::aliases::bool4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte1","title":"typedef byte1","text":"<pre><code>typedef vec&lt;uint8_t,1&gt; linalg::aliases::byte1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte2","title":"typedef byte2","text":"<pre><code>typedef vec&lt;uint8_t,2&gt; linalg::aliases::byte2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte3","title":"typedef byte3","text":"<pre><code>typedef vec&lt;uint8_t,3&gt; linalg::aliases::byte3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte4","title":"typedef byte4","text":"<pre><code>typedef vec&lt;uint8_t,4&gt; linalg::aliases::byte4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1","title":"typedef double1","text":"<pre><code>typedef vec&lt;double,1&gt; linalg::aliases::double1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x1","title":"typedef double1x1","text":"<pre><code>typedef mat&lt;double,1,1&gt; linalg::aliases::double1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x2","title":"typedef double1x2","text":"<pre><code>typedef mat&lt;double,1,2&gt; linalg::aliases::double1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x3","title":"typedef double1x3","text":"<pre><code>typedef mat&lt;double,1,3&gt; linalg::aliases::double1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x4","title":"typedef double1x4","text":"<pre><code>typedef mat&lt;double,1,4&gt; linalg::aliases::double1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2","title":"typedef double2","text":"<pre><code>typedef vec&lt;double,2&gt; linalg::aliases::double2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x1","title":"typedef double2x1","text":"<pre><code>typedef mat&lt;double,2,1&gt; linalg::aliases::double2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x2","title":"typedef double2x2","text":"<pre><code>typedef mat&lt;double,2,2&gt; linalg::aliases::double2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x3","title":"typedef double2x3","text":"<pre><code>typedef mat&lt;double,2,3&gt; linalg::aliases::double2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x4","title":"typedef double2x4","text":"<pre><code>typedef mat&lt;double,2,4&gt; linalg::aliases::double2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3","title":"typedef double3","text":"<pre><code>typedef vec&lt;double,3&gt; linalg::aliases::double3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x1","title":"typedef double3x1","text":"<pre><code>typedef mat&lt;double,3,1&gt; linalg::aliases::double3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x2","title":"typedef double3x2","text":"<pre><code>typedef mat&lt;double,3,2&gt; linalg::aliases::double3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x3","title":"typedef double3x3","text":"<pre><code>typedef mat&lt;double,3,3&gt; linalg::aliases::double3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x4","title":"typedef double3x4","text":"<pre><code>typedef mat&lt;double,3,4&gt; linalg::aliases::double3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4","title":"typedef double4","text":"<pre><code>typedef vec&lt;double,4&gt; linalg::aliases::double4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x1","title":"typedef double4x1","text":"<pre><code>typedef mat&lt;double,4,1&gt; linalg::aliases::double4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x2","title":"typedef double4x2","text":"<pre><code>typedef mat&lt;double,4,2&gt; linalg::aliases::double4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x3","title":"typedef double4x3","text":"<pre><code>typedef mat&lt;double,4,3&gt; linalg::aliases::double4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x4","title":"typedef double4x4","text":"<pre><code>typedef mat&lt;double,4,4&gt; linalg::aliases::double4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1","title":"typedef float1","text":"<pre><code>typedef vec&lt;float,1&gt; linalg::aliases::float1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x1","title":"typedef float1x1","text":"<pre><code>typedef mat&lt;float,1,1&gt; linalg::aliases::float1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x2","title":"typedef float1x2","text":"<pre><code>typedef mat&lt;float,1,2&gt; linalg::aliases::float1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x3","title":"typedef float1x3","text":"<pre><code>typedef mat&lt;float,1,3&gt; linalg::aliases::float1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x4","title":"typedef float1x4","text":"<pre><code>typedef mat&lt;float,1,4&gt; linalg::aliases::float1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2","title":"typedef float2","text":"<pre><code>typedef vec&lt;float,2&gt; linalg::aliases::float2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x1","title":"typedef float2x1","text":"<pre><code>typedef mat&lt;float,2,1&gt; linalg::aliases::float2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x2","title":"typedef float2x2","text":"<pre><code>typedef mat&lt;float,2,2&gt; linalg::aliases::float2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x3","title":"typedef float2x3","text":"<pre><code>typedef mat&lt;float,2,3&gt; linalg::aliases::float2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x4","title":"typedef float2x4","text":"<pre><code>typedef mat&lt;float,2,4&gt; linalg::aliases::float2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3","title":"typedef float3","text":"<pre><code>typedef vec&lt;float,3&gt; linalg::aliases::float3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x1","title":"typedef float3x1","text":"<pre><code>typedef mat&lt;float,3,1&gt; linalg::aliases::float3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x2","title":"typedef float3x2","text":"<pre><code>typedef mat&lt;float,3,2&gt; linalg::aliases::float3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x3","title":"typedef float3x3","text":"<pre><code>typedef mat&lt;float,3,3&gt; linalg::aliases::float3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x4","title":"typedef float3x4","text":"<pre><code>typedef mat&lt;float,3,4&gt; linalg::aliases::float3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4","title":"typedef float4","text":"<pre><code>typedef vec&lt;float,4&gt; linalg::aliases::float4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x1","title":"typedef float4x1","text":"<pre><code>typedef mat&lt;float,4,1&gt; linalg::aliases::float4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x2","title":"typedef float4x2","text":"<pre><code>typedef mat&lt;float,4,2&gt; linalg::aliases::float4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x3","title":"typedef float4x3","text":"<pre><code>typedef mat&lt;float,4,3&gt; linalg::aliases::float4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x4","title":"typedef float4x4","text":"<pre><code>typedef mat&lt;float,4,4&gt; linalg::aliases::float4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1","title":"typedef int1","text":"<pre><code>typedef vec&lt;int,1&gt; linalg::aliases::int1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x1","title":"typedef int1x1","text":"<pre><code>typedef mat&lt;int,1,1&gt; linalg::aliases::int1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x2","title":"typedef int1x2","text":"<pre><code>typedef mat&lt;int,1,2&gt; linalg::aliases::int1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x3","title":"typedef int1x3","text":"<pre><code>typedef mat&lt;int,1,3&gt; linalg::aliases::int1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x4","title":"typedef int1x4","text":"<pre><code>typedef mat&lt;int,1,4&gt; linalg::aliases::int1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2","title":"typedef int2","text":"<pre><code>typedef vec&lt;int,2&gt; linalg::aliases::int2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x1","title":"typedef int2x1","text":"<pre><code>typedef mat&lt;int,2,1&gt; linalg::aliases::int2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x2","title":"typedef int2x2","text":"<pre><code>typedef mat&lt;int,2,2&gt; linalg::aliases::int2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x3","title":"typedef int2x3","text":"<pre><code>typedef mat&lt;int,2,3&gt; linalg::aliases::int2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x4","title":"typedef int2x4","text":"<pre><code>typedef mat&lt;int,2,4&gt; linalg::aliases::int2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3","title":"typedef int3","text":"<pre><code>typedef vec&lt;int,3&gt; linalg::aliases::int3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x1","title":"typedef int3x1","text":"<pre><code>typedef mat&lt;int,3,1&gt; linalg::aliases::int3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x2","title":"typedef int3x2","text":"<pre><code>typedef mat&lt;int,3,2&gt; linalg::aliases::int3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x3","title":"typedef int3x3","text":"<pre><code>typedef mat&lt;int,3,3&gt; linalg::aliases::int3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x4","title":"typedef int3x4","text":"<pre><code>typedef mat&lt;int,3,4&gt; linalg::aliases::int3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4","title":"typedef int4","text":"<pre><code>typedef vec&lt;int,4&gt; linalg::aliases::int4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x1","title":"typedef int4x1","text":"<pre><code>typedef mat&lt;int,4,1&gt; linalg::aliases::int4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x2","title":"typedef int4x2","text":"<pre><code>typedef mat&lt;int,4,2&gt; linalg::aliases::int4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x3","title":"typedef int4x3","text":"<pre><code>typedef mat&lt;int,4,3&gt; linalg::aliases::int4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x4","title":"typedef int4x4","text":"<pre><code>typedef mat&lt;int,4,4&gt; linalg::aliases::int4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short1","title":"typedef short1","text":"<pre><code>typedef vec&lt;int16_t,1&gt; linalg::aliases::short1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short2","title":"typedef short2","text":"<pre><code>typedef vec&lt;int16_t,2&gt; linalg::aliases::short2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short3","title":"typedef short3","text":"<pre><code>typedef vec&lt;int16_t,3&gt; linalg::aliases::short3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short4","title":"typedef short4","text":"<pre><code>typedef vec&lt;int16_t,4&gt; linalg::aliases::short4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint1","title":"typedef uint1","text":"<pre><code>typedef vec&lt;unsigned,1&gt; linalg::aliases::uint1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint2","title":"typedef uint2","text":"<pre><code>typedef vec&lt;unsigned,2&gt; linalg::aliases::uint2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint3","title":"typedef uint3","text":"<pre><code>typedef vec&lt;unsigned,3&gt; linalg::aliases::uint3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint4","title":"typedef uint4","text":"<pre><code>typedef vec&lt;unsigned,4&gt; linalg::aliases::uint4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort1","title":"typedef ushort1","text":"<pre><code>typedef vec&lt;uint16_t,1&gt; linalg::aliases::ushort1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort2","title":"typedef ushort2","text":"<pre><code>typedef vec&lt;uint16_t,2&gt; linalg::aliases::ushort2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort3","title":"typedef ushort3","text":"<pre><code>typedef vec&lt;uint16_t,3&gt; linalg::aliases::ushort3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort4","title":"typedef ushort4","text":"<pre><code>typedef vec&lt;uint16_t,4&gt; linalg::aliases::ushort4;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter/","title":"Struct linalg::converter","text":"<p>template &lt;class T, class U&gt;</p> <p>ClassList &gt; linalg &gt; converter</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 1, 1 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 1, 1 &gt; linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 2, 2 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 2, 2 &gt; linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 3, 3 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 3, 3 &gt; linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 4, 4 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 4, 4 &gt; linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 1 &gt; operator() (const vec&lt; T, 1 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 1 &gt; linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::operator() (\n    const vec&lt; T, 1 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 2 &gt; operator() (const vec&lt; T, 2 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 2 &gt; linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::operator() (\n    const vec&lt; T, 2 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 3 &gt; operator() (const vec&lt; T, 3 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 3 &gt; linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::operator() (\n    const vec&lt; T, 3 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 4 &gt; operator() (const vec&lt; T, 4 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 4 &gt; linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::operator() (\n    const vec&lt; T, 4 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 1 &gt; operator() (const std::array&lt; T, 1 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 1 &gt; linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;::operator() (\n    const std::array&lt; T, 1 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 2 &gt; operator() (const std::array&lt; T, 2 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 2 &gt; linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;::operator() (\n    const std::array&lt; T, 2 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 3 &gt; operator() (const std::array&lt; T, 3 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 3 &gt; linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;::operator() (\n    const std::array&lt; T, 3 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 4 &gt; operator() (const std::array&lt; T, 4 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 4 &gt; linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;::operator() (\n    const std::array&lt; T, 4 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1detail/","title":"Namespace linalg::detail","text":"<p>Namespace List &gt; linalg &gt; detail</p>"},{"location":"api/namespacelinalg_1_1detail/#classes","title":"Classes","text":"Type Name struct any_compare &lt;class A, class B&gt; struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct apply &lt;class F, class Void, T&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; &lt;class F, M, N, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; &lt;class F, M, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; &lt;class F, A&gt; struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct clamp struct empty struct getter &lt;I&gt; struct getter&lt; 0 &gt; &lt;&gt; struct getter&lt; 1 &gt; &lt;&gt; struct getter&lt; 2 &gt; &lt;&gt; struct getter&lt; 3 &gt; &lt;&gt; struct lerp struct make_seq_impl &lt;A, N&gt; struct make_seq_impl&lt; A, 0 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 1 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 2 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 3 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 4 &gt; &lt;A&gt; struct max struct min struct op_add struct op_and struct op_cmp struct op_div struct op_eq struct op_ge struct op_gt struct op_int struct op_le struct op_lsh struct op_lt struct op_mod struct op_mul struct op_ne struct op_neg struct op_not struct op_or struct op_pos struct op_rsh struct op_sub struct op_un struct op_xor struct ord &lt;class T&gt; struct scalar_type &lt;class A&gt; struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; &lt;class T, M, N&gt; struct scalar_type&lt; vec&lt; T, M &gt; &gt; &lt;class T, M&gt; struct scalars &lt;T&gt; struct scalars&lt; T, U... &gt; &lt;class T, U&gt; struct scalars&lt;&gt; &lt;&gt; struct select struct seq &lt;I&gt; struct std_abs struct std_acos struct std_asin struct std_atan struct std_atan2 struct std_ceil struct std_copysign struct std_cos struct std_cosh struct std_exp struct std_floor struct std_fmod struct std_log struct std_log10 struct std_pow struct std_round struct std_sin struct std_sinh struct std_sqrt struct std_tan struct std_tanh"},{"location":"api/namespacelinalg_1_1detail/#public-types","title":"Public Types","text":"Type Name typedef typename std::enable_if&lt;!std::is_same&lt; T, U &gt;::value, decltype(converter&lt; T, U &gt;{}(std::declval&lt; U &gt;()))&gt;::type conv_t typedef typename make_seq_impl&lt; A, B-A &gt;::type make_seq typedef decltype(std::declval&lt; F &gt;()(std::declval&lt; T &gt;()...)) ret_t typedef typename scalars&lt; T... &gt;::type scalars_t"},{"location":"api/namespacelinalg_1_1detail/#public-functions","title":"Public Functions","text":"Type Name constexpr bool operator!= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&lt; (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&lt;= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator== (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&gt; (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&gt;= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  vec&lt; T, sizeof...(I)&gt; constexpr swizzle (const vec&lt; T, M &gt; &amp; v, seq&lt; I... &gt;)  mat&lt; T, sizeof...(I), sizeof...(J)&gt; constexpr swizzle (const mat&lt; T, M, N &gt; &amp; m, seq&lt; I... &gt; i, seq&lt; J... &gt;)"},{"location":"api/namespacelinalg_1_1detail/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg_1_1detail/#typedef-conv_t","title":"typedef conv_t","text":"<pre><code>using linalg::detail::conv_t = typedef typename std::enable_if&lt;!std::is_same&lt;T,U&gt;::value, decltype(converter&lt;T,U&gt;{}(std::declval&lt;U&gt;()))&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-make_seq","title":"typedef make_seq","text":"<pre><code>using linalg::detail::make_seq = typedef typename make_seq_impl&lt;A,B-A&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-ret_t","title":"typedef ret_t","text":"<pre><code>using linalg::detail::ret_t = typedef decltype(std::declval&lt;F&gt;()(std::declval&lt;T&gt;()...));\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-scalars_t","title":"typedef scalars_t","text":"<pre><code>using linalg::detail::scalars_t = typedef typename scalars&lt;T...&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg_1_1detail/#function-operator","title":"function operator!=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator!= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_1","title":"function operator&lt;","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&lt; (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_2","title":"function operator&lt;=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&lt;= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_3","title":"function operator==","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator== (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_4","title":"function operator&gt;","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&gt; (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_5","title":"function operator&gt;=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&gt;= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-swizzle","title":"function swizzle","text":"<pre><code>template&lt;class T, int M, int... I&gt;\nvec&lt; T, sizeof...(I)&gt; constexpr linalg::detail::swizzle (\n    const vec&lt; T, M &gt; &amp; v,\n    seq&lt; I... &gt;\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-swizzle_1","title":"function swizzle","text":"<pre><code>template&lt;class T, int M, int N, int... I, int... J&gt;\nmat&lt; T, sizeof...(I), sizeof...(J)&gt; constexpr linalg::detail::swizzle (\n    const mat&lt; T, M, N &gt; &amp; m,\n    seq&lt; I... &gt; i,\n    seq&lt; J... &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare/","title":"Struct linalg::detail::any_compare","text":"<p>template &lt;class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 1 &gt; &amp; a, const mat&lt; T, M, 1 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;::operator() (\n    const mat&lt; T, M, 1 &gt; &amp; a,\n    const mat&lt; T, M, 1 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 2 &gt; &amp; a, const mat&lt; T, M, 2 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;::operator() (\n    const mat&lt; T, M, 2 &gt; &amp; a,\n    const mat&lt; T, M, 2 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 3 &gt; &amp; a, const mat&lt; T, M, 3 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;::operator() (\n    const mat&lt; T, M, 3 &gt; &amp; a,\n    const mat&lt; T, M, 3 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 4 &gt; &amp; a, const mat&lt; T, M, 4 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;::operator() (\n    const mat&lt; T, M, 4 &gt; &amp; a,\n    const mat&lt; T, M, 4 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 1 &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::operator() (\n    const vec&lt; T, 1 &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::operator() (\n    const vec&lt; T, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::operator() (\n    const vec&lt; T, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::operator() (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply/","title":"Struct linalg::detail::apply","text":"<p>template &lt;class F, class Void, class... T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#enum-apply-f-scalars_t-mat-a-m-n","title":"enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A &gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a, const mat&lt; B, M, N &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#enum-apply-f-scalars_t-mat-a-m-n-mat-b-m-n","title":"enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a,\n    const mat&lt; B, M, N &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#enum-apply-f-scalars_t-vec-a-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#enum-apply-f-scalars_t-vec-a-m-vec-b-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#enum-apply-f-scalars_t-vec-a-m-vec-b-m-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, A a, const mat&lt; B, M, N &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#enum-apply-f-scalars_t-a-a-mat-b-m-n","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    A a,\n    const mat&lt; B, M, N &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#enum-apply-f-scalars_t-a-a-vec-b-m","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#enum-apply-f-scalars_t-a-a-vec-b-m-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, B b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#enum-apply-f-scalars_t-a-b-a-b-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    B b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#enum-apply-f-scalars_t-a-c-a-vec-b-m-c","title":"enum apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;","text":"<p>template &lt;class F, class... A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; typedef ret_t&lt; F, A... &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt;&gt;, F f, A... a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#enum-apply-f-scalars_t-a-a","title":"enum apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; {\n    size =0\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::type =  ret_t&lt;F,A...&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#function-impl","title":"function impl","text":"<pre><code>static inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::impl (\n    seq&lt;&gt;,\n    F f,\n    A... a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a, B b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#enum-apply-f-scalars_t-b-mat-a-m-n-b","title":"enum apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a,\n    B b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#enum-apply-f-scalars_t-b-vec-a-m-b","title":"enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#enum-apply-f-scalars_t-b-vec-a-m-b-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#enum-apply-f-scalars_t-b-c-vec-a-m-b-c","title":"enum apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#enum-apply-f-scalars_t-c-vec-a-m-vec-b-m-c","title":"enum apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1clamp/","title":"Struct linalg::detail::clamp","text":"<p>ClassList &gt; linalg &gt; detail &gt; clamp</p>"},{"location":"api/structlinalg_1_1detail_1_1clamp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1clamp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1clamp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::clamp::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1empty/","title":"Struct linalg::detail::empty","text":"<p>ClassList &gt; linalg &gt; detail &gt; empty</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter/","title":"Struct linalg::detail::getter","text":"<p>template &lt;int I&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/","title":"Struct linalg::detail::getter&lt; 0 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 0 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 0 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/","title":"Struct linalg::detail::getter&lt; 1 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 1 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 1 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/","title":"Struct linalg::detail::getter&lt; 2 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 2 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 2 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/","title":"Struct linalg::detail::getter&lt; 3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 3 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 3 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1lerp/","title":"Struct linalg::detail::lerp","text":"<p>ClassList &gt; linalg &gt; detail &gt; lerp</p>"},{"location":"api/structlinalg_1_1detail_1_1lerp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1lerp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1lerp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::lerp::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl/","title":"Struct linalg::detail::make_seq_impl","text":"<p>template &lt;int A, int N&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 0 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 0 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt;&gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 0 &gt;::type =  seq&lt;&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 1 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 1 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 1 &gt;::type =  seq&lt;A+0&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 2 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 2 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 2 &gt;::type =  seq&lt;A+0,A+1&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 3 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 3 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1, A+2 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 3 &gt;::type =  seq&lt;A+0,A+1,A+2&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 4 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 4 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1, A+2, A+3 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 4 &gt;::type =  seq&lt;A+0,A+1,A+2,A+3&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1max/","title":"Struct linalg::detail::max","text":"<p>ClassList &gt; linalg &gt; detail &gt; max</p>"},{"location":"api/structlinalg_1_1detail_1_1max/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1max/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1max/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::max::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1min/","title":"Struct linalg::detail::min","text":"<p>ClassList &gt; linalg &gt; detail &gt; min</p>"},{"location":"api/structlinalg_1_1detail_1_1min/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1min/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1min/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::min::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__add/","title":"Struct linalg::detail::op_add","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_add</p>"},{"location":"api/structlinalg_1_1detail_1_1op__add/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__add/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__add/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_add::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__and/","title":"Struct linalg::detail::op_and","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_and</p>"},{"location":"api/structlinalg_1_1detail_1_1op__and/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__and/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__and/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_and::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/","title":"Struct linalg::detail::op_cmp","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_cmp</p>"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_cmp::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__div/","title":"Struct linalg::detail::op_div","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_div</p>"},{"location":"api/structlinalg_1_1detail_1_1op__div/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__div/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__div/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_div::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__eq/","title":"Struct linalg::detail::op_eq","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_eq</p>"},{"location":"api/structlinalg_1_1detail_1_1op__eq/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__eq/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__eq/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_eq::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__ge/","title":"Struct linalg::detail::op_ge","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_ge</p>"},{"location":"api/structlinalg_1_1detail_1_1op__ge/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__ge/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__ge/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_ge::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__gt/","title":"Struct linalg::detail::op_gt","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_gt</p>"},{"location":"api/structlinalg_1_1detail_1_1op__gt/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__gt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__gt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_gt::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__int/","title":"Struct linalg::detail::op_int","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_int</p>"},{"location":"api/structlinalg_1_1detail_1_1op__int/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__int/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__int/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_int::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__le/","title":"Struct linalg::detail::op_le","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_le</p>"},{"location":"api/structlinalg_1_1detail_1_1op__le/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__le/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__le/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_le::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/","title":"Struct linalg::detail::op_lsh","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_lsh</p>"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_lsh::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__lt/","title":"Struct linalg::detail::op_lt","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_lt</p>"},{"location":"api/structlinalg_1_1detail_1_1op__lt/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__lt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__lt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_lt::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__mod/","title":"Struct linalg::detail::op_mod","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_mod</p>"},{"location":"api/structlinalg_1_1detail_1_1op__mod/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__mod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__mod/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_mod::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__mul/","title":"Struct linalg::detail::op_mul","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_mul</p>"},{"location":"api/structlinalg_1_1detail_1_1op__mul/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__mul/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__mul/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_mul::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__ne/","title":"Struct linalg::detail::op_ne","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_ne</p>"},{"location":"api/structlinalg_1_1detail_1_1op__ne/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__ne/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__ne/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_ne::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__neg/","title":"Struct linalg::detail::op_neg","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_neg</p>"},{"location":"api/structlinalg_1_1detail_1_1op__neg/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__neg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__neg/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_neg::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__not/","title":"Struct linalg::detail::op_not","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_not</p>"},{"location":"api/structlinalg_1_1detail_1_1op__not/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__not/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__not/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_not::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__or/","title":"Struct linalg::detail::op_or","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_or</p>"},{"location":"api/structlinalg_1_1detail_1_1op__or/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__or/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__or/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_or::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__pos/","title":"Struct linalg::detail::op_pos","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_pos</p>"},{"location":"api/structlinalg_1_1detail_1_1op__pos/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__pos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__pos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_pos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/","title":"Struct linalg::detail::op_rsh","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_rsh</p>"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_rsh::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__sub/","title":"Struct linalg::detail::op_sub","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_sub</p>"},{"location":"api/structlinalg_1_1detail_1_1op__sub/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__sub/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__sub/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_sub::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__un/","title":"Struct linalg::detail::op_un","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_un</p>"},{"location":"api/structlinalg_1_1detail_1_1op__un/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__un/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__un/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_un::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__xor/","title":"Struct linalg::detail::op_xor","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_xor</p>"},{"location":"api/structlinalg_1_1detail_1_1op__xor/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__xor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__xor/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_xor::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1ord/","title":"Struct linalg::detail::ord","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; ord</p>"},{"location":"api/structlinalg_1_1detail_1_1ord/#public-attributes","title":"Public Attributes","text":"Type Name T a T b"},{"location":"api/structlinalg_1_1detail_1_1ord/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1ord/#variable-a","title":"variable a","text":"<pre><code>T linalg::detail::ord&lt; T &gt;::a;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1ord/#variable-b","title":"variable b","text":"<pre><code>T linalg::detail::ord&lt; T &gt;::b;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type/","title":"Struct linalg::detail::scalar_type","text":"<p>template &lt;class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;","text":"<p>template &lt;class T, int M, int N&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type&lt; mat&lt; T, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/","title":"Struct linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type&lt; vec&lt; T, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars/","title":"Struct linalg::detail::scalars","text":"<p>template &lt;class... T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_01T_00_01U_8_8_8_01_4/","title":"Struct linalg::detail::scalars&lt; T, U... &gt;","text":"<p>template &lt;class T, class... U&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars&lt; T, U... &gt;</p> <p>Inherits the following classes: std::conditional::type</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/","title":"Struct linalg::detail::scalars&lt;&gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars&lt;&gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#public-types","title":"Public Types","text":"Type Name typedef void type"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalars&lt;&gt;::type =  void;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1select/","title":"Struct linalg::detail::select","text":"<p>ClassList &gt; linalg &gt; detail &gt; select</p>"},{"location":"api/structlinalg_1_1detail_1_1select/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1select/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1select/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::select::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1seq/","title":"Struct linalg::detail::seq","text":"<p>template &lt;int... I&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; seq</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__abs/","title":"Struct linalg::detail::std_abs","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_abs</p>"},{"location":"api/structlinalg_1_1detail_1_1std__abs/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__abs/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__abs/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_abs::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__acos/","title":"Struct linalg::detail::std_acos","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_acos</p>"},{"location":"api/structlinalg_1_1detail_1_1std__acos/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__acos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__acos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_acos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__asin/","title":"Struct linalg::detail::std_asin","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_asin</p>"},{"location":"api/structlinalg_1_1detail_1_1std__asin/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__asin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__asin/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_asin::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan/","title":"Struct linalg::detail::std_atan","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_atan</p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__atan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__atan/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_atan::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/","title":"Struct linalg::detail::std_atan2","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_atan2</p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_atan2::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/","title":"Struct linalg::detail::std_ceil","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_ceil</p>"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_ceil::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/","title":"Struct linalg::detail::std_copysign","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_copysign</p>"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_copysign::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__cos/","title":"Struct linalg::detail::std_cos","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_cos</p>"},{"location":"api/structlinalg_1_1detail_1_1std__cos/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__cos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__cos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_cos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/","title":"Struct linalg::detail::std_cosh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_cosh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_cosh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__exp/","title":"Struct linalg::detail::std_exp","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_exp</p>"},{"location":"api/structlinalg_1_1detail_1_1std__exp/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__exp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__exp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_exp::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__floor/","title":"Struct linalg::detail::std_floor","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_floor</p>"},{"location":"api/structlinalg_1_1detail_1_1std__floor/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__floor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__floor/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_floor::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/","title":"Struct linalg::detail::std_fmod","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_fmod</p>"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_fmod::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__log/","title":"Struct linalg::detail::std_log","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_log</p>"},{"location":"api/structlinalg_1_1detail_1_1std__log/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__log/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__log/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_log::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__log10/","title":"Struct linalg::detail::std_log10","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_log10</p>"},{"location":"api/structlinalg_1_1detail_1_1std__log10/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__log10/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__log10/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_log10::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__pow/","title":"Struct linalg::detail::std_pow","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_pow</p>"},{"location":"api/structlinalg_1_1detail_1_1std__pow/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__pow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__pow/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_pow::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__round/","title":"Struct linalg::detail::std_round","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_round</p>"},{"location":"api/structlinalg_1_1detail_1_1std__round/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__round/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__round/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_round::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sin/","title":"Struct linalg::detail::std_sin","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sin</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sin/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sin/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sin::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/","title":"Struct linalg::detail::std_sinh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sinh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sinh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/","title":"Struct linalg::detail::std_sqrt","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sqrt</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sqrt::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__tan/","title":"Struct linalg::detail::std_tan","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_tan</p>"},{"location":"api/structlinalg_1_1detail_1_1std__tan/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__tan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__tan/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_tan::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/","title":"Struct linalg::detail::std_tanh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_tanh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_tanh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1identity__t/","title":"Struct linalg::identity_t","text":"<p>ClassList &gt; linalg &gt; identity_t</p>"},{"location":"api/structlinalg_1_1identity__t/#public-functions","title":"Public Functions","text":"Type Name constexpr identity_t (int)"},{"location":"api/structlinalg_1_1identity__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1identity__t/#function-identity_t","title":"function identity_t","text":"<pre><code>inline explicit constexpr linalg::identity_t::identity_t (\n    int\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat/","title":"Struct linalg::mat","text":"<p>template &lt;class T, int M, int N&gt;</p> <p>ClassList &gt; linalg &gt; mat</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/","title":"Struct linalg::mat&lt; T, M, 1 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 1 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 1 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int) const LINALG_CONSTEXPR14 V &amp; operator[] (int)  constexpr vec&lt; T, 1 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 1 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 1 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 1 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const V &amp; x_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const mat&lt; U, M, 1 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 1 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 1 &gt;::operator[] (\n    int\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 1 &gt;::operator[] (\n    int\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 1 &gt; linalg::mat&lt; T, M, 1 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/","title":"Struct linalg::mat&lt; T, M, 2 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 2 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x V y"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 2 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 2 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 2 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 2 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 2 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 2 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const mat&lt; U, M, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 2 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 2 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 2 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 2 &gt; linalg::mat&lt; T, M, 2 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/","title":"Struct linalg::mat&lt; T, M, 3 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 3 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x V y V z"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_, const V &amp; z_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 3 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 3 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 3 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-z","title":"variable z","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 3 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_,\n    const V &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const mat&lt; U, M, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 3 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 3 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 3 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 3 &gt; linalg::mat&lt; T, M, 3 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/","title":"Struct linalg::mat&lt; T, M, 4 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 4 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V w V x V y V z"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_, const V &amp; z_, const V &amp; w_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 4 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 4 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 4 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-w","title":"variable w","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::w;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-z","title":"variable z","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 4 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_,\n    const V &amp; z_,\n    const V &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const mat&lt; U, M, 4 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 4 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 4 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 4 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 4 &gt; linalg::mat&lt; T, M, 4 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1ostream__overloads/","title":"Namespace linalg::ostream_overloads","text":"<p>Namespace List &gt; linalg &gt; ostream_overloads</p>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#public-functions","title":"Public Functions","text":"Type Name std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 1 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 2 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 3 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 4 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 1 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 2 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 3 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 4 &gt; &amp; m)"},{"location":"api/namespacelinalg_1_1ostream__overloads/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 1 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 4 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 1 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_5","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_6","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_7","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 4 &gt; &amp; m\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec/","title":"Struct linalg::vec","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; vec</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/","title":"Struct linalg::vec&lt; T, 1 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 1 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int) const LINALG_CONSTEXPR14 T &amp; operator[] (int)  constexpr vec ()  constexpr vec (const T &amp; x_)  constexpr vec (const vec&lt; U, 1 &gt; &amp; v)  constexpr vec (const U &amp; u)"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 1 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 1 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 1 &gt;::operator[] (\n    int\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 1 &gt;::operator[] (\n    int\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-14","title":"function vec [1/4]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 1 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-24","title":"function vec [2/4]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const T &amp; x_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-34","title":"function vec [3/4]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const vec&lt; U, 1 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-44","title":"function vec [4/4]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const U &amp; u\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/","title":"Struct linalg::vec&lt; T, 2 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 2 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x T y"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 2 &gt; &amp; v)  constexpr vec (const U &amp; u)"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 2 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 2 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 2 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 2 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 2 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-16","title":"function vec [1/6]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 2 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-26","title":"function vec [2/6]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-36","title":"function vec [3/6]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-46","title":"function vec [4/6]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-56","title":"function vec [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const vec&lt; U, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-66","title":"function vec [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const U &amp; u\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/","title":"Struct linalg::vec&lt; T, 3 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 3 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x T y T z"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_, const T &amp; z_)  constexpr vec (const vec&lt; T, 2 &gt; &amp; xy, const T &amp; z_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 3 &gt; &amp; v)  constexpr vec (const U &amp; u)  constexpr const vec&lt; T, 2 &gt; &amp; xy () const vec&lt; T, 2 &gt; &amp; xy ()"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-z","title":"variable z","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 3 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 3 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 3 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-17","title":"function vec [1/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-27","title":"function vec [2/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_,\n    const T &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-37","title":"function vec [3/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const vec&lt; T, 2 &gt; &amp; xy,\n    const T &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-47","title":"function vec [4/7]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-57","title":"function vec [5/7]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-67","title":"function vec [6/7]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const vec&lt; U, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-77","title":"function vec [7/7]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-xy-12","title":"function xy [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 3 &gt;::xy () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-xy-22","title":"function xy [2/2]","text":"<pre><code>inline vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 3 &gt;::xy () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/","title":"Struct linalg::vec&lt; T, 4 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 4 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T w T x T y T z"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_, const T &amp; z_, const T &amp; w_)  constexpr vec (const vec&lt; T, 2 &gt; &amp; xy, const T &amp; z_, const T &amp; w_)  constexpr vec (const vec&lt; T, 3 &gt; &amp; xyz, const T &amp; w_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 4 &gt; &amp; v)  constexpr vec (const U &amp; u)  constexpr const vec&lt; T, 2 &gt; &amp; xy () const vec&lt; T, 2 &gt; &amp; xy ()  constexpr const vec&lt; T, 3 &gt; &amp; xyz () const vec&lt; T, 3 &gt; &amp; xyz ()"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-w","title":"variable w","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::w;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-z","title":"variable z","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 4 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 4 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 4 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-18","title":"function vec [1/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-28","title":"function vec [2/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_,\n    const T &amp; z_,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-38","title":"function vec [3/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; T, 2 &gt; &amp; xy,\n    const T &amp; z_,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-48","title":"function vec [4/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; T, 3 &gt; &amp; xyz,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-58","title":"function vec [5/8]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-68","title":"function vec [6/8]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-78","title":"function vec [7/8]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; U, 4 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-88","title":"function vec [8/8]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xy-12","title":"function xy [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xy () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xy-22","title":"function xy [2/2]","text":"<pre><code>inline vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xy () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xyz-12","title":"function xyz [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 3 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xyz () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xyz-22","title":"function xyz [2/2]","text":"<pre><code>inline vec&lt; T, 3 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xyz () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/classpose__prediction/","title":"Class pose_prediction","text":"<p>ClassList &gt; pose_prediction</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classpose__prediction/#public-functions","title":"Public Functions","text":"Type Name virtual bool fast_pose_reliable () const = 0 virtual pose_type get_fast_pose () const = 0 virtual pose_type get_true_pose () const = 0 virtual void set_offset (const Eigen::Quaternionf &amp; orientation) = 0 virtual bool true_pose_reliable () const = 0 virtual ~pose_prediction ()"},{"location":"api/classpose__prediction/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service ()"},{"location":"api/classpose__prediction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classpose__prediction/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<pre><code>virtual bool pose_prediction::fast_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_fast_pose","title":"function get_fast_pose","text":"<pre><code>virtual pose_type pose_prediction::get_fast_pose () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_true_pose","title":"function get_true_pose","text":"<pre><code>virtual pose_type pose_prediction::get_true_pose () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-set_offset","title":"function set_offset","text":"<pre><code>virtual void pose_prediction::set_offset (\n    const Eigen::Quaternionf &amp; orientation\n) = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<pre><code>virtual bool pose_prediction::true_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-pose_prediction","title":"function ~pose_prediction","text":"<pre><code>inline virtual pose_prediction::~pose_prediction () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/pose_prediction.hpp</code></p>"},{"location":"api/classprint__timer/","title":"Class print_timer","text":"<p>template &lt;typename now_fn, typename time_point, typename duration&gt;</p> <p>ClassList &gt; print_timer</p> <p>Like timer, but prints the output. More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classprint__timer/#public-functions","title":"Public Functions","text":"Type Name print_timer (const std::string &amp; name, const now_fn &amp; now)"},{"location":"api/classprint__timer/#detailed-description","title":"Detailed Description","text":"<p>See PRINT_CPU_TIME_FOR_THIS_BLOCK(name) </p>"},{"location":"api/classprint__timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer/#function-print_timer","title":"function print_timer","text":"<pre><code>inline print_timer::print_timer (\n    const std::string &amp; name,\n    const now_fn &amp; now\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer2/","title":"Class print_timer2","text":"<p>ClassList &gt; print_timer2</p>"},{"location":"api/classprint__timer2/#public-functions","title":"Public Functions","text":"Type Name print_timer2 (std::string name_)  ~print_timer2 ()"},{"location":"api/classprint__timer2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer2/#function-print_timer2","title":"function print_timer2","text":"<pre><code>inline print_timer2::print_timer2 (\n    std::string name_\n) \n</code></pre>"},{"location":"api/classprint__timer2/#function-print_timer2_1","title":"function ~print_timer2","text":"<pre><code>inline print_timer2::~print_timer2 () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer_1_1print__in__destructor/","title":"Class print_timer::print_in_destructor","text":"<p>ClassList &gt; print_in_destructor</p>"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions","title":"Public Functions","text":"Type Name print_in_destructor (const std::string &amp; account_name, const duration &amp; _duration)  ~print_in_destructor ()"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor","title":"function print_in_destructor","text":"<pre><code>inline print_in_destructor::print_in_destructor (\n    const std::string &amp; account_name,\n    const duration &amp; _duration\n) \n</code></pre>"},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor_1","title":"function ~print_in_destructor","text":"<pre><code>inline print_in_destructor::~print_in_destructor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/classshould__profile__class/","title":"Class should_profile_class","text":"<p>ClassList &gt; should_profile_class</p>"},{"location":"api/classshould__profile__class/#public-functions","title":"Public Functions","text":"Type Name bool operator() ()  should_profile_class ()"},{"location":"api/classshould__profile__class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classshould__profile__class/#function-operator","title":"function operator()","text":"<pre><code>inline bool should_profile_class::operator() () \n</code></pre>"},{"location":"api/classshould__profile__class/#function-should_profile_class","title":"function should_profile_class","text":"<pre><code>inline should_profile_class::should_profile_class () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p>"},{"location":"api/namespacestd/#namespaces","title":"Namespaces","text":"Type Name namespace conditional"},{"location":"api/namespacestd/#classes","title":"Classes","text":"Type Name struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; &lt;class T&gt; <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacestd_1_1conditional/","title":"Namespace std::conditional","text":"<p>Namespace List &gt; std &gt; conditional</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 1 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 1 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 2 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 2 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 3 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 3 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 4 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 4 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 1 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 1 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 2 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 2 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 3 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 3 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 4 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 4 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/classtimer/","title":"Class timer","text":"<p>template &lt;typename now_fn, typename time_point, typename durationt&gt;</p> <p>ClassList &gt; timer</p> <p>a timer that times until the end of the code block ([RAII]). More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classtimer/#public-functions","title":"Public Functions","text":"Type Name timer (const now_fn &amp; now, durationt &amp; _duration)  ~timer ()"},{"location":"api/classtimer/#detailed-description","title":"Detailed Description","text":"<p>See [2] for how code-blocks are defined in C++.</p> <p><code>now</code> can be any type that takes no arguments and returns a subtractable type.</p> <p>Example usage:</p> <pre><code>{\n    // stuff that won't get timed.\n    std::chrono::nanoseconds ns;\n    timer&lt;decltype((thread_cpu_time))&gt; timer_obj {thread_cpu_time, ns};\n    // stuff that gets timed.\n}\n// stuff that won't get timed.\nstd::cout &lt;&lt; ns.count() &lt;&lt; std::endl;\n</code></pre>"},{"location":"api/classtimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classtimer/#function-timer","title":"function timer","text":"<pre><code>inline timer::timer (\n    const now_fn &amp; now,\n    durationt &amp; _duration\n) \n</code></pre>"},{"location":"api/classtimer/#function-timer_1","title":"function ~timer","text":"<pre><code>inline timer::~timer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/dir_bdd9a5d540de89e9fe90efdfc6973a4f/","title":"Dir common","text":"<p>FileList &gt; common</p>"},{"location":"api/dir_bdd9a5d540de89e9fe90efdfc6973a4f/#files","title":"Files","text":"Type Name file cpu_timer.hpp file data_format.hpp file dynamic_lib.hpp file extended_window.hpp file linalg.hpp file logger.hpp file phonebook.hpp file plugin.hpp file pose_prediction.hpp file record_logger.hpp file runtime.hpp file shader_util.hpp file switchboard.hpp file threadloop.hpp <p>The documentation for this class was generated from the following file <code>common/</code></p>"},{"location":"api/cpu__timer_8hpp/","title":"File cpu_timer.hpp","text":"<p>FileList &gt; common &gt; cpu_timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/cpu__timer_8hpp/#classes","title":"Classes","text":"Type Name class print_timer &lt;typename now_fn, typename time_point, typename duration&gt;Like timer, but prints the output. class print_timer2 class should_profile_class class timer &lt;typename now_fn, typename time_point, typename durationt&gt;a timer that times until the end of the code block ([RAII])."},{"location":"api/cpu__timer_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name should_profile_class should_profile"},{"location":"api/cpu__timer_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (Duration t)  std::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (Duration t)  std::thread timed_thread (const std::string &amp; account_name, Function &amp;&amp; f, Args &amp;&amp;... args) Use this in place of std::thread(...) to print times."},{"location":"api/cpu__timer_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::nanoseconds cpp_clock_gettime (clockid_t clock_id) A C++ translation of clock_gettime __ std::size_t gen_serial_no ()  std::chrono::nanoseconds thread_cpu_time () Gets the CPU time for the calling thread."},{"location":"api/cpu__timer_8hpp/#macros","title":"Macros","text":"Type Name define PRINT_CPU_TIME_FOR_THIS_BLOCK (name) <code>[**print\\_timer**](classprint__timer.md)&amp;lt;decltype((thread\\_cpu\\_time))&amp;gt; PRINT\\_CPU\\_TIME\\_FOR\\_THIS\\_BLOCK {name, thread\\_cpu\\_time};</code> define PRINT_RECORD_FOR_THIS_BLOCK (name) <code>print\\_timer2 PRINT\\_RECORD\\_FOR\\_THIS\\_BLOCK\\_timer {name};</code> define PRINT_WALL_TIME_FOR_THIS_BLOCK (name) <code>[**print\\_timer**](classprint__timer.md)&amp;lt;decltype((std::chrono::high\\_resolution\\_clock::now))&amp;gt; PRINT\\_WALL\\_TIME\\_FOR\\_THIS\\_BLOCK {name, std::chrono::high\\_resolution\\_clock::now};</code>"},{"location":"api/cpu__timer_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/cpu__timer_8hpp/#variable-should_profile","title":"variable should_profile","text":"<pre><code>should_profile_class should_profile;\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-count_duration","title":"function count_duration","text":"<pre><code>template&lt;typename Duration, typename Out&gt;\nstd::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-count_duration_1","title":"function count_duration","text":"<pre><code>template&lt;typename Duration&gt;\nstd::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-timed_thread","title":"function timed_thread","text":"<p>Use this in place of std::thread(...) to print times. <pre><code>template&lt;class Function, class... Args&gt;\nstd::thread timed_thread (\n    const std::string &amp; account_name,\n    Function &amp;&amp; f,\n    Args &amp;&amp;... args\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-cpp_clock_gettime","title":"function cpp_clock_gettime","text":"<p>A C++ translation of clock_gettime __ <pre><code>static inline std::chrono::nanoseconds cpp_clock_gettime (\n    clockid_t clock_id\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#function-gen_serial_no","title":"function gen_serial_no","text":"<pre><code>static std::size_t gen_serial_no () \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-thread_cpu_time","title":"function thread_cpu_time","text":"<p>Gets the CPU time for the calling thread. <pre><code>static inline std::chrono::nanoseconds thread_cpu_time () \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/cpu__timer_8hpp/#define-print_cpu_time_for_this_block","title":"define PRINT_CPU_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_CPU_TIME_FOR_THIS_BLOCK (\n    name\n) `print_timer &lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK {name, thread_cpu_time};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_record_for_this_block","title":"define PRINT_RECORD_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_RECORD_FOR_THIS_BLOCK (\n    name\n) `print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer {name};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_wall_time_for_this_block","title":"define PRINT_WALL_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_WALL_TIME_FOR_THIS_BLOCK (\n    name\n) `print_timer &lt;decltype((std::chrono::high_resolution_clock::now))&gt; PRINT_WALL_TIME_FOR_THIS_BLOCK {name, std::chrono::high_resolution_clock::now};`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/cpu_timer.hpp</code></p>"},{"location":"api/cpu__timer_8hpp_source/","title":"File cpu_timer.hpp","text":"<p>File List &gt; common &gt; cpu_timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n#include &lt;cerrno&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;thread&gt;\n\nstatic inline std::chrono::nanoseconds\ncpp_clock_gettime(clockid_t clock_id) {\n    /* This ensures the compiler won't reorder this function call; Pretend like it has memory side-effects. */\n    asm volatile (\"\"\n                  : /* OutputOperands */\n                  : /* InputOperands */\n                  : \"memory\" /* Clobbers */);\n    struct timespec ts;\n    if (clock_gettime(clock_id, &amp;ts)) {\n        throw std::runtime_error{std::string{\"clock_gettime returned \"} + strerror(errno)};\n    }\n    asm volatile (\"\"\n                  : /* OutputOperands */\n                  : /* InputOperands */\n                  : \"memory\" /* Clobbers */);\n    return std::chrono::seconds{ts.tv_sec} + std::chrono::nanoseconds{ts.tv_nsec};\n}\n\nstatic inline std::chrono::nanoseconds\nthread_cpu_time() {\n    return cpp_clock_gettime(CLOCK_THREAD_CPUTIME_ID);\n}\n\ntemplate &lt;\n    typename now_fn,\n    typename time_point = decltype(std::declval&lt;now_fn&gt;()()),\n    typename durationt = decltype(std::declval&lt;time_point&gt;() - std::declval&lt;time_point&gt;())\n    &gt;\nclass timer {\npublic:\n    timer(const now_fn&amp; now, durationt&amp; _duration)\n        : _p_now{now} , _p_duration{_duration} {\n        _p_start = _p_now();\n    }\n\n    ~timer() {\n        _p_duration = _p_now() - _p_start;\n    }\n\nprivate:\n    const now_fn&amp; _p_now;\n    durationt&amp; _p_duration;\n    time_point _p_start;\n};\n\ntemplate &lt;typename Duration, typename Out = decltype(std::declval&lt;Duration&gt;().count())&gt;\ntypename std::enable_if&lt;std::is_integral&lt;Out&gt;::value, Out&gt;::type\ncount_duration(Duration t) {\n    return std::chrono::duration_cast&lt;\n        std::chrono::nanoseconds,\n        typename Duration::rep,\n        typename Duration::period\n        &gt;(t).count();\n}\n\ntemplate &lt;typename Duration&gt;\ntypename std::enable_if&lt;std::is_integral&lt;Duration&gt;::value, Duration&gt;::type\ncount_duration(Duration t) {\n    return t;\n}\n\ntemplate &lt;\n    typename now_fn,\n    typename time_point = decltype(std::declval&lt;now_fn&gt;()()),\n    typename duration = decltype(std::declval&lt;time_point&gt;() - std::declval&lt;time_point&gt;())\n    &gt;\nclass print_timer {\nprivate:\n    class print_in_destructor {\n    public:\n        print_in_destructor(const std::string&amp; account_name, const duration&amp; _duration)\n            : _p_account_name{account_name}\n            , _p_duration{_duration}\n        { }\n        ~print_in_destructor() {\n            // std::ostringstream os;\n            // os &lt;&lt; \"cpu_timer,\" &lt;&lt; _p_account_name &lt;&lt; \",\" &lt;&lt; count_duration&lt;duration&gt;(_p_duration) &lt;&lt; \"\\n\";\n            if (rand() % 100 == 0) {\n                std::cout &lt;&lt; \"cpu_timer.hpp is DEPRECATED. See logging.hpp.\\n\";\n            }\n        }\n    private:\n        const std::string _p_account_name;\n        const duration&amp; _p_duration;\n    };\n\n    // NOTE that the destructors get called in reverse order!\n    // This is important, because _p_timer's destructor records the timing information\n    // Then, _p_print_in_destructor prints it\n    // Then, we can destroy _p_duration.\n    duration _p_duration;\n    const print_in_destructor _p_print_in_destructor;\n    const timer&lt;now_fn, time_point, duration&gt; _p_timer;\npublic:\n    print_timer(const std::string&amp; name, const now_fn&amp; now)\n        : _p_print_in_destructor{name, _p_duration}\n        , _p_timer{now, _p_duration}\n    { }\n};\n\nstatic std::size_t gen_serial_no() {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count();\n}\n\nclass should_profile_class {\npublic:\n    should_profile_class() {\n        const char* ILLIXR_STDOUT_METRICS = getenv(\"ILLIXR_STDOUT_METRICS\");\n        actually_should_profile = ILLIXR_STDOUT_METRICS &amp;&amp; (strcmp(ILLIXR_STDOUT_METRICS, \"y\") == 0);\n    }\n    bool operator()() {\n        return actually_should_profile;\n    }\nprivate:\n    bool actually_should_profile;\n};\n\nstatic should_profile_class should_profile;\n\nclass print_timer2 {\nprivate:\n    const std::string name;\n    const std::size_t serial_no;\n    std::size_t wall_time_start;\n    std::size_t cpu_time_start;\npublic:\n    print_timer2(std::string name_)\n        : name{name_}\n        , serial_no{should_profile() ? gen_serial_no() : std::size_t{0}}\n        , wall_time_start{should_profile()\n            ? std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count()\n            : std::size_t{0}\n        }\n        , cpu_time_start{should_profile() ? thread_cpu_time().count() : std::size_t{0}}\n    { }\n    ~print_timer2() {\n        if (should_profile()) {\n            auto cpu_time_stop = thread_cpu_time().count();\n            auto wall_time_stop  = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count();\n            std::cout &lt;&lt; \"cpu_timer,\" &lt;&lt; name &lt;&lt; \",\" &lt;&lt; serial_no &lt;&lt; \",\" &lt;&lt; wall_time_start &lt;&lt; \",\" &lt;&lt; wall_time_stop &lt;&lt; \",\" &lt;&lt; cpu_time_start &lt;&lt; \",\" &lt;&lt; cpu_time_stop &lt;&lt; \"\\n\";\n        }\n    }\n};\n\n#define PRINT_CPU_TIME_FOR_THIS_BLOCK(name)                                 \\\n    print_timer&lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK {name, thread_cpu_time};\n\n#define PRINT_WALL_TIME_FOR_THIS_BLOCK(name)                                    \\\n    print_timer&lt;decltype((std::chrono::high_resolution_clock::now))&gt; PRINT_WALL_TIME_FOR_THIS_BLOCK {name, std::chrono::high_resolution_clock::now};\n\n#define PRINT_RECORD_FOR_THIS_BLOCK(name)                                    \\\n    print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer {name};\n\ntemplate&lt; class Function, class... Args &gt;\nstd::thread timed_thread(const std::string&amp; account_name, Function&amp;&amp; f, Args&amp;&amp;... args) {\n    // Unfortunately we make copies of f and args.\n    // According to StackOverflow, this is unavoidable.\n    // See Sam Varshavchik's comment on https://stackoverflow.com/a/62380971/1078199\n    return std::thread([=] {\n        {   PRINT_RECORD_FOR_THIS_BLOCK(account_name);\n            std::invoke(f, args...);\n        }\n    });\n}\n</code></pre>"},{"location":"api/data__format_8hpp/","title":"File data_format.hpp","text":"<p>FileList &gt; common &gt; data_format.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;boost/optional.hpp&gt;</code></li> <li><code>#include &lt;opencv2/core/mat.hpp&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;GL/gl.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"switchboard.hpp\"</code></li> </ul>"},{"location":"api/data__format_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/data__format_8hpp/#classes","title":"Classes","text":"Type Name struct accel struct camera_frame struct hmd_physical_info struct hologram_input struct hologram_output struct imu_cam_type struct pose_type struct rendered_frame struct rendered_frame_alt struct rgb_depth_type"},{"location":"api/data__format_8hpp/#macros","title":"Macros","text":"Type Name define NANO_SEC <code>1000000000.0</code> define USE_ALT_EYE_FORMAT"},{"location":"api/data__format_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/data__format_8hpp/#define-nano_sec","title":"define NANO_SEC","text":"<pre><code>#define NANO_SEC `1000000000.0`\n</code></pre>"},{"location":"api/data__format_8hpp/#define-use_alt_eye_format","title":"define USE_ALT_EYE_FORMAT","text":"<pre><code>#define USE_ALT_EYE_FORMAT \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/data__format_8hpp_source/","title":"File data_format.hpp","text":"<p>File List &gt; common &gt; data_format.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;boost/optional.hpp&gt;\n\n#include &lt;opencv2/core/mat.hpp&gt;\n#undef Success // For 'Success' conflict\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;GL/gl.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n//#undef Complex // For 'Complex' conflict\n#include \"phonebook.hpp\"\n#include \"switchboard.hpp\"\n\n// Tell gldemo and timewarp_gl to use two texture handle for left and right eye\n#define USE_ALT_EYE_FORMAT\n#define NANO_SEC 1000000000.0\n\nnamespace ILLIXR {\n\n    typedef std::chrono::time_point&lt;std::chrono::system_clock&gt; time_type;\n    typedef unsigned long long ullong;\n\n    // Data type that combines the IMU and camera data at a certain timestamp.\n    // If there is only IMU data for a certain timestamp, img0 and img1 will be null\n    // time is the current UNIX time where dataset_time is the time read from the csv\n    typedef struct {\n        time_type time;\n        Eigen::Vector3f angular_v;\n        Eigen::Vector3f linear_a;\n        std::optional&lt;cv::Mat*&gt; img0;\n        std::optional&lt;cv::Mat*&gt; img1;\n        ullong dataset_time;\n    } imu_cam_type;\n\n    typedef struct {\n      int64_t time;\n      const unsigned char* rgb;\n      const unsigned short* depth;\n    } rgb_depth_type;\n\n    typedef struct {\n        time_type time;\n        Eigen::Vector3f position;\n        Eigen::Quaternionf orientation;\n    } pose_type;\n\n    typedef struct {\n        int pixel[1];\n    } camera_frame;\n\n    // Single-texture format; arrayed by left/right eye\n    // Single-texture format; arrayed by left/right eye\n    struct rendered_frame {\n        GLuint texture_handle;\n        pose_type render_pose; // The pose used when rendering this frame.\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; sample_time;\n    };\n\n    // Using arrays as a swapchain\n    // Array of left eyes, array of right eyes\n    // This more closely matches the format used by Monado\n    struct rendered_frame_alt {\n        GLuint texture_handles[2]; // Does not change between swaps in swapchain\n        GLuint swap_indices[2]; // Which element of the swapchain\n        pose_type render_pose; // The pose used when rendering this frame.\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; sample_time;\n    };\n\n    typedef struct {\n        int seq;\n    } hologram_input;\n\n    typedef struct {\n        int dummy;\n    } hologram_output;\n\n    /* I use \"accel\" instead of \"3-vector\" as a datatype, because\n    this checks that you meant to use an acceleration in a certain\n    place. */\n    struct accel { };\n\n    // High-level HMD specification, timewarp plugin\n    // may/will calculate additional HMD info based on these specifications\n    struct hmd_physical_info {\n        float   ipd;\n        int     displayPixelsWide;\n        int     displayPixelsHigh;\n        float   chromaticAberration[4];\n        float   K[11];\n        int     visiblePixelsWide;\n        int     visiblePixelsHigh;\n        float   visibleMetersWide;\n        float   visibleMetersHigh;\n        float   lensSeparationInMeters;\n        float   metersPerTanAngleAtCenter;\n    };\n}\n</code></pre>"},{"location":"api/dynamic__lib_8hpp/","title":"File dynamic_lib.hpp","text":"<p>FileList &gt; common &gt; dynamic_lib.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;dlfcn.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> </ul>"},{"location":"api/dynamic__lib_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/dynamic__lib_8hpp/#classes","title":"Classes","text":"Type Name class dynamic_lib <p>The documentation for this class was generated from the following file <code>common/dynamic_lib.hpp</code></p>"},{"location":"api/dynamic__lib_8hpp_source/","title":"File dynamic_lib.hpp","text":"<p>File List &gt; common &gt; dynamic_lib.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;dlfcn.h&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;functional&gt;\n\nnamespace ILLIXR {\n\nusing void_ptr = std::unique_ptr&lt;void, std::function&lt;void(void*)&gt;&gt;;\n/*\nUsage:\n    void* thing;\n    void_ptr wrapped_thing = {thing, [](void* thing) {\n        // destructor goes here.\n    }}\n    // wrapped_thing.get() returns underlying thing.\n */\n\nclass dynamic_lib {\nprivate:\n    dynamic_lib(void_ptr&amp;&amp; handle)\n        : _m_handle{std::move(handle)}\n    { }\n\npublic:\n    dynamic_lib(dynamic_lib&amp;&amp; other)\n        : _m_handle{std::move(other._m_handle)}\n    { }\n\n    dynamic_lib&amp; operator=(dynamic_lib&amp;&amp; other) {\n        if (this != &amp;other) {\n            _m_handle = std::move(other._m_handle);\n        }\n        return *this;\n    }\n\n    static dynamic_lib create(const std::string_view&amp; path) {\n        char* error;\n        void* handle = dlopen(path.data(), RTLD_LAZY | RTLD_LOCAL);\n        if ((error = dlerror()) || !handle)\n            throw std::runtime_error{\n                \"dlopen(\" + std::string{path} + \"): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n\n        return dynamic_lib{void_ptr{handle, [](void* handle) {\n            char* error;\n            int ret = dlclose(handle);\n            if ((error = dlerror()) || ret)\n                throw std::runtime_error{\n                    \"dlclose(): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n        }}};\n    }\n\n    const void* operator[](const std::string&amp; symbol_name) const {\n        char* error;\n        void* symbol = dlsym(_m_handle.get(), symbol_name.c_str());\n        if ((error = dlerror()))\n            throw std::runtime_error{\n                \"dlsym(\" + symbol_name + \"): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n        return symbol;\n    }\n\n    template &lt;typename T&gt;\n    const T get(const std::string&amp; symbol_name) const {\n        const void* obj = (*this)[symbol_name];\n        // return reinterpret_cast&lt;const T&gt;((*this)[symbol_name]);\n        return (const T) obj;\n    }\n\nprivate:\n    void_ptr _m_handle;\n};\n\n}\n</code></pre>"},{"location":"api/extended__window_8hpp/","title":"File extended_window.hpp","text":"<p>FileList &gt; common &gt; extended_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;X11/X.h&gt;</code></li> <li><code>#include &lt;X11/Xlib.h&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include &lt;GL/glu.h&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> </ul>"},{"location":"api/extended__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/extended__window_8hpp/#classes","title":"Classes","text":"Type Name class xlib_gl_extended_window"},{"location":"api/extended__window_8hpp/#public-types","title":"Public Types","text":"Type Name typedef GLXContext(* glXCreateContextAttribsARBProc"},{"location":"api/extended__window_8hpp/#macros","title":"Macros","text":"Type Name define GLX_CONTEXT_MAJOR_VERSION_ARB <code>0x2091</code> define GLX_CONTEXT_MINOR_VERSION_ARB <code>0x2092</code>"},{"location":"api/extended__window_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/extended__window_8hpp/#typedef-glxcreatecontextattribsarbproc","title":"typedef glXCreateContextAttribsARBProc","text":"<pre><code>typedef GLXContext(* glXCreateContextAttribsARBProc) (Display *, GLXFBConfig, GLXContext, Bool, const int *);\n</code></pre>"},{"location":"api/extended__window_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/extended__window_8hpp/#define-glx_context_major_version_arb","title":"define GLX_CONTEXT_MAJOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MAJOR_VERSION_ARB `0x2091`\n</code></pre>"},{"location":"api/extended__window_8hpp/#define-glx_context_minor_version_arb","title":"define GLX_CONTEXT_MINOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MINOR_VERSION_ARB `0x2092`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/extended_window.hpp</code></p>"},{"location":"api/extended__window_8hpp_source/","title":"File extended_window.hpp","text":"<p>File List &gt; common &gt; extended_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;X11/X.h&gt;\n#include &lt;X11/Xlib.h&gt;\n#include &lt;GL/glx.h&gt;\n#include &lt;GL/glu.h&gt;\n#include \"phonebook.hpp\"\n\n//GLX context magics\n#define GLX_CONTEXT_MAJOR_VERSION_ARB       0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB       0x2092\ntypedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);\n\nnamespace ILLIXR{\n    class xlib_gl_extended_window : public phonebook::service {\n    public:\n        int                     width;\n        int                     height;\n        Display                 *dpy;\n        Window                  win;\n        GLXContext              glc;\n        xlib_gl_extended_window(int _width, int _height, GLXContext _shared_gl_context){\n            width = _width;\n            height = _height;\n\n            dpy = XOpenDisplay(NULL);\n            if(dpy == NULL) {\n                printf(\"\\n\\tcannot connect to X server\\n\\n\");\n                    exit(0);\n            }\n            Window root = DefaultRootWindow(dpy);\n            // Get a matching FB config\n            static int visual_attribs[] =\n            {\n                GLX_X_RENDERABLE    , True,\n                GLX_DRAWABLE_TYPE   , GLX_WINDOW_BIT,\n                GLX_RENDER_TYPE     , GLX_RGBA_BIT,\n                GLX_X_VISUAL_TYPE   , GLX_TRUE_COLOR,\n                GLX_RED_SIZE        , 8,\n                GLX_GREEN_SIZE      , 8,\n                GLX_BLUE_SIZE       , 8,\n                GLX_ALPHA_SIZE      , 8,\n                GLX_DEPTH_SIZE      , 24,\n                GLX_STENCIL_SIZE    , 8,\n                GLX_DOUBLEBUFFER    , True,\n                //GLX_SAMPLE_BUFFERS  , 1,\n                //GLX_SAMPLES         , 4,\n                None\n            };\n            // vi = glXChooseVisual(dpy, 0, att);\n            // if(vi == NULL) {\n            //  printf(\"\\n\\tno appropriate visual found\\n\\n\");\n            //         exit(0);\n            // }\n            // else {\n            //  printf(\"\\n\\tvisual %p selected\\n\", (void *)vi-&gt;visualid); /* %p creates hexadecimal output like in glxinfo */\n            // }\n#ifndef NDEBUG\n            printf( \"Getting matching framebuffer configs\\n\" );\n#endif\n            int fbcount;\n            GLXFBConfig* fbc = glXChooseFBConfig(dpy, DefaultScreen(dpy), visual_attribs, &amp;fbcount);\n            if (!fbc)\n            {\n                printf( \"Failed to retrieve a framebuffer config\\n\" );\n                exit(1);\n            }\n#ifndef NDEBUG\n            printf( \"Found %d matching FB configs.\\n\", fbcount );\n            // Pick the FB config/visual with the most samples per pixel\n            printf( \"Getting XVisualInfos\\n\" );\n#endif\n            int best_fbc = -1, worst_fbc = -1, best_num_samp = -1, worst_num_samp = 999;\n            int i;\n            for (i=0; i&lt;fbcount; ++i)\n            {\n                XVisualInfo *vi = glXGetVisualFromFBConfig( dpy, fbc[i] );\n                if ( vi )\n                {\n                    int samp_buf, samples;\n                    glXGetFBConfigAttrib( dpy, fbc[i], GLX_SAMPLE_BUFFERS, &amp;samp_buf );\n                    glXGetFBConfigAttrib( dpy, fbc[i], GLX_SAMPLES       , &amp;samples  );\n#ifndef NDEBUG\n                    printf( \"  Matching fbconfig %d, visual ID 0x%2lx: SAMPLE_BUFFERS = %d,\"\n                            \" SAMPLES = %d\\n\",\n                            i, vi -&gt; visualid, samp_buf, samples );\n#endif\n                    if ( best_fbc &lt; 0 || (samp_buf &amp;&amp; samples &gt; best_num_samp) )\n                      best_fbc = i, best_num_samp = samples;\n                    if ( worst_fbc &lt; 0 || !samp_buf || samples &lt; worst_num_samp )\n                      worst_fbc = i, worst_num_samp = samples;\n                }\n                XFree( vi );\n            }\n            GLXFBConfig bestFbc = fbc[ best_fbc ];\n            // Be sure to free the FBConfig list allocated by glXChooseFBConfig()\n            XFree( fbc );\n            // Get a visual\n            XVisualInfo *vi = glXGetVisualFromFBConfig( dpy, bestFbc );\n#ifndef NDEBUG\n            printf( \"Chosen visual ID = 0x%lx\\n\", vi-&gt;visualid );\n#endif\n\n            Colormap cmap = XCreateColormap(dpy, root, vi-&gt;visual, AllocNone);\n            XSetWindowAttributes swa;\n            swa.colormap = cmap;\n            swa.event_mask = ExposureMask | KeyPressMask;\n            win = XCreateWindow(dpy, root, 0, 0, width, height, 0, vi-&gt;depth, InputOutput, vi-&gt;visual, CWColormap | CWEventMask, &amp;swa);\n            XMapWindow(dpy, win);\n            XStoreName(dpy, win, \"ILLIXR Extended Window\");\n\n            //glc = glXCreateContext(dpy, vi, *ctx, true);\n            // calling glXGetProcAddressARB\n            glXCreateContextAttribsARBProc glXCreateContextAttribsARB = 0;\n            glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)\n                glXGetProcAddressARB( (const GLubyte *) \"glXCreateContextAttribsARB\" );\n            int context_attribs[] =\n                {\n                    GLX_CONTEXT_MAJOR_VERSION_ARB, 4,\n                    GLX_CONTEXT_MINOR_VERSION_ARB, 0,\n                    //GLX_CONTEXT_FLAGS_ARB        , GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,\n                    None\n                };\n#ifndef NDEBUG\n            printf( \"Creating context\\n\" );\n#endif\n            glc = glXCreateContextAttribsARB( dpy, bestFbc, _shared_gl_context,\n                                                   True, context_attribs );\n        }\n    };\n}\n</code></pre>"},{"location":"api/linalg_8hpp/","title":"File linalg.hpp","text":"<p>FileList &gt; common &gt; linalg.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;iosfwd&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"api/linalg_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace linalg namespace aliases namespace detail namespace ostream_overloads namespace std"},{"location":"api/linalg_8hpp/#classes","title":"Classes","text":"Type Name struct converter &lt;class T, class U&gt; struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; &lt;class T&gt; struct any_compare &lt;class A, class B&gt; struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct apply &lt;class F, class Void, T&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; &lt;class F, M, N, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; &lt;class F, M, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; &lt;class F, A&gt; struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct clamp struct empty struct getter&lt; 0 &gt; &lt;&gt; struct getter&lt; 1 &gt; &lt;&gt; struct getter&lt; 2 &gt; &lt;&gt; struct getter&lt; 3 &gt; &lt;&gt; struct lerp struct make_seq_impl&lt; A, 0 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 1 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 2 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 3 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 4 &gt; &lt;A&gt; struct max struct min struct op_add struct op_and struct op_cmp struct op_div struct op_eq struct op_ge struct op_gt struct op_int struct op_le struct op_lsh struct op_lt struct op_mod struct op_mul struct op_ne struct op_neg struct op_not struct op_or struct op_pos struct op_rsh struct op_sub struct op_un struct op_xor struct ord &lt;class T&gt; struct scalar_type &lt;class A&gt; struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; &lt;class T, M, N&gt; struct scalar_type&lt; vec&lt; T, M &gt; &gt; &lt;class T, M&gt; struct scalars&lt; T, U... &gt; &lt;class T, U&gt; struct scalars&lt;&gt; &lt;&gt; struct select struct seq &lt;I&gt; struct std_abs struct std_acos struct std_asin struct std_atan struct std_atan2 struct std_ceil struct std_copysign struct std_cos struct std_cosh struct std_exp struct std_floor struct std_fmod struct std_log struct std_log10 struct std_pow struct std_round struct std_sin struct std_sinh struct std_sqrt struct std_tan struct std_tanh struct identity_t struct mat&lt; T, M, 1 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 2 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 3 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 4 &gt; &lt;class T, M&gt; struct vec&lt; T, 1 &gt; &lt;class T&gt; struct vec&lt; T, 2 &gt; &lt;class T&gt; struct vec&lt; T, 3 &gt; &lt;class T&gt; struct vec&lt; T, 4 &gt; &lt;class T&gt; struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; &lt;class T&gt;"},{"location":"api/linalg_8hpp/#macros","title":"Macros","text":"Type Name define LINALG_CONSTEXPR14 define LINALG_H"},{"location":"api/linalg_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/linalg_8hpp/#define-linalg_constexpr14","title":"define LINALG_CONSTEXPR14","text":"<pre><code>#define LINALG_CONSTEXPR14 \n</code></pre>"},{"location":"api/linalg_8hpp/#define-linalg_h","title":"define LINALG_H","text":"<pre><code>#define LINALG_H \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/linalg_8hpp_source/","title":"File linalg.hpp","text":"<p>File List &gt; common &gt; linalg.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// linalg.h - v2.0 - Single-header public domain linear algebra library\n//\n// The intent of this library is to provide the bulk of the functionality\n// you need to write programs that frequently use small, fixed-size vectors\n// and matrices, in domains such as computational geometry or computer\n// graphics. It strives for terse, readable source code.\n//\n// The original author of this software is Sterling Orsten, and its permanent\n// home is &lt;http://github.com/sgorsten/linalg/&gt;. If you find this software\n// useful, an acknowledgement in your source text and/or product documentation\n// is appreciated, but not required.\n//\n// The author acknowledges significant insights and contributions by:\n//     Stan Melax &lt;http://github.com/melax/&gt;\n//     Dimitri Diakopoulos &lt;http://github.com/ddiakopoulos/&gt;\n\n\n\n// This is free and unencumbered software released into the public domain.\n// \n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n// \n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n// \n// For more information, please refer to &lt;http://unlicense.org/&gt;\n\n\n\n#pragma once\n#ifndef LINALG_H\n#define LINALG_H\n\n#include &lt;cmath&gt;        // For various unary math functions, such as std::sqrt\n#include &lt;cstdlib&gt;      // To resolve std::abs ambiguity on clang\n#include &lt;cstdint&gt;      // For implementing namespace linalg::aliases\n#include &lt;array&gt;        // For std::array\n#include &lt;iosfwd&gt;       // For forward definitions of std::ostream\n#include &lt;type_traits&gt;  // For std::enable_if, std::is_same, std::declval\n\n// In Visual Studio 2015, `constexpr` applied to a member function implies `const`, which causes ambiguous overload resolution\n#if _MSC_VER &lt;= 1900\n#define LINALG_CONSTEXPR14\n#else\n#define LINALG_CONSTEXPR14 constexpr\n#endif\n\nnamespace linalg\n{\n    // Small, fixed-length vector type, consisting of exactly M elements of type T, and presumed to be a column-vector unless otherwise noted.\n    template&lt;class T, int M&gt; struct vec;\n\n    // Small, fixed-size matrix type, consisting of exactly M rows and N columns of type T, stored in column-major order.\n    template&lt;class T, int M, int N&gt; struct mat;\n\n    // Specialize converter&lt;T,U&gt; with a function application operator that converts type U to type T to enable implicit conversions\n    template&lt;class T, class U&gt; struct converter {};\n    namespace detail \n    { \n        template&lt;class T, class U&gt; using conv_t = typename std::enable_if&lt;!std::is_same&lt;T,U&gt;::value, decltype(converter&lt;T,U&gt;{}(std::declval&lt;U&gt;()))&gt;::type;\n\n        // Trait for retrieving scalar type of any linear algebra object\n        template&lt;class A&gt; struct scalar_type {};\n        template&lt;class T, int M       &gt; struct scalar_type&lt;vec&lt;T,M  &gt;&gt; { using type = T; };\n        template&lt;class T, int M, int N&gt; struct scalar_type&lt;mat&lt;T,M,N&gt;&gt; { using type = T; };\n\n        // Type returned by the compare(...) function which supports all six comparison operators against 0\n        template&lt;class T&gt; struct ord { T a,b; };\n        template&lt;class T&gt; constexpr bool operator == (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.a == o.b; }\n        template&lt;class T&gt; constexpr bool operator != (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.a == o.b); }\n        template&lt;class T&gt; constexpr bool operator &lt; (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.a &lt; o.b; }\n        template&lt;class T&gt; constexpr bool operator &gt; (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.b &lt; o.a; }\n        template&lt;class T&gt; constexpr bool operator &lt;= (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.b &lt; o.a); }\n        template&lt;class T&gt; constexpr bool operator &gt;= (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.a &lt; o.b); }\n\n        // Patterns which can be used with the compare(...) function\n        template&lt;class A, class B&gt; struct any_compare {};\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,1&gt;,vec&lt;T,1&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,1&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) const { return ord&lt;T&gt;{a.x,b.x}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,2&gt;,vec&lt;T,2&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : ord&lt;T&gt;{a.y,b.y}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,3&gt;,vec&lt;T,3&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : !(a.y==b.y) ? ord&lt;T&gt;{a.y,b.y} : ord&lt;T&gt;{a.z,b.z}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,4&gt;,vec&lt;T,4&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : !(a.y==b.y) ? ord&lt;T&gt;{a.y,b.y} : !(a.z==b.z) ? ord&lt;T&gt;{a.z,b.z} : ord&lt;T&gt;{a.w,b.w}; } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,1&gt;,mat&lt;T,M,1&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,1&gt; &amp; a, const mat&lt;T,M,1&gt; &amp; b) const { return compare(a.x,b.x); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,2&gt;,mat&lt;T,M,2&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,2&gt; &amp; a, const mat&lt;T,M,2&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : compare(a.y,b.y); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,3&gt;,mat&lt;T,M,3&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,3&gt; &amp; a, const mat&lt;T,M,3&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : a.y!=b.y ? compare(a.y,b.y) : compare(a.z,b.z); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,4&gt;,mat&lt;T,M,4&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,4&gt; &amp; a, const mat&lt;T,M,4&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : a.y!=b.y ? compare(a.y,b.y) : a.z!=b.z ? compare(a.z,b.z) : compare(a.w,b.w); } }; \n\n        // Helper for compile-time index-based access to members of vector and matrix types\n        template&lt;int I&gt; struct getter;\n        template&lt;&gt; struct getter&lt;0&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.x) { return a.x; } };\n        template&lt;&gt; struct getter&lt;1&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.y) { return a.y; } };\n        template&lt;&gt; struct getter&lt;2&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.z) { return a.z; } };\n        template&lt;&gt; struct getter&lt;3&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.w) { return a.w; } };\n\n        // Stand-in for std::integer_sequence/std::make_integer_sequence\n        template&lt;int... I&gt; struct seq {};\n        template&lt;int A, int N&gt; struct make_seq_impl;\n        template&lt;int A&gt; struct make_seq_impl&lt;A,0&gt; { using type=seq&lt;&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,1&gt; { using type=seq&lt;A+0&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,2&gt; { using type=seq&lt;A+0,A+1&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,3&gt; { using type=seq&lt;A+0,A+1,A+2&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,4&gt; { using type=seq&lt;A+0,A+1,A+2,A+3&gt;; };\n        template&lt;int A, int B&gt; using make_seq = typename make_seq_impl&lt;A,B-A&gt;::type;\n        template&lt;class T, int M, int... I&gt; vec&lt;T,sizeof...(I)&gt; constexpr swizzle(const vec&lt;T,M&gt; &amp; v, seq&lt;I...&gt;) { return {getter&lt;I&gt;{}(v)...}; }\n        template&lt;class T, int M, int N, int... I, int... J&gt; mat&lt;T,sizeof...(I),sizeof...(J)&gt; constexpr swizzle(const mat&lt;T,M,N&gt; &amp; m, seq&lt;I...&gt; i, seq&lt;J...&gt;) { return {swizzle(getter&lt;J&gt;{}(m),i)...}; }\n\n        // SFINAE helpers to determine result of function application\n        template&lt;class F, class... T&gt; using ret_t = decltype(std::declval&lt;F&gt;()(std::declval&lt;T&gt;()...));\n\n        // SFINAE helper which is defined if all provided types are scalars\n        struct empty {};\n        template&lt;class... T&gt; struct scalars;\n        template&lt;&gt; struct scalars&lt;&gt; { using type=void; };\n        template&lt;class T, class... U&gt; struct scalars&lt;T,U...&gt; : std::conditional&lt;std::is_arithmetic&lt;T&gt;::value, scalars&lt;U...&gt;, empty&gt;::type {};\n        template&lt;class... T&gt; using scalars_t = typename scalars&lt;T...&gt;::type;\n\n        // Helpers which indicate how apply(F, ...) should be called for various arguments\n        template&lt;class F, class Void, class... T&gt; struct apply {}; // Patterns which contain only vectors or scalars\n        template&lt;class F, int M, class A                  &gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;                    &gt; { using type=vec&lt;ret_t&lt;F,A    &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a                                        ) { return {f(getter&lt;I&gt;{}(a)                                )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;          &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b                    ) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b)                )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;B  &gt;, vec&lt;A,M&gt;, B                 &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b                    ) { return {f(getter&lt;I&gt;{}(a), b                             )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;A  &gt;, A,        vec&lt;B,M&gt;          &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b                    ) { return {f(a,              getter&lt;I&gt;{}(b)                )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;, vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b, const vec&lt;C,M&gt; &amp; c) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b), getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;C  &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;, C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b, C                c) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b), c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;B  &gt;, vec&lt;A,M&gt;, B,        vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b, const vec&lt;C,M&gt; &amp; c) { return {f(getter&lt;I&gt;{}(a), b,              getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;B,C&gt;, vec&lt;A,M&gt;, B,        C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b, C                c) { return {f(getter&lt;I&gt;{}(a), b,              c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A  &gt;, A,        vec&lt;B,M&gt;, vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b, const vec&lt;C,M&gt; &amp; c) { return {f(a,              getter&lt;I&gt;{}(b), getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A,C&gt;, A,        vec&lt;B,M&gt;, C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b, C                c) { return {f(a,              getter&lt;I&gt;{}(b), c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A,B&gt;, A,        B,        vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, B                b, const vec&lt;C,M&gt; &amp; c) { return {f(a,              b,              getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, int N, class A         &gt; struct apply&lt;F, scalars_t&lt; &gt;, mat&lt;A,M,N&gt;            &gt; { using type=mat&lt;ret_t&lt;F,A  &gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a                      ) { return {apply&lt;F, void, vec&lt;A,M&gt;          &gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a)                )...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt; &gt;, mat&lt;A,M,N&gt;, mat&lt;B,M,N&gt;&gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a, const mat&lt;B,M,N&gt; &amp; b) { return {apply&lt;F, void, vec&lt;A,M&gt;, vec&lt;B,M&gt;&gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a), getter&lt;J&gt;{}(b))...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt;B&gt;, mat&lt;A,M,N&gt;, B         &gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a, B                  b) { return {apply&lt;F, void, vec&lt;A,M&gt;, B       &gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a), b             )...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt;A&gt;, A,          mat&lt;B,M,N&gt;&gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, A                  a, const mat&lt;B,M,N&gt; &amp; b) { return {apply&lt;F, void, A,        vec&lt;B,M&gt;&gt;::impl(make_seq&lt;0,M&gt;{}, f, a,              getter&lt;J&gt;{}(b))...}; } };\n        template&lt;class F, class... A&gt; struct apply&lt;F, scalars_t&lt;A...&gt;, A...&gt; { using type = ret_t&lt;F,A...&gt;; enum {size=0}; static constexpr type impl(seq&lt;&gt;, F f, A... a) { return f(a...); } };\n\n        // Function objects for selecting between alternatives\n        struct min    { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? a : b)&gt;::type { return a&lt;b ? a : b; } };\n        struct max    { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? b : a)&gt;::type { return a&lt;b ? b : a; } };\n        struct clamp  { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? b : a&lt;c ? a : c)&gt;::type { return a&lt;b ? b : a&lt;c ? a : c; } };\n        struct select { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; typename std::remove_reference&lt;decltype(a ? b : c)&gt;::type             { return a ? b : c; } };\n        struct lerp   { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; decltype(a*(1-c) + b*c)                                               { return a*(1-c) + b*c; } };\n\n        // Function objects for applying operators\n        struct op_pos { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(+a) { return +a; } };\n        struct op_neg { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(-a) { return -a; } };\n        struct op_not { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(!a) { return !a; } };\n        struct op_cmp { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(~(a)) { return ~a; } };\n        struct op_mul { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a * b)  { return a * b; } };\n        struct op_div { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a / b)  { return a / b; } };\n        struct op_mod { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a % b)  { return a % b; } };\n        struct op_add { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a + b)  { return a + b; } };\n        struct op_sub { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a - b)  { return a - b; } };\n        struct op_lsh { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt;&lt; b) { return a &lt;&lt; b; } };\n        struct op_rsh { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt;&gt; b) { return a &gt;&gt; b; } };\n        struct op_lt  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt; b)  { return a &lt; b; } };\n        struct op_gt  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt; b)  { return a &gt; b; } };\n        struct op_le  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt;= b) { return a &lt;= b; } };\n        struct op_ge  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt;= b) { return a &gt;= b; } };\n        struct op_eq  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a == b) { return a == b; } };\n        struct op_ne  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a != b) { return a != b; } };\n        struct op_int { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &amp; b)  { return a &amp; b; } };        \n        struct op_xor { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a ^ b)  { return a ^ b; } };\n        struct op_un  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a | b)  { return a | b; } };\n        struct op_and { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &amp;&amp; b) { return a &amp;&amp; b; } };\n        struct op_or  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a || b) { return a || b; } };\n\n        // Function objects for applying standard library math functions\n        struct std_abs      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::abs  (a)) { return std::abs  (a); } };\n        struct std_floor    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::floor(a)) { return std::floor(a); } };\n        struct std_ceil     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::ceil (a)) { return std::ceil (a); } };\n        struct std_exp      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::exp  (a)) { return std::exp  (a); } };\n        struct std_log      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::log  (a)) { return std::log  (a); } };\n        struct std_log10    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::log10(a)) { return std::log10(a); } };\n        struct std_sqrt     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sqrt (a)) { return std::sqrt (a); } };\n        struct std_sin      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sin  (a)) { return std::sin  (a); } };\n        struct std_cos      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::cos  (a)) { return std::cos  (a); } };\n        struct std_tan      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::tan  (a)) { return std::tan  (a); } };\n        struct std_asin     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::asin (a)) { return std::asin (a); } };\n        struct std_acos     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::acos (a)) { return std::acos (a); } };\n        struct std_atan     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::atan (a)) { return std::atan (a); } };\n        struct std_sinh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sinh (a)) { return std::sinh (a); } };\n        struct std_cosh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::cosh (a)) { return std::cosh (a); } };\n        struct std_tanh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::tanh (a)) { return std::tanh (a); } };\n        struct std_round    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::round(a)) { return std::round(a); } };\n        struct std_fmod     { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::fmod    (a, b)) { return std::fmod    (a, b); } };\n        struct std_pow      { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::pow     (a, b)) { return std::pow     (a, b); } };\n        struct std_atan2    { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::atan2   (a, b)) { return std::atan2   (a, b); } };\n        struct std_copysign { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::copysign(a, b)) { return std::copysign(a, b); } };\n    }\n\n    // Small, fixed-length vector type, consisting of exactly M elements of type T, and presumed to be a column-vector unless otherwise noted\n    template&lt;class T&gt; struct vec&lt;T,1&gt;\n    {\n        T                           x;\n        constexpr                   vec()                               : x() {}\n        constexpr                   vec(const T &amp; x_)                   : x(x_) {}\n        // NOTE: vec&lt;T,1&gt; does NOT have a constructor from pointer, this can conflict with initializing its single element from zero\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,1&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x)) {}\n        constexpr const T &amp;         operator[] (int)   const            { return x; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int)                    { return x; }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,2&gt;\n    {\n        T                           x,y;\n        constexpr                   vec()                               : x(), y() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_)     : x(x_), y(y_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1]) {}\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,2&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:y; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:y; }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,3&gt;\n    {\n        T                           x,y,z;\n        constexpr                   vec()                               : x(), y(), z() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_, \n                                        const T &amp; z_)                   : x(x_), y(y_), z(z_) {}\n        constexpr                   vec(const vec&lt;T,2&gt; &amp; xy,\n                                        const T &amp; z_)                   : vec(xy.x, xy.y, z_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1], p[2]) {}\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,3&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y), static_cast&lt;T&gt;(v.z)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:i==1?y:z; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:i==1?y:z; }\n        constexpr const vec&lt;T,2&gt; &amp;  xy() const                          { return *reinterpret_cast&lt;const vec&lt;T,2&gt; *&gt;(this); }\n        vec&lt;T,2&gt; &amp;                  xy()                                { return *reinterpret_cast&lt;vec&lt;T,2&gt; *&gt;(this); }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,4&gt;\n    {\n        T                           x,y,z,w;\n        constexpr                   vec()                               : x(), y(), z(), w() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_,\n                                        const T &amp; z_, const T &amp; w_)     : x(x_), y(y_), z(z_), w(w_) {}\n        constexpr                   vec(const vec&lt;T,2&gt; &amp; xy, \n                                        const T &amp; z_, const T &amp; w_)     : vec(xy.x, xy.y, z_, w_) {}\n        constexpr                   vec(const vec&lt;T,3&gt; &amp; xyz,\n                                        const T &amp; w_)                   : vec(xyz.x, xyz.y, xyz.z, w_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s, s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1], p[2], p[3]) {}\n        template&lt;class U&gt; \n        constexpr explicit          vec(const vec&lt;U,4&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y), static_cast&lt;T&gt;(v.z), static_cast&lt;T&gt;(v.w)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:i==1?y:i==2?z:w; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:i==1?y:i==2?z:w; }\n        constexpr const vec&lt;T,2&gt; &amp;  xy() const                          { return *reinterpret_cast&lt;const vec&lt;T,2&gt; *&gt;(this); }\n        constexpr const vec&lt;T,3&gt; &amp;  xyz() const                         { return *reinterpret_cast&lt;const vec&lt;T,3&gt; *&gt;(this); }\n        vec&lt;T,2&gt; &amp;                  xy()                                { return *reinterpret_cast&lt;vec&lt;T,2&gt; *&gt;(this); }                \n        vec&lt;T,3&gt; &amp;                  xyz()                               { return *reinterpret_cast&lt;vec&lt;T,3&gt; *&gt;(this); }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n\n    // Small, fixed-size matrix type, consisting of exactly M rows and N columns of type T, stored in column-major order.\n    template&lt;class T, int M&gt; struct mat&lt;T,M,1&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x;\n        constexpr                   mat()                               : x() {}\n        constexpr                   mat(const V &amp; x_)                   : x(x_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,1&gt; &amp; m)           : mat(V(m.x)) {}\n        constexpr vec&lt;T,1&gt;          row(int i) const                    { return {x[i]}; }\n        constexpr const V &amp;         operator[] (int) const              { return x; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int)                    { return x; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,2&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y;\n        constexpr                   mat()                               : x(), y() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_)     : x(x_), y(y_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,2&gt; &amp; m)           : mat(V(m.x), V(m.y)) {}\n        constexpr vec&lt;T,2&gt;          row(int i) const                    { return {x[i], y[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:y; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:y; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,3&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y,z;\n        constexpr                   mat()                               : x(), y(), z() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_, \n                                        const V &amp; z_)                   : x(x_), y(y_), z(z_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s), z(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1), z(p+M*2) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,3&gt; &amp; m)           : mat(V(m.x), V(m.y), V(m.z)) {}\n        constexpr vec&lt;T,3&gt;          row(int i) const                    { return {x[i], y[i], z[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:j==1?y:z; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:j==1?y:z; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,4&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y,z,w;\n        constexpr                   mat()                               : x(), y(), z(), w() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_,\n                                        const V &amp; z_, const V &amp; w_)     : x(x_), y(y_), z(z_), w(w_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s), z(s), w(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1), z(p+M*2), w(p+M*3) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,4&gt; &amp; m)           : mat(V(m.x), V(m.y), V(m.z), V(m.w)) {}\n        constexpr vec&lt;T,4&gt;          row(int i) const                    { return {x[i], y[i], z[i], w[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:j==1?y:j==2?z:w; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:j==1?y:j==2?z:w; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n\n    // Define a type which will convert to the multiplicative identity of any square matrix\n    struct identity_t { constexpr explicit identity_t(int) {} };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,1,1&gt;, identity_t&gt; { mat&lt;T,1,1&gt; operator() (identity_t) const { return {vec&lt;T,1&gt;{1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,2,2&gt;, identity_t&gt; { mat&lt;T,2,2&gt; operator() (identity_t) const { return {{1,0},{0,1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,3,3&gt;, identity_t&gt; { mat&lt;T,3,3&gt; operator() (identity_t) const { return {{1,0,0},{0,1,0},{0,0,1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,4,4&gt;, identity_t&gt; { mat&lt;T,4,4&gt; operator() (identity_t) const { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}; } };\n    constexpr identity_t identity {1};\n\n    // Produce a scalar by applying f(A,B) -&gt; A to adjacent pairs of elements from a vec/mat in left-to-right/column-major order (matching the associativity of arithmetic and logical operators)\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,1&gt; &amp; b) { return f(a, b.x); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,2&gt; &amp; b) { return f(f(a, b.x), b.y); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,3&gt; &amp; b) { return f(f(f(a, b.x), b.y), b.z); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,4&gt; &amp; b) { return f(f(f(f(a, b.x), b.y), b.z), b.w); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,1&gt; &amp; b) { return fold(f, a, b.x); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,2&gt; &amp; b) { return fold(f, fold(f, a, b.x), b.y); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,3&gt; &amp; b) { return fold(f, fold(f, fold(f, a, b.x), b.y), b.z); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,4&gt; &amp; b) { return fold(f, fold(f, fold(f, fold(f, a, b.x), b.y), b.z), b.w); }\n\n    // Type aliases for the result of calling apply(...) with various arguments, can be used with return type SFINAE to constrian overload sets\n    template&lt;class F, class... A&gt; using apply_t = typename detail::apply&lt;F,void,A...&gt;::type;\n    template&lt;class A&gt; using scalar_t = typename detail::scalar_type&lt;A&gt;::type; // Underlying scalar type when performing elementwise operations\n\n    // apply(f,...) applies the provided function in an elementwise fashion to its arguments, producing an object of the same dimensions\n    template&lt;class F, class... A&gt; constexpr apply_t&lt;F,A...&gt; apply(F func, const A &amp; ... args) { return detail::apply&lt;F,void,A...&gt;::impl(detail::make_seq&lt;0,detail::apply&lt;F,void,A...&gt;::size&gt;{}, func, args...); }\n\n    // map(a,f) is equivalent to apply(f,a)\n    template&lt;class A, class F&gt; constexpr apply_t&lt;F,A&gt; map(const A &amp; a, F func) { return apply(func, a); }\n\n    // zip(a,b,f) is equivalent to apply(f,a,b)\n    template&lt;class A, class B, class F&gt; constexpr apply_t&lt;F,A,B&gt; zip(const A &amp; a, const B &amp; b, F func) { return apply(func, a, b); }\n\n    // Relational operators are defined to compare the elements of two vectors or matrices lexicographically, in column-major order\n    template&lt;class A, class B&gt; constexpr typename detail::any_compare&lt;A,B&gt;::type compare(const A &amp; a, const B &amp; b) { return detail::any_compare&lt;A,B&gt;()(a,b); }\n    template&lt;class A, class B&gt; constexpr auto operator == (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) == 0) { return compare(a,b) == 0; }\n    template&lt;class A, class B&gt; constexpr auto operator != (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) != 0) { return compare(a,b) != 0; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;  (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &lt;  0) { return compare(a,b) &lt;  0; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;  (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &gt;  0) { return compare(a,b) &gt;  0; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;= (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &lt;= 0) { return compare(a,b) &lt;= 0; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;= (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &gt;= 0) { return compare(a,b) &gt;= 0; }\n\n    // Functions for coalescing scalar values\n    template&lt;class A&gt; constexpr bool any (const A &amp; a) { return fold(detail::op_or{}, false, a); }\n    template&lt;class A&gt; constexpr bool all (const A &amp; a) { return fold(detail::op_and{}, true, a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; sum    (const A &amp; a) { return fold(detail::op_add{}, scalar_t&lt;A&gt;(0), a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; product(const A &amp; a) { return fold(detail::op_mul{}, scalar_t&lt;A&gt;(1), a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; minelem(const A &amp; a) { return fold(detail::min{}, a.x, a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; maxelem(const A &amp; a) { return fold(detail::max{}, a.x, a); }\n    template&lt;class T, int M&gt; int argmin(const vec&lt;T,M&gt; &amp; a) { int j=0; for(int i=1; i&lt;M; ++i) if(a[i] &lt; a[j]) j = i; return j; }\n    template&lt;class T, int M&gt; int argmax(const vec&lt;T,M&gt; &amp; a) { int j=0; for(int i=1; i&lt;M; ++i) if(a[i] &gt; a[j]) j = i; return j; }\n\n    // Unary operators are defined component-wise for linalg types\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_pos, A&gt; operator + (const A &amp; a) { return apply(detail::op_pos{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_neg, A&gt; operator - (const A &amp; a) { return apply(detail::op_neg{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_cmp, A&gt; operator ~ (const A &amp; a) { return apply(detail::op_cmp{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_not, A&gt; operator ! (const A &amp; a) { return apply(detail::op_not{}, a); }\n\n    // Binary operators are defined component-wise for linalg types\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_add, A, B&gt; operator +  (const A &amp; a, const B &amp; b) { return apply(detail::op_add{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_sub, A, B&gt; operator -  (const A &amp; a, const B &amp; b) { return apply(detail::op_sub{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_mul, A, B&gt; operator *  (const A &amp; a, const B &amp; b) { return apply(detail::op_mul{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_div, A, B&gt; operator /  (const A &amp; a, const B &amp; b) { return apply(detail::op_div{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_mod, A, B&gt; operator %  (const A &amp; a, const B &amp; b) { return apply(detail::op_mod{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_un,  A, B&gt; operator |  (const A &amp; a, const B &amp; b) { return apply(detail::op_un{},  a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_xor, A, B&gt; operator ^  (const A &amp; a, const B &amp; b) { return apply(detail::op_xor{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_int, A, B&gt; operator &amp;  (const A &amp; a, const B &amp; b) { return apply(detail::op_int{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_lsh, A, B&gt; operator &lt;&lt; (const A &amp; a, const B &amp; b) { return apply(detail::op_lsh{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_rsh, A, B&gt; operator &gt;&gt; (const A &amp; a, const B &amp; b) { return apply(detail::op_rsh{}, a, b); }\n\n    // Binary assignment operators a $= b is always defined as though it were explicitly written a = a $ b\n    template&lt;class A, class B&gt; constexpr auto operator +=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a + b) { return a = a + b; }\n    template&lt;class A, class B&gt; constexpr auto operator -=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a - b) { return a = a - b; }\n    template&lt;class A, class B&gt; constexpr auto operator *=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a * b) { return a = a * b; }\n    template&lt;class A, class B&gt; constexpr auto operator /=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a / b) { return a = a / b; }\n    template&lt;class A, class B&gt; constexpr auto operator %=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a % b) { return a = a % b; }\n    template&lt;class A, class B&gt; constexpr auto operator |=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a | b) { return a = a | b; }\n    template&lt;class A, class B&gt; constexpr auto operator ^=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a ^ b) { return a = a ^ b; }\n    template&lt;class A, class B&gt; constexpr auto operator &amp;=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a &amp; b) { return a = a &amp; b; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;&lt;= (A &amp; a, const B &amp; b) -&gt; decltype(a = a &lt;&lt; b) { return a = a &lt;&lt; b; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;&gt;= (A &amp; a, const B &amp; b) -&gt; decltype(a = a &gt;&gt; b) { return a = a &gt;&gt; b; }\n\n    // Swizzles and subobjects\n    template&lt;int... I, class T, int M&gt;                              constexpr vec&lt;T,sizeof...(I)&gt;   swizzle(const vec&lt;T,M&gt; &amp; a)   { return {detail::getter&lt;I&gt;(a)...}; }\n    template&lt;int I0, int I1, class T, int M&gt;                        constexpr vec&lt;T,I1-I0&gt;          subvec (const vec&lt;T,M&gt; &amp; a)   { return detail::swizzle(a, detail::make_seq&lt;I0,I1&gt;{}); }\n    template&lt;int I0, int J0, int I1, int J1, class T, int M, int N&gt; constexpr mat&lt;T,I1-I0,J1-J0&gt;    submat (const mat&lt;T,M,N&gt; &amp; a) { return detail::swizzle(a, detail::make_seq&lt;I0,I1&gt;{}, detail::make_seq&lt;J0,J1&gt;{}); }\n\n    // Component-wise standard library math functions\n    template&lt;class A&gt; apply_t&lt;detail::std_abs,   A&gt; abs  (const A &amp; a) { return apply(detail::std_abs{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_floor, A&gt; floor(const A &amp; a) { return apply(detail::std_floor{}, a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_ceil,  A&gt; ceil (const A &amp; a) { return apply(detail::std_ceil{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_exp,   A&gt; exp  (const A &amp; a) { return apply(detail::std_exp{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_log,   A&gt; log  (const A &amp; a) { return apply(detail::std_log{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_log10, A&gt; log10(const A &amp; a) { return apply(detail::std_log10{}, a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sqrt,  A&gt; sqrt (const A &amp; a) { return apply(detail::std_sqrt{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sin,   A&gt; sin  (const A &amp; a) { return apply(detail::std_sin{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_cos,   A&gt; cos  (const A &amp; a) { return apply(detail::std_cos{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_tan,   A&gt; tan  (const A &amp; a) { return apply(detail::std_tan{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_asin,  A&gt; asin (const A &amp; a) { return apply(detail::std_asin{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_acos,  A&gt; acos (const A &amp; a) { return apply(detail::std_acos{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_atan,  A&gt; atan (const A &amp; a) { return apply(detail::std_atan{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sinh,  A&gt; sinh (const A &amp; a) { return apply(detail::std_sinh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_cosh,  A&gt; cosh (const A &amp; a) { return apply(detail::std_cosh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_tanh,  A&gt; tanh (const A &amp; a) { return apply(detail::std_tanh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_round, A&gt; round(const A &amp; a) { return apply(detail::std_round{}, a); }\n\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_fmod,     A, B&gt; fmod    (const A &amp; a, const B &amp; b) { return apply(detail::std_fmod{},     a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_pow,      A, B&gt; pow     (const A &amp; a, const B &amp; b) { return apply(detail::std_pow{},      a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_atan2,    A, B&gt; atan2   (const A &amp; a, const B &amp; b) { return apply(detail::std_atan2{},    a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_copysign, A, B&gt; copysign(const A &amp; a, const B &amp; b) { return apply(detail::std_copysign{}, a, b); }\n\n    // Component-wise relational functions on vectors\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_eq, A, B&gt; equal  (const A &amp; a, const B &amp; b) { return apply(detail::op_eq{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_ne, A, B&gt; nequal (const A &amp; a, const B &amp; b) { return apply(detail::op_ne{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_lt, A, B&gt; less   (const A &amp; a, const B &amp; b) { return apply(detail::op_lt{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_gt, A, B&gt; greater(const A &amp; a, const B &amp; b) { return apply(detail::op_gt{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_le, A, B&gt; lequal (const A &amp; a, const B &amp; b) { return apply(detail::op_le{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_ge, A, B&gt; gequal (const A &amp; a, const B &amp; b) { return apply(detail::op_ge{}, a, b); }\n\n    // Component-wise selection functions on vectors\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::min, A, B&gt; min(const A &amp; a, const B &amp; b) { return apply(detail::min{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::max, A, B&gt; max(const A &amp; a, const B &amp; b) { return apply(detail::max{}, a, b); }\n    template&lt;class X, class L, class H&gt; constexpr apply_t&lt;detail::clamp,  X, L, H&gt; clamp (const X &amp; x, const L &amp; l, const H &amp; h) { return apply(detail::clamp{},  x, l, h); }\n    template&lt;class P, class A, class B&gt; constexpr apply_t&lt;detail::select, P, A, B&gt; select(const P &amp; p, const A &amp; a, const B &amp; b) { return apply(detail::select{}, p, a, b); }\n    template&lt;class A, class B, class T&gt; constexpr apply_t&lt;detail::lerp,   A, B, T&gt; lerp  (const A &amp; a, const B &amp; b, const T &amp; t) { return apply(detail::lerp{},   a, b, t); }\n\n    // Support for vector algebra\n    template&lt;class T&gt; constexpr T        cross    (const vec&lt;T,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b)      { return a.x*b.y-a.y*b.x; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; cross    (T a, const vec&lt;T,2&gt; &amp; b)                     { return {-a*b.y, a*b.x}; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; cross    (const vec&lt;T,2&gt; &amp; a, T b)                     { return {a.y*b, -a.x*b}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt; cross    (const vec&lt;T,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b)      { return {a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x}; }\n    template&lt;class T, int M&gt; constexpr T dot      (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return sum(a*b); }\n    template&lt;class T, int M&gt; constexpr T length2  (const vec&lt;T,M&gt; &amp; a)                          { return dot(a,a); }\n    template&lt;class T, int M&gt; T           length   (const vec&lt;T,M&gt; &amp; a)                          { return std::sqrt(length2(a)); }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    normalize(const vec&lt;T,M&gt; &amp; a)                          { return a / length(a); }\n    template&lt;class T, int M&gt; constexpr T distance2(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return length2(b-a); }\n    template&lt;class T, int M&gt; T           distance (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return length(b-a); }\n    template&lt;class T, int M&gt; T           uangle   (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { T d=dot(a,b); return d &gt; 1 ? 0 : std::acos(d &lt; -1 ? -1 : d); }\n    template&lt;class T, int M&gt; T           angle    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return uangle(normalize(a), normalize(b)); }\n    template&lt;class T&gt; vec&lt;T,2&gt;           rot      (T a, const vec&lt;T,2&gt; &amp; v)                     { const T s = std::sin(a), c = std::cos(a); return {v.x*c - v.y*s, v.x*s + v.y*c}; }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    nlerp    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b, T t) { return normalize(lerp(a,b,t)); }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    slerp    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b, T t) { T th=uangle(a,b); return th == 0 ? a : a*(std::sin(th*(1-t))/std::sin(th)) + b*(std::sin(th*t)/std::sin(th)); }\n\n    // Support for quaternion algebra using 4D vectors, representing xi + yj + zk + w\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; qconj(const vec&lt;T,4&gt; &amp; q)                     { return {-q.x,-q.y,-q.z,q.w}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qinv (const vec&lt;T,4&gt; &amp; q)                     { return qconj(q)/length2(q); }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qexp (const vec&lt;T,4&gt; &amp; q)                     { const auto v = q.xyz(); const auto vv = length(v); return std::exp(q.w) * vec&lt;T,4&gt;{v * (vv &gt; 0 ? std::sin(vv)/vv : 0), std::cos(vv)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qlog (const vec&lt;T,4&gt; &amp; q)                     { const auto v = q.xyz(); const auto vv = length(v), qq = length(q); return {v * (vv &gt; 0 ? std::acos(q.w/qq)/vv : 0), std::log(qq)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qpow (const vec&lt;T,4&gt; &amp; q, const T &amp; p)        { const auto v = q.xyz(); const auto vv = length(v), qq = length(q), th = std::acos(q.w/qq); return std::pow(qq,p)*vec&lt;T,4&gt;{v * (vv &gt; 0 ? std::sin(p*th)/vv : 0), std::cos(p*th)}; }\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; qmul (const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return {a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y, a.y*b.w+a.w*b.y+a.z*b.x-a.x*b.z, a.z*b.w+a.w*b.z+a.x*b.y-a.y*b.x, a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z}; }\n    template&lt;class T, class... R&gt; constexpr vec&lt;T,4&gt; qmul(const vec&lt;T,4&gt; &amp; a, R... r)  { return qmul(a, qmul(r...)); }\n\n    // Support for 3D spatial rotations using quaternions, via qmul(qmul(q, v), qconj(q))\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qxdir (const vec&lt;T,4&gt; &amp; q)                          { return {q.w*q.w+q.x*q.x-q.y*q.y-q.z*q.z, (q.x*q.y+q.z*q.w)*2, (q.z*q.x-q.y*q.w)*2}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qydir (const vec&lt;T,4&gt; &amp; q)                          { return {(q.x*q.y-q.z*q.w)*2, q.w*q.w-q.x*q.x+q.y*q.y-q.z*q.z, (q.y*q.z+q.x*q.w)*2}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qzdir (const vec&lt;T,4&gt; &amp; q)                          { return {(q.z*q.x+q.y*q.w)*2, (q.y*q.z-q.x*q.w)*2, q.w*q.w-q.x*q.x-q.y*q.y+q.z*q.z}; }\n    template&lt;class T&gt; constexpr mat&lt;T,3,3&gt; qmat  (const vec&lt;T,4&gt; &amp; q)                          { return {qxdir(q), qydir(q), qzdir(q)}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qrot  (const vec&lt;T,4&gt; &amp; q, const vec&lt;T,3&gt; &amp; v)      { return qxdir(q)*v.x + qydir(q)*v.y + qzdir(q)*v.z; }\n    template&lt;class T&gt; T                    qangle(const vec&lt;T,4&gt; &amp; q)                          { return std::atan2(length(q.xyz()), q.w)*2; }\n    template&lt;class T&gt; vec&lt;T,3&gt;             qaxis (const vec&lt;T,4&gt; &amp; q)                          { return normalize(q.xyz()); }\n    template&lt;class T&gt; vec&lt;T,4&gt;             qnlerp(const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b, T t) { return nlerp(a, dot(a,b) &lt; 0 ? -b : b, t); }\n    template&lt;class T&gt; vec&lt;T,4&gt;             qslerp(const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b, T t) { return slerp(a, dot(a,b) &lt; 0 ? -b : b, t); }\n\n    // Support for matrix algebra\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,1&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) { return a.x*b.x; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) { return a.x*b.x + a.y*b.y; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,1&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,1&gt; &amp; b) { return {mul(a,b.x)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,2&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,2&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,3&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,3&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y), mul(a,b.z)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,4&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,4&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y), mul(a,b.z), mul(a,b.w)}; }\n    template&lt;class T, int M, int N, int P&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const vec&lt;T,P&gt; &amp; c) { return mul(mul(a,b),c); }\n    template&lt;class T, int M, int N, int P, int Q&gt; constexpr mat&lt;T,M,Q&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c) { return mul(mul(a,b),c); }\n    template&lt;class T, int M, int N, int P, int Q&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c, const vec&lt;T,Q&gt; &amp; d) { return mul(mul(a,b,c),d); }\n    template&lt;class T, int M, int N, int P, int Q, int R&gt; constexpr mat&lt;T,M,R&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c, const mat&lt;T,Q,R&gt; &amp; d) { return mul(mul(a,b,c),d); }\n    // TODO: Variadic version of mul(...) that works on all compilers\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,1&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) { return {a*b.x}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,2&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) { return {a*b.x, a*b.y}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,3&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) { return {a*b.x, a*b.y, a*b.z}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,4&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return {a*b.x, a*b.y, a*b.z, a*b.w}; }\n    template&lt;class T&gt; constexpr vec&lt;T,1&gt; diagonal(const mat&lt;T,1,1&gt; &amp; a) { return {a.x.x}; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; diagonal(const mat&lt;T,2,2&gt; &amp; a) { return {a.x.x, a.y.y}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt; diagonal(const mat&lt;T,3,3&gt; &amp; a) { return {a.x.x, a.y.y, a.z.z}; }\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; diagonal(const mat&lt;T,4,4&gt; &amp; a) { return {a.x.x, a.y.y, a.z.z, a.w.w}; }\n    template&lt;class T, int N&gt; constexpr T trace(const mat&lt;T,N,N&gt; &amp; a) { return sum(diagonal(a)); }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,1&gt; transpose(const mat&lt;T,1,M&gt; &amp; m) { return {m.row(0)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,2&gt; transpose(const mat&lt;T,2,M&gt; &amp; m) { return {m.row(0), m.row(1)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,3&gt; transpose(const mat&lt;T,3,M&gt; &amp; m) { return {m.row(0), m.row(1), m.row(2)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,4&gt; transpose(const mat&lt;T,4,M&gt; &amp; m) { return {m.row(0), m.row(1), m.row(2), m.row(3)}; }\n    template&lt;class T&gt; constexpr mat&lt;T,1,1&gt; adjugate(const mat&lt;T,1,1&gt; &amp;)   { return {vec&lt;T,1&gt;{1}}; }\n    template&lt;class T&gt; constexpr mat&lt;T,2,2&gt; adjugate(const mat&lt;T,2,2&gt; &amp; a) { return {{a.y.y, -a.x.y}, {-a.y.x, a.x.x}}; }\n    template&lt;class T&gt; constexpr mat&lt;T,3,3&gt; adjugate(const mat&lt;T,3,3&gt; &amp; a);\n    template&lt;class T&gt; constexpr mat&lt;T,4,4&gt; adjugate(const mat&lt;T,4,4&gt; &amp; a);\n    template&lt;class T, int N&gt; constexpr mat&lt;T,N,N&gt; comatrix(const mat&lt;T,N,N&gt; &amp; a) { return transpose(adjugate(a)); }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,1,1&gt; &amp; a) { return a.x.x; }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,2,2&gt; &amp; a) { return a.x.x*a.y.y - a.x.y*a.y.x; }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,3,3&gt; &amp; a) { return a.x.x*(a.y.y*a.z.z - a.z.y*a.y.z) + a.x.y*(a.y.z*a.z.x - a.z.z*a.y.x) + a.x.z*(a.y.x*a.z.y - a.z.x*a.y.y); }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,4,4&gt; &amp; a);\n    template&lt;class T, int N&gt; constexpr mat&lt;T,N,N&gt; inverse(const mat&lt;T,N,N&gt; &amp; a) { return adjugate(a)/determinant(a); }\n\n    // Vectors and matrices can be used as ranges\n    template&lt;class T, int M&gt;       T * begin(      vec&lt;T,M&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M&gt; const T * begin(const vec&lt;T,M&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M&gt;       T * end  (      vec&lt;T,M&gt; &amp; a) { return begin(a) + M; }\n    template&lt;class T, int M&gt; const T * end  (const vec&lt;T,M&gt; &amp; a) { return begin(a) + M; }\n    template&lt;class T, int M, int N&gt;       vec&lt;T,M&gt; * begin(      mat&lt;T,M,N&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M, int N&gt; const vec&lt;T,M&gt; * begin(const mat&lt;T,M,N&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M, int N&gt;       vec&lt;T,M&gt; * end  (      mat&lt;T,M,N&gt; &amp; a) { return begin(a) + N; }\n    template&lt;class T, int M, int N&gt; const vec&lt;T,M&gt; * end  (const mat&lt;T,M,N&gt; &amp; a) { return begin(a) + N; }\n\n    // Factory functions for 3D spatial transformations (will possibly be removed or changed in a future version)\n    enum fwd_axis { neg_z, pos_z };                 // Should projection matrices be generated assuming forward is {0,0,-1} or {0,0,1}\n    enum z_range { neg_one_to_one, zero_to_one };   // Should projection matrices map z into the range of [-1,1] or [0,1]?\n    template&lt;class T&gt; vec&lt;T,4&gt;   rotation_quat     (const vec&lt;T,3&gt; &amp; axis, T angle)         { return {axis*std::sin(angle/2), std::cos(angle/2)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;   rotation_quat     (const mat&lt;T,3,3&gt; &amp; m);\n    template&lt;class T&gt; mat&lt;T,4,4&gt; translation_matrix(const vec&lt;T,3&gt; &amp; translation)           { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{translation,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; rotation_matrix   (const vec&lt;T,4&gt; &amp; rotation)              { return {{qxdir(rotation),0}, {qydir(rotation),0}, {qzdir(rotation),0}, {0,0,0,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; scaling_matrix    (const vec&lt;T,3&gt; &amp; scaling)               { return {{scaling.x,0,0,0}, {0,scaling.y,0,0}, {0,0,scaling.z,0}, {0,0,0,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; pose_matrix       (const vec&lt;T,4&gt; &amp; q, const vec&lt;T,3&gt; &amp; p) { return {{qxdir(q),0}, {qydir(q),0}, {qzdir(q),0}, {p,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; frustum_matrix    (T x0, T x1, T y0, T y1, T n, T f, fwd_axis a = neg_z, z_range z = neg_one_to_one);\n    template&lt;class T&gt; mat&lt;T,4,4&gt; perspective_matrix(T fovy, T aspect, T n, T f, fwd_axis a = neg_z, z_range z = neg_one_to_one) { T y = n*std::tan(fovy / 2), x = y*aspect; return frustum_matrix(-x, x, -y, y, n, f, a, z); }\n\n    // Provide implicit conversion between linalg::vec&lt;T,M&gt; and std::array&lt;T,M&gt;\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,1&gt;, std::array&lt;T,1&gt;&gt; { vec&lt;T,1&gt; operator() (const std::array&lt;T,1&gt; &amp; a) const { return {a[0]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,2&gt;, std::array&lt;T,2&gt;&gt; { vec&lt;T,2&gt; operator() (const std::array&lt;T,2&gt; &amp; a) const { return {a[0], a[1]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,3&gt;, std::array&lt;T,3&gt;&gt; { vec&lt;T,3&gt; operator() (const std::array&lt;T,3&gt; &amp; a) const { return {a[0], a[1], a[2]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,4&gt;, std::array&lt;T,4&gt;&gt; { vec&lt;T,4&gt; operator() (const std::array&lt;T,4&gt; &amp; a) const { return {a[0], a[1], a[2], a[3]}; } };\n\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,1&gt;, vec&lt;T,1&gt;&gt; { std::array&lt;T,1&gt; operator() (const vec&lt;T,1&gt; &amp; a) const { return {a[0]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,2&gt;, vec&lt;T,2&gt;&gt; { std::array&lt;T,2&gt; operator() (const vec&lt;T,2&gt; &amp; a) const { return {a[0], a[1]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,3&gt;, vec&lt;T,3&gt;&gt; { std::array&lt;T,3&gt; operator() (const vec&lt;T,3&gt; &amp; a) const { return {a[0], a[1], a[2]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,4&gt;, vec&lt;T,4&gt;&gt; { std::array&lt;T,4&gt; operator() (const vec&lt;T,4&gt; &amp; a) const { return {a[0], a[1], a[2], a[3]}; } };\n\n    // Provide typedefs for common element types and vector/matrix sizes\n    namespace aliases\n    {\n        typedef vec&lt;bool,1&gt; bool1; typedef vec&lt;uint8_t,1&gt; byte1; typedef vec&lt;int16_t,1&gt; short1; typedef vec&lt;uint16_t,1&gt; ushort1;\n        typedef vec&lt;bool,2&gt; bool2; typedef vec&lt;uint8_t,2&gt; byte2; typedef vec&lt;int16_t,2&gt; short2; typedef vec&lt;uint16_t,2&gt; ushort2; \n        typedef vec&lt;bool,3&gt; bool3; typedef vec&lt;uint8_t,3&gt; byte3; typedef vec&lt;int16_t,3&gt; short3; typedef vec&lt;uint16_t,3&gt; ushort3; \n        typedef vec&lt;bool,4&gt; bool4; typedef vec&lt;uint8_t,4&gt; byte4; typedef vec&lt;int16_t,4&gt; short4; typedef vec&lt;uint16_t,4&gt; ushort4;\n        typedef vec&lt;int,1&gt; int1; typedef vec&lt;unsigned,1&gt; uint1; typedef vec&lt;float,1&gt; float1; typedef vec&lt;double,1&gt; double1;\n        typedef vec&lt;int,2&gt; int2; typedef vec&lt;unsigned,2&gt; uint2; typedef vec&lt;float,2&gt; float2; typedef vec&lt;double,2&gt; double2;\n        typedef vec&lt;int,3&gt; int3; typedef vec&lt;unsigned,3&gt; uint3; typedef vec&lt;float,3&gt; float3; typedef vec&lt;double,3&gt; double3;\n        typedef vec&lt;int,4&gt; int4; typedef vec&lt;unsigned,4&gt; uint4; typedef vec&lt;float,4&gt; float4; typedef vec&lt;double,4&gt; double4;\n        typedef mat&lt;bool,1,1&gt; bool1x1; typedef mat&lt;int,1,1&gt; int1x1; typedef mat&lt;float,1,1&gt; float1x1; typedef mat&lt;double,1,1&gt; double1x1;\n        typedef mat&lt;bool,1,2&gt; bool1x2; typedef mat&lt;int,1,2&gt; int1x2; typedef mat&lt;float,1,2&gt; float1x2; typedef mat&lt;double,1,2&gt; double1x2;\n        typedef mat&lt;bool,1,3&gt; bool1x3; typedef mat&lt;int,1,3&gt; int1x3; typedef mat&lt;float,1,3&gt; float1x3; typedef mat&lt;double,1,3&gt; double1x3;\n        typedef mat&lt;bool,1,4&gt; bool1x4; typedef mat&lt;int,1,4&gt; int1x4; typedef mat&lt;float,1,4&gt; float1x4; typedef mat&lt;double,1,4&gt; double1x4;\n        typedef mat&lt;bool,2,1&gt; bool2x1; typedef mat&lt;int,2,1&gt; int2x1; typedef mat&lt;float,2,1&gt; float2x1; typedef mat&lt;double,2,1&gt; double2x1;\n        typedef mat&lt;bool,2,2&gt; bool2x2; typedef mat&lt;int,2,2&gt; int2x2; typedef mat&lt;float,2,2&gt; float2x2; typedef mat&lt;double,2,2&gt; double2x2;\n        typedef mat&lt;bool,2,3&gt; bool2x3; typedef mat&lt;int,2,3&gt; int2x3; typedef mat&lt;float,2,3&gt; float2x3; typedef mat&lt;double,2,3&gt; double2x3;\n        typedef mat&lt;bool,2,4&gt; bool2x4; typedef mat&lt;int,2,4&gt; int2x4; typedef mat&lt;float,2,4&gt; float2x4; typedef mat&lt;double,2,4&gt; double2x4;\n        typedef mat&lt;bool,3,1&gt; bool3x1; typedef mat&lt;int,3,1&gt; int3x1; typedef mat&lt;float,3,1&gt; float3x1; typedef mat&lt;double,3,1&gt; double3x1;\n        typedef mat&lt;bool,3,2&gt; bool3x2; typedef mat&lt;int,3,2&gt; int3x2; typedef mat&lt;float,3,2&gt; float3x2; typedef mat&lt;double,3,2&gt; double3x2;\n        typedef mat&lt;bool,3,3&gt; bool3x3; typedef mat&lt;int,3,3&gt; int3x3; typedef mat&lt;float,3,3&gt; float3x3; typedef mat&lt;double,3,3&gt; double3x3;\n        typedef mat&lt;bool,3,4&gt; bool3x4; typedef mat&lt;int,3,4&gt; int3x4; typedef mat&lt;float,3,4&gt; float3x4; typedef mat&lt;double,3,4&gt; double3x4;\n        typedef mat&lt;bool,4,1&gt; bool4x1; typedef mat&lt;int,4,1&gt; int4x1; typedef mat&lt;float,4,1&gt; float4x1; typedef mat&lt;double,4,1&gt; double4x1;\n        typedef mat&lt;bool,4,2&gt; bool4x2; typedef mat&lt;int,4,2&gt; int4x2; typedef mat&lt;float,4,2&gt; float4x2; typedef mat&lt;double,4,2&gt; double4x2;\n        typedef mat&lt;bool,4,3&gt; bool4x3; typedef mat&lt;int,4,3&gt; int4x3; typedef mat&lt;float,4,3&gt; float4x3; typedef mat&lt;double,4,3&gt; double4x3;\n        typedef mat&lt;bool,4,4&gt; bool4x4; typedef mat&lt;int,4,4&gt; int4x4; typedef mat&lt;float,4,4&gt; float4x4; typedef mat&lt;double,4,4&gt; double4x4;\n    }\n\n    // Provide output streaming operators, writing something that resembles an aggregate literal that could be used to construct the specified value\n    namespace ostream_overloads\n    {\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,1&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,2&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,3&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; ',' &lt;&lt; v[2] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,4&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; ',' &lt;&lt; v[2] &lt;&lt; ',' &lt;&lt; v[3] &lt;&lt; '}'; }\n\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,1&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,2&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,3&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; ',' &lt;&lt; m[2] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,4&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; ',' &lt;&lt; m[2] &lt;&lt; ',' &lt;&lt; m[3] &lt;&lt; '}'; }\n    }\n}\n\nnamespace std \n{ \n    // Provide specializations for std::hash&lt;...&gt; with linalg types\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,1&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,1&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,2&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,2&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,3&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,3&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1) ^ (h(v.z) &lt;&lt; 2); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,4&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,4&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1) ^ (h(v.z) &lt;&lt; 2) ^ (h(v.w) &lt;&lt; 3); } };\n\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,1&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,1&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,2&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,2&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,3&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,3&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M) ^ (h(v.z) &lt;&lt; (M*2)); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,4&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,4&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M) ^ (h(v.z) &lt;&lt; (M*2)) ^ (h(v.w) &lt;&lt; (M*3)); } };\n}\n\n// Definitions of functions too long to be defined inline\ntemplate&lt;class T&gt; constexpr linalg::mat&lt;T,3,3&gt; linalg::adjugate(const mat&lt;T,3,3&gt; &amp; a) \n{ \n    return {{a.y.y*a.z.z - a.z.y*a.y.z, a.z.y*a.x.z - a.x.y*a.z.z, a.x.y*a.y.z - a.y.y*a.x.z},\n            {a.y.z*a.z.x - a.z.z*a.y.x, a.z.z*a.x.x - a.x.z*a.z.x, a.x.z*a.y.x - a.y.z*a.x.x},\n            {a.y.x*a.z.y - a.z.x*a.y.y, a.z.x*a.x.y - a.x.x*a.z.y, a.x.x*a.y.y - a.y.x*a.x.y}}; \n}\n\ntemplate&lt;class T&gt; constexpr linalg::mat&lt;T,4,4&gt; linalg::adjugate(const mat&lt;T,4,4&gt; &amp; a) \n{ \n    return {{a.y.y*a.z.z*a.w.w + a.w.y*a.y.z*a.z.w + a.z.y*a.w.z*a.y.w - a.y.y*a.w.z*a.z.w - a.z.y*a.y.z*a.w.w - a.w.y*a.z.z*a.y.w,\n             a.x.y*a.w.z*a.z.w + a.z.y*a.x.z*a.w.w + a.w.y*a.z.z*a.x.w - a.w.y*a.x.z*a.z.w - a.z.y*a.w.z*a.x.w - a.x.y*a.z.z*a.w.w,\n             a.x.y*a.y.z*a.w.w + a.w.y*a.x.z*a.y.w + a.y.y*a.w.z*a.x.w - a.x.y*a.w.z*a.y.w - a.y.y*a.x.z*a.w.w - a.w.y*a.y.z*a.x.w,\n             a.x.y*a.z.z*a.y.w + a.y.y*a.x.z*a.z.w + a.z.y*a.y.z*a.x.w - a.x.y*a.y.z*a.z.w - a.z.y*a.x.z*a.y.w - a.y.y*a.z.z*a.x.w},\n            {a.y.z*a.w.w*a.z.x + a.z.z*a.y.w*a.w.x + a.w.z*a.z.w*a.y.x - a.y.z*a.z.w*a.w.x - a.w.z*a.y.w*a.z.x - a.z.z*a.w.w*a.y.x,\n             a.x.z*a.z.w*a.w.x + a.w.z*a.x.w*a.z.x + a.z.z*a.w.w*a.x.x - a.x.z*a.w.w*a.z.x - a.z.z*a.x.w*a.w.x - a.w.z*a.z.w*a.x.x,\n             a.x.z*a.w.w*a.y.x + a.y.z*a.x.w*a.w.x + a.w.z*a.y.w*a.x.x - a.x.z*a.y.w*a.w.x - a.w.z*a.x.w*a.y.x - a.y.z*a.w.w*a.x.x,\n             a.x.z*a.y.w*a.z.x + a.z.z*a.x.w*a.y.x + a.y.z*a.z.w*a.x.x - a.x.z*a.z.w*a.y.x - a.y.z*a.x.w*a.z.x - a.z.z*a.y.w*a.x.x},\n            {a.y.w*a.z.x*a.w.y + a.w.w*a.y.x*a.z.y + a.z.w*a.w.x*a.y.y - a.y.w*a.w.x*a.z.y - a.z.w*a.y.x*a.w.y - a.w.w*a.z.x*a.y.y,\n             a.x.w*a.w.x*a.z.y + a.z.w*a.x.x*a.w.y + a.w.w*a.z.x*a.x.y - a.x.w*a.z.x*a.w.y - a.w.w*a.x.x*a.z.y - a.z.w*a.w.x*a.x.y,\n             a.x.w*a.y.x*a.w.y + a.w.w*a.x.x*a.y.y + a.y.w*a.w.x*a.x.y - a.x.w*a.w.x*a.y.y - a.y.w*a.x.x*a.w.y - a.w.w*a.y.x*a.x.y,\n             a.x.w*a.z.x*a.y.y + a.y.w*a.x.x*a.z.y + a.z.w*a.y.x*a.x.y - a.x.w*a.y.x*a.z.y - a.z.w*a.x.x*a.y.y - a.y.w*a.z.x*a.x.y},\n            {a.y.x*a.w.y*a.z.z + a.z.x*a.y.y*a.w.z + a.w.x*a.z.y*a.y.z - a.y.x*a.z.y*a.w.z - a.w.x*a.y.y*a.z.z - a.z.x*a.w.y*a.y.z,\n             a.x.x*a.z.y*a.w.z + a.w.x*a.x.y*a.z.z + a.z.x*a.w.y*a.x.z - a.x.x*a.w.y*a.z.z - a.z.x*a.x.y*a.w.z - a.w.x*a.z.y*a.x.z,\n             a.x.x*a.w.y*a.y.z + a.y.x*a.x.y*a.w.z + a.w.x*a.y.y*a.x.z - a.x.x*a.y.y*a.w.z - a.w.x*a.x.y*a.y.z - a.y.x*a.w.y*a.x.z,\n             a.x.x*a.y.y*a.z.z + a.z.x*a.x.y*a.y.z + a.y.x*a.z.y*a.x.z - a.x.x*a.z.y*a.y.z - a.y.x*a.x.y*a.z.z - a.z.x*a.y.y*a.x.z}}; \n}\n\ntemplate&lt;class T&gt; constexpr T linalg::determinant(const mat&lt;T,4,4&gt; &amp; a) \n{ \n    return a.x.x*(a.y.y*a.z.z*a.w.w + a.w.y*a.y.z*a.z.w + a.z.y*a.w.z*a.y.w - a.y.y*a.w.z*a.z.w - a.z.y*a.y.z*a.w.w - a.w.y*a.z.z*a.y.w)\n         + a.x.y*(a.y.z*a.w.w*a.z.x + a.z.z*a.y.w*a.w.x + a.w.z*a.z.w*a.y.x - a.y.z*a.z.w*a.w.x - a.w.z*a.y.w*a.z.x - a.z.z*a.w.w*a.y.x)\n         + a.x.z*(a.y.w*a.z.x*a.w.y + a.w.w*a.y.x*a.z.y + a.z.w*a.w.x*a.y.y - a.y.w*a.w.x*a.z.y - a.z.w*a.y.x*a.w.y - a.w.w*a.z.x*a.y.y)\n         + a.x.w*(a.y.x*a.w.y*a.z.z + a.z.x*a.y.y*a.w.z + a.w.x*a.z.y*a.y.z - a.y.x*a.z.y*a.w.z - a.w.x*a.y.y*a.z.z - a.z.x*a.w.y*a.y.z); \n}\n\ntemplate&lt;class T&gt; linalg::vec&lt;T,4&gt; linalg::rotation_quat(const mat&lt;T,3,3&gt; &amp; m)\n{\n    const vec&lt;T,4&gt; q {m.x.x-m.y.y-m.z.z, m.y.y-m.x.x-m.z.z, m.z.z-m.x.x-m.y.y, m.x.x+m.y.y+m.z.z}, s[] {\n        {1, m.x.y + m.y.x, m.z.x + m.x.z, m.y.z - m.z.y}, \n        {m.x.y + m.y.x, 1, m.y.z + m.z.y, m.z.x - m.x.z},\n        {m.x.z + m.z.x, m.y.z + m.z.y, 1, m.x.y - m.y.x},\n        {m.y.z - m.z.y, m.z.x - m.x.z, m.x.y - m.y.x, 1}};\n    return copysign(normalize(sqrt(max(T(0), T(1)+q))), s[argmax(q)]);\n}\n\ntemplate&lt;class T&gt; linalg::mat&lt;T,4,4&gt; linalg::frustum_matrix(T x0, T x1, T y0, T y1, T n, T f, fwd_axis a, z_range z) \n{ \n    const T s = a == pos_z ? T(1) : T(-1), o = z == neg_one_to_one ? n : 0;\n    return {{2*n/(x1-x0),0,0,0}, {0,2*n/(y1-y0),0,0}, {-s*(x0+x1)/(x1-x0),-s*(y0+y1)/(y1-y0),s*(f+o)/(f-n),s}, {0,0,-(n+o)*f/(f-n),0}};\n}\n\n#endif\n</code></pre>"},{"location":"api/logger_8hpp/","title":"File logger.hpp","text":"<p>FileList &gt; common &gt; logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> </ul>"},{"location":"api/logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/logger_8hpp/#classes","title":"Classes","text":"Type Name class start_end_logger a utility for logging to start and end times to a file <p>The documentation for this class was generated from the following file <code>common/logger.hpp</code></p>"},{"location":"api/logger_8hpp_source/","title":"File logger.hpp","text":"<p>File List &gt; common &gt; logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;chrono&gt;\n#include \"phonebook.hpp\"\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nnamespace ILLIXR{\n\n    class start_end_logger\n    {\n    private:\n        std::string component_name;\n        std::ofstream log_file;\n        enum class start_end_state{\n            started,\n            ended,\n            bad\n        };\n        start_end_state log_state;\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; init_time;\n    public:\n        start_end_logger(std::string component_name){\n            log_file.open(\"log/\" + component_name);\n            if (log_file) {\n                log_state = start_end_state::ended;\n                log_file &lt;&lt; \"logger.hpp is DEPRECATED. See logging.hpp\" &lt;&lt; std::endl;\n            } else {\n                log_state = start_end_state::bad;\n            }\n            init_time = std::chrono::high_resolution_clock::now();\n        }\n        ~start_end_logger(){\n            log_file.close();\n        }\n        int log_start(std::chrono::time_point&lt;std::chrono::system_clock&gt; log_time){\n            // check status\n            if (log_state == start_end_state::bad) return -1;\n            if (log_state == start_end_state::started){\n                log_state = start_end_state::bad;\n                log_file &lt;&lt; \"bad logging state, logging terminated\" &lt;&lt; std::endl;\n                return -1;\n            }\n\n            log_state = start_end_state::started;\n            log_file &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(log_time - init_time).count() &lt;&lt; \",\";\n\n            return 0;\n        }\n        int log_end(std::chrono::time_point&lt;std::chrono::system_clock&gt; log_time){\n            // check status\n            if (log_state == start_end_state::bad) return -1;\n            if (log_state == start_end_state::ended){\n                log_state = start_end_state::bad;\n                log_file &lt;&lt; \"bad logging state, logging terminated\" &lt;&lt; std::endl;\n                return -1;\n            }\n\n            log_state = start_end_state::ended;\n            log_file &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(log_time - init_time).count() &lt;&lt; std::endl;\n\n            return 0;\n        }\n    };\n}\n</code></pre>"},{"location":"api/phonebook_8hpp/","title":"File phonebook.hpp","text":"<p>FileList &gt; common &gt; phonebook.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"api/phonebook_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/phonebook_8hpp/#classes","title":"Classes","text":"Type Name class phonebook A service locator for ILLIXR. class service A 'service' that can be registered in the phonebook. <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/phonebook_8hpp_source/","title":"File phonebook.hpp","text":"<p>File List &gt; common &gt; phonebook.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;typeindex&gt;\n#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n#include &lt;mutex&gt;\n#include &lt;memory&gt;\n#include &lt;unordered_map&gt;\n\nnamespace ILLIXR {\n\n    class phonebook {\n        /*\n          Proof of thread-safety:\n          - Since all instance members are private, acquiring a lock in each method implies the class is datarace-free.\n          - Since there is only one lock and this does not call any code containing locks, this is deadlock-free.\n          - Both of these methods are only used during initialization, so the locks are not contended in steady-state.\n\n          However, to write a correct program, one must also check the thread-safety of the elements\n          inserted into this class by the caller.\n        */\n\n    public:\n\n        class service {\n        public:\n            virtual ~service() { }\n        };\n\n        template &lt;typename specific_service&gt;\n        void register_impl(std::shared_ptr&lt;specific_service&gt; impl) {\n            const std::lock_guard&lt;std::mutex&gt; lock{_m_mutex};\n\n            const std::type_index type_index = std::type_index(typeid(specific_service));\n#ifndef DNDEBUG\n            std::cerr &lt;&lt; \"Register \" &lt;&lt; type_index.name() &lt;&lt; std::endl;\n#endif\n            assert(_m_registry.count(type_index) == 0);\n            _m_registry.try_emplace(type_index, impl);\n        }\n\n        template &lt;typename specific_service&gt;\n        std::shared_ptr&lt;specific_service&gt; lookup_impl() const {\n            const std::lock_guard&lt;std::mutex&gt; lock{_m_mutex};\n\n            const std::type_index type_index = std::type_index(typeid(specific_service));\n\n#ifndef NDEBUG\n            // if this assert fails, and there are no duplicate base classes, ensure the hash_code's are unique.\n            if (_m_registry.count(type_index) != 1) {\n                throw std::runtime_error{\"Attempted to lookup an unregistered implementation \" + std::string{type_index.name()}};\n            }\n#endif\n\n            std::shared_ptr&lt;service&gt; this_service = _m_registry.at(type_index);\n            assert(this_service);\n\n            std::shared_ptr&lt;specific_service&gt; this_specific_service = std::dynamic_pointer_cast&lt;specific_service&gt;(this_service);\n            assert(this_specific_service);\n\n            return this_specific_service;\n        }\n\n    private:\n        std::unordered_map&lt;std::type_index, const std::shared_ptr&lt;service&gt;&gt; _m_registry;\n        mutable std::mutex _m_mutex;\n    };\n}\n</code></pre>"},{"location":"api/plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; common &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> </ul>"},{"location":"api/plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/plugin_8hpp/#classes","title":"Classes","text":"Type Name class plugin A dynamically-loadable plugin for Spindle."},{"location":"api/plugin_8hpp/#macros","title":"Macros","text":"Type Name define PLUGIN_MAIN (plugin_class) <code>/* multi line expression */</code>"},{"location":"api/plugin_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugin_8hpp/#define-plugin_main","title":"define PLUGIN_MAIN","text":"<pre><code>#define PLUGIN_MAIN (\n    plugin_class\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/plugin.hpp</code></p>"},{"location":"api/plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; common &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n#include \"record_logger.hpp\"\n\nnamespace ILLIXR {\n\n    /*\n     * This gets included, but it is functionally 'private'. Hence the double-underscores.\n     */\n    const record_header __plugin_start_header {\n        \"plugin_name\",\n        {\n            {\"plugin_id\", typeid(std::size_t)},\n            {\"plugin_name\", typeid(std::string)},\n        },\n    };\n\n    class plugin {\n    public:\n        virtual void start() {\n            record_logger_-&gt;log(record{__plugin_start_header, {\n                {id},\n                {name},\n            }});\n        }\n\n        virtual void stop() { }\n\n        plugin(const std::string&amp; name_, phonebook* pb_)\n            : name{name_}\n            , pb{pb_}\n            , record_logger_{pb-&gt;lookup_impl&lt;record_logger&gt;()}\n            , gen_guid_{pb-&gt;lookup_impl&lt;gen_guid&gt;()}\n            , id{gen_guid_-&gt;get()}\n        { }\n\n        virtual ~plugin() { }\n\n        std::string get_name() { return name; }\n\n    protected:\n        std::string name;\n        const phonebook* pb;\n        const std::shared_ptr&lt;record_logger&gt; record_logger_;\n        const std::shared_ptr&lt;gen_guid&gt; gen_guid_;\n        const std::size_t id;\n    };\n\n#define PLUGIN_MAIN(plugin_class)                                   \\\n    extern \"C\" plugin* this_plugin_factory(phonebook* pb) {         \\\n        plugin_class* obj = new plugin_class {#plugin_class, pb};   \\\n        obj-&gt;start();                                               \\\n        return obj;                                                 \\\n    }\n}\n</code></pre>"},{"location":"api/pose__prediction_8hpp/","title":"File pose_prediction.hpp","text":"<p>FileList &gt; common &gt; pose_prediction.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"data_format.hpp\"</code></li> </ul>"},{"location":"api/pose__prediction_8hpp/#classes","title":"Classes","text":"Type Name class pose_prediction <p>The documentation for this class was generated from the following file <code>common/pose_prediction.hpp</code></p>"},{"location":"api/pose__prediction_8hpp_source/","title":"File pose_prediction.hpp","text":"<p>File List &gt; common &gt; pose_prediction.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"phonebook.hpp\"\n#include \"data_format.hpp\"\n\nusing namespace ILLIXR;\n\nclass pose_prediction : public phonebook::service {\npublic:\n    virtual pose_type get_fast_pose() const = 0;\n    virtual pose_type get_true_pose() const = 0;\n    virtual bool fast_pose_reliable() const = 0;\n    virtual bool true_pose_reliable() const = 0;\n    virtual void set_offset(const Eigen::Quaternionf&amp; orientation) = 0;\n    virtual ~pose_prediction() { }\n};\n</code></pre>"},{"location":"api/record__logger_8hpp/","title":"File record_logger.hpp","text":"<p>FileList &gt; common &gt; record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;any&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> </ul>"},{"location":"api/record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/record__logger_8hpp/#classes","title":"Classes","text":"Type Name class data_use_indicator A helper class that lets one dynamically determine if some data gets used. class gen_guid This class generates unique IDs. class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_logger The ILLIXR logging service for structured records. <p>The documentation for this class was generated from the following file <code>common/record_logger.hpp</code></p>"},{"location":"api/record__logger_8hpp_source/","title":"File record_logger.hpp","text":"<p>File List &gt; common &gt; record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;any&gt;\n#include &lt;atomic&gt;\n#include &lt;unordered_map&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include \"phonebook.hpp\"\n\nnamespace ILLIXR {\n\n    class record_header {\n    public:\n        record_header(std::string name_, std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns_)\n            : id{std::hash&lt;std::string&gt;{}(name_)}\n            , name{name_}\n            , columns{columns_}\n        { }\n\n        bool operator==(const record_header&amp; other) const {\n            // Check pointer first\n            if (this == &amp;other) {\n                return true;\n            }\n\n            if (name != other.name\n                || columns.size() != other.columns.size()\n                || id != other.id) {\n                return false;\n            }\n            for (std::size_t i = 0; i &lt; columns.size(); ++i) {\n                if (columns[i] != other.columns[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        bool operator!=(const record_header&amp; other) const {\n            return !(*this == other);\n        }\n        std::size_t get_id() const { return id; }\n        const std::string&amp; get_name() const { return name; }\n        const std::string&amp; get_column_name(unsigned column) const { return columns[column].first; }\n        const std::type_info&amp; get_column_type(unsigned column) const { return columns[column].second; }\n        unsigned get_columns() const { return columns.size(); }\n        std::string to_string() const {\n            std::string ret = std::string{\"record_header \"} + name + std::string{\" { \"};\n            for (const auto&amp; pair : columns) {\n                ret += std::string{pair.second.name()} + std::string{\" \"} + pair.first + std::string{\"; \"};\n            }\n            ret.erase(ret.size() - 2);\n            ret += std::string{\" }\"};\n            return ret;\n        }\n\n    private:\n        std::size_t id;\n        std::string name;\n        const std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns;\n    };\n\n    class data_use_indicator {\n    public:\n        data_use_indicator() : used{false} { }\n        data_use_indicator(const data_use_indicator&amp; other) : used{false} {\n            other.used = true;\n        }\n        data_use_indicator&amp; operator=(const data_use_indicator&amp; other) {\n            if (&amp;other != this) {\n                other.used = true;\n                used = false;\n            }\n            return *this;\n        }\n        /*\n          copy constructors are just as efficient as move constructors would be,\n          so I won't define move constructors. C++ will invoke copy instead (for no loss).\n        */\n        bool is_used() const { return used; }\n        void mark_used() const { used = true; }\n        void mark_unused() const { used = false; }\n    private:\n        mutable bool used;\n    };\n\n    class record {\n    public:\n        record(const record_header&amp; rh_, std::vector&lt;std::any&gt; values_)\n            : rh{rh_}\n            , values{values_}\n        {\n#ifndef NDEBUG\n            if (values.size() != rh.get_columns()) {\n                std::cerr &lt;&lt; values.size() &lt;&lt; \" elements passed, but rh for \" &lt;&lt; rh.get_name() &lt;&lt; \" only specifies \" &lt;&lt; rh.get_columns() &lt;&lt; \".\" &lt;&lt; std::endl;\n                abort();\n            }\n            for (std::size_t column = 0; column &lt; values.size(); ++column) {\n                if (values[column].type() != rh.get_column_type(column)) {\n                    std::cerr &lt;&lt; \"Caller got wrong type for column \" &lt;&lt; column &lt;&lt; \" of \" &lt;&lt; rh.get_name() &lt;&lt; \". \"\n                              &lt;&lt; \"Caller passed: \" &lt;&lt; values[column].type().name() &lt;&lt; \"; \"\n                              &lt;&lt; \"recod_header for specifies: \" &lt;&lt; rh.get_column_type(column).name() &lt;&lt; \". \"\n                              &lt;&lt; std::endl;\n                    abort();\n                }\n            }\n#endif\n        }\n\n        ~record() {\n#ifndef NDEBUG\n            if (!data_use_indicator_.is_used()) {\n                std::cerr &lt;&lt; \"Record was deleted without being logged.\" &lt;&lt; std::endl;\n                abort();\n            }\n#endif\n        }\n\n        template&lt;typename T&gt;\n        T get_value(unsigned column) const {\n#ifndef NDEBUG\n            data_use_indicator_.mark_used();\n            if (rh.get_column_type(column) != typeid(T)) {\n                std::ostringstream ss;\n                ss &lt;&lt; \"Caller column type for \" &lt;&lt; column &lt;&lt; \" of \" &lt;&lt; rh.get_name() &lt;&lt; \". \"\n                   &lt;&lt; \"Caller passed: \" &lt;&lt; typeid(T).name() &lt;&lt; \"; \"\n                   &lt;&lt; \"record_header specifies: \" &lt;&lt; rh.get_column_type(column).name() &lt;&lt; \". \";\n                throw std::runtime_error{ss.str()};\n            }\n#endif\n            return std::any_cast&lt;T&gt;(values[column]);\n        }\n\n        const record_header&amp; get_record_header() const {\n            return rh;\n        }\n\n        void mark_used() const {\n#ifndef NDEBUG\n            data_use_indicator_.mark_used();\n#endif\n        }\n\n    private:\n        // Holding a pointer to a record_header is more efficient than\n        // requiring each record to hold a list of its column names\n        // and table name. This is just one pointer.\n        const record_header&amp; rh;\n        std::vector&lt;std::any&gt; values;\n#ifndef NDEBUG\n        data_use_indicator data_use_indicator_;\n#endif\n    };\n\n    class record_logger : public phonebook::service {\n    public:\n\n        virtual ~record_logger() { }\n\n        virtual void log(const record&amp; r) = 0;\n\n        virtual void log(const std::vector&lt;record&gt;&amp; rs) {\n            for (const record&amp; r : rs) {\n                log(r);\n            }\n        }\n    };\n\n    class gen_guid : public phonebook::service {\n    public:\n        std::size_t get(std::size_t namespace_ = 0, std::size_t subnamespace = 0, std::size_t subsubnamespace = 0) {\n            if (guid_starts[namespace_][subnamespace].count(subsubnamespace) == 0) {\n                guid_starts[namespace_][subnamespace][subsubnamespace].store(1);\n            }\n            return guid_starts[namespace_][subnamespace][subsubnamespace]++;\n        }\n    private:\n        std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::atomic&lt;std::size_t&gt;&gt;&gt;&gt; guid_starts;\n    };\n\n\n    static std::chrono::milliseconds LOG_BUFFER_DELAY {1000};\n\n    class record_coalescer {\n    private:\n        std::shared_ptr&lt;record_logger&gt; logger;\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; last_log;\n        std::vector&lt;record&gt; buffer;\n\n    public:\n        record_coalescer(std::shared_ptr&lt;record_logger&gt; logger_)\n            : logger{logger_}\n            , last_log{std::chrono::high_resolution_clock::now()}\n        { }\n\n        ~record_coalescer() {\n            flush();\n        }\n\n        void log(record r) {\n            buffer.push_back(r);\n            // Log coalescer should only be used with\n            // In the common case, they will be the same pointer, quickly check the pointers.\n            // In the less common case, we check for object-structural equality.\n#ifndef NDEBUG\n            if (&amp;r.get_record_header() != &amp;buffer[0].get_record_header()\n                &amp;&amp; r.get_record_header() == buffer[0].get_record_header()) {\n                std::cerr &lt;&lt; \"Tried to push a record of type \" &lt;&lt; r.get_record_header().to_string() &lt;&lt; \" to a record logger for type \" &lt;&lt; buffer[0].get_record_header().to_string() &lt;&lt; std::endl;\n                abort();\n            }\n#endif\n            maybe_flush();\n        }\n\n        void maybe_flush() {\n            if (std::chrono::high_resolution_clock::now() &gt; last_log + LOG_BUFFER_DELAY) {\n                flush();\n            }\n        }\n\n        void flush() {\n            std::vector&lt;record&gt; buffer2;\n            buffer.swap(buffer2);\n            logger-&gt;log(buffer2);\n            last_log = std::chrono::high_resolution_clock::now();\n        }\n    };\n}\n</code></pre>"},{"location":"api/runtime_8hpp/","title":"File runtime.hpp","text":"<p>FileList &gt; common &gt; runtime.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include \"extended_window.hpp\"</code></li> </ul>"},{"location":"api/runtime_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/runtime_8hpp/#classes","title":"Classes","text":"Type Name class runtime <p>The documentation for this class was generated from the following file <code>common/runtime.hpp</code></p>"},{"location":"api/runtime_8hpp_source/","title":"File runtime.hpp","text":"<p>File List &gt; common &gt; runtime.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;GL/glx.h&gt;\n#include \"extended_window.hpp\"\n\nnamespace ILLIXR {\n    class plugin;\n\n    typedef plugin* (*plugin_factory) (phonebook*);\n\n    class runtime {\n    public:\n        virtual void load_so(std::string_view so) = 0;\n        virtual void load_plugin_factory(plugin_factory plugin) = 0;\n        virtual void wait() = 0;\n        virtual void stop() = 0;\n        virtual ~runtime() {}\n    };\n\n    extern \"C\" runtime* runtime_factory(GLXContext appGLCtx);\n\n}\n</code></pre>"},{"location":"api/shader__util_8hpp/","title":"File shader_util.hpp","text":"<p>FileList &gt; common &gt; shader_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"GL/gl.h\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/shader__util_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void GLAPIENTRY MessageCallback (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * message, const void * userParam)  GLuint init_and_link (const char * vertex_shader, const char * fragment_shader)"},{"location":"api/shader__util_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/shader__util_8hpp/#function-messagecallback","title":"function MessageCallback","text":"<pre><code>static void GLAPIENTRY MessageCallback (\n    GLenum source,\n    GLenum type,\n    GLuint id,\n    GLenum severity,\n    GLsizei length,\n    const GLchar * message,\n    const void * userParam\n) \n</code></pre>"},{"location":"api/shader__util_8hpp/#function-init_and_link","title":"function init_and_link","text":"<pre><code>static GLuint init_and_link (\n    const char * vertex_shader,\n    const char * fragment_shader\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/shader_util.hpp</code></p>"},{"location":"api/shader__util_8hpp_source/","title":"File shader_util.hpp","text":"<p>File List &gt; common &gt; shader_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include \"GL/gl.h\"\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\n\n\nstatic void GLAPIENTRY\n    MessageCallback([[maybe_unused]] GLenum source,\n                    [[maybe_unused]] GLenum type,\n                    [[maybe_unused]] GLuint id,\n                    [[maybe_unused]] GLenum severity,\n                    [[maybe_unused]] GLsizei length,\n                    [[maybe_unused]] const GLchar* message,\n                    [[maybe_unused]] const void* userParam )\n    {\n#ifndef NDEBUG\n    fprintf( stderr, \"GL CALLBACK: %s type = 0x%x, severity = 0x%x, message = %s\\n\",\n            ( type == GL_DEBUG_TYPE_ERROR ? \"** GL ERROR **\" : \"\" ),\n                type, severity, message );\n#endif\n    }\n\nstatic GLuint init_and_link (const char* vertex_shader, const char* fragment_shader){\n\n    // GL handles for intermediary objects.\n    GLint result, vertex_shader_handle, fragment_shader_handle, shader_program;\n\n\n    vertex_shader_handle = glCreateShader(GL_VERTEX_SHADER);\n    GLint vshader_len = strlen(vertex_shader);\n    glShaderSource(vertex_shader_handle, 1, &amp;vertex_shader, &amp;vshader_len);\n    glCompileShader(vertex_shader_handle);\n    glGetShaderiv(vertex_shader_handle, GL_COMPILE_STATUS, &amp;result);\n    if ( result == GL_FALSE )\n    {\n        GLchar msg[4096];\n        GLsizei length;\n        glGetShaderInfoLog( vertex_shader_handle, sizeof( msg ), &amp;length, msg );\n        printf( \"1 Error: %s\\n\", msg);\n    }\n\n    GLint fragResult = GL_FALSE;\n    fragment_shader_handle = glCreateShader(GL_FRAGMENT_SHADER);\n    GLint fshader_len = strlen(fragment_shader);\n    glShaderSource(fragment_shader_handle, 1, &amp;fragment_shader, &amp;fshader_len);\n    glCompileShader(fragment_shader_handle);\n    if(glGetError()){\n        printf(\"Fragment shader compilation failed\\n\");\n    }\n    glGetShaderiv(fragment_shader_handle, GL_COMPILE_STATUS, &amp;fragResult);\n    if ( fragResult == GL_FALSE )\n    {\n        GLchar msg[4096];\n        GLsizei length;\n        glGetShaderInfoLog( fragment_shader_handle, sizeof( msg ), &amp;length, msg );\n        printf( \"2 Error: %s\\n\", msg);\n    }\n\n    // Create program and link shaders\n    shader_program = glCreateProgram();\n    glAttachShader(shader_program, vertex_shader_handle);\n    glAttachShader(shader_program, fragment_shader_handle);\n    if(glGetError()){\n        printf(\"AttachShader or createProgram failed\\n\");\n    }\n\n    // Link and verify\n\n    glLinkProgram(shader_program);\n\n    if(glGetError()){\n        printf(\"Linking failed\\n\");\n    }\n\n    glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;result);\n    GLenum err = glGetError();\n    if(err){\n        printf(\"initGL, error getting link status, %x\", err);\n    }\n    if ( result == GL_FALSE )\n    {\n        GLsizei length = 0;\n\n        std::vector&lt;GLchar&gt; infoLog(length);\n        glGetProgramInfoLog(shader_program, length, &amp;length, &amp;infoLog[0]);\n\n        std::string error_msg(infoLog.begin(), infoLog.end());\n        std::cout &lt;&lt; error_msg;\n\n    }\n\n    if(glGetError()){\n        printf(\"initGL, error at end of initGL\");\n    }\n\n    // After successful link, detach shaders from shader program\n    glDetachShader(shader_program, vertex_shader_handle);\n    glDetachShader(shader_program, fragment_shader_handle);\n\n    return shader_program;\n}\n</code></pre>"},{"location":"api/switchboard_8hpp/","title":"File switchboard.hpp","text":"<p>FileList &gt; common &gt; switchboard.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"cpu_timer.hpp\"</code></li> </ul>"},{"location":"api/switchboard_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/switchboard_8hpp/#classes","title":"Classes","text":"Type Name class reader_latest &lt;typename event&gt;A handle which can read the latest event on a topic. class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class writer &lt;typename event&gt;A handle which can publish events to a topic. <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/switchboard_8hpp_source/","title":"File switchboard.hpp","text":"<p>File List &gt; common &gt; switchboard.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SWITCHBOARD_HH\n#define SWITCHBOARD_HH\n\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;functional&gt;\n#include \"phonebook.hpp\"\n#include \"cpu_timer.hpp\"\n\nnamespace ILLIXR {\n\ntemplate &lt;typename event&gt;\nclass reader_latest {\npublic:\n    virtual const event* get_latest_ro() const = 0;\n\n    virtual event* get_latest() const = 0;\n\n    virtual ~reader_latest() { };\n};\n\ntemplate &lt;typename event&gt;\nclass writer {\npublic:\n    virtual void put(const event* ev) = 0;\n\n    virtual event* allocate() = 0;\n\n    virtual ~writer() { };\n};\n\n/* This class is pure virtual so that I can hide its implementation from its users. It will be\n   referenced in plugins, but implemented in the runtime.\n\n   However, virtual methods cannot be templated, so these templated methods refer to a virtual\n   method whose type has been erased (coerced to/from void*). This is an instance of the Non-Virtual\n   Interface pattern: https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface\n*/\n\nclass switchboard : public phonebook::service {\n\nprivate:\n    virtual\n    std::unique_ptr&lt;writer&lt;void&gt;&gt; _p_publish(const std::string&amp; topic_name, std::size_t ty) = 0;\n\n    virtual\n    std::unique_ptr&lt;reader_latest&lt;void&gt;&gt; _p_subscribe_latest(const std::string&amp; topic_name, std::size_t ty) = 0;\n\n    virtual\n    void _p_schedule(const std::string&amp; topic_name, std::function&lt;void(const void*)&gt; fn, std::size_t ty) = 0;\n\n    /* TODO: (usability) add a method which queries if a topic has a writer. Readers might assert this. */\n\npublic:\n\n    template &lt;typename event&gt;\n    void schedule([[maybe_unused]] std::string account_name, std::string topic_name, std::function&lt;void(const event*)&gt; fn) {\n        _p_schedule(topic_name, [=](const void* ptr) {\n            fn(reinterpret_cast&lt;const event*&gt;(ptr));\n        }, typeid(event).hash_code());\n    }\n\n    template &lt;typename event&gt;\n    std::unique_ptr&lt;writer&lt;event&gt;&gt; publish(const std::string&amp; topic_name) {\n        auto void_writer = _p_publish(topic_name, typeid(event).hash_code());\n        return std::move(std::unique_ptr&lt;writer&lt;event&gt;&gt;(reinterpret_cast&lt;writer&lt;event&gt;*&gt;(void_writer.release())));\n    }\n\n    template &lt;typename event&gt;\n    std::unique_ptr&lt;reader_latest&lt;event&gt;&gt; subscribe_latest(const std::string&amp; topic_name) {\n        auto void_writer = _p_subscribe_latest(topic_name, typeid(event).hash_code());\n        return std::move(std::unique_ptr&lt;reader_latest&lt;event&gt;&gt;(reinterpret_cast&lt;reader_latest&lt;event&gt;*&gt;(void_writer.release())));\n    }\n\n    virtual ~switchboard() { }\n\n    virtual void stop() = 0;\n};\n\n/* TODO: (usability) Do these HAVE to be smart pointers? If the\n   copy-constructor is already shallow, they could be concrete\n   data-types. */\n\n}\n\n#endif\n</code></pre>"},{"location":"api/threadloop_8hpp/","title":"File threadloop.hpp","text":"<p>FileList &gt; common &gt; threadloop.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"cpu_timer.hpp\"</code></li> </ul>"},{"location":"api/threadloop_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/threadloop_8hpp/#classes","title":"Classes","text":"Type Name class threadloop A reusable threadloop for plugins. <p>The documentation for this class was generated from the following file <code>common/threadloop.hpp</code></p>"},{"location":"api/threadloop_8hpp_source/","title":"File threadloop.hpp","text":"<p>File List &gt; common &gt; threadloop.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;future&gt;\n#include &lt;algorithm&gt;\n#include \"plugin.hpp\"\n#include \"cpu_timer.hpp\"\n\nnamespace ILLIXR {\n\nconst record_header __threadloop_iteration_header {\"threadloop_iteration\", {\n    {\"plugin_id\", typeid(std::size_t)},\n    {\"iteration_no\", typeid(std::size_t)},\n    {\"skips\", typeid(std::size_t)},\n    {\"cpu_time_start\", typeid(std::chrono::nanoseconds)},\n    {\"cpu_time_stop\" , typeid(std::chrono::nanoseconds)},\n    {\"wall_time_start\", typeid(std::chrono::high_resolution_clock::time_point)},\n    {\"wall_time_stop\" , typeid(std::chrono::high_resolution_clock::time_point)},\n}};\n\nclass threadloop : public plugin {\npublic:\n    threadloop(std::string name_, phonebook* pb_) : plugin(name_, pb_) { }\n\n    virtual void start() override {\n        plugin::start();\n        _m_thread = std::thread(std::bind(&amp;threadloop::thread_main, this));\n    }\n\n    virtual void stop() override {\n        if (! _m_terminate.load()) {\n            _m_terminate.store(true);\n            _m_thread.join();\n            std::cerr &lt;&lt; \"Joined \" &lt;&lt; name &lt;&lt; std::endl;\n            plugin::stop();\n        } else {\n            std::cerr &lt;&lt; \"You called stop() on this plugin twice.\" &lt;&lt; std::endl;\n        }\n    }\n\n    virtual ~threadloop() override {\n        if (!_m_terminate.load()) {\n            std::cerr &lt;&lt; \"You didn't call stop() before destructing this plugin.\" &lt;&lt; std::endl;\n            abort();\n        }\n    }\n\nprotected:\n    std::size_t iteration_no = 0;\n    std::size_t skip_no = 0;\n\nprivate:\n    void thread_main() {\n        record_coalescer it_log {record_logger_};\n\n        std::cout &lt;&lt; \"thread,\" &lt;&lt; std::this_thread::get_id() &lt;&lt; \",threadloop,\" &lt;&lt; name &lt;&lt; std::endl;\n\n        _p_thread_setup();\n\n        auto iteration_start_cpu_time  = thread_cpu_time();\n        auto iteration_start_wall_time = std::chrono::high_resolution_clock::now();\n\n        while (!should_terminate()) {\n            skip_option s = _p_should_skip();\n\n            switch (s) {\n            case skip_option::skip_and_yield:\n                std::this_thread::yield();\n                ++skip_no;\n                break;\n            case skip_option::skip_and_spin:\n                ++skip_no;\n                break;\n            case skip_option::run: {\n                _p_one_iteration();\n                it_log.log(record{__threadloop_iteration_header, {\n                    {id},\n                    {iteration_no},\n                    {skip_no},\n                    {iteration_start_cpu_time},\n                    {thread_cpu_time()},\n                    {iteration_start_wall_time},\n                    {std::chrono::high_resolution_clock::now()},\n                }});\n                iteration_start_cpu_time  = thread_cpu_time();\n                iteration_start_wall_time = std::chrono::high_resolution_clock::now();\n                ++iteration_no;\n                skip_no = 0;\n                break;\n            }\n            case skip_option::stop:\n                stop();\n                break;\n            }\n        }\n    }\n\nprotected:\n\n    enum class skip_option {\n        run,\n\n        skip_and_spin,\n\n        skip_and_yield,\n\n        stop,\n    };\n\n    virtual skip_option _p_should_skip() { return skip_option::run; }\n\n    virtual void _p_thread_setup() { }\n\n    virtual void _p_one_iteration() = 0;\n\n    bool should_terminate() {\n        return _m_terminate.load();\n    }\n\nprivate:\n    std::atomic&lt;bool&gt; _m_terminate {false};\n\n    std::thread _m_thread;\n};\n\n}\n</code></pre>"},{"location":"api/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace ILLIXR </li> <li>namespace linalg <ul> <li>namespace aliases </li> <li>namespace detail </li> <li>namespace ostream_overloads </li> </ul> </li> <li>namespace std <ul> <li>namespace conditional </li> </ul> </li> </ul>"},{"location":"api/classes/","title":"Class Index","text":""},{"location":"api/classes/#a","title":"a","text":"<ul> <li>accel (ILLIXR)</li> <li>any_compare (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; (linalg::detail)</li> <li>apply (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail)</li> </ul>"},{"location":"api/classes/#c","title":"c","text":"<ul> <li>camera_frame (ILLIXR)</li> <li>clamp (linalg::detail)</li> <li>converter (linalg)</li> <li>converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; (linalg)</li> </ul>"},{"location":"api/classes/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR)</li> <li>dynamic_lib (ILLIXR)</li> </ul>"},{"location":"api/classes/#e","title":"e","text":"<ul> <li>empty (linalg::detail)</li> </ul>"},{"location":"api/classes/#g","title":"g","text":"<ul> <li>gen_guid (ILLIXR)</li> <li>getter (linalg::detail)</li> <li>getter&lt; 0 &gt; (linalg::detail)</li> <li>getter&lt; 1 &gt; (linalg::detail)</li> <li>getter&lt; 2 &gt; (linalg::detail)</li> <li>getter&lt; 3 &gt; (linalg::detail)</li> </ul>"},{"location":"api/classes/#h","title":"h","text":"<ul> <li>hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 1 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 2 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 3 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 4 &gt; &gt; (std)</li> <li>hmd_physical_info (ILLIXR)</li> <li>hologram_input (ILLIXR)</li> <li>hologram_output (ILLIXR)</li> </ul>"},{"location":"api/classes/#i","title":"i","text":"<ul> <li>identity_t (linalg)</li> <li>imu_cam_type (ILLIXR)</li> </ul>"},{"location":"api/classes/#l","title":"l","text":"<ul> <li>lerp (linalg::detail)</li> </ul>"},{"location":"api/classes/#m","title":"m","text":"<ul> <li>make_seq_impl (linalg::detail)</li> <li>make_seq_impl&lt; A, 0 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 1 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 2 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 3 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 4 &gt; (linalg::detail)</li> <li>mat (linalg)</li> <li>mat&lt; T, M, 1 &gt; (linalg)</li> <li>mat&lt; T, M, 2 &gt; (linalg)</li> <li>mat&lt; T, M, 3 &gt; (linalg)</li> <li>mat&lt; T, M, 4 &gt; (linalg)</li> <li>max (linalg::detail)</li> <li>min (linalg::detail)</li> </ul>"},{"location":"api/classes/#o","title":"o","text":"<ul> <li>op_add (linalg::detail)</li> <li>op_and (linalg::detail)</li> <li>op_cmp (linalg::detail)</li> <li>op_div (linalg::detail)</li> <li>op_eq (linalg::detail)</li> <li>op_ge (linalg::detail)</li> <li>op_gt (linalg::detail)</li> <li>op_int (linalg::detail)</li> <li>op_le (linalg::detail)</li> <li>op_lsh (linalg::detail)</li> <li>op_lt (linalg::detail)</li> <li>op_mod (linalg::detail)</li> <li>op_mul (linalg::detail)</li> <li>op_ne (linalg::detail)</li> <li>op_neg (linalg::detail)</li> <li>op_not (linalg::detail)</li> <li>op_or (linalg::detail)</li> <li>op_pos (linalg::detail)</li> <li>op_rsh (linalg::detail)</li> <li>op_sub (linalg::detail)</li> <li>op_un (linalg::detail)</li> <li>op_xor (linalg::detail)</li> <li>ord (linalg::detail)</li> </ul>"},{"location":"api/classes/#p","title":"p","text":"<ul> <li>phonebook (ILLIXR)</li> <li>plugin (ILLIXR)</li> <li>pose_prediction</li> <li>pose_type (ILLIXR)</li> <li>print_in_destructor</li> <li>print_timer</li> <li>print_timer2</li> </ul>"},{"location":"api/classes/#r","title":"r","text":"<ul> <li>reader_latest (ILLIXR)</li> <li>record (ILLIXR)</li> <li>record_coalescer (ILLIXR)</li> <li>record_header (ILLIXR)</li> <li>record_logger (ILLIXR)</li> <li>rendered_frame (ILLIXR)</li> <li>rendered_frame_alt (ILLIXR)</li> <li>rgb_depth_type (ILLIXR)</li> <li>runtime (ILLIXR)</li> </ul>"},{"location":"api/classes/#s","title":"s","text":"<ul> <li>scalar_type (linalg::detail)</li> <li>scalar_type&lt; mat&lt; T, M, N &gt; &gt; (linalg::detail)</li> <li>scalar_type&lt; vec&lt; T, M &gt; &gt; (linalg::detail)</li> <li>scalars (linalg::detail)</li> <li>scalars&lt; T, U... &gt; (linalg::detail)</li> <li>scalars&lt;&gt; (linalg::detail)</li> <li>select (linalg::detail)</li> <li>seq (linalg::detail)</li> <li>service (ILLIXR::phonebook)</li> <li>should_profile_class</li> <li>start_end_logger (ILLIXR)</li> <li>std_abs (linalg::detail)</li> <li>std_acos (linalg::detail)</li> <li>std_asin (linalg::detail)</li> <li>std_atan (linalg::detail)</li> <li>std_atan2 (linalg::detail)</li> <li>std_ceil (linalg::detail)</li> <li>std_copysign (linalg::detail)</li> <li>std_cos (linalg::detail)</li> <li>std_cosh (linalg::detail)</li> <li>std_exp (linalg::detail)</li> <li>std_floor (linalg::detail)</li> <li>std_fmod (linalg::detail)</li> <li>std_log (linalg::detail)</li> <li>std_log10 (linalg::detail)</li> <li>std_pow (linalg::detail)</li> <li>std_round (linalg::detail)</li> <li>std_sin (linalg::detail)</li> <li>std_sinh (linalg::detail)</li> <li>std_sqrt (linalg::detail)</li> <li>std_tan (linalg::detail)</li> <li>std_tanh (linalg::detail)</li> <li>switchboard (ILLIXR)</li> </ul>"},{"location":"api/classes/#t","title":"t","text":"<ul> <li>threadloop (ILLIXR)</li> <li>timer</li> </ul>"},{"location":"api/classes/#v","title":"v","text":"<ul> <li>vec (linalg)</li> <li>vec&lt; T, 1 &gt; (linalg)</li> <li>vec&lt; T, 2 &gt; (linalg)</li> <li>vec&lt; T, 3 &gt; (linalg)</li> <li>vec&lt; T, 4 &gt; (linalg)</li> </ul>"},{"location":"api/classes/#w","title":"w","text":"<ul> <li>writer (ILLIXR)</li> </ul>"},{"location":"api/classes/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR)</li> </ul>"},{"location":"api/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class ILLIXR::data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>class ILLIXR::dynamic_lib </li> <li>class ILLIXR::phonebook::service A 'service' that can be registered in the phonebook. <ul> <li>class ILLIXR::gen_guid This class generates unique IDs. </li> <li>class ILLIXR::record_logger The ILLIXR logging service for structured records. </li> <li>class ILLIXR::switchboard A manager for typesafe, threadsafe, named event-streams (called topics). </li> <li>class ILLIXR::xlib_gl_extended_window </li> <li>class pose_prediction </li> </ul> </li> <li>class ILLIXR::phonebook A service locator for ILLIXR.</li> <li>class ILLIXR::plugin A dynamically-loadable plugin for Spindle. <ul> <li>class ILLIXR::threadloop A reusable threadloop for plugins. </li> </ul> </li> <li>class ILLIXR::reader_latest A handle which can read the latest event on a topic. </li> <li>class ILLIXR::record This class represents a tuple of fields which get logged by <code>record_logger</code> .</li> <li>class ILLIXR::record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class ILLIXR::record_header Schema of each record. </li> <li>class ILLIXR::runtime </li> <li>class ILLIXR::start_end_logger a utility for logging to start and end times to a file </li> <li>class ILLIXR::writer A handle which can publish events to a topic. </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_timer::print_in_destructor </li> <li>class should_profile_class </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> <li>struct ILLIXR::accel </li> <li>struct ILLIXR::camera_frame </li> <li>struct ILLIXR::hmd_physical_info </li> <li>struct ILLIXR::hologram_input </li> <li>struct ILLIXR::hologram_output </li> <li>struct ILLIXR::imu_cam_type </li> <li>struct ILLIXR::pose_type </li> <li>struct ILLIXR::rendered_frame </li> <li>struct ILLIXR::rendered_frame_alt </li> <li>struct ILLIXR::rgb_depth_type </li> <li>struct linalg::converter </li> <li>struct linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; </li> <li>struct linalg::detail::any_compare </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct linalg::detail::apply </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; </li> <li>struct linalg::detail::clamp </li> <li>struct linalg::detail::empty </li> <li>struct linalg::detail::getter </li> <li>struct linalg::detail::getter&lt; 0 &gt; </li> <li>struct linalg::detail::getter&lt; 1 &gt; </li> <li>struct linalg::detail::getter&lt; 2 &gt; </li> <li>struct linalg::detail::getter&lt; 3 &gt; </li> <li>struct linalg::detail::lerp </li> <li>struct linalg::detail::make_seq_impl </li> <li>struct linalg::detail::make_seq_impl&lt; A, 0 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 1 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 2 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 3 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 4 &gt; </li> <li>struct linalg::detail::max </li> <li>struct linalg::detail::min </li> <li>struct linalg::detail::op_add </li> <li>struct linalg::detail::op_and </li> <li>struct linalg::detail::op_cmp </li> <li>struct linalg::detail::op_div </li> <li>struct linalg::detail::op_eq </li> <li>struct linalg::detail::op_ge </li> <li>struct linalg::detail::op_gt </li> <li>struct linalg::detail::op_int </li> <li>struct linalg::detail::op_le </li> <li>struct linalg::detail::op_lsh </li> <li>struct linalg::detail::op_lt </li> <li>struct linalg::detail::op_mod </li> <li>struct linalg::detail::op_mul </li> <li>struct linalg::detail::op_ne </li> <li>struct linalg::detail::op_neg </li> <li>struct linalg::detail::op_not </li> <li>struct linalg::detail::op_or </li> <li>struct linalg::detail::op_pos </li> <li>struct linalg::detail::op_rsh </li> <li>struct linalg::detail::op_sub </li> <li>struct linalg::detail::op_un </li> <li>struct linalg::detail::op_xor </li> <li>struct linalg::detail::ord </li> <li>struct linalg::detail::scalar_type </li> <li>struct linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt; </li> <li>struct linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt; </li> <li>struct linalg::detail::scalars </li> <li>struct linalg::detail::scalars&lt;&gt; </li> <li>struct linalg::detail::select </li> <li>struct linalg::detail::seq </li> <li>struct linalg::detail::std_abs </li> <li>struct linalg::detail::std_acos </li> <li>struct linalg::detail::std_asin </li> <li>struct linalg::detail::std_atan </li> <li>struct linalg::detail::std_atan2 </li> <li>struct linalg::detail::std_ceil </li> <li>struct linalg::detail::std_copysign </li> <li>struct linalg::detail::std_cos </li> <li>struct linalg::detail::std_cosh </li> <li>struct linalg::detail::std_exp </li> <li>struct linalg::detail::std_floor </li> <li>struct linalg::detail::std_fmod </li> <li>struct linalg::detail::std_log </li> <li>struct linalg::detail::std_log10 </li> <li>struct linalg::detail::std_pow </li> <li>struct linalg::detail::std_round </li> <li>struct linalg::detail::std_sin </li> <li>struct linalg::detail::std_sinh </li> <li>struct linalg::detail::std_sqrt </li> <li>struct linalg::detail::std_tan </li> <li>struct linalg::detail::std_tanh </li> <li>struct linalg::identity_t </li> <li>struct linalg::mat </li> <li>struct linalg::mat&lt; T, M, 1 &gt; </li> <li>struct linalg::mat&lt; T, M, 2 &gt; </li> <li>struct linalg::mat&lt; T, M, 3 &gt; </li> <li>struct linalg::mat&lt; T, M, 4 &gt; </li> <li>struct linalg::vec </li> <li>struct linalg::vec&lt; T, 1 &gt; </li> <li>struct linalg::vec&lt; T, 2 &gt; </li> <li>struct linalg::vec&lt; T, 3 &gt; </li> <li>struct linalg::vec&lt; T, 4 &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt; </li> <li>class std::conditional::type <ul> <li>struct linalg::detail::scalars&lt; T, U... &gt; </li> </ul> </li> </ul>"},{"location":"api/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"api/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"api/class_members/","title":"Class Members","text":""},{"location":"api/class_members/#a","title":"a","text":"<ul> <li>angular_v (ILLIXR::imu_cam_type)</li> <li>allocate (ILLIXR::writer)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>a (linalg::detail::ord)</li> <li>actually_should_profile (should_profile_class)</li> </ul>"},{"location":"api/class_members/#b","title":"b","text":"<ul> <li>buffer (ILLIXR::record_coalescer)</li> <li>b (linalg::detail::ord)</li> </ul>"},{"location":"api/class_members/#c","title":"c","text":"<ul> <li>create (ILLIXR::dynamic_lib)</li> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>columns (ILLIXR::record_header)</li> <li>component_name (ILLIXR::start_end_logger)</li> <li>cpu_time_start (print_timer2)</li> </ul>"},{"location":"api/class_members/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>dummy (ILLIXR::hologram_output)</li> <li>dataset_time (ILLIXR::imu_cam_type)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>depth (ILLIXR::rgb_depth_type)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#f","title":"f","text":"<ul> <li>flush (ILLIXR::record_coalescer)</li> <li>fast_pose_reliable (pose_prediction)</li> </ul>"},{"location":"api/class_members/#g","title":"g","text":"<ul> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid)</li> <li>guid_starts (ILLIXR::gen_guid)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_latest (ILLIXR::reader_latest)</li> <li>get_latest_ro (ILLIXR::reader_latest)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_members/#h","title":"h","text":"<ul> <li>height (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#i","title":"i","text":"<ul> <li>is_used (ILLIXR::data_use_indicator)</li> <li>ipd (ILLIXR::hmd_physical_info)</li> <li>img0 (ILLIXR::imu_cam_type)</li> <li>img1 (ILLIXR::imu_cam_type)</li> <li>id (ILLIXR::plugin, ILLIXR::record_header)</li> <li>init_time (ILLIXR::start_end_logger)</li> <li>iteration_no (ILLIXR::threadloop)</li> <li>impl (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>identity_t (linalg::identity_t)</li> </ul>"},{"location":"api/class_members/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_members/#l","title":"l","text":"<ul> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>linear_a (ILLIXR::imu_cam_type)</li> <li>lookup_impl (ILLIXR::phonebook)</li> <li>last_log (ILLIXR::record_coalescer)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger)</li> <li>logger (ILLIXR::record_coalescer)</li> <li>load_plugin_factory (ILLIXR::runtime)</li> <li>load_so (ILLIXR::runtime)</li> <li>log_end (ILLIXR::start_end_logger)</li> <li>log_file (ILLIXR::start_end_logger)</li> <li>log_start (ILLIXR::start_end_logger)</li> <li>log_state (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_members/#m","title":"m","text":"<ul> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> <li>mat (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#n","title":"n","text":"<ul> <li>name (ILLIXR::plugin, ILLIXR::record_header, print_timer2)</li> </ul>"},{"location":"api/class_members/#o","title":"o","text":"<ul> <li>operator= (ILLIXR::data_use_indicator, ILLIXR::dynamic_lib)</li> <li>operator[] (ILLIXR::dynamic_lib, linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>orientation (ILLIXR::pose_type)</li> <li>operator!= (ILLIXR::record_header)</li> <li>operator== (ILLIXR::record_header)</li> <li>operator() (linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;, linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;, linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;, linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;, linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::clamp, linalg::detail::getter&lt; 0 &gt;, linalg::detail::getter&lt; 1 &gt;, linalg::detail::getter&lt; 2 &gt;, linalg::detail::getter&lt; 3 &gt;, linalg::detail::lerp, linalg::detail::max, linalg::detail::min, linalg::detail::op_add, linalg::detail::op_and, linalg::detail::op_cmp, linalg::detail::op_div, linalg::detail::op_eq, linalg::detail::op_ge, linalg::detail::op_gt, linalg::detail::op_int, linalg::detail::op_le, linalg::detail::op_lsh, linalg::detail::op_lt, linalg::detail::op_mod, linalg::detail::op_mul, linalg::detail::op_ne, linalg::detail::op_neg, linalg::detail::op_not, linalg::detail::op_or, linalg::detail::op_pos, linalg::detail::op_rsh, linalg::detail::op_sub, linalg::detail::op_un, linalg::detail::op_xor, linalg::detail::select, linalg::detail::std_abs, linalg::detail::std_acos, linalg::detail::std_asin, linalg::detail::std_atan, linalg::detail::std_atan2, linalg::detail::std_ceil, linalg::detail::std_copysign, linalg::detail::std_cos, linalg::detail::std_cosh, linalg::detail::std_exp, linalg::detail::std_floor, linalg::detail::std_fmod, linalg::detail::std_log, linalg::detail::std_log10, linalg::detail::std_pow, linalg::detail::std_round, linalg::detail::std_sin, linalg::detail::std_sinh, linalg::detail::std_sqrt, linalg::detail::std_tan, linalg::detail::std_tanh, should_profile_class, std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;)</li> <li>operator U (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#p","title":"p","text":"<ul> <li>pixel (ILLIXR::camera_frame)</li> <li>pb (ILLIXR::plugin)</li> <li>plugin (ILLIXR::plugin)</li> <li>position (ILLIXR::pose_type)</li> <li>publish (ILLIXR::switchboard)</li> <li>put (ILLIXR::writer)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> </ul>"},{"location":"api/class_members/#r","title":"r","text":"<ul> <li>register_impl (ILLIXR::phonebook)</li> <li>record_logger_ (ILLIXR::plugin)</li> <li>record (ILLIXR::record)</li> <li>rh (ILLIXR::record)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>render_pose (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> <li>rgb (ILLIXR::rgb_depth_type)</li> <li>row (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#s","title":"s","text":"<ul> <li>seq (ILLIXR::hologram_input)</li> <li>start (ILLIXR::plugin, ILLIXR::threadloop)</li> <li>stop (ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::threadloop)</li> <li>sample_time (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> <li>swap_indices (ILLIXR::rendered_frame_alt)</li> <li>start_end_logger (ILLIXR::start_end_logger)</li> <li>start_end_state (ILLIXR::start_end_logger)</li> <li>schedule (ILLIXR::switchboard)</li> <li>subscribe_latest (ILLIXR::switchboard)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>skip_no (ILLIXR::threadloop)</li> <li>skip_option (ILLIXR::threadloop)</li> <li>set_offset (pose_prediction)</li> <li>serial_no (print_timer2)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_members/#t","title":"t","text":"<ul> <li>time (ILLIXR::imu_cam_type, ILLIXR::pose_type, ILLIXR::rgb_depth_type)</li> <li>to_string (ILLIXR::record_header)</li> <li>texture_handle (ILLIXR::rendered_frame)</li> <li>texture_handles (ILLIXR::rendered_frame_alt)</li> <li>thread_main (ILLIXR::threadloop)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>type (linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;, linalg::detail::make_seq_impl&lt; A, 0 &gt;, linalg::detail::make_seq_impl&lt; A, 1 &gt;, linalg::detail::make_seq_impl&lt; A, 2 &gt;, linalg::detail::make_seq_impl&lt; A, 3 &gt;, linalg::detail::make_seq_impl&lt; A, 4 &gt;, linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;, linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;, linalg::detail::scalars&lt;&gt;)</li> <li>true_pose_reliable (pose_prediction)</li> <li>timer (timer)</li> </ul>"},{"location":"api/class_members/#u","title":"u","text":"<ul> <li>used (ILLIXR::data_use_indicator)</li> </ul>"},{"location":"api/class_members/#v","title":"v","text":"<ul> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> <li>values (ILLIXR::record)</li> <li>V (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> <li>vec (linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#w","title":"w","text":"<ul> <li>wait (ILLIXR::runtime)</li> <li>width (ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>w (linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>wall_time_start (print_timer2)</li> </ul>"},{"location":"api/class_members/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>x (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xy (linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xyz (linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#y","title":"y","text":"<ul> <li>y (linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#z","title":"z","text":"<ul> <li>z (linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#_1","title":"~","text":"<ul> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~reader_latest (ILLIXR::reader_latest)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~start_end_logger (ILLIXR::start_end_logger)</li> <li>~switchboard (ILLIXR::switchboard)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~writer (ILLIXR::writer)</li> <li>~pose_prediction (pose_prediction)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_members/#_","title":"_","text":"<ul> <li>_m_handle (ILLIXR::dynamic_lib)</li> <li>_m_mutex (ILLIXR::phonebook)</li> <li>_m_registry (ILLIXR::phonebook)</li> <li>_p_publish (ILLIXR::switchboard)</li> <li>_p_schedule (ILLIXR::switchboard)</li> <li>_p_subscribe_latest (ILLIXR::switchboard)</li> <li>_m_terminate (ILLIXR::threadloop)</li> <li>_m_thread (ILLIXR::threadloop)</li> <li>_p_one_iteration (ILLIXR::threadloop)</li> <li>_p_should_skip (ILLIXR::threadloop)</li> <li>_p_thread_setup (ILLIXR::threadloop)</li> <li>_p_duration (print_timer, print_timer::print_in_destructor, timer)</li> <li>_p_print_in_destructor (print_timer)</li> <li>_p_timer (print_timer)</li> <li>_p_account_name (print_timer::print_in_destructor)</li> <li>_p_now (timer)</li> <li>_p_start (timer)</li> </ul>"},{"location":"api/class_member_functions/","title":"Class Member Functions","text":""},{"location":"api/class_member_functions/#a","title":"a","text":"<ul> <li>allocate (ILLIXR::writer)</li> </ul>"},{"location":"api/class_member_functions/#c","title":"c","text":"<ul> <li>create (ILLIXR::dynamic_lib)</li> </ul>"},{"location":"api/class_member_functions/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> </ul>"},{"location":"api/class_member_functions/#f","title":"f","text":"<ul> <li>flush (ILLIXR::record_coalescer)</li> <li>fast_pose_reliable (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#g","title":"g","text":"<ul> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_latest (ILLIXR::reader_latest)</li> <li>get_latest_ro (ILLIXR::reader_latest)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#i","title":"i","text":"<ul> <li>is_used (ILLIXR::data_use_indicator)</li> <li>impl (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>identity_t (linalg::identity_t)</li> </ul>"},{"location":"api/class_member_functions/#l","title":"l","text":"<ul> <li>lookup_impl (ILLIXR::phonebook)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger)</li> <li>load_plugin_factory (ILLIXR::runtime)</li> <li>load_so (ILLIXR::runtime)</li> <li>log_end (ILLIXR::start_end_logger)</li> <li>log_start (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_member_functions/#m","title":"m","text":"<ul> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> <li>mat (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (ILLIXR::data_use_indicator, ILLIXR::dynamic_lib)</li> <li>operator[] (ILLIXR::dynamic_lib, linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>operator!= (ILLIXR::record_header)</li> <li>operator== (ILLIXR::record_header)</li> <li>operator() (linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;, linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;, linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;, linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;, linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::clamp, linalg::detail::getter&lt; 0 &gt;, linalg::detail::getter&lt; 1 &gt;, linalg::detail::getter&lt; 2 &gt;, linalg::detail::getter&lt; 3 &gt;, linalg::detail::lerp, linalg::detail::max, linalg::detail::min, linalg::detail::op_add, linalg::detail::op_and, linalg::detail::op_cmp, linalg::detail::op_div, linalg::detail::op_eq, linalg::detail::op_ge, linalg::detail::op_gt, linalg::detail::op_int, linalg::detail::op_le, linalg::detail::op_lsh, linalg::detail::op_lt, linalg::detail::op_mod, linalg::detail::op_mul, linalg::detail::op_ne, linalg::detail::op_neg, linalg::detail::op_not, linalg::detail::op_or, linalg::detail::op_pos, linalg::detail::op_rsh, linalg::detail::op_sub, linalg::detail::op_un, linalg::detail::op_xor, linalg::detail::select, linalg::detail::std_abs, linalg::detail::std_acos, linalg::detail::std_asin, linalg::detail::std_atan, linalg::detail::std_atan2, linalg::detail::std_ceil, linalg::detail::std_copysign, linalg::detail::std_cos, linalg::detail::std_cosh, linalg::detail::std_exp, linalg::detail::std_floor, linalg::detail::std_fmod, linalg::detail::std_log, linalg::detail::std_log10, linalg::detail::std_pow, linalg::detail::std_round, linalg::detail::std_sin, linalg::detail::std_sinh, linalg::detail::std_sqrt, linalg::detail::std_tan, linalg::detail::std_tanh, should_profile_class, std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;)</li> <li>operator U (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#p","title":"p","text":"<ul> <li>plugin (ILLIXR::plugin)</li> <li>publish (ILLIXR::switchboard)</li> <li>put (ILLIXR::writer)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> </ul>"},{"location":"api/class_member_functions/#r","title":"r","text":"<ul> <li>register_impl (ILLIXR::phonebook)</li> <li>record (ILLIXR::record)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>row (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#s","title":"s","text":"<ul> <li>start (ILLIXR::plugin, ILLIXR::threadloop)</li> <li>stop (ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::threadloop)</li> <li>start_end_logger (ILLIXR::start_end_logger)</li> <li>schedule (ILLIXR::switchboard)</li> <li>subscribe_latest (ILLIXR::switchboard)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>set_offset (pose_prediction)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_member_functions/#t","title":"t","text":"<ul> <li>to_string (ILLIXR::record_header)</li> <li>thread_main (ILLIXR::threadloop)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>true_pose_reliable (pose_prediction)</li> <li>timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#v","title":"v","text":"<ul> <li>vec (linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#w","title":"w","text":"<ul> <li>wait (ILLIXR::runtime)</li> </ul>"},{"location":"api/class_member_functions/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>xy (linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xyz (linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#_1","title":"~","text":"<ul> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~reader_latest (ILLIXR::reader_latest)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~start_end_logger (ILLIXR::start_end_logger)</li> <li>~switchboard (ILLIXR::switchboard)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~writer (ILLIXR::writer)</li> <li>~pose_prediction (pose_prediction)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#_","title":"_","text":"<ul> <li>_p_publish (ILLIXR::switchboard)</li> <li>_p_schedule (ILLIXR::switchboard)</li> <li>_p_subscribe_latest (ILLIXR::switchboard)</li> <li>_p_one_iteration (ILLIXR::threadloop)</li> <li>_p_should_skip (ILLIXR::threadloop)</li> <li>_p_thread_setup (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/","title":"Class Member Variables","text":""},{"location":"api/class_member_variables/#a","title":"a","text":"<ul> <li>angular_v (ILLIXR::imu_cam_type)</li> <li>a (linalg::detail::ord)</li> <li>actually_should_profile (should_profile_class)</li> </ul>"},{"location":"api/class_member_variables/#b","title":"b","text":"<ul> <li>buffer (ILLIXR::record_coalescer)</li> <li>b (linalg::detail::ord)</li> </ul>"},{"location":"api/class_member_variables/#c","title":"c","text":"<ul> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>columns (ILLIXR::record_header)</li> <li>component_name (ILLIXR::start_end_logger)</li> <li>cpu_time_start (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#d","title":"d","text":"<ul> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>dummy (ILLIXR::hologram_output)</li> <li>dataset_time (ILLIXR::imu_cam_type)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>depth (ILLIXR::rgb_depth_type)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#g","title":"g","text":"<ul> <li>guid_starts (ILLIXR::gen_guid)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#h","title":"h","text":"<ul> <li>height (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#i","title":"i","text":"<ul> <li>ipd (ILLIXR::hmd_physical_info)</li> <li>img0 (ILLIXR::imu_cam_type)</li> <li>img1 (ILLIXR::imu_cam_type)</li> <li>id (ILLIXR::plugin, ILLIXR::record_header)</li> <li>init_time (ILLIXR::start_end_logger)</li> <li>iteration_no (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#l","title":"l","text":"<ul> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>linear_a (ILLIXR::imu_cam_type)</li> <li>last_log (ILLIXR::record_coalescer)</li> <li>logger (ILLIXR::record_coalescer)</li> <li>log_file (ILLIXR::start_end_logger)</li> <li>log_state (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_member_variables/#m","title":"m","text":"<ul> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#n","title":"n","text":"<ul> <li>name (ILLIXR::plugin, ILLIXR::record_header, print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#o","title":"o","text":"<ul> <li>orientation (ILLIXR::pose_type)</li> </ul>"},{"location":"api/class_member_variables/#p","title":"p","text":"<ul> <li>pixel (ILLIXR::camera_frame)</li> <li>pb (ILLIXR::plugin)</li> <li>position (ILLIXR::pose_type)</li> </ul>"},{"location":"api/class_member_variables/#r","title":"r","text":"<ul> <li>record_logger_ (ILLIXR::plugin)</li> <li>rh (ILLIXR::record)</li> <li>render_pose (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> <li>rgb (ILLIXR::rgb_depth_type)</li> </ul>"},{"location":"api/class_member_variables/#s","title":"s","text":"<ul> <li>seq (ILLIXR::hologram_input)</li> <li>sample_time (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> <li>swap_indices (ILLIXR::rendered_frame_alt)</li> <li>skip_no (ILLIXR::threadloop)</li> <li>serial_no (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#t","title":"t","text":"<ul> <li>time (ILLIXR::imu_cam_type, ILLIXR::pose_type, ILLIXR::rgb_depth_type)</li> <li>texture_handle (ILLIXR::rendered_frame)</li> <li>texture_handles (ILLIXR::rendered_frame_alt)</li> </ul>"},{"location":"api/class_member_variables/#u","title":"u","text":"<ul> <li>used (ILLIXR::data_use_indicator)</li> </ul>"},{"location":"api/class_member_variables/#v","title":"v","text":"<ul> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> <li>values (ILLIXR::record)</li> </ul>"},{"location":"api/class_member_variables/#w","title":"w","text":"<ul> <li>width (ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>w (linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>wall_time_start (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#x","title":"x","text":"<ul> <li>x (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#y","title":"y","text":"<ul> <li>y (linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#z","title":"z","text":"<ul> <li>z (linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#_","title":"_","text":"<ul> <li>_m_handle (ILLIXR::dynamic_lib)</li> <li>_m_mutex (ILLIXR::phonebook)</li> <li>_m_registry (ILLIXR::phonebook)</li> <li>_m_terminate (ILLIXR::threadloop)</li> <li>_m_thread (ILLIXR::threadloop)</li> <li>_p_duration (print_timer, print_timer::print_in_destructor, timer)</li> <li>_p_print_in_destructor (print_timer)</li> <li>_p_timer (print_timer)</li> <li>_p_account_name (print_timer::print_in_destructor)</li> <li>_p_now (timer)</li> <li>_p_start (timer)</li> </ul>"},{"location":"api/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"api/class_member_typedefs/#t","title":"t","text":"<ul> <li>type (linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;, linalg::detail::make_seq_impl&lt; A, 0 &gt;, linalg::detail::make_seq_impl&lt; A, 1 &gt;, linalg::detail::make_seq_impl&lt; A, 2 &gt;, linalg::detail::make_seq_impl&lt; A, 3 &gt;, linalg::detail::make_seq_impl&lt; A, 4 &gt;, linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;, linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;, linalg::detail::scalars&lt;&gt;)</li> </ul>"},{"location":"api/class_member_typedefs/#v","title":"v","text":"<ul> <li>V (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_enums/","title":"Class Member Enums","text":""},{"location":"api/class_member_enums/#a","title":"a","text":"<ul> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> </ul>"},{"location":"api/class_member_enums/#s","title":"s","text":"<ul> <li>start_end_state (ILLIXR::start_end_logger)</li> <li>skip_option (ILLIXR::threadloop)</li> </ul>"},{"location":"api/namespace_members/","title":"Namespace Members","text":""},{"location":"api/namespace_members/#a","title":"a","text":"<ul> <li>abs (linalg)</li> <li>acos (linalg)</li> <li>adjugate (linalg)</li> <li>all (linalg)</li> <li>angle (linalg)</li> <li>any (linalg)</li> <li>apply (linalg)</li> <li>apply_t (linalg)</li> <li>argmax (linalg)</li> <li>argmin (linalg)</li> <li>asin (linalg)</li> <li>atan (linalg)</li> <li>atan2 (linalg)</li> </ul>"},{"location":"api/namespace_members/#b","title":"b","text":"<ul> <li>begin (linalg)</li> <li>bool1 (linalg::aliases)</li> <li>bool1x1 (linalg::aliases)</li> <li>bool1x2 (linalg::aliases)</li> <li>bool1x3 (linalg::aliases)</li> <li>bool1x4 (linalg::aliases)</li> <li>bool2 (linalg::aliases)</li> <li>bool2x1 (linalg::aliases)</li> <li>bool2x2 (linalg::aliases)</li> <li>bool2x3 (linalg::aliases)</li> <li>bool2x4 (linalg::aliases)</li> <li>bool3 (linalg::aliases)</li> <li>bool3x1 (linalg::aliases)</li> <li>bool3x2 (linalg::aliases)</li> <li>bool3x3 (linalg::aliases)</li> <li>bool3x4 (linalg::aliases)</li> <li>bool4 (linalg::aliases)</li> <li>bool4x1 (linalg::aliases)</li> <li>bool4x2 (linalg::aliases)</li> <li>bool4x3 (linalg::aliases)</li> <li>bool4x4 (linalg::aliases)</li> <li>byte1 (linalg::aliases)</li> <li>byte2 (linalg::aliases)</li> <li>byte3 (linalg::aliases)</li> <li>byte4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#c","title":"c","text":"<ul> <li>ceil (linalg)</li> <li>clamp (linalg)</li> <li>comatrix (linalg)</li> <li>compare (linalg)</li> <li>copysign (linalg)</li> <li>cos (linalg)</li> <li>cosh (linalg)</li> <li>cross (linalg)</li> <li>conv_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_members/#d","title":"d","text":"<ul> <li>determinant (linalg)</li> <li>diagonal (linalg)</li> <li>distance (linalg)</li> <li>distance2 (linalg)</li> <li>dot (linalg)</li> <li>double1 (linalg::aliases)</li> <li>double1x1 (linalg::aliases)</li> <li>double1x2 (linalg::aliases)</li> <li>double1x3 (linalg::aliases)</li> <li>double1x4 (linalg::aliases)</li> <li>double2 (linalg::aliases)</li> <li>double2x1 (linalg::aliases)</li> <li>double2x2 (linalg::aliases)</li> <li>double2x3 (linalg::aliases)</li> <li>double2x4 (linalg::aliases)</li> <li>double3 (linalg::aliases)</li> <li>double3x1 (linalg::aliases)</li> <li>double3x2 (linalg::aliases)</li> <li>double3x3 (linalg::aliases)</li> <li>double3x4 (linalg::aliases)</li> <li>double4 (linalg::aliases)</li> <li>double4x1 (linalg::aliases)</li> <li>double4x2 (linalg::aliases)</li> <li>double4x3 (linalg::aliases)</li> <li>double4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#e","title":"e","text":"<ul> <li>end (linalg)</li> <li>equal (linalg)</li> <li>exp (linalg)</li> </ul>"},{"location":"api/namespace_members/#f","title":"f","text":"<ul> <li>floor (linalg)</li> <li>fmod (linalg)</li> <li>fold (linalg)</li> <li>frustum_matrix (linalg)</li> <li>fwd_axis (linalg)</li> <li>float1 (linalg::aliases)</li> <li>float1x1 (linalg::aliases)</li> <li>float1x2 (linalg::aliases)</li> <li>float1x3 (linalg::aliases)</li> <li>float1x4 (linalg::aliases)</li> <li>float2 (linalg::aliases)</li> <li>float2x1 (linalg::aliases)</li> <li>float2x2 (linalg::aliases)</li> <li>float2x3 (linalg::aliases)</li> <li>float2x4 (linalg::aliases)</li> <li>float3 (linalg::aliases)</li> <li>float3x1 (linalg::aliases)</li> <li>float3x2 (linalg::aliases)</li> <li>float3x3 (linalg::aliases)</li> <li>float3x4 (linalg::aliases)</li> <li>float4 (linalg::aliases)</li> <li>float4x1 (linalg::aliases)</li> <li>float4x2 (linalg::aliases)</li> <li>float4x3 (linalg::aliases)</li> <li>float4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#g","title":"g","text":"<ul> <li>gequal (linalg)</li> <li>greater (linalg)</li> </ul>"},{"location":"api/namespace_members/#i","title":"i","text":"<ul> <li>identity (linalg)</li> <li>inverse (linalg)</li> <li>int1 (linalg::aliases)</li> <li>int1x1 (linalg::aliases)</li> <li>int1x2 (linalg::aliases)</li> <li>int1x3 (linalg::aliases)</li> <li>int1x4 (linalg::aliases)</li> <li>int2 (linalg::aliases)</li> <li>int2x1 (linalg::aliases)</li> <li>int2x2 (linalg::aliases)</li> <li>int2x3 (linalg::aliases)</li> <li>int2x4 (linalg::aliases)</li> <li>int3 (linalg::aliases)</li> <li>int3x1 (linalg::aliases)</li> <li>int3x2 (linalg::aliases)</li> <li>int3x3 (linalg::aliases)</li> <li>int3x4 (linalg::aliases)</li> <li>int4 (linalg::aliases)</li> <li>int4x1 (linalg::aliases)</li> <li>int4x2 (linalg::aliases)</li> <li>int4x3 (linalg::aliases)</li> <li>int4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#l","title":"l","text":"<ul> <li>LOG_BUFFER_DELAY (ILLIXR)</li> <li>length (linalg)</li> <li>length2 (linalg)</li> <li>lequal (linalg)</li> <li>lerp (linalg)</li> <li>less (linalg)</li> <li>log (linalg)</li> <li>log10 (linalg)</li> </ul>"},{"location":"api/namespace_members/#m","title":"m","text":"<ul> <li>make_seq (linalg::detail)</li> <li>map (linalg)</li> <li>max (linalg)</li> <li>maxelem (linalg)</li> <li>min (linalg)</li> <li>minelem (linalg)</li> <li>mul (linalg)</li> </ul>"},{"location":"api/namespace_members/#n","title":"n","text":"<ul> <li>nequal (linalg)</li> <li>nlerp (linalg)</li> <li>normalize (linalg)</li> </ul>"},{"location":"api/namespace_members/#o","title":"o","text":"<ul> <li>operator!= (linalg::detail, linalg)</li> <li>operator&lt; (linalg::detail, linalg)</li> <li>operator&lt;= (linalg::detail, linalg)</li> <li>operator== (linalg::detail, linalg)</li> <li>operator&gt; (linalg::detail, linalg)</li> <li>operator&gt;= (linalg::detail, linalg)</li> <li>operator&lt;&lt; (linalg::ostream_overloads, linalg)</li> <li>operator! (linalg)</li> <li>operator% (linalg)</li> <li>operator%= (linalg)</li> <li>operator&amp; (linalg)</li> <li>operator&amp;= (linalg)</li> <li>operator* (linalg)</li> <li>operator*= (linalg)</li> <li>operator+ (linalg)</li> <li>operator+= (linalg)</li> <li>operator- (linalg)</li> <li>operator-= (linalg)</li> <li>operator/ (linalg)</li> <li>operator/= (linalg)</li> <li>operator&lt;&lt;= (linalg)</li> <li>operator&gt;&gt; (linalg)</li> <li>operator&gt;&gt;= (linalg)</li> <li>operator^ (linalg)</li> <li>operator^= (linalg)</li> <li>operator| (linalg)</li> <li>operator|= (linalg)</li> <li>operator~ (linalg)</li> <li>outerprod (linalg)</li> </ul>"},{"location":"api/namespace_members/#p","title":"p","text":"<ul> <li>plugin_factory (ILLIXR)</li> <li>perspective_matrix (linalg)</li> <li>pose_matrix (linalg)</li> <li>pow (linalg)</li> <li>product (linalg)</li> </ul>"},{"location":"api/namespace_members/#q","title":"q","text":"<ul> <li>qangle (linalg)</li> <li>qaxis (linalg)</li> <li>qconj (linalg)</li> <li>qexp (linalg)</li> <li>qinv (linalg)</li> <li>qlog (linalg)</li> <li>qmat (linalg)</li> <li>qmul (linalg)</li> <li>qnlerp (linalg)</li> <li>qpow (linalg)</li> <li>qrot (linalg)</li> <li>qslerp (linalg)</li> <li>qxdir (linalg)</li> <li>qydir (linalg)</li> <li>qzdir (linalg)</li> </ul>"},{"location":"api/namespace_members/#r","title":"r","text":"<ul> <li>runtime_factory (ILLIXR)</li> <li>ret_t (linalg::detail)</li> <li>rot (linalg)</li> <li>rotation_matrix (linalg)</li> <li>rotation_quat (linalg)</li> <li>round (linalg)</li> </ul>"},{"location":"api/namespace_members/#s","title":"s","text":"<ul> <li>short1 (linalg::aliases)</li> <li>short2 (linalg::aliases)</li> <li>short3 (linalg::aliases)</li> <li>short4 (linalg::aliases)</li> <li>scalars_t (linalg::detail)</li> <li>swizzle (linalg::detail, linalg)</li> <li>scalar_t (linalg)</li> <li>scaling_matrix (linalg)</li> <li>select (linalg)</li> <li>sin (linalg)</li> <li>sinh (linalg)</li> <li>slerp (linalg)</li> <li>sqrt (linalg)</li> <li>submat (linalg)</li> <li>subvec (linalg)</li> <li>sum (linalg)</li> </ul>"},{"location":"api/namespace_members/#t","title":"t","text":"<ul> <li>time_type (ILLIXR)</li> <li>tan (linalg)</li> <li>tanh (linalg)</li> <li>trace (linalg)</li> <li>translation_matrix (linalg)</li> <li>transpose (linalg)</li> </ul>"},{"location":"api/namespace_members/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> <li>uint1 (linalg::aliases)</li> <li>uint2 (linalg::aliases)</li> <li>uint3 (linalg::aliases)</li> <li>uint4 (linalg::aliases)</li> <li>ushort1 (linalg::aliases)</li> <li>ushort2 (linalg::aliases)</li> <li>ushort3 (linalg::aliases)</li> <li>ushort4 (linalg::aliases)</li> <li>uangle (linalg)</li> </ul>"},{"location":"api/namespace_members/#v","title":"v","text":"<ul> <li>void_ptr (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#z","title":"z","text":"<ul> <li>z_range (linalg)</li> <li>zip (linalg)</li> </ul>"},{"location":"api/namespace_members/#_","title":"_","text":"<ul> <li>__plugin_start_header (ILLIXR)</li> <li>__threadloop_iteration_header (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"api/namespace_member_functions/#a","title":"a","text":"<ul> <li>abs (linalg)</li> <li>acos (linalg)</li> <li>adjugate (linalg)</li> <li>all (linalg)</li> <li>angle (linalg)</li> <li>any (linalg)</li> <li>apply (linalg)</li> <li>argmax (linalg)</li> <li>argmin (linalg)</li> <li>asin (linalg)</li> <li>atan (linalg)</li> <li>atan2 (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#b","title":"b","text":"<ul> <li>begin (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#c","title":"c","text":"<ul> <li>ceil (linalg)</li> <li>clamp (linalg)</li> <li>comatrix (linalg)</li> <li>compare (linalg)</li> <li>copysign (linalg)</li> <li>cos (linalg)</li> <li>cosh (linalg)</li> <li>cross (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#d","title":"d","text":"<ul> <li>determinant (linalg)</li> <li>diagonal (linalg)</li> <li>distance (linalg)</li> <li>distance2 (linalg)</li> <li>dot (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#e","title":"e","text":"<ul> <li>end (linalg)</li> <li>equal (linalg)</li> <li>exp (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#f","title":"f","text":"<ul> <li>floor (linalg)</li> <li>fmod (linalg)</li> <li>fold (linalg)</li> <li>frustum_matrix (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#g","title":"g","text":"<ul> <li>gequal (linalg)</li> <li>greater (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#i","title":"i","text":"<ul> <li>inverse (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#l","title":"l","text":"<ul> <li>length (linalg)</li> <li>length2 (linalg)</li> <li>lequal (linalg)</li> <li>lerp (linalg)</li> <li>less (linalg)</li> <li>log (linalg)</li> <li>log10 (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#m","title":"m","text":"<ul> <li>map (linalg)</li> <li>max (linalg)</li> <li>maxelem (linalg)</li> <li>min (linalg)</li> <li>minelem (linalg)</li> <li>mul (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#n","title":"n","text":"<ul> <li>nequal (linalg)</li> <li>nlerp (linalg)</li> <li>normalize (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator!= (linalg::detail, linalg)</li> <li>operator&lt; (linalg::detail, linalg)</li> <li>operator&lt;= (linalg::detail, linalg)</li> <li>operator== (linalg::detail, linalg)</li> <li>operator&gt; (linalg::detail, linalg)</li> <li>operator&gt;= (linalg::detail, linalg)</li> <li>operator&lt;&lt; (linalg::ostream_overloads, linalg)</li> <li>operator! (linalg)</li> <li>operator% (linalg)</li> <li>operator%= (linalg)</li> <li>operator&amp; (linalg)</li> <li>operator&amp;= (linalg)</li> <li>operator* (linalg)</li> <li>operator*= (linalg)</li> <li>operator+ (linalg)</li> <li>operator+= (linalg)</li> <li>operator- (linalg)</li> <li>operator-= (linalg)</li> <li>operator/ (linalg)</li> <li>operator/= (linalg)</li> <li>operator&lt;&lt;= (linalg)</li> <li>operator&gt;&gt; (linalg)</li> <li>operator&gt;&gt;= (linalg)</li> <li>operator^ (linalg)</li> <li>operator^= (linalg)</li> <li>operator| (linalg)</li> <li>operator|= (linalg)</li> <li>operator~ (linalg)</li> <li>outerprod (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#p","title":"p","text":"<ul> <li>perspective_matrix (linalg)</li> <li>pose_matrix (linalg)</li> <li>pow (linalg)</li> <li>product (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#q","title":"q","text":"<ul> <li>qangle (linalg)</li> <li>qaxis (linalg)</li> <li>qconj (linalg)</li> <li>qexp (linalg)</li> <li>qinv (linalg)</li> <li>qlog (linalg)</li> <li>qmat (linalg)</li> <li>qmul (linalg)</li> <li>qnlerp (linalg)</li> <li>qpow (linalg)</li> <li>qrot (linalg)</li> <li>qslerp (linalg)</li> <li>qxdir (linalg)</li> <li>qydir (linalg)</li> <li>qzdir (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#r","title":"r","text":"<ul> <li>runtime_factory (ILLIXR)</li> <li>rot (linalg)</li> <li>rotation_matrix (linalg)</li> <li>rotation_quat (linalg)</li> <li>round (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#s","title":"s","text":"<ul> <li>swizzle (linalg::detail, linalg)</li> <li>scaling_matrix (linalg)</li> <li>select (linalg)</li> <li>sin (linalg)</li> <li>sinh (linalg)</li> <li>slerp (linalg)</li> <li>sqrt (linalg)</li> <li>submat (linalg)</li> <li>subvec (linalg)</li> <li>sum (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#t","title":"t","text":"<ul> <li>tan (linalg)</li> <li>tanh (linalg)</li> <li>trace (linalg)</li> <li>translation_matrix (linalg)</li> <li>transpose (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#u","title":"u","text":"<ul> <li>uangle (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#z","title":"z","text":"<ul> <li>zip (linalg)</li> </ul>"},{"location":"api/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"api/namespace_member_variables/#i","title":"i","text":"<ul> <li>identity (linalg)</li> </ul>"},{"location":"api/namespace_member_variables/#l","title":"l","text":"<ul> <li>LOG_BUFFER_DELAY (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#_","title":"_","text":"<ul> <li>__plugin_start_header (ILLIXR)</li> <li>__threadloop_iteration_header (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"api/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>apply_t (linalg)</li> </ul>"},{"location":"api/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>bool1 (linalg::aliases)</li> <li>bool1x1 (linalg::aliases)</li> <li>bool1x2 (linalg::aliases)</li> <li>bool1x3 (linalg::aliases)</li> <li>bool1x4 (linalg::aliases)</li> <li>bool2 (linalg::aliases)</li> <li>bool2x1 (linalg::aliases)</li> <li>bool2x2 (linalg::aliases)</li> <li>bool2x3 (linalg::aliases)</li> <li>bool2x4 (linalg::aliases)</li> <li>bool3 (linalg::aliases)</li> <li>bool3x1 (linalg::aliases)</li> <li>bool3x2 (linalg::aliases)</li> <li>bool3x3 (linalg::aliases)</li> <li>bool3x4 (linalg::aliases)</li> <li>bool4 (linalg::aliases)</li> <li>bool4x1 (linalg::aliases)</li> <li>bool4x2 (linalg::aliases)</li> <li>bool4x3 (linalg::aliases)</li> <li>bool4x4 (linalg::aliases)</li> <li>byte1 (linalg::aliases)</li> <li>byte2 (linalg::aliases)</li> <li>byte3 (linalg::aliases)</li> <li>byte4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>conv_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>double1 (linalg::aliases)</li> <li>double1x1 (linalg::aliases)</li> <li>double1x2 (linalg::aliases)</li> <li>double1x3 (linalg::aliases)</li> <li>double1x4 (linalg::aliases)</li> <li>double2 (linalg::aliases)</li> <li>double2x1 (linalg::aliases)</li> <li>double2x2 (linalg::aliases)</li> <li>double2x3 (linalg::aliases)</li> <li>double2x4 (linalg::aliases)</li> <li>double3 (linalg::aliases)</li> <li>double3x1 (linalg::aliases)</li> <li>double3x2 (linalg::aliases)</li> <li>double3x3 (linalg::aliases)</li> <li>double3x4 (linalg::aliases)</li> <li>double4 (linalg::aliases)</li> <li>double4x1 (linalg::aliases)</li> <li>double4x2 (linalg::aliases)</li> <li>double4x3 (linalg::aliases)</li> <li>double4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>float1 (linalg::aliases)</li> <li>float1x1 (linalg::aliases)</li> <li>float1x2 (linalg::aliases)</li> <li>float1x3 (linalg::aliases)</li> <li>float1x4 (linalg::aliases)</li> <li>float2 (linalg::aliases)</li> <li>float2x1 (linalg::aliases)</li> <li>float2x2 (linalg::aliases)</li> <li>float2x3 (linalg::aliases)</li> <li>float2x4 (linalg::aliases)</li> <li>float3 (linalg::aliases)</li> <li>float3x1 (linalg::aliases)</li> <li>float3x2 (linalg::aliases)</li> <li>float3x3 (linalg::aliases)</li> <li>float3x4 (linalg::aliases)</li> <li>float4 (linalg::aliases)</li> <li>float4x1 (linalg::aliases)</li> <li>float4x2 (linalg::aliases)</li> <li>float4x3 (linalg::aliases)</li> <li>float4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>int1 (linalg::aliases)</li> <li>int1x1 (linalg::aliases)</li> <li>int1x2 (linalg::aliases)</li> <li>int1x3 (linalg::aliases)</li> <li>int1x4 (linalg::aliases)</li> <li>int2 (linalg::aliases)</li> <li>int2x1 (linalg::aliases)</li> <li>int2x2 (linalg::aliases)</li> <li>int2x3 (linalg::aliases)</li> <li>int2x4 (linalg::aliases)</li> <li>int3 (linalg::aliases)</li> <li>int3x1 (linalg::aliases)</li> <li>int3x2 (linalg::aliases)</li> <li>int3x3 (linalg::aliases)</li> <li>int3x4 (linalg::aliases)</li> <li>int4 (linalg::aliases)</li> <li>int4x1 (linalg::aliases)</li> <li>int4x2 (linalg::aliases)</li> <li>int4x3 (linalg::aliases)</li> <li>int4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>make_seq (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>plugin_factory (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>ret_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>short1 (linalg::aliases)</li> <li>short2 (linalg::aliases)</li> <li>short3 (linalg::aliases)</li> <li>short4 (linalg::aliases)</li> <li>scalars_t (linalg::detail)</li> <li>scalar_t (linalg)</li> </ul>"},{"location":"api/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>time_type (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> <li>uint1 (linalg::aliases)</li> <li>uint2 (linalg::aliases)</li> <li>uint3 (linalg::aliases)</li> <li>uint4 (linalg::aliases)</li> <li>ushort1 (linalg::aliases)</li> <li>ushort2 (linalg::aliases)</li> <li>ushort3 (linalg::aliases)</li> <li>ushort4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>void_ptr (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"api/namespace_member_enums/#f","title":"f","text":"<ul> <li>fwd_axis (linalg)</li> </ul>"},{"location":"api/namespace_member_enums/#z","title":"z","text":"<ul> <li>z_range (linalg)</li> </ul>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#c","title":"c","text":"<ul> <li>count_duration (cpu_timer.hpp)</li> <li>cpp_clock_gettime (cpu_timer.hpp)</li> </ul>"},{"location":"api/functions/#g","title":"g","text":"<ul> <li>gen_serial_no (cpu_timer.hpp)</li> </ul>"},{"location":"api/functions/#i","title":"i","text":"<ul> <li>init_and_link (shader_util.hpp)</li> </ul>"},{"location":"api/functions/#m","title":"m","text":"<ul> <li>MessageCallback (shader_util.hpp)</li> </ul>"},{"location":"api/functions/#t","title":"t","text":"<ul> <li>thread_cpu_time (cpu_timer.hpp)</li> <li>timed_thread (cpu_timer.hpp)</li> </ul>"},{"location":"api/macros/","title":"Macros","text":""},{"location":"api/macros/#g","title":"g","text":"<ul> <li>GLX_CONTEXT_MAJOR_VERSION_ARB (extended_window.hpp)</li> <li>GLX_CONTEXT_MINOR_VERSION_ARB (extended_window.hpp)</li> </ul>"},{"location":"api/macros/#l","title":"l","text":"<ul> <li>LINALG_CONSTEXPR14 (linalg.hpp)</li> <li>LINALG_H (linalg.hpp)</li> </ul>"},{"location":"api/macros/#n","title":"n","text":"<ul> <li>NANO_SEC (data_format.hpp)</li> </ul>"},{"location":"api/macros/#p","title":"p","text":"<ul> <li>PRINT_CPU_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_RECORD_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_WALL_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PLUGIN_MAIN (plugin.hpp)</li> </ul>"},{"location":"api/macros/#u","title":"u","text":"<ul> <li>USE_ALT_EYE_FORMAT (data_format.hpp)</li> </ul>"},{"location":"api/variables/","title":"Variables","text":""},{"location":"api/variables/#g","title":"g","text":"<ul> <li>glXCreateContextAttribsARBProc (extended_window.hpp)</li> </ul>"},{"location":"api/variables/#s","title":"s","text":"<ul> <li>should_profile (cpu_timer.hpp)</li> </ul>"},{"location":"api/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}