{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ILLIXR","text":""},{"location":"#illixr","title":"ILLIXR","text":"<p>Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains several core state-of-the-art components of a generic XR pipeline (components that are required in most, if not all, XR applications), as well as a runtime integration framework that allows us to integrate these components together. ILLIXR's runtime integration framework is modular, extensible, and OpenXR-compatible.</p> <p>We use the term components and not kernels or computations because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in v1.2.0 of ILLIXR.</p> <ol> <li>Simultaneous Localization and Mapping</li> <li>Scene reconstruction</li> <li>Eye tracking</li> <li>Ambisonic encoding</li> <li>Ambisonic manipulation and binauralization</li> <li>Lens distortion correction</li> <li>Chromatic aberration correction</li> <li>Time warp</li> <li>Computational holography for adaptive multi-focal displays</li> </ol> <p>We plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications.</p> <p>Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors.</p> <p>Detailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our paper.</p>"},{"location":"#publications","title":"Publications","text":"<p>We request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.</p> <pre><code>@misc{HuzaifaDesai2020,\n    title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research},\n    author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve},\n    year={2020},\n    eprint={2004.04643},\n    primaryClass={cs.DC}\n}\n</code></pre>"},{"location":"#getting-started-and-documentation","title":"Getting Started and Documentation","text":"<p>For more information, see our getting started page.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Muhammad Huzaifa led the development of ILLIXR in Sarita Adve\u2019s research group at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang.</p> <p>ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.</p> <p>Our OpenXR implementation is derived from Monado. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.</p> <p>The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset.</p> <p>Wesley Darvin came up with the name for ILLIXR.</p>"},{"location":"#licensing-structure","title":"Licensing Structure","text":"<p>ILLIXR is available as open-source software under the University of Illinois/NCSA Open Source License. As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software. The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses:</p> <ul> <li>Open-VINS - GNU General Public License v3.0</li> <li>ElasticFusion - ElasticFusion license</li> <li>RITnet - MIT License</li> <li>libspatialaudio - GNU Lesser General Public License v2.1</li> <li>HOTlab - GNU Lesser General Public License v3.0</li> <li>Monado - Boost Software License 1.0</li> </ul>"},{"location":"#get-in-touch","title":"Get In Touch","text":"<p>Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living benchmark suite and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at illixr at cs dot illinois dot edu or just send us a pull request!</p>"},{"location":"building_ILLIXR/","title":"Building ILLIXR","text":""},{"location":"building_ILLIXR/#basic-usage","title":"Basic usage","text":"<ul> <li> <p>From the project root, <code>make run.dbg -j$(nproc)</code> will build the ILLIXR runtime standalone, the   ILLIXR plugins, and run it for you. <code>make run.opt -j$(nproc)</code>, is the same but with optimizations on and debug off.</p> </li> <li> <p>To build the runtime for Monado, <code>make all.dbg.so</code>.</p> </li> </ul>"},{"location":"building_ILLIXR/#adding-a-new-plugin-common-case","title":"Adding a new plugin (common case)","text":"<p>In the common case, one need only define a <code>Makefile</code> with the line <code>include common/common.mk</code> and symlink common (<code>ln -s ../common common</code>). This provides the necessary targets and uses the compiler <code>$(CXX)</code>, which is defined in Make based on the OS and environment variables.</p> <ul> <li> <p>It compiles <code>plugin.cpp</code> and any other <code>*.cpp</code> files into the plugin.</p> </li> <li> <p>It will invoke a recompile the target any time any <code>*.hpp</code> or <code>*.cpp</code> file changes.</p> </li> <li> <p>It compiles with C++17. You can change this in your plugin by defining <code>STDCXX = ...</code> before the   <code>include</code>. This change will not affect other plugins; just yours.</p> </li> <li> <p>Libraries can be added by appending to <code>LDFLAGS</code> and <code>CFLAGS</code>, for example</p> <pre><code>LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3)\nCFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3)\n</code></pre> </li> <li> <p>See the source for the exact flags.</p> </li> <li> <p>Inserted the name of your directory into the <code>component</code>-list in the root <code>Makefile</code>.</p> </li> </ul>"},{"location":"building_ILLIXR/#adding-a-plugin-general-case","title":"Adding a plugin (general case)","text":"<p>Each plugin can have a completely independent build system, as long as: - It defines a <code>Makefile</code> with targets for <code>plugin.dbg.so</code>, <code>plugin.opt.so</code>, and <code>clean</code>. Inside   this <code>Makefile</code>, one can defer to another build system.</p> <ul> <li> <p>It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using   the same version of Clang or GCC on the same architecture is sufficient for this.</p> </li> <li> <p>It's name is inserted in the root <code>Makefile</code>, in the <code>plugins</code> list.</p> </li> </ul>"},{"location":"building_ILLIXR/#philosophy","title":"Philosophy","text":"<ul> <li> <p>Each plugin should not have to know or care how the others are compiled. In the future, they may   even be distributed separately, just as SOs. Therefore, each plugin needs its own build system.</p> </li> <li> <p>Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be   extremely easy.</p> </li> <li> <p>It should be easy to build in parallel.</p> </li> <li> <p>Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when   experimenting. However, this implies that rebuilding must be fast when not much has changed.</p> </li> <li> <p>Make is the de facto standard for building C/C++ programs. GNU Make, reucrsive make, and the   makefile language begets no shortage of problems [1,2,3,4,5], but we choose   Make for its tradeoff of between simplicity and functionality. What it lacks in functionality   (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the   build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to   have a <code>common.mk</code> included in each plugin. This decision to use Make should be revisited, when   this project outgrows its ability, but for now, Make remains, in our judgement, the best tool for   the job.</p> </li> </ul>"},{"location":"default_plugins/","title":"Default Plugins","text":"<ul> <li> <p><code>offline_imu_cam</code>: Reads IMU data and images from files on disk, emulating a real sensor on the   headset (feeds input measurements with timing similar to an actual IMU).</p> </li> <li> <p><code>ground_truth_slam</code>: Reads the ground-truth from the same dataset to compare our output against   (uses timing from <code>offline_imu_cam</code>).</p> </li> <li> <p><code>open_vins</code>: Runs OpenVINS (upstream) on the input, and outputs a the headset's pose. In practice, this   publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet   have pose prediction, so we say <code>open_vins</code> also publishes a fast pose.</p> </li> <li> <p><code>gldemo</code>: Renders a static scene (into left and right eyebuffers) given the pose from <code>open_vins</code>.</p> </li> <li> <p><code>timewarp_gl</code>: Asynchronous reprojection of the eyebuffers.</p> </li> <li> <p><code>debugview</code>: Renders a frame for debug information.</p> </li> <li> <p><code>audio</code>: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.</p> </li> <li> <p><code>hologram</code>: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.</p> </li> </ul> <p>Below this point, we will use Switchboard terminology. Read the API documentation on <code>switchboard</code> for definitions.</p> <p></p> <ul> <li> <p>In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned   between these two gorups).</p> </li> <li> <p>Solid arrows from plugins to topics represent publishing.</p> </li> <li> <p>Solid arrows from topics to plugins represent synchronous reading. They take some action for   every event which gets published on the topic.</p> </li> <li> <p>Solid arrows from topics to plugins represent asynchronous reading. They need to know just the   latest event on their topic.</p> </li> <li> <p>Imagine the topic as a trough filing with events from its publisher, being drained by its   synchronous readers (AKA subscribers), while asynchronous readres just skim from the top.</p> </li> </ul> <p>See Writing Your Plugin to extend ILLIXR.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#illixr-standalone","title":"ILLIXR standalone","text":"<p>The ILLIXR runtime can be built \"standalone\", to run without Monado. This mode does not support OpenXR, but it is faster for development. These instructions have been tested with Ubuntu 18.10.</p> <ol> <li> <p>Clone the repository.</p> <pre><code>git clone --recursive https://github.com/ILLIXR/ILLIXR\n# TODO: update this link when we move repositories\n</code></pre> </li> <li> <p>Update the submodules. Submodules are git repositories inside a git repository that need to be    pulled down separately.</p> <pre><code>git submodule update --init --recursive\n</code></pre> </li> <li> <p>Install dependencies. This script installs some Ubuntu/Debian packages and builds a specific    version of OpenCV from source.</p> <pre><code>./install_deps.sh\n</code></pre> </li> <li> <p>Build and run ILLIXR standalone.</p> <pre><code>make run.dbg\n</code></pre> </li> </ol>"},{"location":"getting_started/#illixr-with-monado-supports-openxr","title":"ILLIXR with Monado (supports OpenXR)","text":"<p>Monado only supports Ubuntu 18.10, because of a low-level driver issue.</p> <ol> <li> <p>Clone and build ILLIXR (same steps as standalone, except the make target is <code>all.dbg.so</code>).</p> <pre><code>git clone --recursive https://github.com/ILLIXR/ILLIXR\ngit submodule update --init --recursive\n./install_deps.sh\nmake all.dbg.so\n</code></pre> </li> <li> <p>Clone and build Monado.</p> <pre><code>git clone https://github.com/ILLIXR/monado_integration.git\ncd monado_integration\nmkdir build &amp;&amp; cd build\ncmake .. -DBUILD_WITH_LIBUDEV=0 -DBUILD_WITH_LIBUVC=0 -DBUILD_WITH_LIBUSB=0 -DBUILD_WITH_LIBUDEV=0 -DBUILD_WITH_NS=0 -DBUILD_WITH_PSMV=0 -DBUILD_WITH_PSVR=0 -DBUILD_WITH_OPENHMD=0 -DBUILD_WITH_VIVE=0  -DILLIXR_PATH=../../ILLIXR -G \"Unix Makefiles\"\n# replace ../ILLIXR with the path to ILLIXR\nmake -j$(nproc)\n</code></pre> </li> <li> <p>Clone and build our application example.</p> <pre><code>git clone https://gitlab.freedesktop.org/monado/demos/openxr-simple-example\ncd openxr-simple-example\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\n</code></pre> </li> <li> <p>Set environment variables and run.</p> <pre><code>export XR_RUNTIME_JSON=../monado_integration/build/openxr_monado-dev.json\n# replace ../monado_integration with the path to the previous repo\nexport ILLIXR_PATH=../ILLIXR/runtime/plugin.dbg.so\nexport ILLIXR_COMP=../ILLIXR/ground_truth_slam/plugin.dbg.so:../ILLIXR/offline_imu_cam/plugin.dbg.so:../ILLIXR/open_vins/plugin.dbg.so:../ILLIXR/pose_prediction/plugin.dbg.so:../ILLIXR/timewarp_gl/plugin.dbg.so:../ILLIXR/debugview/plugin.dbg.so:../ILLIXR/audio_pipeline/plugin.dbg.so\n# replace ../ILLIXR with the path to ILLIXR\n</code></pre> </li> </ol>"},{"location":"getting_started/#next-steps","title":"Next steps","text":"<p>The source code is divided into the following directories: - <code>runtime</code>: create a runnable binary that loads every plugin.     * This contains Spindle, which is responsible for loading plugins.</p> <ul> <li> <p><code>common</code>: resources one might use in each plugin. Most plugins symlink this directory into theirs.</p> <ul> <li>Contains the interface for Switchboard, which maintains event-streams (implementation is in <code>runtime</code>).</li> <li>Contains the interface for Phonebook, which is a service-directory (implementation is in <code>runtime</code>).</li> </ul> </li> <li> <p>a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See   Default Components for more details.</p> </li> </ul> <p>Try browsing the source of plugins.  If you edit any of the source files, this make commend will detect and rebuild the respective binary. If you want to add your own, see Writing Your Plugin.</p>"},{"location":"monado_illixr_runtime_overview/","title":"Monado Integration Overview","text":"<p>ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to force developers to write their wohle application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR, so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado, an existing, open-source implementation.</p> <ul> <li> <p>When running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and   switchboard are initialized and plugins are loaded, among which is the gldemo app.</p> </li> <li> <p>When running from Monado, however, as mandated by OpenXR specifications, the application is the   entry point. As a result, the Illixr runtime system is loaded at a later point as a shared   library. This article documents the changes to the Illixr runtime when an OpenXR application is   used.</p> </li> </ul>"},{"location":"monado_illixr_runtime_overview/#1-app-launches-and-brings-up-monado","title":"1. App launches and brings up Monado","text":"<p>As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronous Group for more details.</p>"},{"location":"monado_illixr_runtime_overview/#2-monado-probes-hmd-devices-and-illixr-initializes","title":"2.  Monado probes HMD devices and Illixr Initializes","text":"<p>During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as <code>xdev</code>s.  We have an Illixr driver, which will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from environment variables.</p> <p>After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.</p>"},{"location":"monado_illixr_runtime_overview/#3-illixr-runtime-launch","title":"3. Illixr Runtime Launch","text":"<p>When used with Monado, the Illixr runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing switchboard and phonebook, and load plugins.</p> <p>The drivers starts to load the runtime by loading the shared library into the current (the app's) address space and calls the switchboard and phonebook initialization. Then, it calls the plugin loading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a translation plugin into Illixr as the application. The translation plugin will be in the next section. Each plugin should either not block or start its own thread, so the driver will be able to reacquire control and return to Monado and the app shortly.</p>"},{"location":"monado_illixr_runtime_overview/#4-the-translation-plugin","title":"4. The translation plugin","text":"<p>When the app and all Illixr plugins are up and running, the translation plugin handles the connection between Monado and Illixr. It might be confusing to see that this plugin is part of the Illixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But Monado and Illixr are running in different threads in the same address space. The translation plugin is the intersection of these two parallel systems serving as a bridge between the two.</p> <p>The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, it is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames.</p> <p>For implementation details regarding the representation of poses and frames in Monado and in Illixr, please see Monado Integration Dataflow.</p>"},{"location":"monado_integration_dataflow/","title":"Monado Integration Dataflow","text":""},{"location":"monado_integration_dataflow/#monado-integration-dataflow","title":"Monado Integration Dataflow","text":"<p>The integration for monado in terms of dataflow can be divided into two parts, getting pose from illixr, and sending user rendered frame to illixr.</p> <p>In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user application as <code>gldemo</code>. After illixr is initialized from monado, and monado is registered as a plugin for illixr, most recent pose information is easy to get from switchboard.</p> <p>The compositor side of monado integration with illixr is done in more subtle way. Original monado compositor mostly does distortion correction and aberration correction in a vulkan back-end compositor. It also has two client compositor, one for opengl app, the other for vulkan app, which pass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client compositor and sends it to switchboard of illixr, which is then used by <code>timewarp_gl</code> component.</p> <p>In order to get a opengl frame and use it without copying pixels, illixr needs to get the user application gl context. It is done at OpenXR session creation time, where illixr is initialized. Note that logically illixr is initialized during OpenXR instance creation, or running at the background all the time. But, since illixr only supports single session at this time, and requires a user application gl context upon initialization, illixr is initialized at session creation time.</p> <p>Current illixr integration for monado is a temporary solution and has some downsides because of the progress from both monado and illixr.</p> <ol> <li> <p>It does not use the pose that user application declares to use at rendering (OpenXR    specification) because of monado internal interfaces. The pose difference used by timewarp comes    from the last pose query call.</p> </li> <li> <p>It cannot submit frame with depth buffer.</p> </li> <li> <p>The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam    algorithms.</p> </li> <li> <p>No controller action support at all.</p> </li> <li> <p>It only supports gl user applications.</p> </li> <li> <p>User application cannot acquire more than one swapchain image (for each eye) in one frame.</p> </li> <li> <p>Illixr is initialized during session creation time.</p> </li> </ol>"},{"location":"visualizer_logger/","title":"Visualizer & Logger","text":""},{"location":"visualizer_logger/#visualizer-logger","title":"Visualizer &amp; Logger","text":"<p>There is a utility header file <code>common/logger.hpp</code>, which is a logger for recording process starting and ending time, with respect to the component initialization time. Currently, only <code>audio_pipeline</code> and <code>hologram</code>use this logger. Please create a <code>log</code> directory in your running binary directory to let those log files correctly appear.</p> <p><code>log/visualizer.py</code>is a script to create visual timeline according to the log files in the same directory. It is not convenient to use or precisely correct right now.</p>"},{"location":"writing_your_plugin/","title":"Writing your plugin","text":"<p>With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way.</p> <ol> <li> <p>We suggest making a subdirectory in the ILLIXR repo, but one could make it anywhere.</p> </li> <li> <p>Add this directory to <code>plugins</code> in ILLIXR's root <code>Makefile</code>. The order in this list determines    the order of initialization in the program. <code>phonebook</code>, for example, is order-sensitive.</p> </li> <li> <p>In your plugin directory, we suggest symlinking common (<code>ln -s ../common common</code>).</p> </li> <li> <p>Create a <code>Makefile</code> with the following contents. See Building ILLIXR for more details and alternative setups.</p> <pre><code>include common.mk\n</code></pre> </li> <li> <p>You must decide if your plugin should inherit the standardized <code>threadloop</code> or     <code>plugin</code>.</p> </li> <li> <p>If your plugin just needs to run one computation repeatedly, then your plugin class should     extend <code>threadloop</code>.</p> </li> <li> <p>If you need custom concurrency (more complicated than a loop), triggered concurrency (by     events fired in other plugins), or no concurrency then your plugin class should extend     <code>plugin</code>.</p> </li> <li> <p>Write a file called <code>plugin.cpp</code> with this body, replacing every instance of <code>plugin_name</code>:</p> <pre><code>#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\nusing ILLIXR;\n\n// Inherit from `plugin` if you don't need the threadloop\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(phonebook* pb) { }\n    virtual void start() override { }\n    virtual ~plugin_name() override { }\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n</code></pre> </li> <li> <p>At this point, you should be able to go to the ILLIXR root and <code>make dbg</code>. If you edit a source     file and then <code>make dbg</code>, it should trigger a rebuild of your plugin.</p> </li> <li> <p>This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR     runtime. Reading and writing from Phonebook and Switchboard optional, but nearly every plugin     does it. See <code>default_plugins.md</code> for more details.</p> <p>First, we can query the <code>phonebook</code> to get various services including <code>switchboard</code>. Then we query <code>switchboard</code> for event-streams (topics). We will read <code>topic1</code>, write to <code>topic2</code>, and schedule computation on <code>topic 3</code>. See the API documentation for <code>phonebook</code> and <code>switchboard</code> for more details.</p> <pre><code>#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\n/* When datatypes have to be common across plugins\n  (e.g. a phonebook service or switchboard topic),\n   they are defined in this header,\n   which is accessible to all plugins. */\n#include \"common/data_formath.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    /*\n        After the constructor, C++ permits a list of member-constructors.\n        We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2].\n        We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first).\n\n        [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n        [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n    */\n    plugin_name(phonebook* pb)\n          // find the switchboard in phonebook\n        : sb{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n          // create a handle to a topic in switchboard for subscribing\n        , topic1{sb-&gt;subscribe_latest&lt;topic1_type&gt;(\"topic1\")}\n          // create a handle to a topic in switchboard for publishing\n        , topic2{sb-&gt;publish&lt;topic2_type&gt;(\"topic2\")}\n    {\n        // Read topic 1\n        topic1_type* event1 = topic1.get_latest_ro();\n\n        // Write to topic 2\n        topic2_type* event2 = new topic2_type;\n        topic2.put(event2);\n\n        // Read topic 3 synchronously\n        sb-&gt;schedule&lt;topic3_type&gt;(\"topic3\", [&amp;](const topic3_type *event3) {\n            /*\n            This is a [lambda expression][1]\n            [1]: https://en.cppreference.com/w/cpp/language/lambda\n            */\n            std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n        });\n    }\n\nprivate:\n    switchboard* pb\n    std::unique_ptr&lt;reader_latest&lt;topic1_type&gt;&gt; topic1;\n    std::unique_ptr&lt;writer&lt;topic2&gt;&gt; topic2;\n};\n</code></pre> </li> </ol>"},{"location":"api/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace ILLIXR <ul> <li>struct accel </li> <li>struct camera_frame </li> <li>class global_config </li> <li>struct hmd_physical_info </li> <li>struct hologram_input </li> <li>struct hologram_output </li> <li>struct imu_cam_type </li> <li>class phonebook A service locator for ILLIXR. </li> <li>class plugin A dynamically-loadable plugin for Spindle. </li> <li>struct pose_type </li> <li>class reader_latest A handle which can read the latest event on a topic. </li> <li>struct rendered_frame </li> <li>struct rendered_frame_alt </li> <li>class service A 'service' that can be registered in the phonebook. </li> <li>class start_end_logger a utility for logging to start and end times to a file </li> <li>class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). </li> <li>class threadloop A reusable threadloop for plugins. </li> <li>class writer A handle which can publish events to a topic. </li> <li>class xlib_gl_extended_window </li> </ul> </li> <li>namespace linalg <ul> <li>namespace aliases </li> <li>struct converter </li> <li>struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; </li> <li>struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; </li> <li>struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; </li> <li>struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; </li> <li>namespace detail <ul> <li>struct any_compare </li> <li>struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; </li> <li>struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct apply </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; </li> <li>struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; </li> <li>struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; </li> <li>struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; </li> <li>struct clamp </li> <li>struct empty </li> <li>struct getter </li> <li>struct getter&lt; 0 &gt; </li> <li>struct getter&lt; 1 &gt; </li> <li>struct getter&lt; 2 &gt; </li> <li>struct getter&lt; 3 &gt; </li> <li>struct lerp </li> <li>struct make_seq_impl </li> <li>struct make_seq_impl&lt; A, 0 &gt; </li> <li>struct make_seq_impl&lt; A, 1 &gt; </li> <li>struct make_seq_impl&lt; A, 2 &gt; </li> <li>struct make_seq_impl&lt; A, 3 &gt; </li> <li>struct make_seq_impl&lt; A, 4 &gt; </li> <li>struct max </li> <li>struct min </li> <li>struct op_add </li> <li>struct op_and </li> <li>struct op_cmp </li> <li>struct op_div </li> <li>struct op_eq </li> <li>struct op_ge </li> <li>struct op_gt </li> <li>struct op_int </li> <li>struct op_le </li> <li>struct op_lsh </li> <li>struct op_lt </li> <li>struct op_mod </li> <li>struct op_mul </li> <li>struct op_ne </li> <li>struct op_neg </li> <li>struct op_not </li> <li>struct op_or </li> <li>struct op_pos </li> <li>struct op_rsh </li> <li>struct op_sub </li> <li>struct op_un </li> <li>struct op_xor </li> <li>struct ord </li> <li>struct scalar_type </li> <li>struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; </li> <li>struct scalar_type&lt; vec&lt; T, M &gt; &gt; </li> <li>struct scalars </li> <li>struct scalars&lt; T, U... &gt; </li> <li>struct scalars&lt;&gt; </li> <li>struct select </li> <li>struct seq </li> <li>struct std_abs </li> <li>struct std_acos </li> <li>struct std_asin </li> <li>struct std_atan </li> <li>struct std_atan2 </li> <li>struct std_ceil </li> <li>struct std_copysign </li> <li>struct std_cos </li> <li>struct std_cosh </li> <li>struct std_exp </li> <li>struct std_floor </li> <li>struct std_fmod </li> <li>struct std_log </li> <li>struct std_log10 </li> <li>struct std_pow </li> <li>struct std_round </li> <li>struct std_sin </li> <li>struct std_sinh </li> <li>struct std_sqrt </li> <li>struct std_tan </li> <li>struct std_tanh </li> </ul> </li> <li>struct identity_t </li> <li>struct mat </li> <li>struct mat&lt; T, M, 1 &gt; </li> <li>struct mat&lt; T, M, 2 &gt; </li> <li>struct mat&lt; T, M, 3 &gt; </li> <li>struct mat&lt; T, M, 4 &gt; </li> <li>namespace ostream_overloads </li> <li>struct vec </li> <li>struct vec&lt; T, 1 &gt; </li> <li>struct vec&lt; T, 2 &gt; </li> <li>struct vec&lt; T, 3 &gt; </li> <li>struct vec&lt; T, 4 &gt; </li> </ul> </li> <li>class pose_prediction </li> <li>namespace std <ul> <li>namespace conditional </li> <li>struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; </li> <li>struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; </li> <li>struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; </li> </ul> </li> </ul>"},{"location":"api/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir common <ul> <li>file data_format.hpp </li> <li>file extended_window.hpp </li> <li>file linalg.hpp </li> <li>file logger.hpp </li> <li>file phonebook.hpp </li> <li>file plugin.hpp </li> <li>file pose_prediction.hpp </li> <li>file shader_util.hpp </li> <li>file switchboard.hpp </li> <li>file threadloop.hpp </li> </ul> </li> </ul>"},{"location":"api/namespaceILLIXR/","title":"Namespace ILLIXR","text":"<p>Namespace List &gt; ILLIXR</p>"},{"location":"api/namespaceILLIXR/#classes","title":"Classes","text":"Type Name struct accel struct camera_frame class global_config struct hmd_physical_info struct hologram_input struct hologram_output struct imu_cam_type class phonebook A service locator for ILLIXR. class plugin A dynamically-loadable plugin for Spindle. struct pose_type class reader_latest &lt;typename event&gt;A handle which can read the latest event on a topic. struct rendered_frame struct rendered_frame_alt class service A 'service' that can be registered in the phonebook. class start_end_logger a utility for logging to start and end times to a file class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class threadloop A reusable threadloop for plugins. class writer &lt;typename event&gt;A handle which can publish events to a topic. class xlib_gl_extended_window"},{"location":"api/namespaceILLIXR/#public-types","title":"Public Types","text":"Type Name typedef std::chrono::time_point&lt; std::chrono::system_clock &gt; time_type typedef unsigned long long ullong"},{"location":"api/namespaceILLIXR/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR/#typedef-time_type","title":"typedef time_type","text":"<pre><code>typedef std::chrono::time_point&lt;std::chrono::system_clock&gt; ILLIXR::time_type;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-ullong","title":"typedef ullong","text":"<pre><code>typedef unsigned long long ILLIXR::ullong;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1accel/","title":"Struct ILLIXR::accel","text":"<p>ClassList &gt; ILLIXR &gt; accel</p> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1camera__frame/","title":"Struct ILLIXR::camera_frame","text":"<p>ClassList &gt; ILLIXR &gt; camera_frame</p>"},{"location":"api/structILLIXR_1_1camera__frame/#public-attributes","title":"Public Attributes","text":"Type Name int pixel"},{"location":"api/structILLIXR_1_1camera__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1camera__frame/#variable-pixel","title":"variable pixel","text":"<pre><code>int ILLIXR::camera_frame::pixel[1];\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1global__config/","title":"Class ILLIXR::global_config","text":"<p>ClassList &gt; ILLIXR &gt; global_config</p> <p>Inherits the following classes: ILLIXR::service</p>"},{"location":"api/classILLIXR_1_1global__config/#public-attributes","title":"Public Attributes","text":"Type Name GLFWwindow * glfw_context"},{"location":"api/classILLIXR_1_1global__config/#public-functions","title":"Public Functions","text":"Type Name global_config (GLFWwindow * _glfw_context)"},{"location":"api/classILLIXR_1_1global__config/#public-functions-inherited-from-illixrservice","title":"Public Functions inherited from ILLIXR::service","text":"<p>See ILLIXR::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1global__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1global__config/#variable-glfw_context","title":"variable glfw_context","text":"<pre><code>GLFWwindow* ILLIXR::global_config::glfw_context;\n</code></pre>"},{"location":"api/classILLIXR_1_1global__config/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1global__config/#function-global_config","title":"function global_config","text":"<pre><code>inline ILLIXR::global_config::global_config (\n    GLFWwindow * _glfw_context\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/","title":"Struct ILLIXR::hmd_physical_info","text":"<p>ClassList &gt; ILLIXR &gt; hmd_physical_info</p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes","title":"Public Attributes","text":"Type Name float K float chromaticAberration int displayPixelsHigh int displayPixelsWide float ipd float lensSeparationInMeters float metersPerTanAngleAtCenter float visibleMetersHigh float visibleMetersWide int visiblePixelsHigh int visiblePixelsWide"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-k","title":"variable K","text":"<pre><code>float ILLIXR::hmd_physical_info::K[11];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-chromaticaberration","title":"variable chromaticAberration","text":"<pre><code>float ILLIXR::hmd_physical_info::chromaticAberration[4];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelshigh","title":"variable displayPixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelswide","title":"variable displayPixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-ipd","title":"variable ipd","text":"<pre><code>float ILLIXR::hmd_physical_info::ipd;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-lensseparationinmeters","title":"variable lensSeparationInMeters","text":"<pre><code>float ILLIXR::hmd_physical_info::lensSeparationInMeters;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-meterspertanangleatcenter","title":"variable metersPerTanAngleAtCenter","text":"<pre><code>float ILLIXR::hmd_physical_info::metersPerTanAngleAtCenter;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemetershigh","title":"variable visibleMetersHigh","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemeterswide","title":"variable visibleMetersWide","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelshigh","title":"variable visiblePixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelswide","title":"variable visiblePixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsWide;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1hologram__input/","title":"Struct ILLIXR::hologram_input","text":"<p>ClassList &gt; ILLIXR &gt; hologram_input</p>"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes","title":"Public Attributes","text":"Type Name int seq"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__input/#variable-seq","title":"variable seq","text":"<pre><code>int ILLIXR::hologram_input::seq;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1hologram__output/","title":"Struct ILLIXR::hologram_output","text":"<p>ClassList &gt; ILLIXR &gt; hologram_output</p>"},{"location":"api/structILLIXR_1_1hologram__output/#public-attributes","title":"Public Attributes","text":"Type Name int dummy"},{"location":"api/structILLIXR_1_1hologram__output/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__output/#variable-dummy","title":"variable dummy","text":"<pre><code>int ILLIXR::hologram_output::dummy;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__cam__type/","title":"Struct ILLIXR::imu_cam_type","text":"<p>ClassList &gt; ILLIXR &gt; imu_cam_type</p>"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3f angular_v ullong dataset_time std::optional&lt; cv::Mat * &gt; img0 std::optional&lt; cv::Mat * &gt; img1 Eigen::Vector3f linear_a time_type time"},{"location":"api/structILLIXR_1_1imu__cam__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-angular_v","title":"variable angular_v","text":"<pre><code>Eigen::Vector3f ILLIXR::imu_cam_type::angular_v;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-dataset_time","title":"variable dataset_time","text":"<pre><code>ullong ILLIXR::imu_cam_type::dataset_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-img0","title":"variable img0","text":"<pre><code>std::optional&lt;cv::Mat*&gt; ILLIXR::imu_cam_type::img0;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-img1","title":"variable img1","text":"<pre><code>std::optional&lt;cv::Mat*&gt; ILLIXR::imu_cam_type::img1;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-linear_a","title":"variable linear_a","text":"<pre><code>Eigen::Vector3f ILLIXR::imu_cam_type::linear_a;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__cam__type/#variable-time","title":"variable time","text":"<pre><code>time_type ILLIXR::imu_cam_type::time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook/","title":"Class ILLIXR::phonebook","text":"<p>ClassList &gt; ILLIXR &gt; phonebook</p> <p>A service locator for ILLIXR.More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#public-functions","title":"Public Functions","text":"Type Name baseclass * lookup_impl () Look up an implementation of <code>baseclass</code> , which should be registered first. void register_impl (baseclass * impl) Registers an implementation of <code>baseclass</code> for future calls to lookup. virtual ~phonebook ()"},{"location":"api/classILLIXR_1_1phonebook/#detailed-description","title":"Detailed Description","text":"<p>This will be explained through an exmaple: Suppose one dynamically-loaded plugin, <code>A_plugin</code>, needs a service, <code>B_service</code>, provided by another, <code>B_plugin</code>. <code>A_plugin</code> cannot statically construct a <code>B_service</code>, because the implementation <code>B_plugin</code> is dynamically loaded. However, <code>B_plugin</code> can register an implementation of <code>B_service</code> when it is loaded, and <code>A_plugin</code> can lookup that implementation without knowing it.</p> <p><code>B_service.hpp</code> in <code>common</code>:  <pre><code>class B_service {\npublic:\n    virtual void frobnicate(foo data) = 0;\n};\n</code></pre></p> <p><code>B_plugin.hpp</code>:  <pre><code>class B_impl : public B_service {\npublic:\n    virtual void frobnicate(foo data) {\n        // ...\n    }\n};\nvoid blah_blah(phonebook* pb) {\n    // Expose `this` as the \"official\" implementation of `B_service` for this run.\n    pb-&gt;register_impl&lt;B_service&gt;(new B_impl);\n}\n</code></pre></p> <p><code>A_plugin.cpp</code>:  <pre><code>#include \"B_service.hpp\"\nvoid blah_blah(phonebook* pb) {\n    B_service* b = pb-&gt;lookup_impl&lt;B_service&gt;();\n    b-&gt;frobnicate(data);\n}\n</code></pre></p> <p>If the implementation of <code>B_service</code> is not known to <code>A_plugin</code> (the usual case), <code>B_service should be an [abstract class][2]. In either case</code>B_service<code>should be in</code>common`, so both plugins can refer to it.</p> <p>One could even selectively return a different implementation of <code>B_service</code> depending on the caller (through the parameters), but we have not encountered the need for that yet. </p>"},{"location":"api/classILLIXR_1_1phonebook/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook/#function-lookup_impl","title":"function lookup_impl","text":"<p>Look up an implementation of <code>baseclass</code> , which should be registered first. <pre><code>template&lt;typename baseclass&gt;\ninline baseclass * ILLIXR::phonebook::lookup_impl () \n</code></pre></p> <p>Safe to be called from any thread.</p> <p>Do not call <code>delete</code> on the returned object; it is still managed by phonebook.</p> <p>Exception:</p> <ul> <li><code>if</code> an implementation is not already registered. </li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#function-register_impl","title":"function register_impl","text":"<p>Registers an implementation of <code>baseclass</code> for future calls to lookup. <pre><code>template&lt;typename baseclass&gt;\ninline void ILLIXR::phonebook::register_impl (\n    baseclass * impl\n) \n</code></pre></p> <p>This overwwrites any existing implementation of <code>baseclass</code>.</p> <p>Safe to be called from any thread.</p> <p>The implementation will be owned by phonebook (phonebook calls <code>delete</code>). </p>"},{"location":"api/classILLIXR_1_1phonebook/#function-phonebook","title":"function ~phonebook","text":"<pre><code>inline virtual ILLIXR::phonebook::~phonebook () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1plugin/","title":"Class ILLIXR::plugin","text":"<p>ClassList &gt; ILLIXR &gt; plugin</p> <p>A dynamically-loadable plugin for Spindle. </p> <ul> <li><code>#include &lt;plugin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::service</p> <p>Inherited by the following classes: ILLIXR::threadloop,  pose_prediction</p>"},{"location":"api/classILLIXR_1_1plugin/#public-functions","title":"Public Functions","text":"Type Name virtual void start () A method which Spindle calls when it starts the component."},{"location":"api/classILLIXR_1_1plugin/#public-functions-inherited-from-illixrservice","title":"Public Functions inherited from ILLIXR::service","text":"<p>See ILLIXR::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#function-start","title":"function start","text":"<p>A method which Spindle calls when it starts the component. <pre><code>inline virtual void ILLIXR::plugin::start () \n</code></pre></p> <p>This is necessary for actions which have to be started after constructions, such as threads. These cannot be started in the constructor because virtual methods don't work in consturctors.</p> <p>There is no <code>stop()</code> because destructor should be considered analagous. </p> <p>The documentation for this class was generated from the following file <code>common/plugin.hpp</code></p>"},{"location":"api/structILLIXR_1_1pose__type/","title":"Struct ILLIXR::pose_type","text":"<p>ClassList &gt; ILLIXR &gt; pose_type</p>"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Quaternionf orientation Eigen::Vector3f position time_type time"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1pose__type/#variable-orientation","title":"variable orientation","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_type::orientation;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3f ILLIXR::pose_type::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-time","title":"variable time","text":"<pre><code>time_type ILLIXR::pose_type::time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1reader__latest/","title":"Class ILLIXR::reader_latest","text":"<p>template &lt;typename event&gt;</p> <p>ClassList &gt; ILLIXR &gt; reader_latest</p> <p>A handle which can read the latest event on a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1reader__latest/#public-functions","title":"Public Functions","text":"Type Name virtual event * get_latest () const = 0Gets a mutable copy of the latest value. virtual const event * get_latest_ro () const = 0Gets a \"read-only\" copy of the latest value. virtual ~reader_latest ()"},{"location":"api/classILLIXR_1_1reader__latest/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1reader__latest/#function-get_latest","title":"function get_latest","text":"<p>Gets a mutable copy of the latest value. <pre><code>virtual event * ILLIXR::reader_latest::get_latest () const = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1reader__latest/#function-get_latest_ro","title":"function get_latest_ro","text":"<p>Gets a \"read-only\" copy of the latest value. <pre><code>virtual const event * ILLIXR::reader_latest::get_latest_ro () const = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1reader__latest/#function-reader_latest","title":"function ~reader_latest","text":"<pre><code>inline virtual ILLIXR::reader_latest::~reader_latest () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendered__frame/","title":"Struct ILLIXR::rendered_frame","text":"<p>ClassList &gt; ILLIXR &gt; rendered_frame</p>"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes","title":"Public Attributes","text":"Type Name pose_type render_pose std::chrono::time_point&lt; std::chrono::system_clock &gt; sample_time GLuint texture_handle"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame/#variable-render_pose","title":"variable render_pose","text":"<pre><code>pose_type ILLIXR::rendered_frame::render_pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-sample_time","title":"variable sample_time","text":"<pre><code>std::chrono::time_point&lt;std::chrono::system_clock&gt; ILLIXR::rendered_frame::sample_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-texture_handle","title":"variable texture_handle","text":"<pre><code>GLuint ILLIXR::rendered_frame::texture_handle;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/","title":"Struct ILLIXR::rendered_frame_alt","text":"<p>ClassList &gt; ILLIXR &gt; rendered_frame_alt</p>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#public-attributes","title":"Public Attributes","text":"Type Name pose_type render_pose std::chrono::time_point&lt; std::chrono::system_clock &gt; sample_time GLuint swap_indices GLuint texture_handles"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-render_pose","title":"variable render_pose","text":"<pre><code>pose_type ILLIXR::rendered_frame_alt::render_pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-sample_time","title":"variable sample_time","text":"<pre><code>std::chrono::time_point&lt;std::chrono::system_clock&gt; ILLIXR::rendered_frame_alt::sample_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-swap_indices","title":"variable swap_indices","text":"<pre><code>GLuint ILLIXR::rendered_frame_alt::swap_indices[2];\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame__alt/#variable-texture_handles","title":"variable texture_handles","text":"<pre><code>GLuint ILLIXR::rendered_frame_alt::texture_handles[2];\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1service/","title":"Class ILLIXR::service","text":"<p>ClassList &gt; ILLIXR &gt; service</p> <p>A 'service' that can be registered in the phonebook. More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::global_config,  ILLIXR::plugin,  ILLIXR::switchboard,  ILLIXR::xlib_gl_extended_window</p>"},{"location":"api/classILLIXR_1_1service/#public-functions","title":"Public Functions","text":"Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1service/#detailed-description","title":"Detailed Description","text":"<p>These must be 'destructible', have a virtual destructor that phonebook can call in its destructor. </p>"},{"location":"api/classILLIXR_1_1service/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1service/#function-service","title":"function ~service","text":"<pre><code>inline virtual ILLIXR::service::~service () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1start__end__logger/","title":"Class ILLIXR::start_end_logger","text":"<p>ClassList &gt; ILLIXR &gt; start_end_logger</p> <p>a utility for logging to start and end times to a file </p> <ul> <li><code>#include &lt;logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1start__end__logger/#public-functions","title":"Public Functions","text":"Type Name int log_end (std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time)  int log_start (std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time)  start_end_logger (std::string component_name)  ~start_end_logger ()"},{"location":"api/classILLIXR_1_1start__end__logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1start__end__logger/#function-log_end","title":"function log_end","text":"<pre><code>inline int ILLIXR::start_end_logger::log_end (\n    std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-log_start","title":"function log_start","text":"<pre><code>inline int ILLIXR::start_end_logger::log_start (\n    std::chrono::time_point&lt; std::chrono::system_clock &gt; log_time\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-start_end_logger","title":"function start_end_logger","text":"<pre><code>inline ILLIXR::start_end_logger::start_end_logger (\n    std::string component_name\n) \n</code></pre> <p>Log apperas in <code>log/$component_name</code>. </p>"},{"location":"api/classILLIXR_1_1start__end__logger/#function-start_end_logger_1","title":"function ~start_end_logger","text":"<pre><code>inline ILLIXR::start_end_logger::~start_end_logger () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard/","title":"Class ILLIXR::switchboard","text":"<p>ClassList &gt; ILLIXR &gt; switchboard</p> <p>A manager for typesafe, threadsafe, named event-streams (called topics). More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::service</p>"},{"location":"api/classILLIXR_1_1switchboard/#public-functions","title":"Public Functions","text":"Type Name std::unique_ptr&lt; writer&lt; event &gt; &gt; publish (const std::string &amp; name) Gets a handle to publish to the topic <code>name</code> . void schedule (std::string name, std::function&lt; void(const event *)&gt; fn) Schedules the callback <code>fn</code> every time an event is published to<code>name</code> . std::unique_ptr&lt; reader_latest&lt; event &gt; &gt; subscribe_latest (const std::string &amp; name) Gets a handle to read to the latest value from the topic <code>name</code> . virtual ~switchboard ()"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-inherited-from-illixrservice","title":"Public Functions inherited from ILLIXR::service","text":"<p>See ILLIXR::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1switchboard/#detailed-description","title":"Detailed Description","text":"<ul> <li>Writing: One can write to a topic (in any thread) through the <code>ILLIXR::writer</code> returned by <code>publish()</code>.</li> <li>There are two ways of reading: asynchronous reading and synchronous reading:</li> <li>Asynchronous reading returns the most-recent event on the topic (idempotently). One can do this through (in any thread) the <code>ILLIXR::reader_latest</code> handle returned by <code>subscribe_latest()</code>.</li> <li>Synchronous reading schedules a callback to be executed on every event which gets published. One can schedule computation by <code>schedule()</code>, which will run the computation in a thread managed by switchboard.</li> </ul> <pre><code>void do_stuff(switchboard* sb) {\n    auto topic1 = sb-&gt;subscribe_latest&lt;topic1_type&gt;(\"topic1\");\n    auto topic2 = sb-&gt;publish&lt;topic2_type&gt;(\"topic2\");\n\n    // Read topic 3 synchronously\n    sb-&gt;schedule&lt;topic3_type&gt;(\"topic3\", [&amp;](const topic3_type *event3) {\n        // This is a lambda expression\n        // https://en.cppreference.com/w/cpp/language/lambda\n        std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n    });\n\n    while (true) {\n        // Read topic 1\n        topic1_type* event1 = topic1.get_latest_ro();\n\n        // Write to topic 2\n        topic2_type* event2 = new topic2_type;\n        topic2.put(event2);\n    }\n}\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#function-publish","title":"function publish","text":"<p>Gets a handle to publish to the topic <code>name</code> . <pre><code>template&lt;typename event&gt;\ninline std::unique_ptr&lt; writer &lt; event &gt; &gt; ILLIXR::switchboard::publish (\n    const std::string &amp; name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-schedule","title":"function schedule","text":"<p>Schedules the callback <code>fn</code> every time an event is published to<code>name</code> . <pre><code>template&lt;typename event&gt;\ninline void ILLIXR::switchboard::schedule (\n    std::string name,\n    std::function&lt; void(const event *)&gt; fn\n) \n</code></pre></p> <p>Switchboard maintains a threadpool to call <code>fn</code>. It is possible multiple instances of <code>fn</code> will be running concurrently if the event's repetition period is less than the runtime of <code>fn</code>.</p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>if</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-subscribe_latest","title":"function subscribe_latest","text":"<p>Gets a handle to read to the latest value from the topic <code>name</code> . <pre><code>template&lt;typename event&gt;\ninline std::unique_ptr&lt; reader_latest &lt; event &gt; &gt; ILLIXR::switchboard::subscribe_latest (\n    const std::string &amp; name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-switchboard","title":"function ~switchboard","text":"<pre><code>inline virtual ILLIXR::switchboard::~switchboard () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1threadloop/","title":"Class ILLIXR::threadloop","text":"<p>ClassList &gt; ILLIXR &gt; threadloop</p> <p>A reusable threadloop for plugins. More...</p> <ul> <li><code>#include &lt;threadloop.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions","title":"Public Functions","text":"Type Name virtual void start () overrideStarts the thread. void stop () Stops the thread. virtual ~threadloop () override"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name virtual void start () A method which Spindle calls when it starts the component."},{"location":"api/classILLIXR_1_1threadloop/#public-functions-inherited-from-illixrservice","title":"Public Functions inherited from ILLIXR::service","text":"<p>See ILLIXR::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions","title":"Protected Functions","text":"Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. void reliable_sleep (std::chrono::time_point&lt; std::chrono::system_clock &gt; stop) Sleeps until a roughly <code>stop</code> . bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1threadloop/#detailed-description","title":"Detailed Description","text":"<p>The thread continuously runs <code>_p_one_iteration()</code> and is stopable by <code>stop()</code>.</p> <p>This factors out the common code I noticed in many different plugins. </p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-start","title":"function start","text":"<p>Starts the thread. <pre><code>inline virtual void ILLIXR::threadloop::start () override\n</code></pre></p> <p>Implements ILLIXR::plugin::start</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-stop","title":"function stop","text":"<p>Stops the thread. <pre><code>inline void ILLIXR::threadloop::stop () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop","title":"function ~threadloop","text":"<pre><code>inline virtual ILLIXR::threadloop::~threadloop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Override with the computation the thread does every loop. <pre><code>virtual void ILLIXR::threadloop::_p_one_iteration () = 0\n</code></pre></p> <p>This gets called in rapid succession. </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-reliable_sleep","title":"function reliable_sleep","text":"<p>Sleeps until a roughly <code>stop</code> . <pre><code>inline void ILLIXR::threadloop::reliable_sleep (\n    std::chrono::time_point&lt; std::chrono::system_clock &gt; stop\n) \n</code></pre></p> <p>We attempt to still be somewhat responsive to <code>stop()</code> and to be more accurate than stdlib's <code>sleep</code>, by sleeping for the deadline in chunks. </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-should_terminate","title":"function should_terminate","text":"<p>Whether the thread has been asked to terminate. <pre><code>inline bool ILLIXR::threadloop::should_terminate () \n</code></pre></p> <p>Check this before doing long-running computation; it makes termination more responsive. </p> <p>The documentation for this class was generated from the following file <code>common/threadloop.hpp</code></p>"},{"location":"api/classILLIXR_1_1writer/","title":"Class ILLIXR::writer","text":"<p>template &lt;typename event&gt;</p> <p>ClassList &gt; ILLIXR &gt; writer</p> <p>A handle which can publish events to a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1writer/#public-functions","title":"Public Functions","text":"Type Name virtual event * allocate () = 0Like <code>new</code> /<code>malloc</code> but more efficient for the specific case. virtual void put (const event * ev) = 0Publish <code>ev</code> to this topic. virtual ~writer ()"},{"location":"api/classILLIXR_1_1writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1writer/#function-allocate","title":"function allocate","text":"<p>Like <code>new</code> /<code>malloc</code> but more efficient for the specific case. <pre><code>virtual event * ILLIXR::writer::allocate () = 0\n</code></pre></p> <p>There is an optimization available which has not yet been implemented: switchboard can memory from old events, like a slab allocator. Suppose module A publishes data for module B. B's deallocation through the destructor, and A's allocation through this method completes the cycle in a double-buffer (AKA swap-chain). </p>"},{"location":"api/classILLIXR_1_1writer/#function-put","title":"function put","text":"<p>Publish <code>ev</code> to this topic. <pre><code>virtual void ILLIXR::writer::put (\n    const event * ev\n) = 0\n</code></pre></p> <p>Currently, nobody is responsible for calling <code>delete</code> on it, but this will change. </p>"},{"location":"api/classILLIXR_1_1writer/#function-writer","title":"function ~writer","text":"<pre><code>inline virtual ILLIXR::writer::~writer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/","title":"Class ILLIXR::xlib_gl_extended_window","text":"<p>ClassList &gt; ILLIXR &gt; xlib_gl_extended_window</p> <p>Inherits the following classes: ILLIXR::service</p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes","title":"Public Attributes","text":"Type Name Display * dpy GLXContext glc int height int width Window win"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions","title":"Public Functions","text":"Type Name xlib_gl_extended_window (int _width, int _height, GLXContext _shared_gl_context)"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-inherited-from-illixrservice","title":"Public Functions inherited from ILLIXR::service","text":"<p>See ILLIXR::service</p> Type Name virtual ~service ()"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-dpy","title":"variable dpy","text":"<pre><code>Display* ILLIXR::xlib_gl_extended_window::dpy;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-glc","title":"variable glc","text":"<pre><code>GLXContext ILLIXR::xlib_gl_extended_window::glc;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-height","title":"variable height","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::height;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-width","title":"variable width","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::width;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-win","title":"variable win","text":"<pre><code>Window ILLIXR::xlib_gl_extended_window::win;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window","title":"function xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::xlib_gl_extended_window (\n    int _width,\n    int _height,\n    GLXContext _shared_gl_context\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/extended_window.hpp</code></p>"},{"location":"api/namespacelinalg/","title":"Namespace linalg","text":"<p>Namespace List &gt; linalg</p>"},{"location":"api/namespacelinalg/#namespaces","title":"Namespaces","text":"Type Name namespace aliases namespace detail namespace ostream_overloads"},{"location":"api/namespacelinalg/#classes","title":"Classes","text":"Type Name struct converter &lt;class T, class U&gt; struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; &lt;class T&gt; struct identity_t struct mat &lt;class T, M, N&gt; struct mat&lt; T, M, 1 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 2 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 3 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 4 &gt; &lt;class T, M&gt; struct vec &lt;class T, M&gt; struct vec&lt; T, 1 &gt; &lt;class T&gt; struct vec&lt; T, 2 &gt; &lt;class T&gt; struct vec&lt; T, 3 &gt; &lt;class T&gt; struct vec&lt; T, 4 &gt; &lt;class T&gt;"},{"location":"api/namespacelinalg/#public-types","title":"Public Types","text":"Type Name typedef typename detail::apply&lt; F, void, A... &gt;::type apply_t enum fwd_axis typedef typename detail::scalar_type&lt; A &gt;::type scalar_t enum z_range"},{"location":"api/namespacelinalg/#public-attributes","title":"Public Attributes","text":"Type Name constexpr identity_t identity   = <code>{1}</code>"},{"location":"api/namespacelinalg/#public-functions","title":"Public Functions","text":"Type Name apply_t&lt; detail::std_abs, A &gt; abs (const A &amp; a)  apply_t&lt; detail::std_acos, A &gt; acos (const A &amp; a)  constexpr mat&lt; T, 1, 1 &gt; adjugate (const mat&lt; T, 1, 1 &gt; &amp; a)  constexpr mat&lt; T, 2, 2 &gt; adjugate (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr mat&lt; T, 3, 3 &gt; adjugate (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr mat&lt; T, 4, 4 &gt; adjugate (const mat&lt; T, 4, 4 &gt; &amp; a)  constexpr bool all (const A &amp; a)  T angle (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr bool any (const A &amp; a)  constexpr apply_t&lt; F, A... &gt; apply (F func, const A &amp;... args)  int argmax (const vec&lt; T, M &gt; &amp; a)  int argmin (const vec&lt; T, M &gt; &amp; a)  apply_t&lt; detail::std_asin, A &gt; asin (const A &amp; a)  apply_t&lt; detail::std_atan, A &gt; atan (const A &amp; a)  apply_t&lt; detail::std_atan2, A, B &gt; atan2 (const A &amp; a, const B &amp; b)  T * begin (vec&lt; T, M &gt; &amp; a)  const T * begin (const vec&lt; T, M &gt; &amp; a)  vec&lt; T, M &gt; * begin (mat&lt; T, M, N &gt; &amp; a)  const vec&lt; T, M &gt; * begin (const mat&lt; T, M, N &gt; &amp; a)  apply_t&lt; detail::std_ceil, A &gt; ceil (const A &amp; a)  constexpr apply_t&lt; detail::clamp, X, L, H &gt; clamp (const X &amp; x, const L &amp; l, const H &amp; h)  constexpr mat&lt; T, N, N &gt; comatrix (const mat&lt; T, N, N &gt; &amp; a)  constexpr detail::any_compare&lt; A, B &gt;::type compare (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_copysign, A, B &gt; copysign (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_cos, A &gt; cos (const A &amp; a)  apply_t&lt; detail::std_cosh, A &gt; cosh (const A &amp; a)  constexpr T cross (const vec&lt; T, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, 2 &gt; cross (T a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, 2 &gt; cross (const vec&lt; T, 2 &gt; &amp; a, T b)  constexpr vec&lt; T, 3 &gt; cross (const vec&lt; T, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr T determinant (const mat&lt; T, 1, 1 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr T determinant (const mat&lt; T, 4, 4 &gt; &amp; a)  constexpr vec&lt; T, 1 &gt; diagonal (const mat&lt; T, 1, 1 &gt; &amp; a)  constexpr vec&lt; T, 2 &gt; diagonal (const mat&lt; T, 2, 2 &gt; &amp; a)  constexpr vec&lt; T, 3 &gt; diagonal (const mat&lt; T, 3, 3 &gt; &amp; a)  constexpr vec&lt; T, 4 &gt; diagonal (const mat&lt; T, 4, 4 &gt; &amp; a)  T distance (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr T distance2 (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr T dot (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  T * end (vec&lt; T, M &gt; &amp; a)  const T * end (const vec&lt; T, M &gt; &amp; a)  vec&lt; T, M &gt; * end (mat&lt; T, M, N &gt; &amp; a)  const vec&lt; T, M &gt; * end (const mat&lt; T, M, N &gt; &amp; a)  constexpr apply_t&lt; detail::op_eq, A, B &gt; equal (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_exp, A &gt; exp (const A &amp; a)  apply_t&lt; detail::std_floor, A &gt; floor (const A &amp; a)  apply_t&lt; detail::std_fmod, A, B &gt; fmod (const A &amp; a, const B &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 1 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 2 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 3 &gt; &amp; b)  constexpr A fold (F f, A a, const vec&lt; B, 4 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 1 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 2 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 3 &gt; &amp; b)  constexpr A fold (F f, A a, const mat&lt; B, M, 4 &gt; &amp; b)  mat&lt; T, 4, 4 &gt; frustum_matrix (T x0, T x1, T y0, T y1, T n, T f, fwd_axis a=neg_z, z_range z=neg_one_to_one)  constexpr apply_t&lt; detail::op_ge, A, B &gt; gequal (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_gt, A, B &gt; greater (const A &amp; a, const B &amp; b)  constexpr mat&lt; T, N, N &gt; inverse (const mat&lt; T, N, N &gt; &amp; a)  T length (const vec&lt; T, M &gt; &amp; a)  constexpr T length2 (const vec&lt; T, M &gt; &amp; a)  constexpr apply_t&lt; detail::op_le, A, B &gt; lequal (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::lerp, A, B, T &gt; lerp (const A &amp; a, const B &amp; b, const T &amp; t)  constexpr apply_t&lt; detail::op_lt, A, B &gt; less (const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_log, A &gt; log (const A &amp; a)  apply_t&lt; detail::std_log10, A &gt; log10 (const A &amp; a)  constexpr apply_t&lt; F, A &gt; map (const A &amp; a, F func)  constexpr apply_t&lt; detail::max, A, B &gt; max (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; maxelem (const A &amp; a)  constexpr apply_t&lt; detail::min, A, B &gt; min (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; minelem (const A &amp; a)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 1 &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  constexpr mat&lt; T, M, 1 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 1 &gt; &amp; b)  constexpr mat&lt; T, M, 2 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 2 &gt; &amp; b)  constexpr mat&lt; T, M, 3 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 3 &gt; &amp; b)  constexpr mat&lt; T, M, 4 &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, 4 &gt; &amp; b)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const vec&lt; T, P &gt; &amp; c)  constexpr mat&lt; T, M, Q &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c)  constexpr vec&lt; T, M &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c, const vec&lt; T, Q &gt; &amp; d)  constexpr mat&lt; T, M, R &gt; mul (const mat&lt; T, M, N &gt; &amp; a, const mat&lt; T, N, P &gt; &amp; b, const mat&lt; T, P, Q &gt; &amp; c, const mat&lt; T, Q, R &gt; &amp; d)  constexpr apply_t&lt; detail::op_ne, A, B &gt; nequal (const A &amp; a, const B &amp; b)  vec&lt; T, M &gt; nlerp (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b, T t)  vec&lt; T, M &gt; normalize (const vec&lt; T, M &gt; &amp; a)  constexpr apply_t&lt; detail::op_not, A &gt; operator! (const A &amp; a)  virtual constexpr auto operator!= (const A &amp; a, const B &amp; b) = 0 constexpr apply_t&lt; detail::op_mod, A, B &gt; operator% (const A &amp; a, const B &amp; b)  constexpr auto operator%= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_int, A, B &gt; operator&amp; (const A &amp; a, const B &amp; b)  constexpr auto operator&amp;= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_mul, A, B &gt; operator* (const A &amp; a, const B &amp; b)  constexpr auto operator*= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_pos, A &gt; operator+ (const A &amp; a)  constexpr apply_t&lt; detail::op_add, A, B &gt; operator+ (const A &amp; a, const B &amp; b)  constexpr auto operator+= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_neg, A &gt; operator- (const A &amp; a)  constexpr apply_t&lt; detail::op_sub, A, B &gt; operator- (const A &amp; a, const B &amp; b)  constexpr auto operator-= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_div, A, B &gt; operator/ (const A &amp; a, const B &amp; b)  constexpr auto operator/= (A &amp; a, const B &amp; b)  constexpr auto operator&lt; (const A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_lsh, A, B &gt; operator&lt;&lt; (const A &amp; a, const B &amp; b)  constexpr auto operator&lt;&lt;= (A &amp; a, const B &amp; b)  virtual constexpr auto operator&lt;= (const A &amp; a, const B &amp; b) = 0 virtual constexpr auto operator== (const A &amp; a, const B &amp; b) = 0 constexpr auto operator&gt; (const A &amp; a, const B &amp; b)  virtual constexpr auto operator&gt;= (const A &amp; a, const B &amp; b) = 0 constexpr apply_t&lt; detail::op_rsh, A, B &gt; operator&gt;&gt; (const A &amp; a, const B &amp; b)  constexpr auto operator&gt;&gt;= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_xor, A, B &gt; operator^ (const A &amp; a, const B &amp; b)  constexpr auto operator^= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_un, A, B &gt; operator| (const A &amp; a, const B &amp; b)  constexpr auto operator|= (A &amp; a, const B &amp; b)  constexpr apply_t&lt; detail::op_cmp, A &gt; operator~ (const A &amp; a)  constexpr mat&lt; T, M, 1 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b)  constexpr mat&lt; T, M, 2 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b)  constexpr mat&lt; T, M, 3 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b)  constexpr mat&lt; T, M, 4 &gt; outerprod (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  mat&lt; T, 4, 4 &gt; perspective_matrix (T fovy, T aspect, T n, T f, fwd_axis a=neg_z, z_range z=neg_one_to_one)  mat&lt; T, 4, 4 &gt; pose_matrix (const vec&lt; T, 4 &gt; &amp; q, const vec&lt; T, 3 &gt; &amp; p)  apply_t&lt; detail::std_pow, A, B &gt; pow (const A &amp; a, const B &amp; b)  constexpr scalar_t&lt; A &gt; product (const A &amp; a)  T qangle (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 3 &gt; qaxis (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 4 &gt; qconj (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qexp (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qinv (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 4 &gt; qlog (const vec&lt; T, 4 &gt; &amp; q)  constexpr mat&lt; T, 3, 3 &gt; qmat (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 4 &gt; qmul (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b)  constexpr vec&lt; T, 4 &gt; qmul (const vec&lt; T, 4 &gt; &amp; a, R... r)  vec&lt; T, 4 &gt; qnlerp (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b, T t)  vec&lt; T, 4 &gt; qpow (const vec&lt; T, 4 &gt; &amp; q, const T &amp; p)  constexpr vec&lt; T, 3 &gt; qrot (const vec&lt; T, 4 &gt; &amp; q, const vec&lt; T, 3 &gt; &amp; v)  vec&lt; T, 4 &gt; qslerp (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b, T t)  constexpr vec&lt; T, 3 &gt; qxdir (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 3 &gt; qydir (const vec&lt; T, 4 &gt; &amp; q)  constexpr vec&lt; T, 3 &gt; qzdir (const vec&lt; T, 4 &gt; &amp; q)  vec&lt; T, 2 &gt; rot (T a, const vec&lt; T, 2 &gt; &amp; v)  mat&lt; T, 4, 4 &gt; rotation_matrix (const vec&lt; T, 4 &gt; &amp; rotation)  vec&lt; T, 4 &gt; rotation_quat (const vec&lt; T, 3 &gt; &amp; axis, T angle)  vec&lt; T, 4 &gt; rotation_quat (const mat&lt; T, 3, 3 &gt; &amp; m)  apply_t&lt; detail::std_round, A &gt; round (const A &amp; a)  mat&lt; T, 4, 4 &gt; scaling_matrix (const vec&lt; T, 3 &gt; &amp; scaling)  constexpr apply_t&lt; detail::select, P, A, B &gt; select (const P &amp; p, const A &amp; a, const B &amp; b)  apply_t&lt; detail::std_sin, A &gt; sin (const A &amp; a)  apply_t&lt; detail::std_sinh, A &gt; sinh (const A &amp; a)  vec&lt; T, M &gt; slerp (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b, T t)  apply_t&lt; detail::std_sqrt, A &gt; sqrt (const A &amp; a)  constexpr mat&lt; T, I1-I0, J1-J0 &gt; submat (const mat&lt; T, M, N &gt; &amp; a)  constexpr vec&lt; T, I1-I0 &gt; subvec (const vec&lt; T, M &gt; &amp; a)  constexpr scalar_t&lt; A &gt; sum (const A &amp; a)  constexpr vec&lt; T, sizeof...(I)&gt; swizzle (const vec&lt; T, M &gt; &amp; a)  apply_t&lt; detail::std_tan, A &gt; tan (const A &amp; a)  apply_t&lt; detail::std_tanh, A &gt; tanh (const A &amp; a)  constexpr T trace (const mat&lt; T, N, N &gt; &amp; a)  mat&lt; T, 4, 4 &gt; translation_matrix (const vec&lt; T, 3 &gt; &amp; translation)  constexpr mat&lt; T, M, 1 &gt; transpose (const mat&lt; T, 1, M &gt; &amp; m)  constexpr mat&lt; T, M, 2 &gt; transpose (const mat&lt; T, 2, M &gt; &amp; m)  constexpr mat&lt; T, M, 3 &gt; transpose (const mat&lt; T, 3, M &gt; &amp; m)  constexpr mat&lt; T, M, 4 &gt; transpose (const mat&lt; T, 4, M &gt; &amp; m)  T uangle (const vec&lt; T, M &gt; &amp; a, const vec&lt; T, M &gt; &amp; b)  constexpr apply_t&lt; F, A, B &gt; zip (const A &amp; a, const B &amp; b, F func)"},{"location":"api/namespacelinalg/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg/#typedef-apply_t","title":"typedef apply_t","text":"<pre><code>using linalg::apply_t = typedef typename detail::apply&lt;F,void,A...&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg/#enum-fwd_axis","title":"enum fwd_axis","text":"<pre><code>enum linalg::fwd_axis {\n    neg_z,\n    pos_z\n};\n</code></pre>"},{"location":"api/namespacelinalg/#typedef-scalar_t","title":"typedef scalar_t","text":"<pre><code>using linalg::scalar_t = typedef typename detail::scalar_type&lt;A&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg/#enum-z_range","title":"enum z_range","text":"<pre><code>enum linalg::z_range {\n    neg_one_to_one,\n    zero_to_one\n};\n</code></pre>"},{"location":"api/namespacelinalg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacelinalg/#variable-identity","title":"variable identity","text":"<pre><code>constexpr identity_t linalg::identity;\n</code></pre>"},{"location":"api/namespacelinalg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg/#function-abs","title":"function abs","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_abs, A &gt; linalg::abs (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-acos","title":"function acos","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_acos, A &gt; linalg::acos (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 1, 1 &gt; linalg::adjugate (\n    const mat&lt; T, 1, 1 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_1","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 2, 2 &gt; linalg::adjugate (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_2","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 3, 3 &gt; linalg::adjugate (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-adjugate_3","title":"function adjugate","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 4, 4 &gt; linalg::adjugate (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-all","title":"function all","text":"<pre><code>template&lt;class A&gt;\nconstexpr bool linalg::all (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-angle","title":"function angle","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::angle (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-any","title":"function any","text":"<pre><code>template&lt;class A&gt;\nconstexpr bool linalg::any (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-apply","title":"function apply","text":"<pre><code>template&lt;class F, class... A&gt;\nconstexpr apply_t&lt; F, A... &gt; linalg::apply (\n    F func,\n    const A &amp;... args\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-argmax","title":"function argmax","text":"<pre><code>template&lt;class T, int M&gt;\nint linalg::argmax (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-argmin","title":"function argmin","text":"<pre><code>template&lt;class T, int M&gt;\nint linalg::argmin (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-asin","title":"function asin","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_asin, A &gt; linalg::asin (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-atan","title":"function atan","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_atan, A &gt; linalg::atan (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-atan2","title":"function atan2","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_atan2, A, B &gt; linalg::atan2 (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin","title":"function begin","text":"<pre><code>template&lt;class T, int M&gt;\nT * linalg::begin (\n    vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_1","title":"function begin","text":"<pre><code>template&lt;class T, int M&gt;\nconst T * linalg::begin (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_2","title":"function begin","text":"<pre><code>template&lt;class T, int M, int N&gt;\nvec&lt; T, M &gt; * linalg::begin (\n    mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-begin_3","title":"function begin","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconst vec&lt; T, M &gt; * linalg::begin (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-ceil","title":"function ceil","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_ceil, A &gt; linalg::ceil (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-clamp","title":"function clamp","text":"<pre><code>template&lt;class X, class L, class H&gt;\nconstexpr apply_t&lt; detail::clamp, X, L, H &gt; linalg::clamp (\n    const X &amp; x,\n    const L &amp; l,\n    const H &amp; h\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-comatrix","title":"function comatrix","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr mat&lt; T, N, N &gt; linalg::comatrix (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-compare","title":"function compare","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr detail::any_compare&lt; A, B &gt;::type linalg::compare (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-copysign","title":"function copysign","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_copysign, A, B &gt; linalg::copysign (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cos","title":"function cos","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_cos, A &gt; linalg::cos (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cosh","title":"function cosh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_cosh, A &gt; linalg::cosh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::cross (\n    const vec&lt; T, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_1","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::cross (\n    T a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_2","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::cross (\n    const vec&lt; T, 2 &gt; &amp; a,\n    T b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-cross_3","title":"function cross","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::cross (\n    const vec&lt; T, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 1, 1 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_1","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_2","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-determinant_3","title":"function determinant","text":"<pre><code>template&lt;class T&gt;\nconstexpr T linalg::determinant (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 1 &gt; linalg::diagonal (\n    const mat&lt; T, 1, 1 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_1","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 2 &gt; linalg::diagonal (\n    const mat&lt; T, 2, 2 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_2","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::diagonal (\n    const mat&lt; T, 3, 3 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-diagonal_3","title":"function diagonal","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::diagonal (\n    const mat&lt; T, 4, 4 &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-distance","title":"function distance","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::distance (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-distance2","title":"function distance2","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::distance2 (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-dot","title":"function dot","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::dot (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end","title":"function end","text":"<pre><code>template&lt;class T, int M&gt;\nT * linalg::end (\n    vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_1","title":"function end","text":"<pre><code>template&lt;class T, int M&gt;\nconst T * linalg::end (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_2","title":"function end","text":"<pre><code>template&lt;class T, int M, int N&gt;\nvec&lt; T, M &gt; * linalg::end (\n    mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-end_3","title":"function end","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconst vec&lt; T, M &gt; * linalg::end (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-equal","title":"function equal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_eq, A, B &gt; linalg::equal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-exp","title":"function exp","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_exp, A &gt; linalg::exp (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-floor","title":"function floor","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_floor, A &gt; linalg::floor (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fmod","title":"function fmod","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_fmod, A, B &gt; linalg::fmod (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_1","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_2","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_3","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const vec&lt; B, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_4","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_5","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_6","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-fold_7","title":"function fold","text":"<pre><code>template&lt;class F, class A, class B, int M&gt;\nconstexpr A linalg::fold (\n    F f,\n    A a,\n    const mat&lt; B, M, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-frustum_matrix","title":"function frustum_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::frustum_matrix (\n    T x0,\n    T x1,\n    T y0,\n    T y1,\n    T n,\n    T f,\n    fwd_axis a=neg_z,\n    z_range z=neg_one_to_one\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-gequal","title":"function gequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_ge, A, B &gt; linalg::gequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-greater","title":"function greater","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_gt, A, B &gt; linalg::greater (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-inverse","title":"function inverse","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr mat&lt; T, N, N &gt; linalg::inverse (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-length","title":"function length","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::length (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-length2","title":"function length2","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr T linalg::length2 (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-lequal","title":"function lequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_le, A, B &gt; linalg::lequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-lerp","title":"function lerp","text":"<pre><code>template&lt;class A, class B, class T&gt;\nconstexpr apply_t&lt; detail::lerp, A, B, T &gt; linalg::lerp (\n    const A &amp; a,\n    const B &amp; b,\n    const T &amp; t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-less","title":"function less","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_lt, A, B &gt; linalg::less (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-log","title":"function log","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_log, A &gt; linalg::log (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-log10","title":"function log10","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_log10, A &gt; linalg::log10 (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-map","title":"function map","text":"<pre><code>template&lt;class A, class F&gt;\nconstexpr apply_t&lt; F, A &gt; linalg::map (\n    const A &amp; a,\n    F func\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-max","title":"function max","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::max, A, B &gt; linalg::max (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-maxelem","title":"function maxelem","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::maxelem (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-min","title":"function min","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::min, A, B &gt; linalg::min (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-minelem","title":"function minelem","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::minelem (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 1 &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_1","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_2","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_3","title":"function mul","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_4","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_5","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_6","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_7","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_8","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const vec&lt; T, P &gt; &amp; c\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_9","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q&gt;\nconstexpr mat&lt; T, M, Q &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_10","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q&gt;\nconstexpr vec&lt; T, M &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c,\n    const vec&lt; T, Q &gt; &amp; d\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-mul_11","title":"function mul","text":"<pre><code>template&lt;class T, int M, int N, int P, int Q, int R&gt;\nconstexpr mat&lt; T, M, R &gt; linalg::mul (\n    const mat&lt; T, M, N &gt; &amp; a,\n    const mat&lt; T, N, P &gt; &amp; b,\n    const mat&lt; T, P, Q &gt; &amp; c,\n    const mat&lt; T, Q, R &gt; &amp; d\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-nequal","title":"function nequal","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_ne, A, B &gt; linalg::nequal (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-nlerp","title":"function nlerp","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::nlerp (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-normalize","title":"function normalize","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::normalize (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator","title":"function operator!","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_not, A &gt; linalg::operator! (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_1","title":"function operator!=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator!= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_2","title":"function operator%","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_mod, A, B &gt; linalg::operator% (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_3","title":"function operator%=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator%= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_4","title":"function operator&amp;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_int, A, B &gt; linalg::operator&amp; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_5","title":"function operator&amp;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&amp;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_6","title":"function operator*","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_mul, A, B &gt; linalg::operator* (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_7","title":"function operator*=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator*= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_8","title":"function operator+","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_pos, A &gt; linalg::operator+ (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_9","title":"function operator+","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_add, A, B &gt; linalg::operator+ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_10","title":"function operator+=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator+= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-","title":"function operator-","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_neg, A &gt; linalg::operator- (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-_1","title":"function operator-","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_sub, A, B &gt; linalg::operator- (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator-_2","title":"function operator-=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator-= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_11","title":"function operator/","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_div, A, B &gt; linalg::operator/ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_12","title":"function operator/=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator/= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_13","title":"function operator&lt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&lt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_14","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_lsh, A, B &gt; linalg::operator&lt;&lt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_15","title":"function operator&lt;&lt;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&lt;&lt;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_16","title":"function operator&lt;=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator&lt;= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_17","title":"function operator==","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator== (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_18","title":"function operator&gt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&gt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_19","title":"function operator&gt;=","text":"<pre><code>template&lt;class A, class B&gt;\nvirtual constexpr auto linalg::operator&gt;= (\n    const A &amp; a,\n    const B &amp; b\n) = 0\n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_20","title":"function operator&gt;&gt;","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_rsh, A, B &gt; linalg::operator&gt;&gt; (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_21","title":"function operator&gt;&gt;=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator&gt;&gt;= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_22","title":"function operator^","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_xor, A, B &gt; linalg::operator^ (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_23","title":"function operator^=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator^= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_24","title":"function operator|","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr apply_t&lt; detail::op_un, A, B &gt; linalg::operator| (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_25","title":"function operator|=","text":"<pre><code>template&lt;class A, class B&gt;\nconstexpr auto linalg::operator|= (\n    A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-operator_26","title":"function operator~","text":"<pre><code>template&lt;class A&gt;\nconstexpr apply_t&lt; detail::op_cmp, A &gt; linalg::operator~ (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_1","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_2","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-outerprod_3","title":"function outerprod","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::outerprod (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-perspective_matrix","title":"function perspective_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::perspective_matrix (\n    T fovy,\n    T aspect,\n    T n,\n    T f,\n    fwd_axis a=neg_z,\n    z_range z=neg_one_to_one\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-pose_matrix","title":"function pose_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::pose_matrix (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const vec&lt; T, 3 &gt; &amp; p\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-pow","title":"function pow","text":"<pre><code>template&lt;class A, class B&gt;\napply_t&lt; detail::std_pow, A, B &gt; linalg::pow (\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-product","title":"function product","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::product (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qangle","title":"function qangle","text":"<pre><code>template&lt;class T&gt;\nT linalg::qangle (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qaxis","title":"function qaxis","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 3 &gt; linalg::qaxis (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qconj","title":"function qconj","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qconj (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qexp","title":"function qexp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qexp (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qinv","title":"function qinv","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qinv (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qlog","title":"function qlog","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qlog (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmat","title":"function qmat","text":"<pre><code>template&lt;class T&gt;\nconstexpr mat&lt; T, 3, 3 &gt; linalg::qmat (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmul","title":"function qmul","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qmul (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qmul_1","title":"function qmul","text":"<pre><code>template&lt;class T, class... R&gt;\nconstexpr vec&lt; T, 4 &gt; linalg::qmul (\n    const vec&lt; T, 4 &gt; &amp; a,\n    R... r\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qnlerp","title":"function qnlerp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qnlerp (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qpow","title":"function qpow","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qpow (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const T &amp; p\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qrot","title":"function qrot","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qrot (\n    const vec&lt; T, 4 &gt; &amp; q,\n    const vec&lt; T, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qslerp","title":"function qslerp","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::qslerp (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qxdir","title":"function qxdir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qxdir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qydir","title":"function qydir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qydir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-qzdir","title":"function qzdir","text":"<pre><code>template&lt;class T&gt;\nconstexpr vec&lt; T, 3 &gt; linalg::qzdir (\n    const vec&lt; T, 4 &gt; &amp; q\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rot","title":"function rot","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 2 &gt; linalg::rot (\n    T a,\n    const vec&lt; T, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_matrix","title":"function rotation_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::rotation_matrix (\n    const vec&lt; T, 4 &gt; &amp; rotation\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_quat","title":"function rotation_quat","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::rotation_quat (\n    const vec&lt; T, 3 &gt; &amp; axis,\n    T angle\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-rotation_quat_1","title":"function rotation_quat","text":"<pre><code>template&lt;class T&gt;\nvec&lt; T, 4 &gt; linalg::rotation_quat (\n    const mat&lt; T, 3, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-round","title":"function round","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_round, A &gt; linalg::round (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-scaling_matrix","title":"function scaling_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::scaling_matrix (\n    const vec&lt; T, 3 &gt; &amp; scaling\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-select","title":"function select","text":"<pre><code>template&lt;class P, class A, class B&gt;\nconstexpr apply_t&lt; detail::select, P, A, B &gt; linalg::select (\n    const P &amp; p,\n    const A &amp; a,\n    const B &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sin","title":"function sin","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sin, A &gt; linalg::sin (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sinh","title":"function sinh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sinh, A &gt; linalg::sinh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-slerp","title":"function slerp","text":"<pre><code>template&lt;class T, int M&gt;\nvec&lt; T, M &gt; linalg::slerp (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b,\n    T t\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sqrt","title":"function sqrt","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_sqrt, A &gt; linalg::sqrt (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-submat","title":"function submat","text":"<pre><code>template&lt;int I0, int J0, int I1, int J1, class T, int M, int N&gt;\nconstexpr mat&lt; T, I1-I0, J1-J0 &gt; linalg::submat (\n    const mat&lt; T, M, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-subvec","title":"function subvec","text":"<pre><code>template&lt;int I0, int I1, class T, int M&gt;\nconstexpr vec&lt; T, I1-I0 &gt; linalg::subvec (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-sum","title":"function sum","text":"<pre><code>template&lt;class A&gt;\nconstexpr scalar_t&lt; A &gt; linalg::sum (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-swizzle","title":"function swizzle","text":"<pre><code>template&lt;int... I, class T, int M&gt;\nconstexpr vec&lt; T, sizeof...(I)&gt; linalg::swizzle (\n    const vec&lt; T, M &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-tan","title":"function tan","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_tan, A &gt; linalg::tan (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-tanh","title":"function tanh","text":"<pre><code>template&lt;class A&gt;\napply_t&lt; detail::std_tanh, A &gt; linalg::tanh (\n    const A &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-trace","title":"function trace","text":"<pre><code>template&lt;class T, int N&gt;\nconstexpr T linalg::trace (\n    const mat&lt; T, N, N &gt; &amp; a\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-translation_matrix","title":"function translation_matrix","text":"<pre><code>template&lt;class T&gt;\nmat&lt; T, 4, 4 &gt; linalg::translation_matrix (\n    const vec&lt; T, 3 &gt; &amp; translation\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 1 &gt; linalg::transpose (\n    const mat&lt; T, 1, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_1","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 2 &gt; linalg::transpose (\n    const mat&lt; T, 2, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_2","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 3 &gt; linalg::transpose (\n    const mat&lt; T, 3, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-transpose_3","title":"function transpose","text":"<pre><code>template&lt;class T, int M&gt;\nconstexpr mat&lt; T, M, 4 &gt; linalg::transpose (\n    const mat&lt; T, 4, M &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-uangle","title":"function uangle","text":"<pre><code>template&lt;class T, int M&gt;\nT linalg::uangle (\n    const vec&lt; T, M &gt; &amp; a,\n    const vec&lt; T, M &gt; &amp; b\n) \n</code></pre>"},{"location":"api/namespacelinalg/#function-zip","title":"function zip","text":"<pre><code>template&lt;class A, class B, class F&gt;\nconstexpr apply_t&lt; F, A, B &gt; linalg::zip (\n    const A &amp; a,\n    const B &amp; b,\n    F func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1aliases/","title":"Namespace linalg::aliases","text":"<p>Namespace List &gt; linalg &gt; aliases</p>"},{"location":"api/namespacelinalg_1_1aliases/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; bool, 1 &gt; bool1 typedef mat&lt; bool, 1, 1 &gt; bool1x1 typedef mat&lt; bool, 1, 2 &gt; bool1x2 typedef mat&lt; bool, 1, 3 &gt; bool1x3 typedef mat&lt; bool, 1, 4 &gt; bool1x4 typedef vec&lt; bool, 2 &gt; bool2 typedef mat&lt; bool, 2, 1 &gt; bool2x1 typedef mat&lt; bool, 2, 2 &gt; bool2x2 typedef mat&lt; bool, 2, 3 &gt; bool2x3 typedef mat&lt; bool, 2, 4 &gt; bool2x4 typedef vec&lt; bool, 3 &gt; bool3 typedef mat&lt; bool, 3, 1 &gt; bool3x1 typedef mat&lt; bool, 3, 2 &gt; bool3x2 typedef mat&lt; bool, 3, 3 &gt; bool3x3 typedef mat&lt; bool, 3, 4 &gt; bool3x4 typedef vec&lt; bool, 4 &gt; bool4 typedef mat&lt; bool, 4, 1 &gt; bool4x1 typedef mat&lt; bool, 4, 2 &gt; bool4x2 typedef mat&lt; bool, 4, 3 &gt; bool4x3 typedef mat&lt; bool, 4, 4 &gt; bool4x4 typedef vec&lt; uint8_t, 1 &gt; byte1 typedef vec&lt; uint8_t, 2 &gt; byte2 typedef vec&lt; uint8_t, 3 &gt; byte3 typedef vec&lt; uint8_t, 4 &gt; byte4 typedef vec&lt; double, 1 &gt; double1 typedef mat&lt; double, 1, 1 &gt; double1x1 typedef mat&lt; double, 1, 2 &gt; double1x2 typedef mat&lt; double, 1, 3 &gt; double1x3 typedef mat&lt; double, 1, 4 &gt; double1x4 typedef vec&lt; double, 2 &gt; double2 typedef mat&lt; double, 2, 1 &gt; double2x1 typedef mat&lt; double, 2, 2 &gt; double2x2 typedef mat&lt; double, 2, 3 &gt; double2x3 typedef mat&lt; double, 2, 4 &gt; double2x4 typedef vec&lt; double, 3 &gt; double3 typedef mat&lt; double, 3, 1 &gt; double3x1 typedef mat&lt; double, 3, 2 &gt; double3x2 typedef mat&lt; double, 3, 3 &gt; double3x3 typedef mat&lt; double, 3, 4 &gt; double3x4 typedef vec&lt; double, 4 &gt; double4 typedef mat&lt; double, 4, 1 &gt; double4x1 typedef mat&lt; double, 4, 2 &gt; double4x2 typedef mat&lt; double, 4, 3 &gt; double4x3 typedef mat&lt; double, 4, 4 &gt; double4x4 typedef vec&lt; float, 1 &gt; float1 typedef mat&lt; float, 1, 1 &gt; float1x1 typedef mat&lt; float, 1, 2 &gt; float1x2 typedef mat&lt; float, 1, 3 &gt; float1x3 typedef mat&lt; float, 1, 4 &gt; float1x4 typedef vec&lt; float, 2 &gt; float2 typedef mat&lt; float, 2, 1 &gt; float2x1 typedef mat&lt; float, 2, 2 &gt; float2x2 typedef mat&lt; float, 2, 3 &gt; float2x3 typedef mat&lt; float, 2, 4 &gt; float2x4 typedef vec&lt; float, 3 &gt; float3 typedef mat&lt; float, 3, 1 &gt; float3x1 typedef mat&lt; float, 3, 2 &gt; float3x2 typedef mat&lt; float, 3, 3 &gt; float3x3 typedef mat&lt; float, 3, 4 &gt; float3x4 typedef vec&lt; float, 4 &gt; float4 typedef mat&lt; float, 4, 1 &gt; float4x1 typedef mat&lt; float, 4, 2 &gt; float4x2 typedef mat&lt; float, 4, 3 &gt; float4x3 typedef mat&lt; float, 4, 4 &gt; float4x4 typedef vec&lt; int, 1 &gt; int1 typedef mat&lt; int, 1, 1 &gt; int1x1 typedef mat&lt; int, 1, 2 &gt; int1x2 typedef mat&lt; int, 1, 3 &gt; int1x3 typedef mat&lt; int, 1, 4 &gt; int1x4 typedef vec&lt; int, 2 &gt; int2 typedef mat&lt; int, 2, 1 &gt; int2x1 typedef mat&lt; int, 2, 2 &gt; int2x2 typedef mat&lt; int, 2, 3 &gt; int2x3 typedef mat&lt; int, 2, 4 &gt; int2x4 typedef vec&lt; int, 3 &gt; int3 typedef mat&lt; int, 3, 1 &gt; int3x1 typedef mat&lt; int, 3, 2 &gt; int3x2 typedef mat&lt; int, 3, 3 &gt; int3x3 typedef mat&lt; int, 3, 4 &gt; int3x4 typedef vec&lt; int, 4 &gt; int4 typedef mat&lt; int, 4, 1 &gt; int4x1 typedef mat&lt; int, 4, 2 &gt; int4x2 typedef mat&lt; int, 4, 3 &gt; int4x3 typedef mat&lt; int, 4, 4 &gt; int4x4 typedef vec&lt; int16_t, 1 &gt; short1 typedef vec&lt; int16_t, 2 &gt; short2 typedef vec&lt; int16_t, 3 &gt; short3 typedef vec&lt; int16_t, 4 &gt; short4 typedef vec&lt; unsigned, 1 &gt; uint1 typedef vec&lt; unsigned, 2 &gt; uint2 typedef vec&lt; unsigned, 3 &gt; uint3 typedef vec&lt; unsigned, 4 &gt; uint4 typedef vec&lt; uint16_t, 1 &gt; ushort1 typedef vec&lt; uint16_t, 2 &gt; ushort2 typedef vec&lt; uint16_t, 3 &gt; ushort3 typedef vec&lt; uint16_t, 4 &gt; ushort4"},{"location":"api/namespacelinalg_1_1aliases/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1","title":"typedef bool1","text":"<pre><code>typedef vec&lt;bool,1&gt; linalg::aliases::bool1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x1","title":"typedef bool1x1","text":"<pre><code>typedef mat&lt;bool,1,1&gt; linalg::aliases::bool1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x2","title":"typedef bool1x2","text":"<pre><code>typedef mat&lt;bool,1,2&gt; linalg::aliases::bool1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x3","title":"typedef bool1x3","text":"<pre><code>typedef mat&lt;bool,1,3&gt; linalg::aliases::bool1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool1x4","title":"typedef bool1x4","text":"<pre><code>typedef mat&lt;bool,1,4&gt; linalg::aliases::bool1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2","title":"typedef bool2","text":"<pre><code>typedef vec&lt;bool,2&gt; linalg::aliases::bool2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x1","title":"typedef bool2x1","text":"<pre><code>typedef mat&lt;bool,2,1&gt; linalg::aliases::bool2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x2","title":"typedef bool2x2","text":"<pre><code>typedef mat&lt;bool,2,2&gt; linalg::aliases::bool2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x3","title":"typedef bool2x3","text":"<pre><code>typedef mat&lt;bool,2,3&gt; linalg::aliases::bool2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool2x4","title":"typedef bool2x4","text":"<pre><code>typedef mat&lt;bool,2,4&gt; linalg::aliases::bool2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3","title":"typedef bool3","text":"<pre><code>typedef vec&lt;bool,3&gt; linalg::aliases::bool3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x1","title":"typedef bool3x1","text":"<pre><code>typedef mat&lt;bool,3,1&gt; linalg::aliases::bool3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x2","title":"typedef bool3x2","text":"<pre><code>typedef mat&lt;bool,3,2&gt; linalg::aliases::bool3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x3","title":"typedef bool3x3","text":"<pre><code>typedef mat&lt;bool,3,3&gt; linalg::aliases::bool3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool3x4","title":"typedef bool3x4","text":"<pre><code>typedef mat&lt;bool,3,4&gt; linalg::aliases::bool3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4","title":"typedef bool4","text":"<pre><code>typedef vec&lt;bool,4&gt; linalg::aliases::bool4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x1","title":"typedef bool4x1","text":"<pre><code>typedef mat&lt;bool,4,1&gt; linalg::aliases::bool4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x2","title":"typedef bool4x2","text":"<pre><code>typedef mat&lt;bool,4,2&gt; linalg::aliases::bool4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x3","title":"typedef bool4x3","text":"<pre><code>typedef mat&lt;bool,4,3&gt; linalg::aliases::bool4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-bool4x4","title":"typedef bool4x4","text":"<pre><code>typedef mat&lt;bool,4,4&gt; linalg::aliases::bool4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte1","title":"typedef byte1","text":"<pre><code>typedef vec&lt;uint8_t,1&gt; linalg::aliases::byte1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte2","title":"typedef byte2","text":"<pre><code>typedef vec&lt;uint8_t,2&gt; linalg::aliases::byte2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte3","title":"typedef byte3","text":"<pre><code>typedef vec&lt;uint8_t,3&gt; linalg::aliases::byte3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-byte4","title":"typedef byte4","text":"<pre><code>typedef vec&lt;uint8_t,4&gt; linalg::aliases::byte4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1","title":"typedef double1","text":"<pre><code>typedef vec&lt;double,1&gt; linalg::aliases::double1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x1","title":"typedef double1x1","text":"<pre><code>typedef mat&lt;double,1,1&gt; linalg::aliases::double1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x2","title":"typedef double1x2","text":"<pre><code>typedef mat&lt;double,1,2&gt; linalg::aliases::double1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x3","title":"typedef double1x3","text":"<pre><code>typedef mat&lt;double,1,3&gt; linalg::aliases::double1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double1x4","title":"typedef double1x4","text":"<pre><code>typedef mat&lt;double,1,4&gt; linalg::aliases::double1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2","title":"typedef double2","text":"<pre><code>typedef vec&lt;double,2&gt; linalg::aliases::double2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x1","title":"typedef double2x1","text":"<pre><code>typedef mat&lt;double,2,1&gt; linalg::aliases::double2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x2","title":"typedef double2x2","text":"<pre><code>typedef mat&lt;double,2,2&gt; linalg::aliases::double2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x3","title":"typedef double2x3","text":"<pre><code>typedef mat&lt;double,2,3&gt; linalg::aliases::double2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double2x4","title":"typedef double2x4","text":"<pre><code>typedef mat&lt;double,2,4&gt; linalg::aliases::double2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3","title":"typedef double3","text":"<pre><code>typedef vec&lt;double,3&gt; linalg::aliases::double3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x1","title":"typedef double3x1","text":"<pre><code>typedef mat&lt;double,3,1&gt; linalg::aliases::double3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x2","title":"typedef double3x2","text":"<pre><code>typedef mat&lt;double,3,2&gt; linalg::aliases::double3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x3","title":"typedef double3x3","text":"<pre><code>typedef mat&lt;double,3,3&gt; linalg::aliases::double3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double3x4","title":"typedef double3x4","text":"<pre><code>typedef mat&lt;double,3,4&gt; linalg::aliases::double3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4","title":"typedef double4","text":"<pre><code>typedef vec&lt;double,4&gt; linalg::aliases::double4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x1","title":"typedef double4x1","text":"<pre><code>typedef mat&lt;double,4,1&gt; linalg::aliases::double4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x2","title":"typedef double4x2","text":"<pre><code>typedef mat&lt;double,4,2&gt; linalg::aliases::double4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x3","title":"typedef double4x3","text":"<pre><code>typedef mat&lt;double,4,3&gt; linalg::aliases::double4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-double4x4","title":"typedef double4x4","text":"<pre><code>typedef mat&lt;double,4,4&gt; linalg::aliases::double4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1","title":"typedef float1","text":"<pre><code>typedef vec&lt;float,1&gt; linalg::aliases::float1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x1","title":"typedef float1x1","text":"<pre><code>typedef mat&lt;float,1,1&gt; linalg::aliases::float1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x2","title":"typedef float1x2","text":"<pre><code>typedef mat&lt;float,1,2&gt; linalg::aliases::float1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x3","title":"typedef float1x3","text":"<pre><code>typedef mat&lt;float,1,3&gt; linalg::aliases::float1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float1x4","title":"typedef float1x4","text":"<pre><code>typedef mat&lt;float,1,4&gt; linalg::aliases::float1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2","title":"typedef float2","text":"<pre><code>typedef vec&lt;float,2&gt; linalg::aliases::float2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x1","title":"typedef float2x1","text":"<pre><code>typedef mat&lt;float,2,1&gt; linalg::aliases::float2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x2","title":"typedef float2x2","text":"<pre><code>typedef mat&lt;float,2,2&gt; linalg::aliases::float2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x3","title":"typedef float2x3","text":"<pre><code>typedef mat&lt;float,2,3&gt; linalg::aliases::float2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float2x4","title":"typedef float2x4","text":"<pre><code>typedef mat&lt;float,2,4&gt; linalg::aliases::float2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3","title":"typedef float3","text":"<pre><code>typedef vec&lt;float,3&gt; linalg::aliases::float3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x1","title":"typedef float3x1","text":"<pre><code>typedef mat&lt;float,3,1&gt; linalg::aliases::float3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x2","title":"typedef float3x2","text":"<pre><code>typedef mat&lt;float,3,2&gt; linalg::aliases::float3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x3","title":"typedef float3x3","text":"<pre><code>typedef mat&lt;float,3,3&gt; linalg::aliases::float3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float3x4","title":"typedef float3x4","text":"<pre><code>typedef mat&lt;float,3,4&gt; linalg::aliases::float3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4","title":"typedef float4","text":"<pre><code>typedef vec&lt;float,4&gt; linalg::aliases::float4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x1","title":"typedef float4x1","text":"<pre><code>typedef mat&lt;float,4,1&gt; linalg::aliases::float4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x2","title":"typedef float4x2","text":"<pre><code>typedef mat&lt;float,4,2&gt; linalg::aliases::float4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x3","title":"typedef float4x3","text":"<pre><code>typedef mat&lt;float,4,3&gt; linalg::aliases::float4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-float4x4","title":"typedef float4x4","text":"<pre><code>typedef mat&lt;float,4,4&gt; linalg::aliases::float4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1","title":"typedef int1","text":"<pre><code>typedef vec&lt;int,1&gt; linalg::aliases::int1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x1","title":"typedef int1x1","text":"<pre><code>typedef mat&lt;int,1,1&gt; linalg::aliases::int1x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x2","title":"typedef int1x2","text":"<pre><code>typedef mat&lt;int,1,2&gt; linalg::aliases::int1x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x3","title":"typedef int1x3","text":"<pre><code>typedef mat&lt;int,1,3&gt; linalg::aliases::int1x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int1x4","title":"typedef int1x4","text":"<pre><code>typedef mat&lt;int,1,4&gt; linalg::aliases::int1x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2","title":"typedef int2","text":"<pre><code>typedef vec&lt;int,2&gt; linalg::aliases::int2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x1","title":"typedef int2x1","text":"<pre><code>typedef mat&lt;int,2,1&gt; linalg::aliases::int2x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x2","title":"typedef int2x2","text":"<pre><code>typedef mat&lt;int,2,2&gt; linalg::aliases::int2x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x3","title":"typedef int2x3","text":"<pre><code>typedef mat&lt;int,2,3&gt; linalg::aliases::int2x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int2x4","title":"typedef int2x4","text":"<pre><code>typedef mat&lt;int,2,4&gt; linalg::aliases::int2x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3","title":"typedef int3","text":"<pre><code>typedef vec&lt;int,3&gt; linalg::aliases::int3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x1","title":"typedef int3x1","text":"<pre><code>typedef mat&lt;int,3,1&gt; linalg::aliases::int3x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x2","title":"typedef int3x2","text":"<pre><code>typedef mat&lt;int,3,2&gt; linalg::aliases::int3x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x3","title":"typedef int3x3","text":"<pre><code>typedef mat&lt;int,3,3&gt; linalg::aliases::int3x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int3x4","title":"typedef int3x4","text":"<pre><code>typedef mat&lt;int,3,4&gt; linalg::aliases::int3x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4","title":"typedef int4","text":"<pre><code>typedef vec&lt;int,4&gt; linalg::aliases::int4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x1","title":"typedef int4x1","text":"<pre><code>typedef mat&lt;int,4,1&gt; linalg::aliases::int4x1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x2","title":"typedef int4x2","text":"<pre><code>typedef mat&lt;int,4,2&gt; linalg::aliases::int4x2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x3","title":"typedef int4x3","text":"<pre><code>typedef mat&lt;int,4,3&gt; linalg::aliases::int4x3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-int4x4","title":"typedef int4x4","text":"<pre><code>typedef mat&lt;int,4,4&gt; linalg::aliases::int4x4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short1","title":"typedef short1","text":"<pre><code>typedef vec&lt;int16_t,1&gt; linalg::aliases::short1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short2","title":"typedef short2","text":"<pre><code>typedef vec&lt;int16_t,2&gt; linalg::aliases::short2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short3","title":"typedef short3","text":"<pre><code>typedef vec&lt;int16_t,3&gt; linalg::aliases::short3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-short4","title":"typedef short4","text":"<pre><code>typedef vec&lt;int16_t,4&gt; linalg::aliases::short4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint1","title":"typedef uint1","text":"<pre><code>typedef vec&lt;unsigned,1&gt; linalg::aliases::uint1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint2","title":"typedef uint2","text":"<pre><code>typedef vec&lt;unsigned,2&gt; linalg::aliases::uint2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint3","title":"typedef uint3","text":"<pre><code>typedef vec&lt;unsigned,3&gt; linalg::aliases::uint3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-uint4","title":"typedef uint4","text":"<pre><code>typedef vec&lt;unsigned,4&gt; linalg::aliases::uint4;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort1","title":"typedef ushort1","text":"<pre><code>typedef vec&lt;uint16_t,1&gt; linalg::aliases::ushort1;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort2","title":"typedef ushort2","text":"<pre><code>typedef vec&lt;uint16_t,2&gt; linalg::aliases::ushort2;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort3","title":"typedef ushort3","text":"<pre><code>typedef vec&lt;uint16_t,3&gt; linalg::aliases::ushort3;\n</code></pre>"},{"location":"api/namespacelinalg_1_1aliases/#typedef-ushort4","title":"typedef ushort4","text":"<pre><code>typedef vec&lt;uint16_t,4&gt; linalg::aliases::ushort4;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter/","title":"Struct linalg::converter","text":"<p>template &lt;class T, class U&gt;</p> <p>ClassList &gt; linalg &gt; converter</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 1, 1 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_011_00_011_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 1, 1 &gt; linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 2, 2 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_012_00_012_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 2, 2 &gt; linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 3, 3 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_013_00_013_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 3, 3 &gt; linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/","title":"Struct linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#public-functions","title":"Public Functions","text":"Type Name mat&lt; T, 4, 4 &gt; operator() (identity_t) const"},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01mat_3_01T_00_014_00_014_01_4_00_01identity__t_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline mat&lt; T, 4, 4 &gt; linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;::operator() (\n    identity_t\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 1 &gt; operator() (const vec&lt; T, 1 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 1 &gt; linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::operator() (\n    const vec&lt; T, 1 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 2 &gt; operator() (const vec&lt; T, 2 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 2 &gt; linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::operator() (\n    const vec&lt; T, 2 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 3 &gt; operator() (const vec&lt; T, 3 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 3 &gt; linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::operator() (\n    const vec&lt; T, 3 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/","title":"Struct linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; T, 4 &gt; operator() (const vec&lt; T, 4 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01std_1_1array_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::array&lt; T, 4 &gt; linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::operator() (\n    const vec&lt; T, 4 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 1 &gt; operator() (const std::array&lt; T, 1 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_011_01_4_00_01std_1_1array_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 1 &gt; linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;::operator() (\n    const std::array&lt; T, 1 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 2 &gt; operator() (const std::array&lt; T, 2 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_012_01_4_00_01std_1_1array_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 2 &gt; linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;::operator() (\n    const std::array&lt; T, 2 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 3 &gt; operator() (const std::array&lt; T, 3 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_013_01_4_00_01std_1_1array_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 3 &gt; linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;::operator() (\n    const std::array&lt; T, 3 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/","title":"Struct linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name vec&lt; T, 4 &gt; operator() (const std::array&lt; T, 4 &gt; &amp; a) const"},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1converter_3_01vec_3_01T_00_014_01_4_00_01std_1_1array_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline vec&lt; T, 4 &gt; linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;::operator() (\n    const std::array&lt; T, 4 &gt; &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1detail/","title":"Namespace linalg::detail","text":"<p>Namespace List &gt; linalg &gt; detail</p>"},{"location":"api/namespacelinalg_1_1detail/#classes","title":"Classes","text":"Type Name struct any_compare &lt;class A, class B&gt; struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct apply &lt;class F, class Void, T&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; &lt;class F, M, N, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; &lt;class F, M, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; &lt;class F, A&gt; struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct clamp struct empty struct getter &lt;I&gt; struct getter&lt; 0 &gt; &lt;&gt; struct getter&lt; 1 &gt; &lt;&gt; struct getter&lt; 2 &gt; &lt;&gt; struct getter&lt; 3 &gt; &lt;&gt; struct lerp struct make_seq_impl &lt;A, N&gt; struct make_seq_impl&lt; A, 0 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 1 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 2 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 3 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 4 &gt; &lt;A&gt; struct max struct min struct op_add struct op_and struct op_cmp struct op_div struct op_eq struct op_ge struct op_gt struct op_int struct op_le struct op_lsh struct op_lt struct op_mod struct op_mul struct op_ne struct op_neg struct op_not struct op_or struct op_pos struct op_rsh struct op_sub struct op_un struct op_xor struct ord &lt;class T&gt; struct scalar_type &lt;class A&gt; struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; &lt;class T, M, N&gt; struct scalar_type&lt; vec&lt; T, M &gt; &gt; &lt;class T, M&gt; struct scalars &lt;T&gt; struct scalars&lt; T, U... &gt; &lt;class T, U&gt; struct scalars&lt;&gt; &lt;&gt; struct select struct seq &lt;I&gt; struct std_abs struct std_acos struct std_asin struct std_atan struct std_atan2 struct std_ceil struct std_copysign struct std_cos struct std_cosh struct std_exp struct std_floor struct std_fmod struct std_log struct std_log10 struct std_pow struct std_round struct std_sin struct std_sinh struct std_sqrt struct std_tan struct std_tanh"},{"location":"api/namespacelinalg_1_1detail/#public-types","title":"Public Types","text":"Type Name typedef typename std::enable_if&lt;!std::is_same&lt; T, U &gt;::value, decltype(converter&lt; T, U &gt;{}(std::declval&lt; U &gt;()))&gt;::type conv_t typedef typename make_seq_impl&lt; A, B-A &gt;::type make_seq typedef decltype(std::declval&lt; F &gt;()(std::declval&lt; T &gt;()...)) ret_t typedef typename scalars&lt; T... &gt;::type scalars_t"},{"location":"api/namespacelinalg_1_1detail/#public-functions","title":"Public Functions","text":"Type Name constexpr bool operator!= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&lt; (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&lt;= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator== (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&gt; (const ord&lt; T &gt; &amp; o, std::nullptr_t)  constexpr bool operator&gt;= (const ord&lt; T &gt; &amp; o, std::nullptr_t)  vec&lt; T, sizeof...(I)&gt; constexpr swizzle (const vec&lt; T, M &gt; &amp; v, seq&lt; I... &gt; i)  mat&lt; T, sizeof...(I), sizeof...(J)&gt; constexpr swizzle (const mat&lt; T, M, N &gt; &amp; m, seq&lt; I... &gt; i, seq&lt; J... &gt; j)"},{"location":"api/namespacelinalg_1_1detail/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacelinalg_1_1detail/#typedef-conv_t","title":"typedef conv_t","text":"<pre><code>using linalg::detail::conv_t = typedef typename std::enable_if&lt;!std::is_same&lt;T,U&gt;::value, decltype(converter&lt;T,U&gt;{}(std::declval&lt;U&gt;()))&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-make_seq","title":"typedef make_seq","text":"<pre><code>using linalg::detail::make_seq = typedef typename make_seq_impl&lt;A,B-A&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-ret_t","title":"typedef ret_t","text":"<pre><code>using linalg::detail::ret_t = typedef decltype(std::declval&lt;F&gt;()(std::declval&lt;T&gt;()...));\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#typedef-scalars_t","title":"typedef scalars_t","text":"<pre><code>using linalg::detail::scalars_t = typedef typename scalars&lt;T...&gt;::type;\n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg_1_1detail/#function-operator","title":"function operator!=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator!= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_1","title":"function operator&lt;","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&lt; (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_2","title":"function operator&lt;=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&lt;= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_3","title":"function operator==","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator== (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_4","title":"function operator&gt;","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&gt; (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-operator_5","title":"function operator&gt;=","text":"<pre><code>template&lt;class T&gt;\nconstexpr bool linalg::detail::operator&gt;= (\n    const ord&lt; T &gt; &amp; o,\n    std::nullptr_t\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-swizzle","title":"function swizzle","text":"<pre><code>template&lt;class T, int M, int... I&gt;\nvec&lt; T, sizeof...(I)&gt; constexpr linalg::detail::swizzle (\n    const vec&lt; T, M &gt; &amp; v,\n    seq&lt; I... &gt; i\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1detail/#function-swizzle_1","title":"function swizzle","text":"<pre><code>template&lt;class T, int M, int N, int... I, int... J&gt;\nmat&lt; T, sizeof...(I), sizeof...(J)&gt; constexpr linalg::detail::swizzle (\n    const mat&lt; T, M, N &gt; &amp; m,\n    seq&lt; I... &gt; i,\n    seq&lt; J... &gt; j\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare/","title":"Struct linalg::detail::any_compare","text":"<p>template &lt;class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 1 &gt; &amp; a, const mat&lt; T, M, 1 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_011_01_4_00_01mat_3_01T_00_01M_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;::operator() (\n    const mat&lt; T, M, 1 &gt; &amp; a,\n    const mat&lt; T, M, 1 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 2 &gt; &amp; a, const mat&lt; T, M, 2 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_012_01_4_00_01mat_3_01T_00_01M_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;::operator() (\n    const mat&lt; T, M, 2 &gt; &amp; a,\n    const mat&lt; T, M, 2 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 3 &gt; &amp; a, const mat&lt; T, M, 3 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_013_01_4_00_01mat_3_01T_00_01M_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;::operator() (\n    const mat&lt; T, M, 3 &gt; &amp; a,\n    const mat&lt; T, M, 3 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const mat&lt; T, M, 4 &gt; &amp; a, const mat&lt; T, M, 4 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01mat_3_01T_00_01M_00_014_01_4_00_01mat_3_01T_00_01M_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;::operator() (\n    const mat&lt; T, M, 4 &gt; &amp; a,\n    const mat&lt; T, M, 4 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 1 &gt; &amp; a, const vec&lt; T, 1 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_011_01_4_00_01vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;::operator() (\n    const vec&lt; T, 1 &gt; &amp; a,\n    const vec&lt; T, 1 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 2 &gt; &amp; a, const vec&lt; T, 2 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_012_01_4_00_01vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;::operator() (\n    const vec&lt; T, 2 &gt; &amp; a,\n    const vec&lt; T, 2 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 3 &gt; &amp; a, const vec&lt; T, 3 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_013_01_4_00_01vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;::operator() (\n    const vec&lt; T, 3 &gt; &amp; a,\n    const vec&lt; T, 3 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/","title":"Struct linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef ord&lt; T &gt; type"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr ord&lt; T &gt; operator() (const vec&lt; T, 4 &gt; &amp; a, const vec&lt; T, 4 &gt; &amp; b) const"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::type =  ord&lt;T&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1any__compare_3_01vec_3_01T_00_014_01_4_00_01vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr ord&lt; T &gt; linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;::operator() (\n    const vec&lt; T, 4 &gt; &amp; a,\n    const vec&lt; T, 4 &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply/","title":"Struct linalg::detail::apply","text":"<p>template &lt;class F, class Void, class... T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#enum-apply-f-scalars_t-mat-a-m-n","title":"enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A &gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a, const mat&lt; B, M, N &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#enum-apply-f-scalars_t-mat-a-m-n-mat-b-m-n","title":"enum apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_04aeeb67cdd8f651c27a7fc8b3e5f43ca/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a,\n    const mat&lt; B, M, N &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#enum-apply-f-scalars_t-vec-a-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#enum-apply-f-scalars_t-vec-a-m-vec-b-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec_3_01B_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#enum-apply-f-scalars_t-vec-a-m-vec-b-m-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01_4_00_01vec_3_01A_00_01M_01_4_00_01vec8c04718abcb6bd428e3e5069d21cdb08/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, A a, const mat&lt; B, M, N &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#enum-apply-f-scalars_t-a-a-mat-b-m-n","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01mat_3_01B_00_01M_00_01N_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    A a,\n    const mat&lt; B, M, N &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#enum-apply-f-scalars_t-a-a-vec-b-m","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#enum-apply-f-scalars_t-a-a-vec-b-m-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_01_4_00_01A_00_01vec_3_01B_00_01M_01c023422bf2470de8975928af5a32a9fb/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, B b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#enum-apply-f-scalars_t-a-b-a-b-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01B_01_4_00_01A_00_01B_00_01vec_3_01C_00_01M_01_4_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    B b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, A a, const vec&lt; B, M &gt; &amp; b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#enum-apply-f-scalars_t-a-c-a-vec-b-m-c","title":"enum apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_00_01C_01_4_00_01A_00_01vec_3_01B_00_01M_01_4_00_01C_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    A a,\n    const vec&lt; B, M &gt; &amp; b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;","text":"<p>template &lt;class F, class... A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; typedef ret_t&lt; F, A... &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt;&gt;, F f, A... a)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#enum-apply-f-scalars_t-a-a","title":"enum apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; {\n    size =0\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::type =  ret_t&lt;F,A...&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01A_8_8_8_01_4_00_01A_8_8_8_01_4/#function-impl","title":"function impl","text":"<pre><code>static inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;::impl (\n    seq&lt;&gt;,\n    F f,\n    A... a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;","text":"<p>template &lt;class F, int M, int N, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; typedef mat&lt; ret_t&lt; F, A, B &gt;, M, N &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; J... &gt;, F f, const mat&lt; A, M, N &gt; &amp; a, B b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#enum-apply-f-scalars_t-b-mat-a-m-n-b","title":"enum apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; {\n    size =N\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::type =  mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01mat_3_01A_00_01M_00_01N_01_4_00_01B_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... J&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;::impl (\n    seq&lt; J... &gt;,\n    F f,\n    const mat&lt; A, M, N &gt; &amp; a,\n    B b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;","text":"<p>template &lt;class F, int M, class A, class B&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; typedef vec&lt; ret_t&lt; F, A, B &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#enum-apply-f-scalars_t-b-vec-a-m-b","title":"enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::type =  vec&lt;ret_t&lt;F,A,B &gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b, const vec&lt; C, M &gt; &amp; c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#enum-apply-f-scalars_t-b-vec-a-m-b-vec-c-m","title":"enum apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_01_4_00_01vec_3_01A_00_01M_01_4_00_07b0a794b12063cc93872746bb0aa39b1/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b,\n    const vec&lt; C, M &gt; &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, B b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#enum-apply-f-scalars_t-b-c-vec-a-m-b-c","title":"enum apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01B_00_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_01B_00_01C_01_4/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    B b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/","title":"Struct linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;","text":"<p>template &lt;class F, int M, class A, class B, class C&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-types","title":"Public Types","text":"Type Name enum apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; typedef vec&lt; ret_t&lt; F, A, B, C &gt;, M &gt; type"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr type impl (seq&lt; I... &gt;, F f, const vec&lt; A, M &gt; &amp; a, const vec&lt; B, M &gt; &amp; b, C c)"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#enum-apply-f-scalars_t-c-vec-a-m-vec-b-m-c","title":"enum apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;","text":"<pre><code>enum linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; {\n    size =M\n};\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::type =  vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1apply_3_01F_00_01scalars__t_3_01C_01_4_00_01vec_3_01A_00_01M_01_4_00_0ac44fec9d6688f597db0a07139ff2167/#function-impl","title":"function impl","text":"<pre><code>template&lt;int... I&gt;\nstatic inline constexpr type linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;::impl (\n    seq&lt; I... &gt;,\n    F f,\n    const vec&lt; A, M &gt; &amp; a,\n    const vec&lt; B, M &gt; &amp; b,\n    C c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1clamp/","title":"Struct linalg::detail::clamp","text":"<p>ClassList &gt; linalg &gt; detail &gt; clamp</p>"},{"location":"api/structlinalg_1_1detail_1_1clamp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1clamp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1clamp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::clamp::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1empty/","title":"Struct linalg::detail::empty","text":"<p>ClassList &gt; linalg &gt; detail &gt; empty</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter/","title":"Struct linalg::detail::getter","text":"<p>template &lt;int I&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/","title":"Struct linalg::detail::getter&lt; 0 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 0 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_010_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 0 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/","title":"Struct linalg::detail::getter&lt; 1 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 1 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_011_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 1 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/","title":"Struct linalg::detail::getter&lt; 2 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 2 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_012_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 2 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/","title":"Struct linalg::detail::getter&lt; 3 &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; getter&lt; 3 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A &amp; a) const"},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1getter_3_013_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::getter&lt; 3 &gt;::operator() (\n    A &amp; a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1lerp/","title":"Struct linalg::detail::lerp","text":"<p>ClassList &gt; linalg &gt; detail &gt; lerp</p>"},{"location":"api/structlinalg_1_1detail_1_1lerp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1lerp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1lerp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::lerp::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl/","title":"Struct linalg::detail::make_seq_impl","text":"<p>template &lt;int A, int N&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 0 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 0 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt;&gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_010_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 0 &gt;::type =  seq&lt;&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 1 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 1 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_011_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 1 &gt;::type =  seq&lt;A+0&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 2 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 2 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_012_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 2 &gt;::type =  seq&lt;A+0,A+1&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 3 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 3 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1, A+2 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_013_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 3 &gt;::type =  seq&lt;A+0,A+1,A+2&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/","title":"Struct linalg::detail::make_seq_impl&lt; A, 4 &gt;","text":"<p>template &lt;int A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; make_seq_impl&lt; A, 4 &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#public-types","title":"Public Types","text":"Type Name typedef seq&lt; A+0, A+1, A+2, A+3 &gt; type"},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1make__seq__impl_3_01A_00_014_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::make_seq_impl&lt; A, 4 &gt;::type =  seq&lt;A+0,A+1,A+2,A+3&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1max/","title":"Struct linalg::detail::max","text":"<p>ClassList &gt; linalg &gt; detail &gt; max</p>"},{"location":"api/structlinalg_1_1detail_1_1max/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1max/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1max/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::max::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1min/","title":"Struct linalg::detail::min","text":"<p>ClassList &gt; linalg &gt; detail &gt; min</p>"},{"location":"api/structlinalg_1_1detail_1_1min/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1min/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1min/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::min::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__add/","title":"Struct linalg::detail::op_add","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_add</p>"},{"location":"api/structlinalg_1_1detail_1_1op__add/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__add/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__add/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_add::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__and/","title":"Struct linalg::detail::op_and","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_and</p>"},{"location":"api/structlinalg_1_1detail_1_1op__and/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__and/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__and/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_and::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/","title":"Struct linalg::detail::op_cmp","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_cmp</p>"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__cmp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_cmp::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__div/","title":"Struct linalg::detail::op_div","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_div</p>"},{"location":"api/structlinalg_1_1detail_1_1op__div/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__div/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__div/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_div::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__eq/","title":"Struct linalg::detail::op_eq","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_eq</p>"},{"location":"api/structlinalg_1_1detail_1_1op__eq/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__eq/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__eq/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_eq::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__ge/","title":"Struct linalg::detail::op_ge","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_ge</p>"},{"location":"api/structlinalg_1_1detail_1_1op__ge/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__ge/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__ge/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_ge::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__gt/","title":"Struct linalg::detail::op_gt","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_gt</p>"},{"location":"api/structlinalg_1_1detail_1_1op__gt/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__gt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__gt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_gt::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__int/","title":"Struct linalg::detail::op_int","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_int</p>"},{"location":"api/structlinalg_1_1detail_1_1op__int/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__int/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__int/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_int::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__le/","title":"Struct linalg::detail::op_le","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_le</p>"},{"location":"api/structlinalg_1_1detail_1_1op__le/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__le/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__le/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_le::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/","title":"Struct linalg::detail::op_lsh","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_lsh</p>"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__lsh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_lsh::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__lt/","title":"Struct linalg::detail::op_lt","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_lt</p>"},{"location":"api/structlinalg_1_1detail_1_1op__lt/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__lt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__lt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_lt::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__mod/","title":"Struct linalg::detail::op_mod","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_mod</p>"},{"location":"api/structlinalg_1_1detail_1_1op__mod/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__mod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__mod/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_mod::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__mul/","title":"Struct linalg::detail::op_mul","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_mul</p>"},{"location":"api/structlinalg_1_1detail_1_1op__mul/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__mul/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__mul/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_mul::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__ne/","title":"Struct linalg::detail::op_ne","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_ne</p>"},{"location":"api/structlinalg_1_1detail_1_1op__ne/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__ne/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__ne/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_ne::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__neg/","title":"Struct linalg::detail::op_neg","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_neg</p>"},{"location":"api/structlinalg_1_1detail_1_1op__neg/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__neg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__neg/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_neg::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__not/","title":"Struct linalg::detail::op_not","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_not</p>"},{"location":"api/structlinalg_1_1detail_1_1op__not/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__not/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__not/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_not::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__or/","title":"Struct linalg::detail::op_or","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_or</p>"},{"location":"api/structlinalg_1_1detail_1_1op__or/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__or/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__or/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_or::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__pos/","title":"Struct linalg::detail::op_pos","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_pos</p>"},{"location":"api/structlinalg_1_1detail_1_1op__pos/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1op__pos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__pos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline constexpr auto linalg::detail::op_pos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/","title":"Struct linalg::detail::op_rsh","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_rsh</p>"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__rsh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_rsh::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__sub/","title":"Struct linalg::detail::op_sub","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_sub</p>"},{"location":"api/structlinalg_1_1detail_1_1op__sub/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__sub/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__sub/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_sub::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__un/","title":"Struct linalg::detail::op_un","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_un</p>"},{"location":"api/structlinalg_1_1detail_1_1op__un/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__un/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__un/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_un::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1op__xor/","title":"Struct linalg::detail::op_xor","text":"<p>ClassList &gt; linalg &gt; detail &gt; op_xor</p>"},{"location":"api/structlinalg_1_1detail_1_1op__xor/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1op__xor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1op__xor/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline constexpr auto linalg::detail::op_xor::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1ord/","title":"Struct linalg::detail::ord","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; ord</p>"},{"location":"api/structlinalg_1_1detail_1_1ord/#public-attributes","title":"Public Attributes","text":"Type Name T a T b"},{"location":"api/structlinalg_1_1detail_1_1ord/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1ord/#variable-a","title":"variable a","text":"<pre><code>T linalg::detail::ord&lt; T &gt;::a;\n</code></pre>"},{"location":"api/structlinalg_1_1detail_1_1ord/#variable-b","title":"variable b","text":"<pre><code>T linalg::detail::ord&lt; T &gt;::b;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type/","title":"Struct linalg::detail::scalar_type","text":"<p>template &lt;class A&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/","title":"Struct linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;","text":"<p>template &lt;class T, int M, int N&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type&lt; mat&lt; T, M, N &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01mat_3_01T_00_01M_00_01N_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/","title":"Struct linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalar_type&lt; vec&lt; T, M &gt; &gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalar__type_3_01vec_3_01T_00_01M_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars/","title":"Struct linalg::detail::scalars","text":"<p>template &lt;class... T&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_01T_00_01U_8_8_8_01_4/","title":"Struct linalg::detail::scalars&lt; T, U... &gt;","text":"<p>template &lt;class T, class... U&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars&lt; T, U... &gt;</p> <p>Inherits the following classes: std::conditional::type</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/","title":"Struct linalg::detail::scalars&lt;&gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; scalars&lt;&gt;</p>"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#public-types","title":"Public Types","text":"Type Name typedef void type"},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1scalars_3_4/#typedef-type","title":"typedef type","text":"<pre><code>using linalg::detail::scalars&lt;&gt;::type =  void;\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1select/","title":"Struct linalg::detail::select","text":"<p>ClassList &gt; linalg &gt; detail &gt; select</p>"},{"location":"api/structlinalg_1_1detail_1_1select/#public-functions","title":"Public Functions","text":"Type Name constexpr auto operator() (A a, B b, C c) const"},{"location":"api/structlinalg_1_1detail_1_1select/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1select/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B, class C&gt;\ninline constexpr auto linalg::detail::select::operator() (\n    A a,\n    B b,\n    C c\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1seq/","title":"Struct linalg::detail::seq","text":"<p>template &lt;int... I&gt;</p> <p>ClassList &gt; linalg &gt; detail &gt; seq</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__abs/","title":"Struct linalg::detail::std_abs","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_abs</p>"},{"location":"api/structlinalg_1_1detail_1_1std__abs/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__abs/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__abs/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_abs::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__acos/","title":"Struct linalg::detail::std_acos","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_acos</p>"},{"location":"api/structlinalg_1_1detail_1_1std__acos/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__acos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__acos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_acos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__asin/","title":"Struct linalg::detail::std_asin","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_asin</p>"},{"location":"api/structlinalg_1_1detail_1_1std__asin/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__asin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__asin/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_asin::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan/","title":"Struct linalg::detail::std_atan","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_atan</p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__atan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__atan/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_atan::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/","title":"Struct linalg::detail::std_atan2","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_atan2</p>"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__atan2/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_atan2::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/","title":"Struct linalg::detail::std_ceil","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_ceil</p>"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__ceil/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_ceil::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/","title":"Struct linalg::detail::std_copysign","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_copysign</p>"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__copysign/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_copysign::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__cos/","title":"Struct linalg::detail::std_cos","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_cos</p>"},{"location":"api/structlinalg_1_1detail_1_1std__cos/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__cos/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__cos/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_cos::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/","title":"Struct linalg::detail::std_cosh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_cosh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__cosh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_cosh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__exp/","title":"Struct linalg::detail::std_exp","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_exp</p>"},{"location":"api/structlinalg_1_1detail_1_1std__exp/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__exp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__exp/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_exp::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__floor/","title":"Struct linalg::detail::std_floor","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_floor</p>"},{"location":"api/structlinalg_1_1detail_1_1std__floor/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__floor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__floor/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_floor::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/","title":"Struct linalg::detail::std_fmod","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_fmod</p>"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__fmod/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_fmod::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__log/","title":"Struct linalg::detail::std_log","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_log</p>"},{"location":"api/structlinalg_1_1detail_1_1std__log/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__log/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__log/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_log::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__log10/","title":"Struct linalg::detail::std_log10","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_log10</p>"},{"location":"api/structlinalg_1_1detail_1_1std__log10/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__log10/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__log10/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_log10::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__pow/","title":"Struct linalg::detail::std_pow","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_pow</p>"},{"location":"api/structlinalg_1_1detail_1_1std__pow/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a, B b) const"},{"location":"api/structlinalg_1_1detail_1_1std__pow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__pow/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A, class B&gt;\ninline auto linalg::detail::std_pow::operator() (\n    A a,\n    B b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__round/","title":"Struct linalg::detail::std_round","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_round</p>"},{"location":"api/structlinalg_1_1detail_1_1std__round/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__round/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__round/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_round::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sin/","title":"Struct linalg::detail::std_sin","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sin</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sin/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sin/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sin::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/","title":"Struct linalg::detail::std_sinh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sinh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sinh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sinh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/","title":"Struct linalg::detail::std_sqrt","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_sqrt</p>"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__sqrt/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_sqrt::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__tan/","title":"Struct linalg::detail::std_tan","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_tan</p>"},{"location":"api/structlinalg_1_1detail_1_1std__tan/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__tan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__tan/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_tan::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/","title":"Struct linalg::detail::std_tanh","text":"<p>ClassList &gt; linalg &gt; detail &gt; std_tanh</p>"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#public-functions","title":"Public Functions","text":"Type Name auto operator() (A a) const"},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1detail_1_1std__tanh/#function-operator","title":"function operator()","text":"<pre><code>template&lt;class A&gt;\ninline auto linalg::detail::std_tanh::operator() (\n    A a\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1identity__t/","title":"Struct linalg::identity_t","text":"<p>ClassList &gt; linalg &gt; identity_t</p>"},{"location":"api/structlinalg_1_1identity__t/#public-functions","title":"Public Functions","text":"Type Name constexpr identity_t (int)"},{"location":"api/structlinalg_1_1identity__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1identity__t/#function-identity_t","title":"function identity_t","text":"<pre><code>inline explicit constexpr linalg::identity_t::identity_t (\n    int\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat/","title":"Struct linalg::mat","text":"<p>template &lt;class T, int M, int N&gt;</p> <p>ClassList &gt; linalg &gt; mat</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/","title":"Struct linalg::mat&lt; T, M, 1 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 1 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 1 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 1 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 1 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 1 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 1 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const V &amp; x_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const mat&lt; U, M, 1 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 1 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 1 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 1 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 1 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_011_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 1 &gt; linalg::mat&lt; T, M, 1 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/","title":"Struct linalg::mat&lt; T, M, 2 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 2 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x V y"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 2 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 2 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 2 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 2 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 2 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 2 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const mat&lt; U, M, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 2 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 2 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 2 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 2 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_012_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 2 &gt; linalg::mat&lt; T, M, 2 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/","title":"Struct linalg::mat&lt; T, M, 3 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 3 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V x V y V z"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_, const V &amp; z_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 3 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 3 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 3 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#variable-z","title":"variable z","text":"<pre><code>V linalg::mat&lt; T, M, 3 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 3 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_,\n    const V &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const mat&lt; U, M, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 3 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 3 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 3 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 3 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_013_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 3 &gt; linalg::mat&lt; T, M, 3 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/","title":"Struct linalg::mat&lt; T, M, 4 &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; mat&lt; T, M, 4 &gt;</p>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-types","title":"Public Types","text":"Type Name typedef vec&lt; T, M &gt; V"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-attributes","title":"Public Attributes","text":"Type Name V w V x V y V z"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr mat ()  constexpr mat (const V &amp; x_, const V &amp; y_, const V &amp; z_, const V &amp; w_)  constexpr mat (const T &amp; s)  constexpr mat (const T * p)  constexpr mat (const mat&lt; U, M, 4 &gt; &amp; m)  constexpr mat (const U &amp; u)  constexpr operator U () const constexpr const V &amp; operator[] (int j) const LINALG_CONSTEXPR14 V &amp; operator[] (int j)  constexpr vec&lt; T, 4 &gt; row (int i) const"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#typedef-v","title":"typedef V","text":"<pre><code>typedef vec&lt;T,M&gt; linalg::mat&lt; T, M, 4 &gt;::V;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-w","title":"variable w","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::w;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-x","title":"variable x","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-y","title":"variable y","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#variable-z","title":"variable z","text":"<pre><code>V linalg::mat&lt; T, M, 4 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-16","title":"function mat [1/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 4 &gt;::mat () \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-26","title":"function mat [2/6]","text":"<pre><code>inline constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const V &amp; x_,\n    const V &amp; y_,\n    const V &amp; z_,\n    const V &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-36","title":"function mat [3/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-46","title":"function mat [4/6]","text":"<pre><code>inline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-56","title":"function mat [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const mat&lt; U, M, 4 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-mat-66","title":"function mat [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 4 &gt;::mat (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::mat&lt; T, M, 4 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const V &amp; linalg::mat&lt; T, M, 4 &gt;::operator[] (\n    int j\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 V &amp; linalg::mat&lt; T, M, 4 &gt;::operator[] (\n    int j\n) \n</code></pre>"},{"location":"api/structlinalg_1_1mat_3_01T_00_01M_00_014_01_4/#function-row","title":"function row","text":"<pre><code>inline constexpr vec&lt; T, 4 &gt; linalg::mat&lt; T, M, 4 &gt;::row (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacelinalg_1_1ostream__overloads/","title":"Namespace linalg::ostream_overloads","text":"<p>Namespace List &gt; linalg &gt; ostream_overloads</p>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#public-functions","title":"Public Functions","text":"Type Name std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 1 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 2 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 3 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const vec&lt; T, 4 &gt; &amp; v)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 1 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 2 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 3 &gt; &amp; m)  std::basic_ostream&lt; C &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; C &gt; &amp; out, const mat&lt; T, M, 4 &gt; &amp; m)"},{"location":"api/namespacelinalg_1_1ostream__overloads/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 1 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const vec&lt; T, 4 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 1 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_5","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_6","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"api/namespacelinalg_1_1ostream__overloads/#function-operator_7","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class C, class T, int M&gt;\nstd::basic_ostream&lt; C &gt; &amp; linalg::ostream_overloads::operator&lt;&lt; (\n    std::basic_ostream&lt; C &gt; &amp; out,\n    const mat&lt; T, M, 4 &gt; &amp; m\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec/","title":"Struct linalg::vec","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; linalg &gt; vec</p> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/","title":"Struct linalg::vec&lt; T, 1 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 1 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_)  constexpr vec (const vec&lt; U, 1 &gt; &amp; v)  constexpr vec (const U &amp; u)"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 1 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 1 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 1 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 1 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-14","title":"function vec [1/4]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 1 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-24","title":"function vec [2/4]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const T &amp; x_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-34","title":"function vec [3/4]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const vec&lt; U, 1 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_011_01_4/#function-vec-44","title":"function vec [4/4]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 1 &gt;::vec (\n    const U &amp; u\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/","title":"Struct linalg::vec&lt; T, 2 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 2 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x T y"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 2 &gt; &amp; v)  constexpr vec (const U &amp; u)"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 2 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 2 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 2 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 2 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 2 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-16","title":"function vec [1/6]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 2 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-26","title":"function vec [2/6]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-36","title":"function vec [3/6]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-46","title":"function vec [4/6]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-56","title":"function vec [5/6]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const vec&lt; U, 2 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_012_01_4/#function-vec-66","title":"function vec [6/6]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 2 &gt;::vec (\n    const U &amp; u\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/","title":"Struct linalg::vec&lt; T, 3 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 3 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T x T y T z"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_, const T &amp; z_)  constexpr vec (const vec&lt; T, 2 &gt; &amp; xy, const T &amp; z_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 3 &gt; &amp; v)  constexpr vec (const U &amp; u)  constexpr const vec&lt; T, 2 &gt; &amp; xy () const vec&lt; T, 2 &gt; &amp; xy ()"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#variable-z","title":"variable z","text":"<pre><code>T linalg::vec&lt; T, 3 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 3 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 3 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 3 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-17","title":"function vec [1/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-27","title":"function vec [2/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_,\n    const T &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-37","title":"function vec [3/7]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const vec&lt; T, 2 &gt; &amp; xy,\n    const T &amp; z_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-47","title":"function vec [4/7]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-57","title":"function vec [5/7]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-67","title":"function vec [6/7]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const vec&lt; U, 3 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-vec-77","title":"function vec [7/7]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 3 &gt;::vec (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-xy-12","title":"function xy [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 3 &gt;::xy () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_013_01_4/#function-xy-22","title":"function xy [2/2]","text":"<pre><code>inline vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 3 &gt;::xy () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/","title":"Struct linalg::vec&lt; T, 4 &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; linalg &gt; vec&lt; T, 4 &gt;</p>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-attributes","title":"Public Attributes","text":"Type Name T w T x T y T z"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr operator U () const constexpr const T &amp; operator[] (int i) const LINALG_CONSTEXPR14 T &amp; operator[] (int i)  constexpr vec ()  constexpr vec (const T &amp; x_, const T &amp; y_, const T &amp; z_, const T &amp; w_)  constexpr vec (const vec&lt; T, 2 &gt; &amp; xy, const T &amp; z_, const T &amp; w_)  constexpr vec (const vec&lt; T, 3 &gt; &amp; xyz, const T &amp; w_)  constexpr vec (const T &amp; s)  constexpr vec (const T * p)  constexpr vec (const vec&lt; U, 4 &gt; &amp; v)  constexpr vec (const U &amp; u)  constexpr const vec&lt; T, 2 &gt; &amp; xy () const vec&lt; T, 2 &gt; &amp; xy ()  constexpr const vec&lt; T, 3 &gt; &amp; xyz () const vec&lt; T, 3 &gt; &amp; xyz ()"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-w","title":"variable w","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::w;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-x","title":"variable x","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::x;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-y","title":"variable y","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::y;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#variable-z","title":"variable z","text":"<pre><code>T linalg::vec&lt; T, 4 &gt;::z;\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator-u","title":"function operator U","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 4 &gt;::operator U () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr const T &amp; linalg::vec&lt; T, 4 &gt;::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LINALG_CONSTEXPR14 T &amp; linalg::vec&lt; T, 4 &gt;::operator[] (\n    int i\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-18","title":"function vec [1/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-28","title":"function vec [2/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T &amp; x_,\n    const T &amp; y_,\n    const T &amp; z_,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-38","title":"function vec [3/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; T, 2 &gt; &amp; xy,\n    const T &amp; z_,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-48","title":"function vec [4/8]","text":"<pre><code>inline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; T, 3 &gt; &amp; xyz,\n    const T &amp; w_\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-58","title":"function vec [5/8]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T &amp; s\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-68","title":"function vec [6/8]","text":"<pre><code>inline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const T * p\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-78","title":"function vec [7/8]","text":"<pre><code>template&lt;class U&gt;\ninline explicit constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const vec&lt; U, 4 &gt; &amp; v\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-vec-88","title":"function vec [8/8]","text":"<pre><code>template&lt;class U, class&gt;\ninline constexpr linalg::vec&lt; T, 4 &gt;::vec (\n    const U &amp; u\n) \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xy-12","title":"function xy [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xy () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xy-22","title":"function xy [2/2]","text":"<pre><code>inline vec&lt; T, 2 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xy () \n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xyz-12","title":"function xyz [1/2]","text":"<pre><code>inline constexpr const vec&lt; T, 3 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xyz () const\n</code></pre>"},{"location":"api/structlinalg_1_1vec_3_01T_00_014_01_4/#function-xyz-22","title":"function xyz [2/2]","text":"<pre><code>inline vec&lt; T, 3 &gt; &amp; linalg::vec&lt; T, 4 &gt;::xyz () \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/classpose__prediction/","title":"Class pose_prediction","text":"<p>ClassList &gt; pose_prediction</p> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classpose__prediction/#public-functions","title":"Public Functions","text":"Type Name virtual pose_type * get_fast_pose () = 0 virtual pose_type * get_fast_true_pose () = 0"},{"location":"api/classpose__prediction/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name virtual void start () A method which Spindle calls when it starts the component."},{"location":"api/classpose__prediction/#public-functions-inherited-from-illixrservice","title":"Public Functions inherited from ILLIXR::service","text":"<p>See ILLIXR::service</p> Type Name virtual ~service ()"},{"location":"api/classpose__prediction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classpose__prediction/#function-get_fast_pose","title":"function get_fast_pose","text":"<pre><code>virtual pose_type * pose_prediction::get_fast_pose () = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_fast_true_pose","title":"function get_fast_true_pose","text":"<pre><code>virtual pose_type * pose_prediction::get_fast_true_pose () = 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/pose_prediction.hpp</code></p>"},{"location":"api/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p>"},{"location":"api/namespacestd/#namespaces","title":"Namespaces","text":"Type Name namespace conditional"},{"location":"api/namespacestd/#classes","title":"Classes","text":"Type Name struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; &lt;class T&gt; <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/namespacestd_1_1conditional/","title":"Namespace std::conditional","text":"<p>Namespace List &gt; std &gt; conditional</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 1 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 1 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 2 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 2 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 3 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 3 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/","title":"Struct std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;","text":"<p>template &lt;class T, int M&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::mat&lt; T, M, 4 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1mat_3_01T_00_01M_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;::operator() (\n    const linalg::mat&lt; T, M, 4 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 1 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 1 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_011_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 1 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 2 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 2 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_012_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 2 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 3 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 3 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_013_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 3 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/","title":"Struct std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; linalg::vec&lt; T, 4 &gt; &gt;</p>"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const linalg::vec&lt; T, 4 &gt; &amp; v) const"},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structstd_1_1hash_3_01linalg_1_1vec_3_01T_00_014_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline std::size_t std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;::operator() (\n    const linalg::vec&lt; T, 4 &gt; &amp; v\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/dir_bdd9a5d540de89e9fe90efdfc6973a4f/","title":"Dir common","text":"<p>FileList &gt; common</p>"},{"location":"api/dir_bdd9a5d540de89e9fe90efdfc6973a4f/#files","title":"Files","text":"Type Name file data_format.hpp file extended_window.hpp file linalg.hpp file logger.hpp file phonebook.hpp file plugin.hpp file pose_prediction.hpp file shader_util.hpp file switchboard.hpp file threadloop.hpp <p>The documentation for this class was generated from the following file <code>common/</code></p>"},{"location":"api/data__format_8hpp/","title":"File data_format.hpp","text":"<p>FileList &gt; common &gt; data_format.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;boost/optional.hpp&gt;</code></li> <li><code>#include &lt;opencv2/core/mat.hpp&gt;</code></li> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;GL/gl.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"switchboard.hpp\"</code></li> </ul>"},{"location":"api/data__format_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/data__format_8hpp/#classes","title":"Classes","text":"Type Name struct accel struct camera_frame class global_config struct hmd_physical_info struct hologram_input struct hologram_output struct imu_cam_type struct pose_type struct rendered_frame struct rendered_frame_alt"},{"location":"api/data__format_8hpp/#macros","title":"Macros","text":"Type Name define NANO_SEC <code>1000000000.0</code> define USE_ALT_EYE_FORMAT"},{"location":"api/data__format_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/data__format_8hpp/#define-nano_sec","title":"define NANO_SEC","text":"<pre><code>#define NANO_SEC `1000000000.0`\n</code></pre>"},{"location":"api/data__format_8hpp/#define-use_alt_eye_format","title":"define USE_ALT_EYE_FORMAT","text":"<pre><code>#define USE_ALT_EYE_FORMAT \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/data_format.hpp</code></p>"},{"location":"api/data__format_8hpp_source/","title":"File data_format.hpp","text":"<p>File List &gt; common &gt; data_format.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef DATA_HH\n#define DATA_HH\n\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;boost/optional.hpp&gt;\n\n#include &lt;opencv2/core/mat.hpp&gt;\n#undef Success // For 'Success' conflict\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;GL/gl.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n//#undef Complex // For 'Complex' conflict\n#include \"phonebook.hpp\"\n#include \"switchboard.hpp\"\n\n// Tell gldemo and timewarp_gl to use two texture handle for left and right eye\n#define USE_ALT_EYE_FORMAT\n#define NANO_SEC 1000000000.0\n\nnamespace ILLIXR {\n\n    typedef std::chrono::time_point&lt;std::chrono::system_clock&gt; time_type;\n    typedef unsigned long long ullong;\n\n    // Data type that combines the IMU and camera data at a certain timestamp.\n    // If there is only IMU data for a certain timestamp, img0 and img1 will be null\n    // time is the current UNIX time where dataset_time is the time read from the csv\n    typedef struct {\n        time_type time;\n        Eigen::Vector3f angular_v;\n        Eigen::Vector3f linear_a;\n        std::optional&lt;cv::Mat*&gt; img0;\n        std::optional&lt;cv::Mat*&gt; img1;\n        ullong dataset_time;\n    } imu_cam_type;\n\n    typedef struct {\n        time_type time; \n        Eigen::Vector3f position;\n        Eigen::Quaternionf orientation;\n    } pose_type;\n\n    typedef struct {\n        int pixel[1];\n    } camera_frame;\n\n    class global_config : public service {\n    public:\n        global_config(GLFWwindow* _glfw_context) : glfw_context(_glfw_context) { }\n        GLFWwindow* glfw_context;\n    };\n\n    // Single-texture format; arrayed by left/right eye\n    // Single-texture format; arrayed by left/right eye\n    struct rendered_frame {\n        GLuint texture_handle;\n        pose_type render_pose; // The pose used when rendering this frame.\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; sample_time; \n    };\n\n    // Using arrays as a swapchain\n    // Array of left eyes, array of right eyes\n    // This more closely matches the format used by Monado\n    struct rendered_frame_alt {\n        GLuint texture_handles[2]; // Does not change between swaps in swapchain\n        GLuint swap_indices[2]; // Which element of the swapchain\n        pose_type render_pose; // The pose used when rendering this frame.\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; sample_time; \n    };\n\n    typedef struct {\n        int seq;\n    } hologram_input;\n\n    typedef struct {\n        int dummy;\n    } hologram_output;\n\n    /* I use \"accel\" instead of \"3-vector\" as a datatype, because\n    this checks that you meant to use an acceleration in a certain\n    place. */\n    struct accel { };\n\n    // High-level HMD specification, timewarp plugin\n    // may/will calculate additional HMD info based on these specifications\n    struct hmd_physical_info {\n        float   ipd;\n        int     displayPixelsWide;\n        int     displayPixelsHigh;\n        float   chromaticAberration[4];\n        float   K[11];\n        int     visiblePixelsWide;\n        int     visiblePixelsHigh;\n        float   visibleMetersWide;\n        float   visibleMetersHigh;\n        float   lensSeparationInMeters;\n        float   metersPerTanAngleAtCenter;\n    };\n}\n\n#endif\n</code></pre>"},{"location":"api/extended__window_8hpp/","title":"File extended_window.hpp","text":"<p>FileList &gt; common &gt; extended_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;X11/X.h&gt;</code></li> <li><code>#include &lt;X11/Xlib.h&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include &lt;GL/glu.h&gt;</code></li> </ul>"},{"location":"api/extended__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/extended__window_8hpp/#classes","title":"Classes","text":"Type Name class xlib_gl_extended_window"},{"location":"api/extended__window_8hpp/#public-types","title":"Public Types","text":"Type Name typedef GLXContext(* glXCreateContextAttribsARBProc"},{"location":"api/extended__window_8hpp/#macros","title":"Macros","text":"Type Name define GLX_CONTEXT_MAJOR_VERSION_ARB <code>0x2091</code> define GLX_CONTEXT_MINOR_VERSION_ARB <code>0x2092</code>"},{"location":"api/extended__window_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/extended__window_8hpp/#typedef-glxcreatecontextattribsarbproc","title":"typedef glXCreateContextAttribsARBProc","text":"<pre><code>typedef GLXContext(* glXCreateContextAttribsARBProc) (Display *, GLXFBConfig, GLXContext, Bool, const int *);\n</code></pre>"},{"location":"api/extended__window_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/extended__window_8hpp/#define-glx_context_major_version_arb","title":"define GLX_CONTEXT_MAJOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MAJOR_VERSION_ARB `0x2091`\n</code></pre>"},{"location":"api/extended__window_8hpp/#define-glx_context_minor_version_arb","title":"define GLX_CONTEXT_MINOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MINOR_VERSION_ARB `0x2092`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/extended_window.hpp</code></p>"},{"location":"api/extended__window_8hpp_source/","title":"File extended_window.hpp","text":"<p>File List &gt; common &gt; extended_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;X11/X.h&gt;\n#include &lt;X11/Xlib.h&gt;\n#include &lt;GL/glx.h&gt;\n#include &lt;GL/glu.h&gt;\n//GLX context magics\n#define GLX_CONTEXT_MAJOR_VERSION_ARB       0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB       0x2092\ntypedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);\n\nnamespace ILLIXR{\n    class xlib_gl_extended_window : public service {\n    public:\n        int                     width;\n        int                     height;\n        Display                 *dpy;\n        Window                  win;\n        GLXContext              glc;\n        xlib_gl_extended_window(int _width, int _height, GLXContext _shared_gl_context){\n            width = _width;\n            height = _height;\n\n            dpy = XOpenDisplay(NULL);\n            if(dpy == NULL) {\n                printf(\"\\n\\tcannot connect to X server\\n\\n\");\n                    exit(0);\n            }\n            Window root = DefaultRootWindow(dpy);\n            // Get a matching FB config\n            static int visual_attribs[] =\n            {\n                GLX_X_RENDERABLE    , True,\n                GLX_DRAWABLE_TYPE   , GLX_WINDOW_BIT,\n                GLX_RENDER_TYPE     , GLX_RGBA_BIT,\n                GLX_X_VISUAL_TYPE   , GLX_TRUE_COLOR,\n                GLX_RED_SIZE        , 8,\n                GLX_GREEN_SIZE      , 8,\n                GLX_BLUE_SIZE       , 8,\n                GLX_ALPHA_SIZE      , 8,\n                GLX_DEPTH_SIZE      , 24,\n                GLX_STENCIL_SIZE    , 8,\n                GLX_DOUBLEBUFFER    , True,\n                //GLX_SAMPLE_BUFFERS  , 1,\n                //GLX_SAMPLES         , 4,\n                None\n            };\n            // vi = glXChooseVisual(dpy, 0, att);\n            // if(vi == NULL) {\n            //  printf(\"\\n\\tno appropriate visual found\\n\\n\");\n            //         exit(0);\n            // }\n            // else {\n            //  printf(\"\\n\\tvisual %p selected\\n\", (void *)vi-&gt;visualid); /* %p creates hexadecimal output like in glxinfo */\n            // }\n\n            printf( \"Getting matching framebuffer configs\\n\" );\n            int fbcount;\n            GLXFBConfig* fbc = glXChooseFBConfig(dpy, DefaultScreen(dpy), visual_attribs, &amp;fbcount);\n            if (!fbc)\n            {\n                printf( \"Failed to retrieve a framebuffer config\\n\" );\n                exit(1);\n            }\n            printf( \"Found %d matching FB configs.\\n\", fbcount );\n            // Pick the FB config/visual with the most samples per pixel\n            printf( \"Getting XVisualInfos\\n\" );\n            int best_fbc = -1, worst_fbc = -1, best_num_samp = -1, worst_num_samp = 999;\n            int i;\n            for (i=0; i&lt;fbcount; ++i)\n            {\n                XVisualInfo *vi = glXGetVisualFromFBConfig( dpy, fbc[i] );\n                if ( vi )\n                {\n                    int samp_buf, samples;\n                    glXGetFBConfigAttrib( dpy, fbc[i], GLX_SAMPLE_BUFFERS, &amp;samp_buf );\n                    glXGetFBConfigAttrib( dpy, fbc[i], GLX_SAMPLES       , &amp;samples  );\n                    printf( \"  Matching fbconfig %d, visual ID 0x%2x: SAMPLE_BUFFERS = %d,\"\n                            \" SAMPLES = %d\\n\",\n                            i, vi -&gt; visualid, samp_buf, samples );\n                    if ( best_fbc &lt; 0 || samp_buf &amp;&amp; samples &gt; best_num_samp )\n                      best_fbc = i, best_num_samp = samples;\n                    if ( worst_fbc &lt; 0 || !samp_buf || samples &lt; worst_num_samp )\n                      worst_fbc = i, worst_num_samp = samples;\n                }\n                XFree( vi );\n            }\n            GLXFBConfig bestFbc = fbc[ best_fbc ];\n            // Be sure to free the FBConfig list allocated by glXChooseFBConfig()\n            XFree( fbc );\n            // Get a visual\n            XVisualInfo *vi = glXGetVisualFromFBConfig( dpy, bestFbc );\n            printf( \"Chosen visual ID = 0x%x\\n\", vi-&gt;visualid );\n\n            Colormap cmap = XCreateColormap(dpy, root, vi-&gt;visual, AllocNone);\n            XSetWindowAttributes swa;\n            swa.colormap = cmap;\n            swa.event_mask = ExposureMask | KeyPressMask;\n            win = XCreateWindow(dpy, root, 0, 0, width, height, 0, vi-&gt;depth, InputOutput, vi-&gt;visual, CWColormap | CWEventMask, &amp;swa);\n            XMapWindow(dpy, win);\n            XStoreName(dpy, win, \"ILLIXR Extended Window\");\n\n            //glc = glXCreateContext(dpy, vi, *ctx, true);\n            // calling glXGetProcAddressARB\n            glXCreateContextAttribsARBProc glXCreateContextAttribsARB = 0;\n            glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)\n                glXGetProcAddressARB( (const GLubyte *) \"glXCreateContextAttribsARB\" );\n            int context_attribs[] =\n                {\n                    GLX_CONTEXT_MAJOR_VERSION_ARB, 4,\n                    GLX_CONTEXT_MINOR_VERSION_ARB, 0,\n                    //GLX_CONTEXT_FLAGS_ARB        , GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,\n                    None\n                };\n            printf( \"Creating context\\n\" );\n            glc = glXCreateContextAttribsARB( dpy, bestFbc, _shared_gl_context,\n                                                   True, context_attribs );\n        }\n    };\n}\n</code></pre>"},{"location":"api/linalg_8hpp/","title":"File linalg.hpp","text":"<p>FileList &gt; common &gt; linalg.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;iosfwd&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"api/linalg_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace linalg namespace aliases namespace detail namespace ostream_overloads namespace std"},{"location":"api/linalg_8hpp/#classes","title":"Classes","text":"Type Name struct converter &lt;class T, class U&gt; struct converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; &lt;class T&gt; struct converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; &lt;class T&gt; struct any_compare &lt;class A, class B&gt; struct any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; &lt;class T&gt; struct apply &lt;class F, class Void, T&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; &lt;class F, M, N, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; &lt;class F, M, class A&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; &lt;class F, A&gt; struct apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; &lt;class F, M, N, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; &lt;class F, M, class A, class B&gt; struct apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; &lt;class F, M, class A, class B, class C&gt; struct apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; &lt;class F, M, class A, class B, class C&gt; struct clamp struct empty struct getter&lt; 0 &gt; &lt;&gt; struct getter&lt; 1 &gt; &lt;&gt; struct getter&lt; 2 &gt; &lt;&gt; struct getter&lt; 3 &gt; &lt;&gt; struct lerp struct make_seq_impl&lt; A, 0 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 1 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 2 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 3 &gt; &lt;A&gt; struct make_seq_impl&lt; A, 4 &gt; &lt;A&gt; struct max struct min struct op_add struct op_and struct op_cmp struct op_div struct op_eq struct op_ge struct op_gt struct op_int struct op_le struct op_lsh struct op_lt struct op_mod struct op_mul struct op_ne struct op_neg struct op_not struct op_or struct op_pos struct op_rsh struct op_sub struct op_un struct op_xor struct ord &lt;class T&gt; struct scalar_type &lt;class A&gt; struct scalar_type&lt; mat&lt; T, M, N &gt; &gt; &lt;class T, M, N&gt; struct scalar_type&lt; vec&lt; T, M &gt; &gt; &lt;class T, M&gt; struct scalars&lt; T, U... &gt; &lt;class T, U&gt; struct scalars&lt;&gt; &lt;&gt; struct select struct seq &lt;I&gt; struct std_abs struct std_acos struct std_asin struct std_atan struct std_atan2 struct std_ceil struct std_copysign struct std_cos struct std_cosh struct std_exp struct std_floor struct std_fmod struct std_log struct std_log10 struct std_pow struct std_round struct std_sin struct std_sinh struct std_sqrt struct std_tan struct std_tanh struct identity_t struct mat&lt; T, M, 1 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 2 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 3 &gt; &lt;class T, M&gt; struct mat&lt; T, M, 4 &gt; &lt;class T, M&gt; struct vec&lt; T, 1 &gt; &lt;class T&gt; struct vec&lt; T, 2 &gt; &lt;class T&gt; struct vec&lt; T, 3 &gt; &lt;class T&gt; struct vec&lt; T, 4 &gt; &lt;class T&gt; struct hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; &lt;class T, M&gt; struct hash&lt; linalg::vec&lt; T, 1 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 2 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 3 &gt; &gt; &lt;class T&gt; struct hash&lt; linalg::vec&lt; T, 4 &gt; &gt; &lt;class T&gt;"},{"location":"api/linalg_8hpp/#macros","title":"Macros","text":"Type Name define LINALG_CONSTEXPR14 define LINALG_H"},{"location":"api/linalg_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/linalg_8hpp/#define-linalg_constexpr14","title":"define LINALG_CONSTEXPR14","text":"<pre><code>#define LINALG_CONSTEXPR14 \n</code></pre>"},{"location":"api/linalg_8hpp/#define-linalg_h","title":"define LINALG_H","text":"<pre><code>#define LINALG_H \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/linalg.hpp</code></p>"},{"location":"api/linalg_8hpp_source/","title":"File linalg.hpp","text":"<p>File List &gt; common &gt; linalg.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// linalg.h - v2.0 - Single-header public domain linear algebra library\n//\n// The intent of this library is to provide the bulk of the functionality\n// you need to write programs that frequently use small, fixed-size vectors\n// and matrices, in domains such as computational geometry or computer\n// graphics. It strives for terse, readable source code.\n//\n// The original author of this software is Sterling Orsten, and its permanent\n// home is &lt;http://github.com/sgorsten/linalg/&gt;. If you find this software\n// useful, an acknowledgement in your source text and/or product documentation\n// is appreciated, but not required.\n//\n// The author acknowledges significant insights and contributions by:\n//     Stan Melax &lt;http://github.com/melax/&gt;\n//     Dimitri Diakopoulos &lt;http://github.com/ddiakopoulos/&gt;\n\n\n\n// This is free and unencumbered software released into the public domain.\n// \n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n// \n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n// \n// For more information, please refer to &lt;http://unlicense.org/&gt;\n\n\n\n#pragma once\n#ifndef LINALG_H\n#define LINALG_H\n\n#include &lt;cmath&gt;        // For various unary math functions, such as std::sqrt\n#include &lt;cstdlib&gt;      // To resolve std::abs ambiguity on clang\n#include &lt;cstdint&gt;      // For implementing namespace linalg::aliases\n#include &lt;array&gt;        // For std::array\n#include &lt;iosfwd&gt;       // For forward definitions of std::ostream\n#include &lt;type_traits&gt;  // For std::enable_if, std::is_same, std::declval\n\n// In Visual Studio 2015, `constexpr` applied to a member function implies `const`, which causes ambiguous overload resolution\n#if _MSC_VER &lt;= 1900\n#define LINALG_CONSTEXPR14\n#else\n#define LINALG_CONSTEXPR14 constexpr\n#endif\n\nnamespace linalg\n{\n    // Small, fixed-length vector type, consisting of exactly M elements of type T, and presumed to be a column-vector unless otherwise noted.\n    template&lt;class T, int M&gt; struct vec;\n\n    // Small, fixed-size matrix type, consisting of exactly M rows and N columns of type T, stored in column-major order.\n    template&lt;class T, int M, int N&gt; struct mat;\n\n    // Specialize converter&lt;T,U&gt; with a function application operator that converts type U to type T to enable implicit conversions\n    template&lt;class T, class U&gt; struct converter {};\n    namespace detail \n    { \n        template&lt;class T, class U&gt; using conv_t = typename std::enable_if&lt;!std::is_same&lt;T,U&gt;::value, decltype(converter&lt;T,U&gt;{}(std::declval&lt;U&gt;()))&gt;::type;\n\n        // Trait for retrieving scalar type of any linear algebra object\n        template&lt;class A&gt; struct scalar_type {};\n        template&lt;class T, int M       &gt; struct scalar_type&lt;vec&lt;T,M  &gt;&gt; { using type = T; };\n        template&lt;class T, int M, int N&gt; struct scalar_type&lt;mat&lt;T,M,N&gt;&gt; { using type = T; };\n\n        // Type returned by the compare(...) function which supports all six comparison operators against 0\n        template&lt;class T&gt; struct ord { T a,b; };\n        template&lt;class T&gt; constexpr bool operator == (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.a == o.b; }\n        template&lt;class T&gt; constexpr bool operator != (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.a == o.b); }\n        template&lt;class T&gt; constexpr bool operator &lt; (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.a &lt; o.b; }\n        template&lt;class T&gt; constexpr bool operator &gt; (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return o.b &lt; o.a; }\n        template&lt;class T&gt; constexpr bool operator &lt;= (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.b &lt; o.a); }\n        template&lt;class T&gt; constexpr bool operator &gt;= (const ord&lt;T&gt; &amp; o, std::nullptr_t) { return !(o.a &lt; o.b); }\n\n        // Patterns which can be used with the compare(...) function\n        template&lt;class A, class B&gt; struct any_compare {};\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,1&gt;,vec&lt;T,1&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,1&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) const { return ord&lt;T&gt;{a.x,b.x}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,2&gt;,vec&lt;T,2&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : ord&lt;T&gt;{a.y,b.y}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,3&gt;,vec&lt;T,3&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : !(a.y==b.y) ? ord&lt;T&gt;{a.y,b.y} : ord&lt;T&gt;{a.z,b.z}; } };\n        template&lt;class T&gt; struct any_compare&lt;vec&lt;T,4&gt;,vec&lt;T,4&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) const { return !(a.x==b.x) ? ord&lt;T&gt;{a.x,b.x} : !(a.y==b.y) ? ord&lt;T&gt;{a.y,b.y} : !(a.z==b.z) ? ord&lt;T&gt;{a.z,b.z} : ord&lt;T&gt;{a.w,b.w}; } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,1&gt;,mat&lt;T,M,1&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,1&gt; &amp; a, const mat&lt;T,M,1&gt; &amp; b) const { return compare(a.x,b.x); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,2&gt;,mat&lt;T,M,2&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,2&gt; &amp; a, const mat&lt;T,M,2&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : compare(a.y,b.y); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,3&gt;,mat&lt;T,M,3&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,3&gt; &amp; a, const mat&lt;T,M,3&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : a.y!=b.y ? compare(a.y,b.y) : compare(a.z,b.z); } };\n        template&lt;class T, int M&gt; struct any_compare&lt;mat&lt;T,M,4&gt;,mat&lt;T,M,4&gt;&gt; { using type=ord&lt;T&gt;; constexpr ord&lt;T&gt; operator() (const mat&lt;T,M,4&gt; &amp; a, const mat&lt;T,M,4&gt; &amp; b) const { return a.x!=b.x ? compare(a.x,b.x) : a.y!=b.y ? compare(a.y,b.y) : a.z!=b.z ? compare(a.z,b.z) : compare(a.w,b.w); } }; \n\n        // Helper for compile-time index-based access to members of vector and matrix types\n        template&lt;int I&gt; struct getter;\n        template&lt;&gt; struct getter&lt;0&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.x) { return a.x; } };\n        template&lt;&gt; struct getter&lt;1&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.y) { return a.y; } };\n        template&lt;&gt; struct getter&lt;2&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.z) { return a.z; } };\n        template&lt;&gt; struct getter&lt;3&gt; { template&lt;class A&gt; constexpr auto operator() (A &amp; a) const -&gt; decltype(a.w) { return a.w; } };\n\n        // Stand-in for std::integer_sequence/std::make_integer_sequence\n        template&lt;int... I&gt; struct seq {};\n        template&lt;int A, int N&gt; struct make_seq_impl;\n        template&lt;int A&gt; struct make_seq_impl&lt;A,0&gt; { using type=seq&lt;&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,1&gt; { using type=seq&lt;A+0&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,2&gt; { using type=seq&lt;A+0,A+1&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,3&gt; { using type=seq&lt;A+0,A+1,A+2&gt;; };\n        template&lt;int A&gt; struct make_seq_impl&lt;A,4&gt; { using type=seq&lt;A+0,A+1,A+2,A+3&gt;; };\n        template&lt;int A, int B&gt; using make_seq = typename make_seq_impl&lt;A,B-A&gt;::type;\n        template&lt;class T, int M, int... I&gt; vec&lt;T,sizeof...(I)&gt; constexpr swizzle(const vec&lt;T,M&gt; &amp; v, seq&lt;I...&gt; i) { return {getter&lt;I&gt;{}(v)...}; }\n        template&lt;class T, int M, int N, int... I, int... J&gt; mat&lt;T,sizeof...(I),sizeof...(J)&gt; constexpr swizzle(const mat&lt;T,M,N&gt; &amp; m, seq&lt;I...&gt; i, seq&lt;J...&gt; j) { return {swizzle(getter&lt;J&gt;{}(m),i)...}; }\n\n        // SFINAE helpers to determine result of function application\n        template&lt;class F, class... T&gt; using ret_t = decltype(std::declval&lt;F&gt;()(std::declval&lt;T&gt;()...));\n\n        // SFINAE helper which is defined if all provided types are scalars\n        struct empty {};\n        template&lt;class... T&gt; struct scalars;\n        template&lt;&gt; struct scalars&lt;&gt; { using type=void; };\n        template&lt;class T, class... U&gt; struct scalars&lt;T,U...&gt; : std::conditional&lt;std::is_arithmetic&lt;T&gt;::value, scalars&lt;U...&gt;, empty&gt;::type {};\n        template&lt;class... T&gt; using scalars_t = typename scalars&lt;T...&gt;::type;\n\n        // Helpers which indicate how apply(F, ...) should be called for various arguments\n        template&lt;class F, class Void, class... T&gt; struct apply {}; // Patterns which contain only vectors or scalars\n        template&lt;class F, int M, class A                  &gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;                    &gt; { using type=vec&lt;ret_t&lt;F,A    &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a                                        ) { return {f(getter&lt;I&gt;{}(a)                                )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;          &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b                    ) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b)                )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;B  &gt;, vec&lt;A,M&gt;, B                 &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b                    ) { return {f(getter&lt;I&gt;{}(a), b                             )...}; } };\n        template&lt;class F, int M, class A, class B         &gt; struct apply&lt;F, scalars_t&lt;A  &gt;, A,        vec&lt;B,M&gt;          &gt; { using type=vec&lt;ret_t&lt;F,A,B  &gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b                    ) { return {f(a,              getter&lt;I&gt;{}(b)                )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;   &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;, vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b, const vec&lt;C,M&gt; &amp; c) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b), getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;C  &gt;, vec&lt;A,M&gt;, vec&lt;B,M&gt;, C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, const vec&lt;B,M&gt; &amp; b, C                c) { return {f(getter&lt;I&gt;{}(a), getter&lt;I&gt;{}(b), c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;B  &gt;, vec&lt;A,M&gt;, B,        vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b, const vec&lt;C,M&gt; &amp; c) { return {f(getter&lt;I&gt;{}(a), b,              getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;B,C&gt;, vec&lt;A,M&gt;, B,        C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, const vec&lt;A,M&gt; &amp; a, B                b, C                c) { return {f(getter&lt;I&gt;{}(a), b,              c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A  &gt;, A,        vec&lt;B,M&gt;, vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b, const vec&lt;C,M&gt; &amp; c) { return {f(a,              getter&lt;I&gt;{}(b), getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A,C&gt;, A,        vec&lt;B,M&gt;, C       &gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, const vec&lt;B,M&gt; &amp; b, C                c) { return {f(a,              getter&lt;I&gt;{}(b), c             )...}; } };\n        template&lt;class F, int M, class A, class B, class C&gt; struct apply&lt;F, scalars_t&lt;A,B&gt;, A,        B,        vec&lt;C,M&gt;&gt; { using type=vec&lt;ret_t&lt;F,A,B,C&gt;,M&gt;; enum {size=M}; template&lt;int... I&gt; static constexpr type impl(seq&lt;I...&gt;, F f, A                a, B                b, const vec&lt;C,M&gt; &amp; c) { return {f(a,              b,              getter&lt;I&gt;{}(c))...}; } };\n        template&lt;class F, int M, int N, class A         &gt; struct apply&lt;F, scalars_t&lt; &gt;, mat&lt;A,M,N&gt;            &gt; { using type=mat&lt;ret_t&lt;F,A  &gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a                      ) { return {apply&lt;F, void, vec&lt;A,M&gt;          &gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a)                )...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt; &gt;, mat&lt;A,M,N&gt;, mat&lt;B,M,N&gt;&gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a, const mat&lt;B,M,N&gt; &amp; b) { return {apply&lt;F, void, vec&lt;A,M&gt;, vec&lt;B,M&gt;&gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a), getter&lt;J&gt;{}(b))...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt;B&gt;, mat&lt;A,M,N&gt;, B         &gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, const mat&lt;A,M,N&gt; &amp; a, B                  b) { return {apply&lt;F, void, vec&lt;A,M&gt;, B       &gt;::impl(make_seq&lt;0,M&gt;{}, f, getter&lt;J&gt;{}(a), b             )...}; } };\n        template&lt;class F, int M, int N, class A, class B&gt; struct apply&lt;F, scalars_t&lt;A&gt;, A,          mat&lt;B,M,N&gt;&gt; { using type=mat&lt;ret_t&lt;F,A,B&gt;,M,N&gt;; enum {size=N}; template&lt;int... J&gt; static constexpr type impl(seq&lt;J...&gt;, F f, A                  a, const mat&lt;B,M,N&gt; &amp; b) { return {apply&lt;F, void, A,        vec&lt;B,M&gt;&gt;::impl(make_seq&lt;0,M&gt;{}, f, a,              getter&lt;J&gt;{}(b))...}; } };\n        template&lt;class F, class... A&gt; struct apply&lt;F, scalars_t&lt;A...&gt;, A...&gt; { using type = ret_t&lt;F,A...&gt;; enum {size=0}; static constexpr type impl(seq&lt;&gt;, F f, A... a) { return f(a...); } };\n\n        // Function objects for selecting between alternatives\n        struct min    { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? a : b)&gt;::type { return a&lt;b ? a : b; } };\n        struct max    { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? b : a)&gt;::type { return a&lt;b ? b : a; } };\n        struct clamp  { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; typename std::remove_reference&lt;decltype(a&lt;b ? b : a&lt;c ? a : c)&gt;::type { return a&lt;b ? b : a&lt;c ? a : c; } };\n        struct select { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; typename std::remove_reference&lt;decltype(a ? b : c)&gt;::type             { return a ? b : c; } };\n        struct lerp   { template&lt;class A, class B, class C&gt; constexpr auto operator() (A a, B b, C c) const -&gt; decltype(a*(1-c) + b*c)                                               { return a*(1-c) + b*c; } };\n\n        // Function objects for applying operators\n        struct op_pos { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(+a) { return +a; } };\n        struct op_neg { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(-a) { return -a; } };\n        struct op_not { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(!a) { return !a; } };\n        struct op_cmp { template&lt;class A&gt; constexpr auto operator() (A a) const -&gt; decltype(~(a)) { return ~a; } };\n        struct op_mul { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a * b)  { return a * b; } };\n        struct op_div { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a / b)  { return a / b; } };\n        struct op_mod { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a % b)  { return a % b; } };\n        struct op_add { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a + b)  { return a + b; } };\n        struct op_sub { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a - b)  { return a - b; } };\n        struct op_lsh { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt;&lt; b) { return a &lt;&lt; b; } };\n        struct op_rsh { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt;&gt; b) { return a &gt;&gt; b; } };\n        struct op_lt  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt; b)  { return a &lt; b; } };\n        struct op_gt  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt; b)  { return a &gt; b; } };\n        struct op_le  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &lt;= b) { return a &lt;= b; } };\n        struct op_ge  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &gt;= b) { return a &gt;= b; } };\n        struct op_eq  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a == b) { return a == b; } };\n        struct op_ne  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a != b) { return a != b; } };\n        struct op_int { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &amp; b)  { return a &amp; b; } };        \n        struct op_xor { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a ^ b)  { return a ^ b; } };\n        struct op_un  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a | b)  { return a | b; } };\n        struct op_and { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a &amp;&amp; b) { return a &amp;&amp; b; } };\n        struct op_or  { template&lt;class A, class B&gt; constexpr auto operator() (A a, B b) const -&gt; decltype(a || b) { return a || b; } };\n\n        // Function objects for applying standard library math functions\n        struct std_abs      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::abs  (a)) { return std::abs  (a); } };\n        struct std_floor    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::floor(a)) { return std::floor(a); } };\n        struct std_ceil     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::ceil (a)) { return std::ceil (a); } };\n        struct std_exp      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::exp  (a)) { return std::exp  (a); } };\n        struct std_log      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::log  (a)) { return std::log  (a); } };\n        struct std_log10    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::log10(a)) { return std::log10(a); } };\n        struct std_sqrt     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sqrt (a)) { return std::sqrt (a); } };\n        struct std_sin      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sin  (a)) { return std::sin  (a); } };\n        struct std_cos      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::cos  (a)) { return std::cos  (a); } };\n        struct std_tan      { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::tan  (a)) { return std::tan  (a); } };\n        struct std_asin     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::asin (a)) { return std::asin (a); } };\n        struct std_acos     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::acos (a)) { return std::acos (a); } };\n        struct std_atan     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::atan (a)) { return std::atan (a); } };\n        struct std_sinh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::sinh (a)) { return std::sinh (a); } };\n        struct std_cosh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::cosh (a)) { return std::cosh (a); } };\n        struct std_tanh     { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::tanh (a)) { return std::tanh (a); } };\n        struct std_round    { template&lt;class A&gt; auto operator() (A a) const -&gt; decltype(std::round(a)) { return std::round(a); } };\n        struct std_fmod     { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::fmod    (a, b)) { return std::fmod    (a, b); } };\n        struct std_pow      { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::pow     (a, b)) { return std::pow     (a, b); } };\n        struct std_atan2    { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::atan2   (a, b)) { return std::atan2   (a, b); } };\n        struct std_copysign { template&lt;class A, class B&gt; auto operator() (A a, B b) const -&gt; decltype(std::copysign(a, b)) { return std::copysign(a, b); } };\n    }\n\n    // Small, fixed-length vector type, consisting of exactly M elements of type T, and presumed to be a column-vector unless otherwise noted\n    template&lt;class T&gt; struct vec&lt;T,1&gt;\n    {\n        T                           x;\n        constexpr                   vec()                               : x() {}\n        constexpr                   vec(const T &amp; x_)                   : x(x_) {}\n        // NOTE: vec&lt;T,1&gt; does NOT have a constructor from pointer, this can conflict with initializing its single element from zero\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,1&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return x; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return x; }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,2&gt;\n    {\n        T                           x,y;\n        constexpr                   vec()                               : x(), y() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_)     : x(x_), y(y_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1]) {}\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,2&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:y; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:y; }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,3&gt;\n    {\n        T                           x,y,z;\n        constexpr                   vec()                               : x(), y(), z() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_, \n                                        const T &amp; z_)                   : x(x_), y(y_), z(z_) {}\n        constexpr                   vec(const vec&lt;T,2&gt; &amp; xy,\n                                        const T &amp; z_)                   : vec(xy.x, xy.y, z_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1], p[2]) {}\n        template&lt;class U&gt;\n        constexpr explicit          vec(const vec&lt;U,3&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y), static_cast&lt;T&gt;(v.z)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:i==1?y:z; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:i==1?y:z; }\n        constexpr const vec&lt;T,2&gt; &amp;  xy() const                          { return *reinterpret_cast&lt;const vec&lt;T,2&gt; *&gt;(this); }\n        vec&lt;T,2&gt; &amp;                  xy()                                { return *reinterpret_cast&lt;vec&lt;T,2&gt; *&gt;(this); }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n    template&lt;class T&gt; struct vec&lt;T,4&gt;\n    {\n        T                           x,y,z,w;\n        constexpr                   vec()                               : x(), y(), z(), w() {}\n        constexpr                   vec(const T &amp; x_, const T &amp; y_,\n                                        const T &amp; z_, const T &amp; w_)     : x(x_), y(y_), z(z_), w(w_) {}\n        constexpr                   vec(const vec&lt;T,2&gt; &amp; xy, \n                                        const T &amp; z_, const T &amp; w_)     : vec(xy.x, xy.y, z_, w_) {}\n        constexpr                   vec(const vec&lt;T,3&gt; &amp; xyz,\n                                        const T &amp; w_)                   : vec(xyz.x, xyz.y, xyz.z, w_) {}\n        constexpr explicit          vec(const T &amp; s)                    : vec(s, s, s, s) {}\n        constexpr explicit          vec(const T * p)                    : vec(p[0], p[1], p[2], p[3]) {}\n        template&lt;class U&gt; \n        constexpr explicit          vec(const vec&lt;U,4&gt; &amp; v)             : vec(static_cast&lt;T&gt;(v.x), static_cast&lt;T&gt;(v.y), static_cast&lt;T&gt;(v.z), static_cast&lt;T&gt;(v.w)) {}\n        constexpr const T &amp;         operator[] (int i) const            { return i==0?x:i==1?y:i==2?z:w; }\n        LINALG_CONSTEXPR14 T &amp;      operator[] (int i)                  { return i==0?x:i==1?y:i==2?z:w; }\n        constexpr const vec&lt;T,2&gt; &amp;  xy() const                          { return *reinterpret_cast&lt;const vec&lt;T,2&gt; *&gt;(this); }\n        constexpr const vec&lt;T,3&gt; &amp;  xyz() const                         { return *reinterpret_cast&lt;const vec&lt;T,3&gt; *&gt;(this); }\n        vec&lt;T,2&gt; &amp;                  xy()                                { return *reinterpret_cast&lt;vec&lt;T,2&gt; *&gt;(this); }                \n        vec&lt;T,3&gt; &amp;                  xyz()                               { return *reinterpret_cast&lt;vec&lt;T,3&gt; *&gt;(this); }\n\n        template&lt;class U, class=detail::conv_t&lt;vec,U&gt;&gt; constexpr vec(const U &amp; u) : vec(converter&lt;vec,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,vec&gt;&gt; constexpr operator U () const { return converter&lt;U,vec&gt;{}(*this); }\n    };\n\n    // Small, fixed-size matrix type, consisting of exactly M rows and N columns of type T, stored in column-major order.\n    template&lt;class T, int M&gt; struct mat&lt;T,M,1&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x;\n        constexpr                   mat()                               : x() {}\n        constexpr                   mat(const V &amp; x_)                   : x(x_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,1&gt; &amp; m)           : mat(V(m.x)) {}\n        constexpr vec&lt;T,1&gt;          row(int i) const                    { return {x[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return x; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return x; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,2&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y;\n        constexpr                   mat()                               : x(), y() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_)     : x(x_), y(y_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,2&gt; &amp; m)           : mat(V(m.x), V(m.y)) {}\n        constexpr vec&lt;T,2&gt;          row(int i) const                    { return {x[i], y[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:y; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:y; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,3&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y,z;\n        constexpr                   mat()                               : x(), y(), z() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_, \n                                        const V &amp; z_)                   : x(x_), y(y_), z(z_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s), z(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1), z(p+M*2) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,3&gt; &amp; m)           : mat(V(m.x), V(m.y), V(m.z)) {}\n        constexpr vec&lt;T,3&gt;          row(int i) const                    { return {x[i], y[i], z[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:j==1?y:z; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:j==1?y:z; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n    template&lt;class T, int M&gt; struct mat&lt;T,M,4&gt;\n    {\n        typedef vec&lt;T,M&gt;            V;\n        V                           x,y,z,w;\n        constexpr                   mat()                               : x(), y(), z(), w() {}\n        constexpr                   mat(const V &amp; x_, const V &amp; y_,\n                                        const V &amp; z_, const V &amp; w_)     : x(x_), y(y_), z(z_), w(w_) {}\n        constexpr explicit          mat(const T &amp; s)                    : x(s), y(s), z(s), w(s) {}\n        constexpr explicit          mat(const T * p)                    : x(p+M*0), y(p+M*1), z(p+M*2), w(p+M*3) {}\n        template&lt;class U&gt; \n        constexpr explicit          mat(const mat&lt;U,M,4&gt; &amp; m)           : mat(V(m.x), V(m.y), V(m.z), V(m.w)) {}\n        constexpr vec&lt;T,4&gt;          row(int i) const                    { return {x[i], y[i], z[i], w[i]}; }\n        constexpr const V &amp;         operator[] (int j) const            { return j==0?x:j==1?y:j==2?z:w; }\n        LINALG_CONSTEXPR14 V &amp;      operator[] (int j)                  { return j==0?x:j==1?y:j==2?z:w; }\n\n        template&lt;class U, class=detail::conv_t&lt;mat,U&gt;&gt; constexpr mat(const U &amp; u) : mat(converter&lt;mat,U&gt;{}(u)) {}\n        template&lt;class U, class=detail::conv_t&lt;U,mat&gt;&gt; constexpr operator U () const { return converter&lt;U,mat&gt;{}(*this); }\n    };\n\n    // Define a type which will convert to the multiplicative identity of any square matrix\n    struct identity_t { constexpr explicit identity_t(int) {} };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,1,1&gt;, identity_t&gt; { mat&lt;T,1,1&gt; operator() (identity_t) const { return {vec&lt;T,1&gt;{1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,2,2&gt;, identity_t&gt; { mat&lt;T,2,2&gt; operator() (identity_t) const { return {{1,0},{0,1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,3,3&gt;, identity_t&gt; { mat&lt;T,3,3&gt; operator() (identity_t) const { return {{1,0,0},{0,1,0},{0,0,1}}; } };\n    template&lt;class T&gt; struct converter&lt;mat&lt;T,4,4&gt;, identity_t&gt; { mat&lt;T,4,4&gt; operator() (identity_t) const { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}; } };\n    constexpr identity_t identity {1};\n\n    // Produce a scalar by applying f(A,B) -&gt; A to adjacent pairs of elements from a vec/mat in left-to-right/column-major order (matching the associativity of arithmetic and logical operators)\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,1&gt; &amp; b) { return f(a, b.x); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,2&gt; &amp; b) { return f(f(a, b.x), b.y); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,3&gt; &amp; b) { return f(f(f(a, b.x), b.y), b.z); }\n    template&lt;class F, class A, class B&gt; constexpr A fold(F f, A a, const vec&lt;B,4&gt; &amp; b) { return f(f(f(f(a, b.x), b.y), b.z), b.w); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,1&gt; &amp; b) { return fold(f, a, b.x); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,2&gt; &amp; b) { return fold(f, fold(f, a, b.x), b.y); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,3&gt; &amp; b) { return fold(f, fold(f, fold(f, a, b.x), b.y), b.z); }\n    template&lt;class F, class A, class B, int M&gt; constexpr A fold(F f, A a, const mat&lt;B,M,4&gt; &amp; b) { return fold(f, fold(f, fold(f, fold(f, a, b.x), b.y), b.z), b.w); }\n\n    // Type aliases for the result of calling apply(...) with various arguments, can be used with return type SFINAE to constrian overload sets\n    template&lt;class F, class... A&gt; using apply_t = typename detail::apply&lt;F,void,A...&gt;::type;\n    template&lt;class A&gt; using scalar_t = typename detail::scalar_type&lt;A&gt;::type; // Underlying scalar type when performing elementwise operations\n\n    // apply(f,...) applies the provided function in an elementwise fashion to its arguments, producing an object of the same dimensions\n    template&lt;class F, class... A&gt; constexpr apply_t&lt;F,A...&gt; apply(F func, const A &amp; ... args) { return detail::apply&lt;F,void,A...&gt;::impl(detail::make_seq&lt;0,detail::apply&lt;F,void,A...&gt;::size&gt;{}, func, args...); }\n\n    // map(a,f) is equivalent to apply(f,a)\n    template&lt;class A, class F&gt; constexpr apply_t&lt;F,A&gt; map(const A &amp; a, F func) { return apply(func, a); }\n\n    // zip(a,b,f) is equivalent to apply(f,a,b)\n    template&lt;class A, class B, class F&gt; constexpr apply_t&lt;F,A,B&gt; zip(const A &amp; a, const B &amp; b, F func) { return apply(func, a, b); }\n\n    // Relational operators are defined to compare the elements of two vectors or matrices lexicographically, in column-major order\n    template&lt;class A, class B&gt; constexpr typename detail::any_compare&lt;A,B&gt;::type compare(const A &amp; a, const B &amp; b) { return detail::any_compare&lt;A,B&gt;()(a,b); }\n    template&lt;class A, class B&gt; constexpr auto operator == (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) == 0) { return compare(a,b) == 0; }\n    template&lt;class A, class B&gt; constexpr auto operator != (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) != 0) { return compare(a,b) != 0; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;  (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &lt;  0) { return compare(a,b) &lt;  0; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;  (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &gt;  0) { return compare(a,b) &gt;  0; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;= (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &lt;= 0) { return compare(a,b) &lt;= 0; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;= (const A &amp; a, const B &amp; b) -&gt; decltype(compare(a,b) &gt;= 0) { return compare(a,b) &gt;= 0; }\n\n    // Functions for coalescing scalar values\n    template&lt;class A&gt; constexpr bool any (const A &amp; a) { return fold(detail::op_or{}, false, a); }\n    template&lt;class A&gt; constexpr bool all (const A &amp; a) { return fold(detail::op_and{}, true, a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; sum    (const A &amp; a) { return fold(detail::op_add{}, scalar_t&lt;A&gt;(0), a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; product(const A &amp; a) { return fold(detail::op_mul{}, scalar_t&lt;A&gt;(1), a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; minelem(const A &amp; a) { return fold(detail::min{}, a.x, a); }\n    template&lt;class A&gt; constexpr scalar_t&lt;A&gt; maxelem(const A &amp; a) { return fold(detail::max{}, a.x, a); }\n    template&lt;class T, int M&gt; int argmin(const vec&lt;T,M&gt; &amp; a) { int j=0; for(int i=1; i&lt;M; ++i) if(a[i] &lt; a[j]) j = i; return j; }\n    template&lt;class T, int M&gt; int argmax(const vec&lt;T,M&gt; &amp; a) { int j=0; for(int i=1; i&lt;M; ++i) if(a[i] &gt; a[j]) j = i; return j; }\n\n    // Unary operators are defined component-wise for linalg types\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_pos, A&gt; operator + (const A &amp; a) { return apply(detail::op_pos{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_neg, A&gt; operator - (const A &amp; a) { return apply(detail::op_neg{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_cmp, A&gt; operator ~ (const A &amp; a) { return apply(detail::op_cmp{}, a); }\n    template&lt;class A&gt; constexpr apply_t&lt;detail::op_not, A&gt; operator ! (const A &amp; a) { return apply(detail::op_not{}, a); }\n\n    // Binary operators are defined component-wise for linalg types\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_add, A, B&gt; operator +  (const A &amp; a, const B &amp; b) { return apply(detail::op_add{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_sub, A, B&gt; operator -  (const A &amp; a, const B &amp; b) { return apply(detail::op_sub{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_mul, A, B&gt; operator *  (const A &amp; a, const B &amp; b) { return apply(detail::op_mul{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_div, A, B&gt; operator /  (const A &amp; a, const B &amp; b) { return apply(detail::op_div{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_mod, A, B&gt; operator %  (const A &amp; a, const B &amp; b) { return apply(detail::op_mod{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_un,  A, B&gt; operator |  (const A &amp; a, const B &amp; b) { return apply(detail::op_un{},  a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_xor, A, B&gt; operator ^  (const A &amp; a, const B &amp; b) { return apply(detail::op_xor{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_int, A, B&gt; operator &amp;  (const A &amp; a, const B &amp; b) { return apply(detail::op_int{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_lsh, A, B&gt; operator &lt;&lt; (const A &amp; a, const B &amp; b) { return apply(detail::op_lsh{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_rsh, A, B&gt; operator &gt;&gt; (const A &amp; a, const B &amp; b) { return apply(detail::op_rsh{}, a, b); }\n\n    // Binary assignment operators a $= b is always defined as though it were explicitly written a = a $ b\n    template&lt;class A, class B&gt; constexpr auto operator +=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a + b) { return a = a + b; }\n    template&lt;class A, class B&gt; constexpr auto operator -=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a - b) { return a = a - b; }\n    template&lt;class A, class B&gt; constexpr auto operator *=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a * b) { return a = a * b; }\n    template&lt;class A, class B&gt; constexpr auto operator /=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a / b) { return a = a / b; }\n    template&lt;class A, class B&gt; constexpr auto operator %=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a % b) { return a = a % b; }\n    template&lt;class A, class B&gt; constexpr auto operator |=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a | b) { return a = a | b; }\n    template&lt;class A, class B&gt; constexpr auto operator ^=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a ^ b) { return a = a ^ b; }\n    template&lt;class A, class B&gt; constexpr auto operator &amp;=  (A &amp; a, const B &amp; b) -&gt; decltype(a = a &amp; b) { return a = a &amp; b; }\n    template&lt;class A, class B&gt; constexpr auto operator &lt;&lt;= (A &amp; a, const B &amp; b) -&gt; decltype(a = a &lt;&lt; b) { return a = a &lt;&lt; b; }\n    template&lt;class A, class B&gt; constexpr auto operator &gt;&gt;= (A &amp; a, const B &amp; b) -&gt; decltype(a = a &gt;&gt; b) { return a = a &gt;&gt; b; }\n\n    // Swizzles and subobjects\n    template&lt;int... I, class T, int M&gt;                              constexpr vec&lt;T,sizeof...(I)&gt;   swizzle(const vec&lt;T,M&gt; &amp; a)   { return {detail::getter&lt;I&gt;(a)...}; }\n    template&lt;int I0, int I1, class T, int M&gt;                        constexpr vec&lt;T,I1-I0&gt;          subvec (const vec&lt;T,M&gt; &amp; a)   { return detail::swizzle(a, detail::make_seq&lt;I0,I1&gt;{}); }\n    template&lt;int I0, int J0, int I1, int J1, class T, int M, int N&gt; constexpr mat&lt;T,I1-I0,J1-J0&gt;    submat (const mat&lt;T,M,N&gt; &amp; a) { return detail::swizzle(a, detail::make_seq&lt;I0,I1&gt;{}, detail::make_seq&lt;J0,J1&gt;{}); }\n\n    // Component-wise standard library math functions\n    template&lt;class A&gt; apply_t&lt;detail::std_abs,   A&gt; abs  (const A &amp; a) { return apply(detail::std_abs{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_floor, A&gt; floor(const A &amp; a) { return apply(detail::std_floor{}, a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_ceil,  A&gt; ceil (const A &amp; a) { return apply(detail::std_ceil{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_exp,   A&gt; exp  (const A &amp; a) { return apply(detail::std_exp{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_log,   A&gt; log  (const A &amp; a) { return apply(detail::std_log{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_log10, A&gt; log10(const A &amp; a) { return apply(detail::std_log10{}, a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sqrt,  A&gt; sqrt (const A &amp; a) { return apply(detail::std_sqrt{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sin,   A&gt; sin  (const A &amp; a) { return apply(detail::std_sin{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_cos,   A&gt; cos  (const A &amp; a) { return apply(detail::std_cos{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_tan,   A&gt; tan  (const A &amp; a) { return apply(detail::std_tan{},   a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_asin,  A&gt; asin (const A &amp; a) { return apply(detail::std_asin{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_acos,  A&gt; acos (const A &amp; a) { return apply(detail::std_acos{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_atan,  A&gt; atan (const A &amp; a) { return apply(detail::std_atan{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_sinh,  A&gt; sinh (const A &amp; a) { return apply(detail::std_sinh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_cosh,  A&gt; cosh (const A &amp; a) { return apply(detail::std_cosh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_tanh,  A&gt; tanh (const A &amp; a) { return apply(detail::std_tanh{},  a); }\n    template&lt;class A&gt; apply_t&lt;detail::std_round, A&gt; round(const A &amp; a) { return apply(detail::std_round{}, a); }\n\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_fmod,     A, B&gt; fmod    (const A &amp; a, const B &amp; b) { return apply(detail::std_fmod{},     a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_pow,      A, B&gt; pow     (const A &amp; a, const B &amp; b) { return apply(detail::std_pow{},      a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_atan2,    A, B&gt; atan2   (const A &amp; a, const B &amp; b) { return apply(detail::std_atan2{},    a, b); }\n    template&lt;class A, class B&gt; apply_t&lt;detail::std_copysign, A, B&gt; copysign(const A &amp; a, const B &amp; b) { return apply(detail::std_copysign{}, a, b); }\n\n    // Component-wise relational functions on vectors\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_eq, A, B&gt; equal  (const A &amp; a, const B &amp; b) { return apply(detail::op_eq{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_ne, A, B&gt; nequal (const A &amp; a, const B &amp; b) { return apply(detail::op_ne{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_lt, A, B&gt; less   (const A &amp; a, const B &amp; b) { return apply(detail::op_lt{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_gt, A, B&gt; greater(const A &amp; a, const B &amp; b) { return apply(detail::op_gt{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_le, A, B&gt; lequal (const A &amp; a, const B &amp; b) { return apply(detail::op_le{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::op_ge, A, B&gt; gequal (const A &amp; a, const B &amp; b) { return apply(detail::op_ge{}, a, b); }\n\n    // Component-wise selection functions on vectors\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::min, A, B&gt; min(const A &amp; a, const B &amp; b) { return apply(detail::min{}, a, b); }\n    template&lt;class A, class B&gt; constexpr apply_t&lt;detail::max, A, B&gt; max(const A &amp; a, const B &amp; b) { return apply(detail::max{}, a, b); }\n    template&lt;class X, class L, class H&gt; constexpr apply_t&lt;detail::clamp,  X, L, H&gt; clamp (const X &amp; x, const L &amp; l, const H &amp; h) { return apply(detail::clamp{},  x, l, h); }\n    template&lt;class P, class A, class B&gt; constexpr apply_t&lt;detail::select, P, A, B&gt; select(const P &amp; p, const A &amp; a, const B &amp; b) { return apply(detail::select{}, p, a, b); }\n    template&lt;class A, class B, class T&gt; constexpr apply_t&lt;detail::lerp,   A, B, T&gt; lerp  (const A &amp; a, const B &amp; b, const T &amp; t) { return apply(detail::lerp{},   a, b, t); }\n\n    // Support for vector algebra\n    template&lt;class T&gt; constexpr T        cross    (const vec&lt;T,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b)      { return a.x*b.y-a.y*b.x; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; cross    (T a, const vec&lt;T,2&gt; &amp; b)                     { return {-a*b.y, a*b.x}; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; cross    (const vec&lt;T,2&gt; &amp; a, T b)                     { return {a.y*b, -a.x*b}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt; cross    (const vec&lt;T,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b)      { return {a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x}; }\n    template&lt;class T, int M&gt; constexpr T dot      (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return sum(a*b); }\n    template&lt;class T, int M&gt; constexpr T length2  (const vec&lt;T,M&gt; &amp; a)                          { return dot(a,a); }\n    template&lt;class T, int M&gt; T           length   (const vec&lt;T,M&gt; &amp; a)                          { return std::sqrt(length2(a)); }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    normalize(const vec&lt;T,M&gt; &amp; a)                          { return a / length(a); }\n    template&lt;class T, int M&gt; constexpr T distance2(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return length2(b-a); }\n    template&lt;class T, int M&gt; T           distance (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return length(b-a); }\n    template&lt;class T, int M&gt; T           uangle   (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { T d=dot(a,b); return d &gt; 1 ? 0 : std::acos(d &lt; -1 ? -1 : d); }\n    template&lt;class T, int M&gt; T           angle    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b)      { return uangle(normalize(a), normalize(b)); }\n    template&lt;class T&gt; vec&lt;T,2&gt;           rot      (T a, const vec&lt;T,2&gt; &amp; v)                     { const T s = std::sin(a), c = std::cos(a); return {v.x*c - v.y*s, v.x*s + v.y*c}; }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    nlerp    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b, T t) { return normalize(lerp(a,b,t)); }\n    template&lt;class T, int M&gt; vec&lt;T,M&gt;    slerp    (const vec&lt;T,M&gt; &amp; a, const vec&lt;T,M&gt; &amp; b, T t) { T th=uangle(a,b); return th == 0 ? a : a*(std::sin(th*(1-t))/std::sin(th)) + b*(std::sin(th*t)/std::sin(th)); }\n\n    // Support for quaternion algebra using 4D vectors, representing xi + yj + zk + w\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; qconj(const vec&lt;T,4&gt; &amp; q)                     { return {-q.x,-q.y,-q.z,q.w}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qinv (const vec&lt;T,4&gt; &amp; q)                     { return qconj(q)/length2(q); }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qexp (const vec&lt;T,4&gt; &amp; q)                     { const auto v = q.xyz(); const auto vv = length(v); return std::exp(q.w) * vec&lt;T,4&gt;{v * (vv &gt; 0 ? std::sin(vv)/vv : 0), std::cos(vv)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qlog (const vec&lt;T,4&gt; &amp; q)                     { const auto v = q.xyz(); const auto vv = length(v), qq = length(q); return {v * (vv &gt; 0 ? std::acos(q.w/qq)/vv : 0), std::log(qq)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;           qpow (const vec&lt;T,4&gt; &amp; q, const T &amp; p)        { const auto v = q.xyz(); const auto vv = length(v), qq = length(q), th = std::acos(q.w/qq); return std::pow(qq,p)*vec&lt;T,4&gt;{v * (vv &gt; 0 ? std::sin(p*th)/vv : 0), std::cos(p*th)}; }\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; qmul (const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return {a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y, a.y*b.w+a.w*b.y+a.z*b.x-a.x*b.z, a.z*b.w+a.w*b.z+a.x*b.y-a.y*b.x, a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z}; }\n    template&lt;class T, class... R&gt; constexpr vec&lt;T,4&gt; qmul(const vec&lt;T,4&gt; &amp; a, R... r)  { return qmul(a, qmul(r...)); }\n\n    // Support for 3D spatial rotations using quaternions, via qmul(qmul(q, v), qconj(q))\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qxdir (const vec&lt;T,4&gt; &amp; q)                          { return {q.w*q.w+q.x*q.x-q.y*q.y-q.z*q.z, (q.x*q.y+q.z*q.w)*2, (q.z*q.x-q.y*q.w)*2}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qydir (const vec&lt;T,4&gt; &amp; q)                          { return {(q.x*q.y-q.z*q.w)*2, q.w*q.w-q.x*q.x+q.y*q.y-q.z*q.z, (q.y*q.z+q.x*q.w)*2}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qzdir (const vec&lt;T,4&gt; &amp; q)                          { return {(q.z*q.x+q.y*q.w)*2, (q.y*q.z-q.x*q.w)*2, q.w*q.w-q.x*q.x-q.y*q.y+q.z*q.z}; }\n    template&lt;class T&gt; constexpr mat&lt;T,3,3&gt; qmat  (const vec&lt;T,4&gt; &amp; q)                          { return {qxdir(q), qydir(q), qzdir(q)}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt;   qrot  (const vec&lt;T,4&gt; &amp; q, const vec&lt;T,3&gt; &amp; v)      { return qxdir(q)*v.x + qydir(q)*v.y + qzdir(q)*v.z; }\n    template&lt;class T&gt; T                    qangle(const vec&lt;T,4&gt; &amp; q)                          { return std::atan2(length(q.xyz()), q.w)*2; }\n    template&lt;class T&gt; vec&lt;T,3&gt;             qaxis (const vec&lt;T,4&gt; &amp; q)                          { return normalize(q.xyz()); }\n    template&lt;class T&gt; vec&lt;T,4&gt;             qnlerp(const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b, T t) { return nlerp(a, dot(a,b) &lt; 0 ? -b : b, t); }\n    template&lt;class T&gt; vec&lt;T,4&gt;             qslerp(const vec&lt;T,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b, T t) { return slerp(a, dot(a,b) &lt; 0 ? -b : b, t); }\n\n    // Support for matrix algebra\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,1&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) { return a.x*b.x; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,2&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) { return a.x*b.x + a.y*b.y; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,3&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n    template&lt;class T, int M&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,4&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,1&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,1&gt; &amp; b) { return {mul(a,b.x)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,2&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,2&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,3&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,3&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y), mul(a,b.z)}; }\n    template&lt;class T, int M, int N&gt; constexpr mat&lt;T,M,4&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,4&gt; &amp; b) { return {mul(a,b.x), mul(a,b.y), mul(a,b.z), mul(a,b.w)}; }\n    template&lt;class T, int M, int N, int P&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const vec&lt;T,P&gt; &amp; c) { return mul(mul(a,b),c); }\n    template&lt;class T, int M, int N, int P, int Q&gt; constexpr mat&lt;T,M,Q&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c) { return mul(mul(a,b),c); }\n    template&lt;class T, int M, int N, int P, int Q&gt; constexpr vec&lt;T,M&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c, const vec&lt;T,Q&gt; &amp; d) { return mul(mul(a,b,c),d); }\n    template&lt;class T, int M, int N, int P, int Q, int R&gt; constexpr mat&lt;T,M,R&gt; mul(const mat&lt;T,M,N&gt; &amp; a, const mat&lt;T,N,P&gt; &amp; b, const mat&lt;T,P,Q&gt; &amp; c, const mat&lt;T,Q,R&gt; &amp; d) { return mul(mul(a,b,c),d); }\n    // TODO: Variadic version of mul(...) that works on all compilers\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,1&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,1&gt; &amp; b) { return {a*b.x}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,2&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,2&gt; &amp; b) { return {a*b.x, a*b.y}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,3&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,3&gt; &amp; b) { return {a*b.x, a*b.y, a*b.z}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,4&gt; outerprod(const vec&lt;T,M&gt; &amp; a, const vec&lt;T,4&gt; &amp; b) { return {a*b.x, a*b.y, a*b.z, a*b.w}; }\n    template&lt;class T&gt; constexpr vec&lt;T,1&gt; diagonal(const mat&lt;T,1,1&gt; &amp; a) { return {a.x.x}; }\n    template&lt;class T&gt; constexpr vec&lt;T,2&gt; diagonal(const mat&lt;T,2,2&gt; &amp; a) { return {a.x.x, a.y.y}; }\n    template&lt;class T&gt; constexpr vec&lt;T,3&gt; diagonal(const mat&lt;T,3,3&gt; &amp; a) { return {a.x.x, a.y.y, a.z.z}; }\n    template&lt;class T&gt; constexpr vec&lt;T,4&gt; diagonal(const mat&lt;T,4,4&gt; &amp; a) { return {a.x.x, a.y.y, a.z.z, a.w.w}; }\n    template&lt;class T, int N&gt; constexpr T trace(const mat&lt;T,N,N&gt; &amp; a) { return sum(diagonal(a)); }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,1&gt; transpose(const mat&lt;T,1,M&gt; &amp; m) { return {m.row(0)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,2&gt; transpose(const mat&lt;T,2,M&gt; &amp; m) { return {m.row(0), m.row(1)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,3&gt; transpose(const mat&lt;T,3,M&gt; &amp; m) { return {m.row(0), m.row(1), m.row(2)}; }\n    template&lt;class T, int M&gt; constexpr mat&lt;T,M,4&gt; transpose(const mat&lt;T,4,M&gt; &amp; m) { return {m.row(0), m.row(1), m.row(2), m.row(3)}; }\n    template&lt;class T&gt; constexpr mat&lt;T,1,1&gt; adjugate(const mat&lt;T,1,1&gt; &amp; a) { return {vec&lt;T,1&gt;{1}}; }\n    template&lt;class T&gt; constexpr mat&lt;T,2,2&gt; adjugate(const mat&lt;T,2,2&gt; &amp; a) { return {{a.y.y, -a.x.y}, {-a.y.x, a.x.x}}; }\n    template&lt;class T&gt; constexpr mat&lt;T,3,3&gt; adjugate(const mat&lt;T,3,3&gt; &amp; a);\n    template&lt;class T&gt; constexpr mat&lt;T,4,4&gt; adjugate(const mat&lt;T,4,4&gt; &amp; a);\n    template&lt;class T, int N&gt; constexpr mat&lt;T,N,N&gt; comatrix(const mat&lt;T,N,N&gt; &amp; a) { return transpose(adjugate(a)); }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,1,1&gt; &amp; a) { return a.x.x; }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,2,2&gt; &amp; a) { return a.x.x*a.y.y - a.x.y*a.y.x; }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,3,3&gt; &amp; a) { return a.x.x*(a.y.y*a.z.z - a.z.y*a.y.z) + a.x.y*(a.y.z*a.z.x - a.z.z*a.y.x) + a.x.z*(a.y.x*a.z.y - a.z.x*a.y.y); }\n    template&lt;class T&gt; constexpr T determinant(const mat&lt;T,4,4&gt; &amp; a);\n    template&lt;class T, int N&gt; constexpr mat&lt;T,N,N&gt; inverse(const mat&lt;T,N,N&gt; &amp; a) { return adjugate(a)/determinant(a); }\n\n    // Vectors and matrices can be used as ranges\n    template&lt;class T, int M&gt;       T * begin(      vec&lt;T,M&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M&gt; const T * begin(const vec&lt;T,M&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M&gt;       T * end  (      vec&lt;T,M&gt; &amp; a) { return begin(a) + M; }\n    template&lt;class T, int M&gt; const T * end  (const vec&lt;T,M&gt; &amp; a) { return begin(a) + M; }\n    template&lt;class T, int M, int N&gt;       vec&lt;T,M&gt; * begin(      mat&lt;T,M,N&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M, int N&gt; const vec&lt;T,M&gt; * begin(const mat&lt;T,M,N&gt; &amp; a) { return &amp;a.x; }\n    template&lt;class T, int M, int N&gt;       vec&lt;T,M&gt; * end  (      mat&lt;T,M,N&gt; &amp; a) { return begin(a) + N; }\n    template&lt;class T, int M, int N&gt; const vec&lt;T,M&gt; * end  (const mat&lt;T,M,N&gt; &amp; a) { return begin(a) + N; }\n\n    // Factory functions for 3D spatial transformations (will possibly be removed or changed in a future version)\n    enum fwd_axis { neg_z, pos_z };                 // Should projection matrices be generated assuming forward is {0,0,-1} or {0,0,1}\n    enum z_range { neg_one_to_one, zero_to_one };   // Should projection matrices map z into the range of [-1,1] or [0,1]?\n    template&lt;class T&gt; vec&lt;T,4&gt;   rotation_quat     (const vec&lt;T,3&gt; &amp; axis, T angle)         { return {axis*std::sin(angle/2), std::cos(angle/2)}; }\n    template&lt;class T&gt; vec&lt;T,4&gt;   rotation_quat     (const mat&lt;T,3,3&gt; &amp; m);\n    template&lt;class T&gt; mat&lt;T,4,4&gt; translation_matrix(const vec&lt;T,3&gt; &amp; translation)           { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{translation,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; rotation_matrix   (const vec&lt;T,4&gt; &amp; rotation)              { return {{qxdir(rotation),0}, {qydir(rotation),0}, {qzdir(rotation),0}, {0,0,0,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; scaling_matrix    (const vec&lt;T,3&gt; &amp; scaling)               { return {{scaling.x,0,0,0}, {0,scaling.y,0,0}, {0,0,scaling.z,0}, {0,0,0,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; pose_matrix       (const vec&lt;T,4&gt; &amp; q, const vec&lt;T,3&gt; &amp; p) { return {{qxdir(q),0}, {qydir(q),0}, {qzdir(q),0}, {p,1}}; }\n    template&lt;class T&gt; mat&lt;T,4,4&gt; frustum_matrix    (T x0, T x1, T y0, T y1, T n, T f, fwd_axis a = neg_z, z_range z = neg_one_to_one);\n    template&lt;class T&gt; mat&lt;T,4,4&gt; perspective_matrix(T fovy, T aspect, T n, T f, fwd_axis a = neg_z, z_range z = neg_one_to_one) { T y = n*std::tan(fovy / 2), x = y*aspect; return frustum_matrix(-x, x, -y, y, n, f, a, z); }\n\n    // Provide implicit conversion between linalg::vec&lt;T,M&gt; and std::array&lt;T,M&gt;\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,1&gt;, std::array&lt;T,1&gt;&gt; { vec&lt;T,1&gt; operator() (const std::array&lt;T,1&gt; &amp; a) const { return {a[0]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,2&gt;, std::array&lt;T,2&gt;&gt; { vec&lt;T,2&gt; operator() (const std::array&lt;T,2&gt; &amp; a) const { return {a[0], a[1]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,3&gt;, std::array&lt;T,3&gt;&gt; { vec&lt;T,3&gt; operator() (const std::array&lt;T,3&gt; &amp; a) const { return {a[0], a[1], a[2]}; } };\n    template&lt;class T&gt; struct converter&lt;vec&lt;T,4&gt;, std::array&lt;T,4&gt;&gt; { vec&lt;T,4&gt; operator() (const std::array&lt;T,4&gt; &amp; a) const { return {a[0], a[1], a[2], a[3]}; } };\n\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,1&gt;, vec&lt;T,1&gt;&gt; { std::array&lt;T,1&gt; operator() (const vec&lt;T,1&gt; &amp; a) const { return {a[0]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,2&gt;, vec&lt;T,2&gt;&gt; { std::array&lt;T,2&gt; operator() (const vec&lt;T,2&gt; &amp; a) const { return {a[0], a[1]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,3&gt;, vec&lt;T,3&gt;&gt; { std::array&lt;T,3&gt; operator() (const vec&lt;T,3&gt; &amp; a) const { return {a[0], a[1], a[2]}; } };\n    template&lt;class T&gt; struct converter&lt;std::array&lt;T,4&gt;, vec&lt;T,4&gt;&gt; { std::array&lt;T,4&gt; operator() (const vec&lt;T,4&gt; &amp; a) const { return {a[0], a[1], a[2], a[3]}; } };\n\n    // Provide typedefs for common element types and vector/matrix sizes\n    namespace aliases\n    {\n        typedef vec&lt;bool,1&gt; bool1; typedef vec&lt;uint8_t,1&gt; byte1; typedef vec&lt;int16_t,1&gt; short1; typedef vec&lt;uint16_t,1&gt; ushort1;\n        typedef vec&lt;bool,2&gt; bool2; typedef vec&lt;uint8_t,2&gt; byte2; typedef vec&lt;int16_t,2&gt; short2; typedef vec&lt;uint16_t,2&gt; ushort2; \n        typedef vec&lt;bool,3&gt; bool3; typedef vec&lt;uint8_t,3&gt; byte3; typedef vec&lt;int16_t,3&gt; short3; typedef vec&lt;uint16_t,3&gt; ushort3; \n        typedef vec&lt;bool,4&gt; bool4; typedef vec&lt;uint8_t,4&gt; byte4; typedef vec&lt;int16_t,4&gt; short4; typedef vec&lt;uint16_t,4&gt; ushort4;\n        typedef vec&lt;int,1&gt; int1; typedef vec&lt;unsigned,1&gt; uint1; typedef vec&lt;float,1&gt; float1; typedef vec&lt;double,1&gt; double1;\n        typedef vec&lt;int,2&gt; int2; typedef vec&lt;unsigned,2&gt; uint2; typedef vec&lt;float,2&gt; float2; typedef vec&lt;double,2&gt; double2;\n        typedef vec&lt;int,3&gt; int3; typedef vec&lt;unsigned,3&gt; uint3; typedef vec&lt;float,3&gt; float3; typedef vec&lt;double,3&gt; double3;\n        typedef vec&lt;int,4&gt; int4; typedef vec&lt;unsigned,4&gt; uint4; typedef vec&lt;float,4&gt; float4; typedef vec&lt;double,4&gt; double4;\n        typedef mat&lt;bool,1,1&gt; bool1x1; typedef mat&lt;int,1,1&gt; int1x1; typedef mat&lt;float,1,1&gt; float1x1; typedef mat&lt;double,1,1&gt; double1x1;\n        typedef mat&lt;bool,1,2&gt; bool1x2; typedef mat&lt;int,1,2&gt; int1x2; typedef mat&lt;float,1,2&gt; float1x2; typedef mat&lt;double,1,2&gt; double1x2;\n        typedef mat&lt;bool,1,3&gt; bool1x3; typedef mat&lt;int,1,3&gt; int1x3; typedef mat&lt;float,1,3&gt; float1x3; typedef mat&lt;double,1,3&gt; double1x3;\n        typedef mat&lt;bool,1,4&gt; bool1x4; typedef mat&lt;int,1,4&gt; int1x4; typedef mat&lt;float,1,4&gt; float1x4; typedef mat&lt;double,1,4&gt; double1x4;\n        typedef mat&lt;bool,2,1&gt; bool2x1; typedef mat&lt;int,2,1&gt; int2x1; typedef mat&lt;float,2,1&gt; float2x1; typedef mat&lt;double,2,1&gt; double2x1;\n        typedef mat&lt;bool,2,2&gt; bool2x2; typedef mat&lt;int,2,2&gt; int2x2; typedef mat&lt;float,2,2&gt; float2x2; typedef mat&lt;double,2,2&gt; double2x2;\n        typedef mat&lt;bool,2,3&gt; bool2x3; typedef mat&lt;int,2,3&gt; int2x3; typedef mat&lt;float,2,3&gt; float2x3; typedef mat&lt;double,2,3&gt; double2x3;\n        typedef mat&lt;bool,2,4&gt; bool2x4; typedef mat&lt;int,2,4&gt; int2x4; typedef mat&lt;float,2,4&gt; float2x4; typedef mat&lt;double,2,4&gt; double2x4;\n        typedef mat&lt;bool,3,1&gt; bool3x1; typedef mat&lt;int,3,1&gt; int3x1; typedef mat&lt;float,3,1&gt; float3x1; typedef mat&lt;double,3,1&gt; double3x1;\n        typedef mat&lt;bool,3,2&gt; bool3x2; typedef mat&lt;int,3,2&gt; int3x2; typedef mat&lt;float,3,2&gt; float3x2; typedef mat&lt;double,3,2&gt; double3x2;\n        typedef mat&lt;bool,3,3&gt; bool3x3; typedef mat&lt;int,3,3&gt; int3x3; typedef mat&lt;float,3,3&gt; float3x3; typedef mat&lt;double,3,3&gt; double3x3;\n        typedef mat&lt;bool,3,4&gt; bool3x4; typedef mat&lt;int,3,4&gt; int3x4; typedef mat&lt;float,3,4&gt; float3x4; typedef mat&lt;double,3,4&gt; double3x4;\n        typedef mat&lt;bool,4,1&gt; bool4x1; typedef mat&lt;int,4,1&gt; int4x1; typedef mat&lt;float,4,1&gt; float4x1; typedef mat&lt;double,4,1&gt; double4x1;\n        typedef mat&lt;bool,4,2&gt; bool4x2; typedef mat&lt;int,4,2&gt; int4x2; typedef mat&lt;float,4,2&gt; float4x2; typedef mat&lt;double,4,2&gt; double4x2;\n        typedef mat&lt;bool,4,3&gt; bool4x3; typedef mat&lt;int,4,3&gt; int4x3; typedef mat&lt;float,4,3&gt; float4x3; typedef mat&lt;double,4,3&gt; double4x3;\n        typedef mat&lt;bool,4,4&gt; bool4x4; typedef mat&lt;int,4,4&gt; int4x4; typedef mat&lt;float,4,4&gt; float4x4; typedef mat&lt;double,4,4&gt; double4x4;\n    }\n\n    // Provide output streaming operators, writing something that resembles an aggregate literal that could be used to construct the specified value\n    namespace ostream_overloads\n    {\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,1&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,2&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,3&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; ',' &lt;&lt; v[2] &lt;&lt; '}'; }\n        template&lt;class C, class T&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const vec&lt;T,4&gt; &amp; v) { return out &lt;&lt; '{' &lt;&lt; v[0] &lt;&lt; ',' &lt;&lt; v[1] &lt;&lt; ',' &lt;&lt; v[2] &lt;&lt; ',' &lt;&lt; v[3] &lt;&lt; '}'; }\n\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,1&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,2&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,3&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; ',' &lt;&lt; m[2] &lt;&lt; '}'; }\n        template&lt;class C, class T, int M&gt; std::basic_ostream&lt;C&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;C&gt; &amp; out, const mat&lt;T,M,4&gt; &amp; m) { return out &lt;&lt; '{' &lt;&lt; m[0] &lt;&lt; ',' &lt;&lt; m[1] &lt;&lt; ',' &lt;&lt; m[2] &lt;&lt; ',' &lt;&lt; m[3] &lt;&lt; '}'; }\n    }\n}\n\nnamespace std \n{ \n    // Provide specializations for std::hash&lt;...&gt; with linalg types\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,1&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,1&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,2&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,2&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,3&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,3&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1) ^ (h(v.z) &lt;&lt; 2); } };\n    template&lt;class T&gt; struct hash&lt;linalg::vec&lt;T,4&gt;&gt; { std::size_t operator()(const linalg::vec&lt;T,4&gt; &amp; v) const { std::hash&lt;T&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; 1) ^ (h(v.z) &lt;&lt; 2) ^ (h(v.w) &lt;&lt; 3); } };\n\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,1&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,1&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,2&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,2&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,3&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,3&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M) ^ (h(v.z) &lt;&lt; (M*2)); } };\n    template&lt;class T, int M&gt; struct hash&lt;linalg::mat&lt;T,M,4&gt;&gt; { std::size_t operator()(const linalg::mat&lt;T,M,4&gt; &amp; v) const { std::hash&lt;linalg::vec&lt;T,M&gt;&gt; h; return h(v.x) ^ (h(v.y) &lt;&lt; M) ^ (h(v.z) &lt;&lt; (M*2)) ^ (h(v.w) &lt;&lt; (M*3)); } };\n}\n\n// Definitions of functions too long to be defined inline\ntemplate&lt;class T&gt; constexpr linalg::mat&lt;T,3,3&gt; linalg::adjugate(const mat&lt;T,3,3&gt; &amp; a) \n{ \n    return {{a.y.y*a.z.z - a.z.y*a.y.z, a.z.y*a.x.z - a.x.y*a.z.z, a.x.y*a.y.z - a.y.y*a.x.z},\n            {a.y.z*a.z.x - a.z.z*a.y.x, a.z.z*a.x.x - a.x.z*a.z.x, a.x.z*a.y.x - a.y.z*a.x.x},\n            {a.y.x*a.z.y - a.z.x*a.y.y, a.z.x*a.x.y - a.x.x*a.z.y, a.x.x*a.y.y - a.y.x*a.x.y}}; \n}\n\ntemplate&lt;class T&gt; constexpr linalg::mat&lt;T,4,4&gt; linalg::adjugate(const mat&lt;T,4,4&gt; &amp; a) \n{ \n    return {{a.y.y*a.z.z*a.w.w + a.w.y*a.y.z*a.z.w + a.z.y*a.w.z*a.y.w - a.y.y*a.w.z*a.z.w - a.z.y*a.y.z*a.w.w - a.w.y*a.z.z*a.y.w,\n             a.x.y*a.w.z*a.z.w + a.z.y*a.x.z*a.w.w + a.w.y*a.z.z*a.x.w - a.w.y*a.x.z*a.z.w - a.z.y*a.w.z*a.x.w - a.x.y*a.z.z*a.w.w,\n             a.x.y*a.y.z*a.w.w + a.w.y*a.x.z*a.y.w + a.y.y*a.w.z*a.x.w - a.x.y*a.w.z*a.y.w - a.y.y*a.x.z*a.w.w - a.w.y*a.y.z*a.x.w,\n             a.x.y*a.z.z*a.y.w + a.y.y*a.x.z*a.z.w + a.z.y*a.y.z*a.x.w - a.x.y*a.y.z*a.z.w - a.z.y*a.x.z*a.y.w - a.y.y*a.z.z*a.x.w},\n            {a.y.z*a.w.w*a.z.x + a.z.z*a.y.w*a.w.x + a.w.z*a.z.w*a.y.x - a.y.z*a.z.w*a.w.x - a.w.z*a.y.w*a.z.x - a.z.z*a.w.w*a.y.x,\n             a.x.z*a.z.w*a.w.x + a.w.z*a.x.w*a.z.x + a.z.z*a.w.w*a.x.x - a.x.z*a.w.w*a.z.x - a.z.z*a.x.w*a.w.x - a.w.z*a.z.w*a.x.x,\n             a.x.z*a.w.w*a.y.x + a.y.z*a.x.w*a.w.x + a.w.z*a.y.w*a.x.x - a.x.z*a.y.w*a.w.x - a.w.z*a.x.w*a.y.x - a.y.z*a.w.w*a.x.x,\n             a.x.z*a.y.w*a.z.x + a.z.z*a.x.w*a.y.x + a.y.z*a.z.w*a.x.x - a.x.z*a.z.w*a.y.x - a.y.z*a.x.w*a.z.x - a.z.z*a.y.w*a.x.x},\n            {a.y.w*a.z.x*a.w.y + a.w.w*a.y.x*a.z.y + a.z.w*a.w.x*a.y.y - a.y.w*a.w.x*a.z.y - a.z.w*a.y.x*a.w.y - a.w.w*a.z.x*a.y.y,\n             a.x.w*a.w.x*a.z.y + a.z.w*a.x.x*a.w.y + a.w.w*a.z.x*a.x.y - a.x.w*a.z.x*a.w.y - a.w.w*a.x.x*a.z.y - a.z.w*a.w.x*a.x.y,\n             a.x.w*a.y.x*a.w.y + a.w.w*a.x.x*a.y.y + a.y.w*a.w.x*a.x.y - a.x.w*a.w.x*a.y.y - a.y.w*a.x.x*a.w.y - a.w.w*a.y.x*a.x.y,\n             a.x.w*a.z.x*a.y.y + a.y.w*a.x.x*a.z.y + a.z.w*a.y.x*a.x.y - a.x.w*a.y.x*a.z.y - a.z.w*a.x.x*a.y.y - a.y.w*a.z.x*a.x.y},\n            {a.y.x*a.w.y*a.z.z + a.z.x*a.y.y*a.w.z + a.w.x*a.z.y*a.y.z - a.y.x*a.z.y*a.w.z - a.w.x*a.y.y*a.z.z - a.z.x*a.w.y*a.y.z,\n             a.x.x*a.z.y*a.w.z + a.w.x*a.x.y*a.z.z + a.z.x*a.w.y*a.x.z - a.x.x*a.w.y*a.z.z - a.z.x*a.x.y*a.w.z - a.w.x*a.z.y*a.x.z,\n             a.x.x*a.w.y*a.y.z + a.y.x*a.x.y*a.w.z + a.w.x*a.y.y*a.x.z - a.x.x*a.y.y*a.w.z - a.w.x*a.x.y*a.y.z - a.y.x*a.w.y*a.x.z,\n             a.x.x*a.y.y*a.z.z + a.z.x*a.x.y*a.y.z + a.y.x*a.z.y*a.x.z - a.x.x*a.z.y*a.y.z - a.y.x*a.x.y*a.z.z - a.z.x*a.y.y*a.x.z}}; \n}\n\ntemplate&lt;class T&gt; constexpr T linalg::determinant(const mat&lt;T,4,4&gt; &amp; a) \n{ \n    return a.x.x*(a.y.y*a.z.z*a.w.w + a.w.y*a.y.z*a.z.w + a.z.y*a.w.z*a.y.w - a.y.y*a.w.z*a.z.w - a.z.y*a.y.z*a.w.w - a.w.y*a.z.z*a.y.w)\n         + a.x.y*(a.y.z*a.w.w*a.z.x + a.z.z*a.y.w*a.w.x + a.w.z*a.z.w*a.y.x - a.y.z*a.z.w*a.w.x - a.w.z*a.y.w*a.z.x - a.z.z*a.w.w*a.y.x)\n         + a.x.z*(a.y.w*a.z.x*a.w.y + a.w.w*a.y.x*a.z.y + a.z.w*a.w.x*a.y.y - a.y.w*a.w.x*a.z.y - a.z.w*a.y.x*a.w.y - a.w.w*a.z.x*a.y.y)\n         + a.x.w*(a.y.x*a.w.y*a.z.z + a.z.x*a.y.y*a.w.z + a.w.x*a.z.y*a.y.z - a.y.x*a.z.y*a.w.z - a.w.x*a.y.y*a.z.z - a.z.x*a.w.y*a.y.z); \n}\n\ntemplate&lt;class T&gt; linalg::vec&lt;T,4&gt; linalg::rotation_quat(const mat&lt;T,3,3&gt; &amp; m)\n{\n    const vec&lt;T,4&gt; q {m.x.x-m.y.y-m.z.z, m.y.y-m.x.x-m.z.z, m.z.z-m.x.x-m.y.y, m.x.x+m.y.y+m.z.z}, s[] {\n        {1, m.x.y + m.y.x, m.z.x + m.x.z, m.y.z - m.z.y}, \n        {m.x.y + m.y.x, 1, m.y.z + m.z.y, m.z.x - m.x.z},\n        {m.x.z + m.z.x, m.y.z + m.z.y, 1, m.x.y - m.y.x},\n        {m.y.z - m.z.y, m.z.x - m.x.z, m.x.y - m.y.x, 1}};\n    return copysign(normalize(sqrt(max(T(0), T(1)+q))), s[argmax(q)]);\n}\n\ntemplate&lt;class T&gt; linalg::mat&lt;T,4,4&gt; linalg::frustum_matrix(T x0, T x1, T y0, T y1, T n, T f, fwd_axis a, z_range z) \n{ \n    const T s = a == pos_z ? T(1) : T(-1), o = z == neg_one_to_one ? n : 0;\n    return {{2*n/(x1-x0),0,0,0}, {0,2*n/(y1-y0),0,0}, {-s*(x0+x1)/(x1-x0),-s*(y0+y1)/(y1-y0),s*(f+o)/(f-n),s}, {0,0,-(n+o)*f/(f-n),0}};\n}\n\n#endif\n</code></pre>"},{"location":"api/logger_8hpp/","title":"File logger.hpp","text":"<p>FileList &gt; common &gt; logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> </ul>"},{"location":"api/logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/logger_8hpp/#classes","title":"Classes","text":"Type Name class start_end_logger a utility for logging to start and end times to a file <p>The documentation for this class was generated from the following file <code>common/logger.hpp</code></p>"},{"location":"api/logger_8hpp_source/","title":"File logger.hpp","text":"<p>File List &gt; common &gt; logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;chrono&gt;\n#include \"phonebook.hpp\"\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nnamespace ILLIXR{\n\n    class start_end_logger\n    {\n    private:\n        std::string component_name;\n        std::ofstream log_file;\n        enum class start_end_state{\n            started,\n            ended,\n            bad\n        };\n        start_end_state log_state;\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; init_time;\n    public:\n        start_end_logger(std::string component_name){\n            log_file.open(\"log/\" + component_name);\n            if (log_file)\n                log_state = start_end_state::ended;\n            else\n                log_state = start_end_state::bad;\n            init_time = std::chrono::high_resolution_clock::now();\n        }\n        ~start_end_logger(){\n            log_file.close();\n        }\n        int log_start(std::chrono::time_point&lt;std::chrono::system_clock&gt; log_time){\n            // check status\n            if (log_state == start_end_state::bad) return -1;\n            if (log_state == start_end_state::started){\n                log_state = start_end_state::bad;\n                log_file &lt;&lt; \"bad logging state, logging terminated\" &lt;&lt; std::endl;\n                return -1;\n            }\n\n            log_state = start_end_state::started;\n            log_file &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(log_time - init_time).count() &lt;&lt; \",\";\n\n            return 0;\n        }\n        int log_end(std::chrono::time_point&lt;std::chrono::system_clock&gt; log_time){\n            // check status\n            if (log_state == start_end_state::bad) return -1;\n            if (log_state == start_end_state::ended){\n                log_state = start_end_state::bad;\n                log_file &lt;&lt; \"bad logging state, logging terminated\" &lt;&lt; std::endl;\n                return -1;\n            }\n\n            log_state = start_end_state::ended;\n            log_file &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(log_time - init_time).count() &lt;&lt; std::endl;\n\n            return 0;\n        }\n    };\n}\n</code></pre>"},{"location":"api/phonebook_8hpp/","title":"File phonebook.hpp","text":"<p>FileList &gt; common &gt; phonebook.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> </ul>"},{"location":"api/phonebook_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/phonebook_8hpp/#classes","title":"Classes","text":"Type Name class phonebook A service locator for ILLIXR. class service A 'service' that can be registered in the phonebook. <p>The documentation for this class was generated from the following file <code>common/phonebook.hpp</code></p>"},{"location":"api/phonebook_8hpp_source/","title":"File phonebook.hpp","text":"<p>File List &gt; common &gt; phonebook.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef PHONEBOOK_HH\n#define PHONEBOOK_HH\n\n#include &lt;typeindex&gt;\n#include &lt;stdexcept&gt;\n#include &lt;cassert&gt;\n\nnamespace ILLIXR {\n    class service {\n    public:\n        virtual ~service() {}\n    };\n\n    class phonebook {\n    public:\n        template &lt;typename baseclass&gt;\n        void register_impl(baseclass* impl) {\n            _p_register_impl(std::type_index(typeid(baseclass)), static_cast&lt;service*&gt;(impl));\n        }\n\n        template &lt;typename baseclass&gt;\n        baseclass* lookup_impl() {\n            baseclass* ret = dynamic_cast&lt;baseclass*&gt;(_p_lookup_impl(std::type_index(typeid(baseclass))));\n            assert(ret);\n            return ret;\n        }\n\n        virtual ~phonebook() { }\n\n    private:\n        virtual service* _p_lookup_impl(const std::type_index&amp; info) = 0;\n        virtual void _p_register_impl(const std::type_index&amp; info, service* impl) = 0;\n    };\n}\n\n#endif\n</code></pre>"},{"location":"api/plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; common &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> </ul>"},{"location":"api/plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/plugin_8hpp/#classes","title":"Classes","text":"Type Name class plugin A dynamically-loadable plugin for Spindle."},{"location":"api/plugin_8hpp/#macros","title":"Macros","text":"Type Name define PLUGIN_MAIN (plugin_class) <code>/* multi line expression */</code>"},{"location":"api/plugin_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugin_8hpp/#define-plugin_main","title":"define PLUGIN_MAIN","text":"<pre><code>#define PLUGIN_MAIN (\n    plugin_class\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>common/plugin.hpp</code></p>"},{"location":"api/plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; common &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef PLUGIN_HH\n#define PLUGIN_HH\n\n#include \"phonebook.hpp\"\n\nnamespace ILLIXR {\n\n    class plugin : public service {\n    public:\n        virtual void start() {};\n    };\n\n#define PLUGIN_MAIN(plugin_class) \\\n    extern \"C\" plugin* plugin_main(phonebook* pb) {                  \\\n        plugin_class* obj = new plugin_class {pb};                   \\\n        obj-&gt;start();                                                \\\n        return obj;                                                  \\\n    }\n}\n\n#endif\n</code></pre>"},{"location":"api/pose__prediction_8hpp/","title":"File pose_prediction.hpp","text":"<p>FileList &gt; common &gt; pose_prediction.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"data_format.hpp\"</code></li> </ul>"},{"location":"api/pose__prediction_8hpp/#classes","title":"Classes","text":"Type Name class pose_prediction <p>The documentation for this class was generated from the following file <code>common/pose_prediction.hpp</code></p>"},{"location":"api/pose__prediction_8hpp_source/","title":"File pose_prediction.hpp","text":"<p>File List &gt; common &gt; pose_prediction.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"plugin.hpp\"\n#include \"data_format.hpp\"\n\nusing namespace ILLIXR;\n\nclass pose_prediction : public plugin {\npublic:\n    virtual pose_type* get_fast_pose() = 0;\n    virtual pose_type* get_fast_true_pose() = 0;\n};\n</code></pre>"},{"location":"api/shader__util_8hpp/","title":"File shader_util.hpp","text":"<p>FileList &gt; common &gt; shader_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"GL/gl.h\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/shader__util_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void GLAPIENTRY MessageCallback (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * message, const void * userParam)  GLuint init_and_link (const char * vertex_shader, const char * fragment_shader)"},{"location":"api/shader__util_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/shader__util_8hpp/#function-messagecallback","title":"function MessageCallback","text":"<pre><code>static void GLAPIENTRY MessageCallback (\n    GLenum source,\n    GLenum type,\n    GLuint id,\n    GLenum severity,\n    GLsizei length,\n    const GLchar * message,\n    const void * userParam\n) \n</code></pre>"},{"location":"api/shader__util_8hpp/#function-init_and_link","title":"function init_and_link","text":"<pre><code>static GLuint init_and_link (\n    const char * vertex_shader,\n    const char * fragment_shader\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>common/shader_util.hpp</code></p>"},{"location":"api/shader__util_8hpp_source/","title":"File shader_util.hpp","text":"<p>File List &gt; common &gt; shader_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include \"GL/gl.h\"\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\n\n\nstatic void GLAPIENTRY\n    MessageCallback( GLenum source,\n                    GLenum type,\n                    GLuint id,\n                    GLenum severity,\n                    GLsizei length,\n                    const GLchar* message,\n                    const void* userParam )\n    {\n    fprintf( stderr, \"GL CALLBACK: %s type = 0x%x, severity = 0x%x, message = %s\\n\",\n            ( type == GL_DEBUG_TYPE_ERROR ? \"** GL ERROR **\" : \"\" ),\n                type, severity, message );\n    }\n\nstatic GLuint init_and_link (const char* vertex_shader, const char* fragment_shader){\n\n    // GL handles for intermediary objects.\n    GLint result, vertex_shader_handle, fragment_shader_handle, shader_program;\n\n\n    vertex_shader_handle = glCreateShader(GL_VERTEX_SHADER);\n    GLint vshader_len = strlen(vertex_shader);\n    glShaderSource(vertex_shader_handle, 1, &amp;vertex_shader, &amp;vshader_len);\n    glCompileShader(vertex_shader_handle);\n    glGetShaderiv(vertex_shader_handle, GL_COMPILE_STATUS, &amp;result);\n    if ( result == GL_FALSE )\n    {\n        GLchar msg[4096];\n        GLsizei length;\n        glGetShaderInfoLog( vertex_shader_handle, sizeof( msg ), &amp;length, msg );\n        printf( \"1 Error: %s\\n\", msg);\n    }\n\n    GLint fragResult = GL_FALSE;\n    fragment_shader_handle = glCreateShader(GL_FRAGMENT_SHADER);\n    GLint fshader_len = strlen(fragment_shader);\n    glShaderSource(fragment_shader_handle, 1, &amp;fragment_shader, &amp;fshader_len);\n    glCompileShader(fragment_shader_handle);\n    if(glGetError()){\n        printf(\"Fragment shader compilation failed\\n\");\n    }\n    glGetShaderiv(fragment_shader_handle, GL_COMPILE_STATUS, &amp;fragResult);\n    if ( fragResult == GL_FALSE )\n    {\n        GLchar msg[4096];\n        GLsizei length;\n        glGetShaderInfoLog( fragment_shader_handle, sizeof( msg ), &amp;length, msg );\n        printf( \"2 Error: %s\\n\", msg);\n    }\n\n    // Create program and link shaders\n    shader_program = glCreateProgram();\n    glAttachShader(shader_program, vertex_shader_handle);\n    glAttachShader(shader_program, fragment_shader_handle);\n    if(glGetError()){\n        printf(\"AttachShader or createProgram failed\\n\");\n    }\n\n    // Link and verify\n\n    glLinkProgram(shader_program);\n\n    if(glGetError()){\n        printf(\"Linking failed\\n\");\n    }\n\n    glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;result);\n    GLenum err = glGetError();\n    if(err){\n        printf(\"initGL, error getting link status, %x\", err);\n    }\n    if ( result == GL_FALSE )\n    {\n        GLchar msg[4096];\n        GLsizei length;\n\n        std::vector&lt;GLchar&gt; infoLog(length);\n        glGetProgramInfoLog(shader_program, length, &amp;length, &amp;infoLog[0]);\n\n        std::string error_msg(infoLog.begin(), infoLog.end());\n        std::cout &lt;&lt; error_msg;\n\n    }\n\n    if(glGetError()){\n        printf(\"initGL, error at end of initGL\");\n    }\n\n    // After successful link, detach shaders from shader program\n    glDetachShader(shader_program, vertex_shader_handle);\n    glDetachShader(shader_program, fragment_shader_handle);\n\n    return shader_program;\n}\n</code></pre>"},{"location":"api/switchboard_8hpp/","title":"File switchboard.hpp","text":"<p>FileList &gt; common &gt; switchboard.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> </ul>"},{"location":"api/switchboard_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/switchboard_8hpp/#classes","title":"Classes","text":"Type Name class reader_latest &lt;typename event&gt;A handle which can read the latest event on a topic. class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class writer &lt;typename event&gt;A handle which can publish events to a topic. <p>The documentation for this class was generated from the following file <code>common/switchboard.hpp</code></p>"},{"location":"api/switchboard_8hpp_source/","title":"File switchboard.hpp","text":"<p>File List &gt; common &gt; switchboard.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SWITCHBOARD_HH\n#define SWITCHBOARD_HH\n\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;functional&gt;\n#include \"phonebook.hpp\"\n\nnamespace ILLIXR {\n\ntemplate &lt;typename event&gt;\nclass reader_latest {\npublic:\n    virtual const event* get_latest_ro() const = 0;\n\n    virtual event* get_latest() const = 0;\n\n    virtual ~reader_latest() { };\n};\n\ntemplate &lt;typename event&gt;\nclass writer {\npublic:\n    virtual void put(const event* ev) = 0;\n\n    virtual event* allocate() = 0;\n\n    virtual ~writer() { };\n};\n\n/* This class is pure virtual so that I can hide its implementation from its users. It will be\n   referenced in plugins, but implemented in the runtime.\n\n   However, virtual methods cannot be templated, so these templated methods refer to a virtual\n   method whose type has been erased (coerced to/from void*). This is an instance of the Non-Virtual\n   Interface pattern: https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface\n*/\n\nclass switchboard : public service {\n\nprivate:\n    virtual\n    std::unique_ptr&lt;writer&lt;void&gt;&gt; _p_publish(const std::string&amp; name, std::size_t ty) = 0;\n\n    virtual\n    std::unique_ptr&lt;reader_latest&lt;void&gt;&gt; _p_subscribe_latest(const std::string&amp; name, std::size_t ty) = 0;\n\n    virtual\n    void _p_schedule(const std::string&amp; name, std::function&lt;void(const void*)&gt; fn, std::size_t ty) = 0;\n\n    /* TODO: (usability) add a method which queries if a topic has a writer. Readers might assert this. */\n\npublic:\n\n    template &lt;typename event&gt;\n    void schedule(std::string name, std::function&lt;void(const event*)&gt; fn) {\n        _p_schedule(name, [=](const void* ptr){ fn(reinterpret_cast&lt;const event*&gt;(ptr)); }, typeid(event).hash_code());\n    }\n\n    template &lt;typename event&gt;\n    std::unique_ptr&lt;writer&lt;event&gt;&gt; publish(const std::string&amp; name) {\n        auto void_writer = _p_publish(name, typeid(event).hash_code());\n        return std::move(std::unique_ptr&lt;writer&lt;event&gt;&gt;(reinterpret_cast&lt;writer&lt;event&gt;*&gt;(void_writer.release())));\n    }\n\n    template &lt;typename event&gt;\n    std::unique_ptr&lt;reader_latest&lt;event&gt;&gt; subscribe_latest(const std::string&amp; name) {\n        auto void_writer = _p_subscribe_latest(name, typeid(event).hash_code());\n        return std::move(std::unique_ptr&lt;reader_latest&lt;event&gt;&gt;(reinterpret_cast&lt;reader_latest&lt;event&gt;*&gt;(void_writer.release())));\n    }\n\n    virtual ~switchboard() { }\n};\n\n/* TODO: (usability) Do these HAVE to be smart pointers? If the\n   copy-constructor is already shallow, they could be concrete\n   data-types. */\n\n}\n\n#endif\n</code></pre>"},{"location":"api/threadloop_8hpp/","title":"File threadloop.hpp","text":"<p>FileList &gt; common &gt; threadloop.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"plugin.hpp\"</code></li> </ul>"},{"location":"api/threadloop_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/threadloop_8hpp/#classes","title":"Classes","text":"Type Name class threadloop A reusable threadloop for plugins. <p>The documentation for this class was generated from the following file <code>common/threadloop.hpp</code></p>"},{"location":"api/threadloop_8hpp_source/","title":"File threadloop.hpp","text":"<p>File List &gt; common &gt; threadloop.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef THREADLOOP_HH\n#define THREADLOOP_HH\n\n#include &lt;atomic&gt;\n#include &lt;future&gt;\n#include &lt;algorithm&gt;\n#include \"plugin.hpp\"\n\nnamespace ILLIXR {\n\nclass threadloop : public plugin {\npublic:\n    void start() override {\n        _m_thread = std::thread([this]() {\n        while (!should_terminate()) {\n                _p_one_iteration();\n            }\n        });\n    }\n\n    void stop() {\n        _m_terminate.store(true);\n        _m_thread.join();\n    }\n\n    virtual ~threadloop() override {\n        if (!should_terminate()) {\n            stop();\n        }\n    }\n\nprotected:\n    virtual void _p_one_iteration() = 0;\n\n    bool should_terminate() {\n        return _m_terminate.load();\n    }\n\n    void reliable_sleep(std::chrono::time_point&lt;std::chrono::system_clock&gt; stop) {\n        auto start = std::chrono::high_resolution_clock::now();\n        auto sleep_duration = stop - start;\n\n        auto sleep_quantum = std::min&lt;std::common_type_t&lt;decltype(sleep_duration), decltype(MAX_TIMEOUT)&gt;&gt;(\n            sleep_duration / SLEEP_SAFETY_FACTOR,\n            MAX_TIMEOUT\n        );\n\n        // sleep_quantum is at most MAX_TIMEOUT so that we will wake up, and check if should_terminate\n        // Thus, every plugin will respond to termination within MAX_TIMOUT (assuming no long compute-bound thing)\n        while (!should_terminate() &amp;&amp; std::chrono::high_resolution_clock::now() - start &lt; sleep_duration) {\n            std::this_thread::sleep_for(sleep_quantum);\n        }\n    }\n\nprivate:\n    // This factor is related to how accurate reliable_sleep is\n    const size_t SLEEP_SAFETY_FACTOR {100};\n\n    // this factor is related to how quickly we will shutdown when termintae is called\n    std::chrono::milliseconds MAX_TIMEOUT {100};\n\n    std::atomic&lt;bool&gt; _m_terminate {false};\n\n    std::thread _m_thread;\n};\n\n}\n\n#endif\n</code></pre>"},{"location":"api/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace ILLIXR </li> <li>namespace linalg <ul> <li>namespace aliases </li> <li>namespace detail </li> <li>namespace ostream_overloads </li> </ul> </li> <li>namespace std <ul> <li>namespace conditional </li> </ul> </li> </ul>"},{"location":"api/classes/","title":"Class Index","text":""},{"location":"api/classes/#a","title":"a","text":"<ul> <li>accel (ILLIXR)</li> <li>any_compare (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; (linalg::detail)</li> <li>any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; (linalg::detail)</li> <li>apply (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail)</li> </ul>"},{"location":"api/classes/#c","title":"c","text":"<ul> <li>camera_frame (ILLIXR)</li> <li>clamp (linalg::detail)</li> <li>converter (linalg)</li> <li>converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; (linalg)</li> <li>converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; (linalg)</li> <li>converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; (linalg)</li> </ul>"},{"location":"api/classes/#e","title":"e","text":"<ul> <li>empty (linalg::detail)</li> </ul>"},{"location":"api/classes/#g","title":"g","text":"<ul> <li>getter (linalg::detail)</li> <li>getter&lt; 0 &gt; (linalg::detail)</li> <li>getter&lt; 1 &gt; (linalg::detail)</li> <li>getter&lt; 2 &gt; (linalg::detail)</li> <li>getter&lt; 3 &gt; (linalg::detail)</li> <li>global_config (ILLIXR)</li> </ul>"},{"location":"api/classes/#h","title":"h","text":"<ul> <li>hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; (std)</li> <li>hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 1 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 2 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 3 &gt; &gt; (std)</li> <li>hash&lt; linalg::vec&lt; T, 4 &gt; &gt; (std)</li> <li>hmd_physical_info (ILLIXR)</li> <li>hologram_input (ILLIXR)</li> <li>hologram_output (ILLIXR)</li> </ul>"},{"location":"api/classes/#i","title":"i","text":"<ul> <li>identity_t (linalg)</li> <li>imu_cam_type (ILLIXR)</li> </ul>"},{"location":"api/classes/#l","title":"l","text":"<ul> <li>lerp (linalg::detail)</li> </ul>"},{"location":"api/classes/#m","title":"m","text":"<ul> <li>make_seq_impl (linalg::detail)</li> <li>make_seq_impl&lt; A, 0 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 1 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 2 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 3 &gt; (linalg::detail)</li> <li>make_seq_impl&lt; A, 4 &gt; (linalg::detail)</li> <li>mat (linalg)</li> <li>mat&lt; T, M, 1 &gt; (linalg)</li> <li>mat&lt; T, M, 2 &gt; (linalg)</li> <li>mat&lt; T, M, 3 &gt; (linalg)</li> <li>mat&lt; T, M, 4 &gt; (linalg)</li> <li>max (linalg::detail)</li> <li>min (linalg::detail)</li> </ul>"},{"location":"api/classes/#o","title":"o","text":"<ul> <li>op_add (linalg::detail)</li> <li>op_and (linalg::detail)</li> <li>op_cmp (linalg::detail)</li> <li>op_div (linalg::detail)</li> <li>op_eq (linalg::detail)</li> <li>op_ge (linalg::detail)</li> <li>op_gt (linalg::detail)</li> <li>op_int (linalg::detail)</li> <li>op_le (linalg::detail)</li> <li>op_lsh (linalg::detail)</li> <li>op_lt (linalg::detail)</li> <li>op_mod (linalg::detail)</li> <li>op_mul (linalg::detail)</li> <li>op_ne (linalg::detail)</li> <li>op_neg (linalg::detail)</li> <li>op_not (linalg::detail)</li> <li>op_or (linalg::detail)</li> <li>op_pos (linalg::detail)</li> <li>op_rsh (linalg::detail)</li> <li>op_sub (linalg::detail)</li> <li>op_un (linalg::detail)</li> <li>op_xor (linalg::detail)</li> <li>ord (linalg::detail)</li> </ul>"},{"location":"api/classes/#p","title":"p","text":"<ul> <li>phonebook (ILLIXR)</li> <li>plugin (ILLIXR)</li> <li>pose_prediction</li> <li>pose_type (ILLIXR)</li> </ul>"},{"location":"api/classes/#r","title":"r","text":"<ul> <li>reader_latest (ILLIXR)</li> <li>rendered_frame (ILLIXR)</li> <li>rendered_frame_alt (ILLIXR)</li> </ul>"},{"location":"api/classes/#s","title":"s","text":"<ul> <li>scalar_type (linalg::detail)</li> <li>scalar_type&lt; mat&lt; T, M, N &gt; &gt; (linalg::detail)</li> <li>scalar_type&lt; vec&lt; T, M &gt; &gt; (linalg::detail)</li> <li>scalars (linalg::detail)</li> <li>scalars&lt; T, U... &gt; (linalg::detail)</li> <li>scalars&lt;&gt; (linalg::detail)</li> <li>select (linalg::detail)</li> <li>seq (linalg::detail)</li> <li>service (ILLIXR)</li> <li>start_end_logger (ILLIXR)</li> <li>std_abs (linalg::detail)</li> <li>std_acos (linalg::detail)</li> <li>std_asin (linalg::detail)</li> <li>std_atan (linalg::detail)</li> <li>std_atan2 (linalg::detail)</li> <li>std_ceil (linalg::detail)</li> <li>std_copysign (linalg::detail)</li> <li>std_cos (linalg::detail)</li> <li>std_cosh (linalg::detail)</li> <li>std_exp (linalg::detail)</li> <li>std_floor (linalg::detail)</li> <li>std_fmod (linalg::detail)</li> <li>std_log (linalg::detail)</li> <li>std_log10 (linalg::detail)</li> <li>std_pow (linalg::detail)</li> <li>std_round (linalg::detail)</li> <li>std_sin (linalg::detail)</li> <li>std_sinh (linalg::detail)</li> <li>std_sqrt (linalg::detail)</li> <li>std_tan (linalg::detail)</li> <li>std_tanh (linalg::detail)</li> <li>switchboard (ILLIXR)</li> </ul>"},{"location":"api/classes/#t","title":"t","text":"<ul> <li>threadloop (ILLIXR)</li> </ul>"},{"location":"api/classes/#v","title":"v","text":"<ul> <li>vec (linalg)</li> <li>vec&lt; T, 1 &gt; (linalg)</li> <li>vec&lt; T, 2 &gt; (linalg)</li> <li>vec&lt; T, 3 &gt; (linalg)</li> <li>vec&lt; T, 4 &gt; (linalg)</li> </ul>"},{"location":"api/classes/#w","title":"w","text":"<ul> <li>writer (ILLIXR)</li> </ul>"},{"location":"api/classes/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR)</li> </ul>"},{"location":"api/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class ILLIXR::service A 'service' that can be registered in the phonebook. <ul> <li>class ILLIXR::global_config </li> <li>class ILLIXR::plugin A dynamically-loadable plugin for Spindle. <ul> <li>class ILLIXR::threadloop A reusable threadloop for plugins. </li> <li>class pose_prediction </li> </ul> </li> <li>class ILLIXR::switchboard A manager for typesafe, threadsafe, named event-streams (called topics). </li> <li>class ILLIXR::xlib_gl_extended_window </li> </ul> </li> <li>class ILLIXR::phonebook A service locator for ILLIXR.</li> <li>class ILLIXR::reader_latest A handle which can read the latest event on a topic. </li> <li>class ILLIXR::start_end_logger a utility for logging to start and end times to a file </li> <li>class ILLIXR::writer A handle which can publish events to a topic. </li> <li>struct ILLIXR::accel </li> <li>struct ILLIXR::camera_frame </li> <li>struct ILLIXR::hmd_physical_info </li> <li>struct ILLIXR::hologram_input </li> <li>struct ILLIXR::hologram_output </li> <li>struct ILLIXR::imu_cam_type </li> <li>struct ILLIXR::pose_type </li> <li>struct ILLIXR::rendered_frame </li> <li>struct ILLIXR::rendered_frame_alt </li> <li>struct linalg::converter </li> <li>struct linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt; </li> <li>struct linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt; </li> <li>struct linalg::detail::any_compare </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt; </li> <li>struct linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt; </li> <li>struct linalg::detail::apply </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; </li> <li>struct linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; </li> <li>struct linalg::detail::clamp </li> <li>struct linalg::detail::empty </li> <li>struct linalg::detail::getter </li> <li>struct linalg::detail::getter&lt; 0 &gt; </li> <li>struct linalg::detail::getter&lt; 1 &gt; </li> <li>struct linalg::detail::getter&lt; 2 &gt; </li> <li>struct linalg::detail::getter&lt; 3 &gt; </li> <li>struct linalg::detail::lerp </li> <li>struct linalg::detail::make_seq_impl </li> <li>struct linalg::detail::make_seq_impl&lt; A, 0 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 1 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 2 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 3 &gt; </li> <li>struct linalg::detail::make_seq_impl&lt; A, 4 &gt; </li> <li>struct linalg::detail::max </li> <li>struct linalg::detail::min </li> <li>struct linalg::detail::op_add </li> <li>struct linalg::detail::op_and </li> <li>struct linalg::detail::op_cmp </li> <li>struct linalg::detail::op_div </li> <li>struct linalg::detail::op_eq </li> <li>struct linalg::detail::op_ge </li> <li>struct linalg::detail::op_gt </li> <li>struct linalg::detail::op_int </li> <li>struct linalg::detail::op_le </li> <li>struct linalg::detail::op_lsh </li> <li>struct linalg::detail::op_lt </li> <li>struct linalg::detail::op_mod </li> <li>struct linalg::detail::op_mul </li> <li>struct linalg::detail::op_ne </li> <li>struct linalg::detail::op_neg </li> <li>struct linalg::detail::op_not </li> <li>struct linalg::detail::op_or </li> <li>struct linalg::detail::op_pos </li> <li>struct linalg::detail::op_rsh </li> <li>struct linalg::detail::op_sub </li> <li>struct linalg::detail::op_un </li> <li>struct linalg::detail::op_xor </li> <li>struct linalg::detail::ord </li> <li>struct linalg::detail::scalar_type </li> <li>struct linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt; </li> <li>struct linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt; </li> <li>struct linalg::detail::scalars </li> <li>struct linalg::detail::scalars&lt;&gt; </li> <li>struct linalg::detail::select </li> <li>struct linalg::detail::seq </li> <li>struct linalg::detail::std_abs </li> <li>struct linalg::detail::std_acos </li> <li>struct linalg::detail::std_asin </li> <li>struct linalg::detail::std_atan </li> <li>struct linalg::detail::std_atan2 </li> <li>struct linalg::detail::std_ceil </li> <li>struct linalg::detail::std_copysign </li> <li>struct linalg::detail::std_cos </li> <li>struct linalg::detail::std_cosh </li> <li>struct linalg::detail::std_exp </li> <li>struct linalg::detail::std_floor </li> <li>struct linalg::detail::std_fmod </li> <li>struct linalg::detail::std_log </li> <li>struct linalg::detail::std_log10 </li> <li>struct linalg::detail::std_pow </li> <li>struct linalg::detail::std_round </li> <li>struct linalg::detail::std_sin </li> <li>struct linalg::detail::std_sinh </li> <li>struct linalg::detail::std_sqrt </li> <li>struct linalg::detail::std_tan </li> <li>struct linalg::detail::std_tanh </li> <li>struct linalg::identity_t </li> <li>struct linalg::mat </li> <li>struct linalg::mat&lt; T, M, 1 &gt; </li> <li>struct linalg::mat&lt; T, M, 2 &gt; </li> <li>struct linalg::mat&lt; T, M, 3 &gt; </li> <li>struct linalg::mat&lt; T, M, 4 &gt; </li> <li>struct linalg::vec </li> <li>struct linalg::vec&lt; T, 1 &gt; </li> <li>struct linalg::vec&lt; T, 2 &gt; </li> <li>struct linalg::vec&lt; T, 3 &gt; </li> <li>struct linalg::vec&lt; T, 4 &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt; </li> <li>struct std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt; </li> <li>struct std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt; </li> <li>class std::conditional::type <ul> <li>struct linalg::detail::scalars&lt; T, U... &gt; </li> </ul> </li> </ul>"},{"location":"api/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"api/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"api/class_members/","title":"Class Members","text":""},{"location":"api/class_members/#a","title":"a","text":"<ul> <li>angular_v (ILLIXR::imu_cam_type)</li> <li>allocate (ILLIXR::writer)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>a (linalg::detail::ord)</li> </ul>"},{"location":"api/class_members/#b","title":"b","text":"<ul> <li>b (linalg::detail::ord)</li> </ul>"},{"location":"api/class_members/#c","title":"c","text":"<ul> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>component_name (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_members/#d","title":"d","text":"<ul> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>dummy (ILLIXR::hologram_output)</li> <li>dataset_time (ILLIXR::imu_cam_type)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#g","title":"g","text":"<ul> <li>glfw_context (ILLIXR::global_config)</li> <li>global_config (ILLIXR::global_config)</li> <li>get_latest (ILLIXR::reader_latest)</li> <li>get_latest_ro (ILLIXR::reader_latest)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_fast_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_members/#h","title":"h","text":"<ul> <li>height (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#i","title":"i","text":"<ul> <li>ipd (ILLIXR::hmd_physical_info)</li> <li>img0 (ILLIXR::imu_cam_type)</li> <li>img1 (ILLIXR::imu_cam_type)</li> <li>init_time (ILLIXR::start_end_logger)</li> <li>impl (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>identity_t (linalg::identity_t)</li> </ul>"},{"location":"api/class_members/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_members/#l","title":"l","text":"<ul> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>linear_a (ILLIXR::imu_cam_type)</li> <li>lookup_impl (ILLIXR::phonebook)</li> <li>log_end (ILLIXR::start_end_logger)</li> <li>log_file (ILLIXR::start_end_logger)</li> <li>log_start (ILLIXR::start_end_logger)</li> <li>log_state (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_members/#m","title":"m","text":"<ul> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> <li>MAX_TIMEOUT (ILLIXR::threadloop)</li> <li>mat (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#o","title":"o","text":"<ul> <li>orientation (ILLIXR::pose_type)</li> <li>operator() (linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;, linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;, linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;, linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;, linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::clamp, linalg::detail::getter&lt; 0 &gt;, linalg::detail::getter&lt; 1 &gt;, linalg::detail::getter&lt; 2 &gt;, linalg::detail::getter&lt; 3 &gt;, linalg::detail::lerp, linalg::detail::max, linalg::detail::min, linalg::detail::op_add, linalg::detail::op_and, linalg::detail::op_cmp, linalg::detail::op_div, linalg::detail::op_eq, linalg::detail::op_ge, linalg::detail::op_gt, linalg::detail::op_int, linalg::detail::op_le, linalg::detail::op_lsh, linalg::detail::op_lt, linalg::detail::op_mod, linalg::detail::op_mul, linalg::detail::op_ne, linalg::detail::op_neg, linalg::detail::op_not, linalg::detail::op_or, linalg::detail::op_pos, linalg::detail::op_rsh, linalg::detail::op_sub, linalg::detail::op_un, linalg::detail::op_xor, linalg::detail::select, linalg::detail::std_abs, linalg::detail::std_acos, linalg::detail::std_asin, linalg::detail::std_atan, linalg::detail::std_atan2, linalg::detail::std_ceil, linalg::detail::std_copysign, linalg::detail::std_cos, linalg::detail::std_cosh, linalg::detail::std_exp, linalg::detail::std_floor, linalg::detail::std_fmod, linalg::detail::std_log, linalg::detail::std_log10, linalg::detail::std_pow, linalg::detail::std_round, linalg::detail::std_sin, linalg::detail::std_sinh, linalg::detail::std_sqrt, linalg::detail::std_tan, linalg::detail::std_tanh, std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;)</li> <li>operator U (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>operator[] (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#p","title":"p","text":"<ul> <li>pixel (ILLIXR::camera_frame)</li> <li>position (ILLIXR::pose_type)</li> <li>publish (ILLIXR::switchboard)</li> <li>put (ILLIXR::writer)</li> </ul>"},{"location":"api/class_members/#r","title":"r","text":"<ul> <li>register_impl (ILLIXR::phonebook)</li> <li>render_pose (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> <li>reliable_sleep (ILLIXR::threadloop)</li> <li>row (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#s","title":"s","text":"<ul> <li>seq (ILLIXR::hologram_input)</li> <li>start (ILLIXR::plugin, ILLIXR::threadloop)</li> <li>sample_time (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> <li>swap_indices (ILLIXR::rendered_frame_alt)</li> <li>start_end_logger (ILLIXR::start_end_logger)</li> <li>start_end_state (ILLIXR::start_end_logger)</li> <li>schedule (ILLIXR::switchboard)</li> <li>subscribe_latest (ILLIXR::switchboard)</li> <li>SLEEP_SAFETY_FACTOR (ILLIXR::threadloop)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>stop (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_members/#t","title":"t","text":"<ul> <li>time (ILLIXR::imu_cam_type, ILLIXR::pose_type)</li> <li>texture_handle (ILLIXR::rendered_frame)</li> <li>texture_handles (ILLIXR::rendered_frame_alt)</li> <li>type (linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;, linalg::detail::make_seq_impl&lt; A, 0 &gt;, linalg::detail::make_seq_impl&lt; A, 1 &gt;, linalg::detail::make_seq_impl&lt; A, 2 &gt;, linalg::detail::make_seq_impl&lt; A, 3 &gt;, linalg::detail::make_seq_impl&lt; A, 4 &gt;, linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;, linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;, linalg::detail::scalars&lt;&gt;)</li> </ul>"},{"location":"api/class_members/#v","title":"v","text":"<ul> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> <li>V (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> <li>vec (linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#w","title":"w","text":"<ul> <li>width (ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>w (linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>x (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xy (linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xyz (linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#y","title":"y","text":"<ul> <li>y (linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#z","title":"z","text":"<ul> <li>z (linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_members/#_1","title":"~","text":"<ul> <li>~phonebook (ILLIXR::phonebook)</li> <li>~reader_latest (ILLIXR::reader_latest)</li> <li>~service (ILLIXR::service)</li> <li>~start_end_logger (ILLIXR::start_end_logger)</li> <li>~switchboard (ILLIXR::switchboard)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~writer (ILLIXR::writer)</li> </ul>"},{"location":"api/class_members/#_","title":"_","text":"<ul> <li>_p_lookup_impl (ILLIXR::phonebook)</li> <li>_p_register_impl (ILLIXR::phonebook)</li> <li>_p_publish (ILLIXR::switchboard)</li> <li>_p_schedule (ILLIXR::switchboard)</li> <li>_p_subscribe_latest (ILLIXR::switchboard)</li> <li>_m_terminate (ILLIXR::threadloop)</li> <li>_m_thread (ILLIXR::threadloop)</li> <li>_p_one_iteration (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_functions/","title":"Class Member Functions","text":""},{"location":"api/class_member_functions/#a","title":"a","text":"<ul> <li>allocate (ILLIXR::writer)</li> </ul>"},{"location":"api/class_member_functions/#g","title":"g","text":"<ul> <li>global_config (ILLIXR::global_config)</li> <li>get_latest (ILLIXR::reader_latest)</li> <li>get_latest_ro (ILLIXR::reader_latest)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_fast_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#i","title":"i","text":"<ul> <li>impl (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> <li>identity_t (linalg::identity_t)</li> </ul>"},{"location":"api/class_member_functions/#l","title":"l","text":"<ul> <li>lookup_impl (ILLIXR::phonebook)</li> <li>log_end (ILLIXR::start_end_logger)</li> <li>log_start (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_member_functions/#m","title":"m","text":"<ul> <li>mat (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#o","title":"o","text":"<ul> <li>operator() (linalg::converter&lt; mat&lt; T, 1, 1 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 2, 2 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 3, 3 &gt;, identity_t &gt;, linalg::converter&lt; mat&lt; T, 4, 4 &gt;, identity_t &gt;, linalg::converter&lt; std::array&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::converter&lt; std::array&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::converter&lt; vec&lt; T, 1 &gt;, std::array&lt; T, 1 &gt; &gt;, linalg::converter&lt; vec&lt; T, 2 &gt;, std::array&lt; T, 2 &gt; &gt;, linalg::converter&lt; vec&lt; T, 3 &gt;, std::array&lt; T, 3 &gt; &gt;, linalg::converter&lt; vec&lt; T, 4 &gt;, std::array&lt; T, 4 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::clamp, linalg::detail::getter&lt; 0 &gt;, linalg::detail::getter&lt; 1 &gt;, linalg::detail::getter&lt; 2 &gt;, linalg::detail::getter&lt; 3 &gt;, linalg::detail::lerp, linalg::detail::max, linalg::detail::min, linalg::detail::op_add, linalg::detail::op_and, linalg::detail::op_cmp, linalg::detail::op_div, linalg::detail::op_eq, linalg::detail::op_ge, linalg::detail::op_gt, linalg::detail::op_int, linalg::detail::op_le, linalg::detail::op_lsh, linalg::detail::op_lt, linalg::detail::op_mod, linalg::detail::op_mul, linalg::detail::op_ne, linalg::detail::op_neg, linalg::detail::op_not, linalg::detail::op_or, linalg::detail::op_pos, linalg::detail::op_rsh, linalg::detail::op_sub, linalg::detail::op_un, linalg::detail::op_xor, linalg::detail::select, linalg::detail::std_abs, linalg::detail::std_acos, linalg::detail::std_asin, linalg::detail::std_atan, linalg::detail::std_atan2, linalg::detail::std_ceil, linalg::detail::std_copysign, linalg::detail::std_cos, linalg::detail::std_cosh, linalg::detail::std_exp, linalg::detail::std_floor, linalg::detail::std_fmod, linalg::detail::std_log, linalg::detail::std_log10, linalg::detail::std_pow, linalg::detail::std_round, linalg::detail::std_sin, linalg::detail::std_sinh, linalg::detail::std_sqrt, linalg::detail::std_tan, linalg::detail::std_tanh, std::hash&lt; linalg::mat&lt; T, M, 1 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 2 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 3 &gt; &gt;, std::hash&lt; linalg::mat&lt; T, M, 4 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 1 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 2 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 3 &gt; &gt;, std::hash&lt; linalg::vec&lt; T, 4 &gt; &gt;)</li> <li>operator U (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>operator[] (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#p","title":"p","text":"<ul> <li>publish (ILLIXR::switchboard)</li> <li>put (ILLIXR::writer)</li> </ul>"},{"location":"api/class_member_functions/#r","title":"r","text":"<ul> <li>register_impl (ILLIXR::phonebook)</li> <li>reliable_sleep (ILLIXR::threadloop)</li> <li>row (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#s","title":"s","text":"<ul> <li>start (ILLIXR::plugin, ILLIXR::threadloop)</li> <li>start_end_logger (ILLIXR::start_end_logger)</li> <li>schedule (ILLIXR::switchboard)</li> <li>subscribe_latest (ILLIXR::switchboard)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>stop (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_functions/#v","title":"v","text":"<ul> <li>vec (linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>xy (linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> <li>xyz (linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_functions/#_1","title":"~","text":"<ul> <li>~phonebook (ILLIXR::phonebook)</li> <li>~reader_latest (ILLIXR::reader_latest)</li> <li>~service (ILLIXR::service)</li> <li>~start_end_logger (ILLIXR::start_end_logger)</li> <li>~switchboard (ILLIXR::switchboard)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~writer (ILLIXR::writer)</li> </ul>"},{"location":"api/class_member_functions/#_","title":"_","text":"<ul> <li>_p_lookup_impl (ILLIXR::phonebook)</li> <li>_p_register_impl (ILLIXR::phonebook)</li> <li>_p_publish (ILLIXR::switchboard)</li> <li>_p_schedule (ILLIXR::switchboard)</li> <li>_p_subscribe_latest (ILLIXR::switchboard)</li> <li>_p_one_iteration (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/","title":"Class Member Variables","text":""},{"location":"api/class_member_variables/#a","title":"a","text":"<ul> <li>angular_v (ILLIXR::imu_cam_type)</li> <li>a (linalg::detail::ord)</li> </ul>"},{"location":"api/class_member_variables/#b","title":"b","text":"<ul> <li>b (linalg::detail::ord)</li> </ul>"},{"location":"api/class_member_variables/#c","title":"c","text":"<ul> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>component_name (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_member_variables/#d","title":"d","text":"<ul> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>dummy (ILLIXR::hologram_output)</li> <li>dataset_time (ILLIXR::imu_cam_type)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#g","title":"g","text":"<ul> <li>glfw_context (ILLIXR::global_config)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#h","title":"h","text":"<ul> <li>height (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#i","title":"i","text":"<ul> <li>ipd (ILLIXR::hmd_physical_info)</li> <li>img0 (ILLIXR::imu_cam_type)</li> <li>img1 (ILLIXR::imu_cam_type)</li> <li>init_time (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_member_variables/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#l","title":"l","text":"<ul> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>linear_a (ILLIXR::imu_cam_type)</li> <li>log_file (ILLIXR::start_end_logger)</li> <li>log_state (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/class_member_variables/#m","title":"m","text":"<ul> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> <li>MAX_TIMEOUT (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/#o","title":"o","text":"<ul> <li>orientation (ILLIXR::pose_type)</li> </ul>"},{"location":"api/class_member_variables/#p","title":"p","text":"<ul> <li>pixel (ILLIXR::camera_frame)</li> <li>position (ILLIXR::pose_type)</li> </ul>"},{"location":"api/class_member_variables/#r","title":"r","text":"<ul> <li>render_pose (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> </ul>"},{"location":"api/class_member_variables/#s","title":"s","text":"<ul> <li>seq (ILLIXR::hologram_input)</li> <li>sample_time (ILLIXR::rendered_frame, ILLIXR::rendered_frame_alt)</li> <li>swap_indices (ILLIXR::rendered_frame_alt)</li> <li>SLEEP_SAFETY_FACTOR (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/#t","title":"t","text":"<ul> <li>time (ILLIXR::imu_cam_type, ILLIXR::pose_type)</li> <li>texture_handle (ILLIXR::rendered_frame)</li> <li>texture_handles (ILLIXR::rendered_frame_alt)</li> </ul>"},{"location":"api/class_member_variables/#v","title":"v","text":"<ul> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#w","title":"w","text":"<ul> <li>width (ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>w (linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#x","title":"x","text":"<ul> <li>x (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 1 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#y","title":"y","text":"<ul> <li>y (linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 2 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#z","title":"z","text":"<ul> <li>z (linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;, linalg::vec&lt; T, 3 &gt;, linalg::vec&lt; T, 4 &gt;)</li> </ul>"},{"location":"api/class_member_variables/#_","title":"_","text":"<ul> <li>_m_terminate (ILLIXR::threadloop)</li> <li>_m_thread (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"api/class_member_typedefs/#t","title":"t","text":"<ul> <li>type (linalg::detail::any_compare&lt; mat&lt; T, M, 1 &gt;, mat&lt; T, M, 1 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 2 &gt;, mat&lt; T, M, 2 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 3 &gt;, mat&lt; T, M, 3 &gt; &gt;, linalg::detail::any_compare&lt; mat&lt; T, M, 4 &gt;, mat&lt; T, M, 4 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 1 &gt;, vec&lt; T, 1 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 2 &gt;, vec&lt; T, 2 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 3 &gt;, vec&lt; T, 3 &gt; &gt;, linalg::detail::any_compare&lt; vec&lt; T, 4 &gt;, vec&lt; T, 4 &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;, linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;, linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;, linalg::detail::make_seq_impl&lt; A, 0 &gt;, linalg::detail::make_seq_impl&lt; A, 1 &gt;, linalg::detail::make_seq_impl&lt; A, 2 &gt;, linalg::detail::make_seq_impl&lt; A, 3 &gt;, linalg::detail::make_seq_impl&lt; A, 4 &gt;, linalg::detail::scalar_type&lt; mat&lt; T, M, N &gt; &gt;, linalg::detail::scalar_type&lt; vec&lt; T, M &gt; &gt;, linalg::detail::scalars&lt;&gt;)</li> </ul>"},{"location":"api/class_member_typedefs/#v","title":"v","text":"<ul> <li>V (linalg::mat&lt; T, M, 1 &gt;, linalg::mat&lt; T, M, 2 &gt;, linalg::mat&lt; T, M, 3 &gt;, linalg::mat&lt; T, M, 4 &gt;)</li> </ul>"},{"location":"api/class_member_enums/","title":"Class Member Enums","text":""},{"location":"api/class_member_enums/#a","title":"a","text":"<ul> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, mat&lt; A, M, N &gt;, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, mat&lt; B, M, N &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A &gt;, A, vec&lt; B, M &gt;, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, B &gt;, A, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A, C &gt;, A, vec&lt; B, M &gt;, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; A... &gt;, A... &gt; (linalg::detail::apply&lt; F, scalars_t&lt; A... &gt;, A... &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, mat&lt; A, M, N &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B &gt;)</li> <li>apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B &gt;, vec&lt; A, M &gt;, B, vec&lt; C, M &gt; &gt;)</li> <li>apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; B, C &gt;, vec&lt; A, M &gt;, B, C &gt;)</li> <li>apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt; (linalg::detail::apply&lt; F, scalars_t&lt; C &gt;, vec&lt; A, M &gt;, vec&lt; B, M &gt;, C &gt;)</li> </ul>"},{"location":"api/class_member_enums/#s","title":"s","text":"<ul> <li>start_end_state (ILLIXR::start_end_logger)</li> </ul>"},{"location":"api/namespace_members/","title":"Namespace Members","text":""},{"location":"api/namespace_members/#a","title":"a","text":"<ul> <li>abs (linalg)</li> <li>acos (linalg)</li> <li>adjugate (linalg)</li> <li>all (linalg)</li> <li>angle (linalg)</li> <li>any (linalg)</li> <li>apply (linalg)</li> <li>apply_t (linalg)</li> <li>argmax (linalg)</li> <li>argmin (linalg)</li> <li>asin (linalg)</li> <li>atan (linalg)</li> <li>atan2 (linalg)</li> </ul>"},{"location":"api/namespace_members/#b","title":"b","text":"<ul> <li>begin (linalg)</li> <li>bool1 (linalg::aliases)</li> <li>bool1x1 (linalg::aliases)</li> <li>bool1x2 (linalg::aliases)</li> <li>bool1x3 (linalg::aliases)</li> <li>bool1x4 (linalg::aliases)</li> <li>bool2 (linalg::aliases)</li> <li>bool2x1 (linalg::aliases)</li> <li>bool2x2 (linalg::aliases)</li> <li>bool2x3 (linalg::aliases)</li> <li>bool2x4 (linalg::aliases)</li> <li>bool3 (linalg::aliases)</li> <li>bool3x1 (linalg::aliases)</li> <li>bool3x2 (linalg::aliases)</li> <li>bool3x3 (linalg::aliases)</li> <li>bool3x4 (linalg::aliases)</li> <li>bool4 (linalg::aliases)</li> <li>bool4x1 (linalg::aliases)</li> <li>bool4x2 (linalg::aliases)</li> <li>bool4x3 (linalg::aliases)</li> <li>bool4x4 (linalg::aliases)</li> <li>byte1 (linalg::aliases)</li> <li>byte2 (linalg::aliases)</li> <li>byte3 (linalg::aliases)</li> <li>byte4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#c","title":"c","text":"<ul> <li>ceil (linalg)</li> <li>clamp (linalg)</li> <li>comatrix (linalg)</li> <li>compare (linalg)</li> <li>copysign (linalg)</li> <li>cos (linalg)</li> <li>cosh (linalg)</li> <li>cross (linalg)</li> <li>conv_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_members/#d","title":"d","text":"<ul> <li>determinant (linalg)</li> <li>diagonal (linalg)</li> <li>distance (linalg)</li> <li>distance2 (linalg)</li> <li>dot (linalg)</li> <li>double1 (linalg::aliases)</li> <li>double1x1 (linalg::aliases)</li> <li>double1x2 (linalg::aliases)</li> <li>double1x3 (linalg::aliases)</li> <li>double1x4 (linalg::aliases)</li> <li>double2 (linalg::aliases)</li> <li>double2x1 (linalg::aliases)</li> <li>double2x2 (linalg::aliases)</li> <li>double2x3 (linalg::aliases)</li> <li>double2x4 (linalg::aliases)</li> <li>double3 (linalg::aliases)</li> <li>double3x1 (linalg::aliases)</li> <li>double3x2 (linalg::aliases)</li> <li>double3x3 (linalg::aliases)</li> <li>double3x4 (linalg::aliases)</li> <li>double4 (linalg::aliases)</li> <li>double4x1 (linalg::aliases)</li> <li>double4x2 (linalg::aliases)</li> <li>double4x3 (linalg::aliases)</li> <li>double4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#e","title":"e","text":"<ul> <li>end (linalg)</li> <li>equal (linalg)</li> <li>exp (linalg)</li> </ul>"},{"location":"api/namespace_members/#f","title":"f","text":"<ul> <li>floor (linalg)</li> <li>fmod (linalg)</li> <li>fold (linalg)</li> <li>frustum_matrix (linalg)</li> <li>fwd_axis (linalg)</li> <li>float1 (linalg::aliases)</li> <li>float1x1 (linalg::aliases)</li> <li>float1x2 (linalg::aliases)</li> <li>float1x3 (linalg::aliases)</li> <li>float1x4 (linalg::aliases)</li> <li>float2 (linalg::aliases)</li> <li>float2x1 (linalg::aliases)</li> <li>float2x2 (linalg::aliases)</li> <li>float2x3 (linalg::aliases)</li> <li>float2x4 (linalg::aliases)</li> <li>float3 (linalg::aliases)</li> <li>float3x1 (linalg::aliases)</li> <li>float3x2 (linalg::aliases)</li> <li>float3x3 (linalg::aliases)</li> <li>float3x4 (linalg::aliases)</li> <li>float4 (linalg::aliases)</li> <li>float4x1 (linalg::aliases)</li> <li>float4x2 (linalg::aliases)</li> <li>float4x3 (linalg::aliases)</li> <li>float4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#g","title":"g","text":"<ul> <li>gequal (linalg)</li> <li>greater (linalg)</li> </ul>"},{"location":"api/namespace_members/#i","title":"i","text":"<ul> <li>identity (linalg)</li> <li>inverse (linalg)</li> <li>int1 (linalg::aliases)</li> <li>int1x1 (linalg::aliases)</li> <li>int1x2 (linalg::aliases)</li> <li>int1x3 (linalg::aliases)</li> <li>int1x4 (linalg::aliases)</li> <li>int2 (linalg::aliases)</li> <li>int2x1 (linalg::aliases)</li> <li>int2x2 (linalg::aliases)</li> <li>int2x3 (linalg::aliases)</li> <li>int2x4 (linalg::aliases)</li> <li>int3 (linalg::aliases)</li> <li>int3x1 (linalg::aliases)</li> <li>int3x2 (linalg::aliases)</li> <li>int3x3 (linalg::aliases)</li> <li>int3x4 (linalg::aliases)</li> <li>int4 (linalg::aliases)</li> <li>int4x1 (linalg::aliases)</li> <li>int4x2 (linalg::aliases)</li> <li>int4x3 (linalg::aliases)</li> <li>int4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_members/#l","title":"l","text":"<ul> <li>length (linalg)</li> <li>length2 (linalg)</li> <li>lequal (linalg)</li> <li>lerp (linalg)</li> <li>less (linalg)</li> <li>log (linalg)</li> <li>log10 (linalg)</li> </ul>"},{"location":"api/namespace_members/#m","title":"m","text":"<ul> <li>make_seq (linalg::detail)</li> <li>map (linalg)</li> <li>max (linalg)</li> <li>maxelem (linalg)</li> <li>min (linalg)</li> <li>minelem (linalg)</li> <li>mul (linalg)</li> </ul>"},{"location":"api/namespace_members/#n","title":"n","text":"<ul> <li>nequal (linalg)</li> <li>nlerp (linalg)</li> <li>normalize (linalg)</li> </ul>"},{"location":"api/namespace_members/#o","title":"o","text":"<ul> <li>operator!= (linalg::detail, linalg)</li> <li>operator&lt; (linalg::detail, linalg)</li> <li>operator&lt;= (linalg::detail, linalg)</li> <li>operator== (linalg::detail, linalg)</li> <li>operator&gt; (linalg::detail, linalg)</li> <li>operator&gt;= (linalg::detail, linalg)</li> <li>operator&lt;&lt; (linalg::ostream_overloads, linalg)</li> <li>operator! (linalg)</li> <li>operator% (linalg)</li> <li>operator%= (linalg)</li> <li>operator&amp; (linalg)</li> <li>operator&amp;= (linalg)</li> <li>operator* (linalg)</li> <li>operator*= (linalg)</li> <li>operator+ (linalg)</li> <li>operator+= (linalg)</li> <li>operator- (linalg)</li> <li>operator-= (linalg)</li> <li>operator/ (linalg)</li> <li>operator/= (linalg)</li> <li>operator&lt;&lt;= (linalg)</li> <li>operator&gt;&gt; (linalg)</li> <li>operator&gt;&gt;= (linalg)</li> <li>operator^ (linalg)</li> <li>operator^= (linalg)</li> <li>operator| (linalg)</li> <li>operator|= (linalg)</li> <li>operator~ (linalg)</li> <li>outerprod (linalg)</li> </ul>"},{"location":"api/namespace_members/#p","title":"p","text":"<ul> <li>perspective_matrix (linalg)</li> <li>pose_matrix (linalg)</li> <li>pow (linalg)</li> <li>product (linalg)</li> </ul>"},{"location":"api/namespace_members/#q","title":"q","text":"<ul> <li>qangle (linalg)</li> <li>qaxis (linalg)</li> <li>qconj (linalg)</li> <li>qexp (linalg)</li> <li>qinv (linalg)</li> <li>qlog (linalg)</li> <li>qmat (linalg)</li> <li>qmul (linalg)</li> <li>qnlerp (linalg)</li> <li>qpow (linalg)</li> <li>qrot (linalg)</li> <li>qslerp (linalg)</li> <li>qxdir (linalg)</li> <li>qydir (linalg)</li> <li>qzdir (linalg)</li> </ul>"},{"location":"api/namespace_members/#r","title":"r","text":"<ul> <li>ret_t (linalg::detail)</li> <li>rot (linalg)</li> <li>rotation_matrix (linalg)</li> <li>rotation_quat (linalg)</li> <li>round (linalg)</li> </ul>"},{"location":"api/namespace_members/#s","title":"s","text":"<ul> <li>short1 (linalg::aliases)</li> <li>short2 (linalg::aliases)</li> <li>short3 (linalg::aliases)</li> <li>short4 (linalg::aliases)</li> <li>scalars_t (linalg::detail)</li> <li>swizzle (linalg::detail, linalg)</li> <li>scalar_t (linalg)</li> <li>scaling_matrix (linalg)</li> <li>select (linalg)</li> <li>sin (linalg)</li> <li>sinh (linalg)</li> <li>slerp (linalg)</li> <li>sqrt (linalg)</li> <li>submat (linalg)</li> <li>subvec (linalg)</li> <li>sum (linalg)</li> </ul>"},{"location":"api/namespace_members/#t","title":"t","text":"<ul> <li>time_type (ILLIXR)</li> <li>tan (linalg)</li> <li>tanh (linalg)</li> <li>trace (linalg)</li> <li>translation_matrix (linalg)</li> <li>transpose (linalg)</li> </ul>"},{"location":"api/namespace_members/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> <li>uint1 (linalg::aliases)</li> <li>uint2 (linalg::aliases)</li> <li>uint3 (linalg::aliases)</li> <li>uint4 (linalg::aliases)</li> <li>ushort1 (linalg::aliases)</li> <li>ushort2 (linalg::aliases)</li> <li>ushort3 (linalg::aliases)</li> <li>ushort4 (linalg::aliases)</li> <li>uangle (linalg)</li> </ul>"},{"location":"api/namespace_members/#z","title":"z","text":"<ul> <li>z_range (linalg)</li> <li>zip (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"api/namespace_member_functions/#a","title":"a","text":"<ul> <li>abs (linalg)</li> <li>acos (linalg)</li> <li>adjugate (linalg)</li> <li>all (linalg)</li> <li>angle (linalg)</li> <li>any (linalg)</li> <li>apply (linalg)</li> <li>argmax (linalg)</li> <li>argmin (linalg)</li> <li>asin (linalg)</li> <li>atan (linalg)</li> <li>atan2 (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#b","title":"b","text":"<ul> <li>begin (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#c","title":"c","text":"<ul> <li>ceil (linalg)</li> <li>clamp (linalg)</li> <li>comatrix (linalg)</li> <li>compare (linalg)</li> <li>copysign (linalg)</li> <li>cos (linalg)</li> <li>cosh (linalg)</li> <li>cross (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#d","title":"d","text":"<ul> <li>determinant (linalg)</li> <li>diagonal (linalg)</li> <li>distance (linalg)</li> <li>distance2 (linalg)</li> <li>dot (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#e","title":"e","text":"<ul> <li>end (linalg)</li> <li>equal (linalg)</li> <li>exp (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#f","title":"f","text":"<ul> <li>floor (linalg)</li> <li>fmod (linalg)</li> <li>fold (linalg)</li> <li>frustum_matrix (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#g","title":"g","text":"<ul> <li>gequal (linalg)</li> <li>greater (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#i","title":"i","text":"<ul> <li>inverse (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#l","title":"l","text":"<ul> <li>length (linalg)</li> <li>length2 (linalg)</li> <li>lequal (linalg)</li> <li>lerp (linalg)</li> <li>less (linalg)</li> <li>log (linalg)</li> <li>log10 (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#m","title":"m","text":"<ul> <li>map (linalg)</li> <li>max (linalg)</li> <li>maxelem (linalg)</li> <li>min (linalg)</li> <li>minelem (linalg)</li> <li>mul (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#n","title":"n","text":"<ul> <li>nequal (linalg)</li> <li>nlerp (linalg)</li> <li>normalize (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator!= (linalg::detail, linalg)</li> <li>operator&lt; (linalg::detail, linalg)</li> <li>operator&lt;= (linalg::detail, linalg)</li> <li>operator== (linalg::detail, linalg)</li> <li>operator&gt; (linalg::detail, linalg)</li> <li>operator&gt;= (linalg::detail, linalg)</li> <li>operator&lt;&lt; (linalg::ostream_overloads, linalg)</li> <li>operator! (linalg)</li> <li>operator% (linalg)</li> <li>operator%= (linalg)</li> <li>operator&amp; (linalg)</li> <li>operator&amp;= (linalg)</li> <li>operator* (linalg)</li> <li>operator*= (linalg)</li> <li>operator+ (linalg)</li> <li>operator+= (linalg)</li> <li>operator- (linalg)</li> <li>operator-= (linalg)</li> <li>operator/ (linalg)</li> <li>operator/= (linalg)</li> <li>operator&lt;&lt;= (linalg)</li> <li>operator&gt;&gt; (linalg)</li> <li>operator&gt;&gt;= (linalg)</li> <li>operator^ (linalg)</li> <li>operator^= (linalg)</li> <li>operator| (linalg)</li> <li>operator|= (linalg)</li> <li>operator~ (linalg)</li> <li>outerprod (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#p","title":"p","text":"<ul> <li>perspective_matrix (linalg)</li> <li>pose_matrix (linalg)</li> <li>pow (linalg)</li> <li>product (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#q","title":"q","text":"<ul> <li>qangle (linalg)</li> <li>qaxis (linalg)</li> <li>qconj (linalg)</li> <li>qexp (linalg)</li> <li>qinv (linalg)</li> <li>qlog (linalg)</li> <li>qmat (linalg)</li> <li>qmul (linalg)</li> <li>qnlerp (linalg)</li> <li>qpow (linalg)</li> <li>qrot (linalg)</li> <li>qslerp (linalg)</li> <li>qxdir (linalg)</li> <li>qydir (linalg)</li> <li>qzdir (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#r","title":"r","text":"<ul> <li>rot (linalg)</li> <li>rotation_matrix (linalg)</li> <li>rotation_quat (linalg)</li> <li>round (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#s","title":"s","text":"<ul> <li>swizzle (linalg::detail, linalg)</li> <li>scaling_matrix (linalg)</li> <li>select (linalg)</li> <li>sin (linalg)</li> <li>sinh (linalg)</li> <li>slerp (linalg)</li> <li>sqrt (linalg)</li> <li>submat (linalg)</li> <li>subvec (linalg)</li> <li>sum (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#t","title":"t","text":"<ul> <li>tan (linalg)</li> <li>tanh (linalg)</li> <li>trace (linalg)</li> <li>translation_matrix (linalg)</li> <li>transpose (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#u","title":"u","text":"<ul> <li>uangle (linalg)</li> </ul>"},{"location":"api/namespace_member_functions/#z","title":"z","text":"<ul> <li>zip (linalg)</li> </ul>"},{"location":"api/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"api/namespace_member_variables/#i","title":"i","text":"<ul> <li>identity (linalg)</li> </ul>"},{"location":"api/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"api/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>apply_t (linalg)</li> </ul>"},{"location":"api/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>bool1 (linalg::aliases)</li> <li>bool1x1 (linalg::aliases)</li> <li>bool1x2 (linalg::aliases)</li> <li>bool1x3 (linalg::aliases)</li> <li>bool1x4 (linalg::aliases)</li> <li>bool2 (linalg::aliases)</li> <li>bool2x1 (linalg::aliases)</li> <li>bool2x2 (linalg::aliases)</li> <li>bool2x3 (linalg::aliases)</li> <li>bool2x4 (linalg::aliases)</li> <li>bool3 (linalg::aliases)</li> <li>bool3x1 (linalg::aliases)</li> <li>bool3x2 (linalg::aliases)</li> <li>bool3x3 (linalg::aliases)</li> <li>bool3x4 (linalg::aliases)</li> <li>bool4 (linalg::aliases)</li> <li>bool4x1 (linalg::aliases)</li> <li>bool4x2 (linalg::aliases)</li> <li>bool4x3 (linalg::aliases)</li> <li>bool4x4 (linalg::aliases)</li> <li>byte1 (linalg::aliases)</li> <li>byte2 (linalg::aliases)</li> <li>byte3 (linalg::aliases)</li> <li>byte4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>conv_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>double1 (linalg::aliases)</li> <li>double1x1 (linalg::aliases)</li> <li>double1x2 (linalg::aliases)</li> <li>double1x3 (linalg::aliases)</li> <li>double1x4 (linalg::aliases)</li> <li>double2 (linalg::aliases)</li> <li>double2x1 (linalg::aliases)</li> <li>double2x2 (linalg::aliases)</li> <li>double2x3 (linalg::aliases)</li> <li>double2x4 (linalg::aliases)</li> <li>double3 (linalg::aliases)</li> <li>double3x1 (linalg::aliases)</li> <li>double3x2 (linalg::aliases)</li> <li>double3x3 (linalg::aliases)</li> <li>double3x4 (linalg::aliases)</li> <li>double4 (linalg::aliases)</li> <li>double4x1 (linalg::aliases)</li> <li>double4x2 (linalg::aliases)</li> <li>double4x3 (linalg::aliases)</li> <li>double4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>float1 (linalg::aliases)</li> <li>float1x1 (linalg::aliases)</li> <li>float1x2 (linalg::aliases)</li> <li>float1x3 (linalg::aliases)</li> <li>float1x4 (linalg::aliases)</li> <li>float2 (linalg::aliases)</li> <li>float2x1 (linalg::aliases)</li> <li>float2x2 (linalg::aliases)</li> <li>float2x3 (linalg::aliases)</li> <li>float2x4 (linalg::aliases)</li> <li>float3 (linalg::aliases)</li> <li>float3x1 (linalg::aliases)</li> <li>float3x2 (linalg::aliases)</li> <li>float3x3 (linalg::aliases)</li> <li>float3x4 (linalg::aliases)</li> <li>float4 (linalg::aliases)</li> <li>float4x1 (linalg::aliases)</li> <li>float4x2 (linalg::aliases)</li> <li>float4x3 (linalg::aliases)</li> <li>float4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>int1 (linalg::aliases)</li> <li>int1x1 (linalg::aliases)</li> <li>int1x2 (linalg::aliases)</li> <li>int1x3 (linalg::aliases)</li> <li>int1x4 (linalg::aliases)</li> <li>int2 (linalg::aliases)</li> <li>int2x1 (linalg::aliases)</li> <li>int2x2 (linalg::aliases)</li> <li>int2x3 (linalg::aliases)</li> <li>int2x4 (linalg::aliases)</li> <li>int3 (linalg::aliases)</li> <li>int3x1 (linalg::aliases)</li> <li>int3x2 (linalg::aliases)</li> <li>int3x3 (linalg::aliases)</li> <li>int3x4 (linalg::aliases)</li> <li>int4 (linalg::aliases)</li> <li>int4x1 (linalg::aliases)</li> <li>int4x2 (linalg::aliases)</li> <li>int4x3 (linalg::aliases)</li> <li>int4x4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>make_seq (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>ret_t (linalg::detail)</li> </ul>"},{"location":"api/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>short1 (linalg::aliases)</li> <li>short2 (linalg::aliases)</li> <li>short3 (linalg::aliases)</li> <li>short4 (linalg::aliases)</li> <li>scalars_t (linalg::detail)</li> <li>scalar_t (linalg)</li> </ul>"},{"location":"api/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>time_type (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> <li>uint1 (linalg::aliases)</li> <li>uint2 (linalg::aliases)</li> <li>uint3 (linalg::aliases)</li> <li>uint4 (linalg::aliases)</li> <li>ushort1 (linalg::aliases)</li> <li>ushort2 (linalg::aliases)</li> <li>ushort3 (linalg::aliases)</li> <li>ushort4 (linalg::aliases)</li> </ul>"},{"location":"api/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"api/namespace_member_enums/#f","title":"f","text":"<ul> <li>fwd_axis (linalg)</li> </ul>"},{"location":"api/namespace_member_enums/#z","title":"z","text":"<ul> <li>z_range (linalg)</li> </ul>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#i","title":"i","text":"<ul> <li>init_and_link (shader_util.hpp)</li> </ul>"},{"location":"api/functions/#m","title":"m","text":"<ul> <li>MessageCallback (shader_util.hpp)</li> </ul>"},{"location":"api/macros/","title":"Macros","text":""},{"location":"api/macros/#g","title":"g","text":"<ul> <li>GLX_CONTEXT_MAJOR_VERSION_ARB (extended_window.hpp)</li> <li>GLX_CONTEXT_MINOR_VERSION_ARB (extended_window.hpp)</li> </ul>"},{"location":"api/macros/#l","title":"l","text":"<ul> <li>LINALG_CONSTEXPR14 (linalg.hpp)</li> <li>LINALG_H (linalg.hpp)</li> </ul>"},{"location":"api/macros/#n","title":"n","text":"<ul> <li>NANO_SEC (data_format.hpp)</li> </ul>"},{"location":"api/macros/#p","title":"p","text":"<ul> <li>PLUGIN_MAIN (plugin.hpp)</li> </ul>"},{"location":"api/macros/#u","title":"u","text":"<ul> <li>USE_ALT_EYE_FORMAT (data_format.hpp)</li> </ul>"},{"location":"api/variables/","title":"Variables","text":""},{"location":"api/variables/#g","title":"g","text":"<ul> <li>glXCreateContextAttribsARBProc (extended_window.hpp)</li> </ul>"},{"location":"api/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}