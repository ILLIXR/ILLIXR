"""This script generates record_types.hpp.

This is because writing out all of the record types involves a lot of repetition, that must be
gotten right for the system to work. Attribute names have to be written in 5 places, last time I counted.

This will also make it far easier if we need to add some functionality to all of the classes (we can
do it once in bulk).

If you are defining your own record_types, consider importing `record_types.py` and calling `record_type_class`.

"""

from pathlib import Path
from typing import NamedTuple, Optional, List

class Field(NamedTuple):
    """C++ record_class field

    type: C++ type name
    name: C++ member name
    default: if default is None, then I get the field's value from the constructor. Otherwise, it should be an expression."""

    type: str
    name: str
    default: Optional[str]

class RecordType(NamedTuple):
    name: str
    fields: List[Field]

component = Field("std::size_t", "component_id", None)
iteration = Field("std::size_t", "iteration", None)
skip_iteration = Field("std::size_t", "skip_iteration", None)
cpu_time = Field("std::chrono::nanoseconds", "cpu_time", "thread_cpu_time()")
topic_id = Field("std::size_t", "topic_id", None)
serial_no = Field("std::size_t", "serial_no", None)
name = Field("std::string", "name", None)

record_types = [
    RecordType("misc_record", [
        component,
        Field("std::string", "notes", None),
    ]),
    RecordType("component_start_record", [
        component,
        name,
    ]),
    RecordType("component_stop_record", [
        component,
    ]),
    RecordType("start_skip_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("stop_skip_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("start_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("stop_iteration_record", [
        component,
        iteration,
        skip_iteration,
        cpu_time,
    ]),
    RecordType("start_callback_record", [
        component,
        topic_id,
        serial_no,
        cpu_time,
    ]),
    RecordType("stop_callback_record", [
        component,
        topic_id,
        serial_no,
        cpu_time,
    ]),
    RecordType("switchboard_topic_record", [
        component,
        topic_id,
        Field("std::string", "type_name", None),
        name,
        Field("std::size_t", "bytes", None)
    ]),
    RecordType("switchboard_write_record", [
        component,
        topic_id,
        serial_no,
    ]),
    RecordType("switchboard_read_record", [
        component,
        topic_id,
        serial_no,
    ]),
]

def to_cpp_name(string: str) -> str:
    return string.replace(":", "_")

def record_type_class(record_type: RecordType, type_id: int) -> str:
    arg_list = ", ".join(
        f"{field.type} {field.name}_ "
        for field in record_type.fields if field.default is None
    )
    init_list = ",\n\t\t".join(
        field.name + "{" + (field.name + "_" if field.default is None else field.default) + "}"
        for field in record_type.fields
    )
    member_list = "\n\t".join(f"{field.type} {field.name};" for field in record_type.fields)

    base_type_vector = "{\n\t\t" + ",\n\t\t".join(f"{{\"{field.name}\", &types::{to_cpp_name(field.type)}}}" for field in record_type.fields) + "\n\t}"

    return f"""
/**
 * @brief A container for log records.
 *
 * This class is generated by common/record_types.py:
 *
 * \code{{.py}}
 * record_type_class({record_type!r})
 * \endcode
 */
struct {record_type.name} : public record {{
	{record_type.name}({arg_list})
		: {init_list}
	{{ }}
	static const struct_type type_descr;
	{member_list}
}};

static_assert(std::is_standard_layout<{record_type.name}>::value);

const struct_type {record_type.name}::type_descr = struct_type{{
	sizeof({record_type.name}),
	\"{record_type.name}\",
	{type_id},
	{base_type_vector},
}};

"""

if __name__ == '__main__':
    # Specifiying the path relative to __file__ means that this script will work no matter what the CWD is.
    with (Path(__file__).parent / "record_types.hpp").open("w") as f:
        f.write(f"""
#pragma once

/**
 * Do not write to this file directly (but it can be read on its own).
 * It is automatically generated by record_types.py
 */

#include <chrono>
#include <vector>
#include <type_traits>

namespace ILLIXR {{

    /**
     * @brief A light-weight RTTI discriminator.
     *
     * Unlike [std::type_info][1], this can be used to recover the size and original name.
     * 
     * [1]: https://en.cppreference.com/w/cpp/types/type_info
     */
    class type {{
    public:
            std::size_t size;
            std::string name;
            std::size_t type_id;
            type(std::size_t size_, std::string name_, std::size_t type_id_)
                    : size{{size_}}
                    , name{{name_}}
                    , type_id{{type_id_}}
            {{ }}
    }};

    /**
     * @brief Specifies the structure of a struct or tuple type.
     *
     * This is useful if one needs to accept a struct of an unknown type. Accept the struct as void*
     * and a struct_type specification.
     *
     * Alternatives
     * - Use a vector of `std::any` and test (`std::any_cast`) every type you know.
     *   - This is safe but prohibitively slow.
     *   - This is not available in C++11.
     * - Use subclasses and test (`dynamic_cast`) against every subclass you know.
     *   - This requires recompile any time you want to add a type.
     *   - This is also slow.
     */
    class struct_type : public type {{
    public:
            std::vector<std::pair<std::string, const type*>> fields;
            struct_type(std::size_t size_, std::string name_, std::size_t type_id_, std::vector<std::pair<std::string, const type*>> fields_)
                    : type{{size_, name_, type_id_}}
                    , fields{{fields_}}
            {{ }}
    }};

    /**
     * @brief Superclass of all records.
     *
     * New record types do not have to be defined here, but they must:
     *   1. inherit from this `record` class;
     *   2. have a correct `static const struct_type type_descr` (types must be in the same order in the new record type class as they are in the type_descr vector);
     *   3. use base-types that the logging-backend supports;
     *   4. have a unique, non-zero type_id. I recommend a random number. The compiler prefers this type_id to be a statically known constant.
     *
     * This involves a significant amount of repetition, so consider importing `record_types.py` and calling `record_type_class`.
     *
     * New base types do not have to be defined here, but they must:
     *   1. be supported by the logging-backend 
     *   2. have a unique, non-zero type_id. I recommend a random number. The compiler prefers this type_id to be a statically known constant.
     *
     * See the below for examples.
     */
    struct record {{ }};

    namespace types {{

""".lstrip())


        base_types = sorted(set(
            # set(some_list) uniqifies some_list
            field.type
            for record_type in record_types
            for field in record_type.fields
        ))

        f.write("""/*
These are some predefined base types.
*/
""")
        for i, base_type in enumerate(base_types):
            f.write(f"static const type {to_cpp_name(base_type)} {{sizeof({base_type}), std::string{{\"{base_type}\"}}, {i+1}}};\n")

        f.write("""
    } /* namespace types */

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-private-field"
""")


        f.write("""/*
These are some predefined record types.
*/
""")
        for type_id, record_type in enumerate(record_types):
            f.write(record_type_class(record_type, type_id + len(base_types) + 1))

        f.write("""
#pragma GCC diagnostic pop
} /* namespace ILLIXR */
    """)
