//this code decouples mesh compression from InfiniTAM, this receives the obj file from InfiniTAM and performs draco compression on it and publishes in compressed draco format
#include "common/plugin.hpp"
#include "common/switchboard.hpp"
#include "common/data_format.hpp"
#include "common/relative_clock.hpp"
#include "common/phonebook.hpp"

#include <iostream>
#include <stdio.h>
#include "illixr_ipc.pb.h"
//decouple payload generation from ipc server
//ipc server should be a thread loop that constantly listen for new connection and grab the latest payload generated by this plugin
using namespace ILLIXR;
class PayloadGen : public plugin {
    public:
        PayloadGen(std::string name_, phonebook* pb_)
            : plugin{name_, pb_}
        , sb{pb->lookup_impl<switchboard>()}
        //, _m_uncompressed_mesh{sb->get_reader<mesh_type>("original_scene")}
        , _m_uncompressed_mesh{sb->get_reader<mesh_demo_type>("original_scene")}
        , _m_payload{sb->get_writer<payload_type>("mesh_payload")}
        {
            face_count=0;
            vertex_count=0;

            sb->schedule<mesh_demo_type>(id,"original_scene",[&](switchboard::ptr<const mesh_demo_type> datum, std::size_t){ 
                    this->ProcessFrame(datum);
            });
        }

        void ProcessFrame(switchboard::ptr<const mesh_demo_type> datum)
        {
            printf("===========Payload Generation for mesh  %d=========================\n", datum->id);
               //TODO Copy the payload generation from Sainath
               
               std::vector<char> line;
               payload = new ILLIXRIPC::IPCPayload;
               ILLIXRIPC::Mesh* ipcMesh = payload->add_meshes();
               for(unsigned i=0; i< datum->index_x.size(); ++i)
               {
                    ILLIXRIPC::Vector3* ipcVertex = ipcMesh->add_vertices();
                    ipcVertex->set_x(datum->index_x[i]);
                    ipcVertex->set_y(datum->index_y[i]);
                    ipcVertex->set_z(datum->index_z[i]);
                    ILLIXRIPC::Color* ipcColor = ipcMesh->add_vertexcolors();
                    ipcColor->set_r(datum->color_r[i]);
                    ipcColor->set_g(datum->color_g[i]);
                    ipcColor->set_b(datum->color_b[i]);
               }
               for(unsigned j=0; j<datum->face_1.size(); ++j)
               {
                    ipcMesh->add_faces(datum->face_1[j]);
                    ipcMesh->add_faces(datum->face_2[j]);
                    ipcMesh->add_faces(datum->face_3[j]);
               }
               //performs serializeMessage() in the IPC server
               std::string payload_msg;
               payload->SerializeToString(&payload_msg);
               std::string msgSize = std::to_string(payload_msg.size());
               payload_msg.insert(msgSize.size(), 10 - msgSize.size(), ' ');
               payload_msg = msgSize + payload_msg;

               //send to switchboard
               _m_payload.put(_m_payload.allocate<payload_type>(payload_type{payload_msg, datum->id}));
               printf("payload for %u generated\n", datum->id); 
               delete payload;
        }

        virtual ~PayloadGen() override{
        }

    private:
        //ILLIXR related variables
        const std::shared_ptr<switchboard> sb;
        switchboard::reader<mesh_demo_type> _m_uncompressed_mesh;
        switchboard::writer<payload_type> _m_payload;
        ILLIXRIPC::IPCPayload* payload;

        unsigned vertex_count;
        unsigned face_count;
};

PLUGIN_MAIN(PayloadGen)
