{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ILLIXR","text":"<p>Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is     the first fully open-source Extended Reality (XR) system and testbed. The modular, extensible, and OpenXR-compatible ILLIXR runtime     integrates state-of-the-art XR components into a complete XR system. The testbed is part of the broader ILLIXR consortium,     an industry-supported community effort to democratize XR systems     research, development, and benchmarking.</p> <p>You can find the complete ILLIXR system here.</p> <p>ILLIXR also provides its components in standalone configurations to enable architects and     system designers to research each component in isolation. The standalone components are packaged together in the as of the v3.1.0 release of ILLIXR. </p> <p>ILLIXR's modular and extensible runtime allows adding new components and swapping different     implementations of a given component. ILLIXR currently contains the following components: </p> <ul> <li> <p>Perception</p> <ul> <li>Eye Tracking<ol> <li>RITNet **</li> </ol> </li> <li>Scene Reconstruction<ol> <li>ElasticFusion **</li> <li>KinectFusion **</li> </ol> </li> <li>Simultaneous Localization and Mapping<ol> <li>OpenVINS **</li> </ol> </li> <li>Cameras and IMUs<ol> <li>ZED Mini</li> <li>Intel RealSense</li> </ol> </li> </ul> </li> <li> <p>Visual</p> <ul> <li>Chromatic aberration correction</li> <li>Computational holography for adaptive multi-focal displays **</li> <li>Lens distortion correction</li> <li>Asynchronous Reprojection (TimeWarp)</li> </ul> </li> <li> <p>Aural</p> <ul> <li>Audio encoding **</li> <li>Audio playback **</li> </ul> </li> </ul> <p>(** Source is hosted in an external repository under the ILLIXR project.)</p> <p>We continue to add more components (new components and new implementations). </p> <p>Many of the current components of ILLIXR were developed by domain experts and obtained from     publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features,     or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for     proper attribution to its authors.</p>"},{"location":"#papers-talks-demos-consortium","title":"Papers, talks, demos, consortium","text":"<p>A paper with details on ILLIXR, including its components, runtime, telemetry support,     and a comprehensive analysis of performance, power, and quality on desktop and embedded systems.</p> <p>A talk presented at NVIDIA GTC'21 describing ILLIXR and announcing the ILLIXR consortium:     Video.     Slides. </p> <p>A demo of an OpenXR application running with ILLIXR.</p> <p>For more up-to-date list of related papers, demos, and talks, please visit illixr.org.</p> <p>The ILLIXR consortium is an industry-supported community effort to democratize     XR systems research, development, and benchmarking. Visit our web site for more information.</p> <p>The ILLIXR consortium is also holding a biweekly consortium meeting. For past meetings, for more information, past meeting recordings, and request for presenting, please visit here. Please join our Discord for announcement. </p>"},{"location":"#citation","title":"Citation","text":"<p>We request that you cite our following paper when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.</p> <pre><code>@inproceedings{HuzaifaDesai2021,\n  author={Huzaifa, Muhammad and Desai, Rishi and Grayson, Samuel and Jiang, Xutao and Jing, Ying and Lee, Jae and Lu, Fang and Pang, Yihan and Ravichandran, Joseph and Sinclair, Finn and Tian, Boyuan and Yuan, Hengzhi and Zhang, Jeffrey and Adve, Sarita V.},\n  booktitle={2021 IEEE International Symposium on Workload Characterization (IISWC)}, \n  title={ILLIXR: Enabling End-to-End Extended Reality Research}, \n  year={2021},\n  volume={},\n  number={},\n  pages={24-38},\n  doi={10.1109/IISWC53511.2021.00014}\n}\n</code></pre>"},{"location":"#getting-started-and-documentation","title":"Getting Started and Documentation","text":"<p>For more information, see our Getting Started page.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The ILLIXR project started in Sarita Adve\u2019s research group,     co-led by PhD candidate Muhammad Huzaifa, at the University of Illinois at Urbana-Champaign. Other major contributors include     Rishi Desai,     Samuel Grayson,     Xutao Jiang,     Ying Jing,     Jae Lee,     Fang Lu,     Yihan Pang,     Joseph Ravichandran,     Giordano Salvador,     Finn Sinclair,     Boyuan Tian,     Henghzhi Yuan,     and     Jeffrey Zhang.</p> <p>ILLIXR came together after many consultations with researchers and practitioners in many domains:     audio,     graphics,     optics,     robotics,     signal processing,     and     extended reality systems. We are deeply grateful for all of these discussions and specifically to the following:     Wei Cu,     Aleksandra Faust,     Liang Gao,     Matt Horsnell,     Amit Jindal,     Steve LaValle,     Steve Lovegrove,     Andrew Maimone,     Vegard \u00d8ye,     Martin Persson,     Archontis Politis,     Eric Shaffer,     Paris Smaragdis,     Sachin Talathi,     and     Chris Widdowson.</p> <p>Our OpenXR implementation is derived from Monado. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.</p> <p>The development of ILLIXR was supported by     the Applications Driving Architectures (ADA) Research Center         (a JUMP Center co-sponsored by SRC and DARPA),     the Center for Future Architectures Research (C-FAR, a STARnet research center),     a Semiconductor Research Corporation program sponsored by MARCO and DARPA,     and     by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations     from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset.</p> <p>Wesley Darvin came up with the name for ILLIXR.</p>"},{"location":"#licensing-structure","title":"Licensing Structure","text":"<p>ILLIXR is available as open-source software under the permissive     University of Illinois/NCSA Open Source License. As mentioned above, ILLIXR largely consists of components developed by domain experts and     modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software. The external libraries and softwares included in ILLIXR each have their own licenses and     must be used according to those licenses:</p> <ul> <li> <p>ElasticFusion \\ ElasticFusion license</p> </li> <li> <p>KinectFusion \\ MIT License</p> </li> <li> <p>GTSAM \\ Simplified BSD License</p> </li> <li> <p>HOTlab \\ GNU Lesser General Public License v3.0</p> </li> <li> <p>libspatialaudio \\ GNU Lesser General Public License v2.1</p> </li> <li> <p>Monado \\ Boost Software License 1.0</p> </li> <li> <p>moodycamel::ConcurrentQueue \\ Simplified BSD License</p> </li> <li> <p>Open-VINS \\ GNU General Public License v3.0</p> </li> <li> <p>RITnet \\ MIT License</p> </li> </ul> <p>Note that ILLIXR's extensibility allows the source to be configured and compiled using only     permissively licensed software.</p>"},{"location":"#get-in-touch","title":"Get in Touch","text":"<p>Whether you are a computer architect, a compiler writer, a systems person, work on XR related algorithms     or applications, or just anyone interested in XR research, development, or products,     we would love to hear from you and hope you will contribute! You can join     the ILLIXR consortium,     Discord,     or mailing list,     or send us an email,     or just send us a pull request!</p>"},{"location":"CONTRIBUTING/","title":"Contributing Guidelines","text":"<p>Please follow these steps when making pull requests (PRs):</p> <ol> <li> <p>First, create an issue describing the problem that needs to be fixed.     If an issue already exists, skip this step.     If you are looking for an issue to fix, see the \"good first issue\" label.</p> </li> <li> <p>Assign the issue to yourself and add appropriate labels.     If you are an external contributor, comment on the issue so one of the ILLIXR team members         can assign the issue to you.</p> </li> <li> <p>Before you start making changes, make a new branch.     The branch MUST be named <code>issue-&lt;issue number&gt;-&lt;some descriptive name&gt;</code>.     For instance, <code>issue-32-fix-mem-leak</code> addresses the memory leak described in Issue #32.</p> </li> <li> <p>Fix the issue.</p> </li> <li> <p>Add your name to <code>ILLIXR/CONTRIBUTORS</code>.</p> </li> <li> <p>Push commits up to GitHub.</p> </li> <li> <p>Open a PR, and link it to the issue that the PR aims to resolve.     Please give the PR a descriptive name.</p> </li> <li> <p>As you make progress on your PR, keep your branch up-to-date with the <code>master</code> branch which         may have been updated after starting your PR.     Your PR MUST be updated to reflect changes to <code>master</code> in order to be merged.     Use the following procedure for updating your branch and when you are ready to commit your changes:</p> <pre><code>## While on your PR branch &lt;issue-branch&gt; hosted at &lt;your-remote&gt; repository:\ngit commit # or git stash                                               ## Line A\ngit checkout master\n\ngit pull &lt;illixr-remote&gt; master --rebase &amp;&amp; git fetch &lt;illixr-remote&gt;   ## Line B\n\ngit checkout &lt;issue-branch&gt;\ngit rebase master                                                       ## Line C\n\n## If you stashed your changes on 'Line A':\ngit stash apply &lt;stash-number&gt; &amp;&amp; git commit\n\ngit push &lt;your-remote&gt; &lt;issue-branch&gt; --force-with-lease                ## Line D\n</code></pre> <p>For ILLIXR team members (others jump here):</p> <ul> <li> <p>In the example above, <code>&lt;illixr-remote&gt;</code> and <code>&lt;your-remote&gt;</code> are the same.</p> </li> <li> <p>When collaborating on branches in our repository, <code>Line B</code> may pull in changes that overwrite         the git commit history when performing <code>Line C</code>.     Subsequently, performing <code>Line D</code> will rewrite the history in the public branch.     To preserve branch commit histories in the case that a rollback is needed, we will employ         a checkpointing process for force updated branches.     This process will be manually performed, but may be automated in the future.</p> <p>If <code>Line B</code> shows an update to master, the following example illustrates your local repository     just after performing <code>Line B</code>:</p> <pre><code>A -- B -- C -- P -- Q -- R                                          ## master\n           \\\n            D -- E -- F                                             ## issue-123-fixing-bug\n</code></pre> <p>In this example, commits <code>P</code>, <code>Q</code>, and <code>R</code> have been merged to <code>master</code>     (from feature branches not shown) after feature branch <code>issue-123-fixing-bug</code> was     forked from <code>master</code>.</p> <p>To checkpoint the <code>issue-123-fixing-bug</code> branch while it is checked out:</p> <pre><code>git branch issue-123.0-fixing-bug                                   ## Make alias for old issue-123-fixing-bug\ngit checkout -b issue-123.1-fixing-bug                              ## Make new branch to rebase with master\ngit rebase master                                                   ## Replay issue-123-fixing-bug onto master\ngit branch -D issue-123-fixing-bug                                  ## Remove old issue-123-fixing-bug\ngit branch issue-123-fixing-bug                                     ## Make issue-123-fixing-bug an alias of new branch\ngit push &lt;illixr-remote&gt; issue-123.{0,1}-fixing-bug                 ## Push new checkpointed branches to remote\ngit push &lt;illixr-remote&gt; issue-123-fixing-bug --force-with-lease    ## Force update issue-123-fixing-bug\n</code></pre> <p>Note: The term alias here is used to refer to branches which point to the same commit. This usage is different from standard Git Aliases used for git command shortcuts.</p> <p>After checkpointing, your local repository should look as follows:</p> <pre><code>                           D' -- E' -- F'                           ## issue-123.1-fixing-bug, issue-123-fixing-bug\n                          /\nA -- B -- C -- P -- Q -- R                                          ## master\n           \\\n            D -- E -- F                                             ## issue-123.0-fixing-bug\n</code></pre> <p>Commits <code>D</code>, <code>E</code>, and <code>F</code> have been added to a new branch starting from <code>R</code>,     but now have been given new hashes. This new branch is our up-to-date copy of the feature branch <code>issue-123-fixing-bug</code>.</p> <p>While working on a checkpointed branch, keep aliases up-to-date using <code>git rebase</code>:</p> <pre><code>git commit                                                          ## Add changes to issue-123.1-fixing-bug\ngit checkout issue-123-fixing-bug                                   ## Switch to main issue-123-fixing-bug branch\ngit rebase issue-123.1-fixing-bug                                   ## Fast-forward issue-123-fixing-bug to issue-123.1-fixing-bug\n</code></pre> <p>Conflicts are possible when two or more collaborators push changes concurrently to     the same branch. As long as each collaborator ensures that the branch update process starts at <code>Line A</code>,     conflicts can be detected and handled locally. In other words, every call to <code>git-push</code> should be preceeded by a call to <code>git-pull</code>,     following the process from <code>Line A</code> to <code>Line D</code> (or equivalent; git's CLI allows many     ways to achieve the same results).</p> <p>Note: <code>Line B</code> rebases the <code>master</code> branch assuming that we have checked out <code>master</code>. Forgetting to specify <code>master</code> in <code>Line B</code> may result in a lossy forced update in the     example below. Forgetting to checkout <code>master</code> will immediately apply your checked out feature branch's     changes, possibly also resulting in a lossy forced update.</p> <p>The output of <code>Line B</code> for a collaborator after the checkpointing process may contain     something like this:</p> <pre><code>From github.com:ILLIXR/ILLIXR\n  A..R          master                  -&gt; &lt;illixr-remote&gt;/master\n+ A..F'         issue-123-fixing-bug    -&gt; &lt;illixr-remote&gt;/issue-123-fixing-bug  (forced update)\n* [new branch]  issue-123.0-fixing-bug  -&gt; &lt;illixr-remote&gt;/issue-123.0-fixing-bug\n* [new branch]  issue-123.1-fixing-bug  -&gt; &lt;illixr-remote&gt;/issue-123.1-fixing-bug\n</code></pre> <p>Conflicts which do not involve updates to the <code>master</code> branch can be resolved simply     by rebasing the current feature branch with the updated feature branch,     applying new changes on top of the updated feature branch:</p> <pre><code>## For the latest checkpoint X (local) and Y (remote), let Z := Y + 1 in\ngit checkout issue-123.X-fixing-bug -b issue-123.Z-fixing-bug       ## Make new branch issue-123.Z-fixing-bug\ngit rebase &lt;illixr-remote&gt;/issue-123.Y-fixing-bug                   ## Replay updates from issue-123.X-fixing-bug\ngit push &lt;illixr-remote&gt; issue-123.Z-fixing-bug                     ## Make sure to update issue-123-fixing-bug after\n</code></pre> <p>The <code>--force-with-lease</code> argument in <code>Line D</code> is not required for our new checkpoint branch,     since a new branch should not conflict with a non-existing remote branch. We expect the subversion number for a new branch resulting from our     checkpoint conflict resolution to be new and unique. If the push fails, another conflict has occurred, and checkpoint conflict resolution     should be repeated. <code>Line D</code> should be safe to perform for the main feature branch now that we have     replayed our commits on top of the updated feature branch.</p> <p>Note: In the above example, the <code>git-rebase</code> is performed using the remote copy of     the checkpointed branch. We do this because <code>Line B</code> will not fast-forward or force update our local branches     (with the same subversion number as a conflicting remote branch, if any).</p> <p>In the case of a conflict with updates to <code>master</code>, <code>Line A</code> should show updates to     both the <code>master</code> branch and the feature branch to be pushed in <code>Line D</code>. A checkpointed version of the feature branch may also appear. This is because a feature branch should only be checkpointed in the presence of a     change to the <code>master</code> branch. Forced pushes should generally not be used for any other purpose. If multiple updates to <code>master</code> and the feature branch have occured, additional     checkpointed versions of the feature branch may also appear. In this scenario, we need to rebase our latest version of the feature branch with     the latest version of the feature branch pulled from <code>&lt;illixr-remote&gt;</code>.</p> </li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#philosophy","title":"Philosophy","text":"<p>Why are the above steps necessary?</p> <ol> <li> <p>Assigning the issue to yourself ensures that multiple people don't work on the same thing         in parallel.</p> </li> <li> <p>The branch naming scheme organizes things a bit for us, and also makes it easy to find branches.</p> </li> <li> <p>Linking the issue to the PR ensures that we know which issue is being resolved,         and also automatically closes the issue when the PR gets merged.</p> </li> <li> <p>Using rebases keeps the <code>master</code> and feature branch histories streamlined (minimizing branching),         thus making it easier to compose feature branches for integration testing.     See this article on rebasing public branches for more information.</p> </li> </ol> <p>If your PR has not seen activity from the ILLIXR team after a long period of time (e.g., 2 weeks),     feel free to contact the team directly on the GitHub Issue Conversation tab or at     the Gitter forum linked below.</p>"},{"location":"CONTRIBUTING/#other-procedures","title":"Other Procedures","text":"<ol> <li> <p>Branch Management:</p> <p>The branch rebasing and checkpointing process detailed above is tedious, and may be automated in     the future. Check back in with this document occasionally for improvements to the branch management process.</p> </li> <li> <p>Code Formatting:</p> <p>As ILLIXR grows, contributions will need to be standardized to accomodate multiple collaborators     with different coding styles. During code review of a PR, you may be asked to reformat your code to match the standards set for     ILLIXR code base. This process may be manually triggered by a comment from a review, or automated via Git and GitHub     in the future.</p> </li> <li> <p>Issue Templates:</p> <p>To make collaboration easier, templates for Issues and Pull Requests will be added to     the GitHub web interface. If an appropriate template exists for your task, please ensure to select it before submitting.</p> </li> </ol>"},{"location":"CONTRIBUTING/#getting-help","title":"Getting Help","text":"<p>You can get seek help from our development community in three places:</p> <ol> <li> <p>Main documentation site</p> </li> <li> <p>API documentation site</p> </li> <li> <p>Gitter community forum</p> </li> </ol>"},{"location":"LICENSE/","title":"ILLIXR License","text":"<p>Copyright (c) 2019 The Board of Trustees of the University of Illinois.  All rights reserved.</p> <p>Developed by: Professor Sarita Adve's research group               University of Illinois at Urbana-Champaign               http://rsim.cs.illinois.edu</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: * Redistributions of source code must retain the above copyright notice,   this list of conditions and the following disclaimers. * Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimers in the documentation   and/or other materials provided with the distribution. * Neither the names of Professor Sarita Adve's research group, University of   Illinois at Urbana-Champaign, nor the names of its contributors may be used   to endorse or promote products derived from this Software without specific   prior written permission.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.</p>"},{"location":"debugging_illixr/","title":"ILLIXR Debugging Tips","text":""},{"location":"debugging_illixr/#debugging-locally","title":"Debugging Locally","text":"<p>The config described in Getting Started supports running the runtime with     arbitrary commands like <code>gdb</code>. When debugging locally, we recommend using either <code>gdb</code> or <code>valgrind</code> in this way.</p>"},{"location":"debugging_illixr/#debugging-pull-requests-or-with-a-clean-environment","title":"Debugging Pull Requests or with a Clean Environment","text":""},{"location":"debugging_illixr/#1-get-a-docker-image","title":"1. Get a Docker Image","text":""},{"location":"debugging_illixr/#from-your-local-project","title":"From your Local Project","text":"<p>From the root directory in your project, run:</p> <pre><code>docker build [--build-arg=JOBS=\"&lt;integer&gt;\"] [--no-cache] --tag &lt;repository&gt;:&lt;tag&gt; .\n</code></pre> <p>Note the optional <code>Dockerfile</code> argument, <code>JOBS</code>, which specifies the number of threads/tasks to use for building. Also note the optional argument, <code>--no-cache</code>, which forces Docker to rerun commands in <code>Dockerfile</code>     (see this article for more information). For this project's main module, you can use something like <code>illixr-illixr</code> for the <code>&lt;repository&gt;</code> value,     and your current branch name or release version as the <code>&lt;tag&gt;</code> value.</p> <p>Note that building the docker image can take some time (up to 40min on a 4-core desktop machine) and uses somewhere between 2-4GB of RAM.</p>"},{"location":"debugging_illixr/#from-a-github-pull-requests-cicd-flow","title":"From a GitHub Pull Request's CI/CD Flow","text":"<p>Follow these steps when a CI/CD build fails on a PR:</p> <ul> <li> <p>Click <code>details</code> on the failing build.</p> </li> <li> <p>In the build view go to the Push Docker Image tab and copy the <code>docker push ghcr.io/illixr/illixr-tests:&lt;branch-name&gt;</code> command.</p> </li> <li> <p>Then in your terminal, run:</p> <pre><code>docker pull ghcr.io/illixr/illixr-tests:&lt;branch-name&gt;\n</code></pre> </li> </ul>"},{"location":"debugging_illixr/#2-test-your-image-in-the-docker-container","title":"2. Test your Image in the Docker container","text":"<p>Verify that your image was created successfully:</p> <pre><code>docker image ls\n</code></pre> <p>Take note of your image's <code>REPOSITORY</code> and <code>TAG</code> values. Now run:</p> <pre><code>docker run -it --entrypoint /bin/bash &lt;repository&gt;:&lt;tag&gt;\n</code></pre> <p>You are now in a bash shell in a docker container.</p> <p>From here you can test whichever project flow you wish, such as the usual <code>main.opt.exe --yaml illixr.yaml</code>.</p>"},{"location":"external_switchboard_and_phonebook/","title":"Using Switchboard and Phonebook Externally","text":"<p>Switchboard was designed as a self-contained entity from ILLIXR that one can reuse in other projects. The relevant API is here for Switchboard and here for Phonebook.</p> <p>One simply needs to copy these files, maintaining directory structure.</p> <pre><code>illixr/switchboard.hpp\nillixr/phonebook.hpp\nillixr/record_logger.hpp\nillixr/managed_thread.hpp\nillixr/concurrentqueue/blockingconcurrentqueue.hpp\nillixr/concurrentqueue/concurrentqueue.hpp\nillixr/concurrentqueue/lightweightsemaphore.hpp\n</code></pre> <p>This will serve as our <code>main.cpp</code>:</p> <pre><code>#include &lt;iostream&gt;\n#include \"illixr/switchboard.hpp\"\n\nclass service : public ILLIXR::phonebook::service {\npublic:\n    void act() { std::cout &lt;&lt; \"Hello from service\\n\"; };\n};\n\nclass data : public ILLIXR::switchboard::event {\npublic:\n    data(size_t id_) : id{id_} { }\n    size_t id;\n};\n\nint main() {\n    ILLIXR::phonebook main_pb;\n    main_pb.register_impl&lt;service&gt;(std::make_shared&lt;service&gt;());\n    main_pb.lookup_impl&lt;service&gt;()-&gt;act();\n\n    // From docs of Switchboard: if first arg is null, logging is disabled.\n    // Logging should be disabled if we are running externally.\n    ILLIXR::switchboard main_sb {nullptr};\n    auto writer = main_sb.get_writer&lt;data&gt;(\"topic\");\n    auto reader = main_sb.get_reader&lt;data&gt;(\"topic\");\n    writer.put(writer.allocate&lt;data&gt;(42));\n    std::cout &lt;&lt; \"The answer to life... is \" &lt;&lt; reader.get_ro()-&gt;id &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Switchboard and Phonebook will only work with compilers that support C++17 or better.</p> <p>For example:</p> <pre><code># Must copy with directory structure\nmkdir -p illixr/concurrentqueue\ncp path/to/ILLIXR/illixr/switchboard.hpp illixr\ncp path/to/ILLIXR/illixr/phonebook.hpp illixr\ncp path/to/ILLIXR/illixr/record_logger.hpp illixr\ncp path/to/ILLIXR/illixr/managed_thread.hpp illixr\ncp path/to/ILLIXR/illixr/concurrentqueue/blockingconcurrentqueue.hpp illixr/concurrentqueue/blockingconcurrentqueue.hpp\ncp path/to/ILLIXR/illixr/concurrentqueue/concurrentqueue.hpp illixr/concurrentqueue/concurrentqueue.hpp\ncp path/to/ILLIXR/illixr/concurrentqueue/lightweightsemaphore.hpp illixr/concurrentqueue/lightweightsemaphore.hpp\nemacs main.cpp # copy and paste from this doc\n\n# This will *probbaly* work with any C++-17 compatible compiler, but I've tested with clang-10.\n# Nix is my preferred package manager, but you can use whichever you like.\n# This command will not affect system packages, just create a temporary environment with the right clang.\nnix-shell -p clang_10\n\n# Compile\nclang++ -Wextra -pthread -std=c++17 main.cpp\n\n# Run\n./a.out\n</code></pre> <p>The output is:</p> <pre><code>Register 7service\nHello from service\nCreating: topic for 4data\nThe answer to life... is 42\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>The ILLIXR application is configured and built via CMake. The CMake system checks for required dependencies, builds each requested plugin, builds the main ILLIXR binary, and (optionally) installs these components.</p> <p>ILLIXR currently only builds on Linux systems, and has been tested on the following configurations:</p> <ul> <li>Ubuntu<ul> <li>20.04</li> <li>22.04</li> </ul> </li> <li>Fedora<sup>1</sup><ul> <li>37</li> <li>38</li> </ul> </li> <li>CentOS<sup>1</sup><ul> <li>stream9</li> </ul> </li> </ul> <p>Other versions of these operating systems may work, but will likely require some manual installation of dependencies. For other Linux distributions (e.g. RHEL) it will require significant manual installation of dependencies as many are not available in the distribution repos. The instructions below are a generalized version.</p>"},{"location":"getting_started/#building-illixr","title":"Building ILLIXR","text":""},{"location":"getting_started/#clone-the-repository","title":"Clone the repository","text":"<pre>git clone https://github.com/ILLIXR/ILLIXR</pre>"},{"location":"getting_started/#install-dependencies","title":"Install dependencies","text":"<p>There are two levels of dependencies in ILLIXR: those that are required for any type of build, and those that are required only for specific plugins.</p>"},{"location":"getting_started/#select-your-operating-system-and-version","title":"Select your operating system and version","text":"<p>ILLIXR may compile with other versions of the above operating systems, but some of the necessary prerequesite packages are not supplied by the OS repos and will need to be compiled by hand. You should be able to use the package and cmake commands for other versions of the same OS (other than the missing packages) to compile ILLIXR. RHEL is not supported at this time as many of the prerequisite packages are not natively available.</p>"},{"location":"getting_started/#pick-the-illixr-plugins-you-want-to-use","title":"Pick the ILLIXR plugins you want to use","text":"Include virtualization support: See ILLIXR Under Virtualization for details. <p>Use the following to install the dependencies for the selected plugins:</p> <p></p>"},{"location":"getting_started/#build-command","title":"Build command","text":"<p>Use the following to build and install ILLIXR. You can specify the install location by giving the path to <code>CMAKE_INSTALL_PREFIX</code>.  If you want the default install path then do not add the option to the command line.  Note that if your install prefix requires sudo privileges then you will need to run both the build and install under sudo (this is due to the way cmake builds and installs some of the pre-packaged dependencies during the build phase).</p> <p>Common CMake command line arguments (always prepend with a <code>-D</code>):</p> <ul> <li>CMAKE_INSTALL_PREFIX     The root path to install the libraries and binary to. This defaults to <code>/usr/local</code>.</li> <li>CMAKE_BUILD_TYPE    The build type to do: Debug, Release, RelWithDebInfo</li> <li>YAML_FILE    The profile file of plugins to build and install. The default is None, meaning plugins should be specified individually on the command line.</li> <li>USE_&lt;PLUGIN_NAME&gt;=ON    Build the specifically named plugin (e.g <code>-DUSE_TIMEWARP_GL=ON</code> to build the timewarp_gl plugin). Any number of plugins can be specified on the command line in this fashion.</li> </ul> <p>An alternate to specifying the plugins as command line arguments is to create a YAML file which specifies the plugins to build. Using <code>-DYAML_FILE=&amp;lt;FILE_NAME&amp;gt;</code> as the command line argument specifying the YAML file to use. Note: You may need to specify the full path to the YAML_FILE. See profile for the format.</p> <p>The current list of plugins is:  - audio_pipeline - debugview - depthai - display_vk - fauxpose - gldemo - ground_truth_slam - gtsam_integrator - native_renderer - offline_cam - offline_imu - offload_data - offload_vio.device_rx - offload_vio.device_tx - offload_vio.server_rx - offload_vio.server_tx - openni - openvins - passthrough_integrator - pose_lookup - pose_prediction - realsense - record_imu_cam - record_rgb_depth - rk4_integrator - timewarp_gl - timewarp_vk - vkdemo - zed</p> <p>The CMake process will also create a YAML file call <code>illixr.yaml</code> which can be used as input to the binary.</p>"},{"location":"getting_started/#running-illixr","title":"Running ILLIXR","text":"<p>To run the ILLIXR binary just call <code>main.&lt;&gt;.exe</code> with any of the following command line arguments. (the <code>&amp;lt;&amp;gt;</code> indicate an infix specifying the build type, for <code>Debug</code> use <code>dbg</code>, for <code>Release</code> use <code>opt</code>, for <code>RelWithDebInfo</code> use <code>optdbg</code>)</p> <ul> <li>--duration=&lt;&gt;, the duration to run for in seconds (default is 60)</li> <li>--data=&lt;&gt;, the data file to use</li> <li>--demo_data=&lt;&gt;, the demo data to use</li> <li>--enable_offload, ??</li> <li>--enable_alignment, ??</li> <li>--enable_verbose_errors, give more information about errors</li> <li>--enable_pre_sleep, ??</li> <li>-p,--plugins=&lt;&gt;, comma separated list of plugins to use (case sensitive, all lowercase, no spaces)</li> <li>-r,--run=&lt;&gt;, comma separated list of plugins to use (case sensitive, all lowercase, no spaces), supersedes plugins entry.  This is only necessary if a plugin builds more than one library (e.g. offload_vio builds 4 libraries) as each must be loaded individually.</li> <li>-y,--yaml&lt;&gt;, the profile file to use which specifies some or all of the above arguments (e.g. the generated <code>illixr.yaml</code>)</li> <li>--vis, the visualizer to use (openvins currently)</li> </ul> <p>Regarding parameters for the binary, the following priority will be used: 1. If the parameter is specified on the command line it will have the highest priority 2. If the parameter has a value in the yaml file this value will only be used if it is not specified on the command line (second priority) 3. If the parameter has a value as an environment variable this value will only be used if it is not specified on the command line nor yaml file</p>"},{"location":"getting_started/#profile-file-format","title":"Profile file format","text":"<p>An example of a YAML profile file is <pre><code>plugins: timewarp_gl,gldemo,ground_truth_slam,offload_vio\nrun: timewarp_gl,gldemo,ground_truth_slam,offload_vio.device_rx\nvisualizers: openvins\nduration: 5\ndata: data/mav0\ndemo_data: demo_data\nbuild_type: Debug\ninstall_prefix: /home/user/illixr\nenable_offload: true\nenable_alignment: false\nenable_verbose_errors: false\nenable_pre_sleep: false\n</code></pre></p> <p>Where the entries are defined as (* indicates required field):</p> <ul> <li> <p>plugins * : Comma separated list of plugins (case sensitive) to build or load at runtime.</p> </li> <li> <p>run : Comma separated list of plugins (case sensitive) which are used at run time. This is only needed in cases like offload_vio where multiple plugin libraries are built by a single plugin, but must be loaded individually. (e.g. offload_vio.server_rx)</p> </li> <li> <p>visualizers : Comma separated list of visualizers to build or load at runtime (currently openvins is available). At runtime, if multiple visualizers are listed, only the first one will be used.</p> </li> <li> <p>duration : The duration to run ILLIXR for in seconds.</p> </li> <li> <p>data : Path to the data file to dowload (build step) or use at runtime. If a URL is given (must start with http or https) the file will be downloaded and extracted; the path to the extracted data will be put in the illixr.yaml file.</p> </li> <li> <p>demo_data : The path to the demonstration data to use at runtime (ignored by build steps)</p> </li> <li> <p>build_type : The type of build to perform (Debug, Release, or RelWithDebInfo). Ignored at run time.</p> </li> <li> <p>install_prefix : The root path to where the compiled libraries and binaries should be installed. (e.g. specifying /home/user will install libraries in /home/user/lib and binaries in /home/user/bin). Note: The prefix is also used for installing any packages that were downloaded and build from external repositories (e.g. DBoW2, GTSAM, etc). At runtime this path is added to LD_LIBRARY_PATH to aid in finding the plugin libraries.</p> </li> <li> <p>enable_offload : ? Default is false</p> </li> <li> <p>enable_alignment : ? Default is false</p> </li> <li> <p>enable_verbose_errors : Controls the verbosity of error messages. Default is false</p> </li> <li> <p>enable_pre_sleep : ? Default is false</p> </li> </ul> <p>In general, you should not edit a profile file directly. The exception to this is when you are testing things on your own machine. Profile files are generated automatically from the master <code>profiles/plugins.yaml</code> during the cmake configuration stage. This is done so that any changes to a profile or the addition or removal of a plugin can be managed from a single file. The build system will generate an illixr.yaml file which contains entries from the command line and any input profile file and can be freely edited (it is generated every time <code>cmake</code> is called).</p>"},{"location":"getting_started/#illixr-graphics-backends","title":"ILLIXR Graphics Backends","text":"<p>ILLIXR currently supports both OpenGL and Vulkan backends (indicated as <code>gl</code> and <code>vk</code> in the config suffixes). Since some plugins should behave differently (and compile differently) based on what backend is being used, it's important to run <code>make clean</code> if you want to try swapping between the two backends.</p>"},{"location":"getting_started/#rationale","title":"Rationale","text":"<ul> <li>The current system can use profile files to control everything from the build to running ILLIXR, inkeeping with the DRY principle.    However, for maximum flexibility control can also be done at the command line level as well.</li> </ul>"},{"location":"getting_started/#philosophy","title":"Philosophy","text":"<ul> <li> <p>Each plugin should not have to know or care how the others are compiled.     In the future, they may even be distributed separately, just as SOs.     Therefore, each plugin needs its own build system.</p> </li> <li> <p>Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins     should be extremely easy.</p> </li> <li> <p>It should be easy to build in parallel.</p> </li> <li> <p>Re-running <code>make</code> (and optionally <code>cmake</code> first) will only rebuild those parts of the code with have changed.</p> </li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Try browsing the source for the runtime and provided plugins. The source code is divided into components in the following directories:</p> <ul> <li> <p><code>ILLIXR/src/</code>:     A directory holding the implementation for loading and interfacing plugins.     This directory contains Spindle.</p> </li> <li> <p><code>ILLIXR/include/illixr/</code>:     A directory holding resources and utilities available globally to all plugins.     This directory contains the interfaces for Switchboard and Phonebook.</p> </li> <li> <p><code>ILLIXR/plugins/&lt;plugin_dir&gt;/</code>:     A unique directory for each plugin.     Most of the core XR functionality is implemented via plugins.     See Default Components for more details.</p> </li> </ul> <p>If you edit any of the source files, the CMake system will detect and rebuild the respective binary the next time it runs. If you want to add your own plugin, see Writing Your Plugin.</p> <ol> <li> <p>Primary development is aimed at Ubuntu systems, full support for Fedora and CentOS may lag behind.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"glossary/","title":"Glossary of ILLIXR Terminology","text":"<p>A collection of ILLIXR and ILLIXR-adjacent terms and their definitions can be found     on this page your reference.</p>"},{"location":"glossary/#general","title":"General","text":""},{"location":"glossary/#asynchronous-reprojection","title":"Asynchronous Reprojection","text":"<p>The processing of rendered video for motion interpolation. Asynchronous reprojection improves the perception of the rendered video to the HMD when rendering misses it target frame rate.</p> <p>Asynchronous reprojection is implemented in the <code>timewarpgl</code> ILLIXR plugin.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#chromatic-abberation-correction","title":"Chromatic Abberation Correction","text":"<p>The processing of visual anomalies in images where colors are diffracted due to imperfect optics or other perturbing factors.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#compositor","title":"Compositor","text":"<p>A window manager that establishes a framebuffer for each window of a graphical system. A compositor merges information across its windows to construct a unified framebuffer.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#distortion-correction","title":"Distortion Correction","text":"<p>The processing of visual anomalies in images where rectilinear features have been warped.</p> <p>For more information, see the Wikipedia artice.</p>"},{"location":"glossary/#eye-tracking","title":"Eye Tracking","text":"<p>The process of measuring the eye movement of a user (who is possibly also wearing a HMD).</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#event-stream","title":"Event Stream","text":"<p>A communication interface supporting writes, sychronous reads, and asynchronous reads. For synchronous reads, every value written to the stream is visible to consumers. For asynchronous reads, only the latest values written are guaranteed to be visible to consumers.</p>"},{"location":"glossary/#framebuffer","title":"Framebuffer","text":"<p>A region of memory used to hold graphical information to be output to a display or graphics device.</p> <ul> <li> <p>Depth Buffer:     A framebuffer representing the depth information of a 3D scene.     Depth information is useful for applications such as graphics and SLAM.</p> </li> <li> <p>Eye Buffer:     A framebuffer dedicated for display through a HMD lens to be perceived by a user's eye.</p> </li> <li> <p>Frame:     A single frame (image) to be output to a display at a certain instant of time based on the     system's frame rate.</p> </li> <li> <p>Frame Rate:     The interval period between complete (as defined by the output resolution) frame updates     and refreshes.     In many systems, the target frame rate is determined by a fixed vertical sync (VSYNC) period.</p> </li> </ul> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#ground-truth","title":"Ground Truth","text":"<p>The most accurate source of measurement available for a data set. Typically, ground truth measurements are provided for the evaluation of sensor data where the sensor or other data source is not as accurate or reliable as the source for the ground truth.</p> <ul> <li> <p>Ground Truth Poses:     A collection of poses used to evaluate the accuracy of pose generation and prediction algorithms.</p> </li> <li> <p>Ground Truth Images:     A collection of images used to evaluate the accuracy of visual processing algorithms,     like SLAM and VIO.</p> </li> </ul> <p>See the ILLIXR Plugins page for information about sensors implemented in ILLIXR.</p>"},{"location":"glossary/#head-mounted-display","title":"Head-mounted Display","text":"<p>A display device worn on the head and face for use with VR and XR applications. Also known as a HMD.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#inertial-measurement-unit","title":"Inertial Measurement Unit","text":"<p>A device that reports its orientation in space and any forces applied it. Also known as an IMU.</p> <p>An IMU is implemented in the <code>offline_imu</code> ILLIXR plugin.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#plugin","title":"Plugin","text":"<p>A modular component that can be detected and enabled for use by an ILLIXR application. A plugin can be internal or external to the ILLIXR project. Each plugin is compiled and launched dynamically at runtime based on the command line options given or     ILLIXR profile file being used. ILLIXR also implements a Monado runtime translation Plugin.</p> <p>For a list of supported plugins and their details, see the ILLIXR Plugins page. For instructions for how to modify or write your own plugins, see the Modifying a Plugin     and Writing Your Plugin pages.</p> <p>See the Plugin API documentation.</p>"},{"location":"glossary/#profile","title":"Profile","text":"<p>A profile describes the environment to be used for the build system and running ILLIXR. Profiles are defined in YAML files. There are several provided in the <code>profiles</code> directory in the repository. A profile file defines what plugins are to be used, as well as additional information specific to where it is being used.</p> <ul> <li>As input to CMake:    If a profile file is given to cmake via the <code>-DYAML_FILE=</code> directive then the listed plugins will be built.</li> <li>As input to the ILLIXR binary    If a profile file is given on the ILLIXR binary via the <code>--yaml=</code> command line option, then any listed plugins will be loaded and any other command line options given in the profile file will be used. See Running ILLIXR for details.</li> </ul> <p>The same profile file can be given to both cmake and the ILLIXR binary (you may need to change the <code>data:</code> entry), as any unrecognized options are ignored by both systems. See Profile file format for details on the profile file format.</p>"},{"location":"glossary/#pose","title":"Pose","text":"<p>The combination of orientation and position of an object, used for computer vision and robotics applications. ILLIXR applications make use of poses to track the user's HMD within the virtual environment. Internally, ILLIXR has multiple classifications of poses which are used for various purposes.</p> <ul> <li> <p>Slow Pose:     A slow pose is a ... TODO</p> </li> <li> <p>Fast Pose:     A fast pose is a ... TODO</p> </li> <li> <p>True Pose:     A true pose is a ... TODO Depracated starting ILLIXR release <code>v2.X.X</code>.</p> </li> <li> <p>Pose Prediction:     To improve the user's perception latency experience the time between, pose prediction     uses history and current system information to pre-compute the user's next pose     Pre-computing the next pose allows for components downstream from the pose output     in the event stream dataflow graph to begin computation.</p> </li> </ul> <p>Pose Prediction is implemented in the <code>pose_prediction</code> ILLIXR plugin.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#runtime","title":"Runtime","text":"<p>The ILLIXR system runtime is responsible for the dynamic orchestration of ILLIXR device resources, system resources, and client applications.</p> <p>The runtime implementation is located in <code>&lt;ILLIXR_INSTALL_DIR&gt;/bin</code>. See the Getting Started and Monado Overiew pages for details about the ILLIXR runtime.</p>"},{"location":"glossary/#swap-chain","title":"Swap Chain","text":"<p>A set of virtual framebuffers to be output to a display. Only one framebuffer in a swap chain is displayed at a time, enabling the     other virtual framebuffers to be concurrently modified in memory.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#simultaneous-localization-and-mapping","title":"Simultaneous Localization and Mapping","text":"<p>The computational process of creating a map of an unknown environment, and finding one's location     within that space. Also known as SLAM.</p> <p>For more information, see the Wikipedia article.</p>"},{"location":"glossary/#visual-interial-odometry","title":"Visual Interial Odometry","text":"<p>The process of computing a pose estimate from incoming visual information and measurements     from the IMU. Also known as VIO. Often used in combination with SLAM techniques.</p> <p>See the Wikipedia article.</p>"},{"location":"glossary/#components","title":"Components","text":""},{"location":"glossary/#phonebook","title":"Phonebook","text":"<p>An ILLIXR service directory used to introspectively interface plugins and their data. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Phonebook API documentation.</p>"},{"location":"glossary/#spindle","title":"Spindle","text":"<p>An ILLIXR component responsible for launching and managing plugin threads. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Spindle API documentation.</p>"},{"location":"glossary/#switchboard","title":"Switchboard","text":"<p>An ILLIXR event stream manager that maintains data pipelines between plugins. The implementation resides in <code>ILLIXR/runtime/</code>.</p> <p>See the Switchboard API documentation.</p>"},{"location":"glossary/#technologies","title":"Technologies","text":""},{"location":"glossary/#docker","title":"Docker","text":"<p>A platform and containerization framework for deploying applications under virtualization. ILLIXR uses Docker to deploy and test code in a continuous integration and deployment pipeline.</p> <p>For more information, see the Docker overview and getting started page.</p>"},{"location":"glossary/#godot","title":"Godot","text":"<p>An open source game development engine. ILLIXR applications targeting the OpenXR use Godot to access the engine's integration with the OpenXR standard via Monado.</p> <p>For more information, visit the official Godot site.</p>"},{"location":"glossary/#monado","title":"Monado","text":"<p>An open source, modular implementation of the OpenXR standard for GNU/Linux.</p> <p>See the ILLIXR Monado Overview and Monado Dataflow pages for details about our runtime integration using Monado.</p> <p>For more information, visit the official Monado development site.</p>"},{"location":"glossary/#opengl","title":"OpenGL","text":"<p>A cross-platform graphics API that allows developers to create graphics applications easily and portably. Also known as GL.</p> <ul> <li> <p>GL Context:     A data structure storing the state of an OpenGL application instance.     Within a GL context resides framebuffer data.     It is not thread safe to share contexts without appropriate synchronization.</p> </li> <li> <p>GLFW:     An open source implementation of OpenGL.     Supports Windows, MacOS and, Linux (X11 and Wayland).     See the GLFW development site.</p> </li> </ul> <p>For more information, see the official OpenGL page from the Khronos Group.</p>"},{"location":"glossary/#openxr","title":"OpenXR","text":"<p>An open standard for Augmented and Virtual Reality. ILLIXR components target the OpenXR standard and interact with the ILLIXR device     via the Application Interface.</p> <p>For more information, visit the official site from the Khronos Group.</p>"},{"location":"glossary/#qemu-kvm","title":"QEMU-KVM","text":"<p>An open source virtulization tool and machine emulator. See the instructions for running ILLIXR under Virtualization.</p> <p>For more information, see the official QEMU page.</p>"},{"location":"glossary/#sqlite","title":"SQLite","text":"<p>A SQL database engine implementation in C designed to be lightweight and easy to use. The ILLIXR project allows user to records application statistics to a local database for efficient processing. See the Logging and Metrics page for usage details.</p> <p>For more information, see the SQLite development site.</p>"},{"location":"glossary/#ubuntu","title":"Ubuntu","text":"<p>An open source GNU/Linux operating system and distribution. ILLIXR currently supports the Long Term Support (LTS) versions of Ubuntu: 20.04 LTS (Focal) and 11.04 (Jammy)</p> <p>For more information, visit the official Ubuntu site.</p>"},{"location":"glossary/#vulkan","title":"Vulkan","text":"<p>A cross-platform graphics API that allows developers to efficiently target low-level hardware features.</p> <p>For more information, see the official Vulkan page from the Khronos Group.</p>"},{"location":"glossary/#xvfb","title":"Xvfb","text":"<p>A virtual framebuffer for the X11 Window Sytem. ILLIXR uses Xvfb to enable running the graphical ILLIXR application without requiring the user     to have a graphical environment configured at application launch.</p> <p>For more information, see the Xfvb man page.</p>"},{"location":"glossary/#yaml","title":"YAML","text":"<p>A markup language and data serialization standard designed to be user-friendly. We make use of the yaml-cpp libraries to read     our profile files.</p> <p>For more information, visit the official YAML page.</p>"},{"location":"illixr_plugins/","title":"ILLIXR plugins","text":"<p>This page details the structure of ILLIXR's plugins and how they interact with each other.</p>"},{"location":"illixr_plugins/#default-plugins","title":"Default Plugins","text":"<ul> <li> <p><code>audio_pipeline</code>:     Launches a thread for binaural recording and one for binaural playback.     Audio output is not yet routed to the system's speakers or microphone,     but the plugin's compute workload is still representative of a real system.     By default this plugin is enabled (see <code>native</code> configuration).</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> </ul> </li> <li> <p><code>debugview</code>:     Renders incoming frames from the graphics pipeline for debugging live executions of the application.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> <li>Asynchronously reads <code>fast_pose</code> on <code>imu_raw</code> topic. (IMU biases are unused).</li> <li>Asynchronously reads <code>slow_pose</code> on <code>slow_pose</code> topic.</li> <li>Synchronously reads <code>imu</code> on <code>imu</code> topic.</li> <li>Asynchronously reads buffered <code>cam_type</code> on <code>cam</code> topic.</li> </ul> </li> <li> <p><code>gldemo</code>:     Renders a static scene (into left and right eye buffers) given the pose     from <code>pose_prediction</code>.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> <li>Publishes <code>rendered_frame</code> on <code>eyebuffer</code> topic.</li> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic.</li> </ul> </li> <li> <p><code>ground_truth_slam</code>:     Reads the ground truth from the same dataset as the <code>offline_imu</code> plugin.     Ground truth data can be compared against the measurements from <code>offline_imu</code> for accuracy.     Timing information is taken from the <code>offline_imu</code> measurements/data.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> on <code>true_pose</code> topic.</li> <li>Asynchronously reads <code>imu_type</code> on <code>imu</code> topic.</li> </ul> </li> <li> <p><code>gtsam_integrator</code>:     Integrates over all IMU samples since the last published SLAM pose to provide a     fast pose every time a new IMU sample arrives using the GTSAM library (upstream).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_raw_type</code> on <code>imu_raw</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_type</code> on <code>imu</code> topic.</li> <li>Asynchronously reads <code>imu_integrator_input</code> on <code>imu_integrator_input</code> topic.</li> </ul> </li> <li> <p><code>offline_imu</code>:     Reads IMU data files on disk, emulating a real sensor on the headset     (feeds the application input measurements with timing similar to an actual IMU).</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> on <code>imu</code> topic.</li> </ul> </li> <li> <p><code>offline_cam</code>:     Reads camera images from files on disk, emulating real cameras on the headset     (feeds the application input measurements with timing similar to an actual camera).</p> <p>Topic details:</p> <ul> <li>Publishes <code>cam_type</code> on <code>cam</code> topic.</li> <li><code>pose_prediction</code>: Uses the latest IMU value to predict a pose for a future point in time. Implements the <code>pose_prediction</code> service (defined in <code>common</code>),     so poses can be served directly to other plugins.</li> </ul> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>pose_type</code> on <code>slow_pose</code> topic,         but it is only used as a fallback.</li> <li>Asynchronously reads <code>imu_raw</code> on <code>imu_raw</code> topic.</li> <li>Asynchronously reads <code>pose_type</code> on <code>true_pose</code> topic,         but it is only used if the client asks for the true pose.</li> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic.     This tells <code>pose_predict</code> what time to estimate for.</li> </ul> </li> <li> <p><code>timewarp_gl</code>:     Asynchronous reprojection of the eye buffers.     The timewarp ends just after vsync, so it can deduce when the next vsync will be.</p> <p>Topic details:</p> <ul> <li>Calls <code>pose_prediction</code>.</li> <li>Asynchronously reads <code>rendered_frame</code> on <code>eyebuffer</code> topic.</li> <li>Publishes <code>time_type</code> on <code>vsync_estimate</code> topic.</li> <li>Publishes <code>hologram_input</code> on <code>hologram_in</code> topic.</li> <li>Publishes <code>texture_pose</code> on <code>texture_pose</code> topic if <code>ILLIXR_OFFLOAD_ENABLE</code> is set in the env.</li> </ul> </li> </ul> <p>Below this point, we will use Switchboard terminology. Read the API documentation on Switchboard for more information.</p> <p></p> <ul> <li> <p>In the above figure, ovals are plugins.</p> </li> <li> <p>Solid arrows from plugins to topics represent publishing.</p> </li> <li> <p>Solid arrows from topics to plugins represent synchronous reading.     Some action is taken for every event which gets published on the topic.</p> </li> <li> <p>Dashed arrows from topics to plugins represent asynchronous reading.     Plugin readers only need the latest event on their topic.</p> </li> <li> <p>Imagine the topic as a trough filling with events from its publisher.     Synchronous readers (AKA subscribers) drain the trough,         while asynchronous readers just skim fresh events off the top of the trough.</p> </li> </ul> <p>See Writing Your Plugin to extend ILLIXR.</p>"},{"location":"illixr_plugins/#other-supported-plugins","title":"Other Supported Plugins","text":"<p>ILLIXR supports additional plugins to replace some of the default plugins.</p> <ul> <li> <p><code>fauxpose</code>:     An alternate tracking implementation that simply generates \"fast_pose\"     data from a simple mathematical algorithm (circular movement).  The intent     is for use when debugging other plugins and the developer wants a known     pose trajectory without having to configure actual tracking.</p> <p>Topic details: -   Publishes <code>pose_position</code> on <code>fast_pose</code> topic.</p> </li> <li> <p><code>hologram</code>:     Adapts the eyebuffer for use on a holographic display.     By default, this plugin is disabled, since an NVIDIA GPU is currently required.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>hologram_input</code> on <code>hologram_in</code> topic.     Hologram is too slow to run for every input,         so the plugin implements an asynchronous reader which can drop inputs.</li> </ul> </li> <li> <p><code>offload_data</code>:     Writes frames and poses output from the asynchronous reprojection plugin to disk for analysis.</p> <p>Topic details:</p> <ul> <li>Synchronously reads <code>texture_pose</code> on <code>texture_pose</code> topic.</li> </ul> </li> <li> <p><code>open_vins</code>:     An alternate SLAM (upstream) implementation that uses a MSCKF         (Multi-State Constrained Kalman Filter) to determine poses via camera/IMU.</p> <p>Topic details:</p> <ul> <li>Publishes <code>pose_type</code> on <code>slow_pose</code> topic.</li> <li>Publishes <code>imu_integrator_input</code> on <code>imu_integrator_input</code> topic.</li> <li>Synchronously reads/subscribes to <code>imu_type</code> on <code>imu</code> topic.</li> </ul> </li> <li> <p><code>pose_lookup</code>:     Implements the <code>pose_predict</code> service, but uses ground truth from the dataset.     The plugin peeks \"into the future\" to determine what the exact pose will be at a certain time.</p> <p>Topic details:</p> <ul> <li>Asynchronously reads <code>time_type</code> on <code>vsync_estimate</code> topic.     This tells <code>pose_lookup</code> what time to lookup.</li> </ul> </li> <li> <p><code>realsense</code>:     Reads images and IMU measurements from the Intel Realsense.</p> <p>Topic details:</p> <ul> <li>Same interface as <code>zed</code>.</li> </ul> </li> <li> <p><code>rk4_integrator</code>:     Integrates over all IMU samples since the last published SLAM pose to         provide a fast pose every time a new IMU sample arrives using RK4 integration.</p> <p>Topic details:</p> <ul> <li>Same interface as <code>gtsam_integrator</code>.</li> </ul> </li> <li> <p><code>zed</code>:     Reads images and IMU measurements from the ZED Mini.     Unlike <code>offline_imu</code>, <code>zed</code> additionally has RGB and depth data.     Note that this plugin implements two threads: one for the camera, and one for the IMU.</p> <p>Topic details:</p> <ul> <li>Publishes <code>imu_type</code> on <code>imu</code> topic.</li> <li>Publishes <code>rgb_depth_type</code> on <code>rgb_depth</code> topic.</li> </ul> </li> </ul> <p>See Getting Started for more information on adding plugins to a profile file.</p>"},{"location":"logging_and_metrics/","title":"Logging and Metrics","text":"<p>The ILLIXR project supports several ways for an ILLIXR application to log and report details about     its execution.</p>"},{"location":"logging_and_metrics/#logging","title":"Logging","text":"<p>ILLIXR uses the spdlog library for logging. Logging goes to both <code>STDOUT</code> and one or more log files in <code>$ILLIXR_ROOT/logs/</code></p> <p>Available levels, from low to high are: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>critical</code>, <code>off</code>.</p> <p>If <code>NDEBUG</code> is not defined, then the default logging level is <code>warn</code>, otherwise it is <code>debug</code>.</p> <p>Logging is activated by exporting environment variables to a particular level before running ILLIXR. These take the form of <code>&lt;PLUGIN_NAME&gt;_LOG_LEVEL</code>, e.g.,</p> <pre><code># Activate logging for both the ground_truth_slam plugin and the ILLIXR app\n# Each will log to the console, with color (actual colors dependent on the terminal settings)\n# Each log will write to $ILLIXR_ROOT/logs/&lt;plugin_name&gt;.log\n# Each log can have a different level.\n\nexport GROUND_TRUTH_SLAM_LOG_LEVEL=debug\nexport ILLIXR_LOG_LEVEL=warn\n\nmain.dbg.exe -yaml=profiles/native_gl.yaml\n</code></pre> <p>When writing a new plugin, the <code>plugin.spdlogger(std::string log_level)</code> method should be called, e.g., using <code>std::getenv(\"&lt;PLUGIN_NAME&gt;_LOG_LEVEL\")</code> This creates a logger with two sinks (console and file). This logger is then registered in the global spdlog registry. </p> <p>To log inside of a plugin method, use the plugin's name attribute to get the particular logger from the registry and call the desired log level method, e.g. <pre><code>spdlog::get(name)-&gt;info(\"informative message\");\n</code></pre></p> <p>Outside of the plugin class hierarchy, one can use the global ILLIXR logger which is registered under \"illixr\", e.g., <code>spdlog::get(\"illixr\")</code>.  It will look for <code>$ILLIXR_LOG_LEVEL</code> in the environment or use <code>warn</code> by default. This usage requires explicitly adding the name of the component or file to the output message, if desired.</p> <p>Log files are appended. To merge to a single log do <code>$ cat *log | sort &gt; combined.log</code> This will sort correctly because the entries start with an ISO-8601 timestamp. For this reason, if a plugin uses <code>spdlog::set_pattern()</code> to create a custom log pattern, it is highly recommended that the custom pattern start with an ISO-8601 timestamp and it is required to reset to the default log message pattern after use.</p>"},{"location":"logging_and_metrics/#note-about-ifndef-ndebugendif-blocks","title":"Note about #ifndef NDEBUG/#endif blocks","text":"<p>Many of the plugins contain their logging statements inside of blocks which are only active when doing a debug build. This is a historical artifact. New plugins should carefully consider the difference between logging a debug message and conditionally compiling blocks of code based on build type.</p>"},{"location":"logging_and_metrics/#metrics","title":"Metrics","text":"<p>ILLIXR allows users to generate higher order statistics from logged results called Metrics.</p> <p>TODO</p>"},{"location":"modifying_a_plugin/","title":"Modifying a plugin","text":""},{"location":"modifying_a_plugin/#tutorial","title":"Tutorial","text":"<p>This is how you can modify an existing ILLIXR plugin. This example uses the Audio Pipeline plugin, but the steps can be applied to any plugin.</p> <ol> <li> <p>Fork the repository for the component you want to modify into your own repo using the github     web interface, then pull your repo to your computer. For example, using the Audio Pipeline plugin:     <pre><code>git clone https://github.com/&lt;YOUR_USER_NAME&gt;/audio_pipeline.git\n</code></pre></p> </li> <li> <p>Modify the associated <code>cmake/GetAudioPipeline.cmake</code>     original     <pre><code>get_external(PortAudio)\nget_external(SpatialAudio)\n\nset(AUDIO_PIPELINE_CMAKE_ARGS \"\")\nif(HAVE_CENTOS)\n    set(AUDIO_PIPELINE_CMAKE_ARGS \"-DINTERNAL_OPENCV=${OpenCV_DIR}\")\nendif()\nExternalProject_Add(Audio_Pipeline\n    GIT_REPOSITORY https://github.com/ILLIXR/audio_pipeline.git\n    GIT_TAG 714c3541378ece7b481804e4a504e23b49c2bdbe\n    PREFIX ${CMAKE_BINARY_DIR}/_deps/audio_pipeline\n    DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR} ${OpenCV_DEP_STR}\n    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS}\n )\n</code></pre>     which becomes <code>cmake/GetMyAudioPipeline.cmake</code> <pre><code>get_external(PortAudio)\nget_external(SpatialAudio)\n\nset(AUDIO_PIPELINE_CMAKE_ARGS \"\")\nif(HAVE_CENTOS)\n    set(AUDIO_PIPELINE_CMAKE_ARGS \"-DINTERNAL_OPENCV=${OpenCV_DIR}\")\nendif()\nExternalProject_Add(Audio_Pipeline\n    GIT_REPOSITORY https://github.com/&lt;YOUR_USER_NAME&gt;/audio_pipeline.git\n    PREFIX ${CMAKE_BINARY_DIR}/_deps/myaudio_pipeline\n    DEPENDS ${PortAudio_DEP_STR} ${SpatialAudio_DEP_STR} ${OpenCV_DEP_STR}\n    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_CXX_FLAGS=-L${CMAKE_INSTALL_PREFIX}/lib\\ -L${CMAKE_INSTALL_PREFIX}/lib64 -DILLIXR_ROOT=${PROJECT_SOURCE_DIR}/include -DCMAKE_PREFIX_PATH=${CMAKE_INSTALL_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib -DILLIXR_BUILD_SUFFIX=${ILLIXR_BUILD_SUFFIX} ${AUDIO_PIPELINE_CMAKE_ARGS}\n )\n</code></pre></p> </li> <li> <p>Make whatever changes to the plugin code you want and be sure to push them to your forked repo.</p> </li> <li> <p>See the instructions on Getting Started to learn how to build and run ILLIXR.</p> </li> <li> <p>To push the modification to upstream ILLIXR, create a PR to the original repository.</p> </li> </ol>"},{"location":"updating_tags_and_docs/","title":"Updating Tags and Documentation","text":""},{"location":"updating_tags_and_docs/#updating-tags","title":"Updating Tags","text":"<p>For releases, perform these steps from <code>master</code> once the desired features have been merged in.</p> <ol> <li> <p>Get latest tags:</p> <pre><code>git pull --tags -f\n</code></pre> </li> <li> <p>Tag your branch. Please use semantic versioning to name the tag; i.e., <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>:</p> <pre><code>git tag -f &lt;tag-name&gt; ## `-f` is required if updating an existing tag\n</code></pre> </li> <li> <p>Push your tag upstream:</p> <pre><code>git push origin --tags\n</code></pre> </li> </ol>"},{"location":"updating_tags_and_docs/#updating-documentation","title":"Updating Documentation","text":"<p>Perform these steps from the root directory of the project.</p> <ol> <li> <p>Create the directory where the generated files will be placed:</p> <pre><code>mkdir -p site/api\n</code></pre> </li> <li> <p>Run <code>doxygen</code> to generate API documentation:</p> <pre><code>doxygen doxygen.conf\n</code></pre> </li> <li> <p>Run <code>mkdocs</code> to deploy new documentation:</p> <pre><code>mkdocs gh-deploy\n</code></pre> </li> </ol>"},{"location":"using_cameras/","title":"Using Cameras with ILLIXR","text":"<p>ILLIXR supports a wide range of cameras, most of which are for the purpose of feeding images and IMU measurements to the system.  To learn more about how it works, checkout Getting Started. If you are interested in what topics these cameras feed into, checkout ILLIXR plugins.</p> <p>Important Note:  Before running any of these plugins below, it is important to comment out <code>offline_cam</code> and <code>offline_imu</code> in <code>configs\\native.yaml</code>. </p>"},{"location":"using_cameras/#add-calibration-parameters","title":"Add Calibration Parameters","text":"<p>In order to add your camera's calibration extrinsics, you need to modify your choice of SLAM/VIO plugin. Follow these instructions to modify a plugin.</p> <ul> <li> <p><code>OpenVINS</code>:</p> <p>Navigate to <code>ov_msckf/src</code>. Uncomment this line out in <code>slam2.cpp</code> in order to use ZED's calibration parameter for OpenVins.  You can add your own calibration parameters in the same file.     </p> </li> </ul>"},{"location":"using_cameras/#zed-mini","title":"ZED Mini","text":"<ol> <li> <p>Install ZED SDK </p> <p>Install the latest version of the ZED SDK on stereolabs.com. For more information, checkout the ZED API documentation.</p> </li> <li> <p>Get ZED's calibration parameters</p> <p>Both OpenVINS have a decent calibration parameters for ZED. But if you wish to add your own: </p> <pre><code>/usr/local/zed/tools/ZED_Calibration\n</code></pre> <p>Your original factory calibration file is stored here</p> <pre><code>/usr/local/zed/settings/\n</code></pre> <p>Or download it from calib.stereolabs.com.</p> </li> <li> <p>Enable ZED in OpenVINS plugin</p> <p>This step is only required if using OpenVINS. Uncomment this line in the OpenVINS plugin. </p> </li> <li> <p>Run ILLIXR with ZED: </p> <p>Uncomment <code>zed</code> in <code>configs/rt_slam_plugins.yaml</code> and run ILLIXR normally.</p> </li> </ol>"},{"location":"using_cameras/#intel-realsense","title":"Intel Realsense","text":"<p>ILLIXR has been tested with Inteal RealSense D455, but it should work with any D or T series RealSense Camera. </p> <ol> <li> <p>Install librealsense (if you haven't already):</p> <p>Instruction on how to install can be found here.</p> </li> <li> <p>Get RealSense calibration parameters:</p> <p>Navigate to <code>enumerate-devices</code></p> <pre><code>./PATH/TO/LIBREALSENSE/build/tools/enumerate-devices\n</code></pre> <p>Run this command to obtain the calibration parameters</p> <pre><code>./rs-enumerate-devices -c\n</code></pre> </li> <li> <p>Run ILLIXR with RealSense: </p> <p>Uncomment <code>realsense</code> in <code>configs/rt_slam_plugins.yaml</code> and run ILLIXR normally.</p> <p>Note: We will release the corresponding <code>#define realsense</code> soon for OpenVINS + Realsense</p> </li> </ol>"},{"location":"virtualization/","title":"Setting up ILLIXR in QEMU","text":""},{"location":"virtualization/#install-qemu","title":"Install QEMU","text":"<p>See the Install dependencies section for details on installing QEMU.</p>"},{"location":"virtualization/#setup-ubuntu-in-the-vm","title":"Setup Ubuntu in the VM","text":"<p>Run <code>ILLIXR/qemu/qemu.sh</code> to download Ubuntu 22.04, create a virtual hard drive     (<code>illixr.qcow2</code>), and launch <code>qemu</code>.</p> <p>Your VM image will be created at <code>ILLIXR/qemu/illixr.qcow2</code>. Ubuntu will be downloaded and saved at <code>ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso</code>.</p> <p>You will be prompted to install Ubuntu;     follow the instructions and install Ubuntu to the virtual hard drive.</p> <p></p> <p>Choose the \"erase all\" option and confirm:</p> <p> </p> <p>Pick any account name and password you like.</p> <p></p> <p>Once Ubuntu is installed you will be asked to reboot. Close <code>qemu</code> and then run <code>ILLIXR/qemu/qeum.sh</code> again to boot into your brand-new Ubuntu install!</p>"},{"location":"virtualization/#booting-the-vm","title":"Booting the VM","text":"<p>To launch the VM from now on, just use <code>ILLIXR/qemu/qemu.sh</code>. This will boot from the Ubuntu image we created earlier (<code>illixr.qcow2</code>). Once Ubuntu is installed, it is safe to delete <code>ubuntu-22.04.2-desktop-amd64.iso</code>.</p>"},{"location":"virtualization/#setting-up-the-vm","title":"Setting up the VM","text":"<p>Once inside the VM, set up and run ILLIXR as found on the Getting Started page.</p>"},{"location":"virtualization/#uninstalling","title":"Uninstalling","text":"<p>To delete your local VM, just delete <code>ILLIXR/qemu/illixr.qcow2</code>.</p> <p><code>ILLIXR/qemu/ubuntu-22.04.2-desktop-amd64.iso</code> can be deleted anytime you want after Ubuntu     is installed to your VM.</p> <p>If you've deleted <code>illixr.qcow2</code>, you can run <code>ILLIXR/qemu/qemu.sh</code> to recreate it and reinstall everything.</p>"},{"location":"writing_your_plugin/","title":"Writing Your Plugin","text":""},{"location":"writing_your_plugin/#adding-a-new-plugin","title":"Adding a New Plugin","text":"<p>To add a new plugin</p> <ol> <li>create a new subdirectory in the <code>plugins</code> directory named for your plugin (no spaces)</li> <li>put your code in this new subdirectory (additional subdirectories containing parts of your code are allowed)</li> <li>create a CMakeLists.txt file in this new subdirectory. See the template below</li> <li>add the plugin to the <code>profiles/plugins.yaml</code> file, the name must match the subdirectory you created; it should go in the <code>internal_plugins</code> entry</li> </ol> <p>For the examples below is for a plugin called tracker, so just replace any instance of tracker with the name of your plugin.</p>"},{"location":"writing_your_plugin/#simple-example","title":"Simple Example","text":"<pre><code>1   set(TRACKER_SOURCES plugin.cpp\n2                       src/tracker.cpp\n3                       src/tracker.hpp)\n4\n5   set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n6\n7   add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n8\n9   target_include_directories(${PLUGIN_NAME} PRIVATE ${ILLIXR_SOURCE_DIR}/include)\n10\n11  target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n12\n13  install(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre> Line # Notes 1-3 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Tell the system we are building a shared library with the name  <code>PLUGIN_NAME</code> from the specified source files. 9 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR_SOURCE_DIR/include</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 11 Any compile options specific to this plugin. Usually this will be left as is. 13 Add the install directive. This should not need to change."},{"location":"writing_your_plugin/#more-complex-example","title":"More Complex Example","text":"<p>In this example the plugin has external dependencies provided by OS repos, specifically glfw3, x11, glew, glu, opencv, and eigen3. <pre><code>1   set(TRACKER_SOURCES plugin.cpp\n2                       src/tracker.cpp\n3                       src/tracker.hpp)\n4\n5   set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n6\n7   find_package(glfw3 REQUIRED)\n8\n9   add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n10\n11  if(BUILD_OPENCV)\n12      add_dependencies(${PLUGIN_NAME} OpenCV_Viz)\n13  endif()\n14\n15  target_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS})\n16  target_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} dl pthread)\n17  target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n18\n19  install(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre></p> Line# Notes 1-3 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the <code>find_package</code> directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. <code>find_package</code> assumes that there is an appropriate .cmake config file for the dependency on your system. If not the <code>pkg_check_module</code> function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name   <code>PLUGIN_NAME</code>  from the specified source files. 11-13 OpenCV is a special case for a dependency. If your plugin requires OpenCV add these lines to your CMakeLists.txt file and do not use <code>find_package(OpenCV)</code>. 15 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR _SOURCE_DIR</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 16 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 17 Any compile options specific to this plugin. Usually this will be left as is. 19 Add the install directive. This should not need to change. <p>Note: Not all the dependencies were searched for by <code>find_package</code> in this example. This is because there is a set of dependencies which are very common to many plugins and their <code>find_package</code> calls are in the main ILLIXR CMakeLists.txt file and do not need to be searched for again. These packages are</p> <ul> <li>Glew</li> <li>Glu</li> <li>SQLite3</li> <li>X11</li> <li>Eigen3</li> </ul>"},{"location":"writing_your_plugin/#very-complex-example","title":"Very Complex Example","text":"<p>In this example the plugin has dependencies provided by OS repos, and a third party dependency provided by a git repo. <pre><code>1   set(TRACKER_SOURCES plugin.cpp\n2                       src/tracker.cpp\n3                       src/tracker.hpp)\n4\n5   set(PLUGIN_NAME plugin.tracker${ILLIXR_BUILD_SUFFIX})\n6\n7   find_package(glfw3 REQUIRED)\n8\n9   add_library(${PLUGIN_NAME} SHARED ${TRACKER_SOURCES})\n10\n11  get_external(Plotter)\n12\n13  add_dependencies(${PLUGIN_NAME} Plotter)\n14\n15  if(BUILD_OPENCV)\n16      add_dependencies(${PLUGIN_NAME} OpenCV_Viz)\n17  endif()\n18\n19  target_include_directories(${PLUGIN_NAME} PRIVATE ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${OpenCV_INCLUDE_DIRS} ${glfw3_INCLUDE_DIRS} ${gl_INCLUDE_DIRS} ${ILLIXR_SOURCE_DIR}/include ${Eigen3_INCLUDE_DIRS} ${Plotter_INCLUDE_DIRS})\n20  target_link_libraries(${PLUGIN_NAME} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${glu_LDFLAGS} ${OpenCV_LIBRARIES} ${glfw3_LIBRARIES} ${gl_LIBRARIES} ${Eigen3_LIBRARIES} ${Plotter_LIBRARIES} dl pthread)\n21  target_compile_features(${PLUGIN_NAME} PRIVATE cxx_std_17)\n22\n23  install(TARGETS ${PLUGIN_NAME} DESTINATION lib)\n</code></pre></p> Line# Notes 1-3 Specify the source code files individually, we discourage using  <code>GLOB</code>  or  <code>GLOB_RECURSE</code> to generate a list of files as these functions do not always notice when files change. 5 Put the plugin name into a variable (will also be the name of the library). 7 Use the <code>find_package</code> directive to locate any required dependencies. This will automatically populate variables containing header path and library names associated with the dependency. <code>find_package</code> assumes that there is an appropriate .cmake config file for the dependency on your system. If not the <code>pkg_check_module</code> function will perform the same task, but for dependencies which have associated .pc files on your system. 9 Tell the system we are building a shared library with the name   <code>PLUGIN_NAME</code>  from the specified source files. 11 Get the external project called Plotter. 13 Add the external package as a build dependency, this ensures that this plugin won't be built until after the dependency is. 15-17 OpenCV is a special case for a dependency. If your plugin requires OpenCV add these lines to your CMakeLists.txt file and do not use   <code>find_package(OpenCV)</code> . 19 Tell the system about any non-standard include paths the compiler needs to be aware of. Always include <code>ILLIXR _SOURCE_DIR</code> in this, as this is where plugin.hpp and other ILLIXR common headers are. 20 Tell the system about any libraries this plugin needs to link against (usually those associated with dependencies). 21 Any compile options specific to this plugin. Usually this will be left as is. 23 Add the install directive. This should not need to change. <p>Additionally, to build and install the Plotter dependency you will need to create a cmake file in the <code>cmake</code> directory named <code>GetPlotter.cmake</code> (case matters, it must match the call to <code>get_external</code>) with the following content. <pre><code>1   find_package(Plotter QUIET)\n2\n3   if(Plotter_FOUND)\n4       set(Plotter_VERSION \"${Plotter_VERSION_MAJOR}\")\n5   else()\n6       EXTERNALPROJECT_ADD(Plotter\n7               GIT_REPOSITORY https://github.com/mygit/Plotter.git\n8               GIT_TAG 4ff860838726a5e8ac0cbe59128c58a8f6143c6c\n9               PREFIX ${CMAKE_BINARY_DIR}/_deps/plotter\n10              CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DCMAKE_BUILD_TYPE=Release\n11              )\n12      set(Plotter_EXTERNAL Yes)\n13      set(Plotter_INCLUDE_DIRS ${CMAKE_INSTALL_PREFIX}/include)\n14      set(Plotter_LIBRARIES plotter;alt_plotter)\n15endif()\n</code></pre> | Line # | Notes                                                                                                                          | |--------|--------------------------------------------------------------------------------------------------------------------------------| | 1      | See if the package has been previously installed, quietly fail if not.                                                         | | 4      | If it was found, just record the installed version for reporting.                                                              | | 6-11   | Add the Plotter package as a project called <code>Plotter</code> (also case sensitive)                                                    | | 7      | The git repo where the Plotter package is located.                                                                             | | 8      | The git tag to use (can be a tag name or sha5 from a commit).                                                                  | | 9      | The build directory for the package.                                                                                           | | 10     | Any camke arguments to pass to the Plotter build. The ones specified here are required, but any others can be added.           | | 12     | Denote that this is an external package (this is used for internal tracking).                                                  | | 13     | Set where the Plotter include files will land. Usually this will not need to change.                                           | | 14     | Set which libraries are built by the Plotter package. In this example <code>libplotter.so</code> and <code>libalt_plotter.so</code> are being built. |</p>"},{"location":"writing_your_plugin/#external-plugins","title":"External Plugins","text":"<p>For plugins that are external packages (e.g. Audio_Pipeline) you need only create a <code>GetX.cmake</code> file as above and add the plugin name to the <code>external_plugins</code> list in <code>profiles/plugins.yaml</code>.</p> <p>External plugins with external dependencies are a bit more work, but are straight forward. See how Audio Pipeline is handled.</p>"},{"location":"writing_your_plugin/#tutorial","title":"Tutorial","text":"<p>You can extend ILLIXR for your own purposes. To add your own functionality via the plugin interface:</p> <ol> <li> <p>Create a new directory for your plugin in one of these ways </p> <ol> <li>in the plugins directory of the main ILLIXR tree, then follow these instructions</li> <li>anywhere for your new plugin so it can be pushed as a git repository, the follow these instructions focussing on external plugins</li> </ol> </li> <li> <p>You must decide if your plugin should inherit the standardized <code>threadloop</code>         or <code>plugin</code>.</p> <ul> <li> <p>If your plugin just needs to run one computation repeatedly, then your         plugin class should extend <code>threadloop</code>. Your code goes in         <code>_p_one_iteration</code>, which gets called in a hot loop. <code>threadloop</code>         inherits from plugin, but adds threading functionality. If you don't         use <code>_p_one_iteration</code>, inheriting from <code>threadloop</code> is superfluous;         Inherit from plugin directly instead.</p> </li> <li> <p>If you need custom concurrency (more complicated than a loop), triggered         concurrency (by events fired in other plugins), or no concurrency         then your plugin class should extend <code>plugin</code>. Your code goes         in the <code>start</code> method.</p> </li> <li> <p>If you want to schedule data-driven work in either case, call   <code>sb-&gt;schedule(...)</code>.</p> </li> <li> <p>If you spin your own threads, they must wait for       <code>pb-&gt;lookup_impl&lt;Stoplight&gt;()-&gt;wait_for_ready()</code> the first time they       run. This allows the start of all threads in ILLIXR to be       synchronized.</p> </li> <li> <p>They must be joined-or-disowned at-or-before       <code>plugin::stop()</code>. This allows ILLIXR to shutdown cleanly.</p> </li> </ul> </li> <li> <p>Write a file called <code>plugin.cpp</code> with this body, replacing every instance of <code>plugin_name</code>:</p> <pre><code>/// A minimal/no-op ILLIXR plugin\n\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\nusing namespace ILLIXR;\n\n/// Inherit from plugin if you don't need the threadloop\n/// Inherit from threadloop to provide a new thread to perform the task\nclass basic_plugin : public threadloop {\npublic:\n    basic_plugin(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n    {\n        std::cout &lt;&lt; \"Constructing basic_plugin.\" &lt;&lt; std::endl;\n    }\n\n    /// Note the virtual.\n    virtual ~basic_plugin() override {\n        std::cout &lt;&lt; \"Deconstructing basic_plugin.\" &lt;&lt; std::endl;\n    }\n\n    /// For `threadloop` style plugins, do not override the start() method unless you know what you're doing!\n    /// _p_one_iteration() is called in a thread created by threadloop::start()\n    void _p_one_iteration() override {\n        std::cout &lt;&lt; \"This goes to the log when `log` is set in the config.\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"This goes to the console.\" &lt;&lt; std::endl;\n        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n    }\n\n};\n\n/// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(basic_plugin);\n</code></pre> </li> <li> <p>At this point, you should be able to build your plugin with ILLIXR using -DUSE=ON as a command line argument to cmake.      See Getting Started for more details. <li> <p>Finally, run ILLIXR with your new plugin following the instructions in Getting Started:</p> </li> <li> <p>This is all that is required to be a plugin which can be loaded by Spindle in         the ILLIXR runtime.     Reading and writing from Phonebook and Switchboard is optional,         but nearly every plugin does it.     See <code>default_plugins.md</code> for more details.</p> <p>First, we can query the <code>phonebook</code> to get various services     including <code>switchboard</code>. Then we query <code>switchboard</code> for event-streams (topics). We will read <code>topic1</code>, write to <code>topic2</code>, and schedule computation on <code>topic 3</code>. See the API documentation for <code>phonebook</code> and <code>switchboard</code> for more details.</p> <pre><code>#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n/* When datatypes have to be common across plugins\n *     (e.g. a phonebook service or switchboard topic),\n *      they are defined in this header,\n *      which is accessible to all plugins.\n */\n#include \"common/data_format.hpp\"\n\nclass plugin_name : public threadloop {\npublic:\n    /* After the constructor, C++ permits a list of member-constructors.\n     * We use uniform initialization (curly-braces) [1] instead of parens to\n     *     avoid ambiguity [2].\n     * We put the comma at the start of the line, so that lines can be copied around\n     *     or deleted freely (except for the first).\n     *\n     * [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n     * [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n     */\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n          /// Find the switchboard in phonebook\n        , sb{pb-&gt;lookup_impl&lt;switchboard&gt;()}\n          /// Create a handle to a topic in switchboard for subscribing\n        , topic1{sb-&gt;get_reader&lt;topic1_type&gt;(\"topic1\")}\n          /// Create a handle to a topic in switchboard for publishing\n        , topic2{sb-&gt;get_writer&lt;topic2_type&gt;(\"topic2\")}\n    {\n        /// Read topic 1\n        switchboard::ptr&lt;const topic1_type&gt; event1 = topic1.get_ro();\n\n        /// Write to topic 2\n        topic2.put(\n            topic2.allocate&lt;topic2_type&gt;(\n                arg_1, // topic2_type::topic2_type() arg_type_1\n                ...,   // ...\n                arg_k  // topic2_type::topic2_type() arg_type_k\n            )\n        );\n\n        /// Read topic 3 synchronously\n        sb-&gt;schedule&lt;topic3_type&gt;(\n            get_name(),\n            \"topic3\",\n            [&amp;](switchboard::ptr&lt;const topic3_type&gt; event3, std::size_t) {\n                /* This is a [lambda expression][1]\n                 *\n                 * [1]: https://en.cppreference.com/w/cpp/language/lambda\n                 */\n                std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3 &lt;&lt; std::endl;\n                callback(event3);\n            }\n        );\n    }\n\n    virtual void _p_one_iteration override() {\n        std::cout &lt;&lt; \"Running\" &lt;&lt; std::endl;\n        auto target = std::chrono::system_clock::now()\n                    + std::chrono::milliseconds{10};\n        reliable_sleep(target);\n    }\n\nprivate:\n    const std::shared_ptr&lt;switchboard&gt; sb;\n    switchboard::reader&lt;topic1_type&gt; topic1;\n    switchboard::writer&lt;topic2&gt; topic2;\n};\n\n/// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n</code></pre> </li>"},{"location":"api/CMakeLists_8txt/","title":"File CMakeLists.txt","text":"<p>FileList &gt; CMakeLists.txt</p> <p>Go to the source code of this file</p>"},{"location":"api/CMakeLists_8txt/#public-functions","title":"Public Functions","text":"Type Name add_executable (main${ILLIXR_BUILD_SUFFIX}.exe src/main.cpp src/illixr.hpp src/cxxopts.hpp ../include/illixr/runtime.hpp ../include/illixr/phonebook. hpp)  SHARED src plugin cpp src runtime_impl cpp src illixr hpp src cxxopts hpp include illixr runtime hpp include illixr phonebook hpp get_external (Yamlcpp)"},{"location":"api/CMakeLists_8txt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/CMakeLists_8txt/#function-add_executable","title":"function add_executable","text":"<pre><code>add_executable (\n    main${ILLIXR_BUILD_SUFFIX}.exe src/main.cpp src/illixr.hpp src/cxxopts.hpp ../include/illixr/runtime.hpp ../include/illixr/phonebook. hpp\n) \n</code></pre>"},{"location":"api/CMakeLists_8txt/#function-get_external","title":"function get_external","text":"<pre><code>SHARED src plugin cpp src runtime_impl cpp src illixr hpp src cxxopts hpp include illixr runtime hpp include illixr phonebook hpp get_external (\n    Yamlcpp\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/CMakeLists.txt</code></p>"},{"location":"api/CMakeLists_8txt_source/","title":"File CMakeLists.txt","text":"<p>File List &gt; CMakeLists.txt</p> <p>Go to the documentation of this file</p> <pre><code>add_executable(main${ILLIXR_BUILD_SUFFIX}.exe\n        src/main.cpp\n        src/illixr.hpp\n        src/cxxopts.hpp\n        ../include/illixr/runtime.hpp\n        ../include/illixr/phonebook.hpp\n        )\nadd_library(plugin.main${ILLIXR_BUILD_SUFFIX} SHARED\n        src/plugin.cpp\n        src/runtime_impl.cpp\n        src/illixr.hpp\n        src/cxxopts.hpp\n        ../include/illixr/runtime.hpp\n        ../include/illixr/phonebook.hpp\n        )\n\n##############\n# yaml parser\n##############\n\nget_external(Yamlcpp)\n\ntarget_compile_definitions(plugin.main${ILLIXR_BUILD_SUFFIX} PRIVATE \"ILLIXR_VISUALIZERS='${VIS_NAMES}'\")\n\ntarget_include_directories(main${ILLIXR_BUILD_SUFFIX}.exe PUBLIC ${CMAKE_SOURCE_DIR}/include)\ntarget_link_libraries(main${ILLIXR_BUILD_SUFFIX}.exe dl stdc++fs plugin.main${ILLIXR_BUILD_SUFFIX})\n\ntarget_include_directories(plugin.main${ILLIXR_BUILD_SUFFIX} PUBLIC ${X11_INCLUDE_DIR} ${GLEW_INCLUDE_DIR} ${SQLite3_INCLUDE_DIR} ${GLU_INCLUDE_DIR} ${gl_INCLUDE_DIRS} ${yaml-cpp_INCLUDE_DIRS} ${CMAKE_SOURCE_DIR}/include)\ntarget_link_libraries(plugin.main${ILLIXR_BUILD_SUFFIX} ${X11_LIBRARIES} ${GLEW_LIBRARIES} ${SQLite3_LIBRARIES} ${glu_LDFLAGS} ${gl_LIBRARIES} dl Threads::Threads stdc++fs ${yaml-cpp_LIBRARIES} spdlog::spdlog)\n\ninstall(TARGETS main${ILLIXR_BUILD_SUFFIX}.exe DESTINATION bin)\ninstall(TARGETS plugin.main${ILLIXR_BUILD_SUFFIX} DESTINATION lib)\n</code></pre>"},{"location":"api/classILLIXR_1_1cancellable__sleep/","title":"Class ILLIXR::cancellable_sleep","text":"<p>ClassList &gt; ILLIXR &gt; cancellable_sleep</p>"},{"location":"api/classILLIXR_1_1cancellable__sleep/#public-functions","title":"Public Functions","text":"Type Name void cancel ()  bool sleep (std::chrono::duration&lt; T, R &gt; duration)"},{"location":"api/classILLIXR_1_1cancellable__sleep/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1cancellable__sleep/#function-cancel","title":"function cancel","text":"<pre><code>inline void ILLIXR::cancellable_sleep::cancel () \n</code></pre>"},{"location":"api/classILLIXR_1_1cancellable__sleep/#function-sleep","title":"function sleep","text":"<pre><code>template&lt;typename T, typename R&gt;\ninline bool ILLIXR::cancellable_sleep::sleep (\n    std::chrono::duration&lt; T, R &gt; duration\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/illixr.hpp</code></p>"},{"location":"api/classILLIXR_1_1noop__record__logger/","title":"Class ILLIXR::noop_record_logger","text":"<p>ClassList &gt; ILLIXR &gt; noop_record_logger</p> <p>Inherits the following classes: record_logger</p>"},{"location":"api/classILLIXR_1_1noop__record__logger/#protected-functions","title":"Protected Functions","text":"Type Name virtual void log (const record &amp; r) override"},{"location":"api/classILLIXR_1_1noop__record__logger/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1noop__record__logger/#function-log","title":"function log","text":"<pre><code>inline virtual void ILLIXR::noop_record_logger::log (\n    const record &amp; r\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/noop_record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1sqlite__record__logger/","title":"Class ILLIXR::sqlite_record_logger","text":"<p>ClassList &gt; ILLIXR &gt; sqlite_record_logger</p> <p>Inherits the following classes: record_logger</p>"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#protected-functions","title":"Protected Functions","text":"Type Name virtual void log (const std::vector&lt; record &gt; &amp; r) override virtual void log (const record &amp; r) override"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1sqlite__record__logger/#function-log-12","title":"function log [1/2]","text":"<pre><code>inline virtual void ILLIXR::sqlite_record_logger::log (\n    const std::vector&lt; record &gt; &amp; r\n) override\n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__record__logger/#function-log-22","title":"function log [2/2]","text":"<pre><code>inline virtual void ILLIXR::sqlite_record_logger::log (\n    const record &amp; r\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/sqlite_record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1sqlite__thread/","title":"Class ILLIXR::sqlite_thread","text":"<p>ClassList &gt; ILLIXR &gt; sqlite_thread</p>"},{"location":"api/classILLIXR_1_1sqlite__thread/#public-functions","title":"Public Functions","text":"Type Name sqlite3pp::database prep_db ()  std::string prep_insert_str ()  void process (const std::vector&lt; record &gt; &amp; record_batch, std::size_t batch_size)  void pull_queue ()  void put_queue (const std::vector&lt; record &gt; &amp; buffer_in)  void put_queue (const record &amp; record_in)  sqlite_thread (const record_header &amp; rh_)  ~sqlite_thread ()"},{"location":"api/classILLIXR_1_1sqlite__thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1sqlite__thread/#function-prep_db","title":"function prep_db","text":"<pre><code>inline sqlite3pp::database ILLIXR::sqlite_thread::prep_db () \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-prep_insert_str","title":"function prep_insert_str","text":"<pre><code>inline std::string ILLIXR::sqlite_thread::prep_insert_str () \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-process","title":"function process","text":"<pre><code>inline void ILLIXR::sqlite_thread::process (\n    const std::vector&lt; record &gt; &amp; record_batch,\n    std::size_t batch_size\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-pull_queue","title":"function pull_queue","text":"<pre><code>inline void ILLIXR::sqlite_thread::pull_queue () \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-put_queue-12","title":"function put_queue [1/2]","text":"<pre><code>inline void ILLIXR::sqlite_thread::put_queue (\n    const std::vector&lt; record &gt; &amp; buffer_in\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-put_queue-22","title":"function put_queue [2/2]","text":"<pre><code>inline void ILLIXR::sqlite_thread::put_queue (\n    const record &amp; record_in\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-sqlite_thread","title":"function sqlite_thread","text":"<pre><code>inline ILLIXR::sqlite_thread::sqlite_thread (\n    const record_header &amp; rh_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1sqlite__thread/#function-sqlite_thread_1","title":"function ~sqlite_thread","text":"<pre><code>inline ILLIXR::sqlite_thread::~sqlite_thread () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/sqlite_record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1stdout__record__logger/","title":"Class ILLIXR::stdout_record_logger","text":"<p>ClassList &gt; ILLIXR &gt; stdout_record_logger</p> <p>Inherits the following classes: record_logger</p>"},{"location":"api/classILLIXR_1_1stdout__record__logger/#protected-functions","title":"Protected Functions","text":"Type Name virtual void log (const record &amp; r) override"},{"location":"api/classILLIXR_1_1stdout__record__logger/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1stdout__record__logger/#function-log","title":"function log","text":"<pre><code>inline virtual void ILLIXR::stdout_record_logger::log (\n    const record &amp; r\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/stdout_record_logger.hpp</code></p>"},{"location":"api/classcxxopts_1_1KeyValue/","title":"Class cxxopts::KeyValue","text":"<p>ClassList &gt; cxxopts &gt; KeyValue</p>"},{"location":"api/classcxxopts_1_1KeyValue/#public-functions","title":"Public Functions","text":"Type Name KeyValue (std::string key_, std::string value_) noexcept T as () const CXXOPTS_NODISCARD const std::string &amp; key () const CXXOPTS_NODISCARD const std::string &amp; value () const"},{"location":"api/classcxxopts_1_1KeyValue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1KeyValue/#function-keyvalue","title":"function KeyValue","text":"<pre><code>inline cxxopts::KeyValue::KeyValue (\n    std::string key_,\n    std::string value_\n) noexcept\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-as","title":"function as","text":"<pre><code>template&lt;typename T&gt;\ninline T cxxopts::KeyValue::as () const\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-key","title":"function key","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::KeyValue::key () const\n</code></pre>"},{"location":"api/classcxxopts_1_1KeyValue/#function-value","title":"function value","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::KeyValue::value () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionAdder/","title":"Class cxxopts::OptionAdder","text":"<p>ClassList &gt; cxxopts &gt; OptionAdder</p>"},{"location":"api/classcxxopts_1_1OptionAdder/#public-functions","title":"Public Functions","text":"Type Name OptionAdder (Options &amp; options, std::string group)  OptionAdder &amp; operator() (const std::string &amp; opts, const std::string &amp; desc, const std::shared_ptr&lt; const Value &gt; &amp; value=::cxxopts::value&lt; bool &gt;(), std::string arg_help=\"\")"},{"location":"api/classcxxopts_1_1OptionAdder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionAdder/#function-optionadder","title":"function OptionAdder","text":"<pre><code>inline cxxopts::OptionAdder::OptionAdder (\n    Options &amp; options,\n    std::string group\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionAdder/#function-operator","title":"function operator()","text":"<pre><code>inline OptionAdder &amp; cxxopts::OptionAdder::operator() (\n    const std::string &amp; opts,\n    const std::string &amp; desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value=::cxxopts::value&lt; bool &gt;(),\n    std::string arg_help=\"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionDetails/","title":"Class cxxopts::OptionDetails","text":"<p>ClassList &gt; cxxopts &gt; OptionDetails</p>"},{"location":"api/classcxxopts_1_1OptionDetails/#public-functions","title":"Public Functions","text":"Type Name OptionDetails (std::string short_, OptionNames long_, String desc, std::shared_ptr&lt; const Value &gt; val)  OptionDetails (const OptionDetails &amp; rhs)  OptionDetails (OptionDetails &amp;&amp; rhs) = default CXXOPTS_NODISCARD const String &amp; description () const CXXOPTS_NODISCARD const std::string &amp; essential_name () const CXXOPTS_NODISCARD const std::string &amp; first_long_name () const std::size_t hash () const CXXOPTS_NODISCARD const OptionNames &amp; long_names () const CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; make_storage () const CXXOPTS_NODISCARD const std::string &amp; short_name () const CXXOPTS_NODISCARD const Value &amp; value () const"},{"location":"api/classcxxopts_1_1OptionDetails/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-13","title":"function OptionDetails [1/3]","text":"<pre><code>inline cxxopts::OptionDetails::OptionDetails (\n    std::string short_,\n    OptionNames long_,\n    String desc,\n    std::shared_ptr&lt; const Value &gt; val\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-23","title":"function OptionDetails [2/3]","text":"<pre><code>inline cxxopts::OptionDetails::OptionDetails (\n    const OptionDetails &amp; rhs\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-optiondetails-33","title":"function OptionDetails [3/3]","text":"<pre><code>cxxopts::OptionDetails::OptionDetails (\n    OptionDetails &amp;&amp; rhs\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-description","title":"function description","text":"<pre><code>inline CXXOPTS_NODISCARD const String &amp; cxxopts::OptionDetails::description () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-essential_name","title":"function essential_name","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::essential_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-first_long_name","title":"function first_long_name","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::first_long_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-hash","title":"function hash","text":"<pre><code>inline std::size_t cxxopts::OptionDetails::hash () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-long_names","title":"function long_names","text":"<pre><code>inline CXXOPTS_NODISCARD const OptionNames &amp; cxxopts::OptionDetails::long_names () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-make_storage","title":"function make_storage","text":"<pre><code>inline CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; cxxopts::OptionDetails::make_storage () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-short_name","title":"function short_name","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::OptionDetails::short_name () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionDetails/#function-value","title":"function value","text":"<pre><code>inline CXXOPTS_NODISCARD const Value &amp; cxxopts::OptionDetails::value () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionParser/","title":"Class cxxopts::OptionParser","text":"<p>ClassList &gt; cxxopts &gt; OptionParser</p>"},{"location":"api/classcxxopts_1_1OptionParser/#public-functions","title":"Public Functions","text":"Type Name OptionParser (const OptionMap &amp; options, const PositionalList &amp; positional, bool allow_unrecognised)  void add_to_option (OptionMap::const_iterator iter, const std::string &amp; option, const std::string &amp; arg)  void checked_parse_arg (int argc, const char *const * argv, int &amp; current, const std::shared_ptr&lt; OptionDetails &gt; &amp; value, const std::string &amp; name)  bool consume_positional (const std::string &amp; a, PositionalListIterator &amp; next)  ParseResult parse (int argc, const char *const * argv)  void parse_default (const std::shared_ptr&lt; OptionDetails &gt; &amp; details)  void parse_no_value (const std::shared_ptr&lt; OptionDetails &gt; &amp; details)  void parse_option (const std::shared_ptr&lt; OptionDetails &gt; &amp; value, const std::string &amp; name, const std::string &amp; arg=\"\")"},{"location":"api/classcxxopts_1_1OptionParser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionParser/#function-optionparser","title":"function OptionParser","text":"<pre><code>inline cxxopts::OptionParser::OptionParser (\n    const OptionMap &amp; options,\n    const PositionalList &amp; positional,\n    bool allow_unrecognised\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-add_to_option","title":"function add_to_option","text":"<pre><code>inline void cxxopts::OptionParser::add_to_option (\n    OptionMap::const_iterator iter,\n    const std::string &amp; option,\n    const std::string &amp; arg\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-checked_parse_arg","title":"function checked_parse_arg","text":"<pre><code>inline void cxxopts::OptionParser::checked_parse_arg (\n    int argc,\n    const char *const * argv,\n    int &amp; current,\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; value,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-consume_positional","title":"function consume_positional","text":"<pre><code>inline bool cxxopts::OptionParser::consume_positional (\n    const std::string &amp; a,\n    PositionalListIterator &amp; next\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse","title":"function parse","text":"<pre><code>inline ParseResult cxxopts::OptionParser::parse (\n    int argc,\n    const char *const * argv\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_default","title":"function parse_default","text":"<pre><code>inline void cxxopts::OptionParser::parse_default (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_no_value","title":"function parse_no_value","text":"<pre><code>inline void cxxopts::OptionParser::parse_no_value (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionParser/#function-parse_option","title":"function parse_option","text":"<pre><code>inline void cxxopts::OptionParser::parse_option (\n    const std::shared_ptr&lt; OptionDetails &gt; &amp; value,\n    const std::string &amp; name,\n    const std::string &amp; arg=\"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1OptionValue/","title":"Class cxxopts::OptionValue","text":"<p>ClassList &gt; cxxopts &gt; OptionValue</p>"},{"location":"api/classcxxopts_1_1OptionValue/#public-functions","title":"Public Functions","text":"Type Name const T &amp; as () const CXXOPTS_NODISCARD std::size_t count () noexcept const CXXOPTS_NODISCARD bool has_default () noexcept const void parse (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details, const std::string &amp; text)  void parse_default (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details)  void parse_no_value (const std::shared_ptr&lt; const OptionDetails &gt; &amp; details)"},{"location":"api/classcxxopts_1_1OptionValue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1OptionValue/#function-as","title":"function as","text":"<pre><code>template&lt;typename T&gt;\ninline const T &amp; cxxopts::OptionValue::as () const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-count","title":"function count","text":"<pre><code>inline CXXOPTS_NODISCARD std::size_t cxxopts::OptionValue::count () noexcept const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-has_default","title":"function has_default","text":"<pre><code>inline CXXOPTS_NODISCARD bool cxxopts::OptionValue::has_default () noexcept const\n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse","title":"function parse","text":"<pre><code>inline void cxxopts::OptionValue::parse (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details,\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse_default","title":"function parse_default","text":"<pre><code>inline void cxxopts::OptionValue::parse_default (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1OptionValue/#function-parse_no_value","title":"function parse_no_value","text":"<pre><code>inline void cxxopts::OptionValue::parse_no_value (\n    const std::shared_ptr&lt; const OptionDetails &gt; &amp; details\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1Options/","title":"Class cxxopts::Options","text":"<p>ClassList &gt; cxxopts &gt; Options</p>"},{"location":"api/classcxxopts_1_1Options/#public-functions","title":"Public Functions","text":"Type Name Options (std::string program_name, std::string help_string=\"\")  void add_option (const std::string &amp; group, const Option &amp; option)  void add_option (const std::string &amp; group, const std::string &amp; s, const OptionNames &amp; l, std::string desc, const std::shared_ptr&lt; const Value &gt; &amp; value, std::string arg_help)  void add_option (const std::string &amp; group, const std::string &amp; short_name, const std::string &amp; single_long_name, std::string desc, const std::shared_ptr&lt; const Value &gt; &amp; value, std::string arg_help)  OptionAdder add_options (std::string group=\"\")  void add_options (const std::string &amp; group, std::initializer_list&lt; Option &gt; options)  Options &amp; allow_unrecognised_options ()  Options &amp; custom_help (std::string help_text)  const HelpGroupDetails &amp; group_help (const std::string &amp; group) const std::vector&lt; std::string &gt; groups () const std::string help (const std::vector&lt; std::string &gt; &amp; groups={}, bool print_usage=true) const ParseResult parse (int argc, const char *const * argv)  void parse_positional (std::string option)  void parse_positional (std::vector&lt; std::string &gt; options)  void parse_positional (std::initializer_list&lt; std::string &gt; options)  void parse_positional (Iterator begin, Iterator end)  Options &amp; positional_help (std::string help_text)  const std::string &amp; program () const Options &amp; set_tab_expansion (bool expansion=true)  Options &amp; set_width (std::size_t width)  Options &amp; show_positional_help ()"},{"location":"api/classcxxopts_1_1Options/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1Options/#function-options","title":"function Options","text":"<pre><code>inline explicit cxxopts::Options::Options (\n    std::string program_name,\n    std::string help_string=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-13","title":"function add_option [1/3]","text":"<pre><code>inline void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const Option &amp; option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-23","title":"function add_option [2/3]","text":"<pre><code>inline void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const std::string &amp; s,\n    const OptionNames &amp; l,\n    std::string desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value,\n    std::string arg_help\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_option-33","title":"function add_option [3/3]","text":"<pre><code>inline void cxxopts::Options::add_option (\n    const std::string &amp; group,\n    const std::string &amp; short_name,\n    const std::string &amp; single_long_name,\n    std::string desc,\n    const std::shared_ptr&lt; const Value &gt; &amp; value,\n    std::string arg_help\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_options-12","title":"function add_options [1/2]","text":"<pre><code>inline OptionAdder cxxopts::Options::add_options (\n    std::string group=\"\"\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-add_options-22","title":"function add_options [2/2]","text":"<pre><code>inline void cxxopts::Options::add_options (\n    const std::string &amp; group,\n    std::initializer_list&lt; Option &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-allow_unrecognised_options","title":"function allow_unrecognised_options","text":"<pre><code>inline Options &amp; cxxopts::Options::allow_unrecognised_options () \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-custom_help","title":"function custom_help","text":"<pre><code>inline Options &amp; cxxopts::Options::custom_help (\n    std::string help_text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-group_help","title":"function group_help","text":"<pre><code>inline const HelpGroupDetails &amp; cxxopts::Options::group_help (\n    const std::string &amp; group\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-groups","title":"function groups","text":"<pre><code>inline std::vector&lt; std::string &gt; cxxopts::Options::groups () const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-help","title":"function help","text":"<pre><code>inline std::string cxxopts::Options::help (\n    const std::vector&lt; std::string &gt; &amp; groups={},\n    bool print_usage=true\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse","title":"function parse","text":"<pre><code>inline ParseResult cxxopts::Options::parse (\n    int argc,\n    const char *const * argv\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-14","title":"function parse_positional [1/4]","text":"<pre><code>inline void cxxopts::Options::parse_positional (\n    std::string option\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-24","title":"function parse_positional [2/4]","text":"<pre><code>inline void cxxopts::Options::parse_positional (\n    std::vector&lt; std::string &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-34","title":"function parse_positional [3/4]","text":"<pre><code>inline void cxxopts::Options::parse_positional (\n    std::initializer_list&lt; std::string &gt; options\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-parse_positional-44","title":"function parse_positional [4/4]","text":"<pre><code>template&lt;typename Iterator&gt;\ninline void cxxopts::Options::parse_positional (\n    Iterator begin,\n    Iterator end\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-positional_help","title":"function positional_help","text":"<pre><code>inline Options &amp; cxxopts::Options::positional_help (\n    std::string help_text\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-program","title":"function program","text":"<pre><code>inline const std::string &amp; cxxopts::Options::program () const\n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-set_tab_expansion","title":"function set_tab_expansion","text":"<pre><code>inline Options &amp; cxxopts::Options::set_tab_expansion (\n    bool expansion=true\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-set_width","title":"function set_width","text":"<pre><code>inline Options &amp; cxxopts::Options::set_width (\n    std::size_t width\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1Options/#function-show_positional_help","title":"function show_positional_help","text":"<pre><code>inline Options &amp; cxxopts::Options::show_positional_help () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1ParseResult/","title":"Class cxxopts::ParseResult","text":"<p>ClassList &gt; cxxopts &gt; ParseResult</p>"},{"location":"api/classcxxopts_1_1ParseResult/#classes","title":"Classes","text":"Type Name class Iterator"},{"location":"api/classcxxopts_1_1ParseResult/#public-functions","title":"Public Functions","text":"Type Name ParseResult () = default ParseResult (const ParseResult &amp;) = default ParseResult (NameHashMap &amp;&amp; keys, ParsedHashMap &amp;&amp; values, std::vector&lt; KeyValue &gt; sequential, std::vector&lt; KeyValue &gt; default_opts, std::vector&lt; std::string &gt; &amp;&amp; unmatched_args)  const std::vector&lt; KeyValue &gt; &amp; arguments () const const std::string arguments_string () const Iterator begin () const std::size_t count (const std::string &amp; o) const const std::vector&lt; KeyValue &gt; &amp; defaults () const Iterator end () const ParseResult &amp; operator= (ParseResult &amp;&amp;) = default ParseResult &amp; operator= (const ParseResult &amp;) = default const OptionValue &amp; operator[] (const std::string &amp; option) const const std::vector&lt; std::string &gt; &amp; unmatched () const"},{"location":"api/classcxxopts_1_1ParseResult/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-13","title":"function ParseResult [1/3]","text":"<pre><code>cxxopts::ParseResult::ParseResult () = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-23","title":"function ParseResult [2/3]","text":"<pre><code>cxxopts::ParseResult::ParseResult (\n    const ParseResult &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-parseresult-33","title":"function ParseResult [3/3]","text":"<pre><code>inline cxxopts::ParseResult::ParseResult (\n    NameHashMap &amp;&amp; keys,\n    ParsedHashMap &amp;&amp; values,\n    std::vector&lt; KeyValue &gt; sequential,\n    std::vector&lt; KeyValue &gt; default_opts,\n    std::vector&lt; std::string &gt; &amp;&amp; unmatched_args\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-arguments","title":"function arguments","text":"<pre><code>inline const std::vector&lt; KeyValue &gt; &amp; cxxopts::ParseResult::arguments () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-arguments_string","title":"function arguments_string","text":"<pre><code>inline const std::string cxxopts::ParseResult::arguments_string () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-begin","title":"function begin","text":"<pre><code>inline Iterator cxxopts::ParseResult::begin () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-count","title":"function count","text":"<pre><code>inline std::size_t cxxopts::ParseResult::count (\n    const std::string &amp; o\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-defaults","title":"function defaults","text":"<pre><code>inline const std::vector&lt; KeyValue &gt; &amp; cxxopts::ParseResult::defaults () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-end","title":"function end","text":"<pre><code>inline Iterator cxxopts::ParseResult::end () const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator","title":"function operator=","text":"<pre><code>ParseResult &amp; cxxopts::ParseResult::operator= (\n    ParseResult &amp;&amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator_1","title":"function operator=","text":"<pre><code>ParseResult &amp; cxxopts::ParseResult::operator= (\n    const ParseResult &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-operator_2","title":"function operator[]","text":"<pre><code>inline const OptionValue &amp; cxxopts::ParseResult::operator[] (\n    const std::string &amp; option\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult/#function-unmatched","title":"function unmatched","text":"<pre><code>inline const std::vector&lt; std::string &gt; &amp; cxxopts::ParseResult::unmatched () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/","title":"Class cxxopts::ParseResult::Iterator","text":"<p>ClassList &gt; cxxopts &gt; ParseResult &gt; Iterator</p>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-types","title":"Public Types","text":"Type Name typedef void difference_type typedef std::forward_iterator_tag iterator_category typedef const KeyValue * pointer typedef const KeyValue &amp; reference typedef KeyValue value_type"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-functions","title":"Public Functions","text":"Type Name Iterator () = default Iterator (const Iterator &amp;) = default CXXOPTS_DIAGNOSTIC_PUSH Iterator (const ParseResult * pr, bool end=false)  bool operator!= (const Iterator &amp; other) const const KeyValue &amp; operator* ()  CXXOPTS_DIAGNOSTIC_POP Iterator &amp; operator++ ()  Iterator operator++ (int)  const KeyValue * operator-&gt; ()  bool operator== (const Iterator &amp; other) const"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using cxxopts::ParseResult::Iterator::difference_type =  void;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>using cxxopts::ParseResult::Iterator::iterator_category =  std::forward_iterator_tag;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using cxxopts::ParseResult::Iterator::pointer =  const KeyValue*;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-reference","title":"typedef reference","text":"<pre><code>using cxxopts::ParseResult::Iterator::reference =  const KeyValue&amp;;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using cxxopts::ParseResult::Iterator::value_type =  KeyValue;\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-13","title":"function Iterator [1/3]","text":"<pre><code>cxxopts::ParseResult::Iterator::Iterator () = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-23","title":"function Iterator [2/3]","text":"<pre><code>cxxopts::ParseResult::Iterator::Iterator (\n    const Iterator &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-iterator-33","title":"function Iterator [3/3]","text":"<pre><code>inline CXXOPTS_DIAGNOSTIC_PUSH cxxopts::ParseResult::Iterator::Iterator (\n    const ParseResult * pr,\n    bool end=false\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator","title":"function operator!=","text":"<pre><code>inline bool cxxopts::ParseResult::Iterator::operator!= (\n    const Iterator &amp; other\n) const\n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline const KeyValue &amp; cxxopts::ParseResult::Iterator::operator* () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline CXXOPTS_DIAGNOSTIC_POP Iterator &amp; cxxopts::ParseResult::Iterator::operator++ () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_3","title":"function operator++","text":"<pre><code>inline Iterator cxxopts::ParseResult::Iterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline const KeyValue * cxxopts::ParseResult::Iterator::operator-&gt; () \n</code></pre>"},{"location":"api/classcxxopts_1_1ParseResult_1_1Iterator/#function-operator_4","title":"function operator==","text":"<pre><code>inline bool cxxopts::ParseResult::Iterator::operator== (\n    const Iterator &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1Value/","title":"Class cxxopts::Value","text":"<p>ClassList &gt; cxxopts &gt; Value</p> <p>Inherits the following classes: std::enable_shared_from_this&lt; Value &gt;</p> <p>Inherited by the following classes: cxxopts::values::abstract_value,  cxxopts::values::abstract_value</p>"},{"location":"api/classcxxopts_1_1Value/#public-functions","title":"Public Functions","text":"Type Name virtual std::shared_ptr&lt; Value &gt; clone () const = 0 virtual std::shared_ptr&lt; Value &gt; default_value (const std::string &amp; value) = 0 virtual std::string get_default_value () const = 0 virtual std::string get_implicit_value () const = 0 virtual bool has_default () const = 0 virtual bool has_implicit () const = 0 virtual std::shared_ptr&lt; Value &gt; implicit_value (const std::string &amp; value) = 0 virtual bool is_boolean () const = 0 virtual bool is_container () const = 0 virtual std::shared_ptr&lt; Value &gt; no_implicit_value () = 0 virtual void parse (const std::string &amp; text) const = 0 virtual void parse () const = 0 virtual ~Value () = default"},{"location":"api/classcxxopts_1_1Value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1Value/#function-clone","title":"function clone","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::clone () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-default_value","title":"function default_value","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::default_value (\n    const std::string &amp; value\n) = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-get_default_value","title":"function get_default_value","text":"<pre><code>virtual std::string cxxopts::Value::get_default_value () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-get_implicit_value","title":"function get_implicit_value","text":"<pre><code>virtual std::string cxxopts::Value::get_implicit_value () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-has_default","title":"function has_default","text":"<pre><code>virtual bool cxxopts::Value::has_default () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-has_implicit","title":"function has_implicit","text":"<pre><code>virtual bool cxxopts::Value::has_implicit () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-implicit_value","title":"function implicit_value","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::implicit_value (\n    const std::string &amp; value\n) = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-is_boolean","title":"function is_boolean","text":"<pre><code>virtual bool cxxopts::Value::is_boolean () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-is_container","title":"function is_container","text":"<pre><code>virtual bool cxxopts::Value::is_container () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-no_implicit_value","title":"function no_implicit_value","text":"<pre><code>virtual std::shared_ptr&lt; Value &gt; cxxopts::Value::no_implicit_value () = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-parse-12","title":"function parse [1/2]","text":"<pre><code>virtual void cxxopts::Value::parse (\n    const std::string &amp; text\n) const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-parse-22","title":"function parse [2/2]","text":"<pre><code>virtual void cxxopts::Value::parse () const = 0\n</code></pre>"},{"location":"api/classcxxopts_1_1Value/#function-value","title":"function ~Value","text":"<pre><code>virtual cxxopts::Value::~Value () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/","title":"Class cxxopts::exceptions::exception","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; exception</p> <p>Inherits the following classes: std::exception</p> <p>Inherited by the following classes: cxxopts::exceptions::option_has_no_value,  cxxopts::exceptions::parsing,  cxxopts::exceptions::specification</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#public-functions","title":"Public Functions","text":"Type Name exception (std::string message)  CXXOPTS_NODISCARD const char * what () noexcept override const"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#function-exception","title":"function exception","text":"<pre><code>inline explicit cxxopts::exceptions::exception::exception (\n    std::string message\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1exceptions_1_1exception/#function-what","title":"function what","text":"<pre><code>inline CXXOPTS_NODISCARD const char * cxxopts::exceptions::exception::what () noexcept override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/","title":"Class cxxopts::exceptions::gratuitous_argument_for_option","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; gratuitous_argument_for_option</p> <p>Inherits the following classes: cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/#public-functions","title":"Public Functions","text":"Type Name gratuitous_argument_for_option (const std::string &amp; option, const std::string &amp; arg)"},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1gratuitous__argument__for__option/#function-gratuitous_argument_for_option","title":"function gratuitous_argument_for_option","text":"<pre><code>inline cxxopts::exceptions::gratuitous_argument_for_option::gratuitous_argument_for_option (\n    const std::string &amp; option,\n    const std::string &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/","title":"Class cxxopts::exceptions::incorrect_argument_type","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; incorrect_argument_type</p> <p>Inherits the following classes: cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/#public-functions","title":"Public Functions","text":"Type Name incorrect_argument_type (const std::string &amp; arg)"},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1incorrect__argument__type/#function-incorrect_argument_type","title":"function incorrect_argument_type","text":"<pre><code>inline explicit cxxopts::exceptions::incorrect_argument_type::incorrect_argument_type (\n    const std::string &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/","title":"Class cxxopts::exceptions::invalid_option_format","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; invalid_option_format</p> <p>Inherits the following classes: cxxopts::exceptions::specification</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/#public-functions","title":"Public Functions","text":"Type Name invalid_option_format (const std::string &amp; format)"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__format/#function-invalid_option_format","title":"function invalid_option_format","text":"<pre><code>inline explicit cxxopts::exceptions::invalid_option_format::invalid_option_format (\n    const std::string &amp; format\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/","title":"Class cxxopts::exceptions::invalid_option_syntax","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; invalid_option_syntax</p> <p>Inherits the following classes: cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/#public-functions","title":"Public Functions","text":"Type Name invalid_option_syntax (const std::string &amp; text)"},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1invalid__option__syntax/#function-invalid_option_syntax","title":"function invalid_option_syntax","text":"<pre><code>inline explicit cxxopts::exceptions::invalid_option_syntax::invalid_option_syntax (\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/","title":"Class cxxopts::exceptions::missing_argument","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; missing_argument</p> <p>Inherits the following classes: cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/#public-functions","title":"Public Functions","text":"Type Name missing_argument (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1missing__argument/#function-missing_argument","title":"function missing_argument","text":"<pre><code>inline explicit cxxopts::exceptions::missing_argument::missing_argument (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/","title":"Class cxxopts::exceptions::no_such_option","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; no_such_option</p> <p>Inherits the following classes: cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/#public-functions","title":"Public Functions","text":"Type Name no_such_option (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1no__such__option/#function-no_such_option","title":"function no_such_option","text":"<pre><code>inline explicit cxxopts::exceptions::no_such_option::no_such_option (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/","title":"Class cxxopts::exceptions::option_already_exists","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; option_already_exists</p> <p>Inherits the following classes: cxxopts::exceptions::specification</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/#public-functions","title":"Public Functions","text":"Type Name option_already_exists (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1option__already__exists/#function-option_already_exists","title":"function option_already_exists","text":"<pre><code>inline explicit cxxopts::exceptions::option_already_exists::option_already_exists (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/","title":"Class cxxopts::exceptions::option_has_no_value","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; option_has_no_value</p> <p>Inherits the following classes: cxxopts::exceptions::exception</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/#public-functions","title":"Public Functions","text":"Type Name option_has_no_value (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1option__has__no__value/#function-option_has_no_value","title":"function option_has_no_value","text":"<pre><code>inline explicit cxxopts::exceptions::option_has_no_value::option_has_no_value (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/","title":"Class cxxopts::exceptions::option_requires_argument","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; option_requires_argument</p> <p>Inherits the following classes: cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/#public-functions","title":"Public Functions","text":"Type Name option_requires_argument (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1option__requires__argument/#function-option_requires_argument","title":"function option_requires_argument","text":"<pre><code>inline explicit cxxopts::exceptions::option_requires_argument::option_requires_argument (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/","title":"Class cxxopts::exceptions::parsing","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; parsing</p> <p>Inherits the following classes: cxxopts::exceptions::exception</p> <p>Inherited by the following classes: cxxopts::exceptions::gratuitous_argument_for_option,  cxxopts::exceptions::incorrect_argument_type,  cxxopts::exceptions::invalid_option_syntax,  cxxopts::exceptions::missing_argument,  cxxopts::exceptions::no_such_option,  cxxopts::exceptions::option_requires_argument,  cxxopts::exceptions::requested_option_not_present</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/#public-functions","title":"Public Functions","text":"Type Name parsing (const std::string &amp; message)"},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1parsing/#function-parsing","title":"function parsing","text":"<pre><code>inline explicit cxxopts::exceptions::parsing::parsing (\n    const std::string &amp; message\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/","title":"Class cxxopts::exceptions::requested_option_not_present","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; requested_option_not_present</p> <p>Inherits the following classes: cxxopts::exceptions::parsing</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/#public-functions","title":"Public Functions","text":"Type Name requested_option_not_present (const std::string &amp; option)"},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1requested__option__not__present/#function-requested_option_not_present","title":"function requested_option_not_present","text":"<pre><code>inline explicit cxxopts::exceptions::requested_option_not_present::requested_option_not_present (\n    const std::string &amp; option\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1exceptions_1_1specification/","title":"Class cxxopts::exceptions::specification","text":"<p>ClassList &gt; cxxopts &gt; exceptions &gt; specification</p> <p>Inherits the following classes: cxxopts::exceptions::exception</p> <p>Inherited by the following classes: cxxopts::exceptions::invalid_option_format,  cxxopts::exceptions::option_already_exists</p>"},{"location":"api/classcxxopts_1_1exceptions_1_1specification/#public-functions","title":"Public Functions","text":"Type Name specification (const std::string &amp; message)"},{"location":"api/classcxxopts_1_1exceptions_1_1specification/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1exceptions_1_1specification/#function-specification","title":"function specification","text":"<pre><code>inline explicit cxxopts::exceptions::specification::specification (\n    const std::string &amp; message\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/","title":"Class cxxopts::values::abstract_value","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; abstract_value</p> <p>Inherits the following classes: cxxopts::Value</p> <p>Inherited by the following classes: cxxopts::values::standard_value,  cxxopts::values::standard_value&lt; bool &gt;</p>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#public-functions","title":"Public Functions","text":"Type Name abstract_value ()  abstract_value (T * t)  abstract_value (const abstract_value &amp; rhs)  std::shared_ptr&lt; Value &gt; default_value (const std::string &amp; value) override const T &amp; get () const std::string get_default_value () override const std::string get_implicit_value () override const bool has_default () override const bool has_implicit () override const std::shared_ptr&lt; Value &gt; implicit_value (const std::string &amp; value) override bool is_boolean () override const bool is_container () override const std::shared_ptr&lt; Value &gt; no_implicit_value () override abstract_value &amp; operator= (const abstract_value &amp;) = default void parse (const std::string &amp; text) override const void parse () override const ~abstract_value () override"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#protected-attributes","title":"Protected Attributes","text":"Type Name bool m_default   = <code>false</code> std::string m_default_value   = <code>{}</code> bool m_implicit   = <code>false</code> std::string m_implicit_value   = <code>{}</code> std::shared_ptr&lt; T &gt; m_result   = <code>{}</code> T * m_store   = <code>{}</code>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-13","title":"function abstract_value [1/3]","text":"<pre><code>inline cxxopts::values::abstract_value::abstract_value () \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-23","title":"function abstract_value [2/3]","text":"<pre><code>inline explicit cxxopts::values::abstract_value::abstract_value (\n    T * t\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value-33","title":"function abstract_value [3/3]","text":"<pre><code>inline cxxopts::values::abstract_value::abstract_value (\n    const abstract_value &amp; rhs\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-default_value","title":"function default_value","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::default_value (\n    const std::string &amp; value\n) override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get","title":"function get","text":"<pre><code>inline const T &amp; cxxopts::values::abstract_value::get () const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get_default_value","title":"function get_default_value","text":"<pre><code>inline std::string cxxopts::values::abstract_value::get_default_value () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-get_implicit_value","title":"function get_implicit_value","text":"<pre><code>inline std::string cxxopts::values::abstract_value::get_implicit_value () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-has_default","title":"function has_default","text":"<pre><code>inline bool cxxopts::values::abstract_value::has_default () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-has_implicit","title":"function has_implicit","text":"<pre><code>inline bool cxxopts::values::abstract_value::has_implicit () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-implicit_value","title":"function implicit_value","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::implicit_value (\n    const std::string &amp; value\n) override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-is_boolean","title":"function is_boolean","text":"<pre><code>inline bool cxxopts::values::abstract_value::is_boolean () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-is_container","title":"function is_container","text":"<pre><code>inline bool cxxopts::values::abstract_value::is_container () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-no_implicit_value","title":"function no_implicit_value","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::abstract_value::no_implicit_value () override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-operator","title":"function operator=","text":"<pre><code>abstract_value &amp; cxxopts::values::abstract_value::operator= (\n    const abstract_value &amp;\n) = default\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-parse-12","title":"function parse [1/2]","text":"<pre><code>inline void cxxopts::values::abstract_value::parse (\n    const std::string &amp; text\n) override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-parse-22","title":"function parse [2/2]","text":"<pre><code>inline void cxxopts::values::abstract_value::parse () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#function-abstract_value","title":"function ~abstract_value","text":"<pre><code>cxxopts::values::abstract_value::~abstract_value () override\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_default","title":"variable m_default","text":"<pre><code>bool cxxopts::values::abstract_value&lt; T &gt;::m_default;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_default_value","title":"variable m_default_value","text":"<pre><code>std::string cxxopts::values::abstract_value&lt; T &gt;::m_default_value;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_implicit","title":"variable m_implicit","text":"<pre><code>bool cxxopts::values::abstract_value&lt; T &gt;::m_implicit;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_implicit_value","title":"variable m_implicit_value","text":"<pre><code>std::string cxxopts::values::abstract_value&lt; T &gt;::m_implicit_value;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_result","title":"variable m_result","text":"<pre><code>std::shared_ptr&lt;T&gt; cxxopts::values::abstract_value&lt; T &gt;::m_result;\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1abstract__value/#variable-m_store","title":"variable m_store","text":"<pre><code>T* cxxopts::values::abstract_value&lt; T &gt;::m_store;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value/","title":"Class cxxopts::values::standard_value","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; standard_value</p> <p>Inherits the following classes: cxxopts::values::abstract_value&lt; T &gt;</p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value/#public-functions","title":"Public Functions","text":"Type Name CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; clone () override const"},{"location":"api/classcxxopts_1_1values_1_1standard__value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1standard__value/#function-clone","title":"function clone","text":"<pre><code>inline CXXOPTS_NODISCARD std::shared_ptr&lt; Value &gt; cxxopts::values::standard_value::clone () override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/","title":"Class cxxopts::values::standard_value&lt; bool &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; standard_value&lt; bool &gt;</p> <p>Inherits the following classes: cxxopts::values::abstract_value&lt; bool &gt;</p>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#public-functions","title":"Public Functions","text":"Type Name std::shared_ptr&lt; Value &gt; clone () override const standard_value ()  standard_value (bool * b)  ~standard_value () override"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-clone","title":"function clone","text":"<pre><code>inline std::shared_ptr&lt; Value &gt; cxxopts::values::standard_value&lt; bool &gt;::clone () override const\n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-12","title":"function standard_value [1/2]","text":"<pre><code>inline cxxopts::values::standard_value&lt; bool &gt;::standard_value () \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value-22","title":"function standard_value [2/2]","text":"<pre><code>inline explicit cxxopts::values::standard_value&lt; bool &gt;::standard_value (\n    bool * b\n) \n</code></pre>"},{"location":"api/classcxxopts_1_1values_1_1standard__value_3_01bool_01_4/#function-standard_value","title":"function ~standard_value","text":"<pre><code>cxxopts::values::standard_value&lt; bool &gt;::~standard_value () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/classruntime__impl/","title":"Class runtime_impl","text":"<p>ClassList &gt; runtime_impl</p> <p>Inherits the following classes: runtime</p>"},{"location":"api/classruntime__impl/#public-functions","title":"Public Functions","text":"Type Name void load_plugin_factory (plugin_factory plugin_main) override void load_so (const std::vector&lt; std::string &gt; &amp; so_paths) override void load_so (const std::string_view &amp; so) override runtime_impl ()  void stop () override void wait () override ~runtime_impl () override"},{"location":"api/classruntime__impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classruntime__impl/#function-load_plugin_factory","title":"function load_plugin_factory","text":"<pre><code>inline void runtime_impl::load_plugin_factory (\n    plugin_factory plugin_main\n) override\n</code></pre>"},{"location":"api/classruntime__impl/#function-load_so-12","title":"function load_so [1/2]","text":"<pre><code>inline void runtime_impl::load_so (\n    const std::vector&lt; std::string &gt; &amp; so_paths\n) override\n</code></pre>"},{"location":"api/classruntime__impl/#function-load_so-22","title":"function load_so [2/2]","text":"<pre><code>inline void runtime_impl::load_so (\n    const std::string_view &amp; so\n) override\n</code></pre>"},{"location":"api/classruntime__impl/#function-runtime_impl","title":"function runtime_impl","text":"<pre><code>inline explicit runtime_impl::runtime_impl () \n</code></pre>"},{"location":"api/classruntime__impl/#function-stop","title":"function stop","text":"<pre><code>inline void runtime_impl::stop () override\n</code></pre>"},{"location":"api/classruntime__impl/#function-wait","title":"function wait","text":"<pre><code>inline void runtime_impl::wait () override\n</code></pre>"},{"location":"api/classruntime__impl/#function-runtime_impl_1","title":"function ~runtime_impl","text":"<pre><code>inline runtime_impl::~runtime_impl () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/runtime_impl.cpp</code></p>"},{"location":"api/cxxopts_8hpp/","title":"File cxxopts.hpp","text":"<p>FileList &gt; src &gt; cxxopts.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;locale&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> </ul>"},{"location":"api/cxxopts_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cxxopts namespace exceptions namespace values namespace detail namespace parser_tool"},{"location":"api/cxxopts_8hpp/#classes","title":"Classes","text":"Type Name struct HelpGroupDetails struct HelpOptionDetails class KeyValue struct Option class OptionAdder class OptionDetails class OptionParser class OptionValue class Options class ParseResult class Iterator class Value class exception class gratuitous_argument_for_option class incorrect_argument_type class invalid_option_format class invalid_option_syntax class missing_argument class no_such_option class option_already_exists class option_has_no_value class option_requires_argument class parsing class requested_option_not_present class specification class abstract_value &lt;typename T&gt; struct SignedCheck&lt; T, false &gt; &lt;typename T&gt; struct SignedCheck&lt; T, true &gt; &lt;typename T&gt; struct ArguDesc struct IntegerDesc class standard_value &lt;typename T&gt; class standard_value&lt; bool &gt; &lt;&gt; struct type_is_container &lt;typename T&gt; struct type_is_container&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"api/cxxopts_8hpp/#macros","title":"Macros","text":"Type Name define CXXOPTS_DIAGNOSTIC_POP define CXXOPTS_DIAGNOSTIC_PUSH define CXXOPTS_IGNORE_WARNING (x)  define CXXOPTS_LINKONCE define CXXOPTS_LINKONCE_CONST define CXXOPTS_NODISCARD define CXXOPTS_RTTI_CAST <code>dynamic\\_cast</code> define CXXOPTS_VECTOR_DELIMITER <code>','</code> define CXXOPTS__VERSION_MAJOR <code>3</code> define CXXOPTS__VERSION_MINOR <code>1</code> define CXXOPTS__VERSION_PATCH <code>1</code>"},{"location":"api/cxxopts_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/cxxopts_8hpp/#define-cxxopts_diagnostic_pop","title":"define CXXOPTS_DIAGNOSTIC_POP","text":"<pre><code>#define CXXOPTS_DIAGNOSTIC_POP \n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts_diagnostic_push","title":"define CXXOPTS_DIAGNOSTIC_PUSH","text":"<pre><code>#define CXXOPTS_DIAGNOSTIC_PUSH \n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts_ignore_warning","title":"define CXXOPTS_IGNORE_WARNING","text":"<pre><code>#define CXXOPTS_IGNORE_WARNING (\n    x\n) \n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts_linkonce","title":"define CXXOPTS_LINKONCE","text":"<pre><code>#define CXXOPTS_LINKONCE \n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts_linkonce_const","title":"define CXXOPTS_LINKONCE_CONST","text":"<pre><code>#define CXXOPTS_LINKONCE_CONST \n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts_nodiscard","title":"define CXXOPTS_NODISCARD","text":"<pre><code>#define CXXOPTS_NODISCARD \n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts_rtti_cast","title":"define CXXOPTS_RTTI_CAST","text":"<pre><code>#define CXXOPTS_RTTI_CAST `dynamic_cast`\n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts_vector_delimiter","title":"define CXXOPTS_VECTOR_DELIMITER","text":"<pre><code>#define CXXOPTS_VECTOR_DELIMITER `','`\n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts__version_major","title":"define CXXOPTS__VERSION_MAJOR","text":"<pre><code>#define CXXOPTS__VERSION_MAJOR `3`\n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts__version_minor","title":"define CXXOPTS__VERSION_MINOR","text":"<pre><code>#define CXXOPTS__VERSION_MINOR `1`\n</code></pre>"},{"location":"api/cxxopts_8hpp/#define-cxxopts__version_patch","title":"define CXXOPTS__VERSION_PATCH","text":"<pre><code>#define CXXOPTS__VERSION_PATCH `1`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/cxxopts_8hpp_source/","title":"File cxxopts.hpp","text":"<p>File List &gt; src &gt; cxxopts.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n\nCopyright (c) 2014-2022 Jarryd Beck\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// vim: ts=2:sw=2:expandtab\n\n#ifndef CXXOPTS_HPP_INCLUDED\n#define CXXOPTS_HPP_INCLUDED\n\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n#include &lt;exception&gt;\n#include &lt;initializer_list&gt;\n#include &lt;limits&gt;\n#include &lt;locale&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#ifdef CXXOPTS_NO_EXCEPTIONS\n    #include &lt;iostream&gt;\n#endif\n\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n    #if (__GNUC__ * 10 + __GNUC_MINOR__) &lt; 49\n        #define CXXOPTS_NO_REGEX true\n    #endif\n#endif\n#if defined(_MSC_VER) &amp;&amp; !defined(__clang__)\n    #define CXXOPTS_LINKONCE_CONST __declspec(selectany) extern\n    #define CXXOPTS_LINKONCE       __declspec(selectany) extern\n#else\n    #define CXXOPTS_LINKONCE_CONST\n    #define CXXOPTS_LINKONCE\n#endif\n\n#ifndef CXXOPTS_NO_REGEX\n    #include &lt;regex&gt;\n#endif // CXXOPTS_NO_REGEX\n\n// Nonstandard before C++17, which is coincidentally what we also need for &lt;optional&gt;\n#ifdef __has_include\n    #if __has_include(&lt;optional&gt;)\n        #include &lt;optional&gt;\n        #ifdef __cpp_lib_optional\n            #define CXXOPTS_HAS_OPTIONAL\n        #endif\n    #endif\n#endif\n\n#if __cplusplus &gt;= 201603L\n    #define CXXOPTS_NODISCARD [[nodiscard]]\n#else\n    #define CXXOPTS_NODISCARD\n#endif\n\n#ifndef CXXOPTS_VECTOR_DELIMITER\n    #define CXXOPTS_VECTOR_DELIMITER ','\n#endif\n\n#define CXXOPTS__VERSION_MAJOR 3\n#define CXXOPTS__VERSION_MINOR 1\n#define CXXOPTS__VERSION_PATCH 1\n\n#if (__GNUC__ &lt; 10 || (__GNUC__ == 10 &amp;&amp; __GNUC_MINOR__ &lt; 1)) &amp;&amp; __GNUC__ &gt;= 6\n    #define CXXOPTS_NULL_DEREF_IGNORE\n#endif\n\n#if defined(__GNUC__)\n    #define DO_PRAGMA(x)              _Pragma(#x)\n    #define CXXOPTS_DIAGNOSTIC_PUSH   DO_PRAGMA(GCC diagnostic push)\n    #define CXXOPTS_DIAGNOSTIC_POP    DO_PRAGMA(GCC diagnostic pop)\n    #define CXXOPTS_IGNORE_WARNING(x) DO_PRAGMA(GCC diagnostic ignored x)\n#else\n    // define other compilers here if needed\n    #define CXXOPTS_DIAGNOSTIC_PUSH\n    #define CXXOPTS_DIAGNOSTIC_POP\n    #define CXXOPTS_IGNORE_WARNING(x)\n#endif\n\n#ifdef CXXOPTS_NO_RTTI\n    #define CXXOPTS_RTTI_CAST static_cast\n#else\n    #define CXXOPTS_RTTI_CAST dynamic_cast\n#endif\n\nnamespace cxxopts {\nstatic constexpr struct {\n    uint8_t major, minor, patch;\n} version = {CXXOPTS__VERSION_MAJOR, CXXOPTS__VERSION_MINOR, CXXOPTS__VERSION_PATCH};\n} // namespace cxxopts\n\n// when we ask cxxopts to use Unicode, help strings are processed using ICU,\n// which results in the correct lengths being computed for strings when they\n// are formatted for the help output\n// it is necessary to make sure that &lt;unicode/unistr.h&gt; can be found by the\n// compiler, and that icu-uc is linked in to the binary.\n\n#ifdef CXXOPTS_USE_UNICODE\n    #include &lt;unicode/unistr.h&gt;\n\nnamespace cxxopts {\n\nusing String = icu::UnicodeString;\n\ninline String toLocalString(std::string s) {\n    return icu::UnicodeString::fromUTF8(std::move(s));\n}\n\n// GNU GCC with -Weffc++ will issue a warning regarding the upcoming class, we want to silence it:\n// warning: base class 'class std::enable_shared_from_this&lt;cxxopts::Value&gt;' has accessible non-virtual destructor\nCXXOPTS_DIAGNOSTIC_PUSH\nCXXOPTS_IGNORE_WARNING(\"-Wnon-virtual-dtor\")\n\n// This will be ignored under other compilers like LLVM clang.\nclass UnicodeStringIterator {\npublic:\n    using iterator_category = std::forward_iterator_tag;\n    using value_type        = int32_t;\n    using difference_type   = std::ptrdiff_t;\n    using pointer           = value_type*;\n    using reference         = value_type&amp;;\n\n    UnicodeStringIterator(const icu::UnicodeString* string, int32_t pos)\n        : s(string)\n        , i(pos) { }\n\n    value_type operator*() const {\n        return s-&gt;char32At(i);\n    }\n\n    bool operator==(const UnicodeStringIterator&amp; rhs) const {\n        return s == rhs.s &amp;&amp; i == rhs.i;\n    }\n\n    bool operator!=(const UnicodeStringIterator&amp; rhs) const {\n        return !(*this == rhs);\n    }\n\n    UnicodeStringIterator&amp; operator++() {\n        ++i;\n        return *this;\n    }\n\n    UnicodeStringIterator operator+(int32_t v) {\n        return UnicodeStringIterator(s, i + v);\n    }\n\nprivate:\n    const icu::UnicodeString* s;\n    int32_t                   i;\n};\n\nCXXOPTS_DIAGNOSTIC_POP\n\ninline String&amp; stringAppend(String&amp; s, String a) {\n    return s.append(std::move(a));\n}\n\ninline String&amp; stringAppend(String&amp; s, std::size_t n, UChar32 c) {\n    for (std::size_t i = 0; i != n; ++i) {\n        s.append(c);\n    }\n\n    return s;\n}\n\ntemplate&lt;typename Iterator&gt;\nString&amp; stringAppend(String&amp; s, Iterator begin, Iterator end) {\n    while (begin != end) {\n        s.append(*begin);\n        ++begin;\n    }\n\n    return s;\n}\n\ninline size_t stringLength(const String&amp; s) {\n    return static_cast&lt;size_t&gt;(s.length());\n}\n\ninline std::string toUTF8String(const String&amp; s) {\n    std::string result;\n    s.toUTF8String(result);\n\n    return result;\n}\n\ninline bool empty(const String&amp; s) {\n    return s.isEmpty();\n}\n\n} // namespace cxxopts\n\nnamespace std {\n\ninline cxxopts::UnicodeStringIterator begin(const icu::UnicodeString&amp; s) {\n    return cxxopts::UnicodeStringIterator(&amp;s, 0);\n}\n\ninline cxxopts::UnicodeStringIterator end(const icu::UnicodeString&amp; s) {\n    return cxxopts::UnicodeStringIterator(&amp;s, s.length());\n}\n\n} // namespace std\n\n// ifdef CXXOPTS_USE_UNICODE\n#else\n\nnamespace cxxopts {\n\nusing String = std::string;\n\ntemplate&lt;typename T&gt;\nT toLocalString(T&amp;&amp; t) {\n    return std::forward&lt;T&gt;(t);\n}\n\ninline std::size_t stringLength(const String&amp; s) {\n    return s.length();\n}\n\ninline String&amp; stringAppend(String&amp; s, const String&amp; a) {\n    return s.append(a);\n}\n\ninline String&amp; stringAppend(String&amp; s, std::size_t n, char c) {\n    return s.append(n, c);\n}\n\ntemplate&lt;typename Iterator&gt;\nString&amp; stringAppend(String&amp; s, Iterator begin, Iterator end) {\n    return s.append(begin, end);\n}\n\ntemplate&lt;typename T&gt;\nstd::string toUTF8String(T&amp;&amp; t) {\n    return std::forward&lt;T&gt;(t);\n}\n\ninline bool empty(const std::string&amp; s) {\n    return s.empty();\n}\n\n} // namespace cxxopts\n\n// ifdef CXXOPTS_USE_UNICODE\n#endif\n\nnamespace cxxopts {\n\nnamespace {\n    CXXOPTS_LINKONCE_CONST std::string LQUOTE(\"\\'\");\n    CXXOPTS_LINKONCE_CONST std::string RQUOTE(\"\\'\");\n} // namespace\n\n// GNU GCC with -Weffc++ will issue a warning regarding the upcoming class, we\n// want to silence it: warning: base class 'class\n// std::enable_shared_from_this&lt;cxxopts::Value&gt;' has accessible non-virtual\n// destructor This will be ignored under other compilers like LLVM clang.\nCXXOPTS_DIAGNOSTIC_PUSH\nCXXOPTS_IGNORE_WARNING(\"-Wnon-virtual-dtor\")\n\n// some older versions of GCC warn under this warning\nCXXOPTS_IGNORE_WARNING(\"-Weffc++\")\n\nclass Value : public std::enable_shared_from_this&lt;Value&gt; {\npublic:\n    virtual ~Value() = default;\n\n    virtual std::shared_ptr&lt;Value&gt; clone() const = 0;\n\n    virtual void parse(const std::string&amp; text) const = 0;\n\n    virtual void parse() const = 0;\n\n    virtual bool has_default() const = 0;\n\n    virtual bool is_container() const = 0;\n\n    virtual bool has_implicit() const = 0;\n\n    virtual std::string get_default_value() const = 0;\n\n    virtual std::string get_implicit_value() const = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; default_value(const std::string&amp; value) = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; implicit_value(const std::string&amp; value) = 0;\n\n    virtual std::shared_ptr&lt;Value&gt; no_implicit_value() = 0;\n\n    virtual bool is_boolean() const = 0;\n};\n\nCXXOPTS_DIAGNOSTIC_POP\n\nnamespace exceptions {\n\n    class exception : public std::exception {\n    public:\n        explicit exception(std::string message)\n            : m_message(std::move(message)) { }\n\n        CXXOPTS_NODISCARD\n        const char* what() const noexcept override {\n            return m_message.c_str();\n        }\n\n    private:\n        std::string m_message;\n    };\n\n    class specification : public exception {\n    public:\n        explicit specification(const std::string&amp; message)\n            : exception(message) { }\n    };\n\n    class parsing : public exception {\n    public:\n        explicit parsing(const std::string&amp; message)\n            : exception(message) { }\n    };\n\n    class option_already_exists : public specification {\n    public:\n        explicit option_already_exists(const std::string&amp; option)\n            : specification(\"Option \" + LQUOTE + option + RQUOTE + \" already exists\") { }\n    };\n\n    class invalid_option_format : public specification {\n    public:\n        explicit invalid_option_format(const std::string&amp; format)\n            : specification(\"Invalid option format \" + LQUOTE + format + RQUOTE) { }\n    };\n\n    class invalid_option_syntax : public parsing {\n    public:\n        explicit invalid_option_syntax(const std::string&amp; text)\n            : parsing(\"Argument \" + LQUOTE + text + RQUOTE + \" starts with a - but has incorrect syntax\") { }\n    };\n\n    class no_such_option : public parsing {\n    public:\n        explicit no_such_option(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" does not exist\") { }\n    };\n\n    class missing_argument : public parsing {\n    public:\n        explicit missing_argument(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" is missing an argument\") { }\n    };\n\n    class option_requires_argument : public parsing {\n    public:\n        explicit option_requires_argument(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" requires an argument\") { }\n    };\n\n    class gratuitous_argument_for_option : public parsing {\n    public:\n        gratuitous_argument_for_option(const std::string&amp; option, const std::string&amp; arg)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" does not take an argument, but argument \" + LQUOTE + arg +\n                      RQUOTE + \" given\") { }\n    };\n\n    class requested_option_not_present : public parsing {\n    public:\n        explicit requested_option_not_present(const std::string&amp; option)\n            : parsing(\"Option \" + LQUOTE + option + RQUOTE + \" not present\") { }\n    };\n\n    class option_has_no_value : public exception {\n    public:\n        explicit option_has_no_value(const std::string&amp; option)\n            : exception(!option.empty() ? (\"Option \" + LQUOTE + option + RQUOTE + \" has no value\") : \"Option has no value\") { }\n    };\n\n    class incorrect_argument_type : public parsing {\n    public:\n        explicit incorrect_argument_type(const std::string&amp; arg)\n            : parsing(\"Argument \" + LQUOTE + arg + RQUOTE + \" failed to parse\") { }\n    };\n\n} // namespace exceptions\n\ntemplate&lt;typename T&gt;\nvoid throw_or_mimic(const std::string&amp; text) {\n    static_assert(std::is_base_of&lt;std::exception, T&gt;::value,\n                  \"throw_or_mimic only works on std::exception and \"\n                  \"deriving classes\");\n\n#ifndef CXXOPTS_NO_EXCEPTIONS\n    // If CXXOPTS_NO_EXCEPTIONS is not defined, just throw\n    throw T{text};\n#else\n    // Otherwise manually instantiate the exception, print what() to stderr,\n    // and exit\n    T exception{text};\n    std::cerr &lt;&lt; exception.what() &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n#endif\n}\n\nusing OptionNames = std::vector&lt;std::string&gt;;\n\nnamespace values {\n\n    namespace parser_tool {\n\n        struct IntegerDesc {\n            std::string negative = \"\";\n            std::string base     = \"\";\n            std::string value    = \"\";\n        };\n\n        struct ArguDesc {\n            std::string arg_name  = \"\";\n            bool        grouping  = false;\n            bool        set_value = false;\n            std::string value     = \"\";\n        };\n\n#ifdef CXXOPTS_NO_REGEX\n        inline IntegerDesc SplitInteger(const std::string&amp; text) {\n            if (text.empty()) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n            IntegerDesc desc;\n            const char* pdata = text.c_str();\n            if (*pdata == '-') {\n                pdata += 1;\n                desc.negative = \"-\";\n            }\n            if (strncmp(pdata, \"0x\", 2) == 0) {\n                pdata += 2;\n                desc.base = \"0x\";\n            }\n            if (*pdata != '\\0') {\n                desc.value = std::string(pdata);\n            } else {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n            return desc;\n        }\n\n        inline bool IsTrueText(const std::string&amp; text) {\n            const char* pdata = text.c_str();\n            if (*pdata == 't' || *pdata == 'T') {\n                pdata += 1;\n                if (strncmp(pdata, \"rue\\0\", 4) == 0) {\n                    return true;\n                }\n            } else if (strncmp(pdata, \"1\\0\", 2) == 0) {\n                return true;\n            }\n            return false;\n        }\n\n        inline bool IsFalseText(const std::string&amp; text) {\n            const char* pdata = text.c_str();\n            if (*pdata == 'f' || *pdata == 'F') {\n                pdata += 1;\n                if (strncmp(pdata, \"alse\\0\", 5) == 0) {\n                    return true;\n                }\n            } else if (strncmp(pdata, \"0\\0\", 2) == 0) {\n                return true;\n            }\n            return false;\n        }\n\n        inline OptionNames split_option_names(const std::string&amp; text) {\n            OptionNames split_names;\n\n            std::string::size_type token_start_pos = 0;\n            auto                   length          = text.length();\n\n            if (length == 0) {\n                throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n            }\n\n            while (token_start_pos &lt; length) {\n                const auto&amp; npos               = std::string::npos;\n                auto        next_non_space_pos = text.find_first_not_of(' ', token_start_pos);\n                if (next_non_space_pos == npos) {\n                    throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                }\n                token_start_pos         = next_non_space_pos;\n                auto next_delimiter_pos = text.find(',', token_start_pos);\n                if (next_delimiter_pos == token_start_pos) {\n                    throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                }\n                if (next_delimiter_pos == npos) {\n                    next_delimiter_pos = length;\n                }\n                auto token_length = next_delimiter_pos - token_start_pos;\n                // validate the token itself matches the regex /([:alnum:][-_[:alnum:]]*/\n                {\n                    const char* option_name_valid_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                                                          \"abcdefghijklmnopqrstuvwxyz\"\n                                                          \"0123456789\"\n                                                          \"_-.?\";\n\n                    if (!std::isalnum(text[token_start_pos], std::locale::classic()) ||\n                        text.find_first_not_of(option_name_valid_chars, token_start_pos) &lt; next_delimiter_pos) {\n                        throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n                    }\n                }\n                split_names.emplace_back(text.substr(token_start_pos, token_length));\n                token_start_pos = next_delimiter_pos + 1;\n            }\n            return split_names;\n        }\n\n        inline ArguDesc ParseArgument(const char* arg, bool&amp; matched) {\n            ArguDesc    argu_desc;\n            const char* pdata = arg;\n            matched           = false;\n            if (strncmp(pdata, \"--\", 2) == 0) {\n                pdata += 2;\n                if (isalnum(*pdata, std::locale::classic())) {\n                    argu_desc.arg_name.push_back(*pdata);\n                    pdata += 1;\n                    while (isalnum(*pdata, std::locale::classic()) || *pdata == '-' || *pdata == '_') {\n                        argu_desc.arg_name.push_back(*pdata);\n                        pdata += 1;\n                    }\n                    if (argu_desc.arg_name.length() &gt; 1) {\n                        if (*pdata == '=') {\n                            argu_desc.set_value = true;\n                            pdata += 1;\n                            if (*pdata != '\\0') {\n                                argu_desc.value = std::string(pdata);\n                            }\n                            matched = true;\n                        } else if (*pdata == '\\0') {\n                            matched = true;\n                        }\n                    }\n                }\n            } else if (strncmp(pdata, \"-\", 1) == 0) {\n                pdata += 1;\n                argu_desc.grouping = true;\n                while (isalnum(*pdata, std::locale::classic())) {\n                    argu_desc.arg_name.push_back(*pdata);\n                    pdata += 1;\n                }\n                matched = !argu_desc.arg_name.empty() &amp;&amp; *pdata == '\\0';\n            }\n            return argu_desc;\n        }\n\n#else // CXXOPTS_NO_REGEX\n\n        namespace {\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; integer_pattern(\"(-)?(0x)?([0-9a-zA-Z]+)|((0x)?0)\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; truthy_pattern(\"(t|T)(rue)?|1\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; falsy_pattern(\"(f|F)(alse)?|0\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_matcher(\"--([[:alnum:]][-_[:alnum:]\\\\.]+)(=(.*))?|-([[:alnum:]].*)\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_specifier(\"([[:alnum:]][-_[:alnum:]\\\\.]*)(,[ ]*[[:alnum:]][-_[:alnum:]]*)*\");\n            CXXOPTS_LINKONCE\n            std::basic_regex&lt;char&gt; option_specifier_separator(\", *\");\n\n        } // namespace\n\n        inline IntegerDesc SplitInteger(const std::string&amp; text) {\n            std::smatch match;\n            std::regex_match(text, match, integer_pattern);\n\n            if (match.length() == 0) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            IntegerDesc desc;\n            desc.negative = match[1];\n            desc.base = match[2];\n            desc.value = match[3];\n\n            if (match.length(4) &gt; 0) {\n                desc.base = match[5];\n                desc.value = \"0\";\n                return desc;\n            }\n\n            return desc;\n        }\n\n        inline bool IsTrueText(const std::string&amp; text) {\n            std::smatch result;\n            std::regex_match(text, result, truthy_pattern);\n            return !result.empty();\n        }\n\n        inline bool IsFalseText(const std::string&amp; text) {\n            std::smatch result;\n            std::regex_match(text, result, falsy_pattern);\n            return !result.empty();\n        }\n\n        // Gets the option names specified via a single, comma-separated string,\n        // and returns the separate, space-discarded, non-empty names\n        // (without considering which or how many are single-character)\n        inline OptionNames split_option_names(const std::string&amp; text) {\n            if (!std::regex_match(text.c_str(), option_specifier)) {\n                throw_or_mimic&lt;exceptions::invalid_option_format&gt;(text);\n            }\n\n            OptionNames split_names;\n\n            constexpr int use_non_matches{-1};\n            auto token_iterator =\n                std::sregex_token_iterator(text.begin(), text.end(), option_specifier_separator, use_non_matches);\n            std::copy(token_iterator, std::sregex_token_iterator(), std::back_inserter(split_names));\n            return split_names;\n        }\n\n        inline ArguDesc ParseArgument(const char* arg, bool&amp; matched) {\n            std::match_results&lt;const char*&gt; result;\n            std::regex_match(arg, result, option_matcher);\n            matched = !result.empty();\n\n            ArguDesc argu_desc;\n            if (matched) {\n                argu_desc.arg_name = result[1].str();\n                argu_desc.set_value = result[2].length() &gt; 0;\n                argu_desc.value = result[3].str();\n                if (result[4].length() &gt; 0) {\n                    argu_desc.grouping = true;\n                    argu_desc.arg_name = result[4].str();\n                }\n            }\n\n            return argu_desc;\n        }\n\n#endif // CXXOPTS_NO_REGEX\n#undef CXXOPTS_NO_REGEX\n    } // namespace parser_tool\n\n    namespace detail {\n\n        template&lt;typename T, bool B&gt;\n        struct SignedCheck;\n\n        template&lt;typename T&gt;\n        struct SignedCheck&lt;T, true&gt; {\n            template&lt;typename U&gt;\n            void operator()(bool negative, U u, const std::string&amp; text) {\n                if (negative) {\n                    if (u &gt; static_cast&lt;U&gt;((std::numeric_limits&lt;T&gt;::min)())) {\n                        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n                    }\n                } else {\n                    if (u &gt; static_cast&lt;U&gt;((std::numeric_limits&lt;T&gt;::max)())) {\n                        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n                    }\n                }\n            }\n        };\n\n        template&lt;typename T&gt;\n        struct SignedCheck&lt;T, false&gt; {\n            template&lt;typename U&gt;\n            void operator()(bool, U, const std::string&amp;) const { }\n        };\n\n        template&lt;typename T, typename U&gt;\n        void check_signed_range(bool negative, U value, const std::string&amp; text) {\n            SignedCheck&lt;T, std::numeric_limits&lt;T&gt;::is_signed&gt;()(negative, value, text);\n        }\n\n    } // namespace detail\n\n    template&lt;typename R, typename T&gt;\n    void checked_negate(R&amp; r, T&amp;&amp; t, const std::string&amp;, std::true_type) {\n        // if we got to here, then `t` is a positive number that fits into\n        // `R`. So to avoid MSVC C4146, we first cast it to `R`.\n        // See https://github.com/jarro2783/cxxopts/issues/62 for more details.\n        r = static_cast&lt;R&gt;(-static_cast&lt;R&gt;(t - 1) - 1);\n    }\n\n    template&lt;typename R, typename T&gt;\n    void checked_negate(R&amp;, T&amp;&amp;, const std::string&amp; text, std::false_type) {\n        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n    }\n\n    template&lt;typename T&gt;\n    void integer_parser(const std::string&amp; text, T&amp; value) {\n        parser_tool::IntegerDesc int_desc = parser_tool::SplitInteger(text);\n\n        using US                 = typename std::make_unsigned&lt;T&gt;::type;\n        constexpr bool is_signed = std::numeric_limits&lt;T&gt;::is_signed;\n\n        const bool         negative    = int_desc.negative.length() &gt; 0;\n        const uint8_t      base        = int_desc.base.length() &gt; 0 ? 16 : 10;\n        const std::string&amp; value_match = int_desc.value;\n\n        US result = 0;\n\n        for (char ch : value_match) {\n            US digit = 0;\n\n            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {\n                digit = static_cast&lt;US&gt;(ch - '0');\n            } else if (base == 16 &amp;&amp; ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') {\n                digit = static_cast&lt;US&gt;(ch - 'a' + 10);\n            } else if (base == 16 &amp;&amp; ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') {\n                digit = static_cast&lt;US&gt;(ch - 'A' + 10);\n            } else {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            const US next = static_cast&lt;US&gt;(result * base + digit);\n            if (result &gt; next) {\n                throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n            }\n\n            result = next;\n        }\n\n        detail::check_signed_range&lt;T&gt;(negative, result, text);\n\n        if (negative) {\n            checked_negate&lt;T&gt;(value, result, text, std::integral_constant&lt;bool, is_signed&gt;());\n        } else {\n            value = static_cast&lt;T&gt;(result);\n        }\n    }\n\n    template&lt;typename T&gt;\n    void stringstream_parser(const std::string&amp; text, T&amp; value) {\n        std::stringstream in(text);\n        in &gt;&gt; value;\n        if (!in) {\n            throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n        }\n    }\n\n    template&lt;typename T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;\n    void parse_value(const std::string&amp; text, T&amp; value) {\n        integer_parser(text, value);\n    }\n\n    inline void parse_value(const std::string&amp; text, bool&amp; value) {\n        if (parser_tool::IsTrueText(text)) {\n            value = true;\n            return;\n        }\n\n        if (parser_tool::IsFalseText(text)) {\n            value = false;\n            return;\n        }\n\n        throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n    }\n\n    inline void parse_value(const std::string&amp; text, std::string&amp; value) {\n        value = text;\n    }\n\n    // The fallback parser. It uses the stringstream parser to parse all types\n    // that have not been overloaded explicitly.  It has to be placed in the\n    // source code before all other more specialized templates.\n    template&lt;typename T, typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type* = nullptr&gt;\n    void parse_value(const std::string&amp; text, T&amp; value) {\n        stringstream_parser(text, value);\n    }\n\n    template&lt;typename T&gt;\n    void parse_value(const std::string&amp; text, std::vector&lt;T&gt;&amp; value) {\n        if (text.empty()) {\n            T v;\n            parse_value(text, v);\n            value.emplace_back(std::move(v));\n            return;\n        }\n        std::stringstream in(text);\n        std::string       token;\n        while (!in.eof() &amp;&amp; std::getline(in, token, CXXOPTS_VECTOR_DELIMITER)) {\n            T v;\n            parse_value(token, v);\n            value.emplace_back(std::move(v));\n        }\n    }\n\n#ifdef CXXOPTS_HAS_OPTIONAL\n    template&lt;typename T&gt;\n    void parse_value(const std::string&amp; text, std::optional&lt;T&gt;&amp; value) {\n        T result;\n        parse_value(text, result);\n        value = std::move(result);\n    }\n#endif\n\n    inline void parse_value(const std::string&amp; text, char&amp; c) {\n        if (text.length() != 1) {\n            throw_or_mimic&lt;exceptions::incorrect_argument_type&gt;(text);\n        }\n\n        c = text[0];\n    }\n\n    template&lt;typename T&gt;\n    struct type_is_container {\n        static constexpr bool value = false;\n    };\n\n    template&lt;typename T&gt;\n    struct type_is_container&lt;std::vector&lt;T&gt;&gt; {\n        static constexpr bool value = true;\n    };\n\n    template&lt;typename T&gt;\n    class abstract_value : public Value {\n        using Self = abstract_value&lt;T&gt;;\n\n    public:\n        abstract_value()\n            : m_result(std::make_shared&lt;T&gt;())\n            , m_store(m_result.get()) { }\n\n        explicit abstract_value(T* t)\n            : m_store(t) { }\n\n        ~abstract_value() override = default;\n\n        abstract_value&amp; operator=(const abstract_value&amp;) = default;\n\n        abstract_value(const abstract_value&amp; rhs) {\n            if (rhs.m_result) {\n                m_result = std::make_shared&lt;T&gt;();\n                m_store  = m_result.get();\n            } else {\n                m_store = rhs.m_store;\n            }\n\n            m_default        = rhs.m_default;\n            m_implicit       = rhs.m_implicit;\n            m_default_value  = rhs.m_default_value;\n            m_implicit_value = rhs.m_implicit_value;\n        }\n\n        void parse(const std::string&amp; text) const override {\n            parse_value(text, *m_store);\n        }\n\n        bool is_container() const override {\n            return type_is_container&lt;T&gt;::value;\n        }\n\n        void parse() const override {\n            parse_value(m_default_value, *m_store);\n        }\n\n        bool has_default() const override {\n            return m_default;\n        }\n\n        bool has_implicit() const override {\n            return m_implicit;\n        }\n\n        std::shared_ptr&lt;Value&gt; default_value(const std::string&amp; value) override {\n            m_default       = true;\n            m_default_value = value;\n            return shared_from_this();\n        }\n\n        std::shared_ptr&lt;Value&gt; implicit_value(const std::string&amp; value) override {\n            m_implicit       = true;\n            m_implicit_value = value;\n            return shared_from_this();\n        }\n\n        std::shared_ptr&lt;Value&gt; no_implicit_value() override {\n            m_implicit = false;\n            return shared_from_this();\n        }\n\n        std::string get_default_value() const override {\n            return m_default_value;\n        }\n\n        std::string get_implicit_value() const override {\n            return m_implicit_value;\n        }\n\n        bool is_boolean() const override {\n            return std::is_same&lt;T, bool&gt;::value;\n        }\n\n        const T&amp; get() const {\n            if (m_store == nullptr) {\n                return *m_result;\n            }\n            return *m_store;\n        }\n\n    protected:\n        std::shared_ptr&lt;T&gt; m_result{};\n        T*                 m_store{};\n\n        bool m_default  = false;\n        bool m_implicit = false;\n\n        std::string m_default_value{};\n        std::string m_implicit_value{};\n    };\n\n    template&lt;typename T&gt;\n    class standard_value : public abstract_value&lt;T&gt; {\n    public:\n        using abstract_value&lt;T&gt;::abstract_value;\n\n        CXXOPTS_NODISCARD\n        std::shared_ptr&lt;Value&gt; clone() const override {\n            return std::make_shared&lt;standard_value&lt;T&gt;&gt;(*this);\n        }\n    };\n\n    template&lt;&gt;\n    class standard_value&lt;bool&gt; : public abstract_value&lt;bool&gt; {\n    public:\n        ~standard_value() override = default;\n\n        standard_value() {\n            set_default_and_implicit();\n        }\n\n        explicit standard_value(bool* b)\n            : abstract_value(b) {\n            m_implicit       = true;\n            m_implicit_value = \"true\";\n        }\n\n        std::shared_ptr&lt;Value&gt; clone() const override {\n            return std::make_shared&lt;standard_value&lt;bool&gt;&gt;(*this);\n        }\n\n    private:\n        void set_default_and_implicit() {\n            m_default        = true;\n            m_default_value  = \"false\";\n            m_implicit       = true;\n            m_implicit_value = \"true\";\n        }\n    };\n\n} // namespace values\n\ntemplate&lt;typename T&gt;\nstd::shared_ptr&lt;Value&gt; value() {\n    return std::make_shared&lt;values::standard_value&lt;T&gt;&gt;();\n}\n\ntemplate&lt;typename T&gt;\nstd::shared_ptr&lt;Value&gt; value(T&amp; t) {\n    return std::make_shared&lt;values::standard_value&lt;T&gt;&gt;(&amp;t);\n}\n\nclass OptionAdder;\n\nCXXOPTS_NODISCARD\ninline const std::string&amp; first_or_empty(const OptionNames&amp; long_names) {\n    static const std::string empty{\"\"};\n    return long_names.empty() ? empty : long_names.front();\n}\n\nclass OptionDetails {\npublic:\n    OptionDetails(std::string short_, OptionNames long_, String desc, std::shared_ptr&lt;const Value&gt; val)\n        : m_short(std::move(short_))\n        , m_long(std::move(long_))\n        , m_desc(std::move(desc))\n        , m_value(std::move(val))\n        , m_count(0) {\n        m_hash = std::hash&lt;std::string&gt;{}(first_long_name() + m_short);\n    }\n\n    OptionDetails(const OptionDetails&amp; rhs)\n        : m_desc(rhs.m_desc)\n        , m_value(rhs.m_value-&gt;clone())\n        , m_count(rhs.m_count) { }\n\n    OptionDetails(OptionDetails&amp;&amp; rhs) = default;\n\n    CXXOPTS_NODISCARD\n    const String&amp; description() const {\n        return m_desc;\n    }\n\n    CXXOPTS_NODISCARD\n    const Value&amp; value() const {\n        return *m_value;\n    }\n\n    CXXOPTS_NODISCARD\n    std::shared_ptr&lt;Value&gt; make_storage() const {\n        return m_value-&gt;clone();\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; short_name() const {\n        return m_short;\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; first_long_name() const {\n        return first_or_empty(m_long);\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; essential_name() const {\n        return m_long.empty() ? m_short : m_long.front();\n    }\n\n    CXXOPTS_NODISCARD\n    const OptionNames&amp; long_names() const {\n        return m_long;\n    }\n\n    std::size_t hash() const {\n        return m_hash;\n    }\n\nprivate:\n    std::string                  m_short{};\n    OptionNames                  m_long{};\n    String                       m_desc{};\n    std::shared_ptr&lt;const Value&gt; m_value{};\n    int                          m_count;\n\n    std::size_t m_hash{};\n};\n\nstruct HelpOptionDetails {\n    std::string s;\n    OptionNames l;\n    String      desc;\n    bool        has_default;\n    std::string default_value;\n    bool        has_implicit;\n    std::string implicit_value;\n    std::string arg_help;\n    bool        is_container;\n    bool        is_boolean;\n};\n\nstruct HelpGroupDetails {\n    std::string                    name{};\n    std::string                    description{};\n    std::vector&lt;HelpOptionDetails&gt; options{};\n};\n\nclass OptionValue {\npublic:\n    void parse(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details, const std::string&amp; text) {\n        ensure_value(details);\n        ++m_count;\n        m_value-&gt;parse(text);\n        m_long_names = &amp;details-&gt;long_names();\n    }\n\n    void parse_default(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        ensure_value(details);\n        m_default    = true;\n        m_long_names = &amp;details-&gt;long_names();\n        m_value-&gt;parse();\n    }\n\n    void parse_no_value(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        m_long_names = &amp;details-&gt;long_names();\n    }\n\n#if defined(CXXOPTS_NULL_DEREF_IGNORE)\n    CXXOPTS_DIAGNOSTIC_PUSH\n    CXXOPTS_IGNORE_WARNING(\"-Wnull-dereference\")\n#endif\n\n    CXXOPTS_NODISCARD\n    std::size_t count() const noexcept {\n        return m_count;\n    }\n\n#if defined(CXXOPTS_NULL_DEREF_IGNORE)\n    CXXOPTS_DIAGNOSTIC_POP\n#endif\n\n    // TODO: maybe default options should count towards the number of arguments\n    CXXOPTS_NODISCARD\n    bool has_default() const noexcept {\n        return m_default;\n    }\n\n    template&lt;typename T&gt;\n    const T&amp; as() const {\n        if (m_value == nullptr) {\n            throw_or_mimic&lt;exceptions::option_has_no_value&gt;(m_long_names == nullptr ? \"\" : first_or_empty(*m_long_names));\n        }\n\n        return CXXOPTS_RTTI_CAST&lt;const values::standard_value&lt;T&gt;&amp;&gt;(*m_value).get();\n    }\n\nprivate:\n    void ensure_value(const std::shared_ptr&lt;const OptionDetails&gt;&amp; details) {\n        if (m_value == nullptr) {\n            m_value = details-&gt;make_storage();\n        }\n    }\n\n    const OptionNames* m_long_names = nullptr;\n    // Holding this pointer is safe, since OptionValue's only exist in key-value pairs,\n    // where the key has the string we point to.\n    std::shared_ptr&lt;Value&gt; m_value{};\n    std::size_t            m_count   = 0;\n    bool                   m_default = false;\n};\n\nclass KeyValue {\npublic:\n    KeyValue(std::string key_, std::string value_) noexcept\n        : m_key(std::move(key_))\n        , m_value(std::move(value_)) { }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; key() const {\n        return m_key;\n    }\n\n    CXXOPTS_NODISCARD\n    const std::string&amp; value() const {\n        return m_value;\n    }\n\n    template&lt;typename T&gt;\n    T as() const {\n        T result;\n        values::parse_value(m_value, result);\n        return result;\n    }\n\nprivate:\n    std::string m_key;\n    std::string m_value;\n};\n\nusing ParsedHashMap = std::unordered_map&lt;std::size_t, OptionValue&gt;;\nusing NameHashMap   = std::unordered_map&lt;std::string, std::size_t&gt;;\n\nclass ParseResult {\npublic:\n    class Iterator {\n    public:\n        using iterator_category = std::forward_iterator_tag;\n        using value_type        = KeyValue;\n        using difference_type   = void;\n        using pointer           = const KeyValue*;\n        using reference         = const KeyValue&amp;;\n\n        Iterator()                = default;\n        Iterator(const Iterator&amp;) = default;\n\n        // GCC complains about m_iter not being initialised in the member\n        // initializer list\n        CXXOPTS_DIAGNOSTIC_PUSH\n        CXXOPTS_IGNORE_WARNING(\"-Weffc++\")\n\n        Iterator(const ParseResult* pr, bool end = false)\n            : m_pr(pr) {\n            if (end) {\n                m_sequential = false;\n                m_iter       = m_pr-&gt;m_defaults.end();\n            } else {\n                m_sequential = true;\n                m_iter       = m_pr-&gt;m_sequential.begin();\n\n                if (m_iter == m_pr-&gt;m_sequential.end()) {\n                    m_sequential = false;\n                    m_iter       = m_pr-&gt;m_defaults.begin();\n                }\n            }\n        }\n\n        CXXOPTS_DIAGNOSTIC_POP\n\n        Iterator&amp; operator++() {\n            ++m_iter;\n            if (m_sequential &amp;&amp; m_iter == m_pr-&gt;m_sequential.end()) {\n                m_sequential = false;\n                m_iter       = m_pr-&gt;m_defaults.begin();\n                return *this;\n            }\n            return *this;\n        }\n\n        Iterator operator++(int) {\n            Iterator retval = *this;\n            ++(*this);\n            return retval;\n        }\n\n        bool operator==(const Iterator&amp; other) const {\n            return (m_sequential == other.m_sequential) &amp;&amp; (m_iter == other.m_iter);\n        }\n\n        bool operator!=(const Iterator&amp; other) const {\n            return !(*this == other);\n        }\n\n        const KeyValue&amp; operator*() {\n            return *m_iter;\n        }\n\n        const KeyValue* operator-&gt;() {\n            return m_iter.operator-&gt;();\n        }\n\n    private:\n        const ParseResult*                    m_pr;\n        std::vector&lt;KeyValue&gt;::const_iterator m_iter;\n        bool                                  m_sequential = true;\n    };\n\n    ParseResult()                   = default;\n    ParseResult(const ParseResult&amp;) = default;\n\n    ParseResult(NameHashMap&amp;&amp; keys, ParsedHashMap&amp;&amp; values, std::vector&lt;KeyValue&gt; sequential,\n                std::vector&lt;KeyValue&gt; default_opts, std::vector&lt;std::string&gt;&amp;&amp; unmatched_args)\n        : m_keys(std::move(keys))\n        , m_values(std::move(values))\n        , m_sequential(std::move(sequential))\n        , m_defaults(std::move(default_opts))\n        , m_unmatched(std::move(unmatched_args)) { }\n\n    ParseResult&amp; operator=(ParseResult&amp;&amp;)      = default;\n    ParseResult&amp; operator=(const ParseResult&amp;) = default;\n\n    Iterator begin() const {\n        return Iterator(this);\n    }\n\n    Iterator end() const {\n        return Iterator(this, true);\n    }\n\n    std::size_t count(const std::string&amp; o) const {\n        auto iter = m_keys.find(o);\n        if (iter == m_keys.end()) {\n            return 0;\n        }\n\n        auto viter = m_values.find(iter-&gt;second);\n\n        if (viter == m_values.end()) {\n            return 0;\n        }\n\n        return viter-&gt;second.count();\n    }\n\n    const OptionValue&amp; operator[](const std::string&amp; option) const {\n        auto iter = m_keys.find(option);\n\n        if (iter == m_keys.end()) {\n            throw_or_mimic&lt;exceptions::requested_option_not_present&gt;(option);\n        }\n\n        auto viter = m_values.find(iter-&gt;second);\n\n        if (viter == m_values.end()) {\n            throw_or_mimic&lt;exceptions::requested_option_not_present&gt;(option);\n        }\n\n        return viter-&gt;second;\n    }\n\n    const std::vector&lt;KeyValue&gt;&amp; arguments() const {\n        return m_sequential;\n    }\n\n    const std::vector&lt;std::string&gt;&amp; unmatched() const {\n        return m_unmatched;\n    }\n\n    const std::vector&lt;KeyValue&gt;&amp; defaults() const {\n        return m_defaults;\n    }\n\n    const std::string arguments_string() const {\n        std::string result;\n        for (const auto&amp; kv : m_sequential) {\n            result += kv.key() + \" = \" + kv.value() + \"\\n\";\n        }\n        for (const auto&amp; kv : m_defaults) {\n            result += kv.key() + \" = \" + kv.value() + \" \" + \"(default)\" + \"\\n\";\n        }\n        return result;\n    }\n\nprivate:\n    NameHashMap              m_keys{};\n    ParsedHashMap            m_values{};\n    std::vector&lt;KeyValue&gt;    m_sequential{};\n    std::vector&lt;KeyValue&gt;    m_defaults{};\n    std::vector&lt;std::string&gt; m_unmatched{};\n};\n\nstruct Option {\n    Option(std::string opts, std::string desc, std::shared_ptr&lt;const Value&gt; value = ::cxxopts::value&lt;bool&gt;(),\n           std::string arg_help = \"\")\n        : opts_(std::move(opts))\n        , desc_(std::move(desc))\n        , value_(std::move(value))\n        , arg_help_(std::move(arg_help)) { }\n\n    std::string                  opts_;\n    std::string                  desc_;\n    std::shared_ptr&lt;const Value&gt; value_;\n    std::string                  arg_help_;\n};\n\nusing OptionMap              = std::unordered_map&lt;std::string, std::shared_ptr&lt;OptionDetails&gt;&gt;;\nusing PositionalList         = std::vector&lt;std::string&gt;;\nusing PositionalListIterator = PositionalList::const_iterator;\n\nclass OptionParser {\npublic:\n    OptionParser(const OptionMap&amp; options, const PositionalList&amp; positional, bool allow_unrecognised)\n        : m_options(options)\n        , m_positional(positional)\n        , m_allow_unrecognised(allow_unrecognised) { }\n\n    ParseResult parse(int argc, const char* const* argv);\n\n    bool consume_positional(const std::string&amp; a, PositionalListIterator&amp; next);\n\n    void checked_parse_arg(int argc, const char* const* argv, int&amp; current, const std::shared_ptr&lt;OptionDetails&gt;&amp; value,\n                           const std::string&amp; name);\n\n    void add_to_option(OptionMap::const_iterator iter, const std::string&amp; option, const std::string&amp; arg);\n\n    void parse_option(const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; name, const std::string&amp; arg = \"\");\n\n    void parse_default(const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\n    void parse_no_value(const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\nprivate:\n    void finalise_aliases();\n\n    const OptionMap&amp;      m_options;\n    const PositionalList&amp; m_positional;\n\n    std::vector&lt;KeyValue&gt; m_sequential{};\n    std::vector&lt;KeyValue&gt; m_defaults{};\n    bool                  m_allow_unrecognised;\n\n    ParsedHashMap m_parsed{};\n    NameHashMap   m_keys{};\n};\n\nclass Options {\npublic:\n    explicit Options(std::string program_name, std::string help_string = \"\")\n        : m_program(std::move(program_name))\n        , m_help_string(toLocalString(std::move(help_string)))\n        , m_custom_help(\"[OPTION...]\")\n        , m_positional_help(\"positional parameters\")\n        , m_show_positional(false)\n        , m_allow_unrecognised(false)\n        , m_width(76)\n        , m_tab_expansion(false)\n        , m_options(std::make_shared&lt;OptionMap&gt;()) { }\n\n    Options&amp; positional_help(std::string help_text) {\n        m_positional_help = std::move(help_text);\n        return *this;\n    }\n\n    Options&amp; custom_help(std::string help_text) {\n        m_custom_help = std::move(help_text);\n        return *this;\n    }\n\n    Options&amp; show_positional_help() {\n        m_show_positional = true;\n        return *this;\n    }\n\n    Options&amp; allow_unrecognised_options() {\n        m_allow_unrecognised = true;\n        return *this;\n    }\n\n    Options&amp; set_width(std::size_t width) {\n        m_width = width;\n        return *this;\n    }\n\n    Options&amp; set_tab_expansion(bool expansion = true) {\n        m_tab_expansion = expansion;\n        return *this;\n    }\n\n    ParseResult parse(int argc, const char* const* argv);\n\n    OptionAdder add_options(std::string group = \"\");\n\n    void add_options(const std::string&amp; group, std::initializer_list&lt;Option&gt; options);\n\n    void add_option(const std::string&amp; group, const Option&amp; option);\n\n    void add_option(const std::string&amp; group, const std::string&amp; s, const OptionNames&amp; l, std::string desc,\n                    const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help);\n\n    void add_option(const std::string&amp; group, const std::string&amp; short_name, const std::string&amp; single_long_name,\n                    std::string desc, const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n        OptionNames long_names;\n        long_names.emplace_back(single_long_name);\n        add_option(group, short_name, long_names, desc, value, arg_help);\n    }\n\n    // parse positional arguments into the given option\n    void parse_positional(std::string option);\n\n    void parse_positional(std::vector&lt;std::string&gt; options);\n\n    void parse_positional(std::initializer_list&lt;std::string&gt; options);\n\n    template&lt;typename Iterator&gt;\n    void parse_positional(Iterator begin, Iterator end) {\n        parse_positional(std::vector&lt;std::string&gt;{begin, end});\n    }\n\n    std::string help(const std::vector&lt;std::string&gt;&amp; groups = {}, bool print_usage = true) const;\n\n    std::vector&lt;std::string&gt; groups() const;\n\n    const HelpGroupDetails&amp; group_help(const std::string&amp; group) const;\n\n    const std::string&amp; program() const {\n        return m_program;\n    }\n\nprivate:\n    void add_one_option(const std::string&amp; option, const std::shared_ptr&lt;OptionDetails&gt;&amp; details);\n\n    String help_one_group(const std::string&amp; group) const;\n\n    void generate_group_help(String&amp; result, const std::vector&lt;std::string&gt;&amp; groups) const;\n\n    void generate_all_groups_help(String&amp; result) const;\n\n    std::string m_program{};\n    String      m_help_string{};\n    std::string m_custom_help{};\n    std::string m_positional_help{};\n    bool        m_show_positional;\n    bool        m_allow_unrecognised;\n    std::size_t m_width;\n    bool        m_tab_expansion;\n\n    std::shared_ptr&lt;OptionMap&gt;      m_options;\n    std::vector&lt;std::string&gt;        m_positional{};\n    std::unordered_set&lt;std::string&gt; m_positional_set{};\n\n    // mapping from groups to help options\n    std::map&lt;std::string, HelpGroupDetails&gt; m_help{};\n};\n\nclass OptionAdder {\npublic:\n    OptionAdder(Options&amp; options, std::string group)\n        : m_options(options)\n        , m_group(std::move(group)) { }\n\n    OptionAdder&amp; operator()(const std::string&amp; opts, const std::string&amp; desc,\n                            const std::shared_ptr&lt;const Value&gt;&amp; value = ::cxxopts::value&lt;bool&gt;(), std::string arg_help = \"\");\n\nprivate:\n    Options&amp;    m_options;\n    std::string m_group;\n};\n\nnamespace {\n    constexpr std::size_t OPTION_LONGEST  = 30;\n    constexpr std::size_t OPTION_DESC_GAP = 2;\n\n    String format_option(const HelpOptionDetails&amp; o) {\n        const auto&amp; s = o.s;\n        const auto&amp; l = first_or_empty(o.l);\n\n        String result = \"  \";\n\n        if (!s.empty()) {\n            result += \"-\" + toLocalString(s);\n            if (!l.empty()) {\n                result += \",\";\n            }\n        } else {\n            result += \"   \";\n        }\n\n        if (!l.empty()) {\n            result += \" --\" + toLocalString(l);\n        }\n\n        auto arg = !o.arg_help.empty() ? toLocalString(o.arg_help) : \"arg\";\n\n        if (!o.is_boolean) {\n            if (o.has_implicit) {\n                result += \" [=\" + arg + \"(=\" + toLocalString(o.implicit_value) + \")]\";\n            } else {\n                result += \" \" + arg;\n            }\n        }\n\n        return result;\n    }\n\n    String format_description(const HelpOptionDetails&amp; o, std::size_t start, std::size_t allowed, bool tab_expansion) {\n        auto desc = o.desc;\n\n        if (o.has_default &amp;&amp; (!o.is_boolean || o.default_value != \"false\")) {\n            if (!o.default_value.empty()) {\n                desc += toLocalString(\" (default: \" + o.default_value + \")\");\n            } else {\n                desc += toLocalString(\" (default: \\\"\\\")\");\n            }\n        }\n\n        String result;\n\n        if (tab_expansion) {\n            String desc2;\n            auto   size = std::size_t{0};\n            for (auto c = std::begin(desc); c != std::end(desc); ++c) {\n                if (*c == '\\n') {\n                    desc2 += *c;\n                    size = 0;\n                } else if (*c == '\\t') {\n                    auto skip = 8 - size % 8;\n                    stringAppend(desc2, skip, ' ');\n                    size += skip;\n                } else {\n                    desc2 += *c;\n                    ++size;\n                }\n            }\n            desc = desc2;\n        }\n\n        desc += \" \";\n\n        auto current   = std::begin(desc);\n        auto previous  = current;\n        auto startLine = current;\n        auto lastSpace = current;\n\n        auto size = std::size_t{};\n\n        bool appendNewLine;\n        bool onlyWhiteSpace = true;\n\n        while (current != std::end(desc)) {\n            appendNewLine = false;\n            if (*previous == ' ' || *previous == '\\t') {\n                lastSpace = current;\n            }\n            if (*current != ' ' &amp;&amp; *current != '\\t') {\n                onlyWhiteSpace = false;\n            }\n\n            while (*current == '\\n') {\n                previous = current;\n                ++current;\n                appendNewLine = true;\n            }\n\n            if (!appendNewLine &amp;&amp; size &gt;= allowed) {\n                if (lastSpace != startLine) {\n                    current  = lastSpace;\n                    previous = current;\n                }\n                appendNewLine = true;\n            }\n\n            if (appendNewLine) {\n                stringAppend(result, startLine, current);\n                startLine = current;\n                lastSpace = current;\n\n                if (*previous != '\\n') {\n                    stringAppend(result, \"\\n\");\n                }\n\n                stringAppend(result, start, ' ');\n\n                if (*previous != '\\n') {\n                    stringAppend(result, lastSpace, current);\n                }\n\n                onlyWhiteSpace = true;\n                size           = 0;\n            }\n\n            previous = current;\n            ++current;\n            ++size;\n        }\n\n        // append whatever is left but ignore whitespace\n        if (!onlyWhiteSpace) {\n            stringAppend(result, startLine, previous);\n        }\n\n        return result;\n    }\n\n} // namespace\n\ninline void Options::add_options(const std::string&amp; group, std::initializer_list&lt;Option&gt; options) {\n    OptionAdder option_adder(*this, group);\n    for (const auto&amp; option : options) {\n        option_adder(option.opts_, option.desc_, option.value_, option.arg_help_);\n    }\n}\n\ninline OptionAdder Options::add_options(std::string group) {\n    return OptionAdder(*this, std::move(group));\n}\n\ninline OptionAdder&amp; OptionAdder::operator()(const std::string&amp; opts, const std::string&amp; desc,\n                                            const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n    OptionNames option_names = values::parser_tool::split_option_names(opts);\n    // Note: All names will be non-empty; but we must separate the short\n    // (length-1) and longer names\n    std::string short_name{\"\"};\n    auto        first_short_name_iter = std::partition(option_names.begin(), option_names.end(), [&amp;](const std::string&amp; name) {\n        return name.length() &gt; 1;\n    });\n    auto        num_length_1_names    = (option_names.end() - first_short_name_iter);\n    switch (num_length_1_names) {\n    case 1:\n        short_name = *first_short_name_iter;\n        option_names.erase(first_short_name_iter);\n    case 0:\n        break;\n    default:\n        throw_or_mimic&lt;exceptions::invalid_option_format&gt;(opts);\n    };\n\n    m_options.add_option(m_group, short_name, option_names, desc, value, std::move(arg_help));\n\n    return *this;\n}\n\ninline void OptionParser::parse_default(const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    // TODO: remove the duplicate code here\n    auto&amp; store = m_parsed[details-&gt;hash()];\n    store.parse_default(details);\n    m_defaults.emplace_back(details-&gt;essential_name(), details-&gt;value().get_default_value());\n}\n\ninline void OptionParser::parse_no_value(const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    auto&amp; store = m_parsed[details-&gt;hash()];\n    store.parse_no_value(details);\n}\n\ninline void OptionParser::parse_option(const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; /*name*/,\n                                       const std::string&amp;                    arg) {\n    auto  hash   = value-&gt;hash();\n    auto&amp; result = m_parsed[hash];\n    result.parse(value, arg);\n\n    m_sequential.emplace_back(value-&gt;essential_name(), arg);\n}\n\ninline void OptionParser::checked_parse_arg(int argc, const char* const* argv, int&amp; current,\n                                            const std::shared_ptr&lt;OptionDetails&gt;&amp; value, const std::string&amp; name) {\n    if (current + 1 &gt;= argc) {\n        if (value-&gt;value().has_implicit()) {\n            parse_option(value, name, value-&gt;value().get_implicit_value());\n        } else {\n            throw_or_mimic&lt;exceptions::missing_argument&gt;(name);\n        }\n    } else {\n        if (value-&gt;value().has_implicit()) {\n            parse_option(value, name, value-&gt;value().get_implicit_value());\n        } else {\n            parse_option(value, name, argv[current + 1]);\n            ++current;\n        }\n    }\n}\n\ninline void OptionParser::add_to_option(OptionMap::const_iterator iter, const std::string&amp; option, const std::string&amp; arg) {\n    parse_option(iter-&gt;second, option, arg);\n}\n\ninline bool OptionParser::consume_positional(const std::string&amp; a, PositionalListIterator&amp; next) {\n    while (next != m_positional.end()) {\n        auto iter = m_options.find(*next);\n        if (iter != m_options.end()) {\n            if (!iter-&gt;second-&gt;value().is_container()) {\n                auto&amp; result = m_parsed[iter-&gt;second-&gt;hash()];\n                if (result.count() == 0) {\n                    add_to_option(iter, *next, a);\n                    ++next;\n                    return true;\n                }\n                ++next;\n                continue;\n            }\n            add_to_option(iter, *next, a);\n            return true;\n        }\n        throw_or_mimic&lt;exceptions::no_such_option&gt;(*next);\n    }\n\n    return false;\n}\n\ninline void Options::parse_positional(std::string option) {\n    parse_positional(std::vector&lt;std::string&gt;{std::move(option)});\n}\n\ninline void Options::parse_positional(std::vector&lt;std::string&gt; options) {\n    m_positional = std::move(options);\n\n    m_positional_set.insert(m_positional.begin(), m_positional.end());\n}\n\ninline void Options::parse_positional(std::initializer_list&lt;std::string&gt; options) {\n    parse_positional(std::vector&lt;std::string&gt;(options));\n}\n\ninline ParseResult Options::parse(int argc, const char* const* argv) {\n    OptionParser parser(*m_options, m_positional, m_allow_unrecognised);\n\n    return parser.parse(argc, argv);\n}\n\ninline ParseResult OptionParser::parse(int argc, const char* const* argv) {\n    int  current           = 1;\n    bool consume_remaining = false;\n    auto next_positional   = m_positional.begin();\n\n    std::vector&lt;std::string&gt; unmatched;\n\n    while (current != argc) {\n        if (strcmp(argv[current], \"--\") == 0) {\n            consume_remaining = true;\n            ++current;\n            break;\n        }\n        bool                          matched   = false;\n        values::parser_tool::ArguDesc argu_desc = values::parser_tool::ParseArgument(argv[current], matched);\n\n        if (!matched) {\n            // not a flag\n\n            // but if it starts with a `-`, then it's an error\n            if (argv[current][0] == '-' &amp;&amp; argv[current][1] != '\\0') {\n                if (!m_allow_unrecognised) {\n                    throw_or_mimic&lt;exceptions::invalid_option_syntax&gt;(argv[current]);\n                }\n            }\n\n            // if true is returned here then it was consumed, otherwise it is\n            // ignored\n            if (consume_positional(argv[current], next_positional)) {\n            } else {\n                unmatched.emplace_back(argv[current]);\n            }\n            // if we return from here then it was parsed successfully, so continue\n        } else {\n            // short or long option?\n            if (argu_desc.grouping) {\n                const std::string&amp; s = argu_desc.arg_name;\n\n                for (std::size_t i = 0; i != s.size(); ++i) {\n                    std::string name(1, s[i]);\n                    auto        iter = m_options.find(name);\n\n                    if (iter == m_options.end()) {\n                        if (m_allow_unrecognised) {\n                            unmatched.push_back(std::string(\"-\") + s[i]);\n                            continue;\n                        }\n                        // error\n                        throw_or_mimic&lt;exceptions::no_such_option&gt;(name);\n                    }\n\n                    auto value = iter-&gt;second;\n\n                    if (i + 1 == s.size()) {\n                        // it must be the last argument\n                        checked_parse_arg(argc, argv, current, value, name);\n                    } else if (value-&gt;value().has_implicit()) {\n                        parse_option(value, name, value-&gt;value().get_implicit_value());\n                    } else if (i + 1 &lt; s.size()) {\n                        std::string arg_value = s.substr(i + 1);\n                        parse_option(value, name, arg_value);\n                        break;\n                    } else {\n                        // error\n                        throw_or_mimic&lt;exceptions::option_requires_argument&gt;(name);\n                    }\n                }\n            } else if (argu_desc.arg_name.length() != 0) {\n                const std::string&amp; name = argu_desc.arg_name;\n\n                auto iter = m_options.find(name);\n\n                if (iter == m_options.end()) {\n                    if (m_allow_unrecognised) {\n                        // keep unrecognised options in argument list, skip to next argument\n                        unmatched.emplace_back(argv[current]);\n                        ++current;\n                        continue;\n                    }\n                    // error\n                    throw_or_mimic&lt;exceptions::no_such_option&gt;(name);\n                }\n\n                auto opt = iter-&gt;second;\n\n                // equals provided for long option?\n                if (argu_desc.set_value) {\n                    // parse the option given\n\n                    parse_option(opt, name, argu_desc.value);\n                } else {\n                    // parse the next argument\n                    checked_parse_arg(argc, argv, current, opt, name);\n                }\n            }\n        }\n\n        ++current;\n    }\n\n    for (auto&amp; opt : m_options) {\n        auto&amp;       detail = opt.second;\n        const auto&amp; value  = detail-&gt;value();\n\n        auto&amp; store = m_parsed[detail-&gt;hash()];\n\n        if (value.has_default()) {\n            if (!store.count() &amp;&amp; !store.has_default()) {\n                parse_default(detail);\n            }\n        } else {\n            parse_no_value(detail);\n        }\n    }\n\n    if (consume_remaining) {\n        while (current &lt; argc) {\n            if (!consume_positional(argv[current], next_positional)) {\n                break;\n            }\n            ++current;\n        }\n\n        // adjust argv for any that couldn't be swallowed\n        while (current != argc) {\n            unmatched.emplace_back(argv[current]);\n            ++current;\n        }\n    }\n\n    finalise_aliases();\n\n    ParseResult parsed(std::move(m_keys), std::move(m_parsed), std::move(m_sequential), std::move(m_defaults),\n                       std::move(unmatched));\n    return parsed;\n}\n\ninline void OptionParser::finalise_aliases() {\n    for (auto&amp; option : m_options) {\n        auto&amp; detail                = *option.second;\n        auto  hash                  = detail.hash();\n        m_keys[detail.short_name()] = hash;\n        for (const auto&amp; long_name : detail.long_names()) {\n            m_keys[long_name] = hash;\n        }\n\n        m_parsed.emplace(hash, OptionValue());\n    }\n}\n\ninline void Options::add_option(const std::string&amp; group, const Option&amp; option) {\n    add_options(group, {option});\n}\n\ninline void Options::add_option(const std::string&amp; group, const std::string&amp; s, const OptionNames&amp; l, std::string desc,\n                                const std::shared_ptr&lt;const Value&gt;&amp; value, std::string arg_help) {\n    auto stringDesc = toLocalString(std::move(desc));\n    auto option     = std::make_shared&lt;OptionDetails&gt;(s, l, stringDesc, value);\n\n    if (!s.empty()) {\n        add_one_option(s, option);\n    }\n\n    for (const auto&amp; long_name : l) {\n        add_one_option(long_name, option);\n    }\n\n    // add the help details\n    auto&amp; options = m_help[group];\n\n    options.options.emplace_back(HelpOptionDetails{s, l, stringDesc, value-&gt;has_default(), value-&gt;get_default_value(),\n                                                   value-&gt;has_implicit(), value-&gt;get_implicit_value(), std::move(arg_help),\n                                                   value-&gt;is_container(), value-&gt;is_boolean()});\n}\n\ninline void Options::add_one_option(const std::string&amp; option, const std::shared_ptr&lt;OptionDetails&gt;&amp; details) {\n    auto in = m_options-&gt;emplace(option, details);\n\n    if (!in.second) {\n        throw_or_mimic&lt;exceptions::option_already_exists&gt;(option);\n    }\n}\n\ninline String Options::help_one_group(const std::string&amp; g) const {\n    using OptionHelp = std::vector&lt;std::pair&lt;String, String&gt;&gt;;\n\n    auto group = m_help.find(g);\n    if (group == m_help.end()) {\n        return \"\";\n    }\n\n    OptionHelp format;\n\n    std::size_t longest = 0;\n\n    String result;\n\n    if (!g.empty()) {\n        result += toLocalString(\" \" + g + \" options:\\n\");\n    }\n\n    for (const auto&amp; o : group-&gt;second.options) {\n        if (o.l.size() &amp;&amp; m_positional_set.find(o.l.front()) != m_positional_set.end() &amp;&amp; !m_show_positional) {\n            continue;\n        }\n\n        auto s  = format_option(o);\n        longest = (std::max)(longest, stringLength(s));\n        format.push_back(std::make_pair(s, String()));\n    }\n    longest = (std::min)(longest, OPTION_LONGEST);\n\n    // widest allowed description -- min 10 chars for helptext/line\n    std::size_t allowed = 10;\n    if (m_width &gt; allowed + longest + OPTION_DESC_GAP) {\n        allowed = m_width - longest - OPTION_DESC_GAP;\n    }\n\n    auto fiter = format.begin();\n    for (const auto&amp; o : group-&gt;second.options) {\n        if (o.l.size() &amp;&amp; m_positional_set.find(o.l.front()) != m_positional_set.end() &amp;&amp; !m_show_positional) {\n            continue;\n        }\n\n        auto d = format_description(o, longest + OPTION_DESC_GAP, allowed, m_tab_expansion);\n\n        result += fiter-&gt;first;\n        if (stringLength(fiter-&gt;first) &gt; longest) {\n            result += '\\n';\n            result += toLocalString(std::string(longest + OPTION_DESC_GAP, ' '));\n        } else {\n            result += toLocalString(std::string(longest + OPTION_DESC_GAP - stringLength(fiter-&gt;first), ' '));\n        }\n        result += d;\n        result += '\\n';\n\n        ++fiter;\n    }\n\n    return result;\n}\n\ninline void Options::generate_group_help(String&amp; result, const std::vector&lt;std::string&gt;&amp; print_groups) const {\n    for (std::size_t i = 0; i != print_groups.size(); ++i) {\n        const String&amp; group_help_text = help_one_group(print_groups[i]);\n        if (empty(group_help_text)) {\n            continue;\n        }\n        result += group_help_text;\n        if (i &lt; print_groups.size() - 1) {\n            result += '\\n';\n        }\n    }\n}\n\ninline void Options::generate_all_groups_help(String&amp; result) const {\n    std::vector&lt;std::string&gt; all_groups;\n\n    std::transform(m_help.begin(), m_help.end(), std::back_inserter(all_groups),\n                   [](const std::map&lt;std::string, HelpGroupDetails&gt;::value_type&amp; group) {\n                       return group.first;\n                   });\n\n    generate_group_help(result, all_groups);\n}\n\ninline std::string Options::help(const std::vector&lt;std::string&gt;&amp; help_groups, bool print_usage) const {\n    String result = m_help_string;\n    if (print_usage) {\n        result += \"\\nUsage:\\n  \" + toLocalString(m_program);\n    }\n\n    if (!m_custom_help.empty()) {\n        result += \" \" + toLocalString(m_custom_help);\n    }\n\n    if (!m_positional.empty() &amp;&amp; !m_positional_help.empty()) {\n        result += \" \" + toLocalString(m_positional_help);\n    }\n\n    result += \"\\n\\n\";\n\n    if (help_groups.empty()) {\n        generate_all_groups_help(result);\n    } else {\n        generate_group_help(result, help_groups);\n    }\n\n    return toUTF8String(result);\n}\n\ninline std::vector&lt;std::string&gt; Options::groups() const {\n    std::vector&lt;std::string&gt; g;\n\n    std::transform(m_help.begin(), m_help.end(), std::back_inserter(g),\n                   [](const std::map&lt;std::string, HelpGroupDetails&gt;::value_type&amp; pair) {\n                       return pair.first;\n                   });\n\n    return g;\n}\n\ninline const HelpGroupDetails&amp; Options::group_help(const std::string&amp; group) const {\n    return m_help.at(group);\n}\n\n} // namespace cxxopts\n\n#endif // CXXOPTS_HPP_INCLUDED\n</code></pre>"},{"location":"api/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir /home/friedel/devel/ILLIXR-historic/src","text":"<p>FileList &gt; src</p>"},{"location":"api/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file cxxopts.hpp file illixr.hpp file main.cpp file noop_record_logger.hpp file plugin.cpp file runtime_impl.cpp file sqlite_record_logger.hpp file stdout_record_logger.hpp <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/</code></p>"},{"location":"api/illixr_8hpp/","title":"File illixr.hpp","text":"<p>FileList &gt; src &gt; illixr.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cxxopts.hpp\"</code></li> <li><code>#include \"illixr/runtime.hpp\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/illixr_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/illixr_8hpp/#classes","title":"Classes","text":"Type Name class cancellable_sleep"},{"location":"api/illixr_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr unsigned int ILLIXR_PRE_SLEEP_DURATION   = <code>{10}</code> constexpr std::chrono::seconds ILLIXR_RUN_DURATION_DEFAULT   = <code>{60}</code> ILLIXR::runtime * r"},{"location":"api/illixr_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; T &gt; operator+ (const std::vector&lt; T &gt; &amp; a, const std::vector&lt; T &gt; &amp; b)"},{"location":"api/illixr_8hpp/#macros","title":"Macros","text":"Type Name define GET_BOOL (NAME, ENV) <code>/* multi line expression */</code> define GET_LONG (NAME, ENV) <code>/* multi line expression */</code> define GET_STRING (NAME, ENV) <code>/* multi line expression */</code> define STRINGIZE (x) <code>\\_STR(x)</code> define _STR (y) <code>#y</code>"},{"location":"api/illixr_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/illixr_8hpp/#variable-illixr_pre_sleep_duration","title":"variable ILLIXR_PRE_SLEEP_DURATION","text":"<pre><code>constexpr unsigned int ILLIXR_PRE_SLEEP_DURATION;\n</code></pre>"},{"location":"api/illixr_8hpp/#variable-illixr_run_duration_default","title":"variable ILLIXR_RUN_DURATION_DEFAULT","text":"<pre><code>constexpr std::chrono::seconds ILLIXR_RUN_DURATION_DEFAULT;\n</code></pre>"},{"location":"api/illixr_8hpp/#variable-r","title":"variable r","text":"<pre><code>ILLIXR::runtime* r;\n</code></pre>"},{"location":"api/illixr_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/illixr_8hpp/#function-operator","title":"function operator+","text":"<pre><code>template&lt;typename T&gt;\nstd::vector&lt; T &gt; operator+ (\n    const std::vector&lt; T &gt; &amp; a,\n    const std::vector&lt; T &gt; &amp; b\n) \n</code></pre>"},{"location":"api/illixr_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/illixr_8hpp/#define-get_bool","title":"define GET_BOOL","text":"<pre><code>#define GET_BOOL (\n    NAME,\n    ENV\n) `/* multi line expression */`\n</code></pre>"},{"location":"api/illixr_8hpp/#define-get_long","title":"define GET_LONG","text":"<pre><code>#define GET_LONG (\n    NAME,\n    ENV\n) `/* multi line expression */`\n</code></pre>"},{"location":"api/illixr_8hpp/#define-get_string","title":"define GET_STRING","text":"<pre><code>#define GET_STRING (\n    NAME,\n    ENV\n) `/* multi line expression */`\n</code></pre>"},{"location":"api/illixr_8hpp/#define-stringize","title":"define STRINGIZE","text":"<pre><code>#define STRINGIZE (\n    x\n) `_STR(x)`\n</code></pre>"},{"location":"api/illixr_8hpp/#define-_str","title":"define _STR","text":"<pre><code>#define _STR (\n    y\n) `#y`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/illixr.hpp</code></p>"},{"location":"api/illixr_8hpp_source/","title":"File illixr.hpp","text":"<p>File List &gt; src &gt; illixr.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"cxxopts.hpp\"\n#include \"illixr/runtime.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\n#define GET_STRING(NAME, ENV)                                         \\\n    if (options.count(#NAME)) {                                       \\\n        setenv(#ENV, options[#NAME].as&lt;std::string&gt;().c_str(), true); \\\n    } else if (config[#NAME]) {                                       \\\n        setenv(#ENV, config[#NAME].as&lt;std::string&gt;().c_str(), true);  \\\n    }\n\n#define GET_BOOL(NAME, ENV)                      \\\n    if (options.count(#NAME) || config[#NAME]) { \\\n        bool val;                                \\\n        if (options.count(#NAME)) {              \\\n            val = options[#NAME].as&lt;bool&gt;();     \\\n        } else {                                 \\\n            val = config[#NAME].as&lt;bool&gt;();      \\\n        }                                        \\\n        if (val) {                               \\\n            setenv(#ENV, \"True\", true);          \\\n        } else {                                 \\\n            setenv(#ENV, \"False\", false);        \\\n        }                                        \\\n    }\n#define _STR(y)      #y\n#define STRINGIZE(x) _STR(x)\n#define GET_LONG(NAME, ENV)                                                    \\\n    if (options.count(#NAME)) {                                                \\\n        setenv(#ENV, std::to_string(options[#NAME].as&lt;long&gt;()).c_str(), true); \\\n    } else if (config[#NAME]) {                                                \\\n        setenv(#ENV, std::to_string(config[#NAME].as&lt;long&gt;()).c_str(), true);  \\\n    }\n\nconstexpr std::chrono::seconds          ILLIXR_RUN_DURATION_DEFAULT{60};\n[[maybe_unused]] constexpr unsigned int ILLIXR_PRE_SLEEP_DURATION{10};\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; operator+(const std::vector&lt;T&gt;&amp; a, const std::vector&lt;T&gt;&amp; b) {\n    std::vector&lt;T&gt; c = a;\n    c.insert(c.end(), b.begin(), b.end());\n    return c;\n}\n\nextern ILLIXR::runtime* r;\n\nnamespace ILLIXR {\nint run(const cxxopts::ParseResult&amp; options);\n\nclass cancellable_sleep {\npublic:\n    template&lt;typename T, typename R&gt;\n    bool sleep(std::chrono::duration&lt;T, R&gt; duration) {\n        auto wake_up_time = std::chrono::system_clock::now() + duration;\n        while (!_m_terminate.load() &amp;&amp; std::chrono::system_clock::now() &lt; wake_up_time) {\n            std::this_thread::sleep_for(std::chrono::milliseconds{100});\n        }\n        return _m_terminate.load();\n    }\n\n    void cancel() {\n        _m_terminate.store(true);\n    }\n\nprivate:\n    std::atomic&lt;bool&gt; _m_terminate{false};\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; src &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr.hpp\"</code></li> <li><code>#include &lt;csignal&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"api/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, const char * argv)"},{"location":"api/main_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void sigabrt_handler (int sig) A signal handler for SIGABRT. void sigill_handler (int sig) A signal handler for SIGILL. void sigint_handler (int sig) NDEBUG."},{"location":"api/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    const char * argv\n) \n</code></pre>"},{"location":"api/main_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/main_8cpp/#function-sigabrt_handler","title":"function sigabrt_handler","text":"<p>A signal handler for SIGABRT. <pre><code>static void sigabrt_handler (\n    int sig\n) \n</code></pre></p> <p>Forward SIGABRT from <code>std::abort</code> and <code>assert</code> to catchsegv in <code>ci.yaml</code>. Provides additional debugging information via <code>-rdynamic</code>. </p>"},{"location":"api/main_8cpp/#function-sigill_handler","title":"function sigill_handler","text":"<p>A signal handler for SIGILL. <pre><code>static void sigill_handler (\n    int sig\n) \n</code></pre></p> <p>Forward SIGILL from illegal instructions to catchsegv in <code>ci.yaml</code>. Provides additional debugging information via <code>-rdynamic</code>. </p>"},{"location":"api/main_8cpp/#function-sigint_handler","title":"function sigint_handler","text":"<p>NDEBUG. <pre><code>static void sigint_handler (\n    int sig\n) \n</code></pre></p> <p>A signal handler for SIGINT.</p> <p>Stops the execution of the application via the ILLIXR runtime. </p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/main.cpp</code></p>"},{"location":"api/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; src &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr.hpp\"\n\n#include &lt;csignal&gt;\n#include &lt;iostream&gt;\n\n#ifndef NDEBUG\nstatic void sigill_handler(int sig) {\n    assert(sig == SIGILL &amp;&amp; \"sigill_handler is for SIGILL\");\n    std::raise(SIGSEGV);\n}\n\nstatic void sigabrt_handler(int sig) {\n    assert(sig == SIGABRT &amp;&amp; \"sigabrt_handler is for SIGABRT\");\n    std::raise(SIGSEGV);\n}\n#endif \n\nstatic void sigint_handler([[maybe_unused]] int sig) {\n    assert(sig == SIGINT &amp;&amp; \"sigint_handler is for SIGINT\");\n    if (r) {\n        r-&gt;stop();\n    }\n}\n\nint main(int argc, const char* argv[]) {\n    cxxopts::Options options(\"ILLIXR\", \"Main program\");\n    options.show_positional_help();\n    // std::string illixr_data, illixr_demo_data, realsense_cam;\n    // illixr_data = illixr_demo_data = realsense_cam = \"\";\n    // bool offload_enable, alignment_enable, enable_verbose_errors, enable_pre_sleep;\n    // offload_enable = alignment_enable = enable_verbose_errors = enable_pre_sleep = false;\n    // long run_dur = 0;\n    options.add_options()(\"d,duration\", \"The duration to run for\", cxxopts::value&lt;long&gt;())(\n        \"data\", \"The data\", cxxopts::value&lt;std::string&gt;())(\"demo_data\", \"The demo data\", cxxopts::value&lt;std::string&gt;())(\n        \"enable_offload\", \"\")(\"enable_alignment\", \"\")(\"enable_verbose_errors\", \"\")(\"enable_pre_sleep\", \"\")(\n        \"h,help\", \"Produce help message\")(\"realsense_cam\", \"\", cxxopts::value&lt;std::string&gt;()-&gt;default_value(\"auto\"))(\n        \"p,plugins\", \"The plugins to use\", cxxopts::value&lt;std::vector&lt;std::string&gt;&gt;())(\n        \"vis\", \"The visualizer to use\", cxxopts::value&lt;std::vector&lt;std::string&gt;&gt;())(\"y,yaml\", \"Yaml config file\",\n                                                                                    cxxopts::value&lt;std::string&gt;())(\n        \"r,run\",\n        \"The plugins to run, supersedes plugins entry. This is only necessary if a plugin builds more than one library (e.g. \"\n        \"offload_vio builds 4 libraries) as each must be loaded individually.\");\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n        std::cout &lt;&lt; options.help() &lt;&lt; std::endl;\n        return EXIT_SUCCESS;\n    }\n\n#ifndef NDEBUG\n    std::signal(SIGILL, sigill_handler);\n    std::signal(SIGABRT, sigabrt_handler);\n#endif \n\n    std::signal(SIGINT, sigint_handler);\n\n    return ILLIXR::run(result);\n}\n</code></pre>"},{"location":"api/namespacecxxopts/","title":"Namespace cxxopts","text":"<p>Namespace List &gt; cxxopts</p>"},{"location":"api/namespacecxxopts/#namespaces","title":"Namespaces","text":"Type Name namespace exceptions namespace values"},{"location":"api/namespacecxxopts/#classes","title":"Classes","text":"Type Name struct HelpGroupDetails struct HelpOptionDetails class KeyValue struct Option class OptionAdder class OptionDetails class OptionParser class OptionValue class Options class ParseResult class Value"},{"location":"api/namespacecxxopts/#public-types","title":"Public Types","text":"Type Name typedef std::unordered_map&lt; std::string, std::size_t &gt; NameHashMap typedef std::unordered_map&lt; std::string, std::shared_ptr&lt; OptionDetails &gt; &gt; OptionMap typedef std::vector&lt; std::string &gt; OptionNames typedef std::unordered_map&lt; std::size_t, OptionValue &gt; ParsedHashMap typedef std::vector&lt; std::string &gt; PositionalList typedef PositionalList::const_iterator PositionalListIterator typedef std::string String"},{"location":"api/namespacecxxopts/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t major uint8_t minor uint8_t patch"},{"location":"api/namespacecxxopts/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr struct cxxopts version   = <code>{CXXOPTS\\_\\_VERSION\\_MAJOR, CXXOPTS\\_\\_VERSION\\_MINOR, CXXOPTS\\_\\_VERSION\\_PATCH}</code>"},{"location":"api/namespacecxxopts/#public-functions","title":"Public Functions","text":"Type Name bool empty (const std::string &amp; s)  CXXOPTS_NODISCARD const std::string &amp; first_or_empty (const OptionNames &amp; long_names)  String &amp; stringAppend (String &amp; s, const String &amp; a)  String &amp; stringAppend (String &amp; s, std::size_t n, char c)  String &amp; stringAppend (String &amp; s, Iterator begin, Iterator end)  std::size_t stringLength (const String &amp; s)  void throw_or_mimic (const std::string &amp; text)  T toLocalString (T &amp;&amp; t)  std::string toUTF8String (T &amp;&amp; t)  std::shared_ptr&lt; Value &gt; value ()  std::shared_ptr&lt; Value &gt; value (T &amp; t)"},{"location":"api/namespacecxxopts/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacecxxopts/#typedef-namehashmap","title":"typedef NameHashMap","text":"<pre><code>using cxxopts::NameHashMap = typedef std::unordered_map&lt;std::string, std::size_t&gt;;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-optionmap","title":"typedef OptionMap","text":"<pre><code>using cxxopts::OptionMap = typedef std::unordered_map&lt;std::string, std::shared_ptr&lt;OptionDetails&gt; &gt;;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-optionnames","title":"typedef OptionNames","text":"<pre><code>using cxxopts::OptionNames = typedef std::vector&lt;std::string&gt;;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-parsedhashmap","title":"typedef ParsedHashMap","text":"<pre><code>using cxxopts::ParsedHashMap = typedef std::unordered_map&lt;std::size_t, OptionValue&gt;;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-positionallist","title":"typedef PositionalList","text":"<pre><code>using cxxopts::PositionalList = typedef std::vector&lt;std::string&gt;;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-positionallistiterator","title":"typedef PositionalListIterator","text":"<pre><code>using cxxopts::PositionalListIterator = typedef PositionalList::const_iterator;\n</code></pre>"},{"location":"api/namespacecxxopts/#typedef-string","title":"typedef String","text":"<pre><code>using cxxopts::String = typedef std::string;\n</code></pre>"},{"location":"api/namespacecxxopts/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacecxxopts/#variable-major","title":"variable major","text":"<pre><code>uint8_t cxxopts::major;\n</code></pre>"},{"location":"api/namespacecxxopts/#variable-minor","title":"variable minor","text":"<pre><code>uint8_t cxxopts::minor;\n</code></pre>"},{"location":"api/namespacecxxopts/#variable-patch","title":"variable patch","text":"<pre><code>uint8_t cxxopts::patch;\n</code></pre>"},{"location":"api/namespacecxxopts/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespacecxxopts/#variable-version","title":"variable version","text":"<pre><code>constexpr struct cxxopts cxxopts::version;\n</code></pre>"},{"location":"api/namespacecxxopts/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts/#function-empty","title":"function empty","text":"<pre><code>inline bool cxxopts::empty (\n    const std::string &amp; s\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-first_or_empty","title":"function first_or_empty","text":"<pre><code>inline CXXOPTS_NODISCARD const std::string &amp; cxxopts::first_or_empty (\n    const OptionNames &amp; long_names\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringappend","title":"function stringAppend","text":"<pre><code>inline String &amp; cxxopts::stringAppend (\n    String &amp; s,\n    const String &amp; a\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringappend_1","title":"function stringAppend","text":"<pre><code>inline String &amp; cxxopts::stringAppend (\n    String &amp; s,\n    std::size_t n,\n    char c\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringappend_2","title":"function stringAppend","text":"<pre><code>template&lt;typename Iterator&gt;\nString &amp; cxxopts::stringAppend (\n    String &amp; s,\n    Iterator begin,\n    Iterator end\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-stringlength","title":"function stringLength","text":"<pre><code>inline std::size_t cxxopts::stringLength (\n    const String &amp; s\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-throw_or_mimic","title":"function throw_or_mimic","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::throw_or_mimic (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-tolocalstring","title":"function toLocalString","text":"<pre><code>template&lt;typename T&gt;\nT cxxopts::toLocalString (\n    T &amp;&amp; t\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-toutf8string","title":"function toUTF8String","text":"<pre><code>template&lt;typename T&gt;\nstd::string cxxopts::toUTF8String (\n    T &amp;&amp; t\n) \n</code></pre>"},{"location":"api/namespacecxxopts/#function-value","title":"function value","text":"<pre><code>template&lt;typename T&gt;\nstd::shared_ptr&lt; Value &gt; cxxopts::value () \n</code></pre>"},{"location":"api/namespacecxxopts/#function-value_1","title":"function value","text":"<pre><code>template&lt;typename T&gt;\nstd::shared_ptr&lt; Value &gt; cxxopts::value (\n    T &amp; t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1_0d1/","title":"Namespace cxxopts","text":"<p>Namespace List &gt; cxxopts</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1exceptions/","title":"Namespace cxxopts::exceptions","text":"<p>Namespace List &gt; cxxopts &gt; exceptions</p>"},{"location":"api/namespacecxxopts_1_1exceptions/#classes","title":"Classes","text":"Type Name class exception class gratuitous_argument_for_option class incorrect_argument_type class invalid_option_format class invalid_option_syntax class missing_argument class no_such_option class option_already_exists class option_has_no_value class option_requires_argument class parsing class requested_option_not_present class specification <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values/","title":"Namespace cxxopts::values","text":"<p>Namespace List &gt; cxxopts &gt; values</p>"},{"location":"api/namespacecxxopts_1_1values/#namespaces","title":"Namespaces","text":"Type Name namespace detail namespace parser_tool"},{"location":"api/namespacecxxopts_1_1values/#classes","title":"Classes","text":"Type Name class abstract_value &lt;typename T&gt; class standard_value &lt;typename T&gt; class standard_value&lt; bool &gt; &lt;&gt; struct type_is_container &lt;typename T&gt; struct type_is_container&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"api/namespacecxxopts_1_1values/#public-functions","title":"Public Functions","text":"Type Name void checked_negate (R &amp; r, T &amp;&amp; t, const std::string &amp;, std::true_type)  void checked_negate (R &amp;, T &amp;&amp;, const std::string &amp; text, std::false_type)  void integer_parser (const std::string &amp; text, T &amp; value)  void parse_value (const std::string &amp; text, T &amp; value)  void parse_value (const std::string &amp; text, bool &amp; value)  void parse_value (const std::string &amp; text, std::string &amp; value)  void parse_value (const std::string &amp; text, std::vector&lt; T &gt; &amp; value)  void parse_value (const std::string &amp; text, char &amp; c)  void stringstream_parser (const std::string &amp; text, T &amp; value)"},{"location":"api/namespacecxxopts_1_1values/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts_1_1values/#function-checked_negate","title":"function checked_negate","text":"<pre><code>template&lt;typename R, typename T&gt;\nvoid cxxopts::values::checked_negate (\n    R &amp; r,\n    T &amp;&amp; t,\n    const std::string &amp;,\n    std::true_type\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-checked_negate_1","title":"function checked_negate","text":"<pre><code>template&lt;typename R, typename T&gt;\nvoid cxxopts::values::checked_negate (\n    R &amp;,\n    T &amp;&amp;,\n    const std::string &amp; text,\n    std::false_type\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-integer_parser","title":"function integer_parser","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::values::integer_parser (\n    const std::string &amp; text,\n    T &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value","title":"function parse_value","text":"<pre><code>template&lt;typename T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type *&gt;\nvoid cxxopts::values::parse_value (\n    const std::string &amp; text,\n    T &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_1","title":"function parse_value","text":"<pre><code>inline void cxxopts::values::parse_value (\n    const std::string &amp; text,\n    bool &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_2","title":"function parse_value","text":"<pre><code>inline void cxxopts::values::parse_value (\n    const std::string &amp; text,\n    std::string &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_3","title":"function parse_value","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::values::parse_value (\n    const std::string &amp; text,\n    std::vector&lt; T &gt; &amp; value\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-parse_value_4","title":"function parse_value","text":"<pre><code>inline void cxxopts::values::parse_value (\n    const std::string &amp; text,\n    char &amp; c\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values/#function-stringstream_parser","title":"function stringstream_parser","text":"<pre><code>template&lt;typename T&gt;\nvoid cxxopts::values::stringstream_parser (\n    const std::string &amp; text,\n    T &amp; value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values_1_1detail/","title":"Namespace cxxopts::values::detail","text":"<p>Namespace List &gt; cxxopts &gt; values &gt; detail</p>"},{"location":"api/namespacecxxopts_1_1values_1_1detail/#classes","title":"Classes","text":"Type Name struct SignedCheck &lt;typename T, B&gt; struct SignedCheck&lt; T, false &gt; &lt;typename T&gt; struct SignedCheck&lt; T, true &gt; &lt;typename T&gt;"},{"location":"api/namespacecxxopts_1_1values_1_1detail/#public-functions","title":"Public Functions","text":"Type Name void check_signed_range (bool negative, U value, const std::string &amp; text)"},{"location":"api/namespacecxxopts_1_1values_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts_1_1values_1_1detail/#function-check_signed_range","title":"function check_signed_range","text":"<pre><code>template&lt;typename T, typename U&gt;\nvoid cxxopts::values::detail::check_signed_range (\n    bool negative,\n    U value,\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/","title":"Namespace cxxopts::values::parser_tool","text":"<p>Namespace List &gt; cxxopts &gt; values &gt; parser_tool</p>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#classes","title":"Classes","text":"Type Name struct ArguDesc struct IntegerDesc"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#public-functions","title":"Public Functions","text":"Type Name bool IsFalseText (const std::string &amp; text)  bool IsTrueText (const std::string &amp; text)  ArguDesc ParseArgument (const char * arg, bool &amp; matched)  IntegerDesc SplitInteger (const std::string &amp; text)  OptionNames split_option_names (const std::string &amp; text)"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-isfalsetext","title":"function IsFalseText","text":"<pre><code>inline bool cxxopts::values::parser_tool::IsFalseText (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-istruetext","title":"function IsTrueText","text":"<pre><code>inline bool cxxopts::values::parser_tool::IsTrueText (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-parseargument","title":"function ParseArgument","text":"<pre><code>inline ArguDesc cxxopts::values::parser_tool::ParseArgument (\n    const char * arg,\n    bool &amp; matched\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-splitinteger","title":"function SplitInteger","text":"<pre><code>inline IntegerDesc cxxopts::values::parser_tool::SplitInteger (\n    const std::string &amp; text\n) \n</code></pre>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool/#function-split_option_names","title":"function split_option_names","text":"<pre><code>inline OptionNames cxxopts::values::parser_tool::split_option_names (\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/namespacecxxopts_1_1values_1_1parser__tool_1_1_0d1/","title":"Namespace cxxopts::values::parser_tool","text":"<p>Namespace List &gt; parser_tool</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/noop__record__logger_8hpp/","title":"File noop_record_logger.hpp","text":"<p>FileList &gt; src &gt; noop_record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/record_logger.hpp\"</code></li> </ul>"},{"location":"api/noop__record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/noop__record__logger_8hpp/#classes","title":"Classes","text":"Type Name class noop_record_logger <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/noop_record_logger.hpp</code></p>"},{"location":"api/noop__record__logger_8hpp_source/","title":"File noop_record_logger.hpp","text":"<p>File List &gt; src &gt; noop_record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr/record_logger.hpp\"\n\nnamespace ILLIXR {\nclass noop_record_logger : public record_logger {\nprotected:\n    virtual void log(const record&amp; r) override {\n        r.mark_used();\n    }\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugin_8cpp/","title":"File plugin.cpp","text":"<p>FileList &gt; src &gt; plugin.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;unistd.h&gt;</code></li> <li><code>#include &lt;yaml-cpp/yaml.h&gt;</code></li> </ul>"},{"location":"api/plugin_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name ILLIXR::runtime * r   = <code>nullptr</code>"},{"location":"api/plugin_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/plugin_8cpp/#variable-r","title":"variable r","text":"<pre><code>ILLIXR::runtime* r;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/plugin.cpp</code></p>"},{"location":"api/plugin_8cpp_source/","title":"File plugin.cpp","text":"<p>File List &gt; src &gt; plugin.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr.hpp\"\n#include \"illixr/error_util.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;unistd.h&gt;\n#include &lt;yaml-cpp/yaml.h&gt;\n\nILLIXR::runtime* r = nullptr;\n\nusing namespace ILLIXR;\n\nint ILLIXR::run(const cxxopts::ParseResult&amp; options) {\n    std::chrono::seconds     run_duration;\n    std::vector&lt;std::string&gt; plugins;\n\n    r = ILLIXR::runtime_factory();\n\n#ifndef NDEBUG\n    const bool enable_pre_sleep = ILLIXR::str_to_bool(getenv_or(\"ILLIXR_ENABLE_PRE_SLEEP\", \"False\"));\n    if (enable_pre_sleep) {\n        const pid_t pid = getpid();\n        spdlog::get(\"illixr\")-&gt;info(\"[main] Pre-sleep enabled.\");\n        spdlog::get(\"illixr\")-&gt;info(\"[main] PID: {}\", pid);\n        spdlog::get(\"illixr\")-&gt;info(\"[main] Sleeping for {} seconds...\", ILLIXR_PRE_SLEEP_DURATION);\n        sleep(ILLIXR_PRE_SLEEP_DURATION);\n        spdlog::get(\"illixr\")-&gt;info(\"[main] Resuming...\");\n    }\n#endif \n    // read in yaml config file\n    YAML::Node config;\n    if (options.count(\"yaml\")) {\n        std::cout &lt;&lt; \"Reading \" &lt;&lt; options[\"yaml\"].as&lt;std::string&gt;() &lt;&lt; std::endl;\n        config = YAML::LoadFile(options[\"yaml\"].as&lt;std::string&gt;());\n    }\n    if (options.count(\"duration\")) {\n        run_duration = std::chrono::seconds{options[\"duration\"].as&lt;long&gt;()};\n    } else if (config[\"duration\"]) {\n        run_duration = std::chrono::seconds{config[\"duration\"].as&lt;long&gt;()};\n    } else {\n        run_duration = getenv(\"ILLIXR_RUN_DURATION\")\n            ? std::chrono::seconds{std::stol(std::string{getenv(\"ILLIXR_RUN_DURATION\")})}\n            : ILLIXR_RUN_DURATION_DEFAULT;\n    }\n    GET_STRING(data, ILLIXR_DATA)\n    GET_STRING(demo_data, ILLIXR_DEMO_DATA)\n    GET_BOOL(enable_offload, ILLIXR_OFFLOAD_ENABLE)\n    GET_BOOL(alignment_enable, ILLIXR_ALIGNMENT_ENABLE)\n    GET_BOOL(enable_verbose_errors, ILLIXR_ENABLE_VERBOSE_ERRORS)\n    GET_BOOL(enable_pre_sleep, ILLIXR_ENABLE_PRE_SLEEP)\n    GET_STRING(realsense_cam, REALSENSE_CAM)\n\n    setenv(\"__GL_MaxFramesAllowed\", \"1\", false);\n    setenv(\"__GL_SYNC_TO_VBLANK\", \"1\", false);\n    bool have_plugins = false;\n    // run entry supersedes plugins entry\n    for (auto item : {\"plugins\", \"run\"}) {\n        if (options.count(item)) {\n            plugins      = options[item].as&lt;std::vector&lt;std::string&gt;&gt;();\n            have_plugins = true;\n        } else if (config[item]) {\n            std::stringstream tss(config[item].as&lt;std::string&gt;());\n            while (tss.good()) {\n                std::string substr;\n                getline(tss, substr, ',');\n                plugins.push_back(substr);\n            }\n            have_plugins = true;\n        }\n    }\n\n    if (!have_plugins) {\n        std::cout &lt;&lt; \"No plugins specified.\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"A list of plugins must be given on the command line or in a YAML file\" &lt;&lt; std::endl;\n        return EXIT_FAILURE;\n    }\n    std::vector&lt;std::string&gt; visualizers;\n    if (options.count(\"vis\")) {\n        visualizers = options[\"vis\"].as&lt;std::vector&lt;std::string&gt;&gt;();\n    } else if (config[\"visualizers\"]) {\n        std::stringstream vss(config[\"visualizers\"].as&lt;std::string&gt;());\n        while (vss.good()) {\n            std::string substr;\n            getline(vss, substr, ',');\n            visualizers.push_back(substr);\n        }\n    }\n    if (!visualizers.empty())\n        plugins.push_back(visualizers[0]);\n\n    if (config[\"install_prefix\"]) {\n        std::string temp_path(getenv(\"LD_LIBRARY_PATH\"));\n        temp_path = config[\"install_prefix\"].as&lt;std::string&gt;() + \":\" + temp_path;\n        setenv(\"LD_LIBRARY_PATH\", temp_path.c_str(), true);\n    }\n\n    RAC_ERRNO_MSG(\"main after creating runtime\");\n\n    std::vector&lt;std::string&gt; lib_paths;\n    std::transform(plugins.begin(), plugins.end(), std::back_inserter(lib_paths), [](const std::string&amp; arg) {\n        return \"libplugin.\" + arg + STRINGIZE(ILLIXR_BUILD_SUFFIX) + \".so\";\n    });\n\n    RAC_ERRNO_MSG(\"main before loading dynamic libraries\");\n    r-&gt;load_so(lib_paths);\n\n    cancellable_sleep cs;\n    std::thread       th{[&amp;] {\n        cs.sleep(run_duration);\n        r-&gt;stop();\n    }};\n\n    r-&gt;wait(); // blocks until shutdown is r-&gt;stop()\n\n    // cancel our sleep, so we can join the other thread\n    cs.cancel();\n    th.join();\n\n    delete r;\n    return 0;\n}\n</code></pre>"},{"location":"api/runtime__impl_8cpp/","title":"File runtime_impl.cpp","text":"<p>FileList &gt; src &gt; runtime_impl.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/runtime.hpp\"</code></li> <li><code>#include \"illixr/dynamic_lib.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/extended_window.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/plugin.hpp\"</code></li> <li><code>#include \"illixr/record_logger.hpp\"</code></li> <li><code>#include \"illixr/stoplight.hpp\"</code></li> <li><code>#include \"illixr/switchboard.hpp\"</code></li> <li><code>#include \"sqlite_record_logger.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/sinks/basic_file_sink.h&gt;</code></li> <li><code>#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/runtime__impl_8cpp/#classes","title":"Classes","text":"Type Name class runtime_impl"},{"location":"api/runtime__impl_8cpp/#public-functions","title":"Public Functions","text":"Type Name runtime * runtime_factory ()  void spdlogger (const std::string &amp; name, const char * log_level)"},{"location":"api/runtime__impl_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/runtime__impl_8cpp/#function-runtime_factory","title":"function runtime_factory","text":"<pre><code>runtime * runtime_factory () \n</code></pre>"},{"location":"api/runtime__impl_8cpp/#function-spdlogger","title":"function spdlogger","text":"<pre><code>void spdlogger (\n    const std::string &amp; name,\n    const char * log_level\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/runtime_impl.cpp</code></p>"},{"location":"api/runtime__impl_8cpp_source/","title":"File runtime_impl.cpp","text":"<p>File List &gt; src &gt; runtime_impl.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"illixr/runtime.hpp\"\n\n#include \"illixr/dynamic_lib.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/extended_window.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/plugin.hpp\"\n#include \"illixr/record_logger.hpp\"\n#include \"illixr/stoplight.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"sqlite_record_logger.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;GL/glx.h&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/sinks/basic_file_sink.h&gt;\n#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\n\nvoid spdlogger(const std::string&amp; name, const char* log_level) {\n    if (!log_level) {\n#ifdef NDEBUG\n        log_level = \"warn\";\n#else\n        log_level = \"debug\";\n#endif\n    }\n    std::vector&lt;spdlog::sink_ptr&gt; sinks;\n    sinks.push_back(std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;());\n    sinks.push_back(std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(\"logs/\" + name + \".log\"));\n    auto logger = std::make_shared&lt;spdlog::logger&gt;(name, begin(sinks), end(sinks));\n    logger-&gt;set_level(spdlog::level::from_str(log_level));\n    spdlog::register_logger(logger);\n}\n\nclass runtime_impl : public runtime {\npublic:\n    explicit runtime_impl() {\n        spdlogger(\"illixr\", std::getenv(\"ILLIXR_LOG_LEVEL\"));\n        pb.register_impl&lt;record_logger&gt;(std::make_shared&lt;sqlite_record_logger&gt;());\n        pb.register_impl&lt;gen_guid&gt;(std::make_shared&lt;gen_guid&gt;());\n        pb.register_impl&lt;switchboard&gt;(std::make_shared&lt;switchboard&gt;(&amp;pb));\n#if !defined(ILLIXR_MONADO) &amp;&amp; !defined(ILLIXR_VULKAN) // the extended window is only needed for our native OpenGL backend\n        pb.register_impl&lt;xlib_gl_extended_window&gt;(\n            std::make_shared&lt;xlib_gl_extended_window&gt;(display_params::width_pixels, display_params::height_pixels, nullptr));\n#endif\n        pb.register_impl&lt;Stoplight&gt;(std::make_shared&lt;Stoplight&gt;());\n        pb.register_impl&lt;RelativeClock&gt;(std::make_shared&lt;RelativeClock&gt;());\n    }\n\n    void load_so(const std::vector&lt;std::string&gt;&amp; so_paths) override {\n        RAC_ERRNO_MSG(\"runtime_impl before creating any dynamic library\");\n\n        std::transform(so_paths.cbegin(), so_paths.cend(), std::back_inserter(libs), [](const auto&amp; so_path) {\n            RAC_ERRNO_MSG(\"runtime_impl before creating the dynamic library\");\n            return dynamic_lib::create(so_path);\n        });\n\n        RAC_ERRNO_MSG(\"runtime_impl after creating the dynamic libraries\");\n\n        std::vector&lt;plugin_factory&gt; plugin_factories;\n        std::transform(libs.cbegin(), libs.cend(), std::back_inserter(plugin_factories), [](const auto&amp; lib) {\n            return lib.template get&lt;plugin* (*) (phonebook*)&gt;(\"this_plugin_factory\");\n        });\n\n        RAC_ERRNO_MSG(\"runtime_impl after generating plugin factories\");\n\n        std::transform(plugin_factories.cbegin(), plugin_factories.cend(), std::back_inserter(plugins),\n                       [this](const auto&amp; plugin_factory) {\n                           RAC_ERRNO_MSG(\"runtime_impl before building the plugin\");\n                           return std::unique_ptr&lt;plugin&gt;{plugin_factory(&amp;pb)};\n                       });\n\n        std::for_each(plugins.cbegin(), plugins.cend(), [](const auto&amp; plugin) {\n            // Well-behaved plugins (any derived from threadloop) start there threads here, and then wait on the Stoplight.\n            plugin-&gt;start();\n        });\n\n        // This actually kicks off the plugins\n        pb.lookup_impl&lt;RelativeClock&gt;()-&gt;start();\n        pb.lookup_impl&lt;Stoplight&gt;()-&gt;signal_ready();\n    }\n\n    void load_so(const std::string_view&amp; so) override {\n        auto lib                 = dynamic_lib::create(so);\n        auto this_plugin_factory = lib.get&lt;plugin* (*) (phonebook*)&gt;(\"this_plugin_factory\");\n        load_plugin_factory(this_plugin_factory);\n        libs.push_back(std::move(lib));\n    }\n\n    void load_plugin_factory(plugin_factory plugin_main) override {\n        plugins.emplace_back(plugin_main(&amp;pb));\n        plugins.back()-&gt;start();\n    }\n\n    void wait() override {\n        // We don't want wait() returning before all the plugin threads have been joined.\n        // That would cause a nasty race-condition if the client tried to delete the runtime right after wait() returned.\n        pb.lookup_impl&lt;Stoplight&gt;()-&gt;wait_for_shutdown_complete();\n    }\n\n    void stop() override {\n        pb.lookup_impl&lt;Stoplight&gt;()-&gt;signal_should_stop();\n        // After this point, threads may exit their main loops\n        // They still have destructors and still have to be joined.\n\n        pb.lookup_impl&lt;switchboard&gt;()-&gt;stop();\n        // After this point, Switchboard's internal thread-workers which power synchronous callbacks are stopped and joined.\n\n        for (const std::unique_ptr&lt;plugin&gt;&amp; plugin : plugins) {\n            plugin-&gt;stop();\n            // Each plugin gets joined in its stop\n        }\n\n        // Tell runtime::wait() that it can return\n        pb.lookup_impl&lt;Stoplight&gt;()-&gt;signal_shutdown_complete();\n    }\n\n    ~runtime_impl() override {\n        if (!pb.lookup_impl&lt;Stoplight&gt;()-&gt;check_shutdown_complete()) {\n            stop();\n        }\n        // This will be re-enabled in #225\n        // assert(errno == 0 &amp;&amp; \"errno was set during run. Maybe spurious?\");\n        /*\n          Note that this assertion can have false positives AND false negatives!\n          - False positive because the contract of some functions specifies that errno is only meaningful if the return code was\n          an error [1].\n            - We will try to mitigate this by clearing errno on success in ILLIXR.\n          - False negative if some intervening call clears errno.\n            - We will try to mitigate this by checking for errors immediately after a call.\n\n          Despite these mitigations, the best way to catch errors is to check errno immediately after a calling function.\n\n          [1] https://cboard.cprogramming.com/linux-programming/119957-xlib-perversity.html\n         */\n    }\n\nprivate:\n    // I have to keep the dynamic libs in scope until the program is dead\n    std::vector&lt;dynamic_lib&gt;             libs;\n    phonebook                            pb;\n    std::vector&lt;std::unique_ptr&lt;plugin&gt;&gt; plugins;\n};\n\nextern \"C\" runtime* runtime_factory() {\n    RAC_ERRNO_MSG(\"runtime_impl before creating the runtime\");\n    return new runtime_impl{};\n}\n</code></pre>"},{"location":"api/sqlite__record__logger_8hpp/","title":"File sqlite_record_logger.hpp","text":"<p>FileList &gt; src &gt; sqlite_record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/concurrentqueue/blockingconcurrentqueue.hpp\"</code></li> <li><code>#include \"illixr/error_util.hpp\"</code></li> <li><code>#include \"illixr/global_module_defs.hpp\"</code></li> <li><code>#include \"illixr/record_logger.hpp\"</code></li> <li><code>#include \"sqlite3pp/sqlite3pp.hpp\"</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/sqlite__record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/sqlite__record__logger_8hpp/#classes","title":"Classes","text":"Type Name class sqlite_record_logger class sqlite_thread <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/sqlite_record_logger.hpp</code></p>"},{"location":"api/sqlite__record__logger_8hpp_source/","title":"File sqlite_record_logger.hpp","text":"<p>File List &gt; src &gt; sqlite_record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/concurrentqueue/blockingconcurrentqueue.hpp\"\n#include \"illixr/error_util.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/record_logger.hpp\"\n#include \"sqlite3pp/sqlite3pp.hpp\"\n\n#include &lt;filesystem&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;thread&gt;\n\nnamespace ILLIXR {\n\nclass sqlite_thread {\npublic:\n    sqlite3pp::database prep_db() {\n        RAC_ERRNO_MSG(\"sqlite_record_logger at start of prep_db\");\n\n        if (!std::filesystem::exists(dir)) {\n            std::filesystem::create_directory(dir);\n        }\n\n        const std::string path = dir / (table_name + std::string{\".sqlite\"});\n\n        RAC_ERRNO_MSG(\"sqlite_record_logger before sqlite3pp::database\");\n        sqlite3pp::database db{path.c_str()};\n        RAC_ERRNO_MSG(\"sqlite_record_logger after sqlite3pp::database\");\n\n        return db;\n    }\n\n    std::string prep_insert_str() {\n        RAC_ERRNO_MSG(\"sqlite_record_logger at start of prep_insert_str\");\n\n        std::string drop_table_string = std::string{\"DROP TABLE IF EXISTS \"} + table_name + std::string{\";\"};\n        db.execute(drop_table_string.c_str());\n        RAC_ERRNO_MSG(\"sqlite_record_logger after drop table execute.\");\n\n        std::string create_table_string = std::string{\"CREATE TABLE \"} + table_name + std::string{\"(\"};\n        for (unsigned int i = 0; i &lt; rh.get_columns(); ++i) {\n            create_table_string += rh.get_column_name(i) + std::string{\" \"};\n            if (false) {\n            } else if (rh.get_column_type(i) == typeid(std::size_t)) {\n                create_table_string += std::string{\"INTEGER\"};\n            } else if (rh.get_column_type(i) == typeid(bool)) {\n                create_table_string += std::string{\"INTEGER\"};\n            } else if (rh.get_column_type(i) == typeid(double)) {\n                create_table_string += std::string{\"REAL\"}; // For performance timing. Will be deleted when implementing #208.\n            } else if (rh.get_column_type(i) == typeid(std::chrono::nanoseconds)) {\n                create_table_string += std::string{\"INTEGER\"};\n            } else if (rh.get_column_type(i) == typeid(std::chrono::high_resolution_clock::time_point)) {\n                create_table_string += std::string{\"INTEGER\"};\n            } else if (rh.get_column_type(i) == typeid(duration)) {\n                create_table_string += std::string{\"INTEGER\"};\n            } else if (rh.get_column_type(i) == typeid(time_point)) {\n                create_table_string += std::string{\"INTEGER\"};\n            } else if (rh.get_column_type(i) == typeid(std::string)) {\n                create_table_string += std::string{\"TEXT\"};\n            } else {\n                throw std::runtime_error{std::string{\"type \"} + std::string{rh.get_column_type(i).name()} +\n                                         std::string{\" not found\"}};\n            }\n            create_table_string += std::string{\", \"};\n        }\n        create_table_string.erase(create_table_string.size() - 2);\n        create_table_string += std::string{\");\"};\n\n        RAC_ERRNO_MSG(\"sqlite_record_logger before create table execute\");\n        db.execute(create_table_string.c_str());\n        RAC_ERRNO_MSG(\"sqlite_record_logger after create table execute\");\n\n        std::string insert_string = std::string{\"INSERT INTO \"} + table_name + std::string{\" VALUES (\"};\n        for (unsigned int i = 0; i &lt; rh.get_columns(); ++i) {\n            insert_string += std::string{\"?\"} + std::to_string(i + 1) + std::string{\", \"};\n        }\n        insert_string.erase(insert_string.size() - 2);\n        insert_string += std::string{\");\"};\n        return insert_string;\n    }\n\n    sqlite_thread(const record_header&amp; rh_)\n        : rh{rh_}\n        , table_name{rh.get_name()}\n        , db{prep_db()}\n        , insert_str{prep_insert_str()}\n        , insert_cmd{db, insert_str.c_str()}\n        , thread{std::bind(&amp;sqlite_thread::pull_queue, this)} { }\n\n    void pull_queue() {\n        const std::size_t   max_record_batch_size = 1024 * 256;\n        std::vector&lt;record&gt; record_batch{max_record_batch_size};\n        std::size_t         actual_batch_size;\n\n        spdlog::get(\"illixr\")-&gt;set_pattern(\"[%Y-%m-%d %H:%M:%S.%e] [%n] [%^%l%$] [sqlite_record_logger] thread %t %v\");\n        spdlog::get(\"illixr\")-&gt;debug(\"{}\", table_name);\n        spdlog::get(\"illixr\")-&gt;set_pattern(\"%+\");\n\n        std::size_t processed = 0;\n        while (!terminate.load()) {\n            std::this_thread::sleep_for(std::chrono::seconds{1});\n            // Uncomment this block to log in \"real time\";\n            // Otherwise, everything gets loged \"post real time\".\n            /*\n            const std::chrono::seconds max_record_match_wait_time {10};\n            actual_batch_size = queue.wait_dequeue_bulk_timed(record_batch.begin(), record_batch.size(),\n            max_record_match_wait_time); process(record_batch, actual_batch_size); processed += actual_batch_size;\n            */\n        }\n\n        // We got the terminate commnad,\n        // So drain whatever is left in the queue.\n        // But don't wait around once it is empty.\n        std::size_t post_processed = 0;\n        while ((actual_batch_size = queue.try_dequeue_bulk(record_batch.begin(), record_batch.size()))) {\n            process(record_batch, actual_batch_size);\n            post_processed += actual_batch_size;\n        }\n        spdlog::get(\"illixr\")-&gt;debug(\"[sqlite_record_logger] Drained {} (sqlite); {}/{} done post real time\", table_name,\n                                     post_processed, (processed + post_processed));\n    }\n\n    void process(const std::vector&lt;record&gt;&amp; record_batch, std::size_t batch_size) {\n        sqlite3pp::transaction xct{db};\n        for (std::size_t i = 0; i &lt; batch_size; ++i) {\n            // TODO(performance): reuse the sqlite3pp statement\n            // This currently has to be 'reinterpreted' for every iteration.\n            sqlite3pp::command cmd{db, insert_str.c_str()};\n            const record&amp;      r = record_batch[i];\n            for (unsigned int j = 0; j &lt; rh.get_columns(); ++j) {\n                /*\n                  If you get a `std::bad_any_cast` here, make sure the user didn't lie about record.get_record_header().\n                  The types there should be the same as those in record.get_values().\n                */\n                if (false) {\n                } else if (rh.get_column_type(j) == typeid(std::size_t)) {\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(r.get_value&lt;std::size_t&gt;(j)));\n                } else if (rh.get_column_type(j) == typeid(bool)) {\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(r.get_value&lt;bool&gt;(j)));\n                } else if (rh.get_column_type(j) == typeid(double)) {\n                    cmd.bind(j + 1, r.get_value&lt;double&gt;(j));\n                } else if (rh.get_column_type(j) == typeid(std::chrono::nanoseconds)) {\n                    auto val = r.get_value&lt;duration&gt;(j);\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh.get_column_type(j) == typeid(std::chrono::high_resolution_clock::time_point)) {\n                    auto val = r.get_value&lt;std::chrono::high_resolution_clock::time_point&gt;(j).time_since_epoch();\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh.get_column_type(j) == typeid(duration)) {\n                    auto val = r.get_value&lt;duration&gt;(j);\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh.get_column_type(j) == typeid(time_point)) {\n                    auto val = r.get_value&lt;time_point&gt;(j).time_since_epoch();\n                    cmd.bind(j + 1, static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count()));\n                } else if (rh.get_column_type(j) == typeid(std::string)) {\n                    // r.get_value&lt;std::string&gt;(j) returns a std::string temporary\n                    // c_str() returns a pointer into that std::string temporary\n                    // Therefore, need to copy.\n                    cmd.bind(j + 1, r.get_value&lt;std::string&gt;(j).c_str(), sqlite3pp::copy);\n                } else {\n                    throw std::runtime_error{std::string{\"type \"} + std::string{rh.get_column_type(j).name()} +\n                                             std::string{\" not implemented\"}};\n                }\n            }\n            RAC_ERRNO_MSG(\"sqlite_record_logger set errno before process cmd execute\");\n\n            cmd.execute();\n            RAC_ERRNO_MSG(\"sqlite_record_logger after process cmd execute\");\n        }\n        xct.commit();\n    }\n\n    void put_queue(const std::vector&lt;record&gt;&amp; buffer_in) {\n        queue.enqueue_bulk(buffer_in.begin(), buffer_in.size());\n    }\n\n    void put_queue(const record&amp; record_in) {\n        queue.enqueue(record_in);\n    }\n\n    ~sqlite_thread() {\n        terminate.store(true);\n        thread.join();\n    }\n\nprivate:\n    static const std::filesystem::path          dir;\n    const record_header&amp;                        rh;\n    std::string                                 table_name;\n    sqlite3pp::database                         db;\n    std::string                                 insert_str;\n    sqlite3pp::command                          insert_cmd;\n    moodycamel::BlockingConcurrentQueue&lt;record&gt; queue;\n    std::atomic&lt;bool&gt;                           terminate{false};\n    std::thread                                 thread;\n};\n\nconst std::filesystem::path sqlite_thread::dir{\"metrics\"};\n\nclass sqlite_record_logger : public record_logger {\nprivate:\n    sqlite_thread&amp; get_sqlite_thread(const record&amp; r) {\n        const record_header&amp; rh = r.get_record_header();\n        {\n            const std::shared_lock&lt;std::shared_mutex&gt; lock{_m_registry_lock};\n            auto                                      result = registered_tables.find(rh.get_id());\n            if (result != registered_tables.cend()) {\n                return result-&gt;second;\n            }\n        }\n        const std::unique_lock&lt;std::shared_mutex&gt; lock{_m_registry_lock};\n        auto                                      pair = registered_tables.try_emplace(rh.get_id(), rh);\n        return pair.first-&gt;second;\n    }\n\nprotected:\n    virtual void log(const std::vector&lt;record&gt;&amp; r) override {\n        if (!r.empty()) {\n            get_sqlite_thread(r[0]).put_queue(r);\n        }\n    }\n\n    virtual void log(const record&amp; r) override {\n        get_sqlite_thread(r).put_queue(r);\n    }\n\nprivate:\n    std::unordered_map&lt;std::size_t, sqlite_thread&gt; registered_tables;\n    std::shared_mutex                              _m_registry_lock;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/stdout__record__logger_8hpp/","title":"File stdout_record_logger.hpp","text":"<p>FileList &gt; src &gt; stdout_record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/data_format.hpp\"</code></li> <li><code>#include \"illixr/record_logger.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"api/stdout__record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR"},{"location":"api/stdout__record__logger_8hpp/#classes","title":"Classes","text":"Type Name class stdout_record_logger <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/stdout_record_logger.hpp</code></p>"},{"location":"api/stdout__record__logger_8hpp_source/","title":"File stdout_record_logger.hpp","text":"<p>File List &gt; src &gt; stdout_record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/data_format.hpp\"\n#include \"illixr/record_logger.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\nnamespace ILLIXR {\nclass stdout_record_logger : public record_logger {\nprotected:\n    virtual void log(const record&amp; r) override {\n        const record_header&amp; rh = r.get_record_header();\n        for (unsigned i = 0; i &lt; rh.get_columns(); ++i) {\n            std::cout &lt;&lt; rh.get_column_name(i) &lt;&lt; ',';\n            if (false) {\n            } else if (rh.get_column_type(i) == typeid(std::size_t)) {\n                std::cout &lt;&lt; r.get_value&lt;std::size_t&gt;(i);\n            } else if (rh.get_column_type(i) == typeid(bool)) {\n                std::cout &lt;&lt; std::boolalpha &lt;&lt; r.get_value&lt;bool&gt;(i);\n            } else if (rh.get_column_type(i) == typeid(double)) {\n                std::cout &lt;&lt; r.get_value&lt;double&gt;(i);\n            } else if (rh.get_column_type(i) == typeid(duration)) {\n                auto val = r.get_value&lt;duration&gt;(i);\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(time_point)) {\n                auto val = r.get_value&lt;time_point&gt;(i).time_since_epoch();\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(std::chrono::nanoseconds)) {\n                auto val = r.get_value&lt;std::chrono::nanoseconds&gt;(i);\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(std::chrono::high_resolution_clock::time_point)) {\n                auto val = r.get_value&lt;std::chrono::high_resolution_clock::time_point&gt;(i).time_since_epoch();\n                std::cout &lt;&lt; static_cast&lt;long long&gt;(std::chrono::nanoseconds{val}.count());\n            } else if (rh.get_column_type(i) == typeid(std::string)) {\n                std::cout &lt;&lt; r.get_value&lt;std::string&gt;(i);\n            } else {\n                std::ostringstream ss;\n                ss &lt;&lt; \"type \" &lt;&lt; rh.get_column_type(i).name() &lt;&lt; \" (used in \" &lt;&lt; rh.get_name() &lt;&lt; \") is not implemented.\\n\";\n                throw std::runtime_error{ss.str()};\n            }\n            std::cout &lt;&lt; ',';\n        }\n        std::cout &lt;&lt; '\\n';\n    }\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/","title":"Struct cxxopts::HelpGroupDetails","text":"<p>ClassList &gt; cxxopts &gt; HelpGroupDetails</p>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#public-attributes","title":"Public Attributes","text":"Type Name std::string description   = <code>{}</code> std::string name   = <code>{}</code> std::vector&lt; HelpOptionDetails &gt; options   = <code>{}</code>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1HelpGroupDetails/#variable-description","title":"variable description","text":"<pre><code>std::string cxxopts::HelpGroupDetails::description;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#variable-name","title":"variable name","text":"<pre><code>std::string cxxopts::HelpGroupDetails::name;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpGroupDetails/#variable-options","title":"variable options","text":"<pre><code>std::vector&lt;HelpOptionDetails&gt; cxxopts::HelpGroupDetails::options;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/","title":"Struct cxxopts::HelpOptionDetails","text":"<p>ClassList &gt; cxxopts &gt; HelpOptionDetails</p>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#public-attributes","title":"Public Attributes","text":"Type Name std::string arg_help std::string default_value String desc bool has_default bool has_implicit std::string implicit_value bool is_boolean bool is_container OptionNames l std::string s"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-arg_help","title":"variable arg_help","text":"<pre><code>std::string cxxopts::HelpOptionDetails::arg_help;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-default_value","title":"variable default_value","text":"<pre><code>std::string cxxopts::HelpOptionDetails::default_value;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-desc","title":"variable desc","text":"<pre><code>String cxxopts::HelpOptionDetails::desc;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-has_default","title":"variable has_default","text":"<pre><code>bool cxxopts::HelpOptionDetails::has_default;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-has_implicit","title":"variable has_implicit","text":"<pre><code>bool cxxopts::HelpOptionDetails::has_implicit;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-implicit_value","title":"variable implicit_value","text":"<pre><code>std::string cxxopts::HelpOptionDetails::implicit_value;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-is_boolean","title":"variable is_boolean","text":"<pre><code>bool cxxopts::HelpOptionDetails::is_boolean;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-is_container","title":"variable is_container","text":"<pre><code>bool cxxopts::HelpOptionDetails::is_container;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-l","title":"variable l","text":"<pre><code>OptionNames cxxopts::HelpOptionDetails::l;\n</code></pre>"},{"location":"api/structcxxopts_1_1HelpOptionDetails/#variable-s","title":"variable s","text":"<pre><code>std::string cxxopts::HelpOptionDetails::s;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1Option/","title":"Struct cxxopts::Option","text":"<p>ClassList &gt; cxxopts &gt; Option</p>"},{"location":"api/structcxxopts_1_1Option/#public-attributes","title":"Public Attributes","text":"Type Name std::string arg_help_ std::string desc_ std::string opts_ std::shared_ptr&lt; const Value &gt; value_"},{"location":"api/structcxxopts_1_1Option/#public-functions","title":"Public Functions","text":"Type Name Option (std::string opts, std::string desc, std::shared_ptr&lt; const Value &gt; value=::cxxopts::value&lt; bool &gt;(), std::string arg_help=\"\")"},{"location":"api/structcxxopts_1_1Option/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1Option/#variable-arg_help_","title":"variable arg_help_","text":"<pre><code>std::string cxxopts::Option::arg_help_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#variable-desc_","title":"variable desc_","text":"<pre><code>std::string cxxopts::Option::desc_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#variable-opts_","title":"variable opts_","text":"<pre><code>std::string cxxopts::Option::opts_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#variable-value_","title":"variable value_","text":"<pre><code>std::shared_ptr&lt;const Value&gt; cxxopts::Option::value_;\n</code></pre>"},{"location":"api/structcxxopts_1_1Option/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structcxxopts_1_1Option/#function-option","title":"function Option","text":"<pre><code>inline cxxopts::Option::Option (\n    std::string opts,\n    std::string desc,\n    std::shared_ptr&lt; const Value &gt; value=::cxxopts::value&lt; bool &gt;(),\n    std::string arg_help=\"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck/","title":"Struct cxxopts::values::detail::SignedCheck","text":"<p>template &lt;typename T, bool B&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; detail &gt; SignedCheck</p> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/","title":"Struct cxxopts::values::detail::SignedCheck&lt; T, false &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; detail &gt; SignedCheck&lt; T, false &gt;</p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/#public-functions","title":"Public Functions","text":"Type Name void operator() (bool, U, const std::string &amp;) const"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01false_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;typename U&gt;\ninline void cxxopts::values::detail::SignedCheck&lt; T, false &gt;::operator() (\n    bool,\n    U,\n    const std::string &amp;\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/","title":"Struct cxxopts::values::detail::SignedCheck&lt; T, true &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; detail &gt; SignedCheck&lt; T, true &gt;</p>"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/#public-functions","title":"Public Functions","text":"Type Name void operator() (bool negative, U u, const std::string &amp; text)"},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1detail_1_1SignedCheck_3_01T_00_01true_01_4/#function-operator","title":"function operator()","text":"<pre><code>template&lt;typename U&gt;\ninline void cxxopts::values::detail::SignedCheck&lt; T, true &gt;::operator() (\n    bool negative,\n    U u,\n    const std::string &amp; text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/","title":"Struct cxxopts::values::parser_tool::ArguDesc","text":"<p>ClassList &gt; cxxopts &gt; values &gt; parser_tool &gt; ArguDesc</p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#public-attributes","title":"Public Attributes","text":"Type Name std::string arg_name   = <code>\"\"</code> bool grouping   = <code>false</code> bool set_value   = <code>false</code> std::string value   = <code>\"\"</code>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-arg_name","title":"variable arg_name","text":"<pre><code>std::string cxxopts::values::parser_tool::ArguDesc::arg_name;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-grouping","title":"variable grouping","text":"<pre><code>bool cxxopts::values::parser_tool::ArguDesc::grouping;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-set_value","title":"variable set_value","text":"<pre><code>bool cxxopts::values::parser_tool::ArguDesc::set_value;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1ArguDesc/#variable-value","title":"variable value","text":"<pre><code>std::string cxxopts::values::parser_tool::ArguDesc::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/","title":"Struct cxxopts::values::parser_tool::IntegerDesc","text":"<p>ClassList &gt; cxxopts &gt; values &gt; parser_tool &gt; IntegerDesc</p>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#public-attributes","title":"Public Attributes","text":"Type Name std::string base   = <code>\"\"</code> std::string negative   = <code>\"\"</code> std::string value   = <code>\"\"</code>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#variable-base","title":"variable base","text":"<pre><code>std::string cxxopts::values::parser_tool::IntegerDesc::base;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#variable-negative","title":"variable negative","text":"<pre><code>std::string cxxopts::values::parser_tool::IntegerDesc::negative;\n</code></pre>"},{"location":"api/structcxxopts_1_1values_1_1parser__tool_1_1IntegerDesc/#variable-value","title":"variable value","text":"<pre><code>std::string cxxopts::values::parser_tool::IntegerDesc::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container/","title":"Struct cxxopts::values::type_is_container","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; type_is_container</p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr bool value   = <code>false</code>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1type__is__container/#variable-value","title":"variable value","text":"<pre><code>constexpr bool cxxopts::values::type_is_container&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/","title":"Struct cxxopts::values::type_is_container&lt; std::vector&lt; T &gt; &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cxxopts &gt; values &gt; type_is_container&lt; std::vector&lt; T &gt; &gt;</p>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr bool value   = <code>true</code>"},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structcxxopts_1_1values_1_1type__is__container_3_01std_1_1vector_3_01T_01_4_01_4/#variable-value","title":"variable value","text":"<pre><code>constexpr bool cxxopts::values::type_is_container&lt; std::vector&lt; T &gt; &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/friedel/devel/ILLIXR-historic/src/cxxopts.hpp</code></p>"},{"location":"plugin_README/README_debugview/","title":"debugview","text":""},{"location":"plugin_README/README_debugview/#summary","title":"Summary","text":"<p><code>debugview</code> is a simple debugging view for the ILLIXR system. By subscribing to several Switchboard endpoints, many important datapoints can be observed to help debug issues with the runtime. The debug view shows the current calculated SLAM pose and the (optional) ground truth pose read from the ground truth dataset as 3D headset models drawn on a backdrop scene. In addition, camera and IMU data is also visible, with the stereoscopic onboard camera views shown in one of the windows. Various offsets can be applied to the generated poses to aid in viewing. Dear ImGUI is used for displaying data and providing an interactive interface.</p>"},{"location":"plugin_README/README_debugview/#switchboard-connection","title":"Switchboard connection","text":"<ul> <li><code>debugview</code> subscribes to the slow-pose, which represents the latest pose published by the SLAM/IMU system.</li> <li>In the future, <code>debugview</code> will also query for the most up-to-date predicted pose through an RPC-like query system. This is not currently in our release version; but is in development and will be added soon. The \"fast pose\" referenced in this plugin just samples the <code>slow_pose</code> instead.</li> <li><code>debugview</code> also is synchronously dependent on the <code>imu_cam</code> topic, as the stereoscopic camera views are displayed in the debug window. In ILLIXR, \"synchronous dependencies\" are implemented as scheduled \"handlers\" that are executed from a shared thread pool; this handler is executed every time a fresh \"packet\" is available from the <code>imu_cam</code> topic. Given that this is a separate thread from the main graphics thread, this <code>imu_cam</code> packet must be saved/cached for later, when the grahpics thread renders the next frame. This is a good example to follow when writing your own multithreaded components that use both synchronous and asynchronous dependencies, and need to share information across dependency boundaries.</li> </ul>"},{"location":"plugin_README/README_debugview/#notes","title":"Notes","text":"<p><code>debugview</code> will be under heavy development in the near-term. Pull requests may or may not be accepted, due to the frequency of rapid internal changes.</p>"},{"location":"plugin_README/README_debugview/#known-issues","title":"Known Issues","text":"<p>Currently, the poses returned from the SLAM system have an incorrect initial rotation, as the poses are returned in an incorrect frame of reference. Thus, the headsets may appear to be tilted incorrectly; the button \"calculate new orientation offset\" will reset the orientation, such that the current orientation is considered the \"neutral\" orientation. In a future update, the correct frame of reference/transform matrix will be applied and the pose will accurately reflect the actual head position.</p>"},{"location":"plugin_README/README_debugview/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_display_vk/","title":"display_vk","text":""},{"location":"plugin_README/README_display_vk/#summary","title":"Summary","text":"<p><code>display_vk</code> implements the service interface <code>display_sink</code>, which sets up a windowing backend (using GLFW in this case), initializes Vulkan, and creates a swapchain. If available, Vulkan validation layers are enabled. This plugin is only required when running the native target. For Monado, the <code>display_sink</code> service is provided by the Monado compositor.</p>"},{"location":"plugin_README/README_fauxpose/","title":"FauxPose ILLIXR plugin","text":""},{"location":"plugin_README/README_fauxpose/#summary","title":"Summary","text":"<p>The <code>FauxPose</code> ILLIXR plugin generates \"fast_pose\" data from a simple mathematical algorithm (circular movement).  The intent is for use when debugging other plugins and the developer wants a known pose trajectory without having to configure actual tracking.</p> <p>The movement is hard-coded to be on the Y=center.y plane, with the X and Z values set to rotate in a circle.  The period and amplitude of the movement are have default values (0.5, and 2.0 respectively) that can be changed through environment variables.</p> <pre><code>Topic details:\n-   *Publishes* `pose_position` on `fast_pose` topic.\n</code></pre>"},{"location":"plugin_README/README_fauxpose/#usage","title":"Usage","text":"<p>The \"FauxPose\" plugin must be included in the YAML configuration file prior to any rendering plugin (such as \"debugview\" or \"gldemo\").  Also no other pose-generating plugin should be included.  (In the standard configuration this requires removing the \"rt_slam_plugins\" -- usually by commenting out the line:     #- !include \"rt_slam_plugins.yaml\"</p> <p>And then adding FauxPose as a plugin:         - path: fauxpose/</p> <p>An example \"faux.yaml\" configuration file is included as an example.</p> <p>By default, the \"orbit\" of the tracked position will be about the point (0.0, 1.5, 0.0), with a default amplitude of \"2.0\", and period of \"0.5\" seconds, with the orientation facing the negative-X direction.  The first three of these values can be overridden through environment variables:     * FAUXPOSE_PERIOD=     * FAUXPOSE_AMPLITUDE=     * FAUXPOSE_CENTER="},{"location":"plugin_README/README_gldemo/","title":"gldemo","text":""},{"location":"plugin_README/README_gldemo/#summary","title":"Summary","text":"<p>The <code>gldemo</code> plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>gldemo</code> will subscribe to several Switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the Switchboard API. <code>gldemo</code> is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; <code>gldemo</code> fills this requirement. As an important note, <code>gldemo</code> does not render stereoscopically; the two eye renders are rendered from the same position. This may be updated to render stereoscopically in the future, but is not seen as a critical feature as this is generally intended as a debugging tool.</p>"},{"location":"plugin_README/README_gldemo/#switchboard-connection","title":"Switchboard connection","text":"<p><code>gldemo</code> subscribes to and publishes to several Switchboard plugs. Most notably, <code>gldemo</code> subscribes to the <code>fast_pose</code> plug, which (ideally) represents the most recent extrapolated pose. This connection represents an area of active development in ILLIXR, as we are replacing the pose subscription with an RPC-like proper pose prediction system. As of the time of writing, <code>fast_pose</code> is functionally identical to the <code>slow_pose</code> published by the SLAM system, but this will change when proper pose extrapolation is implemented. <code>gldemo</code> also pulls the correct graphics context from Phonebook.</p> <p><code>gldemo</code> publishes the rendered eyebuffers to the Switchboard system as well, using whichever eyebuffer format has been selected with the <code>USE_ALT_EYE_FORMAT</code> compile-time macro. The alternative eye format is more similar to the format used by Monado/OpenXR, and is more fully explained by the code comments.</p>"},{"location":"plugin_README/README_gldemo/#notes","title":"Notes","text":"<p><code>gldemo</code> does not pretend to be an OpenXR application; it does not use the OpenXR API, nor does it follow typical OpenXR patterns. It hooks directly into the Switchboard system and is intended as a debug/visualization tool. For more accurate and representative testing, consider running ILLIXR with an actual OpenXR application.</p>"},{"location":"plugin_README/README_gldemo/#known-issues","title":"Known Issues","text":"<p>As noted above, <code>gldemo</code> does not actually render stereoscopically, and the two eye buffers are rendered from the same eye location. (This is not to say that the two eye buffers are not rendered separately; they are actually two separate drawcalls.) In addition, the quality of the pose used by <code>gldemo</code> is dependent on the upstream pose, which is currently not extrapolated/predicted and is subject to change.</p>"},{"location":"plugin_README/README_gldemo/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and are a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_native_renderer/","title":"native_renderer","text":""},{"location":"plugin_README/README_native_renderer/#summary","title":"Summary","text":"<p><code>native_renderer</code> utilizes <code>vkdemo</code> and <code>timewarp_vk</code> to construct a full rendering pipeline. <code>vkdemo</code> is used to render the scene, and <code>timewarp_vk</code> is used to perform rotational reprojection. This plugin creates the necessary Vulkan resoruces and targets for <code>vkdemo</code> and <code>timewarp_vk</code> to render to, and then composites the results into a single image. The resulting image is presented using the Vulkan swapchain provided by <code>display_vk</code>.</p>"},{"location":"plugin_README/README_openni/","title":"OpenNI","text":""},{"location":"plugin_README/README_openni/#set-camera-mode","title":"Set Camera Mode","text":"<p>If you wish to switch up the video modes of OpenNI, update these two macros in <code>openni/plugin.cpp</code> accordingly: <pre><code>#define RGB_MODE 0\n#define DEPTH_MODE 0\n</code></pre></p> <p>You can see the list of available modes once you run ILLIXR the first time. </p>"},{"location":"plugin_README/README_openni/#debugging","title":"Debugging","text":"<p><pre><code>Device open failed:     DeviceOpen using default: no devices found\n</code></pre> Solution: No OpenNI compatible device is plugged in. So plug one in</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": USB transfer timeout!\n</code></pre> Solution: This is usually fixed by unplug and plug back in.</p> <p><pre><code>Device open failed:     Could not open \"1d27/0601@3/2\": Failed to open the USB device!\n</code></pre> Solution: Fix by running with sudo </p>"},{"location":"plugin_README/README_record_imu_cam/","title":"Record IMU Cam","text":"<p>The purpose of this plugin is to record a dataset, similar to the EuRoC MAV dataset that includes the IMU data and Cam images.</p>"},{"location":"plugin_README/README_record_imu_cam/#how-to-record-a-dataset","title":"How to record a dataset","text":"<p>In <code>configs/rt_slam_plugins.yaml</code>, uncomment this line:</p> <pre><code>- path: record_imu_cam/\n</code></pre> <p>After recording, the dataset will be stored in the ILLIXR project directory, with the following structure:</p> <pre><code>ILLIXR/data_record\n    \\_ cam0/\n        \\_ data/ \n            \\_ timestamp.png\n            \\_ ...\n        \\_ data.csv\n    \\_ cam1/\n        \\_ data/\n            \\_ timestamp.png\n            \\_ ...\n        \\_ data.csv\n    \\_ imu0\n        \\_ data.csv\n</code></pre>"},{"location":"plugin_README/README_record_imu_cam/#format","title":"Format","text":"<ol> <li><code>cam0/data.csv</code> and <code>cam1/data.csv</code> are both formatted as <pre><code>timestamp [ns], timestamp.png\n</code></pre> <ol> <li> <p><code>imu0/data.csv</code> is formatted as </p> <p>timestamp [ns],w_x [rad s^-1],w_y [rad s^-1],w_z [rad s^-1],a_x [m s^-2],a_y [m s^-2],a_z [m s^-2]</p> </li> </ol> </li> </ol>"},{"location":"plugin_README/README_record_imu_cam/#how-to-rerun-recorded-dataset","title":"How to rerun recorded dataset","text":"<ol> <li> <p>(IMPORTANT) In <code>configs/rt_slam_plugins.yaml</code>, comment this line: </p> <p># - path: record_imu_cam/  </p> </li> <li> <p>In <code>configs/native.yaml</code> (or whatever mode you're running ILLIXR with), add the path of the recorded dataset like so:</p> <pre><code>data: data_record\n  # subpath: mav0\n  # relative_to:\n  #  archive_path:\n  #    download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip'\n</code></pre> <p>Make sure to comment the default EuRoC dataset</p> </li> <li> <p>In <code>runner/runner/main.py</code>, head toward the function corresponding to the mode with which you want to run ILLIXR, and change the <code>data_path</code> line like so (if run natively, it is this line):</p> <pre><code>data_path = pathify(config[\"data\"], root_dir, root_dir / \"data_record\", True, True)\n</code></pre> </li> <li> <p>Make sure other plugins that feed images and IMU are commented, such as <code>offline_cam</code>, <code>offline_imu</code>, <code>zed</code>, and <code>realsense</code>.</p> </li> </ol>"},{"location":"plugin_README/README_timewarp_gl/","title":"timewarp_gl","text":""},{"location":"plugin_README/README_timewarp_gl/#summary","title":"Summary","text":"<p><code>timewarp_gl</code> is an OpenGL-based asynchronous rotational reprojection plugin intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation). </p>"},{"location":"plugin_README/README_timewarp_gl/#switchboard-connection","title":"Switchboard connection","text":"<p><code>timewarp_gl</code> subscribes to and publishes to several Switchboard plugs and Phonebook resources.</p> <ul> <li>The plugin grabs the GL context from Phonebook. This is necessary to share the eyebuffers with the rendering application (or <code>gldemo</code>). As this is an OpenGL-based reprojection plugin, it relies on OpenGL resources for the eyebuffers.</li> <li><code>timewarp_gl</code> subscribes to the most recent pose published by the system. Currently, as our pose-prediction system is still under development, this is not technically accurate; the final, intended functionality is that the timewarp plugin will sample a pose prediction algorithm through an RPC-like mechanism. As we complete our work on our pose prediction system, this plugin will be modified to use this mechanism.</li> <li><code>timewarp_gl</code> also subscribes to the most recent frame published by the system. This frame data also includes the pose that was used to render the frame; this is how the timewarp algorithm calcuates the \"diff\" to be used to reproject the frame.</li> </ul>"},{"location":"plugin_README/README_timewarp_gl/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.</p>"},{"location":"plugin_README/README_timewarp_gl/#known-issues","title":"Known Issues","text":"<p>As noted above, this plugin currently samples <code>slow_pose</code>. This will be changed to sample a <code>fast_pose</code> topic through an RPC mechanism. In addition, JMP Van Waveren's algorithm includes a method for warping between two reprojection matrices based on the actual progress of the display controller's \"scanline\"; this is simply commented out in our code, but can be re-enabled when our pose prediction system comes online.</p>"},{"location":"plugin_README/README_timewarp_gl/#contributions","title":"Contributions","text":"<p>Contributions are welcome; please raise an issue first, though, as many issues are known and may be a part of our existing internal backlog.</p>"},{"location":"plugin_README/README_timewarp_vk/","title":"timewarp_vk","text":""},{"location":"plugin_README/README_timewarp_vk/#summary","title":"Summary","text":"<p><code>timewarp_vk</code> is an Vulkan-based rotational reprojection service intended for use in the ILLIXR architecture. This plugin implements a rotational reprojection algorithm (i.e. does not reproject position, only rotation). </p>"},{"location":"plugin_README/README_timewarp_vk/#phonebook-service","title":"Phonebook Service","text":"<p><code>timewarp_vk</code> is registered as a service in phonebook, conforming to the <code>timewarp</code> render pass interface. Three functions are exposed:</p> <ul> <li><code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which <code>timewarp_vk</code> binds to</li> <li><code>update_uniforms(const pose_type render_pose)</code> calculates the reprojection matrix given the current pose and the pose used to render the frame, and updates the uniform buffer with the reprojection matrix. This must be called before <code>record_command_buffer</code> is called</li> <li><code>record_command_buffer(VkCommandBuffer commandBuffer, int left)</code> records the commands into a given command buffer that would perform the reprojection for one eye, for which 1 is left and 0 is right</li> </ul>"},{"location":"plugin_README/README_timewarp_vk/#notes","title":"Notes","text":"<p>The rotational reprojection algorithm implemented in this plugin is a re-implementation of the algorithm used by the late Jan Paul van Waveren. His invaluable, priceless work in the area of AR/VR has made our project possible. View his codebase here.</p>"},{"location":"plugin_README/README_vkdemo/","title":"vkdemo","text":""},{"location":"plugin_README/README_vkdemo/#summary","title":"Summary","text":"<p>The <code>vkdemo</code> plugin serves as a stand-in for an actual application when ILLIXR is run as a standalone application without an actual OpenXR application. <code>vkdemo</code> will subscribe to several Switchboard plugs, render a simple, hard-coded 3D scene (in fact, the same 3D scene that is included in the <code>debugview</code> plugin) and publish the results to the Switchboard API. <code>vkdemo</code> is intended to be as lightweight as possible, serving as a baseline debug \"dummy application\". During development, it is useful to have some content being published to the HMD display without needing to use the full OpenXR interface; <code>vkdemo</code> fills this requirement.</p>"},{"location":"plugin_README/README_vkdemo/#phonebook-service","title":"Phonebook Service","text":"<p><code>vkdemo</code> is registered as a service in phonebook, conforming to the <code>app</code> render pass interface. Three functions are exposed: * <code>setup(VkRenderPass render_pass, uint32_t subpass)</code> initializes the required Vulkan pipeline and resources given a specific render pass and subpass, to which <code>vkdemo</code> binds to * <code>update_uniforms(const pose_type render_pose)</code> updates the uniform buffer with the given pose, which is used to render the scene. This must be called before <code>record_command_buffer</code> is called. * <code>record_command_buffer(VkCommandBuffer commandBuffer, int eye)</code> records the commands into a given command buffer that would perform the rendering for one eye, for which 0 is left and 1 is right. To achieve stereoscopic rendering, the function is called twice, once for each eye. * <code>virtual void destroy()</code> cleans up the resources allocated by <code>vkdemo</code>. Currently, this part is not yet implemented.</p>"},{"location":"plugin_README/README_zed/","title":"ZED Mini","text":""},{"location":"plugin_README/README_zed/#getting-started","title":"Getting started","text":"<ul> <li>First, download the latest version of the ZED SDK on stereolabs.com.</li> <li>For more information, read the ZED API documentation.</li> </ul>"},{"location":"plugin_README/README_zed/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ubuntu 20.04 or 22.04</li> <li>CUDA</li> <li>ZED SDK</li> <li>OpenCV 4</li> </ul>"},{"location":"plugin_README/monado_illixr_runtime_overview/","title":"Monado Integration Overview","text":"<p>ILLIXR's Plugins provide XR services, and the Runtime ties them together. However, we don't want to force developers to write their whole application specifically     for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR,     so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado, an existing, open-source implementation     of the standard.</p> <ul> <li> <p>When running ILLIXR without Monado, the ILLIXR runtime is the entry-point.     Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app.</p> </li> <li> <p>When running from Monado, however, as mandated by OpenXR specifications,         the application is the entry point.     As a result, the ILLIXR runtime system is loaded at a later point as a shared library.     This page documents the changes to the ILLIXR runtime when an OpenXR application is used.</p> </li> </ul>"},{"location":"plugin_README/monado_illixr_runtime_overview/#openxr-application-launch","title":"OpenXR Application Launch","text":"<p>As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a     configuration JSON file pointed to by an environment variable and loads the OpenXR runtime,     which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronos Group for more details.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#monado-device-probe-and-illixr-initialization","title":"Monado Device Probe and ILLIXR Initialization","text":"<p>During initialization, Monado asks all drivers to probe for and initialize HMDs     and controllers, internally known as <code>xdev</code>s. Our ILLIXR driver will always respond to Monado with one discovered HMD that     will be used to capture OpenXR queries and events from Monado's state tracker. The driver obtains the path to the ILLIXR runtime <code>.so</code> file and a list of plugins from     environment variables.</p> <p>After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime,     which we capture and send to the ILLIXR driver. At this moment, all necessary data is ready and ILLIXR will be launched.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#illixr-runtime-launch","title":"ILLIXR Runtime Launch","text":"<p>When used with Monado, the ILLIXR Runtime is compiled into     a shared library instead of an executable. The library exports its two major functionalities:     initializing Switchboard and Phonebook,     and     loading Plugins.</p> <p>The driver starts to load the runtime by loading the shared library into the current     (application's) address space and calls the Switchboard and Phonebook initialization. Then, it calls the plugin loading for each ILLIXR plugin     (except <code>gldemo</code>, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path     to load a Translation Plugin into ILLIXR as the application. If the plugin implements a long-running computation, it may block the main ILLIXR thread     which drives the entire application. To remedy this, a plugin should implement long-running processing in its own thread. This way, the driver will be able to reacquire control and return to Monado     and the application efficiently.</p>"},{"location":"plugin_README/monado_illixr_runtime_overview/#translation-plugin","title":"Translation Plugin","text":"<p>When the application and all ILLIXR plugins are up and running,     the translation plugin handles the connection between Monado and ILLIXR. It might be confusing to see that this plugin is part of the ILLIXR driver which is part of     Monado while at the same time also part of ILLIXR as a plugin. However, Monado and ILLIXR are running in different threads in the same address space. The translation plugin is the interface of these two parallel systems.</p> <p>The translation plugin handles two types of events at the moment:     pose requests and frame submissions. From the view of Monado, the translation plugin is the destination of all requests:     from the application,     to Monado's state trackers,     to the xdev interface who is responsible for servicing the request. From the view of ILLIXR, the translation plugin behaves the same as the <code>gldemo</code> application:     reading pose and submitting frames.</p> <p>For implementation details regarding the representation of poses and frames in Monado     and in ILLIXR, please see ILLIXR's Monado Integration Dataflow.</p>"},{"location":"plugin_README/monado_integration_dataflow/","title":"Monado Dataflow","text":""},{"location":"plugin_README/monado_integration_dataflow/#monado-integration-dataflow","title":"Monado Integration Dataflow","text":"<p>The dataflow for the ILLIXR Monado integration comprises two steps: 1.  getting pose data from ILLIXR,     and 1.  sending a user rendered frame back to ILLIXR.</p> <p>In Monado, ILLIXR is recognized as an HMD for Monado, while in ILLIXR,     Monado looks like a user application (such as <code>gldemo</code>). After ILLIXR is initialized from Monado, and Monado is registered as a plugin for ILLIXR,     the most recent pose information can be easily obtained via Switchboard.</p> <p>The compositor side of Monado integration with ILLIXR is implemented more subtly. The original Monado compositor primarily performs distortion correction     and aberration correction in a Vulkan back-end compositor. The compositor also has two client compositors (one for OpenGL applications and another     for Vulkan applications) which pass frame data to the back-end compositor. ILLIXR integration intercepts the frame at GL client compositor and sends it to Switchboard     of ILLIXR, which is then used by <code>timewarp_gl</code> component.</p> <p>To get an OpenGL frame and use it without copying pixels, ILLIXR needs to get the user     application GL context. This is done at OpenXR session creation time, where ILLIXR is initialized. Note that, logically, ILLIXR is initialized during OpenXR instance creation,     or is otherwise running in the background all the time. Currently, ILLIXR is initialized at session creation time, since ILLIXR only supports single     OpenXR session, and requires a user application GL context upon initialization,</p> <p>The current ILLIXR integration for Monado is a temporary solution and has some drawbacks caused     by the concurrent and continued development from both the Monado and ILLIXR projects. The integration:</p> <ol> <li> <p>Does not use the pose that user application declares to use at rendering         (using the OpenXR specification).     This is due to incongruencies with Monado's internal interfaces and representations.     The pose difference used by timewarp is computed using the most recent query         for a pose update.</p> </li> <li> <p>Cannot submit frame data with a depth buffer.</p> </li> <li> <p>Cannot have poses that make use of OpenXR Spaces.     Raw pose data is instead retrieved from the application's SLAM algorithms.</p> </li> <li> <p>Does not support controller action.</p> </li> <li> <p>Only supports GL user-space applications.</p> </li> <li> <p>User-space applications cannot acquire more than one swap chain buffer for each eye         during the the processing of a frame.</p> </li> <li> <p>Must initialize ILLIXR during the session initialization.</p> </li> </ol>"},{"location":"plugin_README/offload_vio/","title":"Running ILLIXR With VIO Offloaded","text":"<p>In order to run the offloading plugins you need the following extra dependecies</p> <pre><code>sudo add-apt-repository ppa:ecal/ecal-latest\nsudo apt-get update\nsudo apt-get install ecal\nsudo apt-get install libprotobuf-dev protobuf-compiler\n</code></pre> <p>The most simple example is running the offloaded setup on one machine with the server in one terminal and the device running in a different terminal. Each terminal must be running from separate ILLIXR  repositories (clone ILLIXR twice to different locations; running both the server and device from the same  ILLIR repository will cause lock issues). </p> <p>Start ILLIXR using <pre><code>main.opt.exe --yaml=profiles/offload-server.yaml --data=&lt;&gt; --demo_data=&lt;&gt;\n</code></pre> for one terminal and  <pre><code>main.opt.exe --yaml=profiles/offload-device.yaml --data=&lt;&gt; --demo_data=&lt;&gt;\n</code></pre> on the other terminal. This will run OpenVINS on the server and will feed it with the EuRoC dataset from the device.</p> <p>To run more complicated experiment setups where the device and server are not on the same machine, you will need to establish TCP communication between machines, you'll need to configure both the server and client settings. The IP address and port number can be set in the configuration file:</p> <p><code>include/illixr/network/net_config.hpp</code></p> <p>This file contains variables where you can enter the respective IP addresses and port numbers for the server and client. Edit these fields to suit your network setup.</p>"},{"location":"plugin_README/offload_vio/#compression","title":"Compression","text":"<p>H.264 codec is supported for compressing the camera images to save bandwidth. To enable compression, define <code>USE_COMPRESSION</code> in <code>device_tx/plugin.cpp</code> and <code>server_rx/plugin.cpp</code>. In <code>device_tx/video_encoder.cpp</code> and <code>server_rx/video_decoder.cpp</code>, define appropriate image dimensions and desired target bitrate (defaults to 5Mbps). The codec library is implemented based on GStreamer and DeepStream. Please follow the instructions here to install GStreamer and DeepStream SDK. You don't have to reinstall CUDA and NVIDIA Driver if you have a relatively new version. TensorRT and librdkafka are not required either.</p>"},{"location":"api/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class CSVIterator </li> <li>class CSVRow </li> <li>namespace ILLIXR RAC_ERRNO_MSG. <ul> <li>class Event A boolean condition-variable. </li> <li>class RelativeClock Relative clock for all of ILLIXR . </li> <li>class Stoplight Start/stop synchronization for the whole application. </li> <li>struct cam_type </li> <li>struct connection_signal </li> <li>class data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>struct display_params Display parameters. </li> <li>class dynamic_lib </li> <li>struct fast_pose_type </li> <li>class gen_guid This class generates unique IDs. </li> <li>struct hmd_physical_info </li> <li>struct hologram_input </li> <li>struct image_handle </li> <li>struct imu_integrator_input </li> <li>struct imu_params </li> <li>struct imu_raw_type </li> <li>struct imu_type </li> <li>class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. </li> <li>namespace math_util </li> <li>class phonebook A service locator forILLIXR . <ul> <li>class service A 'service' that can be registered in the phonebook. </li> </ul> </li> <li>class plugin A dynamically-loadable plugin for Spindle. </li> <li>struct pose_type </li> <li>class record This class represents a tuple of fields which get logged by <code>record_logger</code> . </li> <li>class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class record_header Schema of each record. </li> <li>class record_logger The ILLIXR logging service for structured records. </li> <li>struct rendered_frame </li> <li>struct rendering_params Rendering parameters. </li> <li>struct rgb_depth_type </li> <li>class runtime </li> <li>struct signal_to_quad </li> <li>class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). <ul> <li>class buffered_reader </li> <li>class event Virtual class for event types. </li> <li>class event_wrapper Helper class for making event types. </li> <li>class reader A handle which can read the latest event on a topic. </li> <li>class writer A handle which can publish events to a topic. </li> </ul> </li> <li>struct texture_pose </li> <li>class threadloop A reusable threadloop for plugins. </li> <li>class time_point </li> <li>struct vk_image_handle </li> <li>class xlib_gl_extended_window </li> </ul> </li> <li>class topic Represents a topic. </li> <li>class topic_buffer </li> <li>class topic_subscription Represents a single topic_subscription (callback and queue) </li> <li>class pose_prediction </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_in_destructor </li> <li>class should_profile_class </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> </ul>"},{"location":"api/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>dir illixr <ul> <li>file cpu_timer.hpp </li> <li>file csv_iterator.hpp </li> <li>file data_format.hpp </li> <li>file dynamic_lib.hpp </li> <li>file error_util.hpp </li> <li>file extended_window.hpp </li> <li>file global_module_defs.hpp </li> <li>file managed_thread.hpp </li> <li>file math_util.hpp </li> <li>file opencv_data_types.hpp </li> <li>file phonebook.hpp </li> <li>file plugin.hpp </li> <li>file pose_prediction.hpp </li> <li>file record_logger.hpp </li> <li>file relative_clock.hpp </li> <li>file runtime.hpp </li> <li>file shader_util.hpp </li> <li>file stoplight.hpp </li> <li>file switchboard.hpp </li> <li>file threadloop.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/classCSVIterator/","title":"Class CSVIterator","text":"<p>ClassList &gt; CSVIterator</p>"},{"location":"api/classCSVIterator/#public-types","title":"Public Types","text":"Type Name typedef std::size_t difference_type typedef std::input_iterator_tag iterator_category typedef CSVRow * pointer typedef CSVRow &amp; reference typedef CSVRow value_type"},{"location":"api/classCSVIterator/#public-functions","title":"Public Functions","text":"Type Name CSVIterator (std::istream &amp; str, std::size_t skip=0)  CSVIterator ()  bool operator!= (CSVIterator const &amp; rhs)  CSVRow const &amp; operator* () const CSVIterator &amp; operator++ ()  CSVIterator operator++ (int)  CSVIterator &amp; operator+= (std::size_t skip)  CSVRow const * operator-&gt; () const bool operator== (CSVIterator const &amp; rhs)  const std::string &amp; operator[] (std::size_t idx)"},{"location":"api/classCSVIterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classCSVIterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>typedef std::size_t CSVIterator::difference_type;\n</code></pre>"},{"location":"api/classCSVIterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>typedef std::input_iterator_tag CSVIterator::iterator_category;\n</code></pre>"},{"location":"api/classCSVIterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>typedef CSVRow* CSVIterator::pointer;\n</code></pre>"},{"location":"api/classCSVIterator/#typedef-reference","title":"typedef reference","text":"<pre><code>typedef CSVRow&amp; CSVIterator::reference;\n</code></pre>"},{"location":"api/classCSVIterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>typedef CSVRow CSVIterator::value_type;\n</code></pre>"},{"location":"api/classCSVIterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classCSVIterator/#function-csviterator-12","title":"function CSVIterator [1/2]","text":"<pre><code>inline explicit CSVIterator::CSVIterator (\n    std::istream &amp; str,\n    std::size_t skip=0\n) \n</code></pre>"},{"location":"api/classCSVIterator/#function-csviterator-22","title":"function CSVIterator [2/2]","text":"<pre><code>inline CSVIterator::CSVIterator () \n</code></pre>"},{"location":"api/classCSVIterator/#function-operator","title":"function operator!=","text":"<pre><code>inline bool CSVIterator::operator!= (\n    CSVIterator const &amp; rhs\n) \n</code></pre>"},{"location":"api/classCSVIterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline CSVRow const &amp; CSVIterator::operator* () const\n</code></pre>"},{"location":"api/classCSVIterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline CSVIterator &amp; CSVIterator::operator++ () \n</code></pre>"},{"location":"api/classCSVIterator/#function-operator_3","title":"function operator++","text":"<pre><code>inline CSVIterator CSVIterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"api/classCSVIterator/#function-operator_4","title":"function operator+=","text":"<pre><code>inline CSVIterator &amp; CSVIterator::operator+= (\n    std::size_t skip\n) \n</code></pre>"},{"location":"api/classCSVIterator/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline CSVRow const * CSVIterator::operator-&gt; () const\n</code></pre>"},{"location":"api/classCSVIterator/#function-operator_5","title":"function operator==","text":"<pre><code>inline bool CSVIterator::operator== (\n    CSVIterator const &amp; rhs\n) \n</code></pre>"},{"location":"api/classCSVIterator/#function-operator_6","title":"function operator[]","text":"<pre><code>inline const std::string &amp; CSVIterator::operator[] (\n    std::size_t idx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/csv_iterator.hpp</code></p>"},{"location":"api/classCSVRow/","title":"Class CSVRow","text":"<p>ClassList &gt; CSVRow</p>"},{"location":"api/classCSVRow/#public-functions","title":"Public Functions","text":"Type Name std::string const &amp; operator[] (std::size_t index) const void readNextRow (std::istream &amp; str)  std::size_t size () const"},{"location":"api/classCSVRow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classCSVRow/#function-operator","title":"function operator[]","text":"<pre><code>inline std::string const &amp; CSVRow::operator[] (\n    std::size_t index\n) const\n</code></pre>"},{"location":"api/classCSVRow/#function-readnextrow","title":"function readNextRow","text":"<pre><code>inline void CSVRow::readNextRow (\n    std::istream &amp; str\n) \n</code></pre>"},{"location":"api/classCSVRow/#function-size","title":"function size","text":"<pre><code>inline std::size_t CSVRow::size () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/csv_iterator.hpp</code></p>"},{"location":"api/namespaceILLIXR/","title":"Namespace ILLIXR","text":"<p>Namespace List &gt; ILLIXR</p> <p>RAC_ERRNO_MSG. </p>"},{"location":"api/namespaceILLIXR/#namespaces","title":"Namespaces","text":"Type Name namespace math_util"},{"location":"api/namespaceILLIXR/#classes","title":"Classes","text":"Type Name class Event A boolean condition-variable. class RelativeClock Relative clock for all of ILLIXR . class Stoplight Start/stop synchronization for the whole application. struct cam_type struct connection_signal class data_use_indicator A helper class that lets one dynamically determine if some data gets used. struct display_params Display parameters. class dynamic_lib struct fast_pose_type class gen_guid This class generates unique IDs. struct hmd_physical_info struct hologram_input struct image_handle struct imu_integrator_input struct imu_params struct imu_raw_type struct imu_type class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. class phonebook A service locator forILLIXR . class plugin A dynamically-loadable plugin for Spindle. struct pose_type class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_logger The ILLIXR logging service for structured records. struct rendered_frame struct rendering_params Rendering parameters. struct rgb_depth_type class runtime struct signal_to_quad class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). struct texture_pose class threadloop A reusable threadloop for plugins. class time_point struct vk_image_handle class xlib_gl_extended_window"},{"location":"api/namespaceILLIXR/#public-types","title":"Public Types","text":"Type Name typedef std::chrono::duration&lt; _clock_rep, _clock_period &gt; _clock_duration typedef std::nano _clock_period typedef long _clock_rep typedef RelativeClock::duration duration enum graphics_api typedef plugin *(* plugin_factory typedef std::size_t plugin_id_t enum swapchain_usage typedef unsigned long long ullong typedef struct ILLIXR::vk_image_handle vk_image_handle typedef std::unique_ptr&lt; void, std::function&lt; void(void *)&gt; &gt; void_ptr"},{"location":"api/namespaceILLIXR/#public-attributes","title":"Public Attributes","text":"Type Name const record_header __plugin_start_header   = <code>/* multi line expression */</code> const record_header __switchboard_callback_header   = <code>/* multi line expression */</code> const record_header __switchboard_topic_stop_header   = <code>/* multi line expression */</code> const record_header __threadloop_iteration_header   = <code>/* multi line expression */</code>"},{"location":"api/namespaceILLIXR/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const bool ENABLE_VERBOSE_ERRORS   = <code>{[**ILLIXR::str\\_to\\_bool**](namespaceILLIXR.md#function-str_to_bool)([**ILLIXR::getenv\\_or**](namespaceILLIXR.md#function-getenv_or)(\"ILLIXR\\_ENABLE\\_VERBOSE\\_ERRORS\", \"False\"))}</code> std::chrono::milliseconds LOG_BUFFER_DELAY   = <code>{1000}</code>"},{"location":"api/namespaceILLIXR/#public-functions","title":"Public Functions","text":"Type Name void abort (const std::string &amp; msg=\"\", const int error_val=1) Exits the application during a fatal error. double duration2double (duration dur)  constexpr duration freq2period (double fps)  std::string getenv_or (const std::string &amp; var, std::string default_) Temporary environment variable getter. Not needed once #198 is merged. bool operator!= (const time_point &amp; lhs, const time_point &amp; rhs)  time_point operator+ (const time_point &amp; pt, const time_point::duration &amp; d)  time_point operator+ (const time_point::duration &amp; d, const time_point &amp; pt)  time_point::duration operator- (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator&lt; (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator&lt;= (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator== (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator&gt; (const time_point &amp; lhs, const time_point &amp; rhs)  bool operator&gt;= (const time_point &amp; lhs, const time_point &amp; rhs)  void report_and_clear_errno (const std::string &amp; file, const int &amp; line, const std::string &amp; function, const std::string &amp; msg=\"\") Support function to report errno values when debugging (NDEBUG). runtime * runtime_factory ()  bool str_to_bool (const std::string &amp; var) Convert a string containing a (python) boolean to the bool type."},{"location":"api/namespaceILLIXR/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespaceILLIXR/#typedef-_clock_duration","title":"typedef _clock_duration","text":"<pre><code>using ILLIXR::_clock_duration = typedef std::chrono::duration&lt;_clock_rep, _clock_period&gt;;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-_clock_period","title":"typedef _clock_period","text":"<pre><code>using ILLIXR::_clock_period = typedef std::nano;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-_clock_rep","title":"typedef _clock_rep","text":"<pre><code>using ILLIXR::_clock_rep = typedef long;\n</code></pre> <p>Mimick of <code>std::chrono::time_point&lt;Clock, Rep&gt;</code> 1.</p> <p>Can't use <code>std::chrono::time_point&lt;Clock, Rep&gt;</code>, because the <code>Clock</code> must satisfy the Clock interface 2, but <code>RelativeClock</code> cannot satisfy this interface because <code>RelativeClock::now()</code> is a stateful (instance method) not pure (class method). Instead, we will mimick the interface of 1 here. </p>"},{"location":"api/namespaceILLIXR/#typedef-duration","title":"typedef duration","text":"<pre><code>using ILLIXR::duration = typedef RelativeClock::duration;\n</code></pre>"},{"location":"api/namespaceILLIXR/#enum-graphics_api","title":"enum graphics_api","text":"<pre><code>enum ILLIXR::graphics_api {\n    OPENGL,\n    VULKAN,\n    TBD\n};\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-plugin_factory","title":"typedef plugin_factory","text":"<pre><code>typedef plugin *(* ILLIXR::plugin_factory) (phonebook *);\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-plugin_id_t","title":"typedef plugin_id_t","text":"<pre><code>typedef std::size_t ILLIXR::plugin_id_t;\n</code></pre>"},{"location":"api/namespaceILLIXR/#enum-swapchain_usage","title":"enum swapchain_usage","text":"<pre><code>enum ILLIXR::swapchain_usage {\n    LEFT_SWAPCHAIN,\n    RIGHT_SWAPCHAIN,\n    LEFT_RENDER,\n    RIGHT_RENDER,\n    NA\n};\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-ullong","title":"typedef ullong","text":"<pre><code>using ILLIXR::ullong = typedef unsigned long long;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-vk_image_handle","title":"typedef vk_image_handle","text":"<pre><code>typedef struct ILLIXR::vk_image_handle ILLIXR::vk_image_handle;\n</code></pre>"},{"location":"api/namespaceILLIXR/#typedef-void_ptr","title":"typedef void_ptr","text":"<pre><code>using ILLIXR::void_ptr = typedef std::unique_ptr&lt;void, std::function&lt;void(void*)&gt; &gt;;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-__plugin_start_header","title":"variable __plugin_start_header","text":"<pre><code>const record_header ILLIXR::__plugin_start_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-__switchboard_callback_header","title":"variable __switchboard_callback_header","text":"<pre><code>const record_header ILLIXR::__switchboard_callback_header;\n</code></pre> <p>@Should be private to Switchboard. </p>"},{"location":"api/namespaceILLIXR/#variable-__switchboard_topic_stop_header","title":"variable __switchboard_topic_stop_header","text":"<pre><code>const record_header ILLIXR::__switchboard_topic_stop_header;\n</code></pre> <p>@Should be private to Switchboard. </p>"},{"location":"api/namespaceILLIXR/#variable-__threadloop_iteration_header","title":"variable __threadloop_iteration_header","text":"<pre><code>const record_header ILLIXR::__threadloop_iteration_header;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespaceILLIXR/#variable-enable_verbose_errors","title":"variable ENABLE_VERBOSE_ERRORS","text":"<pre><code>const bool ILLIXR::ENABLE_VERBOSE_ERRORS;\n</code></pre>"},{"location":"api/namespaceILLIXR/#variable-log_buffer_delay","title":"variable LOG_BUFFER_DELAY","text":"<pre><code>std::chrono::milliseconds ILLIXR::LOG_BUFFER_DELAY;\n</code></pre>"},{"location":"api/namespaceILLIXR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR/#function-abort","title":"function abort","text":"<p>Exits the application during a fatal error. <pre><code>inline void ILLIXR::abort (\n    const std::string &amp; msg=\"\",\n    const int error_val=1\n) \n</code></pre></p> <p>Switches to using abort during debugging over std::exit so that we can capture SIGABRT for debugging. </p>"},{"location":"api/namespaceILLIXR/#function-duration2double","title":"function duration2double","text":"<pre><code>template&lt;typename unit&gt;\ndouble ILLIXR::duration2double (\n    duration dur\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-freq2period","title":"function freq2period","text":"<pre><code>constexpr duration ILLIXR::freq2period (\n    double fps\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-getenv_or","title":"function getenv_or","text":"<p>Temporary environment variable getter. Not needed once #198 is merged. <pre><code>inline std::string ILLIXR::getenv_or (\n    const std::string &amp; var,\n    std::string default_\n) \n</code></pre></p>"},{"location":"api/namespaceILLIXR/#function-operator","title":"function operator!=","text":"<pre><code>inline bool ILLIXR::operator!= (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_1","title":"function operator+","text":"<pre><code>inline time_point ILLIXR::operator+ (\n    const time_point &amp; pt,\n    const time_point::duration &amp; d\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_2","title":"function operator+","text":"<pre><code>inline time_point ILLIXR::operator+ (\n    const time_point::duration &amp; d,\n    const time_point &amp; pt\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator-","title":"function operator-","text":"<pre><code>inline time_point::duration ILLIXR::operator- (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_3","title":"function operator&lt;","text":"<pre><code>inline bool ILLIXR::operator&lt; (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_4","title":"function operator&lt;=","text":"<pre><code>inline bool ILLIXR::operator&lt;= (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_5","title":"function operator==","text":"<pre><code>inline bool ILLIXR::operator== (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_6","title":"function operator&gt;","text":"<pre><code>inline bool ILLIXR::operator&gt; (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-operator_7","title":"function operator&gt;=","text":"<pre><code>inline bool ILLIXR::operator&gt;= (\n    const time_point &amp; lhs,\n    const time_point &amp; rhs\n) \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-report_and_clear_errno","title":"function report_and_clear_errno","text":"<p>Support function to report errno values when debugging (NDEBUG). <pre><code>inline void ILLIXR::report_and_clear_errno (\n    const std::string &amp; file,\n    const int &amp; line,\n    const std::string &amp; function,\n    const std::string &amp; msg=\"\"\n) \n</code></pre></p> <p>If errno is set, this function will report errno's value and the calling context. It will subsequently clear errno (reset value to 0). Otherwise, this function does nothing. </p>"},{"location":"api/namespaceILLIXR/#function-runtime_factory","title":"function runtime_factory","text":"<pre><code>runtime * ILLIXR::runtime_factory () \n</code></pre>"},{"location":"api/namespaceILLIXR/#function-str_to_bool","title":"function str_to_bool","text":"<p>Convert a string containing a (python) boolean to the bool type. <pre><code>inline bool ILLIXR::str_to_bool (\n    const std::string &amp; var\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1Event/","title":"Class ILLIXR::Event","text":"<p>ClassList &gt; ILLIXR &gt; Event</p> <p>A boolean condition-variable. More...</p> <ul> <li><code>#include &lt;stoplight.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1Event/#public-functions","title":"Public Functions","text":"Type Name void clear () Clears the condition-variable. bool is_set () constTest if is set without blocking. void set (bool new_value=true) Sets the condition-variable to new_value. void wait () constWait indefinitely for the event to be set. bool wait_timeout (const std::chrono::duration&lt; Rep, Period &gt; &amp; duration) constWait for the event to be set with a timeout."},{"location":"api/classILLIXR_1_1Event/#detailed-description","title":"Detailed Description","text":"<p>Inspired by https://docs.python.org/3/library/threading.html#event-objects </p>"},{"location":"api/classILLIXR_1_1Event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1Event/#function-clear","title":"function clear","text":"<p>Clears the condition-variable. <pre><code>inline void ILLIXR::Event::clear () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1Event/#function-is_set","title":"function is_set","text":"<p>Test if is set without blocking. <pre><code>inline bool ILLIXR::Event::is_set () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1Event/#function-set","title":"function set","text":"<p>Sets the condition-variable to new_value. <pre><code>inline void ILLIXR::Event::set (\n    bool new_value=true\n) \n</code></pre></p> <p>Defaults to true, so that set() sets the bool. </p>"},{"location":"api/classILLIXR_1_1Event/#function-wait","title":"function wait","text":"<p>Wait indefinitely for the event to be set. <pre><code>inline void ILLIXR::Event::wait () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1Event/#function-wait_timeout","title":"function wait_timeout","text":"<p>Wait for the event to be set with a timeout. <pre><code>template&lt;class Clock, class Rep, class Period&gt;\ninline bool ILLIXR::Event::wait_timeout (\n    const std::chrono::duration&lt; Rep, Period &gt; &amp; duration\n) const\n</code></pre></p> <p>Returns whether the event was actually set. </p> <p>The documentation for this class was generated from the following file <code>include/illixr/stoplight.hpp</code></p>"},{"location":"api/classILLIXR_1_1RelativeClock/","title":"Class ILLIXR::RelativeClock","text":"<p>ClassList &gt; ILLIXR &gt; RelativeClock</p> <p>Relative clock for all of ILLIXR .More...</p> <ul> <li><code>#include &lt;relative_clock.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1RelativeClock/#public-types","title":"Public Types","text":"Type Name typedef _clock_duration duration typedef _clock_period period typedef _clock_rep rep"},{"location":"api/classILLIXR_1_1RelativeClock/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr bool is_steady   = <code>true</code>"},{"location":"api/classILLIXR_1_1RelativeClock/#public-functions","title":"Public Functions","text":"Type Name int64_t absolute_ns (time_point relative)  bool is_started () constCheck if the clock is started. time_point now () const void start () Starts the clock. All times are relative to this point. time_point start_time () constGet the start time of the clock."},{"location":"api/classILLIXR_1_1RelativeClock/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1RelativeClock/#detailed-description","title":"Detailed Description","text":"<p>Please use this instead of std::chrono clocks; this way, you can fake real time without changing your code.</p> <p>It also eliminates the class of bugs relating to using absolute time instead of time-since-start.</p> <p>Unfortunately this can't satisfy Clock because it needs to have data (namely _m_start) shared across link-time boundaries. There's no clean way to do this with static variables, so instead I use instance variables and Phonebook. </p>"},{"location":"api/classILLIXR_1_1RelativeClock/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1RelativeClock/#typedef-duration","title":"typedef duration","text":"<pre><code>using ILLIXR::RelativeClock::duration =  _clock_duration;\n</code></pre>"},{"location":"api/classILLIXR_1_1RelativeClock/#typedef-period","title":"typedef period","text":"<pre><code>using ILLIXR::RelativeClock::period =  _clock_period;\n</code></pre>"},{"location":"api/classILLIXR_1_1RelativeClock/#typedef-rep","title":"typedef rep","text":"<pre><code>using ILLIXR::RelativeClock::rep =  _clock_rep;\n</code></pre>"},{"location":"api/classILLIXR_1_1RelativeClock/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1RelativeClock/#variable-is_steady","title":"variable is_steady","text":"<pre><code>constexpr bool ILLIXR::RelativeClock::is_steady;\n</code></pre>"},{"location":"api/classILLIXR_1_1RelativeClock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1RelativeClock/#function-absolute_ns","title":"function absolute_ns","text":"<pre><code>inline int64_t ILLIXR::RelativeClock::absolute_ns (\n    time_point relative\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1RelativeClock/#function-is_started","title":"function is_started","text":"<p>Check if the clock is started. <pre><code>inline bool ILLIXR::RelativeClock::is_started () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1RelativeClock/#function-now","title":"function now","text":"<pre><code>inline time_point ILLIXR::RelativeClock::now () const\n</code></pre>"},{"location":"api/classILLIXR_1_1RelativeClock/#function-start","title":"function start","text":"<p>Starts the clock. All times are relative to this point. <pre><code>inline void ILLIXR::RelativeClock::start () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1RelativeClock/#function-start_time","title":"function start_time","text":"<p>Get the start time of the clock. <pre><code>inline time_point ILLIXR::RelativeClock::start_time () const\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/illixr/relative_clock.hpp</code></p>"},{"location":"api/classILLIXR_1_1Stoplight/","title":"Class ILLIXR::Stoplight","text":"<p>ClassList &gt; ILLIXR &gt; Stoplight</p> <p>Start/stop synchronization for the whole application. More...</p> <ul> <li><code>#include &lt;stoplight.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1Stoplight/#public-functions","title":"Public Functions","text":"Type Name bool check_should_stop () const bool check_shutdown_complete () const void signal_ready ()  void signal_should_stop ()  void signal_shutdown_complete ()  void wait_for_ready () const void wait_for_shutdown_complete () const"},{"location":"api/classILLIXR_1_1Stoplight/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1Stoplight/#detailed-description","title":"Detailed Description","text":"<p>Threads should: * Do intiailization actions. * Wait for ready() * Do their main work in a loop until should_stop(). * Do their shutdown actions.</p> <p>The main thread should: * Construct and start all plugins and construct all services. * Set ready(). * Wait for shutdown_complete().</p> <p>The stopping thread should: * Someone should set should_stop(). * stop() and destruct each plugin and destruct each service. * Set shutdown_complete(). </p>"},{"location":"api/classILLIXR_1_1Stoplight/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1Stoplight/#function-check_should_stop","title":"function check_should_stop","text":"<pre><code>inline bool ILLIXR::Stoplight::check_should_stop () const\n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-check_shutdown_complete","title":"function check_shutdown_complete","text":"<pre><code>inline bool ILLIXR::Stoplight::check_shutdown_complete () const\n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-signal_ready","title":"function signal_ready","text":"<pre><code>inline void ILLIXR::Stoplight::signal_ready () \n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-signal_should_stop","title":"function signal_should_stop","text":"<pre><code>inline void ILLIXR::Stoplight::signal_should_stop () \n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-signal_shutdown_complete","title":"function signal_shutdown_complete","text":"<pre><code>inline void ILLIXR::Stoplight::signal_shutdown_complete () \n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-wait_for_ready","title":"function wait_for_ready","text":"<pre><code>inline void ILLIXR::Stoplight::wait_for_ready () const\n</code></pre>"},{"location":"api/classILLIXR_1_1Stoplight/#function-wait_for_shutdown_complete","title":"function wait_for_shutdown_complete","text":"<pre><code>inline void ILLIXR::Stoplight::wait_for_shutdown_complete () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/stoplight.hpp</code></p>"},{"location":"api/structILLIXR_1_1cam__type/","title":"Struct ILLIXR::cam_type","text":"<p>ClassList &gt; ILLIXR &gt; cam_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1cam__type/#public-attributes","title":"Public Attributes","text":"Type Name cv::Mat img0 cv::Mat img1 time_point time"},{"location":"api/structILLIXR_1_1cam__type/#public-functions","title":"Public Functions","text":"Type Name cam_type (time_point _time, cv::Mat _img0, cv::Mat _img1)"},{"location":"api/structILLIXR_1_1cam__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1cam__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1cam__type/#variable-img0","title":"variable img0","text":"<pre><code>cv::Mat ILLIXR::cam_type::img0;\n</code></pre>"},{"location":"api/structILLIXR_1_1cam__type/#variable-img1","title":"variable img1","text":"<pre><code>cv::Mat ILLIXR::cam_type::img1;\n</code></pre>"},{"location":"api/structILLIXR_1_1cam__type/#variable-time","title":"variable time","text":"<pre><code>time_point ILLIXR::cam_type::time;\n</code></pre>"},{"location":"api/structILLIXR_1_1cam__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1cam__type/#function-cam_type","title":"function cam_type","text":"<pre><code>inline ILLIXR::cam_type::cam_type (\n    time_point _time,\n    cv::Mat _img0,\n    cv::Mat _img1\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/opencv_data_types.hpp</code></p>"},{"location":"api/structILLIXR_1_1connection__signal/","title":"Struct ILLIXR::connection_signal","text":"<p>ClassList &gt; ILLIXR &gt; connection_signal</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1connection__signal/#public-attributes","title":"Public Attributes","text":"Type Name bool start"},{"location":"api/structILLIXR_1_1connection__signal/#public-functions","title":"Public Functions","text":"Type Name connection_signal (bool start_)"},{"location":"api/structILLIXR_1_1connection__signal/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1connection__signal/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1connection__signal/#variable-start","title":"variable start","text":"<pre><code>bool ILLIXR::connection_signal::start;\n</code></pre>"},{"location":"api/structILLIXR_1_1connection__signal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1connection__signal/#function-connection_signal","title":"function connection_signal","text":"<pre><code>inline ILLIXR::connection_signal::connection_signal (\n    bool start_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1data__use__indicator/","title":"Class ILLIXR::data_use_indicator","text":"<p>ClassList &gt; ILLIXR &gt; data_use_indicator</p> <p>A helper class that lets one dynamically determine if some data gets used. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions","title":"Public Functions","text":"Type Name data_use_indicator ()  data_use_indicator (const data_use_indicator &amp; other)  bool is_used () const void mark_unused () const void mark_used () const data_use_indicator &amp; operator= (const data_use_indicator &amp; other)"},{"location":"api/classILLIXR_1_1data__use__indicator/#detailed-description","title":"Detailed Description","text":"<p>When a data_use_indicator gets copied, the original is considered used and the new one is considered unused. </p>"},{"location":"api/classILLIXR_1_1data__use__indicator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-12","title":"function data_use_indicator [1/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator () \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-data_use_indicator-22","title":"function data_use_indicator [2/2]","text":"<pre><code>inline ILLIXR::data_use_indicator::data_use_indicator (\n    const data_use_indicator &amp; other\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-is_used","title":"function is_used","text":"<pre><code>inline bool ILLIXR::data_use_indicator::is_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_unused","title":"function mark_unused","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_unused () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::data_use_indicator::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1data__use__indicator/#function-operator","title":"function operator=","text":"<pre><code>inline data_use_indicator &amp; ILLIXR::data_use_indicator::operator= (\n    const data_use_indicator &amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/record_logger.hpp</code></p>"},{"location":"api/structILLIXR_1_1display__params/","title":"Struct ILLIXR::display_params","text":"<p>ClassList &gt; ILLIXR &gt; display_params</p> <p>Display parameters. </p> <ul> <li><code>#include &lt;global_module_defs.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1display__params/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float aberration   = <code>{-0.016f, 0.0f, 0.024f, 0.0f}</code> constexpr float fov_x   = <code>90.0f</code> constexpr float fov_y   = <code>90.0f</code> constexpr float frequency   = <code>120.0f</code> constexpr float height_meters   = <code>0.06214f</code> constexpr unsigned height_pixels   = <code>1440</code> constexpr float ipd   = <code>0.064f</code> constexpr float lens_separation   = <code>width\\_meters / 2.0f</code> constexpr float lens_vertical_position   = <code>height\\_meters / 2.0f</code> constexpr float meters_per_tan_angle   = <code>width\\_meters / (2 \\* (fov\\_x \\* M\\_PI / 180.0f))</code> constexpr duration period   = <code>freq2period(frequency)</code> constexpr float width_meters   = <code>0.11047f</code> constexpr unsigned width_pixels   = <code>2560</code>"},{"location":"api/structILLIXR_1_1display__params/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1display__params/#variable-aberration","title":"variable aberration","text":"<pre><code>constexpr float ILLIXR::display_params::aberration[4];\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-fov_x","title":"variable fov_x","text":"<pre><code>constexpr float ILLIXR::display_params::fov_x;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-fov_y","title":"variable fov_y","text":"<pre><code>constexpr float ILLIXR::display_params::fov_y;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-frequency","title":"variable frequency","text":"<pre><code>constexpr float ILLIXR::display_params::frequency;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-height_meters","title":"variable height_meters","text":"<pre><code>constexpr float ILLIXR::display_params::height_meters;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-height_pixels","title":"variable height_pixels","text":"<pre><code>constexpr unsigned ILLIXR::display_params::height_pixels;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-ipd","title":"variable ipd","text":"<pre><code>constexpr float ILLIXR::display_params::ipd;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-lens_separation","title":"variable lens_separation","text":"<pre><code>constexpr float ILLIXR::display_params::lens_separation;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-lens_vertical_position","title":"variable lens_vertical_position","text":"<pre><code>constexpr float ILLIXR::display_params::lens_vertical_position;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-meters_per_tan_angle","title":"variable meters_per_tan_angle","text":"<pre><code>constexpr float ILLIXR::display_params::meters_per_tan_angle;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-period","title":"variable period","text":"<pre><code>constexpr duration ILLIXR::display_params::period;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-width_meters","title":"variable width_meters","text":"<pre><code>constexpr float ILLIXR::display_params::width_meters;\n</code></pre>"},{"location":"api/structILLIXR_1_1display__params/#variable-width_pixels","title":"variable width_pixels","text":"<pre><code>constexpr unsigned ILLIXR::display_params::width_pixels;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/classILLIXR_1_1dynamic__lib/","title":"Class ILLIXR::dynamic_lib","text":"<p>ClassList &gt; ILLIXR &gt; dynamic_lib</p>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions","title":"Public Functions","text":"Type Name dynamic_lib (dynamic_lib &amp;&amp; other) noexcept const T get (const std::string &amp; symbol_name) const dynamic_lib &amp; operator= (dynamic_lib &amp;&amp; other) noexcept const void * operator[] (const std::string &amp; symbol_name) const ~dynamic_lib ()"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions","title":"Public Static Functions","text":"Type Name dynamic_lib create (const std::string &amp; path)  dynamic_lib create (const std::string_view &amp; path)"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-dynamic_lib-22","title":"function dynamic_lib [2/2]","text":"<pre><code>inline ILLIXR::dynamic_lib::dynamic_lib (\n    dynamic_lib &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-get","title":"function get","text":"<pre><code>template&lt;typename T&gt;\ninline const T ILLIXR::dynamic_lib::get (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator","title":"function operator=","text":"<pre><code>inline dynamic_lib &amp; ILLIXR::dynamic_lib::operator= (\n    dynamic_lib &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const void * ILLIXR::dynamic_lib::operator[] (\n    const std::string &amp; symbol_name\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-dynamic_lib","title":"function ~dynamic_lib","text":"<pre><code>inline ILLIXR::dynamic_lib::~dynamic_lib () \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classILLIXR_1_1dynamic__lib/#function-create-12","title":"function create [1/2]","text":"<pre><code>static inline dynamic_lib ILLIXR::dynamic_lib::create (\n    const std::string &amp; path\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1dynamic__lib/#function-create-22","title":"function create [2/2]","text":"<pre><code>static inline dynamic_lib ILLIXR::dynamic_lib::create (\n    const std::string_view &amp; path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/dynamic_lib.hpp</code></p>"},{"location":"api/structILLIXR_1_1fast__pose__type/","title":"Struct ILLIXR::fast_pose_type","text":"<p>ClassList &gt; ILLIXR &gt; fast_pose_type</p>"},{"location":"api/structILLIXR_1_1fast__pose__type/#public-attributes","title":"Public Attributes","text":"Type Name pose_type pose time_point predict_computed_time time_point predict_target_time"},{"location":"api/structILLIXR_1_1fast__pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1fast__pose__type/#variable-pose","title":"variable pose","text":"<pre><code>pose_type ILLIXR::fast_pose_type::pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1fast__pose__type/#variable-predict_computed_time","title":"variable predict_computed_time","text":"<pre><code>time_point ILLIXR::fast_pose_type::predict_computed_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1fast__pose__type/#variable-predict_target_time","title":"variable predict_target_time","text":"<pre><code>time_point ILLIXR::fast_pose_type::predict_target_time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1gen__guid/","title":"Class ILLIXR::gen_guid","text":"<p>ClassList &gt; ILLIXR &gt; gen_guid</p> <p>This class generates unique IDs. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions","title":"Public Functions","text":"Type Name std::size_t get (std::size_t namespace_=0, std::size_t subnamespace=0, std::size_t subsubnamespace=0) Generate a number, unique from other calls to the same namespace/subnamespace/subsubnamepsace."},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1gen__guid/#detailed-description","title":"Detailed Description","text":"<p>If you need unique IDs (e.g. for each component), have each component call this class through Phonebook. It returns unique IDs.</p> <p>You can use namespaces to express logical containment. The return value will be unique between other <code>get</code> calls to the same namespace. This is useful for components and sub-components. For example, If component with ID 0 has 3 subcomponents, one might call get(0) to name each of them. Then, suppose component with ID 1 has 2 subcomponents, one might call get(1) twice to name those. The subcomponent IDs could be reused (non-unique), but tuple (component ID, subcomponent ID) will still be unique. You can also just use the global namespace for everything, if you do not care about generating small integers for the IDs. </p>"},{"location":"api/classILLIXR_1_1gen__guid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1gen__guid/#function-get","title":"function get","text":"<p>Generate a number, unique from other calls to the same namespace/subnamespace/subsubnamepsace. <pre><code>inline std::size_t ILLIXR::gen_guid::get (\n    std::size_t namespace_=0,\n    std::size_t subnamespace=0,\n    std::size_t subsubnamespace=0\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/illixr/record_logger.hpp</code></p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/","title":"Struct ILLIXR::hmd_physical_info","text":"<p>ClassList &gt; ILLIXR &gt; hmd_physical_info</p>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes","title":"Public Attributes","text":"Type Name float K float chromaticAberration int displayPixelsHigh int displayPixelsWide float ipd float lensSeparationInMeters float metersPerTanAngleAtCenter float visibleMetersHigh float visibleMetersWide int visiblePixelsHigh int visiblePixelsWide"},{"location":"api/structILLIXR_1_1hmd__physical__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-k","title":"variable K","text":"<pre><code>float ILLIXR::hmd_physical_info::K[11];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-chromaticaberration","title":"variable chromaticAberration","text":"<pre><code>float ILLIXR::hmd_physical_info::chromaticAberration[4];\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelshigh","title":"variable displayPixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-displaypixelswide","title":"variable displayPixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::displayPixelsWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-ipd","title":"variable ipd","text":"<pre><code>float ILLIXR::hmd_physical_info::ipd;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-lensseparationinmeters","title":"variable lensSeparationInMeters","text":"<pre><code>float ILLIXR::hmd_physical_info::lensSeparationInMeters;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-meterspertanangleatcenter","title":"variable metersPerTanAngleAtCenter","text":"<pre><code>float ILLIXR::hmd_physical_info::metersPerTanAngleAtCenter;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemetershigh","title":"variable visibleMetersHigh","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblemeterswide","title":"variable visibleMetersWide","text":"<pre><code>float ILLIXR::hmd_physical_info::visibleMetersWide;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelshigh","title":"variable visiblePixelsHigh","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsHigh;\n</code></pre>"},{"location":"api/structILLIXR_1_1hmd__physical__info/#variable-visiblepixelswide","title":"variable visiblePixelsWide","text":"<pre><code>int ILLIXR::hmd_physical_info::visiblePixelsWide;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1hologram__input/","title":"Struct ILLIXR::hologram_input","text":"<p>ClassList &gt; ILLIXR &gt; hologram_input</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes","title":"Public Attributes","text":"Type Name uint seq   = <code>{}</code>"},{"location":"api/structILLIXR_1_1hologram__input/#public-functions","title":"Public Functions","text":"Type Name hologram_input () = default hologram_input (uint seq_)"},{"location":"api/structILLIXR_1_1hologram__input/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1hologram__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__input/#variable-seq","title":"variable seq","text":"<pre><code>uint ILLIXR::hologram_input::seq;\n</code></pre>"},{"location":"api/structILLIXR_1_1hologram__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1hologram__input/#function-hologram_input-12","title":"function hologram_input [1/2]","text":"<pre><code>ILLIXR::hologram_input::hologram_input () = default\n</code></pre>"},{"location":"api/structILLIXR_1_1hologram__input/#function-hologram_input-22","title":"function hologram_input [2/2]","text":"<pre><code>inline explicit ILLIXR::hologram_input::hologram_input (\n    uint seq_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1image__handle/","title":"Struct ILLIXR::image_handle","text":"<p>ClassList &gt; ILLIXR &gt; image_handle</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1image__handle/#public-attributes","title":"Public Attributes","text":"Type Name union ILLIXR::image_handle image_handle GLuint gl_handle uint32_t num_images graphics_api type swapchain_usage usage vk_image_handle vk_handle"},{"location":"api/structILLIXR_1_1image__handle/#public-functions","title":"Public Functions","text":"Type Name image_handle ()  image_handle (GLuint gl_handle_, uint32_t num_images_, swapchain_usage usage_)  image_handle (int vk_fd_, int64_t format, size_t alloc_size, uint32_t width_, uint32_t height_, uint32_t num_images_, swapchain_usage usage_)"},{"location":"api/structILLIXR_1_1image__handle/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1image__handle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1image__handle/#variable-image_handle","title":"variable image_handle","text":"<pre><code>union ILLIXR::image_handle ILLIXR::image_handle;\n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#variable-gl_handle","title":"variable gl_handle","text":"<pre><code>GLuint ILLIXR::image_handle::gl_handle;\n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#variable-num_images","title":"variable num_images","text":"<pre><code>uint32_t ILLIXR::image_handle::num_images;\n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#variable-type","title":"variable type","text":"<pre><code>graphics_api ILLIXR::image_handle::type;\n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#variable-usage","title":"variable usage","text":"<pre><code>swapchain_usage ILLIXR::image_handle::usage;\n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#variable-vk_handle","title":"variable vk_handle","text":"<pre><code>vk_image_handle ILLIXR::image_handle::vk_handle;\n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1image__handle/#function-image_handle-13","title":"function image_handle [1/3]","text":"<pre><code>inline ILLIXR::image_handle::image_handle () \n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#function-image_handle-23","title":"function image_handle [2/3]","text":"<pre><code>inline ILLIXR::image_handle::image_handle (\n    GLuint gl_handle_,\n    uint32_t num_images_,\n    swapchain_usage usage_\n) \n</code></pre>"},{"location":"api/structILLIXR_1_1image__handle/#function-image_handle-33","title":"function image_handle [3/3]","text":"<pre><code>inline ILLIXR::image_handle::image_handle (\n    int vk_fd_,\n    int64_t format,\n    size_t alloc_size,\n    uint32_t width_,\n    uint32_t height_,\n    uint32_t num_images_,\n    swapchain_usage usage_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__integrator__input/","title":"Struct ILLIXR::imu_integrator_input","text":"<p>ClassList &gt; ILLIXR &gt; imu_integrator_input</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3d biasAcc Eigen::Vector3d biasGyro time_point last_cam_integration_time imu_params params Eigen::Matrix&lt; double, 3, 1 &gt; position Eigen::Quaterniond quat duration t_offset Eigen::Matrix&lt; double, 3, 1 &gt; velocity"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-functions","title":"Public Functions","text":"Type Name imu_integrator_input (time_point last_cam_integration_time_, duration t_offset_, imu_params params_, Eigen::Vector3d biasAcc_, Eigen::Vector3d biasGyro_, Eigen::Matrix&lt; double, 3, 1 &gt; position_, Eigen::Matrix&lt; double, 3, 1 &gt; velocity_, Eigen::Quaterniond quat_)"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-biasacc","title":"variable biasAcc","text":"<pre><code>Eigen::Vector3d ILLIXR::imu_integrator_input::biasAcc;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-biasgyro","title":"variable biasGyro","text":"<pre><code>Eigen::Vector3d ILLIXR::imu_integrator_input::biasGyro;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-last_cam_integration_time","title":"variable last_cam_integration_time","text":"<pre><code>time_point ILLIXR::imu_integrator_input::last_cam_integration_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-params","title":"variable params","text":"<pre><code>imu_params ILLIXR::imu_integrator_input::params;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-position","title":"variable position","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_integrator_input::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-quat","title":"variable quat","text":"<pre><code>Eigen::Quaterniond ILLIXR::imu_integrator_input::quat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-t_offset","title":"variable t_offset","text":"<pre><code>duration ILLIXR::imu_integrator_input::t_offset;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#variable-velocity","title":"variable velocity","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_integrator_input::velocity;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__integrator__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1imu__integrator__input/#function-imu_integrator_input","title":"function imu_integrator_input","text":"<pre><code>inline ILLIXR::imu_integrator_input::imu_integrator_input (\n    time_point last_cam_integration_time_,\n    duration t_offset_,\n    imu_params params_,\n    Eigen::Vector3d biasAcc_,\n    Eigen::Vector3d biasGyro_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; position_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; velocity_,\n    Eigen::Quaterniond quat_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__params/","title":"Struct ILLIXR::imu_params","text":"<p>ClassList &gt; ILLIXR &gt; imu_params</p>"},{"location":"api/structILLIXR_1_1imu__params/#public-attributes","title":"Public Attributes","text":"Type Name double acc_noise double acc_walk double gyro_noise double gyro_walk double imu_integration_sigma Eigen::Matrix&lt; double, 3, 1 &gt; n_gravity double nominal_rate"},{"location":"api/structILLIXR_1_1imu__params/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__params/#variable-acc_noise","title":"variable acc_noise","text":"<pre><code>double ILLIXR::imu_params::acc_noise;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-acc_walk","title":"variable acc_walk","text":"<pre><code>double ILLIXR::imu_params::acc_walk;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-gyro_noise","title":"variable gyro_noise","text":"<pre><code>double ILLIXR::imu_params::gyro_noise;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-gyro_walk","title":"variable gyro_walk","text":"<pre><code>double ILLIXR::imu_params::gyro_walk;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-imu_integration_sigma","title":"variable imu_integration_sigma","text":"<pre><code>double ILLIXR::imu_params::imu_integration_sigma;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-n_gravity","title":"variable n_gravity","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_params::n_gravity;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__params/#variable-nominal_rate","title":"variable nominal_rate","text":"<pre><code>double ILLIXR::imu_params::nominal_rate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__raw__type/","title":"Struct ILLIXR::imu_raw_type","text":"<p>ClassList &gt; ILLIXR &gt; imu_raw_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Matrix&lt; double, 3, 1 &gt; a_hat Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2 time_point imu_time Eigen::Matrix&lt; double, 3, 1 &gt; pos Eigen::Quaterniond quat Eigen::Matrix&lt; double, 3, 1 &gt; vel Eigen::Matrix&lt; double, 3, 1 &gt; w_hat Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-functions","title":"Public Functions","text":"Type Name imu_raw_type (Eigen::Matrix&lt; double, 3, 1 &gt; w_hat_, Eigen::Matrix&lt; double, 3, 1 &gt; a_hat_, Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2_, Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2_, Eigen::Matrix&lt; double, 3, 1 &gt; pos_, Eigen::Matrix&lt; double, 3, 1 &gt; vel_, Eigen::Quaterniond quat_, time_point imu_time_)"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-a_hat","title":"variable a_hat","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_raw_type::a_hat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-a_hat2","title":"variable a_hat2","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_raw_type::a_hat2;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-imu_time","title":"variable imu_time","text":"<pre><code>time_point ILLIXR::imu_raw_type::imu_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-pos","title":"variable pos","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_raw_type::pos;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-quat","title":"variable quat","text":"<pre><code>Eigen::Quaterniond ILLIXR::imu_raw_type::quat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-vel","title":"variable vel","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_raw_type::vel;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-w_hat","title":"variable w_hat","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_raw_type::w_hat;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#variable-w_hat2","title":"variable w_hat2","text":"<pre><code>Eigen::Matrix&lt;double, 3, 1&gt; ILLIXR::imu_raw_type::w_hat2;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__raw__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1imu__raw__type/#function-imu_raw_type","title":"function imu_raw_type","text":"<pre><code>inline ILLIXR::imu_raw_type::imu_raw_type (\n    Eigen::Matrix&lt; double, 3, 1 &gt; w_hat_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; a_hat_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; w_hat2_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; a_hat2_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; pos_,\n    Eigen::Matrix&lt; double, 3, 1 &gt; vel_,\n    Eigen::Quaterniond quat_,\n    time_point imu_time_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1imu__type/","title":"Struct ILLIXR::imu_type","text":"<p>ClassList &gt; ILLIXR &gt; imu_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1imu__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Vector3d angular_v Eigen::Vector3d linear_a time_point time"},{"location":"api/structILLIXR_1_1imu__type/#public-functions","title":"Public Functions","text":"Type Name imu_type (time_point time_, Eigen::Vector3d angular_v_, Eigen::Vector3d linear_a_)"},{"location":"api/structILLIXR_1_1imu__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1imu__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1imu__type/#variable-angular_v","title":"variable angular_v","text":"<pre><code>Eigen::Vector3d ILLIXR::imu_type::angular_v;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__type/#variable-linear_a","title":"variable linear_a","text":"<pre><code>Eigen::Vector3d ILLIXR::imu_type::linear_a;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__type/#variable-time","title":"variable time","text":"<pre><code>time_point ILLIXR::imu_type::time;\n</code></pre>"},{"location":"api/structILLIXR_1_1imu__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1imu__type/#function-imu_type","title":"function imu_type","text":"<pre><code>inline ILLIXR::imu_type::imu_type (\n    time_point time_,\n    Eigen::Vector3d angular_v_,\n    Eigen::Vector3d linear_a_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1managed__thread/","title":"Class ILLIXR::managed_thread","text":"<p>ClassList &gt; ILLIXR &gt; managed_thread</p> <p>An object that manages a std::thread; it joins and exits when the object gets destructed. </p> <ul> <li><code>#include &lt;managed_thread.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1managed__thread/#public-types","title":"Public Types","text":"Type Name enum state Possible states for a managed_thread ."},{"location":"api/classILLIXR_1_1managed__thread/#public-functions","title":"Public Functions","text":"Type Name state get_state ()  managed_thread () noexceptConstructs a non-startable thread. managed_thread (std::function&lt; void()&gt; body, std::function&lt; void()&gt; on_start=std::function&lt; void()&gt;{}, std::function&lt; void()&gt; on_stop=std::function&lt; void()&gt;{}) noexceptConstructs a startable thread. void start () Moves a managed_thread from startable to running. void stop () Moves a managed_thread from running to stopped. ~managed_thread () noexceptStops a thread, if necessary."},{"location":"api/classILLIXR_1_1managed__thread/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1managed__thread/#enum-state","title":"enum state","text":"<p>Possible states for a managed_thread . <pre><code>enum ILLIXR::managed_thread::state {\n    nonstartable,\n    startable,\n    running,\n    stopped\n};\n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1managed__thread/#function-get_state","title":"function get_state","text":"<pre><code>inline state ILLIXR::managed_thread::get_state () \n</code></pre>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread-12","title":"function managed_thread [1/2]","text":"<p>Constructs a non-startable thread. <pre><code>ILLIXR::managed_thread::managed_thread () noexcept\n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread-22","title":"function managed_thread [2/2]","text":"<p>Constructs a startable thread. <pre><code>inline explicit ILLIXR::managed_thread::managed_thread (\n    std::function&lt; void()&gt; body,\n    std::function&lt; void()&gt; on_start=std::function&lt; void()&gt;{},\n    std::function&lt; void()&gt; on_stop=std::function&lt; void()&gt;{}\n) noexcept\n</code></pre></p> <p><code>on_stop</code> is called once (if present) <code>on_start</code> is called as the thread is joining <code>body</code> is called in a tight loop </p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-start","title":"function start","text":"<p>Moves a managed_thread from startable to running. <pre><code>inline void ILLIXR::managed_thread::start () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-stop","title":"function stop","text":"<p>Moves a managed_thread from running to stopped. <pre><code>inline void ILLIXR::managed_thread::stop () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1managed__thread/#function-managed_thread","title":"function ~managed_thread","text":"<p>Stops a thread, if necessary. <pre><code>inline ILLIXR::managed_thread::~managed_thread () noexcept\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/illixr/managed_thread.hpp</code></p>"},{"location":"api/namespaceILLIXR_1_1math__util/","title":"Namespace ILLIXR::math_util","text":"<p>Namespace List &gt; ILLIXR &gt; math_util</p>"},{"location":"api/namespaceILLIXR_1_1math__util/#public-functions","title":"Public Functions","text":"Type Name void projection (Eigen::Matrix4f * result, const float tan_left, const float tan_right, const float tan_up, float const tan_down, const float near_z, const float far_z) Calculates a projection matrix with the given tangent angles and clip planes. void projection_fov (Eigen::Matrix4f * result, const float fov_left, const float fov_right, const float fov_up, const float fov_down, const float near_z, const float far_z) Calculates a projection matrix with the given FoVs and clip planes."},{"location":"api/namespaceILLIXR_1_1math__util/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespaceILLIXR_1_1math__util/#function-projection","title":"function projection","text":"<p>Calculates a projection matrix with the given tangent angles and clip planes. <pre><code>void ILLIXR::math_util::projection (\n    Eigen::Matrix4f * result,\n    const float tan_left,\n    const float tan_right,\n    const float tan_up,\n    float const tan_down,\n    const float near_z,\n    const float far_z\n) \n</code></pre></p>"},{"location":"api/namespaceILLIXR_1_1math__util/#function-projection_fov","title":"function projection_fov","text":"<p>Calculates a projection matrix with the given FoVs and clip planes. <pre><code>void ILLIXR::math_util::projection_fov (\n    Eigen::Matrix4f * result,\n    const float fov_left,\n    const float fov_right,\n    const float fov_up,\n    const float fov_down,\n    const float near_z,\n    const float far_z\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/illixr/math_util.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook/","title":"Class ILLIXR::phonebook","text":"<p>ClassList &gt; ILLIXR &gt; phonebook</p> <p>A service locator forILLIXR .More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#classes","title":"Classes","text":"Type Name class service A 'service' that can be registered in the phonebook."},{"location":"api/classILLIXR_1_1phonebook/#public-functions","title":"Public Functions","text":"Type Name std::shared_ptr&lt; specific_service &gt; lookup_impl () constLook up an implementation of <code>specific_service</code> , which should be registered first. void register_impl (std::shared_ptr&lt; specific_service &gt; impl) Registers an implementation of <code>baseclass</code> for future calls to lookup."},{"location":"api/classILLIXR_1_1phonebook/#detailed-description","title":"Detailed Description","text":"<p>This will be explained through an exmaple: Suppose one dynamically-loaded plugin, <code>A_plugin</code>, needs a service, <code>B_service</code>, provided by another, <code>B_plugin</code>. <code>A_plugin</code> cannot statically construct a <code>B_service</code>, because the implementation <code>B_plugin</code> is dynamically loaded. However, <code>B_plugin</code> can register an implementation of <code>B_service</code> when it is loaded, and <code>A_plugin</code> can lookup that implementation without knowing it.</p> <p><code>B_service.hpp</code> in <code>common</code>:  <pre><code>class B_service {\npublic:\n    virtual void frobnicate(foo data) = 0;\n};\n</code></pre></p> <p><code>B_plugin.hpp</code>:  <pre><code>class B_impl : public B_service {\npublic:\n    virtual void frobnicate(foo data) {\n        // ...\n    }\n};\nvoid blah_blah(phonebook* pb) {\n    // Expose `this` as the \"official\" implementation of `B_service` for this run.\n    pb-&gt;register_impl&lt;B_service&gt;(std::make_shared&lt;B_impl&gt;());\n}\n</code></pre></p> <p><code>A_plugin.cpp</code>:  <pre><code>#include \"B_service.hpp\"\nvoid blah_blah(phonebook* pb) {\n    B_service* b = pb-&gt;lookup_impl&lt;B_service&gt;();\n    b-&gt;frobnicate(data);\n}\n</code></pre></p> <p>If the implementation of <code>B_service</code> is not known to <code>A_plugin</code> (the usual case), <code>B_service should be an [abstract class][2]. In either case</code>B_service<code>should be in</code>common`, so both plugins can refer to it.</p> <p>One could even selectively return a different implementation of <code>B_service</code> depending on the caller (through the parameters), but we have not encountered the need for that yet. </p>"},{"location":"api/classILLIXR_1_1phonebook/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook/#function-lookup_impl","title":"function lookup_impl","text":"<p>Look up an implementation of <code>specific_service</code> , which should be registered first. <pre><code>template&lt;typename specific_service&gt;\ninline std::shared_ptr&lt; specific_service &gt; ILLIXR::phonebook::lookup_impl () const\n</code></pre></p> <p>Safe to be called from any thread.</p> <p>Do not call <code>delete</code> on the returned object; it is still managed by phonebook.</p> <p>Exception:</p> <ul> <li><code>if</code> an implementation is not already registered. </li> </ul>"},{"location":"api/classILLIXR_1_1phonebook/#function-register_impl","title":"function register_impl","text":"<p>Registers an implementation of <code>baseclass</code> for future calls to lookup. <pre><code>template&lt;typename specific_service&gt;\ninline void ILLIXR::phonebook::register_impl (\n    std::shared_ptr&lt; specific_service &gt; impl\n) \n</code></pre></p> <p>Safe to be called from any thread.</p> <p>The implementation will be owned by phonebook (phonebook calls <code>delete</code>). </p> <p>The documentation for this class was generated from the following file <code>include/illixr/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/","title":"Class ILLIXR::phonebook::service","text":"<p>ClassList &gt; ILLIXR &gt; phonebook &gt; service</p> <p>A 'service' that can be registered in the phonebook. More...</p> <ul> <li><code>#include &lt;phonebook.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::RelativeClock,  ILLIXR::Stoplight,  ILLIXR::gen_guid,  ILLIXR::record_logger,  ILLIXR::switchboard,  ILLIXR::xlib_gl_extended_window,  pose_prediction</p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions","title":"Public Functions","text":"Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#detailed-description","title":"Detailed Description","text":"<p>These must be 'destructible', have a virtual destructor that phonebook can call in its destructor. </p>"},{"location":"api/classILLIXR_1_1phonebook_1_1service/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1phonebook_1_1service/#function-service","title":"function ~service","text":"<pre><code>virtual ILLIXR::phonebook::service::~service () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/phonebook.hpp</code></p>"},{"location":"api/classILLIXR_1_1plugin/","title":"Class ILLIXR::plugin","text":"<p>ClassList &gt; ILLIXR &gt; plugin</p> <p>A dynamically-loadable plugin for Spindle. </p> <ul> <li><code>#include &lt;plugin.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::threadloop</p>"},{"location":"api/classILLIXR_1_1plugin/#public-functions","title":"Public Functions","text":"Type Name std::string get_name () noexcept const plugin (std::string name_, phonebook * pb_)  void spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes","title":"Protected Attributes","text":"Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id std::string name const phonebook * pb const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1plugin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#function-get_name","title":"function get_name","text":"<pre><code>inline std::string ILLIXR::plugin::get_name () noexcept const\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin","title":"function plugin","text":"<pre><code>inline ILLIXR::plugin::plugin (\n    std::string name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-spdlogger","title":"function spdlogger","text":"<pre><code>inline void ILLIXR::plugin::spdlogger (\n    const char * log_level\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#function-start","title":"function start","text":"<p>A method which Spindle calls when it starts the component. <pre><code>inline virtual void ILLIXR::plugin::start () \n</code></pre></p> <p>This is necessary because a constructor can't call derived virtual methods (due to structure of C++). See <code>threadloop</code> for an example of this use-case. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-stop","title":"function stop","text":"<p>A method which Spindle calls when it stops the component. <pre><code>inline virtual void ILLIXR::plugin::stop () \n</code></pre></p> <p>This is necessary because the parent class might define some actions that need to be taken prior to destructing the derived class. For example, threadloop must halt and join the thread before the derived class can be safely destructed. However, the derived class's destructor is called before its parent (threadloop), so threadloop doesn't get a chance to join the thread before the derived class is destroyed, and the thread accesses freed memory. Instead, we call plugin-&gt;stop manually before destrying anything.</p> <p>Concrete plugins are responsible for initializing their specific logger and sinks. </p>"},{"location":"api/classILLIXR_1_1plugin/#function-plugin_1","title":"function ~plugin","text":"<pre><code>virtual ILLIXR::plugin::~plugin () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1plugin/#variable-gen_guid_","title":"variable gen_guid_","text":"<pre><code>const std::shared_ptr&lt;gen_guid&gt; ILLIXR::plugin::gen_guid_;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-id","title":"variable id","text":"<pre><code>const std::size_t ILLIXR::plugin::id;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-name","title":"variable name","text":"<pre><code>std::string ILLIXR::plugin::name;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-pb","title":"variable pb","text":"<pre><code>const phonebook* ILLIXR::plugin::pb;\n</code></pre>"},{"location":"api/classILLIXR_1_1plugin/#variable-record_logger_","title":"variable record_logger_","text":"<pre><code>const std::shared_ptr&lt;record_logger&gt; ILLIXR::plugin::record_logger_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/plugin.hpp</code></p>"},{"location":"api/structILLIXR_1_1pose__type/","title":"Struct ILLIXR::pose_type","text":"<p>ClassList &gt; ILLIXR &gt; pose_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes","title":"Public Attributes","text":"Type Name Eigen::Quaternionf orientation Eigen::Vector3f position time_point sensor_time"},{"location":"api/structILLIXR_1_1pose__type/#public-functions","title":"Public Functions","text":"Type Name pose_type ()  pose_type (time_point sensor_time_, Eigen::Vector3f position_, Eigen::Quaternionf orientation_)"},{"location":"api/structILLIXR_1_1pose__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1pose__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1pose__type/#variable-orientation","title":"variable orientation","text":"<pre><code>Eigen::Quaternionf ILLIXR::pose_type::orientation;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3f ILLIXR::pose_type::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#variable-sensor_time","title":"variable sensor_time","text":"<pre><code>time_point ILLIXR::pose_type::sensor_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1pose__type/#function-pose_type-12","title":"function pose_type [1/2]","text":"<pre><code>inline ILLIXR::pose_type::pose_type () \n</code></pre>"},{"location":"api/structILLIXR_1_1pose__type/#function-pose_type-22","title":"function pose_type [2/2]","text":"<pre><code>inline ILLIXR::pose_type::pose_type (\n    time_point sensor_time_,\n    Eigen::Vector3f position_,\n    Eigen::Quaternionf orientation_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1record/","title":"Class ILLIXR::record","text":"<p>ClassList &gt; ILLIXR &gt; record</p> <p>This class represents a tuple of fields which get logged by <code>record_logger</code> .More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record/#public-functions","title":"Public Functions","text":"Type Name const record_header &amp; get_record_header () const T get_value (unsigned column) const void mark_used () const record (const record_header &amp; rh_, std::vector&lt; std::any &gt; values_)  record () = default ~record ()"},{"location":"api/classILLIXR_1_1record/#detailed-description","title":"Detailed Description","text":"<p><code>rh_</code> is a pointer rather than a reference for historical reasons. It should not be null. </p>"},{"location":"api/classILLIXR_1_1record/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record/#function-get_record_header","title":"function get_record_header","text":"<pre><code>inline const record_header &amp; ILLIXR::record::get_record_header () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-get_value","title":"function get_value","text":"<pre><code>template&lt;typename T&gt;\ninline T ILLIXR::record::get_value (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-mark_used","title":"function mark_used","text":"<pre><code>inline void ILLIXR::record::mark_used () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record-12","title":"function record [1/2]","text":"<pre><code>inline ILLIXR::record::record (\n    const record_header &amp; rh_,\n    std::vector&lt; std::any &gt; values_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record-22","title":"function record [2/2]","text":"<pre><code>ILLIXR::record::record () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1record/#function-record","title":"function ~record","text":"<pre><code>inline ILLIXR::record::~record () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__coalescer/","title":"Class ILLIXR::record_coalescer","text":"<p>ClassList &gt; ILLIXR &gt; record_coalescer</p> <p>Coalesces logs of the same type to be written back as a single-transaction. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions","title":"Public Functions","text":"Type Name void flush () Flush buffer of logs to the underlying logger. void log (const record &amp; r) Appends a log to the buffer, which will eventually be written. void maybe_flush () Use internal decision process, and possibly trigger flush. operator bool () const record_coalescer (std::shared_ptr&lt; record_logger &gt; logger_)  ~record_coalescer ()"},{"location":"api/classILLIXR_1_1record__coalescer/#detailed-description","title":"Detailed Description","text":"<p>Records should all be of the same type. TODO: remove this constraint. Use <code>log&lt;record_type&gt;(Args... args)</code> and <code>std::forward</code>.</p> <p>In some backend-implementations, logging many logs of the same type is more efficient than logging them individually; However, the client often wants to produce one log-record at a time. This class resolves this mismatch by buffering logs from the client. Every time a new log is added, an internal decision process determines whether or not to flush the buffer, or keep accumulating and wait unitl later.</p> <p>Currently this internal decision process is \"is the oldest log in the buffer more than 1 second old?\". I chose this because this frequency should have very little overhead, even if every component is also coalescing at 1 per second.</p> <p>At destructor time, any remaining logs are flushed.</p> <p>Use like:</p> <pre><code>log_coalescer(logger);\nlc.log(make_my_record(id, it, skip_it, ...));\n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__coalescer/#function-flush","title":"function flush","text":"<p>Flush buffer of logs to the underlying logger. <pre><code>inline void ILLIXR::record_coalescer::flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-log","title":"function log","text":"<p>Appends a log to the buffer, which will eventually be written. <pre><code>inline void ILLIXR::record_coalescer::log (\n    const record &amp; r\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-maybe_flush","title":"function maybe_flush","text":"<p>Use internal decision process, and possibly trigger flush. <pre><code>inline void ILLIXR::record_coalescer::maybe_flush () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit ILLIXR::record_coalescer::operator bool () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer","title":"function record_coalescer","text":"<pre><code>inline explicit ILLIXR::record_coalescer::record_coalescer (\n    std::shared_ptr&lt; record_logger &gt; logger_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__coalescer/#function-record_coalescer_1","title":"function ~record_coalescer","text":"<pre><code>inline ILLIXR::record_coalescer::~record_coalescer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__header/","title":"Class ILLIXR::record_header","text":"<p>ClassList &gt; ILLIXR &gt; record_header</p> <p>Schema of each record. More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1record__header/#public-functions","title":"Public Functions","text":"Type Name const std::string &amp; get_column_name (unsigned column) const const std::type_info &amp; get_column_type (unsigned column) const unsigned get_columns () const std::size_t get_id () const const std::string &amp; get_name () const bool operator!= (const record_header &amp; other) const bool operator== (const record_header &amp; other) constCompares two schemata. record_header (const std::string &amp; name_, std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_)  std::string to_string () const"},{"location":"api/classILLIXR_1_1record__header/#detailed-description","title":"Detailed Description","text":"<p>name_ should be globally unique. </p>"},{"location":"api/classILLIXR_1_1record__header/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__header/#function-get_column_name","title":"function get_column_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_column_name (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_column_type","title":"function get_column_type","text":"<pre><code>inline const std::type_info &amp; ILLIXR::record_header::get_column_type (\n    unsigned column\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_columns","title":"function get_columns","text":"<pre><code>inline unsigned ILLIXR::record_header::get_columns () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_id","title":"function get_id","text":"<pre><code>inline std::size_t ILLIXR::record_header::get_id () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-get_name","title":"function get_name","text":"<pre><code>inline const std::string &amp; ILLIXR::record_header::get_name () const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator","title":"function operator!=","text":"<pre><code>inline bool ILLIXR::record_header::operator!= (\n    const record_header &amp; other\n) const\n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-operator_1","title":"function operator==","text":"<p>Compares two schemata. <pre><code>inline bool ILLIXR::record_header::operator== (\n    const record_header &amp; other\n) const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__header/#function-record_header","title":"function record_header","text":"<pre><code>inline ILLIXR::record_header::record_header (\n    const std::string &amp; name_,\n    std::vector&lt; std::pair&lt; std::string, const std::type_info &amp; &gt; &gt; columns_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1record__header/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string ILLIXR::record_header::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/record_logger.hpp</code></p>"},{"location":"api/classILLIXR_1_1record__logger/","title":"Class ILLIXR::record_logger","text":"<p>ClassList &gt; ILLIXR &gt; record_logger</p> <p>The ILLIXR logging service for structured records.More...</p> <ul> <li><code>#include &lt;record_logger.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions","title":"Public Functions","text":"Type Name virtual void log (const record &amp; r) = 0Writes one log record. virtual void log (const std::vector&lt; record &gt; &amp; rs) Writes many of the same type of log record. ~record_logger () override"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1record__logger/#detailed-description","title":"Detailed Description","text":"<p>This has two advantages over printf logging. It has lower overhead (because it goes into a database), won't result in spliced messages (no stdout race-conditions), and is used uniformly by ILLIXR components. </p>"},{"location":"api/classILLIXR_1_1record__logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1record__logger/#function-log-12","title":"function log [1/2]","text":"<p>Writes one log record. <pre><code>virtual void ILLIXR::record_logger::log (\n    const record &amp; r\n) = 0\n</code></pre></p>"},{"location":"api/classILLIXR_1_1record__logger/#function-log-22","title":"function log [2/2]","text":"<p>Writes many of the same type of log record. <pre><code>inline virtual void ILLIXR::record_logger::log (\n    const std::vector&lt; record &gt; &amp; rs\n) \n</code></pre></p> <p>This is more efficient than calling log many times. </p>"},{"location":"api/classILLIXR_1_1record__logger/#function-record_logger","title":"function ~record_logger","text":"<pre><code>ILLIXR::record_logger::~record_logger () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/record_logger.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendered__frame/","title":"Struct ILLIXR::rendered_frame","text":"<p>ClassList &gt; ILLIXR &gt; rendered_frame</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes","title":"Public Attributes","text":"Type Name fast_pose_type render_pose time_point render_time   = <code>{}</code> time_point sample_time   = <code>{}</code> std::array&lt; GLuint, 2 &gt; swap_indices   = <code>{}</code> std::array&lt; GLuint, 2 &gt; swapchain_indices   = <code>{}</code>"},{"location":"api/structILLIXR_1_1rendered__frame/#public-functions","title":"Public Functions","text":"Type Name rendered_frame () = default rendered_frame (std::array&lt; GLuint, 2 &gt; &amp;&amp; swapchain_indices_, std::array&lt; GLuint, 2 &gt; &amp;&amp; swap_indices_, fast_pose_type render_pose_, time_point sample_time_, time_point render_time_)"},{"location":"api/structILLIXR_1_1rendered__frame/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1rendered__frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame/#variable-render_pose","title":"variable render_pose","text":"<pre><code>fast_pose_type ILLIXR::rendered_frame::render_pose;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-render_time","title":"variable render_time","text":"<pre><code>time_point ILLIXR::rendered_frame::render_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-sample_time","title":"variable sample_time","text":"<pre><code>time_point ILLIXR::rendered_frame::sample_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-swap_indices","title":"variable swap_indices","text":"<pre><code>std::array&lt;GLuint, 2&gt; ILLIXR::rendered_frame::swap_indices;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#variable-swapchain_indices","title":"variable swapchain_indices","text":"<pre><code>std::array&lt;GLuint, 2&gt; ILLIXR::rendered_frame::swapchain_indices;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1rendered__frame/#function-rendered_frame-12","title":"function rendered_frame [1/2]","text":"<pre><code>ILLIXR::rendered_frame::rendered_frame () = default\n</code></pre>"},{"location":"api/structILLIXR_1_1rendered__frame/#function-rendered_frame-22","title":"function rendered_frame [2/2]","text":"<pre><code>inline ILLIXR::rendered_frame::rendered_frame (\n    std::array&lt; GLuint, 2 &gt; &amp;&amp; swapchain_indices_,\n    std::array&lt; GLuint, 2 &gt; &amp;&amp; swap_indices_,\n    fast_pose_type render_pose_,\n    time_point sample_time_,\n    time_point render_time_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/structILLIXR_1_1rendering__params/","title":"Struct ILLIXR::rendering_params","text":"<p>ClassList &gt; ILLIXR &gt; rendering_params</p> <p>Rendering parameters. </p> <ul> <li><code>#include &lt;global_module_defs.hpp&gt;</code></li> </ul>"},{"location":"api/structILLIXR_1_1rendering__params/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float far_z   = <code>20.0f</code> constexpr float near_z   = <code>0.1f</code>"},{"location":"api/structILLIXR_1_1rendering__params/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rendering__params/#variable-far_z","title":"variable far_z","text":"<pre><code>constexpr float ILLIXR::rendering_params::far_z;\n</code></pre>"},{"location":"api/structILLIXR_1_1rendering__params/#variable-near_z","title":"variable near_z","text":"<pre><code>constexpr float ILLIXR::rendering_params::near_z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/structILLIXR_1_1rgb__depth__type/","title":"Struct ILLIXR::rgb_depth_type","text":"<p>ClassList &gt; ILLIXR &gt; rgb_depth_type</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1rgb__depth__type/#public-attributes","title":"Public Attributes","text":"Type Name cv::Mat depth cv::Mat rgb time_point time"},{"location":"api/structILLIXR_1_1rgb__depth__type/#public-functions","title":"Public Functions","text":"Type Name rgb_depth_type (time_point _time, cv::Mat _rgb, cv::Mat _depth)"},{"location":"api/structILLIXR_1_1rgb__depth__type/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1rgb__depth__type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1rgb__depth__type/#variable-depth","title":"variable depth","text":"<pre><code>cv::Mat ILLIXR::rgb_depth_type::depth;\n</code></pre>"},{"location":"api/structILLIXR_1_1rgb__depth__type/#variable-rgb","title":"variable rgb","text":"<pre><code>cv::Mat ILLIXR::rgb_depth_type::rgb;\n</code></pre>"},{"location":"api/structILLIXR_1_1rgb__depth__type/#variable-time","title":"variable time","text":"<pre><code>time_point ILLIXR::rgb_depth_type::time;\n</code></pre>"},{"location":"api/structILLIXR_1_1rgb__depth__type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1rgb__depth__type/#function-rgb_depth_type","title":"function rgb_depth_type","text":"<pre><code>inline ILLIXR::rgb_depth_type::rgb_depth_type (\n    time_point _time,\n    cv::Mat _rgb,\n    cv::Mat _depth\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/opencv_data_types.hpp</code></p>"},{"location":"api/classILLIXR_1_1runtime/","title":"Class ILLIXR::runtime","text":"<p>ClassList &gt; ILLIXR &gt; runtime</p>"},{"location":"api/classILLIXR_1_1runtime/#public-functions","title":"Public Functions","text":"Type Name virtual void load_plugin_factory (plugin_factory plugin) = 0 virtual void load_so (const std::vector&lt; std::string &gt; &amp; so) = 0 virtual void load_so (const std::string_view &amp; so) = 0 virtual void stop () = 0 virtual void wait () = 0 virtual ~runtime () = default"},{"location":"api/classILLIXR_1_1runtime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1runtime/#function-load_plugin_factory","title":"function load_plugin_factory","text":"<pre><code>virtual void ILLIXR::runtime::load_plugin_factory (\n    plugin_factory plugin\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_so-12","title":"function load_so [1/2]","text":"<pre><code>virtual void ILLIXR::runtime::load_so (\n    const std::vector&lt; std::string &gt; &amp; so\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-load_so-22","title":"function load_so [2/2]","text":"<pre><code>virtual void ILLIXR::runtime::load_so (\n    const std::string_view &amp; so\n) = 0\n</code></pre>"},{"location":"api/classILLIXR_1_1runtime/#function-stop","title":"function stop","text":"<pre><code>virtual void ILLIXR::runtime::stop () = 0\n</code></pre> <p>Requests that the runtime is completely stopped. Clients must call this before deleting the runtime. </p>"},{"location":"api/classILLIXR_1_1runtime/#function-wait","title":"function wait","text":"<pre><code>virtual void ILLIXR::runtime::wait () = 0\n</code></pre> <p>Returns when the runtime is completely stopped. </p>"},{"location":"api/classILLIXR_1_1runtime/#function-runtime","title":"function ~runtime","text":"<pre><code>virtual ILLIXR::runtime::~runtime () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/runtime.hpp</code></p>"},{"location":"api/structILLIXR_1_1signal__to__quad/","title":"Struct ILLIXR::signal_to_quad","text":"<p>ClassList &gt; ILLIXR &gt; signal_to_quad</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1signal__to__quad/#public-attributes","title":"Public Attributes","text":"Type Name ullong seq"},{"location":"api/structILLIXR_1_1signal__to__quad/#public-functions","title":"Public Functions","text":"Type Name signal_to_quad (ullong seq_)"},{"location":"api/structILLIXR_1_1signal__to__quad/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1signal__to__quad/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1signal__to__quad/#variable-seq","title":"variable seq","text":"<pre><code>ullong ILLIXR::signal_to_quad::seq;\n</code></pre>"},{"location":"api/structILLIXR_1_1signal__to__quad/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1signal__to__quad/#function-signal_to_quad","title":"function signal_to_quad","text":"<pre><code>inline ILLIXR::signal_to_quad::signal_to_quad (\n    ullong seq_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard/","title":"Class ILLIXR::switchboard","text":"<p>ClassList &gt; ILLIXR &gt; switchboard</p> <p>A manager for typesafe, threadsafe, named event-streams (called topics). More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1switchboard/#classes","title":"Classes","text":"Type Name class buffered_reader &lt;typename specific_event&gt; class event Virtual class for event types. class event_wrapper &lt;typename underlying_type&gt;Helper class for making event types. class reader &lt;typename specific_event&gt;A handle which can read the latest event on a topic. class writer &lt;typename specific_event&gt;A handle which can publish events to a topic."},{"location":"api/classILLIXR_1_1switchboard/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; specific_event &gt; ptr The type of shared pointer returned by switchboard."},{"location":"api/classILLIXR_1_1switchboard/#public-functions","title":"Public Functions","text":"Type Name buffered_reader&lt; specific_event &gt; get_buffered_reader (const std::string &amp; topic_name)  reader&lt; specific_event &gt; get_reader (const std::string &amp; topic_name) Gets a handle to read to the latest value from the topic <code>topic_name</code> . writer&lt; specific_event &gt; get_writer (const std::string &amp; topic_name) Gets a handle to publish to the topic <code>topic_name</code> . void schedule (plugin_id_t plugin_id, std::string topic_name, std::function&lt; void(ptr&lt; const specific_event &gt; &amp;&amp;, std::size_t)&gt; fn) Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . void stop () Stops calling switchboard callbacks. switchboard (const phonebook * pb)"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1switchboard/#detailed-description","title":"Detailed Description","text":"<ul> <li>Writing: One can write to a topic (in any thread) through the object returned by <code>get_writer()</code>.</li> <li>There are two ways of reading: asynchronous reading and synchronous reading:</li> <li>Asynchronous reading returns the most-recent event on the topic (idempotently). One can do this through (in any thread) the object returned by <code>get_reader()</code>.</li> <li>Synchronous reading schedules a callback to be executed on every event which gets published. One can schedule computation by <code>schedule()</code>, which will run the computation in a thread managed by switchboard.</li> </ul> <pre><code>// Get a reader on topic1\nswitchboard::reader&lt;topic1_type&gt; topic1 = switchboard.get_reader&lt;topic1_type&gt;(\"topic1\");\n\n// Get a writer on topic2\nswitchboard::writer&lt;topic2_type&gt; topic2 = switchboard.get_writer&lt;topic2_type&gt;(\"topic2\");\n\nwhile (true) {\n    // Read topic 1\n    switchboard::ptr&lt;topic1_type&gt; event1 = topic1.get_rw();\n\n    // Write to topic 2 using topic 1 input\n    topic2.put(topic2.allocate&lt;topic2_type&gt;( do_something(event1-&gt;foo) ));\n}\n\n// Read topic 3 synchronously\nswitchboard.schedule&lt;topic3_type&gt;(plugin_id, \"topic3\", [&amp;](switchboard::ptr&lt;topic3_type&gt; event3, std::size_t it) {\n    // This is a lambda expression\n    // https://en.cppreference.com/w/cpp/language/lambda\n    std::cout &lt;&lt; \"Got a new event on topic3: \" &lt;&lt; event3-&gt;foo &lt;&lt; \" for iteration \" &lt;&lt; it &lt;&lt; std::endl;\n});\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#typedef-ptr","title":"typedef ptr","text":"<p>The type of shared pointer returned by switchboard. <pre><code>using ILLIXR::switchboard::ptr =  std::shared_ptr&lt;specific_event&gt;;\n</code></pre></p> <p>TODO: Make this agnostic to the type of <code>ptr</code> Currently, it depends on <code>ptr</code> == shared_ptr </p>"},{"location":"api/classILLIXR_1_1switchboard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard/#function-get_buffered_reader","title":"function get_buffered_reader","text":"<pre><code>template&lt;typename specific_event&gt;\ninline buffered_reader&lt; specific_event &gt; ILLIXR::switchboard::get_buffered_reader (\n    const std::string &amp; topic_name\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_reader","title":"function get_reader","text":"<p>Gets a handle to read to the latest value from the topic <code>topic_name</code> . <pre><code>template&lt;typename specific_event&gt;\ninline reader &lt; specific_event &gt; ILLIXR::switchboard::get_reader (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-get_writer","title":"function get_writer","text":"<p>Gets a handle to publish to the topic <code>topic_name</code> . <pre><code>template&lt;typename specific_event&gt;\ninline writer &lt; specific_event &gt; ILLIXR::switchboard::get_writer (\n    const std::string &amp; topic_name\n) \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>If</code> topic already exists, and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-schedule","title":"function schedule","text":"<p>Schedules the callback <code>fn</code> every time an event is published to<code>topic_name</code> . <pre><code>template&lt;typename specific_event&gt;\ninline void ILLIXR::switchboard::schedule (\n    plugin_id_t plugin_id,\n    std::string topic_name,\n    std::function&lt; void( ptr &lt; const specific_event &gt; &amp;&amp;, std::size_t)&gt; fn\n) \n</code></pre></p> <p>Switchboard maintains a threadpool to call <code>fn</code>.</p> <p>This is safe to be called from any thread.</p> <p>Exception:</p> <ul> <li><code>if</code> topic already exists and its type does not match the <code>event</code>. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard/#function-stop","title":"function stop","text":"<p>Stops calling switchboard callbacks. <pre><code>inline void ILLIXR::switchboard::stop () \n</code></pre></p> <p>This is safe to be called from any thread.</p> <p>Leave topics in place, so existing reader/writer handles will not crash. </p>"},{"location":"api/classILLIXR_1_1switchboard/#function-switchboard","title":"function switchboard","text":"<pre><code>inline ILLIXR::switchboard::switchboard (\n    const phonebook * pb\n) \n</code></pre> <p>If <code>pb</code> is null, then logging is disabled. </p> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/","title":"Class ILLIXR::switchboard::buffered_reader","text":"<p>template &lt;typename specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; buffered_reader</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#public-functions","title":"Public Functions","text":"Type Name buffered_reader (topic &amp; topic)  ptr&lt; const specific_event &gt; dequeue ()  size_t size () const"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#function-buffered_reader","title":"function buffered_reader","text":"<pre><code>inline ILLIXR::switchboard::buffered_reader::buffered_reader (\n    topic &amp; topic\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#function-dequeue","title":"function dequeue","text":"<pre><code>inline ptr &lt; const specific_event &gt; ILLIXR::switchboard::buffered_reader::dequeue () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1buffered__reader/#function-size","title":"function size","text":"<pre><code>inline size_t ILLIXR::switchboard::buffered_reader::size () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/","title":"Class ILLIXR::switchboard::event","text":"<p>ClassList &gt; ILLIXR &gt; switchboard &gt; event</p> <p>Virtual class for event types. More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: ILLIXR::cam_type,  ILLIXR::connection_signal,  ILLIXR::hologram_input,  ILLIXR::image_handle,  ILLIXR::imu_integrator_input,  ILLIXR::imu_raw_type,  ILLIXR::imu_type,  ILLIXR::pose_type,  ILLIXR::rendered_frame,  ILLIXR::rgb_depth_type,  ILLIXR::signal_to_quad,  ILLIXR::switchboard::event_wrapper,  ILLIXR::texture_pose</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#public-functions","title":"Public Functions","text":"Type Name virtual ~event () = default"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#detailed-description","title":"Detailed Description","text":"<p>Minimum requirement: Events must be destructible. Casting events from various sources to void* (aka type-punning) breaks [strict-aliasing][1] and is undefined behavior in modern C++. Therefore, we require a common supertype for all events. We will cast them to this common supertype, event* instead.</p> <p>[1] https://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1event/#function-event","title":"function ~event","text":"<pre><code>virtual ILLIXR::switchboard::event::~event () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/","title":"Class ILLIXR::switchboard::event_wrapper","text":"<p>template &lt;typename underlying_type&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; event_wrapper</p> <p>Helper class for making event types. More...</p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions","title":"Public Functions","text":"Type Name event_wrapper ()  event_wrapper (underlying_type underlying_data_)  operator underlying_type () const underlying_type &amp; operator* ()  const underlying_type &amp; operator* () const"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#detailed-description","title":"Detailed Description","text":"<p>Since topic has no static type-information on the contained events, this class does not either.</p> <pre><code>event_wrapper&lt;int&gt; int_event = 5;\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-event_wrapper-12","title":"function event_wrapper [1/2]","text":"<pre><code>inline ILLIXR::switchboard::event_wrapper::event_wrapper () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-event_wrapper-22","title":"function event_wrapper [2/2]","text":"<pre><code>inline ILLIXR::switchboard::event_wrapper::event_wrapper (\n    underlying_type underlying_data_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator-underlying_type","title":"function operator underlying_type","text":"<pre><code>inline ILLIXR::switchboard::event_wrapper::operator underlying_type () const\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator","title":"function operator*","text":"<pre><code>inline underlying_type &amp; ILLIXR::switchboard::event_wrapper::operator* () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1event__wrapper/#function-operator_1","title":"function operator*","text":"<pre><code>inline const underlying_type &amp; ILLIXR::switchboard::event_wrapper::operator* () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/","title":"Class ILLIXR::switchboard::reader","text":"<p>template &lt;typename specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; reader</p> <p>A handle which can read the latest event on a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; const specific_event &gt; get_ro () constGets a non-null \"read-only\" copy of the latest value. ptr&lt; const specific_event &gt; get_ro_nullable () noexcept constGets a \"read-only\" copy of the latest value. ptr&lt; specific_event &gt; get_rw () constGets a non-null mutable copy of the latest value. reader (topic &amp; topic_)"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_ro","title":"function get_ro","text":"<p>Gets a non-null \"read-only\" copy of the latest value. <pre><code>inline ptr &lt; const specific_event &gt; ILLIXR::switchboard::reader::get_ro () const\n</code></pre></p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If no event is on the topic yet. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_ro_nullable","title":"function get_ro_nullable","text":"<p>Gets a \"read-only\" copy of the latest value. <pre><code>inline ptr &lt; const specific_event &gt; ILLIXR::switchboard::reader::get_ro_nullable () noexcept const\n</code></pre></p> <p>This will return null if no event is on the topic yet. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-get_rw","title":"function get_rw","text":"<p>Gets a non-null mutable copy of the latest value. <pre><code>inline ptr &lt; specific_event &gt; ILLIXR::switchboard::reader::get_rw () const\n</code></pre></p> <p>Exception:</p> <ul> <li><code>runtime_error</code> If no event is on the topic yet. </li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1reader/#function-reader","title":"function reader","text":"<pre><code>inline ILLIXR::switchboard::reader::reader (\n    topic &amp; topic_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/","title":"Class ILLIXR::switchboard::writer","text":"<p>template &lt;typename specific_event&gt;</p> <p>ClassList &gt; ILLIXR &gt; switchboard &gt; writer</p> <p>A handle which can publish events to a topic. </p> <ul> <li><code>#include &lt;switchboard.hpp&gt;</code></li> </ul>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; specific_event &gt; allocate (Args &amp;&amp;... args) Like <code>new</code> /<code>malloc</code> but more efficient for this specific case. void put (ptr&lt; specific_event &gt; &amp;&amp; this_specific_event) Publish <code>ev</code> to this topic. writer (topic &amp; topic_)"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-allocate","title":"function allocate","text":"<p>Like <code>new</code> /<code>malloc</code> but more efficient for this specific case. <pre><code>template&lt;class... Args&gt;\ninline ptr &lt; specific_event &gt; ILLIXR::switchboard::writer::allocate (\n    Args &amp;&amp;... args\n) \n</code></pre></p> <p>There is an optimization available which has not yet been implemented: switchboard can reuse memory from old events, like a slab allocator. Suppose module A publishes data for module B. B's deallocation through the destructor, and A's allocation through this method completes the cycle in a double-buffer (AKA swap-chain). </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-put","title":"function put","text":"<p>Publish <code>ev</code> to this topic. <pre><code>inline void ILLIXR::switchboard::writer::put (\n    ptr &lt; specific_event &gt; &amp;&amp; this_specific_event\n) \n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1writer/#function-writer","title":"function writer","text":"<pre><code>inline ILLIXR::switchboard::writer::writer (\n    topic &amp; topic_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/structILLIXR_1_1texture__pose/","title":"Struct ILLIXR::texture_pose","text":"<p>ClassList &gt; ILLIXR &gt; texture_pose</p> <p>Inherits the following classes: ILLIXR::switchboard::event</p>"},{"location":"api/structILLIXR_1_1texture__pose/#public-attributes","title":"Public Attributes","text":"Type Name unsigned char * image   = <code>{}</code> Eigen::Quaternionf latest_quaternion duration offload_duration   = <code>{}</code> time_point pose_time   = <code>{}</code> Eigen::Vector3f position Eigen::Quaternionf render_quaternion"},{"location":"api/structILLIXR_1_1texture__pose/#public-functions","title":"Public Functions","text":"Type Name texture_pose () = default texture_pose (duration offload_duration_, unsigned char * image_, time_point pose_time_, Eigen::Vector3f position_, Eigen::Quaternionf latest_quaternion_, Eigen::Quaternionf render_quaternion_)"},{"location":"api/structILLIXR_1_1texture__pose/#public-functions-inherited-from-illixrswitchboardevent","title":"Public Functions inherited from ILLIXR::switchboard::event","text":"<p>See ILLIXR::switchboard::event</p> Type Name virtual ~event () = default"},{"location":"api/structILLIXR_1_1texture__pose/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1texture__pose/#variable-image","title":"variable image","text":"<pre><code>unsigned char* ILLIXR::texture_pose::image;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-latest_quaternion","title":"variable latest_quaternion","text":"<pre><code>Eigen::Quaternionf ILLIXR::texture_pose::latest_quaternion;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-offload_duration","title":"variable offload_duration","text":"<pre><code>duration ILLIXR::texture_pose::offload_duration;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-pose_time","title":"variable pose_time","text":"<pre><code>time_point ILLIXR::texture_pose::pose_time;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-position","title":"variable position","text":"<pre><code>Eigen::Vector3f ILLIXR::texture_pose::position;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#variable-render_quaternion","title":"variable render_quaternion","text":"<pre><code>Eigen::Quaternionf ILLIXR::texture_pose::render_quaternion;\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1texture__pose/#function-texture_pose-12","title":"function texture_pose [1/2]","text":"<pre><code>ILLIXR::texture_pose::texture_pose () = default\n</code></pre>"},{"location":"api/structILLIXR_1_1texture__pose/#function-texture_pose-22","title":"function texture_pose [2/2]","text":"<pre><code>inline ILLIXR::texture_pose::texture_pose (\n    duration offload_duration_,\n    unsigned char * image_,\n    time_point pose_time_,\n    Eigen::Vector3f position_,\n    Eigen::Quaternionf latest_quaternion_,\n    Eigen::Quaternionf render_quaternion_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1threadloop/","title":"Class ILLIXR::threadloop","text":"<p>ClassList &gt; ILLIXR &gt; threadloop</p> <p>A reusable threadloop for plugins. More...</p> <ul> <li><code>#include &lt;threadloop.hpp&gt;</code></li> </ul> <p>Inherits the following classes: ILLIXR::plugin</p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions","title":"Public Functions","text":"Type Name virtual void internal_stop () Stops the thread. virtual void start () overrideStarts the thread. virtual void stop () overrideJoins the thread. threadloop (const std::string &amp; name_, phonebook * pb_)  ~threadloop () override"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-inherited-from-illixrplugin","title":"Public Functions inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name std::string get_name () noexcept const plugin (std::string name_, phonebook * pb_)  void spdlogger (const char * log_level)  virtual void start () A method which Spindle calls when it starts the component. virtual void stop () A method which Spindle calls when it stops the component. virtual ~plugin () = default"},{"location":"api/classILLIXR_1_1threadloop/#protected-types","title":"Protected Types","text":"Type Name enum skip_option"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes","title":"Protected Attributes","text":"Type Name std::size_t iteration_no   = <code>0</code> std::size_t skip_no   = <code>0</code>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-inherited-from-illixrplugin","title":"Protected Attributes inherited from ILLIXR::plugin","text":"<p>See ILLIXR::plugin</p> Type Name const std::shared_ptr&lt; gen_guid &gt; gen_guid_ const std::size_t id std::string name const phonebook * pb const std::shared_ptr&lt; record_logger &gt; record_logger_"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions","title":"Protected Functions","text":"Type Name virtual void _p_one_iteration () = 0Override with the computation the thread does every loop. virtual skip_option _p_should_skip () Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ virtual void _p_thread_setup () Gets called at setup time, from the new thread. bool should_terminate () Whether the thread has been asked to terminate."},{"location":"api/classILLIXR_1_1threadloop/#detailed-description","title":"Detailed Description","text":"<p>The thread continuously runs <code>_p_one_iteration()</code> and is stopable by <code>stop()</code>.</p> <p>This factors out the common code I noticed in many different plugins. </p>"},{"location":"api/classILLIXR_1_1threadloop/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-internal_stop","title":"function internal_stop","text":"<p>Stops the thread. <pre><code>inline virtual void ILLIXR::threadloop::internal_stop () \n</code></pre></p> <p>A thread should call this if it wants to stop itself (due to out of data for example). </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-start","title":"function start","text":"<p>Starts the thread. <pre><code>inline virtual void ILLIXR::threadloop::start () override\n</code></pre></p> <p>This cannot go into the constructor because it starts a thread which calls <code>_p_one_iteration()</code> which is virtual in the child class.</p> <p>Calling a virtual child method from the parent constructor will not work as expected 1. Instead, the ISO CPP FAQ recommends calling a <code>start()</code> method immediately after construction 2. </p> <p>Implements ILLIXR::plugin::start</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-stop","title":"function stop","text":"<p>Joins the thread. <pre><code>inline virtual void ILLIXR::threadloop::stop () override\n</code></pre></p> <p>Must have already stopped the stoplight. </p> <p>Implements ILLIXR::plugin::stop</p>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop","title":"function threadloop","text":"<pre><code>inline ILLIXR::threadloop::threadloop (\n    const std::string &amp; name_,\n    phonebook * pb_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#function-threadloop_1","title":"function ~threadloop","text":"<pre><code>inline ILLIXR::threadloop::~threadloop () override\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#enum-skip_option","title":"enum skip_option","text":"<pre><code>enum ILLIXR::threadloop::skip_option {\n    run,\n    skip_and_spin,\n    skip_and_yield,\n    stop\n};\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#variable-iteration_no","title":"variable iteration_no","text":"<pre><code>std::size_t ILLIXR::threadloop::iteration_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#variable-skip_no","title":"variable skip_no","text":"<pre><code>std::size_t ILLIXR::threadloop::skip_no;\n</code></pre>"},{"location":"api/classILLIXR_1_1threadloop/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/classILLIXR_1_1threadloop/#function-_p_one_iteration","title":"function _p_one_iteration","text":"<p>Override with the computation the thread does every loop. <pre><code>virtual void ILLIXR::threadloop::_p_one_iteration () = 0\n</code></pre></p> <p>This gets called in rapid succession. </p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_should_skip","title":"function _p_should_skip","text":"<p>Gets called in a tight loop, to gate the invocation of <code>_p_one_iteration()</code> __ <pre><code>inline virtual skip_option ILLIXR::threadloop::_p_should_skip () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-_p_thread_setup","title":"function _p_thread_setup","text":"<p>Gets called at setup time, from the new thread. <pre><code>inline virtual void ILLIXR::threadloop::_p_thread_setup () \n</code></pre></p>"},{"location":"api/classILLIXR_1_1threadloop/#function-should_terminate","title":"function should_terminate","text":"<p>Whether the thread has been asked to terminate. <pre><code>inline bool ILLIXR::threadloop::should_terminate () \n</code></pre></p> <p>Check this before doing long-running computation; it makes termination more responsive. </p> <p>The documentation for this class was generated from the following file <code>include/illixr/threadloop.hpp</code></p>"},{"location":"api/classILLIXR_1_1time__point/","title":"Class ILLIXR::time_point","text":"<p>ClassList &gt; ILLIXR &gt; time_point</p>"},{"location":"api/classILLIXR_1_1time__point/#public-types","title":"Public Types","text":"Type Name typedef _clock_duration duration"},{"location":"api/classILLIXR_1_1time__point/#public-functions","title":"Public Functions","text":"Type Name time_point &amp; operator+= (const duration &amp; d)  time_point &amp; operator-= (const duration &amp; d)  time_point () = default constexpr time_point (const duration &amp; time_since_epoch)  duration time_since_epoch () const"},{"location":"api/classILLIXR_1_1time__point/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classILLIXR_1_1time__point/#typedef-duration","title":"typedef duration","text":"<pre><code>using ILLIXR::time_point::duration =  _clock_duration;\n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1time__point/#function-operator","title":"function operator+=","text":"<pre><code>inline time_point &amp; ILLIXR::time_point::operator+= (\n    const duration &amp; d\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-operator-","title":"function operator-=","text":"<pre><code>inline time_point &amp; ILLIXR::time_point::operator-= (\n    const duration &amp; d\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-time_point-12","title":"function time_point [1/2]","text":"<pre><code>ILLIXR::time_point::time_point () = default\n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-time_point-22","title":"function time_point [2/2]","text":"<pre><code>inline explicit constexpr ILLIXR::time_point::time_point (\n    const duration &amp; time_since_epoch\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1time__point/#function-time_since_epoch","title":"function time_since_epoch","text":"<pre><code>inline duration ILLIXR::time_point::time_since_epoch () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/relative_clock.hpp</code></p>"},{"location":"api/structILLIXR_1_1vk__image__handle/","title":"Struct ILLIXR::vk_image_handle","text":"<p>ClassList &gt; ILLIXR &gt; vk_image_handle</p>"},{"location":"api/structILLIXR_1_1vk__image__handle/#public-attributes","title":"Public Attributes","text":"Type Name size_t allocation_size int file_descriptor int64_t format uint32_t height uint32_t width"},{"location":"api/structILLIXR_1_1vk__image__handle/#public-functions","title":"Public Functions","text":"Type Name vk_image_handle (int fd_, int64_t format_, size_t alloc_size, uint32_t width_, uint32_t height_)"},{"location":"api/structILLIXR_1_1vk__image__handle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structILLIXR_1_1vk__image__handle/#variable-allocation_size","title":"variable allocation_size","text":"<pre><code>size_t ILLIXR::vk_image_handle::allocation_size;\n</code></pre>"},{"location":"api/structILLIXR_1_1vk__image__handle/#variable-file_descriptor","title":"variable file_descriptor","text":"<pre><code>int ILLIXR::vk_image_handle::file_descriptor;\n</code></pre>"},{"location":"api/structILLIXR_1_1vk__image__handle/#variable-format","title":"variable format","text":"<pre><code>int64_t ILLIXR::vk_image_handle::format;\n</code></pre>"},{"location":"api/structILLIXR_1_1vk__image__handle/#variable-height","title":"variable height","text":"<pre><code>uint32_t ILLIXR::vk_image_handle::height;\n</code></pre>"},{"location":"api/structILLIXR_1_1vk__image__handle/#variable-width","title":"variable width","text":"<pre><code>uint32_t ILLIXR::vk_image_handle::width;\n</code></pre>"},{"location":"api/structILLIXR_1_1vk__image__handle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structILLIXR_1_1vk__image__handle/#function-vk_image_handle","title":"function vk_image_handle","text":"<pre><code>inline ILLIXR::vk_image_handle::vk_image_handle (\n    int fd_,\n    int64_t format_,\n    size_t alloc_size,\n    uint32_t width_,\n    uint32_t height_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/","title":"Class ILLIXR::xlib_gl_extended_window","text":"<p>ClassList &gt; ILLIXR &gt; xlib_gl_extended_window</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes","title":"Public Attributes","text":"Type Name Display * dpy GLXContext glc int height int width Window win"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions","title":"Public Functions","text":"Type Name xlib_gl_extended_window (int _width, int _height, GLXContext _shared_gl_context)  ~xlib_gl_extended_window () override"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-dpy","title":"variable dpy","text":"<pre><code>Display* ILLIXR::xlib_gl_extended_window::dpy;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-glc","title":"variable glc","text":"<pre><code>GLXContext ILLIXR::xlib_gl_extended_window::glc;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-height","title":"variable height","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::height;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-width","title":"variable width","text":"<pre><code>int ILLIXR::xlib_gl_extended_window::width;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#variable-win","title":"variable win","text":"<pre><code>Window ILLIXR::xlib_gl_extended_window::win;\n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window","title":"function xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::xlib_gl_extended_window (\n    int _width,\n    int _height,\n    GLXContext _shared_gl_context\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1xlib__gl__extended__window/#function-xlib_gl_extended_window_1","title":"function ~xlib_gl_extended_window","text":"<pre><code>inline ILLIXR::xlib_gl_extended_window::~xlib_gl_extended_window () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/extended_window.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/","title":"Class ILLIXR::switchboard::topic","text":"<p>ClassList &gt; topic</p> <p>Represents a topic. More...</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; const event &gt; get () constGets a read-only copy of the most recent event on the topic. topic_buffer &amp; get_buffer ()  const std::string &amp; name ()  void put (ptr&lt; const event &gt; &amp;&amp; this_event) Publishes <code>this_event</code> to the topic. void schedule (plugin_id_t plugin_id, std::function&lt; void(ptr&lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback) Schedules <code>callback</code> on the topic (<code>plugin_id</code> is for accounting) void stop () Stop and remove all topic_subscription threads. topic (std::string name, const std::type_info &amp; ty, std::shared_ptr&lt; record_logger &gt; record_logger_)  const std::type_info &amp; ty ()"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#detailed-description","title":"Detailed Description","text":"<p>Note, this class cannot have any static type-information about the contained events because I need to hold all of the topics in a homogeneous container (can't add topic&lt;int&gt; and topic&lt;float&gt; to the same std::vector&lt;topic&lt;WHAT_GOES_HERE&gt;&gt;).</p> <p>Therefore, this class uses type-erasure, and regards all events as type <code>event</code>. I could have used <code>std::any</code> for this, but I think inheriting <code>event</code> will be slightly more efficient because it avoids a heap-allocation.</p> <p>However, this class can have dynamic type-information in _m_ty, that gets set and checked at runtime. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-get","title":"function get","text":"<p>Gets a read-only copy of the most recent event on the topic. <pre><code>inline ptr &lt; const event &gt; topic::get () const\n</code></pre></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-get_buffer","title":"function get_buffer","text":"<pre><code>inline topic_buffer &amp; topic::get_buffer () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-name","title":"function name","text":"<pre><code>inline const std::string &amp; topic::name () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-put","title":"function put","text":"<p>Publishes <code>this_event</code> to the topic. <pre><code>inline void topic::put (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre></p> <p>Thread-safe * Caveat:This (circular) queue based solution may race if &gt;= N write attempts to the N-sized queue interrupt a concurrent reader (using 'get').The reader's critical section is as follows:   * Read the latest serial number   * Compute the serial's modulus   * Dereference and access the position in the queue/array</p> <p>The critical section is extremely small, so a race is unlikely, albeit possible. The probability of a data race decreases geometrically with N. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-schedule","title":"function schedule","text":"<p>Schedules <code>callback</code> on the topic (<code>plugin_id</code> is for accounting) <pre><code>inline void topic::schedule (\n    plugin_id_t plugin_id,\n    std::function&lt; void( ptr &lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback\n) \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-stop","title":"function stop","text":"<p>Stop and remove all topic_subscription threads. <pre><code>inline void topic::stop () \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-topic","title":"function topic","text":"<pre><code>inline topic::topic (\n    std::string name,\n    const std::type_info &amp; ty,\n    std::shared_ptr&lt; record_logger &gt; record_logger_\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic/#function-ty","title":"function ty","text":"<pre><code>inline const std::type_info &amp; topic::ty () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/","title":"Class ILLIXR::switchboard::topic_buffer","text":"<p>ClassList &gt; topic_buffer</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#public-functions","title":"Public Functions","text":"Type Name ptr&lt; const event &gt; dequeue ()  void enqueue (ptr&lt; const event &gt; &amp;&amp; this_event)  size_t size () const topic_buffer ()"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-dequeue","title":"function dequeue","text":"<pre><code>inline ptr &lt; const event &gt; topic_buffer::dequeue () \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-enqueue","title":"function enqueue","text":"<pre><code>inline void topic_buffer::enqueue (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-size","title":"function size","text":"<pre><code>inline size_t topic_buffer::size () const\n</code></pre>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__buffer/#function-topic_buffer","title":"function topic_buffer","text":"<pre><code>inline topic_buffer::topic_buffer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/","title":"Class ILLIXR::switchboard::topic_subscription","text":"<p>ClassList &gt; topic_subscription</p> <p>Represents a single topic_subscription (callback and queue) More...</p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#public-functions","title":"Public Functions","text":"Type Name void enqueue (ptr&lt; const event &gt; &amp;&amp; this_event) Tells the subscriber about <code>this_event</code> . topic_subscription (const std::string &amp; topic_name, plugin_id_t plugin_id, std::function&lt; void(ptr&lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback, std::shared_ptr&lt; record_logger &gt; record_logger_)"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#detailed-description","title":"Detailed Description","text":"<p>This class treats everything as <code>event</code>s (type-erased) because <code>topic</code> treats everything as <code>event</code>s.</p> <p>Each topic can have 0 or more topic_subscriptions. </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#function-enqueue","title":"function enqueue","text":"<p>Tells the subscriber about <code>this_event</code> . <pre><code>inline void topic_subscription::enqueue (\n    ptr &lt; const event &gt; &amp;&amp; this_event\n) \n</code></pre></p> <p>Thread-safe </p>"},{"location":"api/classILLIXR_1_1switchboard_1_1topic__subscription/#function-topic_subscription","title":"function topic_subscription","text":"<pre><code>inline topic_subscription::topic_subscription (\n    const std::string &amp; topic_name,\n    plugin_id_t plugin_id,\n    std::function&lt; void( ptr &lt; const event &gt; &amp;&amp;, std::size_t)&gt; callback,\n    std::shared_ptr&lt; record_logger &gt; record_logger_\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/classpose__prediction/","title":"Class pose_prediction","text":"<p>ClassList &gt; pose_prediction</p> <p>Inherits the following classes: ILLIXR::phonebook::service</p>"},{"location":"api/classpose__prediction/#public-functions","title":"Public Functions","text":"Type Name virtual pose_type correct_pose (const pose_type &amp; pose) const = 0 virtual bool fast_pose_reliable () const = 0 virtual fast_pose_type get_fast_pose () const = 0 virtual fast_pose_type get_fast_pose (time_point future_time) const = 0 virtual Eigen::Quaternionf get_offset () = 0 virtual pose_type get_true_pose () const = 0 virtual void set_offset (const Eigen::Quaternionf &amp; orientation) = 0 virtual bool true_pose_reliable () const = 0 ~pose_prediction () override"},{"location":"api/classpose__prediction/#public-functions-inherited-from-illixrphonebookservice","title":"Public Functions inherited from ILLIXR::phonebook::service","text":"<p>See ILLIXR::phonebook::service</p> Type Name virtual ~service () = default"},{"location":"api/classpose__prediction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classpose__prediction/#function-correct_pose","title":"function correct_pose","text":"<pre><code>virtual pose_type pose_prediction::correct_pose (\n    const pose_type &amp; pose\n) const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-fast_pose_reliable","title":"function fast_pose_reliable","text":"<pre><code>virtual bool pose_prediction::fast_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_fast_pose-12","title":"function get_fast_pose [1/2]","text":"<pre><code>virtual fast_pose_type pose_prediction::get_fast_pose () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_fast_pose-22","title":"function get_fast_pose [2/2]","text":"<pre><code>virtual fast_pose_type pose_prediction::get_fast_pose (\n    time_point future_time\n) const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_offset","title":"function get_offset","text":"<pre><code>virtual Eigen::Quaternionf pose_prediction::get_offset () = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-get_true_pose","title":"function get_true_pose","text":"<pre><code>virtual pose_type pose_prediction::get_true_pose () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-set_offset","title":"function set_offset","text":"<pre><code>virtual void pose_prediction::set_offset (\n    const Eigen::Quaternionf &amp; orientation\n) = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-true_pose_reliable","title":"function true_pose_reliable","text":"<pre><code>virtual bool pose_prediction::true_pose_reliable () const = 0\n</code></pre>"},{"location":"api/classpose__prediction/#function-pose_prediction","title":"function ~pose_prediction","text":"<pre><code>pose_prediction::~pose_prediction () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/pose_prediction.hpp</code></p>"},{"location":"api/classprint__timer/","title":"Class print_timer","text":"<p>template &lt;typename now_fn, typename time_point, typename duration&gt;</p> <p>ClassList &gt; print_timer</p> <p>Like timer, but prints the output. More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classprint__timer/#public-functions","title":"Public Functions","text":"Type Name print_timer (const std::string &amp; name, const now_fn &amp; now)"},{"location":"api/classprint__timer/#detailed-description","title":"Detailed Description","text":"<p>See PRINT_CPU_TIME_FOR_THIS_BLOCK(name) </p>"},{"location":"api/classprint__timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer/#function-print_timer","title":"function print_timer","text":"<pre><code>inline print_timer::print_timer (\n    const std::string &amp; name,\n    const now_fn &amp; now\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer2/","title":"Class print_timer2","text":"<p>ClassList &gt; print_timer2</p>"},{"location":"api/classprint__timer2/#public-functions","title":"Public Functions","text":"Type Name print_timer2 (std::string name_)  ~print_timer2 ()"},{"location":"api/classprint__timer2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer2/#function-print_timer2","title":"function print_timer2","text":"<pre><code>inline explicit print_timer2::print_timer2 (\n    std::string name_\n) \n</code></pre>"},{"location":"api/classprint__timer2/#function-print_timer2_1","title":"function ~print_timer2","text":"<pre><code>inline print_timer2::~print_timer2 () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classprint__timer_1_1print__in__destructor/","title":"Class print_timer::print_in_destructor","text":"<p>ClassList &gt; print_in_destructor</p>"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions","title":"Public Functions","text":"Type Name print_in_destructor (std::string account_name, const duration &amp; _duration)  ~print_in_destructor ()"},{"location":"api/classprint__timer_1_1print__in__destructor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor","title":"function print_in_destructor","text":"<pre><code>inline print_in_destructor::print_in_destructor (\n    std::string account_name,\n    const duration &amp; _duration\n) \n</code></pre>"},{"location":"api/classprint__timer_1_1print__in__destructor/#function-print_in_destructor_1","title":"function ~print_in_destructor","text":"<pre><code>inline print_in_destructor::~print_in_destructor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classshould__profile__class/","title":"Class should_profile_class","text":"<p>ClassList &gt; should_profile_class</p>"},{"location":"api/classshould__profile__class/#public-functions","title":"Public Functions","text":"Type Name bool operator() () const should_profile_class ()"},{"location":"api/classshould__profile__class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classshould__profile__class/#function-operator","title":"function operator()","text":"<pre><code>inline bool should_profile_class::operator() () const\n</code></pre>"},{"location":"api/classshould__profile__class/#function-should_profile_class","title":"function should_profile_class","text":"<pre><code>inline should_profile_class::should_profile_class () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/classtimer/","title":"Class timer","text":"<p>template &lt;typename now_fn, typename time_point, typename durationt&gt;</p> <p>ClassList &gt; timer</p> <p>a timer that times until the end of the code block ([RAII]). More...</p> <ul> <li><code>#include &lt;cpu_timer.hpp&gt;</code></li> </ul>"},{"location":"api/classtimer/#public-functions","title":"Public Functions","text":"Type Name timer (const now_fn &amp; now, durationt &amp; _duration)  ~timer ()"},{"location":"api/classtimer/#detailed-description","title":"Detailed Description","text":"<p>See [2] for how code-blocks are defined in C++.</p> <p><code>now</code> can be any type that takes no arguments and returns a subtractable type.</p> <p>Example usage:</p> <pre><code>{\n    // stuff that won't get timed.\n    std::chrono::nanoseconds ns;\n    timer&lt;decltype((thread_cpu_time))&gt; timer_obj {thread_cpu_time, ns};\n    // stuff that gets timed.\n}\n// stuff that won't get timed.\nstd::cout &lt;&lt; ns.count() &lt;&lt; std::endl;\n</code></pre>"},{"location":"api/classtimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classtimer/#function-timer","title":"function timer","text":"<pre><code>inline timer::timer (\n    const now_fn &amp; now,\n    durationt &amp; _duration\n) \n</code></pre>"},{"location":"api/classtimer/#function-timer_1","title":"function ~timer","text":"<pre><code>inline timer::~timer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir include","text":"<p>FileList &gt; include</p>"},{"location":"api/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Type Name dir illixr <p>The documentation for this class was generated from the following file <code>include/</code></p>"},{"location":"api/dir_896702a6becdb992133bce403d5f6094/","title":"Dir include/illixr","text":"<p>FileList &gt; illixr</p>"},{"location":"api/dir_896702a6becdb992133bce403d5f6094/#files","title":"Files","text":"Type Name file cpu_timer.hpp file csv_iterator.hpp file data_format.hpp file dynamic_lib.hpp file error_util.hpp file extended_window.hpp file global_module_defs.hpp file managed_thread.hpp file math_util.hpp file opencv_data_types.hpp file phonebook.hpp file plugin.hpp file pose_prediction.hpp file record_logger.hpp file relative_clock.hpp file runtime.hpp file shader_util.hpp file stoplight.hpp file switchboard.hpp file threadloop.hpp <p>The documentation for this class was generated from the following file <code>include/illixr/</code></p>"},{"location":"api/cpu__timer_8hpp/","title":"File cpu_timer.hpp","text":"<p>FileList &gt; illixr &gt; cpu_timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/cpu__timer_8hpp/#classes","title":"Classes","text":"Type Name class print_timer &lt;typename now_fn, typename time_point, typename duration&gt;Like timer, but prints the output. class print_timer2 class should_profile_class class timer &lt;typename now_fn, typename time_point, typename durationt&gt;a timer that times until the end of the code block ([RAII])."},{"location":"api/cpu__timer_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name should_profile_class should_profile"},{"location":"api/cpu__timer_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (Duration t)  std::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (Duration t)  std::thread timed_thread (const std::string &amp; account_name, Function &amp;&amp; f, Args &amp;&amp;... args) Use this in place of std::thread(...) to print times."},{"location":"api/cpu__timer_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::nanoseconds cpp_clock_gettime (clockid_t clock_id) A C++ translation of clock_gettime __ std::size_t gen_serial_no ()  std::chrono::nanoseconds thread_cpu_time () Gets the CPU time for the calling thread."},{"location":"api/cpu__timer_8hpp/#macros","title":"Macros","text":"Type Name define PRINT_CPU_TIME_FOR_THIS_BLOCK (name) <code>[**print\\_timer**](classprint__timer.md)&amp;lt;decltype((thread\\_cpu\\_time))&amp;gt; PRINT\\_CPU\\_TIME\\_FOR\\_THIS\\_BLOCK{name, thread\\_cpu\\_time};</code> define PRINT_RECORD_FOR_THIS_BLOCK (name) <code>print\\_timer2 PRINT\\_RECORD\\_FOR\\_THIS\\_BLOCK\\_timer{name};</code> define PRINT_WALL_TIME_FOR_THIS_BLOCK (name) <code>/* multi line expression */</code>"},{"location":"api/cpu__timer_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/cpu__timer_8hpp/#variable-should_profile","title":"variable should_profile","text":"<pre><code>should_profile_class should_profile;\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-count_duration","title":"function count_duration","text":"<pre><code>template&lt;typename Duration, typename Out&gt;\nstd::enable_if&lt; std::is_integral&lt; Out &gt;::value, Out &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-count_duration_1","title":"function count_duration","text":"<pre><code>template&lt;typename Duration&gt;\nstd::enable_if&lt; std::is_integral&lt; Duration &gt;::value, Duration &gt;::type count_duration (\n    Duration t\n) \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-timed_thread","title":"function timed_thread","text":"<p>Use this in place of std::thread(...) to print times. <pre><code>template&lt;class Function, class... Args&gt;\nstd::thread timed_thread (\n    const std::string &amp; account_name,\n    Function &amp;&amp; f,\n    Args &amp;&amp;... args\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/cpu__timer_8hpp/#function-cpp_clock_gettime","title":"function cpp_clock_gettime","text":"<p>A C++ translation of clock_gettime __ <pre><code>static inline std::chrono::nanoseconds cpp_clock_gettime (\n    clockid_t clock_id\n) \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#function-gen_serial_no","title":"function gen_serial_no","text":"<pre><code>static std::size_t gen_serial_no () \n</code></pre>"},{"location":"api/cpu__timer_8hpp/#function-thread_cpu_time","title":"function thread_cpu_time","text":"<p>Gets the CPU time for the calling thread. <pre><code>static inline std::chrono::nanoseconds thread_cpu_time () \n</code></pre></p>"},{"location":"api/cpu__timer_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/cpu__timer_8hpp/#define-print_cpu_time_for_this_block","title":"define PRINT_CPU_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_CPU_TIME_FOR_THIS_BLOCK (\n    name\n) `print_timer &lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK{name, thread_cpu_time};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_record_for_this_block","title":"define PRINT_RECORD_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_RECORD_FOR_THIS_BLOCK (\n    name\n) `print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer{name};`\n</code></pre>"},{"location":"api/cpu__timer_8hpp/#define-print_wall_time_for_this_block","title":"define PRINT_WALL_TIME_FOR_THIS_BLOCK","text":"<pre><code>#define PRINT_WALL_TIME_FOR_THIS_BLOCK (\n    name\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/cpu_timer.hpp</code></p>"},{"location":"api/cpu__timer_8hpp_source/","title":"File cpu_timer.hpp","text":"<p>File List &gt; illixr &gt; cpu_timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n//\n\n#include \"error_util.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;cstring&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nstatic inline std::chrono::nanoseconds cpp_clock_gettime(clockid_t clock_id) {\n    /* This ensures the compiler won't reorder this function call; Pretend like it has memory side-effects. */\n    asm volatile(\"\"\n                 : /* OutputOperands */\n                 : /* InputOperands */\n                 : \"memory\" /* Clobbers */);\n\n    struct timespec ts { };\n\n    RAC_ERRNO_MSG(\"cpu_timer before clock_gettime\");\n\n    if (clock_gettime(clock_id, &amp;ts)) {\n        throw std::runtime_error{std::string{\"clock_gettime returned \"} + strerror(errno)};\n    }\n    RAC_ERRNO_MSG(\"cpu_timer after clock_gettime\");\n\n    asm volatile(\"\"\n                 : /* OutputOperands */\n                 : /* InputOperands */\n                 : \"memory\" /* Clobbers */);\n    return std::chrono::seconds{ts.tv_sec} + std::chrono::nanoseconds{ts.tv_nsec};\n}\n\nstatic inline std::chrono::nanoseconds thread_cpu_time() {\n    RAC_ERRNO_MSG(\"cpu_timer before cpp_clock_gettime\");\n    return cpp_clock_gettime(CLOCK_THREAD_CPUTIME_ID);\n}\n\ntemplate&lt;typename now_fn, typename time_point = decltype(std::declval&lt;now_fn&gt;()()),\n         typename durationt = decltype(std::declval&lt;time_point&gt;() - std::declval&lt;time_point&gt;())&gt;\nclass timer {\npublic:\n    timer(const now_fn&amp; now, durationt&amp; _duration)\n        : _p_now{now}\n        , _p_duration{_duration} {\n        _p_start = _p_now();\n    }\n\n    ~timer() {\n        _p_duration = _p_now() - _p_start;\n    }\n\nprivate:\n    const now_fn&amp; _p_now;\n    durationt&amp;    _p_duration;\n    time_point    _p_start;\n};\n\ntemplate&lt;typename Duration, typename Out = decltype(std::declval&lt;Duration&gt;().count())&gt;\ntypename std::enable_if&lt;std::is_integral&lt;Out&gt;::value, Out&gt;::type count_duration(Duration t) {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds, typename Duration::rep, typename Duration::period&gt;(t).count();\n}\n\ntemplate&lt;typename Duration&gt;\ntypename std::enable_if&lt;std::is_integral&lt;Duration&gt;::value, Duration&gt;::type count_duration(Duration t) {\n    return t;\n}\n\ntemplate&lt;typename now_fn, typename time_point = decltype(std::declval&lt;now_fn&gt;()()),\n         typename duration = decltype(std::declval&lt;time_point&gt;() - std::declval&lt;time_point&gt;())&gt;\nclass print_timer {\nprivate:\n    class print_in_destructor {\n    public:\n        print_in_destructor(std::string account_name, const duration&amp; _duration)\n            : _p_account_name{std::move(account_name)}\n            , _p_duration{_duration} { }\n\n        ~print_in_destructor() {\n            // std::ostringstream os;\n            // os &lt;&lt; \"cpu_timer,\" &lt;&lt; _p_account_name &lt;&lt; \",\" &lt;&lt; count_duration&lt;duration&gt;(_p_duration) &lt;&lt; \"\\n\";\n            if (rand() % 100 == 0) {\n#ifndef NDEBUG\n                spdlog::get(\"illixr\")-&gt;info(\"cpu_timer.hpp is DEPRECATED. See logging.hpp.\");\n#endif\n            }\n        }\n\n    private:\n        const std::string _p_account_name;\n        const duration&amp;   _p_duration;\n    };\n\n    // NOTE that the destructors get called in reverse order!\n    // This is important, because _p_timer's destructor records the timing information\n    // Then, _p_print_in_destructor prints it\n    // Then, we can destroy _p_duration.\n    duration                                  _p_duration;\n    const print_in_destructor                 _p_print_in_destructor;\n    const timer&lt;now_fn, time_point, duration&gt; _p_timer;\n\npublic:\n    print_timer(const std::string&amp; name, const now_fn&amp; now)\n        : _p_print_in_destructor{name, _p_duration}\n        , _p_timer{now, _p_duration} { }\n};\n\nstatic std::size_t gen_serial_no() {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch())\n        .count();\n}\n\nclass should_profile_class {\npublic:\n    should_profile_class() {\n        const char* ILLIXR_STDOUT_METRICS = getenv(\"ILLIXR_STDOUT_METRICS\");\n        actually_should_profile           = ILLIXR_STDOUT_METRICS &amp;&amp; (strcmp(ILLIXR_STDOUT_METRICS, \"y\") == 0);\n    }\n\n    bool operator()() const {\n        return actually_should_profile;\n    }\n\nprivate:\n    bool actually_should_profile;\n};\n\nstatic should_profile_class should_profile;\n\nclass print_timer2 {\nprivate:\n    const std::string name;\n    const std::size_t serial_no;\n    std::size_t       wall_time_start;\n    std::size_t       cpu_time_start;\n\npublic:\n    explicit print_timer2(std::string name_)\n        : name{std::move(name_)}\n        , serial_no{should_profile() ? gen_serial_no() : std::size_t{0}}\n        , wall_time_start{should_profile() ? std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n                                                 std::chrono::high_resolution_clock::now().time_since_epoch())\n                                                 .count()\n                                           : std::size_t{0}}\n        , cpu_time_start{should_profile() ? thread_cpu_time().count() : std::size_t{0}} { }\n\n    ~print_timer2() {\n        if (should_profile()) {\n            auto cpu_time_stop  = thread_cpu_time().count();\n            auto wall_time_stop = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n                                      std::chrono::high_resolution_clock::now().time_since_epoch())\n                                      .count();\n\n            spdlog::get(\"illixr\")-&gt;info(\"[cpu_timer]  cpu_timer,{},{},{},{},{},{}\", name, serial_no, wall_time_start,\n                                        wall_time_stop, cpu_time_start, cpu_time_stop);\n        }\n    }\n};\n\n#define PRINT_CPU_TIME_FOR_THIS_BLOCK(name) \\\n    print_timer&lt;decltype((thread_cpu_time))&gt; PRINT_CPU_TIME_FOR_THIS_BLOCK{name, thread_cpu_time};\n\n#define PRINT_WALL_TIME_FOR_THIS_BLOCK(name)                                                         \\\n    print_timer&lt;decltype((std::chrono::high_resolution_clock::now))&gt; PRINT_WALL_TIME_FOR_THIS_BLOCK{ \\\n        name, std::chrono::high_resolution_clock::now};\n\n#define PRINT_RECORD_FOR_THIS_BLOCK(name) print_timer2 PRINT_RECORD_FOR_THIS_BLOCK_timer{name};\n\ntemplate&lt;class Function, class... Args&gt;\nstd::thread timed_thread(const std::string&amp; account_name, Function&amp;&amp; f, Args&amp;&amp;... args) {\n    // Unfortunately we make copies of f and args.\n    // According to StackOverflow, this is unavoidable.\n    // See Sam Varshavchik's comment on https://stackoverflow.com/a/62380971/1078199\n    return std::thread([=] {\n        {\n            PRINT_RECORD_FOR_THIS_BLOCK(account_name)\n            std::invoke(f, args...);\n        }\n    });\n}\n</code></pre>"},{"location":"api/csv__iterator_8hpp/","title":"File csv_iterator.hpp","text":"<p>FileList &gt; illixr &gt; csv_iterator.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/csv__iterator_8hpp/#classes","title":"Classes","text":"Type Name class CSVIterator class CSVRow"},{"location":"api/csv__iterator_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::istream &amp; operator&gt;&gt; (std::istream &amp; str, CSVRow &amp; data)"},{"location":"api/csv__iterator_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/csv__iterator_8hpp/#function-operator","title":"function operator&gt;&gt;","text":"<pre><code>std::istream &amp; operator&gt;&gt; (\n    std::istream &amp; str,\n    CSVRow &amp; data\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/csv_iterator.hpp</code></p>"},{"location":"api/csv__iterator_8hpp_source/","title":"File csv_iterator.hpp","text":"<p>File List &gt; illixr &gt; csv_iterator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iterator&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nclass CSVRow {\npublic:\n    std::string const&amp; operator[](std::size_t index) const {\n        return m_data[index];\n    }\n\n    [[nodiscard]] std::size_t size() const {\n        return m_data.size();\n    }\n\n    void readNextRow(std::istream&amp; str) {\n        std::string line;\n        std::getline(str, line);\n\n        line = line.substr(0, line.find_last_not_of(\"\\r\\n\\t \\v\") + 1);\n\n        std::stringstream lineStream(line);\n        std::string       cell;\n\n        m_data.clear();\n        while (std::getline(lineStream, cell, ',')) {\n            m_data.push_back(cell);\n        }\n        // This checks for a trailing comma with no data after it.\n        if (!lineStream &amp;&amp; cell.empty()) {\n            // If there was a trailing comma then add an empty element.\n            m_data.emplace_back(\"\");\n        }\n    }\n\nprivate:\n    std::vector&lt;std::string&gt; m_data;\n};\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; str, CSVRow&amp; data) {\n    data.readNextRow(str);\n    return str;\n}\n\nclass CSVIterator {\npublic:\n    typedef std::input_iterator_tag iterator_category;\n    typedef CSVRow                  value_type;\n    typedef std::size_t             difference_type;\n    typedef CSVRow*                 pointer;\n    typedef CSVRow&amp;                 reference;\n\n    explicit CSVIterator(std::istream&amp; str, std::size_t skip = 0)\n        : m_str(str.good() ? &amp;str : nullptr) {\n        ++(*this);\n        (*this) += skip;\n    }\n\n    CSVIterator()\n        : m_str(nullptr) { }\n\n    CSVIterator&amp; operator+=(std::size_t skip) {\n        for (size_t i = 0; i &lt; skip; ++i) {\n            ++(*this);\n        }\n        return *this;\n    }\n\n    // Pre Increment\n    CSVIterator&amp; operator++() {\n        if (m_str) {\n            if (!((*m_str) &gt;&gt; m_row)) {\n                m_str = nullptr;\n            }\n        }\n        return *this;\n    }\n\n    // Post increment\n    CSVIterator operator++(int) {\n        CSVIterator tmp(*this);\n        ++(*this);\n        return tmp;\n    }\n\n    CSVRow const&amp; operator*() const {\n        return m_row;\n    }\n\n    CSVRow const* operator-&gt;() const {\n        return &amp;m_row;\n    }\n\n    bool operator==(CSVIterator const&amp; rhs) {\n        return ((this == &amp;rhs) || ((this-&gt;m_str == nullptr) &amp;&amp; (rhs.m_str == nullptr)));\n    }\n\n    bool operator!=(CSVIterator const&amp; rhs) {\n        return !((*this) == rhs);\n    }\n\n    const std::string&amp; operator[](std::size_t idx) {\n        return m_row[idx];\n    }\n\nprivate:\n    std::istream* m_str;\n    CSVRow        m_row;\n};\n</code></pre>"},{"location":"api/data__format_8hpp/","title":"File data_format.hpp","text":"<p>FileList &gt; illixr &gt; data_format.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;eigen3/Eigen/Dense&gt;</code></li> <li><code>#include &lt;GL/gl.h&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"relative_clock.hpp\"</code></li> <li><code>#include \"switchboard.hpp\"</code></li> </ul>"},{"location":"api/data__format_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/data__format_8hpp/#classes","title":"Classes","text":"Type Name struct connection_signal struct fast_pose_type struct hmd_physical_info struct hologram_input struct image_handle struct imu_integrator_input struct imu_params struct imu_raw_type struct imu_type struct pose_type struct rendered_frame struct signal_to_quad struct texture_pose struct vk_image_handle"},{"location":"api/data__format_8hpp/#macros","title":"Macros","text":"Type Name define USE_ALT_EYE_FORMAT"},{"location":"api/data__format_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/data__format_8hpp/#define-use_alt_eye_format","title":"define USE_ALT_EYE_FORMAT","text":"<pre><code>#define USE_ALT_EYE_FORMAT \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/data_format.hpp</code></p>"},{"location":"api/data__format_8hpp_source/","title":"File data_format.hpp","text":"<p>File List &gt; illixr &gt; data_format.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#undef Success // For 'Success' conflict\n#include &lt;eigen3/Eigen/Dense&gt;\n#include &lt;GL/gl.h&gt;\n#include &lt;utility&gt;\n//#undef Complex // For 'Complex' conflict\n\n#include \"relative_clock.hpp\"\n#include \"switchboard.hpp\"\n\n// Tell gldemo and timewarp_gl to use two texture handle for left and right eye\n#define USE_ALT_EYE_FORMAT\n\nnamespace ILLIXR {\nusing ullong = unsigned long long;\n\nstruct imu_type : switchboard::event {\n    time_point      time;\n    Eigen::Vector3d angular_v;\n    Eigen::Vector3d linear_a;\n\n    imu_type(time_point time_, Eigen::Vector3d angular_v_, Eigen::Vector3d linear_a_)\n        : time{time_}\n        , angular_v{std::move(angular_v_)}\n        , linear_a{std::move(linear_a_)} { }\n};\n\nstruct connection_signal : public switchboard::event {\n    bool start;\n\n    connection_signal(bool start_)\n        : start{start_} { }\n};\n\n// Values needed to initialize the IMU integrator\ntypedef struct {\n    double                      gyro_noise;\n    double                      acc_noise;\n    double                      gyro_walk;\n    double                      acc_walk;\n    Eigen::Matrix&lt;double, 3, 1&gt; n_gravity;\n    double                      imu_integration_sigma;\n    double                      nominal_rate;\n} imu_params;\n\n// IMU biases, initialization params, and slow pose needed by the IMU integrator\nstruct imu_integrator_input : public switchboard::event {\n    time_point last_cam_integration_time;\n    duration   t_offset;\n    imu_params params;\n\n    Eigen::Vector3d             biasAcc;\n    Eigen::Vector3d             biasGyro;\n    Eigen::Matrix&lt;double, 3, 1&gt; position;\n    Eigen::Matrix&lt;double, 3, 1&gt; velocity;\n    Eigen::Quaterniond          quat;\n\n    imu_integrator_input(time_point last_cam_integration_time_, duration t_offset_, imu_params params_,\n                         Eigen::Vector3d biasAcc_, Eigen::Vector3d biasGyro_, Eigen::Matrix&lt;double, 3, 1&gt; position_,\n                         Eigen::Matrix&lt;double, 3, 1&gt; velocity_, Eigen::Quaterniond quat_)\n        : last_cam_integration_time{last_cam_integration_time_}\n        , t_offset{t_offset_}\n        , params{std::move(params_)}\n        , biasAcc{std::move(biasAcc_)}\n        , biasGyro{std::move(biasGyro_)}\n        , position{std::move(position_)}\n        , velocity{std::move(velocity_)}\n        , quat{std::move(quat_)} { }\n};\n\n// Output of the IMU integrator to be used by pose prediction\nstruct imu_raw_type : public switchboard::event {\n    // Biases from the last two IMU integration iterations used by RK4 for pose predict\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat;\n    Eigen::Matrix&lt;double, 3, 1&gt; w_hat2;\n    Eigen::Matrix&lt;double, 3, 1&gt; a_hat2;\n\n    // Faster pose propagated forwards by the IMU integrator\n    Eigen::Matrix&lt;double, 3, 1&gt; pos;\n    Eigen::Matrix&lt;double, 3, 1&gt; vel;\n    Eigen::Quaterniond          quat;\n    time_point                  imu_time;\n\n    imu_raw_type(Eigen::Matrix&lt;double, 3, 1&gt; w_hat_, Eigen::Matrix&lt;double, 3, 1&gt; a_hat_, Eigen::Matrix&lt;double, 3, 1&gt; w_hat2_,\n                 Eigen::Matrix&lt;double, 3, 1&gt; a_hat2_, Eigen::Matrix&lt;double, 3, 1&gt; pos_, Eigen::Matrix&lt;double, 3, 1&gt; vel_,\n                 Eigen::Quaterniond quat_, time_point imu_time_)\n        : w_hat{std::move(w_hat_)}\n        , a_hat{std::move(a_hat_)}\n        , w_hat2{std::move(w_hat2_)}\n        , a_hat2{std::move(a_hat2_)}\n        , pos{std::move(pos_)}\n        , vel{std::move(vel_)}\n        , quat{std::move(quat_)}\n        , imu_time{imu_time_} { }\n};\n\nstruct pose_type : public switchboard::event {\n    time_point         sensor_time; // Recorded time of sensor data ingestion\n    Eigen::Vector3f    position;\n    Eigen::Quaternionf orientation;\n\n    pose_type()\n        : sensor_time{time_point{}}\n        , position{Eigen::Vector3f{0, 0, 0}}\n        , orientation{Eigen::Quaternionf{1, 0, 0, 0}} { }\n\n    pose_type(time_point sensor_time_, Eigen::Vector3f position_, Eigen::Quaternionf orientation_)\n        : sensor_time{sensor_time_}\n        , position{std::move(position_)}\n        , orientation{std::move(orientation_)} { }\n};\n\ntypedef struct {\n    pose_type  pose;\n    time_point predict_computed_time; // Time at which the prediction was computed\n    time_point predict_target_time;   // Time that prediction targeted.\n} fast_pose_type;\n\n// Used to identify which graphics API is being used (for swapchain construction)\nenum class graphics_api { OPENGL, VULKAN, TBD };\n\n// Used to distinguish between different image handles\nenum class swapchain_usage { LEFT_SWAPCHAIN, RIGHT_SWAPCHAIN, LEFT_RENDER, RIGHT_RENDER, NA };\n\ntypedef struct vk_image_handle {\n    int      file_descriptor;\n    int64_t  format;\n    size_t   allocation_size;\n    uint32_t width;\n    uint32_t height;\n\n    vk_image_handle(int fd_, int64_t format_, size_t alloc_size, uint32_t width_, uint32_t height_)\n        : file_descriptor{fd_}\n        , format{format_}\n        , allocation_size{alloc_size}\n        , width{width_}\n        , height{height_} { }\n} vk_image_handle;\n\n// This is used to share swapchain images between ILLIXR and Monado.\n// When Monado uses its GL pipeline, it's enough to just share a context during creation.\n// Otherwise, file descriptors are needed to share the images.\nstruct image_handle : public switchboard::event {\n    graphics_api type;\n\n    union {\n        GLuint          gl_handle;\n        vk_image_handle vk_handle;\n    };\n\n    uint32_t        num_images;\n    swapchain_usage usage;\n\n    image_handle()\n        : type{graphics_api::TBD}\n        , gl_handle{0}\n        , num_images{0}\n        , usage{swapchain_usage::NA} { }\n\n    image_handle(GLuint gl_handle_, uint32_t num_images_, swapchain_usage usage_)\n        : type{graphics_api::OPENGL}\n        , gl_handle{gl_handle_}\n        , num_images{num_images_}\n        , usage{usage_} { }\n\n    image_handle(int vk_fd_, int64_t format, size_t alloc_size, uint32_t width_, uint32_t height_, uint32_t num_images_,\n                 swapchain_usage usage_)\n        : type{graphics_api::VULKAN}\n        , vk_handle{vk_fd_, format, alloc_size, width_, height_}\n        , num_images{num_images_}\n        , usage{usage_} { }\n};\n\n// Using arrays as a swapchain\n// Array of left eyes, array of right eyes\n// This more closely matches the format used by Monado\nstruct rendered_frame : public switchboard::event {\n    std::array&lt;GLuint, 2&gt; swapchain_indices{}; // Does not change between swaps in swapchain\n    std::array&lt;GLuint, 2&gt; swap_indices{};      // Which element of the swapchain\n    fast_pose_type        render_pose;         // The pose used when rendering this frame.\n    time_point            sample_time{};\n    time_point            render_time{};\n\n    rendered_frame() = default;\n\n    rendered_frame(std::array&lt;GLuint, 2&gt;&amp;&amp; swapchain_indices_, std::array&lt;GLuint, 2&gt;&amp;&amp; swap_indices_,\n                   fast_pose_type render_pose_, time_point sample_time_, time_point render_time_)\n        : swapchain_indices{swapchain_indices_}\n        , swap_indices{swap_indices_}\n        , render_pose(std::move(render_pose_))\n        , sample_time(sample_time_)\n        , render_time(render_time_) { }\n};\n\nstruct hologram_input : public switchboard::event {\n    uint seq{};\n\n    hologram_input() = default;\n\n    explicit hologram_input(uint seq_)\n        : seq{seq_} { }\n};\n\nstruct signal_to_quad : public switchboard::event {\n    ullong seq;\n\n    signal_to_quad(ullong seq_)\n        : seq{seq_} { }\n};\n\n// High-level HMD specification, timewarp plugin\n// may/will calculate additional HMD info based on these specifications\nstruct hmd_physical_info {\n    float ipd;\n    int   displayPixelsWide;\n    int   displayPixelsHigh;\n    float chromaticAberration[4];\n    float K[11];\n    int   visiblePixelsWide;\n    int   visiblePixelsHigh;\n    float visibleMetersWide;\n    float visibleMetersHigh;\n    float lensSeparationInMeters;\n    float metersPerTanAngleAtCenter;\n};\n\nstruct texture_pose : public switchboard::event {\n    duration           offload_duration{};\n    unsigned char*     image{};\n    time_point         pose_time{};\n    Eigen::Vector3f    position;\n    Eigen::Quaternionf latest_quaternion;\n    Eigen::Quaternionf render_quaternion;\n\n    texture_pose() = default;\n\n    texture_pose(duration offload_duration_, unsigned char* image_, time_point pose_time_, Eigen::Vector3f position_,\n                 Eigen::Quaternionf latest_quaternion_, Eigen::Quaternionf render_quaternion_)\n        : offload_duration{offload_duration_}\n        , image{image_}\n        , pose_time{pose_time_}\n        , position{std::move(position_)}\n        , latest_quaternion{std::move(latest_quaternion_)}\n        , render_quaternion{std::move(render_quaternion_)} { }\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/dynamic__lib_8hpp/","title":"File dynamic_lib.hpp","text":"<p>FileList &gt; illixr &gt; dynamic_lib.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include &lt;dlfcn.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/dynamic__lib_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/dynamic__lib_8hpp/#classes","title":"Classes","text":"Type Name class dynamic_lib <p>The documentation for this class was generated from the following file <code>include/illixr/dynamic_lib.hpp</code></p>"},{"location":"api/dynamic__lib_8hpp_source/","title":"File dynamic_lib.hpp","text":"<p>File List &gt; illixr &gt; dynamic_lib.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"error_util.hpp\"\n\n#include &lt;dlfcn.h&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n\nusing void_ptr = std::unique_ptr&lt;void, std::function&lt;void(void*)&gt;&gt;;\n\n/*\nUsage:\n    void* thing;\n    void_ptr wrapped_thing = {thing, [](void* thing) {\n        // destructor goes here.\n    }}\n    // wrapped_thing.get() returns underlying thing.\n */\n\nclass dynamic_lib {\nprivate:\n    explicit dynamic_lib(void_ptr&amp;&amp; handle, std::string lib_path = \"\")\n        : _m_handle{std::move(handle)}\n        , _m_lib_path{std::move(lib_path)} { }\n\npublic:\n    dynamic_lib(dynamic_lib&amp;&amp; other) noexcept\n        : _m_handle{std::move(other._m_handle)}\n        , _m_lib_path{std::move(other._m_lib_path)} { }\n\n    dynamic_lib&amp; operator=(dynamic_lib&amp;&amp; other) noexcept {\n        if (this != &amp;other) {\n            _m_handle   = std::move(other._m_handle);\n            _m_lib_path = std::move(other._m_lib_path);\n        }\n        return *this;\n    }\n\n    ~dynamic_lib() {\n#ifndef NDEBUG\n        if (!_m_lib_path.empty()) {\n            spdlog::get(\"illixr\")-&gt;debug(\"[dynamic_lib] Destructing library : {}\", _m_lib_path);\n        }\n#endif \n    }\n\n    static dynamic_lib create(const std::string&amp; path) {\n        return dynamic_lib::create(std::string_view{path});\n    }\n\n    static dynamic_lib create(const std::string_view&amp; path) {\n        char* error;\n\n        // dlopen man page says that it can set errno sp\n        RAC_ERRNO_MSG(\"dynamic_lib before dlopen\");\n        void* handle = dlopen(path.data(), RTLD_LAZY | RTLD_LOCAL);\n        RAC_ERRNO_MSG(\"dynamic_lib after dlopen\");\n\n        if ((error = dlerror()) || !handle) {\n            throw std::runtime_error{\"dlopen(\\\"\" + std::string{path} +\n                                     \"\\\"): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n        }\n\n        return dynamic_lib{\n            void_ptr{handle,\n                     [](void* handle) {\n                         RAC_ERRNO();\n\n                         char* error;\n                         int   ret = dlclose(handle);\n                         if ((error = dlerror()) || ret) {\n                             const std::string msg_error{\"dlclose(): \" + (error == nullptr ? \"NULL\" : std::string{error})};\n                             spdlog::get(\"illixr\")-&gt;error(\"[dynamic_lib] {}\", msg_error);\n                             throw std::runtime_error{msg_error};\n                         }\n                     }},\n            std::string{path} \n        };\n    }\n\n    const void* operator[](const std::string&amp; symbol_name) const {\n        RAC_ERRNO_MSG(\"dynamic_lib at start of operator[]\");\n\n        char* error;\n        void* symbol = dlsym(_m_handle.get(), symbol_name.c_str());\n        if ((error = dlerror())) {\n            throw std::runtime_error{\"dlsym(\\\"\" + symbol_name + \"\\\"): \" + std::string{error}};\n        }\n        return symbol;\n    }\n\n    template&lt;typename T&gt;\n    const T get(const std::string&amp; symbol_name) const {\n        const void* obj = (*this)[symbol_name];\n        // return reinterpret_cast&lt;const T&gt;((*this)[symbol_name]);\n        return (const T) obj;\n    }\n\nprivate:\n    void_ptr    _m_handle;\n    std::string _m_lib_path;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/error__util_8hpp/","title":"File error_util.hpp","text":"<p>FileList &gt; illixr &gt; error_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"global_module_defs.hpp\"</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/error__util_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/error__util_8hpp/#macros","title":"Macros","text":"Type Name define RAC_ERRNO () <code>[**ILLIXR::report\\_and\\_clear\\_errno**](namespaceILLIXR.md#function-report_and_clear_errno)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_, \\_\\_func\\_\\_)</code>Parameterless macro for report_and_clear_errno. define RAC_ERRNO_MSG (msg) <code>[**ILLIXR::report\\_and\\_clear\\_errno**](namespaceILLIXR.md#function-report_and_clear_errno)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_, \\_\\_func\\_\\_, msg)</code>RAC_ERRNO."},{"location":"api/error__util_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/error__util_8hpp/#define-rac_errno","title":"define RAC_ERRNO","text":"<p>Parameterless macro for report_and_clear_errno. <pre><code>#define RAC_ERRNO (\n\n) `ILLIXR::report_and_clear_errno (__FILE__, __LINE__, __func__)`\n</code></pre></p>"},{"location":"api/error__util_8hpp/#define-rac_errno_msg","title":"define RAC_ERRNO_MSG","text":"<p>RAC_ERRNO. <pre><code>#define RAC_ERRNO_MSG (\n    msg\n) `ILLIXR::report_and_clear_errno (__FILE__, __LINE__, __func__, msg)`\n</code></pre></p> <p>Parameterized macro for report_and_clear_errno.</p> <p>Prints a message from the calling context for additional info. </p> <p>The documentation for this class was generated from the following file <code>include/illixr/error_util.hpp</code></p>"},{"location":"api/error__util_8hpp_source/","title":"File error_util.hpp","text":"<p>File List &gt; illixr &gt; error_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef NDEBUG\n    #include &lt;cerrno&gt;\n    #include &lt;cstdlib&gt;\n#endif\n#include \"global_module_defs.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n\n#ifndef RAC_ERRNO\n    #define RAC_ERRNO() ILLIXR::report_and_clear_errno(__FILE__, __LINE__, __func__)\n#endif \n\n#ifndef RAC_ERRNO_MSG\n    #define RAC_ERRNO_MSG(msg) ILLIXR::report_and_clear_errno(__FILE__, __LINE__, __func__, msg)\n#endif \n\nnamespace ILLIXR {\n\nstatic const bool ENABLE_VERBOSE_ERRORS{ILLIXR::str_to_bool(ILLIXR::getenv_or(\"ILLIXR_ENABLE_VERBOSE_ERRORS\", \"False\"))};\n\ninline void report_and_clear_errno([[maybe_unused]] const std::string&amp; file, [[maybe_unused]] const int&amp; line,\n                                   [[maybe_unused]] const std::string&amp; function, [[maybe_unused]] const std::string&amp; msg = \"\") {\n#ifndef NDEBUG\n    if (errno &gt; 0) {\n        if (ILLIXR::ENABLE_VERBOSE_ERRORS) {\n            spdlog::get(\"illixr\")-&gt;error(\"[error_util] || Errno was set: {} @ {}:{} [{}]\", errno, file, line, function);\n            if (!msg.empty()) {\n                spdlog::get(\"illixr\")-&gt;error(\"[error_util]|&gt; Message: {}\", msg);\n            }\n        }\n        errno = 0;\n    }\n#endif \n}\n\ninline void abort(const std::string&amp; msg = \"\", [[maybe_unused]] const int error_val = 1) {\n    spdlog::get(\"illixr\")-&gt;error(\"[error_util] ** ERROR ** {}\", msg);\n#ifndef NDEBUG\n    std::abort();\n#else  \n    std::exit(error_val);\n#endif \n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/extended__window_8hpp/","title":"File extended_window.hpp","text":"<p>FileList &gt; illixr &gt; extended_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include \"global_module_defs.hpp\"</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> </ul>"},{"location":"api/extended__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/extended__window_8hpp/#classes","title":"Classes","text":"Type Name class xlib_gl_extended_window"},{"location":"api/extended__window_8hpp/#public-types","title":"Public Types","text":"Type Name typedef GLXContext(* glXCreateContextAttribsARBProc"},{"location":"api/extended__window_8hpp/#macros","title":"Macros","text":"Type Name define GLX_CONTEXT_MAJOR_VERSION_ARB <code>0x2091</code> define GLX_CONTEXT_MINOR_VERSION_ARB <code>0x2092</code>"},{"location":"api/extended__window_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/extended__window_8hpp/#typedef-glxcreatecontextattribsarbproc","title":"typedef glXCreateContextAttribsARBProc","text":"<pre><code>typedef GLXContext(* glXCreateContextAttribsARBProc) (Display *, GLXFBConfig, GLXContext, Bool, const int *);\n</code></pre>"},{"location":"api/extended__window_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/extended__window_8hpp/#define-glx_context_major_version_arb","title":"define GLX_CONTEXT_MAJOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MAJOR_VERSION_ARB `0x2091`\n</code></pre>"},{"location":"api/extended__window_8hpp/#define-glx_context_minor_version_arb","title":"define GLX_CONTEXT_MINOR_VERSION_ARB","text":"<pre><code>#define GLX_CONTEXT_MINOR_VERSION_ARB `0x2092`\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/extended_window.hpp</code></p>"},{"location":"api/extended__window_8hpp_source/","title":"File extended_window.hpp","text":"<p>File List &gt; illixr &gt; extended_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"error_util.hpp\"\n#include \"global_module_defs.hpp\"\n#include \"phonebook.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;cerrno&gt;\n#include &lt;GL/glx.h&gt;\n#ifndef NDEBUG\n    #include &lt;spdlog/spdlog.h&gt;\n#endif\n\n// GLX context magics\n#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092\ntypedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);\n\nnamespace ILLIXR {\nclass xlib_gl_extended_window : public phonebook::service {\npublic:\n    int        width;\n    int        height;\n    Display*   dpy;\n    Window     win;\n    GLXContext glc;\n\n    xlib_gl_extended_window(int _width, int _height, GLXContext _shared_gl_context) {\n        width  = _width;\n        height = _height;\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Opening display\");\n#endif\n        RAC_ERRNO_MSG(\"extended_window at start of xlib_gl_extended_window constructor\");\n\n        dpy = XOpenDisplay(nullptr);\n        if (dpy == nullptr) {\n            ILLIXR::abort(\"Cannot connect to X server\");\n        } else {\n            // Apparently, XOpenDisplay's _true_ error indication is whether dpy is nullptr.\n            // https://cboard.cprogramming.com/linux-programming/119957-xlib-perversity.html\n            // if (errno != 0) {\n            //  std::cerr &lt;&lt; \"XOpenDisplay succeeded, but errno = \" &lt;&lt; errno &lt;&lt; \"; This is benign, so I'm clearing it now.\\n\";\n            // }\n            errno = 0;\n        }\n\n        Window root = DefaultRootWindow(dpy);\n        // Get a matching FB config\n        static int visual_attribs[] = {GLX_X_RENDERABLE,\n                                       True,\n                                       GLX_DRAWABLE_TYPE,\n                                       GLX_WINDOW_BIT,\n                                       GLX_RENDER_TYPE,\n                                       GLX_RGBA_BIT,\n                                       GLX_X_VISUAL_TYPE,\n                                       GLX_TRUE_COLOR,\n                                       GLX_RED_SIZE,\n                                       8,\n                                       GLX_GREEN_SIZE,\n                                       8,\n                                       GLX_BLUE_SIZE,\n                                       8,\n                                       GLX_ALPHA_SIZE,\n                                       8,\n                                       GLX_DEPTH_SIZE,\n                                       24,\n                                       GLX_STENCIL_SIZE,\n                                       8,\n                                       GLX_DOUBLEBUFFER,\n                                       True,\n                                       None};\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Getting matching framebuffer configs\");\n#endif\n        RAC_ERRNO_MSG(\"extended_window before glXChooseFBConfig\");\n\n        int          fbcount = 0;\n        int          screen  = DefaultScreen(dpy);\n        GLXFBConfig* fbc     = glXChooseFBConfig(dpy, screen, visual_attribs, &amp;fbcount);\n        if (!fbc) {\n            ILLIXR::abort(\"Failed to retrieve a framebuffer config\");\n        }\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Found {} matching FB configs\", fbcount);\n\n        // Pick the FB config/visual with the most samples per pixel\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Getting XVisualInfos\");\n#endif\n        int best_fbc = -1, worst_fbc = -1, best_num_samp = -1, worst_num_samp = 999;\n        int i;\n        for (i = 0; i &lt; fbcount; ++i) {\n            XVisualInfo* vi = glXGetVisualFromFBConfig(dpy, fbc[i]);\n            if (vi) {\n                int samp_buf, samples;\n                glXGetFBConfigAttrib(dpy, fbc[i], GLX_SAMPLE_BUFFERS, &amp;samp_buf);\n                glXGetFBConfigAttrib(dpy, fbc[i], GLX_SAMPLES, &amp;samples);\n#ifndef NDEBUG\n                spdlog::get(\"illixr\")-&gt;debug(\n                    \"[extended_window] Matching fbconfig {}, visual ID {:x}: SAMPLE_BUFFERS = {}, SAMPLES = {}\", i,\n                    vi-&gt;visualid, samp_buf, samples);\n#endif\n                if (best_fbc &lt; 0 || (samp_buf &amp;&amp; samples &gt; best_num_samp)) {\n                    best_fbc = i, best_num_samp = samples;\n                }\n                if (worst_fbc &lt; 0 || (!samp_buf || samples &lt; worst_num_samp)) {\n                    worst_fbc = i, worst_num_samp = samples;\n                }\n            }\n            XFree(vi);\n        }\n\n        assert(0 &lt;= best_fbc &amp;&amp; best_fbc &lt; fbcount);\n        GLXFBConfig bestFbc = fbc[best_fbc];\n\n        // Free the FBConfig list allocated by glXChooseFBConfig()\n        XFree(fbc);\n\n        // Get a visual\n        XVisualInfo* vi = glXGetVisualFromFBConfig(dpy, bestFbc);\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Chose visual ID = {:x}\", vi-&gt;visualid);\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Creating colormap\");\n#endif\n        _m_cmap = XCreateColormap(dpy, root, vi-&gt;visual, AllocNone);\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Creating window\");\n#endif\n        XSetWindowAttributes attributes;\n        attributes.colormap         = _m_cmap;\n        attributes.background_pixel = 0;\n        attributes.border_pixel     = 0;\n        attributes.event_mask       = ExposureMask | KeyPressMask;\n        win                         = XCreateWindow(dpy, root, 0, 0, width, height, 0, vi-&gt;depth, InputOutput, vi-&gt;visual,\n                                                    CWBackPixel | CWColormap | CWBorderPixel | CWEventMask, &amp;attributes);\n        if (!win) {\n            ILLIXR::abort(\"Failed to create window\");\n        }\n        XStoreName(dpy, win, \"ILLIXR Extended Window\");\n        XMapWindow(dpy, win);\n\n        // Done with visual info\n        XFree(vi);\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[extended_window] Creating context\");\n#endif\n        auto glXCreateContextAttribsARB =\n            (glXCreateContextAttribsARBProc) glXGetProcAddressARB((const GLubyte*) \"glXCreateContextAttribsARB\");\n        int context_attribs[] = {GLX_CONTEXT_MAJOR_VERSION_ARB, 3, GLX_CONTEXT_MINOR_VERSION_ARB, 3, None};\n\n        glc = glXCreateContextAttribsARB(dpy, bestFbc, _shared_gl_context, True, context_attribs);\n\n        // Sync to process errors\n        RAC_ERRNO_MSG(\"extended_window before XSync\");\n        XSync(dpy, false);\n        RAC_ERRNO_MSG(\"extended_window after XSync\");\n\n#ifndef NDEBUG\n        // Doing glXMakeCurrent here makes a third thread, the runtime one, enter the mix, and\n        // then there are three GL threads: runtime, timewarp, and gldemo, and the switching of\n        // contexts without synchronization during the initialization phase causes a data race.\n        // This is why native.yaml sometimes succeeds and sometimes doesn't. Headless succeeds\n        // because this behavior is OpenGL implementation dependent, and apparently mesa\n        // differs from NVIDIA in this regard.\n        // The proper fix is #173. Comment the below back in once #173 is done. In any case,\n        // this is just for debugging and does not affect any functionality.\n\n        /*\n        const bool gl_result_0 = static_cast&lt;bool&gt;(glXMakeCurrent(dpy, win, glc));\n        int major = 0, minor = 0;\n        glGetIntegerv(GL_MAJOR_VERSION, &amp;major);\n        glGetIntegerv(GL_MINOR_VERSION, &amp;minor);\n        std::cout &lt;&lt; \"OpenGL context created\" &lt;&lt; std::endl\n                  &lt;&lt; \"Version \" &lt;&lt; major &lt;&lt; \".\" &lt;&lt; minor &lt;&lt; std::endl\n                  &lt;&lt; \"Vender \" &lt;&lt; glGetString(GL_VENDOR) &lt;&lt; std::endl\n                  &lt;&lt; \"Renderer \" &lt;&lt; glGetString(GL_RENDERER) &lt;&lt; std::endl;\n        const bool gl_result_1 = static_cast&lt;bool&gt;(glXMakeCurrent(dpy, None, nullptr));\n        */\n#endif\n    }\n\n    ~xlib_gl_extended_window() override {\n        RAC_ERRNO_MSG(\"xlib_gl_extended_window at start of destructor\");\n\n        [[maybe_unused]] const bool gl_result = static_cast&lt;bool&gt;(glXMakeCurrent(dpy, None, nullptr));\n        assert(gl_result &amp;&amp; \"glXMakeCurrent should not fail\");\n\n        glXDestroyContext(dpy, glc);\n        XDestroyWindow(dpy, win);\n        Window root = DefaultRootWindow(dpy);\n        XDestroyWindow(dpy, root);\n        XFreeColormap(dpy, _m_cmap);\n\n        XCloseDisplay(dpy);\n\n        RAC_ERRNO_MSG(\"xlib_gl_extended_window at end of destructor\");\n    }\n\nprivate:\n    Colormap _m_cmap;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/global__module__defs_8hpp/","title":"File global_module_defs.hpp","text":"<p>FileList &gt; illixr &gt; global_module_defs.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"relative_clock.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"api/global__module__defs_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/global__module__defs_8hpp/#classes","title":"Classes","text":"Type Name struct display_params Display parameters. struct rendering_params Rendering parameters. <p>The documentation for this class was generated from the following file <code>include/illixr/global_module_defs.hpp</code></p>"},{"location":"api/global__module__defs_8hpp_source/","title":"File global_module_defs.hpp","text":"<p>File List &gt; illixr &gt; global_module_defs.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Common parameters. Ultimately, these need to be moved to a yaml file.\n#pragma once\n\n#include \"relative_clock.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace ILLIXR {\n\nstruct display_params {\n    // Display width in pixels\n    static constexpr unsigned width_pixels = 2560;\n\n    // Display height in pixels\n    static constexpr unsigned height_pixels = 1440;\n\n    // Display width in meters\n    static constexpr float width_meters = 0.11047f;\n\n    // Display height in meters\n    static constexpr float height_meters = 0.06214f;\n\n    // Separation between lens centers in meters\n    static constexpr float lens_separation = width_meters / 2.0f;\n\n    // Vertical position of the lens in meters\n    static constexpr float lens_vertical_position = height_meters / 2.0f;\n\n    // Display horizontal field-of-view in degrees\n    static constexpr float fov_x = 90.0f;\n\n    // Display vertical field-of-view in degrees\n    static constexpr float fov_y = 90.0f;\n\n    // Meters per tangent angle at the center of the HMD (required by timewarp_gl's distortion correction)\n    static constexpr float meters_per_tan_angle = width_meters / (2 * (fov_x * M_PI / 180.0f));\n\n    // Inter-pupilary distance (ipd) in meters\n    static constexpr float ipd = 0.064f;\n\n    // Display refresh rate in Hz\n    static constexpr float frequency = 120.0f;\n\n    // Display period in nanoseconds\n    static constexpr duration period = freq2period(frequency);\n\n    // Chromatic aberration constants\n    static constexpr float aberration[4] = {-0.016f, 0.0f, 0.024f, 0.0f};\n};\n\nstruct rendering_params {\n    // Near plane distance in meters\n    static constexpr float near_z = 0.1f;\n\n    // Far plane distance in meters\n    static constexpr float far_z = 20.0f;\n};\n\ninline bool str_to_bool(const std::string&amp; var) {\n    std::string temp = var;\n    std::transform(temp.begin(), temp.end(), temp.begin(), ::toupper);\n    return (temp == \"TRUE\") ? true\n        : (temp == \"FALSE\") ? false\n                            : throw std::runtime_error(\"Invalid conversion from std::string to bool\");\n}\n\ninline std::string getenv_or(const std::string&amp; var, std::string default_) {\n    if (std::getenv(var.c_str())) {\n        return {std::getenv(var.c_str())};\n    } else {\n        return default_;\n    }\n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/managed__thread_8hpp/","title":"File managed_thread.hpp","text":"<p>FileList &gt; illixr &gt; managed_thread.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/managed__thread_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/managed__thread_8hpp/#classes","title":"Classes","text":"Type Name class managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. <p>The documentation for this class was generated from the following file <code>include/illixr/managed_thread.hpp</code></p>"},{"location":"api/managed__thread_8hpp_source/","title":"File managed_thread.hpp","text":"<p>File List &gt; illixr &gt; managed_thread.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;functional&gt;\n#include &lt;stdexcept&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n\nclass managed_thread {\nprivate:\n    std::atomic&lt;bool&gt;     _m_stop{false};\n    std::thread           _m_thread;\n    std::function&lt;void()&gt; _m_body;\n    std::function&lt;void()&gt; _m_on_start;\n    std::function&lt;void()&gt; _m_on_stop;\n\n    void thread_main() {\n        assert(_m_body);\n        if (_m_on_start) {\n            _m_on_start();\n        }\n        while (!this-&gt;_m_stop.load()) {\n            _m_body();\n        }\n        if (_m_on_stop) {\n            _m_on_stop();\n        }\n    }\n\npublic:\n    managed_thread() noexcept = default;\n\n    explicit managed_thread(std::function&lt;void()&gt; body, std::function&lt;void()&gt; on_start = std::function&lt;void()&gt;{},\n                            std::function&lt;void()&gt; on_stop = std::function&lt;void()&gt;{}) noexcept\n        : _m_body{std::move(body)}\n        , _m_on_start{std::move(on_start)}\n        , _m_on_stop{std::move(on_stop)} { }\n\n    ~managed_thread() noexcept {\n        if (get_state() == state::running) {\n            stop();\n        }\n        assert(get_state() == state::stopped || get_state() == state::startable || get_state() == state::nonstartable);\n        // assert(!_m_thread.joinable());\n    }\n\n    enum class state {\n        nonstartable,\n        startable,\n        running,\n        stopped,\n    };\n\n    state get_state() {\n        bool stopped = _m_stop.load();\n        if (!_m_body) {\n            return state::nonstartable;\n        } else if (!stopped &amp;&amp; !_m_thread.joinable()) {\n            return state::startable;\n        } else if (!stopped &amp;&amp; _m_thread.joinable()) {\n            return state::running;\n        } else if (stopped) {\n            return state::stopped;\n        } else {\n            throw std::logic_error{\"Unknown state\"};\n        }\n    }\n\n    void start() {\n        assert(get_state() == state::startable);\n        _m_thread = std::thread{&amp;managed_thread::thread_main, this};\n        assert(get_state() == state::running);\n    }\n\n    void stop() {\n        assert(get_state() == state::running);\n        _m_stop.store(true);\n        _m_thread.join();\n        assert(get_state() == state::stopped);\n    }\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/math__util_8hpp/","title":"File math_util.hpp","text":"<p>FileList &gt; illixr &gt; math_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;eigen3/Eigen/Core&gt;</code></li> </ul>"},{"location":"api/math__util_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG. namespace math_util <p>The documentation for this class was generated from the following file <code>include/illixr/math_util.hpp</code></p>"},{"location":"api/math__util_8hpp_source/","title":"File math_util.hpp","text":"<p>File List &gt; illixr &gt; math_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;eigen3/Eigen/Core&gt;\n\nnamespace ILLIXR {\nnamespace math_util {\n    void projection(Eigen::Matrix4f* result, const float tan_left, const float tan_right, const float tan_up,\n                    float const tan_down, const float near_z, const float far_z) {\n        const float tan_width  = tan_right - tan_left;\n        const float tan_height = tan_up - tan_down;\n\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n        (*result)(0, 0) = 2 / tan_width;\n        (*result)(0, 1) = 0;\n        (*result)(0, 2) = (tan_right + tan_left) / tan_width;\n        (*result)(0, 3) = 0;\n\n        (*result)(1, 0) = 0;\n        (*result)(1, 1) = 2 / tan_height;\n        (*result)(1, 2) = (tan_up + tan_down) / tan_height;\n        (*result)(1, 3) = 0;\n\n        (*result)(2, 0) = 0;\n        (*result)(2, 1) = 0;\n        (*result)(2, 2) = -far_z / (far_z - near_z);\n        (*result)(2, 3) = -(far_z * near_z) / (far_z - near_z);\n\n        (*result)(3, 0) = 0;\n        (*result)(3, 1) = 0;\n        (*result)(3, 2) = -1;\n        (*result)(3, 3) = 0;\n    }\n\n    void projection_fov(Eigen::Matrix4f* result, const float fov_left, const float fov_right, const float fov_up,\n                        const float fov_down, const float near_z, const float far_z) {\n        const float tan_left  = -tanf(static_cast&lt;float&gt;(fov_left * (M_PI / 180.0f)));\n        const float tan_right = tanf(static_cast&lt;float&gt;(fov_right * (M_PI / 180.0f)));\n\n        const float tan_down = -tanf(static_cast&lt;float&gt;(fov_down * (M_PI / 180.0f)));\n        const float tan_up   = tanf(static_cast&lt;float&gt;(fov_up * (M_PI / 180.0f)));\n\n        projection(result, tan_left, tan_right, tan_up, tan_down, near_z, far_z);\n    }\n} // namespace math_util\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/opencv__data__types_8hpp/","title":"File opencv_data_types.hpp","text":"<p>FileList &gt; illixr &gt; opencv_data_types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"switchboard.hpp\"</code></li> <li><code>#include &lt;opencv2/core/mat.hpp&gt;</code></li> </ul>"},{"location":"api/opencv__data__types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/opencv__data__types_8hpp/#classes","title":"Classes","text":"Type Name struct cam_type struct rgb_depth_type <p>The documentation for this class was generated from the following file <code>include/illixr/opencv_data_types.hpp</code></p>"},{"location":"api/opencv__data__types_8hpp_source/","title":"File opencv_data_types.hpp","text":"<p>File List &gt; illixr &gt; opencv_data_types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"switchboard.hpp\"\n\n#include &lt;opencv2/core/mat.hpp&gt;\n\nnamespace ILLIXR {\n\nstruct cam_type : switchboard::event {\n    time_point time;\n    cv::Mat    img0;\n    cv::Mat    img1;\n\n    cam_type(time_point _time, cv::Mat _img0, cv::Mat _img1)\n        : time{_time}\n        , img0{std::move(_img0)}\n        , img1{std::move(_img1)} { }\n};\n\nstruct rgb_depth_type : public switchboard::event {\n    [[maybe_unused]] time_point time;\n    cv::Mat                     rgb;\n    cv::Mat                     depth;\n\n    rgb_depth_type(time_point _time, cv::Mat _rgb, cv::Mat _depth)\n        : time{_time}\n        , rgb{std::move(_rgb)}\n        , depth{std::move(_depth)} { }\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/phonebook_8hpp/","title":"File phonebook.hpp","text":"<p>FileList &gt; illixr &gt; phonebook.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> </ul>"},{"location":"api/phonebook_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/phonebook_8hpp/#classes","title":"Classes","text":"Type Name class phonebook A service locator forILLIXR . class service A 'service' that can be registered in the phonebook. <p>The documentation for this class was generated from the following file <code>include/illixr/phonebook.hpp</code></p>"},{"location":"api/phonebook_8hpp_source/","title":"File phonebook.hpp","text":"<p>File List &gt; illixr &gt; phonebook.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;typeindex&gt;\n#include &lt;unordered_map&gt;\n\n#ifndef NDEBUG\n    #include &lt;iostream&gt;\n    #include &lt;spdlog/spdlog.h&gt;\n    #include &lt;stdexcept&gt;\n#endif\n\nnamespace ILLIXR {\n\nclass phonebook {\n    /*\n      Proof of thread-safety:\n      - Since all instance members are private, acquiring a lock in each method implies the class is datarace-free.\n      - Since there is only one lock and this does not call any code containing locks, this is deadlock-free.\n      - Both of these methods are only used during initialization, so the locks are not contended in steady-state.\n\n      However, to write a correct program, one must also check the thread-safety of the elements\n      inserted into this class by the caller.\n    */\n\npublic:\n    class service {\n    public:\n        virtual ~service() = default;\n    };\n\n    template&lt;typename specific_service&gt;\n    void register_impl(std::shared_ptr&lt;specific_service&gt; impl) {\n        const std::unique_lock&lt;std::shared_mutex&gt; lock{_m_mutex};\n\n        const std::type_index type_index = std::type_index(typeid(specific_service));\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[phonebook] Register {}\", type_index.name());\n#endif\n        assert(_m_registry.count(type_index) == 0);\n        _m_registry.try_emplace(type_index, impl);\n    }\n\n    template&lt;typename specific_service&gt;\n    std::shared_ptr&lt;specific_service&gt; lookup_impl() const {\n        const std::shared_lock&lt;std::shared_mutex&gt; lock{_m_mutex};\n\n        const std::type_index type_index = std::type_index(typeid(specific_service));\n\n#ifndef NDEBUG\n        // if this assert fails, and there are no duplicate base classes, ensure the hash_code's are unique.\n        if (_m_registry.count(type_index) != 1) {\n            throw std::runtime_error{\"Attempted to lookup an unregistered implementation \" + std::string{type_index.name()}};\n        }\n#endif\n\n        std::shared_ptr&lt;service&gt; this_service = _m_registry.at(type_index);\n        assert(this_service);\n\n        std::shared_ptr&lt;specific_service&gt; this_specific_service = std::dynamic_pointer_cast&lt;specific_service&gt;(this_service);\n        assert(this_specific_service);\n\n        return this_specific_service;\n    }\n\nprivate:\n    std::unordered_map&lt;std::type_index, const std::shared_ptr&lt;service&gt;&gt; _m_registry;\n    mutable std::shared_mutex                                           _m_mutex;\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/plugin_8hpp/","title":"File plugin.hpp","text":"<p>FileList &gt; illixr &gt; plugin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> <li><code>#include \"spdlog/common.h\"</code></li> <li><code>#include \"spdlog/sinks/basic_file_sink.h\"</code></li> <li><code>#include \"spdlog/sinks/stdout_color_sinks.h\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;typeinfo&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/plugin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/plugin_8hpp/#classes","title":"Classes","text":"Type Name class plugin A dynamically-loadable plugin for Spindle."},{"location":"api/plugin_8hpp/#macros","title":"Macros","text":"Type Name define PLUGIN_MAIN (plugin_class) <code>/* multi line expression */</code>"},{"location":"api/plugin_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/plugin_8hpp/#define-plugin_main","title":"define PLUGIN_MAIN","text":"<pre><code>#define PLUGIN_MAIN (\n    plugin_class\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/plugin.hpp</code></p>"},{"location":"api/plugin_8hpp_source/","title":"File plugin.hpp","text":"<p>File List &gt; illixr &gt; plugin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"phonebook.hpp\"\n#include \"record_logger.hpp\"\n#include \"spdlog/common.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n#include \"spdlog/sinks/stdout_color_sinks.h\"\n\n#include &lt;memory&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n\nnamespace ILLIXR {\n\nusing plugin_id_t = std::size_t;\n\n/*\n * This gets included, but it is functionally 'private'. Hence the double-underscores.\n */\nconst record_header __plugin_start_header{\n    \"plugin_name\",\n    {\n        {\"plugin_id\", typeid(plugin_id_t)},\n        {\"plugin_name\", typeid(std::string)},\n    },\n};\n\nclass plugin {\npublic:\n    virtual void start() {\n        record_logger_-&gt;log(record{__plugin_start_header,\n                                   {\n                                       {id},\n                                       {name},\n                                   }});\n    }\n\n    virtual void stop() { }\n\n    plugin(std::string name_, phonebook* pb_)\n        : name{std::move(name_)}\n        , pb{pb_}\n        , record_logger_{pb-&gt;lookup_impl&lt;record_logger&gt;()}\n        , gen_guid_{pb-&gt;lookup_impl&lt;gen_guid&gt;()}\n        , id{gen_guid_-&gt;get()} { }\n\n    virtual ~plugin() = default;\n\n    [[nodiscard]] std::string get_name() const noexcept {\n        return name;\n    }\n\n    void spdlogger(const char* log_level) {\n        if (!log_level) {\n#ifdef NDEBUG\n            log_level = \"warn\";\n#else\n            log_level = \"debug\";\n#endif\n        }\n        std::vector&lt;spdlog::sink_ptr&gt; sinks;\n        auto                          file_sink = std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(\"logs/\" + name + \".log\");\n        auto                          console_sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;();\n        sinks.push_back(file_sink);\n        sinks.push_back(console_sink);\n        auto plugin_logger = std::make_shared&lt;spdlog::logger&gt;(name, begin(sinks), end(sinks));\n        plugin_logger-&gt;set_level(spdlog::level::from_str(log_level));\n        spdlog::register_logger(plugin_logger);\n    }\n\nprotected:\n    std::string                          name;\n    const phonebook*                     pb;\n    const std::shared_ptr&lt;record_logger&gt; record_logger_;\n    const std::shared_ptr&lt;gen_guid&gt;      gen_guid_;\n    const std::size_t                    id;\n};\n\n#define PLUGIN_MAIN(plugin_class)                           \\\n    extern \"C\" plugin* this_plugin_factory(phonebook* pb) { \\\n        auto* obj = new plugin_class{#plugin_class, pb};    \\\n        return obj;                                         \\\n    }\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/pose__prediction_8hpp/","title":"File pose_prediction.hpp","text":"<p>FileList &gt; illixr &gt; pose_prediction.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"data_format.hpp\"</code></li> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include \"illixr/relative_clock.hpp\"</code></li> <li><code>#include &lt;eigen3/Eigen/Geometry&gt;</code></li> </ul>"},{"location":"api/pose__prediction_8hpp/#classes","title":"Classes","text":"Type Name class pose_prediction <p>The documentation for this class was generated from the following file <code>include/illixr/pose_prediction.hpp</code></p>"},{"location":"api/pose__prediction_8hpp_source/","title":"File pose_prediction.hpp","text":"<p>File List &gt; illixr &gt; pose_prediction.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"data_format.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n\n#include &lt;eigen3/Eigen/Geometry&gt;\n\nusing namespace ILLIXR;\n\nclass pose_prediction : public phonebook::service {\npublic:\n    [[nodiscard]] virtual fast_pose_type     get_fast_pose() const                             = 0;\n    [[nodiscard]] virtual pose_type          get_true_pose() const                             = 0;\n    [[nodiscard]] virtual fast_pose_type     get_fast_pose(time_point future_time) const       = 0;\n    [[nodiscard]] virtual bool               fast_pose_reliable() const                        = 0;\n    [[nodiscard]] virtual bool               true_pose_reliable() const                        = 0;\n    virtual void                             set_offset(const Eigen::Quaternionf&amp; orientation) = 0;\n    [[nodiscard]] virtual Eigen::Quaternionf get_offset()                                      = 0;\n    [[nodiscard]] virtual pose_type          correct_pose(const pose_type&amp; pose) const         = 0;\n\n    ~pose_prediction() override = default;\n};\n</code></pre>"},{"location":"api/record__logger_8hpp/","title":"File record_logger.hpp","text":"<p>FileList &gt; illixr &gt; record_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;any&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"phonebook.hpp\"</code></li> </ul>"},{"location":"api/record__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/record__logger_8hpp/#classes","title":"Classes","text":"Type Name class data_use_indicator A helper class that lets one dynamically determine if some data gets used. class gen_guid This class generates unique IDs. class record This class represents a tuple of fields which get logged by <code>record_logger</code> . class record_coalescer Coalesces logs of the same type to be written back as a single-transaction. class record_header Schema of each record. class record_logger The ILLIXR logging service for structured records. <p>The documentation for this class was generated from the following file <code>include/illixr/record_logger.hpp</code></p>"},{"location":"api/record__logger_8hpp_source/","title":"File record_logger.hpp","text":"<p>File List &gt; illixr &gt; record_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;any&gt;\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#ifndef NDEBUG\n    #include &lt;iostream&gt;\n    #include &lt;sstream&gt;\n#endif\n\n#include \"phonebook.hpp\"\n\nnamespace ILLIXR {\n\nclass record_header {\npublic:\n    record_header(const std::string&amp; name_, std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns_)\n        : id{std::hash&lt;std::string&gt;{}(name_)}\n        , name{name_}\n        , columns{std::move(columns_)} { }\n\n    bool operator==(const record_header&amp; other) const {\n        // Check pointer first\n        if (this == &amp;other) {\n            return true;\n        }\n\n        if (name != other.name || columns.size() != other.columns.size() || id != other.id) {\n            return false;\n        }\n        for (std::size_t i = 0; i &lt; columns.size(); ++i) {\n            if (columns[i] != other.columns[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool operator!=(const record_header&amp; other) const {\n        return !(*this == other);\n    }\n\n    [[nodiscard]] std::size_t get_id() const {\n        return id;\n    }\n\n    [[nodiscard]] const std::string&amp; get_name() const {\n        return name;\n    }\n\n    [[nodiscard]] const std::string&amp; get_column_name(unsigned column) const {\n        return columns[column].first;\n    }\n\n    [[nodiscard]] const std::type_info&amp; get_column_type(unsigned column) const {\n        return columns[column].second;\n    }\n\n    [[nodiscard]] unsigned get_columns() const {\n        return columns.size();\n    }\n\n    [[nodiscard]] std::string to_string() const {\n        std::string ret = std::string{\"record_header \"} + name + std::string{\" { \"};\n        for (const auto&amp; pair : columns) {\n            ret += std::string{pair.second.name()} + std::string{\" \"} + pair.first + std::string{\"; \"};\n        }\n        ret.erase(ret.size() - 2);\n        ret += std::string{\" }\"};\n        return ret;\n    }\n\nprivate:\n    std::size_t                                                      id;\n    std::string                                                      name;\n    const std::vector&lt;std::pair&lt;std::string, const std::type_info&amp;&gt;&gt; columns;\n};\n\nclass data_use_indicator {\npublic:\n    data_use_indicator()\n        : used{false} { }\n\n    data_use_indicator(const data_use_indicator&amp; other)\n        : used{false} {\n        other.used = true;\n    }\n\n    data_use_indicator&amp; operator=(const data_use_indicator&amp; other) {\n        if (&amp;other != this) {\n            other.used = true;\n            used       = false;\n        }\n        return *this;\n    }\n\n    /*\n      copy constructors are just as efficient as move constructors would be,\n      so I won't define move constructors. C++ will invoke copy instead (for no loss).\n    */\n    bool is_used() const {\n        return used;\n    }\n\n    void mark_used() const {\n        used = true;\n    }\n\n    void mark_unused() const {\n        used = false;\n    }\n\nprivate:\n    mutable bool used;\n};\n\nclass record {\npublic:\n    record(const record_header&amp; rh_, std::vector&lt;std::any&gt; values_)\n        : rh{rh_}\n        , values(std::move(values_)) {\n#ifndef NDEBUG\n        assert(rh);\n        if (values.size() != rh-&gt;get().get_columns()) {\n            spdlog::get(\"illixr\")-&gt;error(\"[record_logger] {} elements passed, but rh for {} only specifies {}.\", values.size(),\n                                         rh-&gt;get().get_name(), rh-&gt;get().get_columns());\n            abort();\n        }\n        for (std::size_t column = 0; column &lt; values.size(); ++column) {\n            if (values[column].type() != rh-&gt;get().get_column_type(column)) {\n                spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Caller got wrong type for column {} of {}.\", column,\n                                             rh-&gt;get().get_name());\n                spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Caller passed: {}; record_header specifies: {}\",\n                                             values[column].type().name(), rh-&gt;get().get_column_type(column).name());\n                abort();\n            }\n        }\n#endif\n    }\n\n    record() = default;\n\n    ~record() {\n#ifndef NDEBUG\n        if (rh &amp;&amp; !data_use_indicator_.is_used()) {\n            spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Record was deleted without being logged.\");\n            abort();\n        }\n#endif\n    }\n\n    template&lt;typename T&gt;\n    T get_value(unsigned column) const {\n#ifndef NDEBUG\n        assert(rh);\n        data_use_indicator_.mark_used();\n        if (rh-&gt;get().get_column_type(column) != typeid(T)) {\n            std::ostringstream ss;\n            ss &lt;&lt; \"Caller column type for \" &lt;&lt; column &lt;&lt; \" of \" &lt;&lt; rh-&gt;get().get_name() &lt;&lt; \". \"\n               &lt;&lt; \"Caller passed: \" &lt;&lt; typeid(T).name() &lt;&lt; \"; \"\n               &lt;&lt; \"record_header specifies: \" &lt;&lt; rh-&gt;get().get_column_type(column).name() &lt;&lt; \". \";\n            throw std::runtime_error{ss.str()};\n        }\n#endif\n        return std::any_cast&lt;T&gt;(values[column]);\n    }\n\n    const record_header&amp; get_record_header() const {\n        assert(rh);\n        return rh-&gt;get();\n    }\n\n    void mark_used() const {\n#ifndef NDEBUG\n        assert(rh);\n        data_use_indicator_.mark_used();\n#endif\n    }\n\nprivate:\n    // Holding a pointer to a record_header is more efficient than\n    // requiring each record to hold a list of its column names\n    // and table name. This is just one pointer.\n    std::optional&lt;std::reference_wrapper&lt;const record_header&gt;&gt; rh;\n    std::vector&lt;std::any&gt;                                      values;\n#ifndef NDEBUG\n    data_use_indicator data_use_indicator_;\n#endif\n};\n\nclass record_logger : public phonebook::service {\npublic:\n    ~record_logger() override = default;\n\n    virtual void log(const record&amp; r) = 0;\n\n    virtual void log(const std::vector&lt;record&gt;&amp; rs) {\n        for (const record&amp; r : rs) {\n            log(r);\n        }\n    }\n};\n\nclass gen_guid : public phonebook::service {\npublic:\n    std::size_t get(std::size_t namespace_ = 0, std::size_t subnamespace = 0, std::size_t subsubnamespace = 0) {\n        if (guid_starts[namespace_][subnamespace].count(subsubnamespace) == 0) {\n            guid_starts[namespace_][subnamespace][subsubnamespace].store(1);\n        }\n        return guid_starts[namespace_][subnamespace][subsubnamespace]++;\n    }\n\nprivate:\n    std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::unordered_map&lt;std::size_t, std::atomic&lt;std::size_t&gt;&gt;&gt;&gt;\n        guid_starts;\n};\n\nstatic std::chrono::milliseconds LOG_BUFFER_DELAY{1000};\n\nclass record_coalescer {\nprivate:\n    std::shared_ptr&lt;record_logger&gt;                              logger;\n    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; last_log;\n    std::vector&lt;record&gt;                                         buffer;\n\npublic:\n    explicit record_coalescer(std::shared_ptr&lt;record_logger&gt; logger_)\n        : logger{std::move(logger_)}\n        , last_log{std::chrono::high_resolution_clock::now()} { }\n\n    ~record_coalescer() {\n        flush();\n    }\n\n    void log(const record&amp; r) {\n        if (logger) {\n            buffer.push_back(r);\n            // Log coalescer should only be used with\n            // In the common case, they will be the same pointer, quickly check the pointers.\n            // In the less common case, we check for object-structural equality.\n#ifndef NDEBUG\n            if (&amp;r.get_record_header() != &amp;buffer[0].get_record_header() &amp;&amp;\n                r.get_record_header() == buffer[0].get_record_header()) {\n                spdlog::get(\"illixr\")-&gt;error(\"[record_logger] Tried to push a record of type {} to a record logger for type {}\",\n                                             r.get_record_header().to_string(), buffer[0].get_record_header().to_string());\n                abort();\n            }\n#endif\n            maybe_flush();\n        }\n    }\n\n    void maybe_flush() {\n        if (std::chrono::high_resolution_clock::now() &gt; last_log + LOG_BUFFER_DELAY) {\n            flush();\n        }\n    }\n\n    void flush() {\n        if (logger) {\n            std::vector&lt;record&gt; buffer2;\n            buffer.swap(buffer2);\n            logger-&gt;log(buffer2);\n            last_log = std::chrono::high_resolution_clock::now();\n        }\n    }\n\n    explicit operator bool() const {\n        return bool(logger);\n    }\n};\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/relative__clock_8hpp/","title":"File relative_clock.hpp","text":"<p>FileList &gt; illixr &gt; relative_clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;ratio&gt;</code></li> </ul>"},{"location":"api/relative__clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/relative__clock_8hpp/#classes","title":"Classes","text":"Type Name class RelativeClock Relative clock for all of ILLIXR . class time_point <p>The documentation for this class was generated from the following file <code>include/illixr/relative_clock.hpp</code></p>"},{"location":"api/relative__clock_8hpp_source/","title":"File relative_clock.hpp","text":"<p>File List &gt; illixr &gt; relative_clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;ratio&gt;\n\nnamespace ILLIXR {\n\nusing _clock_rep      = long;\nusing _clock_period   = std::nano;\nusing _clock_duration = std::chrono::duration&lt;_clock_rep, _clock_period&gt;;\n\nclass time_point {\npublic:\n    using duration = _clock_duration;\n\n    time_point() = default;\n\n    constexpr explicit time_point(const duration&amp; time_since_epoch)\n        : _m_time_since_epoch{time_since_epoch} { }\n\n    [[nodiscard]] duration time_since_epoch() const {\n        return _m_time_since_epoch;\n    }\n\n    time_point&amp; operator+=(const duration&amp; d) {\n        this-&gt;_m_time_since_epoch += d;\n        return *this;\n    }\n\n    time_point&amp; operator-=(const duration&amp; d) {\n        this-&gt;_m_time_since_epoch -= d;\n        return *this;\n    }\n\nprivate:\n    duration _m_time_since_epoch;\n};\n\ninline time_point::duration operator-(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() - rhs.time_since_epoch();\n}\n\ninline time_point operator+(const time_point&amp; pt, const time_point::duration&amp; d) {\n    return time_point(pt.time_since_epoch() + d);\n}\n\ninline time_point operator+(const time_point::duration&amp; d, const time_point&amp; pt) {\n    return time_point(pt.time_since_epoch() + d);\n}\n\ninline bool operator&lt;(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &lt; rhs.time_since_epoch();\n}\n\ninline bool operator&gt;(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &gt; rhs.time_since_epoch();\n}\n\ninline bool operator&lt;=(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &lt;= rhs.time_since_epoch();\n}\n\ninline bool operator&gt;=(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() &gt;= rhs.time_since_epoch();\n}\n\ninline bool operator==(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() == rhs.time_since_epoch();\n}\n\ninline bool operator!=(const time_point&amp; lhs, const time_point&amp; rhs) {\n    return lhs.time_since_epoch() != rhs.time_since_epoch();\n}\n\nclass RelativeClock : public phonebook::service {\npublic:\n    using rep      = _clock_rep;\n    using period   = _clock_period;\n    using duration = _clock_duration;\n    // using time_point                = time_point;\n    static constexpr bool is_steady = true;\n    static_assert(std::chrono::steady_clock::is_steady);\n\n    [[nodiscard]] time_point now() const {\n        assert(this-&gt;is_started() &amp;&amp; \"Can't call now() before this clock has been start()ed.\");\n        return time_point{std::chrono::steady_clock::now() - _m_start};\n    }\n\n    int64_t absolute_ns(time_point relative) {\n        return std::chrono::nanoseconds{_m_start.time_since_epoch()}.count() +\n            std::chrono::nanoseconds{relative.time_since_epoch()}.count();\n    }\n\n    void start() {\n        _m_start = std::chrono::steady_clock::now();\n    }\n\n    [[nodiscard]] bool is_started() const {\n        return _m_start &gt; std::chrono::steady_clock::time_point{};\n    }\n\n    [[nodiscard]] time_point start_time() const {\n        return time_point{_m_start.time_since_epoch()};\n    }\n\nprivate:\n    std::chrono::steady_clock::time_point _m_start;\n};\n\nusing duration = RelativeClock::duration;\n\ntemplate&lt;typename unit = std::ratio&lt;1&gt;&gt;\ndouble duration2double(duration dur) {\n    return std::chrono::duration&lt;double, unit&gt;{dur}.count();\n}\n\nconstexpr duration freq2period(double fps) {\n    return duration{static_cast&lt;size_t&gt;(std::chrono::nanoseconds{std::chrono::seconds{1}}.count() / fps)};\n}\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/runtime_8hpp/","title":"File runtime.hpp","text":"<p>FileList &gt; illixr &gt; runtime.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"illixr/phonebook.hpp\"</code></li> <li><code>#include &lt;GL/glx.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/runtime_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/runtime_8hpp/#classes","title":"Classes","text":"Type Name class runtime <p>The documentation for this class was generated from the following file <code>include/illixr/runtime.hpp</code></p>"},{"location":"api/runtime_8hpp_source/","title":"File runtime.hpp","text":"<p>File List &gt; illixr &gt; runtime.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"illixr/phonebook.hpp\"\n\n#include &lt;GL/glx.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace ILLIXR {\nclass plugin;\n\ntypedef plugin* (*plugin_factory)(phonebook*);\n\nclass runtime {\npublic:\n    virtual void load_so(const std::vector&lt;std::string&gt;&amp; so) = 0;\n    virtual void load_so(const std::string_view&amp; so)         = 0;\n    virtual void load_plugin_factory(plugin_factory plugin)  = 0;\n\n    virtual void wait() = 0;\n\n    virtual void stop() = 0;\n\n    virtual ~runtime() = default;\n};\n\nextern \"C\" runtime* runtime_factory();\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/shader__util_8hpp/","title":"File shader_util.hpp","text":"<p>FileList &gt; illixr &gt; shader_util.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;GL/gl.h&gt;</code></li> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"api/shader__util_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr std::size_t GL_MAX_LOG_LENGTH   = <code>4096U</code>"},{"location":"api/shader__util_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void GLAPIENTRY MessageCallback (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * message, const void * userParam)  GLuint init_and_link (const char * vertex_shader, const char * fragment_shader)"},{"location":"api/shader__util_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/shader__util_8hpp/#variable-gl_max_log_length","title":"variable GL_MAX_LOG_LENGTH","text":"<pre><code>constexpr std::size_t GL_MAX_LOG_LENGTH;\n</code></pre>"},{"location":"api/shader__util_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/shader__util_8hpp/#function-messagecallback","title":"function MessageCallback","text":"<pre><code>static void GLAPIENTRY MessageCallback (\n    GLenum source,\n    GLenum type,\n    GLuint id,\n    GLenum severity,\n    GLsizei length,\n    const GLchar * message,\n    const void * userParam\n) \n</code></pre>"},{"location":"api/shader__util_8hpp/#function-init_and_link","title":"function init_and_link","text":"<pre><code>static GLuint init_and_link (\n    const char * vertex_shader,\n    const char * fragment_shader\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/shader_util.hpp</code></p>"},{"location":"api/shader__util_8hpp_source/","title":"File shader_util.hpp","text":"<p>File List &gt; illixr &gt; shader_util.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"error_util.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;cstring&gt;\n#include &lt;GL/gl.h&gt;\n#include &lt;GL/glew.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace ILLIXR;\n\nstatic constexpr std::size_t GL_MAX_LOG_LENGTH = 4096U;\n\nstatic void GLAPIENTRY MessageCallback([[maybe_unused]] GLenum source, [[maybe_unused]] GLenum type, [[maybe_unused]] GLuint id,\n                                       [[maybe_unused]] GLenum severity, [[maybe_unused]] GLsizei length,\n                                       [[maybe_unused]] const GLchar* message, [[maybe_unused]] const void* userParam) {\n#ifndef NDEBUG\n    if (severity == GL_DEBUG_SEVERITY_NOTIFICATION) {\n        return;\n    }\n    std::string type_error = (type == GL_DEBUG_TYPE_ERROR) ? \"** GL ERROR **\" : \"\";\n    spdlog::get(\"illixr\")-&gt;warn(\"[shader_util] GL CALLBACK: {} type = {:x}, severity = {:x}, message = {}\", type_error, type,\n                                severity, message);\n    // https://www.khronos.org/opengl/wiki/Debug_Output#Message_Components\n    if (severity == GL_DEBUG_SEVERITY_HIGH) {\n        ILLIXR::abort();\n    } \n#endif\n}\n\nstatic GLuint init_and_link(const char* vertex_shader, const char* fragment_shader) {\n    // GL handles for intermediary objects.\n    GLint result, vertex_shader_handle, fragment_shader_handle, shader_program;\n\n    vertex_shader_handle = glCreateShader(GL_VERTEX_SHADER);\n    auto vshader_len     = static_cast&lt;GLint&gt;(strlen(vertex_shader));\n    glShaderSource(vertex_shader_handle, 1, &amp;vertex_shader, &amp;vshader_len);\n    glCompileShader(vertex_shader_handle);\n    glGetShaderiv(vertex_shader_handle, GL_COMPILE_STATUS, &amp;result);\n    if (result == GL_FALSE) {\n        GLsizei             length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetShaderInfoLog(vertex_shader_handle, GL_MAX_LOG_LENGTH * sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get vertex_shader_handle: \" + msg);\n    }\n\n    GLint fragResult       = GL_FALSE;\n    fragment_shader_handle = glCreateShader(GL_FRAGMENT_SHADER);\n    auto fshader_len       = static_cast&lt;GLint&gt;(strlen(fragment_shader));\n    glShaderSource(fragment_shader_handle, 1, &amp;fragment_shader, &amp;fshader_len);\n    glCompileShader(fragment_shader_handle);\n    glGetShaderiv(fragment_shader_handle, GL_COMPILE_STATUS, &amp;fragResult);\n    if (fragResult == GL_FALSE) {\n        GLsizei             length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetShaderInfoLog(fragment_shader_handle, GL_MAX_LOG_LENGTH * sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get fragment_shader_handle: \" + msg);\n    }\n\n    // Create program and link shaders\n    shader_program = glCreateProgram();\n    glAttachShader(shader_program, vertex_shader_handle);\n    glAttachShader(shader_program, fragment_shader_handle);\n    const GLenum gl_err_attach = glGetError();\n    if (gl_err_attach != GL_NO_ERROR) {\n        ILLIXR::abort(\"[shader_util] AttachShader or createProgram failed\");\n    }\n\n    // Link and verify\n\n    glLinkProgram(shader_program);\n\n    const GLenum gl_err_link = glGetError();\n    if (gl_err_link != GL_NO_ERROR) {\n        ILLIXR::abort(\"[shader_util] Linking failed\");\n    }\n\n    glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;result);\n    if (result == GL_FALSE) {\n        GLsizei             length = 0;\n        std::vector&lt;GLchar&gt; gl_buf_log;\n        gl_buf_log.resize(GL_MAX_LOG_LENGTH);\n\n        glGetProgramInfoLog(shader_program, GL_MAX_LOG_LENGTH * sizeof(GLchar), &amp;length, gl_buf_log.data());\n        const std::string msg{gl_buf_log.begin(), gl_buf_log.end()};\n        assert(length == static_cast&lt;GLsizei&gt;(msg.size()) &amp;&amp; \"Length of log should match GLchar vector contents\");\n        ILLIXR::abort(\"[shader_util] Failed to get shader program: \" + msg);\n    }\n\n    // After successful link, detach shaders from shader program\n    glDetachShader(shader_program, vertex_shader_handle);\n    glDetachShader(shader_program, fragment_shader_handle);\n\n    return shader_program;\n}\n</code></pre>"},{"location":"api/stoplight_8hpp/","title":"File stoplight.hpp","text":"<p>FileList &gt; illixr &gt; stoplight.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"api/stoplight_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/stoplight_8hpp/#classes","title":"Classes","text":"Type Name class Event A boolean condition-variable. class Stoplight Start/stop synchronization for the whole application. <p>The documentation for this class was generated from the following file <code>include/illixr/stoplight.hpp</code></p>"},{"location":"api/stoplight_8hpp_source/","title":"File stoplight.hpp","text":"<p>File List &gt; illixr &gt; stoplight.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"phonebook.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;condition_variable&gt;\n#include &lt;mutex&gt;\n\nnamespace ILLIXR {\n\nclass Event {\nprivate:\n    mutable std::mutex              _m_mutex;\n    mutable std::condition_variable _m_cv;\n    std::atomic&lt;bool&gt;               _m_value = false;\n\npublic:\n    void set(bool new_value = true) {\n        {\n            std::lock_guard lock{_m_mutex};\n            _m_value = new_value;\n        }\n        if (new_value) {\n            _m_cv.notify_all();\n        }\n    }\n\n    void clear() {\n        set(false);\n    }\n\n    bool is_set() const {\n        return _m_value;\n    }\n\n    void wait() const {\n        std::unique_lock&lt;std::mutex&gt; lock{_m_mutex};\n        // Check if we even need to wait\n        if (_m_value) {\n            return;\n        }\n        _m_cv.wait(lock, [this] {\n            return _m_value.load();\n        });\n    }\n\n    template&lt;class Clock, class Rep, class Period&gt;\n    bool wait_timeout(const std::chrono::duration&lt;Rep, Period&gt;&amp; duration) const {\n        auto timeout_time = Clock::now() + duration;\n        if (_m_value) {\n            return true;\n        }\n        std::unique_lock&lt;std::mutex&gt; lock{_m_mutex};\n        while (_m_cv.wait_until(lock, timeout_time) != std::cv_status::timeout) {\n            if (_m_value) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nclass Stoplight : public phonebook::service {\npublic:\n    void wait_for_ready() const {\n        _m_ready.wait();\n    }\n\n    void signal_ready() {\n        _m_ready.set();\n    }\n\n    bool check_should_stop() const {\n        return _m_should_stop.is_set();\n    }\n\n    void signal_should_stop() {\n        _m_should_stop.set();\n    }\n\n    void wait_for_shutdown_complete() const {\n        _m_shutdown_complete.wait();\n    }\n\n    bool check_shutdown_complete() const {\n        return _m_shutdown_complete.is_set();\n    }\n\n    void signal_shutdown_complete() {\n        _m_shutdown_complete.set();\n    }\n\nprivate:\n    Event _m_ready;\n    Event _m_should_stop;\n    Event _m_shutdown_complete;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/switchboard_8hpp/","title":"File switchboard.hpp","text":"<p>FileList &gt; illixr &gt; switchboard.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include \"concurrentqueue/blockingconcurrentqueue.hpp\"</code></li> <li><code>#include \"managed_thread.hpp\"</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> </ul>"},{"location":"api/switchboard_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/switchboard_8hpp/#classes","title":"Classes","text":"Type Name class switchboard A manager for typesafe, threadsafe, named event-streams (called topics). class buffered_reader &lt;typename specific_event&gt; class event Virtual class for event types. class event_wrapper &lt;typename underlying_type&gt;Helper class for making event types. class reader &lt;typename specific_event&gt;A handle which can read the latest event on a topic. class writer &lt;typename specific_event&gt;A handle which can publish events to a topic."},{"location":"api/switchboard_8hpp/#public-static-functions","title":"Public Static Functions","text":"Type Name std::chrono::nanoseconds thread_cpu_time ()"},{"location":"api/switchboard_8hpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/switchboard_8hpp/#function-thread_cpu_time","title":"function thread_cpu_time","text":"<pre><code>static std::chrono::nanoseconds thread_cpu_time () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/illixr/switchboard.hpp</code></p>"},{"location":"api/switchboard_8hpp_source/","title":"File switchboard.hpp","text":"<p>File List &gt; illixr &gt; switchboard.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;mutex&gt;\n#include &lt;shared_mutex&gt;\n#ifndef NDEBUG\n    #include &lt;spdlog/spdlog.h&gt;\n#endif\n#if __has_include(\"cpu_timer.hpp\")\n    #include \"cpu_timer.hpp\"\n#else\nstatic std::chrono::nanoseconds thread_cpu_time() {\n    return {};\n}\n#endif\n#include \"concurrentqueue/blockingconcurrentqueue.hpp\"\n#include \"managed_thread.hpp\"\n#include \"phonebook.hpp\"\n#include \"record_logger.hpp\"\n\nnamespace ILLIXR {\n\nusing plugin_id_t = std::size_t;\n\nconst record_header __switchboard_callback_header{\n    \"switchboard_callback\",\n    {\n        {\"plugin_id\", typeid(plugin_id_t)},\n        {\"topic_name\", typeid(std::string)},\n        {\"iteration_no\", typeid(std::size_t)},\n        {\"cpu_time_start\", typeid(std::chrono::nanoseconds)},\n        {\"cpu_time_stop\", typeid(std::chrono::nanoseconds)},\n        {\"wall_time_start\", typeid(std::chrono::high_resolution_clock::time_point)},\n        {\"wall_time_stop\", typeid(std::chrono::high_resolution_clock::time_point)},\n    }};\n\nconst record_header __switchboard_topic_stop_header{\"switchboard_topic_stop\",\n                                                    {\n                                                        {\"plugin_id\", typeid(plugin_id_t)},\n                                                        {\"topic_name\", typeid(std::string)},\n                                                        {\"enqueued\", typeid(std::size_t)},\n                                                        {\"dequeued\", typeid(std::size_t)},\n                                                        {\"idle_cycles\", typeid(std::size_t)},\n                                                    }};\n\nclass switchboard : public phonebook::service {\npublic:\n    template&lt;typename specific_event&gt;\n    using ptr = std::shared_ptr&lt;specific_event&gt;;\n\n    class event {\n    public:\n        virtual ~event() = default;\n    };\n\n    template&lt;typename underlying_type&gt;\n    class event_wrapper : public event {\n    private:\n        underlying_type underlying_data;\n\n    public:\n        event_wrapper() { }\n\n        event_wrapper(underlying_type underlying_data_)\n            : underlying_data{underlying_data_} { }\n\n        operator underlying_type() const {\n            return underlying_data;\n        }\n\n        underlying_type&amp; operator*() {\n            return underlying_data;\n        }\n\n        const underlying_type&amp; operator*() const {\n            return underlying_data;\n        }\n    };\n\nprivate:\n    class topic_subscription {\n    private:\n        const std::string&amp;                                    _m_topic_name;\n        plugin_id_t                                           _m_plugin_id;\n        std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt;  _m_callback;\n        const std::shared_ptr&lt;record_logger&gt;                  _m_record_logger;\n        record_coalescer                                      _m_cb_log;\n        moodycamel::BlockingConcurrentQueue&lt;ptr&lt;const event&gt;&gt; _m_queue{8 /*max size estimate*/};\n        moodycamel::ConsumerToken                             _m_ctok{_m_queue};\n        static constexpr std::chrono::milliseconds            _m_queue_timeout{100};\n        std::size_t                                           _m_enqueued{0};\n        std::size_t                                           _m_dequeued{0};\n        std::size_t                                           _m_idle_cycles{0};\n\n        // This needs to be last,\n        // so it is destructed before the data it uses.\n        managed_thread _m_thread;\n\n        void thread_on_start() {\n#ifndef NDEBUG\n            spdlog::get(\"illixr\")-&gt;set_pattern(\"[%Y-%m-%d %H:%M:%S.%e] [%n] [%^%l%$] [switchboard] thread %t %v\");\n            spdlog::get(\"illixr\")-&gt;debug(\"start\");\n            spdlog::get(\"illixr\")-&gt;set_pattern(\"%+\");\n#endif\n        }\n\n        void thread_body() {\n            // Try to pull event off of queue\n            ptr&lt;const event&gt; this_event;\n            std::int64_t     timeout_usecs = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(_m_queue_timeout).count();\n            // Note the use of timed blocking wait\n            if (_m_queue.wait_dequeue_timed(_m_ctok, this_event, timeout_usecs)) {\n                // Process event\n                // Also, record and log the time\n                _m_dequeued++;\n                auto cb_start_cpu_time  = thread_cpu_time();\n                auto cb_start_wall_time = std::chrono::high_resolution_clock::now();\n                // std::cerr &lt;&lt; \"deq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get_ro())) &lt;&lt; \" \" &lt;&lt;\n                // this_event.use_count() &lt;&lt; \" v\\n\";\n                _m_callback(std::move(this_event), _m_dequeued);\n                if (_m_cb_log) {\n                    _m_cb_log.log(record{__switchboard_callback_header,\n                                         {\n                                             {_m_plugin_id},\n                                             {_m_topic_name},\n                                             {_m_dequeued},\n                                             {cb_start_cpu_time},\n                                             {thread_cpu_time()},\n                                             {cb_start_wall_time},\n                                             {std::chrono::high_resolution_clock::now()},\n                                         }});\n                }\n            } else {\n                // Nothing to do.\n                _m_idle_cycles++;\n            }\n        }\n\n        void thread_on_stop() {\n            // Drain queue\n            std::size_t unprocessed = _m_enqueued - _m_dequeued;\n            {\n                ptr&lt;const event&gt; this_event;\n                for (std::size_t i = 0; i &lt; unprocessed; ++i) {\n                    [[maybe_unused]] bool ret = _m_queue.try_dequeue(_m_ctok, this_event);\n                    assert(ret);\n                    // std::cerr &lt;&lt; \"deq (stopping) \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get_ro())) &lt;&lt; \" \"\n                    // &lt;&lt; this_event.use_count() &lt;&lt; \" v\\n\";\n                    this_event.reset();\n                }\n            }\n\n            // Log stats\n            if (_m_record_logger) {\n                _m_record_logger-&gt;log(record{__switchboard_topic_stop_header,\n                                             {\n                                                 {_m_plugin_id},\n                                                 {_m_topic_name},\n                                                 {_m_dequeued},\n                                                 {unprocessed},\n                                                 {_m_idle_cycles},\n                                             }});\n            }\n        }\n\n    public:\n        topic_subscription(const std::string&amp; topic_name, plugin_id_t plugin_id,\n                           std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt; callback,\n                           std::shared_ptr&lt;record_logger&gt;                       record_logger_)\n            : _m_topic_name{topic_name}\n            , _m_plugin_id{plugin_id}\n            , _m_callback{callback}\n            , _m_record_logger{record_logger_}\n            , _m_cb_log{record_logger_}\n            , _m_thread{[this] {\n                            this-&gt;thread_body();\n                        },\n                        [this] {\n                            this-&gt;thread_on_start();\n                        },\n                        [this] {\n                            this-&gt;thread_on_stop();\n                        }} {\n            _m_thread.start();\n        }\n\n        void enqueue(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            if (_m_thread.get_state() == managed_thread::state::running) {\n                [[maybe_unused]] bool ret = _m_queue.enqueue(std::move(this_event));\n                assert(ret);\n                _m_enqueued++;\n            }\n        }\n    };\n\n    class topic_buffer {\n    private:\n        moodycamel::BlockingConcurrentQueue&lt;ptr&lt;const event&gt;&gt; _m_queue{8 /*max size estimate*/};\n        moodycamel::ConsumerToken                             _m_ctok{_m_queue};\n        std::atomic&lt;size_t&gt;                                   _m_queue_size{0};\n\n    public:\n        topic_buffer() {\n#ifndef NDEBUG\n            spdlog::get(\"illixr\")-&gt;info(\"[switchboard] topic buffer created\");\n#endif\n        }\n\n        void enqueue(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            _m_queue_size++;\n            [[maybe_unused]] bool ret = _m_queue.enqueue(std::move(this_event));\n            assert(ret);\n        }\n\n        size_t size() const {\n            return _m_queue_size;\n        }\n\n        ptr&lt;const event&gt; dequeue() {\n            ptr&lt;const event&gt; obj;\n            _m_queue_size--;\n            _m_queue.wait_dequeue(_m_ctok, obj);\n            return obj;\n        }\n    };\n\n    class topic {\n    private:\n        const std::string                                   _m_name;\n        const std::type_info&amp;                               _m_ty;\n        const std::shared_ptr&lt;record_logger&gt;                _m_record_logger;\n        std::atomic&lt;size_t&gt;                                 _m_latest_index;\n        static constexpr std::size_t                        _m_latest_buffer_size = 256;\n        std::array&lt;ptr&lt;const event&gt;, _m_latest_buffer_size&gt; _m_latest_buffer;\n        std::list&lt;topic_subscription&gt;                       _m_subscriptions;\n        std::list&lt;topic_buffer&gt;                             _m_buffers;\n        std::shared_mutex                                   _m_subscriptions_lock;\n\n    public:\n        topic(std::string name, const std::type_info&amp; ty, std::shared_ptr&lt;record_logger&gt; record_logger_)\n            : _m_name{name}\n            , _m_ty{ty}\n            , _m_record_logger{record_logger_}\n            , _m_latest_index{0} { }\n\n        const std::string&amp; name() {\n            return _m_name;\n        }\n\n        const std::type_info&amp; ty() {\n            return _m_ty;\n        }\n\n        ptr&lt;const event&gt; get() const {\n            size_t           idx        = _m_latest_index.load() % _m_latest_buffer_size;\n            ptr&lt;const event&gt; this_event = _m_latest_buffer[idx];\n            // if (this_event) {\n            //  std::cerr &lt;&lt; \"get \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event.get())) &lt;&lt; \" \" &lt;&lt;\n            // this_event.use_count() &lt;&lt; \"v \\n\";\n            // }\n            return this_event;\n        }\n\n        void put(ptr&lt;const event&gt;&amp;&amp; this_event) {\n            assert(this_event != nullptr);\n            assert(this_event.unique() ||\n                   this_event.use_count() &lt;= 2); \n\n            /* The pointer that this gets exchanged with needs to get dropped. */\n            size_t index            = (_m_latest_index.load() + 1) % _m_latest_buffer_size;\n            _m_latest_buffer[index] = this_event;\n            _m_latest_index++;\n\n            // Read/write on _m_subscriptions.\n            // Must acquire shared state on _m_subscriptions_lock\n            std::unique_lock lock{_m_subscriptions_lock};\n            for (topic_subscription&amp; ts : _m_subscriptions) {\n                // std::cerr &lt;&lt; \"enq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt;\n                // this_event-&gt;use_count() &lt;&lt; \" ^\\n\";\n                ptr&lt;const event&gt; event_ptr_copy{this_event};\n                ts.enqueue(std::move(event_ptr_copy));\n            }\n\n            for (topic_buffer&amp; ts : _m_buffers) {\n                // std::cerr &lt;&lt; \"enq \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt;\n                // this_event-&gt;use_count() &lt;&lt; \" ^\\n\";\n                ptr&lt;const event&gt; event_ptr_copy{this_event};\n                ts.enqueue(std::move(event_ptr_copy));\n            }\n            // std::cerr &lt;&lt; \"put done \" &lt;&lt; ptr_to_str(reinterpret_cast&lt;const void*&gt;(this_event-&gt;get())) &lt;&lt; \" \" &lt;&lt;\n            // this_event-&gt;use_count() &lt;&lt; \" (= 1 + len(sub)) \\n\";\n        }\n\n        void schedule(plugin_id_t plugin_id, std::function&lt;void(ptr&lt;const event&gt;&amp;&amp;, std::size_t)&gt; callback) {\n            // Write on _m_subscriptions.\n            // Must acquire unique state on _m_subscriptions_lock\n            const std::unique_lock lock{_m_subscriptions_lock};\n            _m_subscriptions.emplace_back(_m_name, plugin_id, callback, _m_record_logger);\n        }\n\n        topic_buffer&amp; get_buffer() {\n            const std::unique_lock lock{_m_subscriptions_lock};\n            _m_buffers.emplace_back();\n            return _m_buffers.back();\n        }\n\n        void stop() {\n            // Write on _m_subscriptions.\n            // Must acquire unique state on _m_subscriptions_lock\n            const std::unique_lock lock{_m_subscriptions_lock};\n            _m_subscriptions.clear();\n        }\n    };\n\npublic:\n    template&lt;typename specific_event&gt;\n    class reader {\n    private:\n        topic&amp; _m_topic;\n\n    public:\n        reader(topic&amp; topic_)\n            : _m_topic{topic_} {\n#ifndef NDEBUG\n            if (typeid(specific_event) != _m_topic.ty()) {\n                spdlog::get(\"illixr\")-&gt;error(\"[switchboard] topic '{}' holds type {}, but caller used type {}\", _m_topic.name(),\n                                             _m_topic.ty().name(), typeid(specific_event).name());\n                abort();\n            }\n#endif\n        }\n\n        ptr&lt;const specific_event&gt; get_ro_nullable() const noexcept {\n            ptr&lt;const event&gt;          this_event          = _m_topic.get();\n            ptr&lt;const specific_event&gt; this_specific_event = std::dynamic_pointer_cast&lt;const specific_event&gt;(this_event);\n\n            if (this_event != nullptr) {\n                assert(this_specific_event /* Otherwise, dynamic cast failed; dynamic type information could be wrong*/);\n                return this_specific_event;\n            } else {\n                return ptr&lt;const specific_event&gt;{nullptr};\n            }\n        }\n\n        ptr&lt;const specific_event&gt; get_ro() const {\n            ptr&lt;const specific_event&gt; this_specific_event = get_ro_nullable();\n            if (this_specific_event != nullptr) {\n                return this_specific_event;\n            } else {\n                throw std::runtime_error(\"No event on topic\");\n            }\n        }\n\n        ptr&lt;specific_event&gt; get_rw() const {\n            /*\n              This method is currently not more efficient than calling get_ro() and making a copy,\n              but in the future it could be.\n             */\n            ptr&lt;const specific_event&gt; this_specific_event = get_ro();\n            return std::make_shared&lt;specific_event&gt;(*this_specific_event);\n        }\n    };\n\n    template&lt;typename specific_event&gt;\n    class buffered_reader {\n    private:\n        topic&amp;        _m_topic;\n        size_t        serial_no = 0;\n        topic_buffer&amp; _m_tb;\n\n    public:\n        buffered_reader(topic&amp; topic)\n            : _m_topic{topic}\n            , _m_tb{_m_topic.get_buffer()} { }\n\n        size_t size() const {\n            return _m_tb.size();\n        }\n\n        ptr&lt;const specific_event&gt; dequeue() {\n            // CPU_TIMER_TIME_EVENT_INFO(true, false, \"callback\", cpu_timer::make_type_eraser&lt;FrameInfo&gt;(\"\", _m_topic.name(),\n            // serial_no));\n            serial_no++;\n            ptr&lt;const event&gt;          this_event          = _m_tb.dequeue();\n            ptr&lt;const specific_event&gt; this_specific_event = std::dynamic_pointer_cast&lt;const specific_event&gt;(this_event);\n            return this_specific_event;\n        }\n    };\n\n    template&lt;typename specific_event&gt;\n    class writer {\n    private:\n        // Reference to the underlying topic\n        topic&amp; _m_topic;\n\n    public:\n        writer(topic&amp; topic_)\n            : _m_topic{topic_} { }\n\n        template&lt;class... Args&gt;\n        ptr&lt;specific_event&gt; allocate(Args&amp;&amp;... args) {\n            return std::make_shared&lt;specific_event&gt;(std::forward&lt;Args&gt;(args)...);\n        }\n\n        void put(ptr&lt;specific_event&gt;&amp;&amp; this_specific_event) {\n            assert(typeid(specific_event) == _m_topic.ty());\n            assert(this_specific_event != nullptr);\n            assert(this_specific_event.unique());\n            ptr&lt;const event&gt; this_event =\n                std::const_pointer_cast&lt;const event&gt;(std::static_pointer_cast&lt;event&gt;(std::move(this_specific_event)));\n            assert(this_event.unique() ||\n                   this_event.use_count() &lt;= 2); \n            _m_topic.put(std::move(this_event));\n        }\n    };\n\nprivate:\n    std::unordered_map&lt;std::string, topic&gt; _m_registry;\n    std::shared_mutex                      _m_registry_lock;\n    std::shared_ptr&lt;record_logger&gt;         _m_record_logger;\n\n    template&lt;typename specific_event&gt;\n    topic&amp; try_register_topic(const std::string&amp; topic_name) {\n        {\n            const std::shared_lock lock{_m_registry_lock};\n            auto                   found = _m_registry.find(topic_name);\n            if (found != _m_registry.end()) {\n                topic&amp; topic_ = found-&gt;second;\n#ifndef NDEBUG\n                if (typeid(specific_event) != topic_.ty()) {\n                    spdlog::get(\"illixr\")-&gt;error(\"[switchboard] topic '{}' holds type {}, but caller used type {}\", topic_name,\n                                                 topic_.ty().name(), typeid(specific_event).name());\n                    abort();\n                }\n#endif\n                return topic_;\n            }\n        }\n\n#ifndef NDEBUG\n        spdlog::get(\"illixr\")-&gt;debug(\"[switchboard] Creating: {} for {}\", topic_name, typeid(specific_event).name());\n#endif\n        // Topic not found. Need to create it here.\n        const std::unique_lock lock{_m_registry_lock};\n        return _m_registry.try_emplace(topic_name, topic_name, typeid(specific_event), _m_record_logger).first-&gt;second;\n    }\n\npublic:\n    switchboard(const phonebook* pb)\n        : _m_record_logger{pb ? pb-&gt;lookup_impl&lt;record_logger&gt;() : nullptr} { }\n\n    template&lt;typename specific_event&gt;\n    void schedule(plugin_id_t plugin_id, std::string topic_name,\n                  std::function&lt;void(ptr&lt;const specific_event&gt;&amp;&amp;, std::size_t)&gt; fn) {\n        try_register_topic&lt;specific_event&gt;(topic_name)\n            .schedule(plugin_id, [=](ptr&lt;const event&gt;&amp;&amp; this_event, std::size_t it_no) {\n                assert(this_event);\n                ptr&lt;const specific_event&gt; this_specific_event =\n                    std::dynamic_pointer_cast&lt;const specific_event&gt;(std::move(this_event));\n                assert(this_specific_event);\n                fn(std::move(this_specific_event), it_no);\n            });\n    }\n\n    template&lt;typename specific_event&gt;\n    writer&lt;specific_event&gt; get_writer(const std::string&amp; topic_name) {\n        return writer&lt;specific_event&gt;{try_register_topic&lt;specific_event&gt;(topic_name)};\n    }\n\n    template&lt;typename specific_event&gt;\n    reader&lt;specific_event&gt; get_reader(const std::string&amp; topic_name) {\n        return reader&lt;specific_event&gt;{try_register_topic&lt;specific_event&gt;(topic_name)};\n    }\n\n    template&lt;typename specific_event&gt;\n    buffered_reader&lt;specific_event&gt; get_buffered_reader(const std::string&amp; topic_name) {\n        return buffered_reader&lt;specific_event&gt;{try_register_topic&lt;specific_event&gt;(topic_name)};\n    }\n\n    void stop() {\n        const std::shared_lock lock{_m_registry_lock};\n        for (auto&amp; pair : _m_registry) {\n            pair.second.stop();\n        }\n    }\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/threadloop_8hpp/","title":"File threadloop.hpp","text":"<p>FileList &gt; illixr &gt; threadloop.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cpu_timer.hpp\"</code></li> <li><code>#include \"error_util.hpp\"</code></li> <li><code>#include \"phonebook.hpp\"</code></li> <li><code>#include \"plugin.hpp\"</code></li> <li><code>#include \"record_logger.hpp\"</code></li> <li><code>#include \"stoplight.hpp\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"api/threadloop_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ILLIXR RAC_ERRNO_MSG."},{"location":"api/threadloop_8hpp/#classes","title":"Classes","text":"Type Name class threadloop A reusable threadloop for plugins. <p>The documentation for this class was generated from the following file <code>include/illixr/threadloop.hpp</code></p>"},{"location":"api/threadloop_8hpp_source/","title":"File threadloop.hpp","text":"<p>File List &gt; illixr &gt; threadloop.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"cpu_timer.hpp\"\n#include \"error_util.hpp\"\n#include \"phonebook.hpp\"\n#include \"plugin.hpp\"\n#include \"record_logger.hpp\"\n#include \"stoplight.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n\nnamespace ILLIXR {\n\nconst record_header __threadloop_iteration_header{\n    \"threadloop_iteration\",\n    {\n        {\"plugin_id\", typeid(std::size_t)},\n        {\"iteration_no\", typeid(std::size_t)},\n        {\"skips\", typeid(std::size_t)},\n        {\"cpu_time_start\", typeid(std::chrono::nanoseconds)},\n        {\"cpu_time_stop\", typeid(std::chrono::nanoseconds)},\n        {\"wall_time_start\", typeid(std::chrono::high_resolution_clock::time_point)},\n        {\"wall_time_stop\", typeid(std::chrono::high_resolution_clock::time_point)},\n    }};\n\nclass threadloop : public plugin {\npublic:\n    threadloop(const std::string&amp; name_, phonebook* pb_)\n        : plugin{name_, pb_}\n        , _m_stoplight{pb-&gt;lookup_impl&lt;Stoplight&gt;()} { }\n\n    void start() override {\n        plugin::start();\n        _m_thread = std::thread(std::bind(&amp;threadloop::thread_main, this));\n        assert(!_m_stoplight-&gt;check_should_stop());\n        assert(_m_thread.joinable());\n    }\n\n    void stop() override {\n        assert(_m_stoplight-&gt;check_should_stop());\n        assert(_m_thread.joinable());\n        _m_thread.join();\n    }\n\n    virtual void internal_stop() {\n        _m_internal_stop.store(true);\n    }\n\n    ~threadloop() override {\n        assert(_m_stoplight-&gt;check_should_stop());\n        assert(!_m_thread.joinable());\n    }\n\nprotected:\n    std::size_t iteration_no = 0;\n    std::size_t skip_no      = 0;\n\nprivate:\n    void thread_main() {\n        record_coalescer it_log{record_logger_};\n\n        // TODO: In the future, synchronize the main loop instead of the setup.\n        // This is currently not possible because RelativeClock is required in\n        // some setup functions, and RelativeClock is only guaranteed to be\n        // available once `wait_for_ready()` unblocks.\n        _m_stoplight-&gt;wait_for_ready();\n        _p_thread_setup();\n\n        while (!_m_stoplight-&gt;check_should_stop() &amp;&amp; !should_terminate()) {\n            skip_option s = _p_should_skip();\n\n            switch (s) {\n            case skip_option::skip_and_yield:\n                std::this_thread::yield();\n                ++skip_no;\n                break;\n            case skip_option::skip_and_spin:\n                ++skip_no;\n                break;\n            case skip_option::run: {\n                auto iteration_start_cpu_time  = thread_cpu_time();\n                auto iteration_start_wall_time = std::chrono::high_resolution_clock::now();\n\n                RAC_ERRNO();\n                _p_one_iteration();\n                RAC_ERRNO();\n\n                it_log.log(record{__threadloop_iteration_header,\n                                  {\n                                      {id},\n                                      {iteration_no},\n                                      {skip_no},\n                                      {iteration_start_cpu_time},\n                                      {thread_cpu_time()},\n                                      {iteration_start_wall_time},\n                                      {std::chrono::high_resolution_clock::now()},\n                                  }});\n                ++iteration_no;\n                skip_no = 0;\n                break;\n            }\n            case skip_option::stop:\n                // Break out of the switch AND the loop\n                // See https://stackoverflow.com/questions/27788326/breaking-out-of-nested-loop-c\n                goto break_loop;\n            }\n        }\n    break_loop:\n        [[maybe_unused]] int cpp_requires_a_statement_after_a_label_plz_optimize_me_away;\n    }\n\nprotected:\n    enum class skip_option {\n        run,\n\n        skip_and_spin,\n\n        skip_and_yield,\n\n        stop,\n    };\n\n    virtual skip_option _p_should_skip() {\n        return skip_option::run;\n    }\n\n    virtual void _p_thread_setup() { }\n\n    virtual void _p_one_iteration() = 0;\n\n    bool should_terminate() {\n        return _m_internal_stop.load();\n    }\n\nprivate:\n    std::atomic&lt;bool&gt;                _m_internal_stop{false};\n    std::thread                      _m_thread;\n    std::shared_ptr&lt;const Stoplight&gt; _m_stoplight;\n};\n\n} // namespace ILLIXR\n</code></pre>"},{"location":"api/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace ILLIXR RAC_ERRNO_MSG. <ul> <li>namespace math_util </li> </ul> </li> </ul>"},{"location":"api/classes/","title":"Class Index","text":""},{"location":"api/classes/#b","title":"b","text":"<ul> <li>buffered_reader (ILLIXR::switchboard)</li> </ul>"},{"location":"api/classes/#c","title":"c","text":"<ul> <li>cam_type (ILLIXR)</li> <li>connection_signal (ILLIXR)</li> <li>CSVIterator</li> <li>CSVRow</li> </ul>"},{"location":"api/classes/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR)</li> <li>display_params (ILLIXR)</li> <li>dynamic_lib (ILLIXR)</li> </ul>"},{"location":"api/classes/#e","title":"e","text":"<ul> <li>Event (ILLIXR)</li> <li>event (ILLIXR::switchboard)</li> <li>event_wrapper (ILLIXR::switchboard)</li> </ul>"},{"location":"api/classes/#f","title":"f","text":"<ul> <li>fast_pose_type (ILLIXR)</li> </ul>"},{"location":"api/classes/#g","title":"g","text":"<ul> <li>gen_guid (ILLIXR)</li> </ul>"},{"location":"api/classes/#h","title":"h","text":"<ul> <li>hmd_physical_info (ILLIXR)</li> <li>hologram_input (ILLIXR)</li> </ul>"},{"location":"api/classes/#i","title":"i","text":"<ul> <li>image_handle (ILLIXR)</li> <li>imu_integrator_input (ILLIXR)</li> <li>imu_params (ILLIXR)</li> <li>imu_raw_type (ILLIXR)</li> <li>imu_type (ILLIXR)</li> </ul>"},{"location":"api/classes/#m","title":"m","text":"<ul> <li>managed_thread (ILLIXR)</li> </ul>"},{"location":"api/classes/#p","title":"p","text":"<ul> <li>phonebook (ILLIXR)</li> <li>plugin (ILLIXR)</li> <li>pose_prediction</li> <li>pose_type (ILLIXR)</li> <li>print_in_destructor</li> <li>print_timer</li> <li>print_timer2</li> </ul>"},{"location":"api/classes/#r","title":"r","text":"<ul> <li>reader (ILLIXR::switchboard)</li> <li>record (ILLIXR)</li> <li>record_coalescer (ILLIXR)</li> <li>record_header (ILLIXR)</li> <li>record_logger (ILLIXR)</li> <li>RelativeClock (ILLIXR)</li> <li>rendered_frame (ILLIXR)</li> <li>rendering_params (ILLIXR)</li> <li>rgb_depth_type (ILLIXR)</li> <li>runtime (ILLIXR)</li> </ul>"},{"location":"api/classes/#s","title":"s","text":"<ul> <li>service (ILLIXR::phonebook)</li> <li>should_profile_class</li> <li>signal_to_quad (ILLIXR)</li> <li>Stoplight (ILLIXR)</li> <li>switchboard (ILLIXR)</li> </ul>"},{"location":"api/classes/#t","title":"t","text":"<ul> <li>texture_pose (ILLIXR)</li> <li>threadloop (ILLIXR)</li> <li>time_point (ILLIXR)</li> <li>timer</li> <li>topic</li> <li>topic_buffer</li> <li>topic_subscription</li> </ul>"},{"location":"api/classes/#v","title":"v","text":"<ul> <li>vk_image_handle (ILLIXR)</li> </ul>"},{"location":"api/classes/#w","title":"w","text":"<ul> <li>writer (ILLIXR::switchboard)</li> </ul>"},{"location":"api/classes/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR)</li> </ul>"},{"location":"api/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class CSVIterator </li> <li>class CSVRow </li> <li>class ILLIXR::Event A boolean condition-variable. </li> <li>class ILLIXR::phonebook::service A 'service' that can be registered in the phonebook. <ul> <li>class ILLIXR::RelativeClock Relative clock for all of ILLIXR .</li> <li>class ILLIXR::Stoplight Start/stop synchronization for the whole application. </li> <li>class ILLIXR::gen_guid This class generates unique IDs. </li> <li>class ILLIXR::record_logger The ILLIXR logging service for structured records.</li> <li>class ILLIXR::switchboard A manager for typesafe, threadsafe, named event-streams (called topics). </li> <li>class ILLIXR::xlib_gl_extended_window </li> <li>class pose_prediction </li> </ul> </li> <li>class ILLIXR::data_use_indicator A helper class that lets one dynamically determine if some data gets used. </li> <li>class ILLIXR::dynamic_lib </li> <li>class ILLIXR::managed_thread An object that manages a std::thread; it joins and exits when the object gets destructed. </li> <li>class ILLIXR::phonebook A service locator forILLIXR .</li> <li>class ILLIXR::plugin A dynamically-loadable plugin for Spindle. <ul> <li>class ILLIXR::threadloop A reusable threadloop for plugins. </li> </ul> </li> <li>class ILLIXR::record This class represents a tuple of fields which get logged by <code>record_logger</code> .</li> <li>class ILLIXR::record_coalescer Coalesces logs of the same type to be written back as a single-transaction. </li> <li>class ILLIXR::record_header Schema of each record. </li> <li>class ILLIXR::runtime </li> <li>class ILLIXR::switchboard::buffered_reader </li> <li>class ILLIXR::switchboard::event Virtual class for event types. <ul> <li>struct ILLIXR::cam_type </li> <li>struct ILLIXR::connection_signal </li> <li>struct ILLIXR::hologram_input </li> <li>struct ILLIXR::image_handle </li> <li>struct ILLIXR::imu_integrator_input </li> <li>struct ILLIXR::imu_raw_type </li> <li>struct ILLIXR::imu_type </li> <li>struct ILLIXR::pose_type </li> <li>struct ILLIXR::rendered_frame </li> <li>struct ILLIXR::rgb_depth_type </li> <li>struct ILLIXR::signal_to_quad </li> <li>class ILLIXR::switchboard::event_wrapper Helper class for making event types. </li> <li>struct ILLIXR::texture_pose </li> </ul> </li> <li>class ILLIXR::switchboard::reader A handle which can read the latest event on a topic. </li> <li>class ILLIXR::switchboard::writer A handle which can publish events to a topic. </li> <li>class ILLIXR::time_point </li> <li>class ILLIXR::switchboard::topic Represents a topic. </li> <li>class ILLIXR::switchboard::topic_buffer </li> <li>class ILLIXR::switchboard::topic_subscription Represents a single topic_subscription (callback and queue) </li> <li>class print_timer Like timer, but prints the output. </li> <li>class print_timer2 </li> <li>class print_timer::print_in_destructor </li> <li>class should_profile_class </li> <li>class timer a timer that times until the end of the code block ([RAII]). </li> <li>struct ILLIXR::display_params Display parameters. </li> <li>struct ILLIXR::fast_pose_type </li> <li>struct ILLIXR::hmd_physical_info </li> <li>struct ILLIXR::imu_params </li> <li>struct ILLIXR::rendering_params Rendering parameters. </li> <li>struct ILLIXR::vk_image_handle </li> </ul>"},{"location":"api/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"api/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"api/class_members/","title":"Class Members","text":""},{"location":"api/class_members/#a","title":"a","text":"<ul> <li>absolute_ns (ILLIXR::RelativeClock)</li> <li>aberration (ILLIXR::display_params)</li> <li>acc_noise (ILLIXR::imu_params)</li> <li>acc_walk (ILLIXR::imu_params)</li> <li>a_hat (ILLIXR::imu_raw_type)</li> <li>a_hat2 (ILLIXR::imu_raw_type)</li> <li>angular_v (ILLIXR::imu_type)</li> <li>allocate (ILLIXR::switchboard::writer)</li> <li>allocation_size (ILLIXR::vk_image_handle)</li> <li>actually_should_profile (should_profile_class)</li> </ul>"},{"location":"api/class_members/#b","title":"b","text":"<ul> <li>biasAcc (ILLIXR::imu_integrator_input)</li> <li>biasGyro (ILLIXR::imu_integrator_input)</li> <li>buffer (ILLIXR::record_coalescer)</li> <li>buffered_reader (ILLIXR::switchboard::buffered_reader)</li> </ul>"},{"location":"api/class_members/#c","title":"c","text":"<ul> <li>CSVIterator (CSVIterator)</li> <li>clear (ILLIXR::Event)</li> <li>check_should_stop (ILLIXR::Stoplight)</li> <li>check_shutdown_complete (ILLIXR::Stoplight)</li> <li>cam_type (ILLIXR::cam_type)</li> <li>connection_signal (ILLIXR::connection_signal)</li> <li>create (ILLIXR::dynamic_lib)</li> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>columns (ILLIXR::record_header)</li> <li>correct_pose (pose_prediction)</li> <li>cpu_time_start (print_timer2)</li> </ul>"},{"location":"api/class_members/#d","title":"d","text":"<ul> <li>difference_type (CSVIterator)</li> <li>duration (ILLIXR::RelativeClock, ILLIXR::time_point)</li> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>depth (ILLIXR::rgb_depth_type)</li> <li>dequeue (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#e","title":"e","text":"<ul> <li>event_wrapper (ILLIXR::switchboard::event_wrapper)</li> <li>enqueue (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> </ul>"},{"location":"api/class_members/#f","title":"f","text":"<ul> <li>fov_x (ILLIXR::display_params)</li> <li>fov_y (ILLIXR::display_params)</li> <li>frequency (ILLIXR::display_params)</li> <li>flush (ILLIXR::record_coalescer)</li> <li>far_z (ILLIXR::rendering_params)</li> <li>file_descriptor (ILLIXR::vk_image_handle)</li> <li>format (ILLIXR::vk_image_handle)</li> <li>fast_pose_reliable (pose_prediction)</li> </ul>"},{"location":"api/class_members/#g","title":"g","text":"<ul> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid, ILLIXR::switchboard::topic)</li> <li>guid_starts (ILLIXR::gen_guid)</li> <li>gl_handle (ILLIXR::image_handle)</li> <li>gyro_noise (ILLIXR::imu_params)</li> <li>gyro_walk (ILLIXR::imu_params)</li> <li>get_state (ILLIXR::managed_thread)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>get_ro (ILLIXR::switchboard::reader)</li> <li>get_ro_nullable (ILLIXR::switchboard::reader)</li> <li>get_rw (ILLIXR::switchboard::reader)</li> <li>get_buffered_reader (ILLIXR::switchboard)</li> <li>get_reader (ILLIXR::switchboard)</li> <li>get_writer (ILLIXR::switchboard)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> <li>get_buffer (ILLIXR::switchboard::topic)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_offset (pose_prediction)</li> <li>get_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_members/#h","title":"h","text":"<ul> <li>height_meters (ILLIXR::display_params)</li> <li>height_pixels (ILLIXR::display_params)</li> <li>hologram_input (ILLIXR::hologram_input)</li> <li>height (ILLIXR::vk_image_handle, ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#i","title":"i","text":"<ul> <li>iterator_category (CSVIterator)</li> <li>is_set (ILLIXR::Event)</li> <li>is_started (ILLIXR::RelativeClock)</li> <li>is_steady (ILLIXR::RelativeClock)</li> <li>img0 (ILLIXR::cam_type)</li> <li>img1 (ILLIXR::cam_type)</li> <li>is_used (ILLIXR::data_use_indicator)</li> <li>ipd (ILLIXR::display_params, ILLIXR::hmd_physical_info)</li> <li>image_handle (ILLIXR::image_handle)</li> <li>imu_integrator_input (ILLIXR::imu_integrator_input)</li> <li>imu_integration_sigma (ILLIXR::imu_params)</li> <li>imu_raw_type (ILLIXR::imu_raw_type)</li> <li>imu_time (ILLIXR::imu_raw_type)</li> <li>imu_type (ILLIXR::imu_type)</li> <li>id (ILLIXR::plugin, ILLIXR::record_header)</li> <li>image (ILLIXR::texture_pose)</li> <li>internal_stop (ILLIXR::threadloop)</li> <li>iteration_no (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_members/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_members/#l","title":"l","text":"<ul> <li>lens_separation (ILLIXR::display_params)</li> <li>lens_vertical_position (ILLIXR::display_params)</li> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>last_cam_integration_time (ILLIXR::imu_integrator_input)</li> <li>linear_a (ILLIXR::imu_type)</li> <li>lookup_impl (ILLIXR::phonebook)</li> <li>last_log (ILLIXR::record_coalescer)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger)</li> <li>logger (ILLIXR::record_coalescer)</li> <li>load_plugin_factory (ILLIXR::runtime)</li> <li>load_so (ILLIXR::runtime)</li> <li>latest_quaternion (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_members/#m","title":"m","text":"<ul> <li>m_row (CSVIterator)</li> <li>m_str (CSVIterator)</li> <li>m_data (CSVRow)</li> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>meters_per_tan_angle (ILLIXR::display_params)</li> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> <li>managed_thread (ILLIXR::managed_thread)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> </ul>"},{"location":"api/class_members/#n","title":"n","text":"<ul> <li>now (ILLIXR::RelativeClock)</li> <li>num_images (ILLIXR::image_handle)</li> <li>n_gravity (ILLIXR::imu_params)</li> <li>nominal_rate (ILLIXR::imu_params)</li> <li>name (ILLIXR::plugin, ILLIXR::record_header, ILLIXR::switchboard::topic, print_timer2)</li> <li>near_z (ILLIXR::rendering_params)</li> </ul>"},{"location":"api/class_members/#o","title":"o","text":"<ul> <li>operator!= (CSVIterator, ILLIXR::record_header)</li> <li>operator* (CSVIterator, ILLIXR::switchboard::event_wrapper)</li> <li>operator++ (CSVIterator)</li> <li>operator+= (CSVIterator, ILLIXR::time_point)</li> <li>operator-&gt; (CSVIterator)</li> <li>operator== (CSVIterator, ILLIXR::record_header)</li> <li>operator[] (CSVIterator, CSVRow, ILLIXR::dynamic_lib)</li> <li>operator= (ILLIXR::data_use_indicator, ILLIXR::dynamic_lib)</li> <li>orientation (ILLIXR::pose_type)</li> <li>operator bool (ILLIXR::record_coalescer)</li> <li>operator underlying_type (ILLIXR::switchboard::event_wrapper)</li> <li>offload_duration (ILLIXR::texture_pose)</li> <li>operator-= (ILLIXR::time_point)</li> <li>operator() (should_profile_class)</li> </ul>"},{"location":"api/class_members/#p","title":"p","text":"<ul> <li>pointer (CSVIterator)</li> <li>period (ILLIXR::RelativeClock, ILLIXR::display_params)</li> <li>pose (ILLIXR::fast_pose_type)</li> <li>predict_computed_time (ILLIXR::fast_pose_type)</li> <li>predict_target_time (ILLIXR::fast_pose_type)</li> <li>params (ILLIXR::imu_integrator_input)</li> <li>position (ILLIXR::imu_integrator_input, ILLIXR::pose_type, ILLIXR::texture_pose)</li> <li>pos (ILLIXR::imu_raw_type)</li> <li>pb (ILLIXR::plugin)</li> <li>plugin (ILLIXR::plugin)</li> <li>pose_type (ILLIXR::pose_type)</li> <li>put (ILLIXR::switchboard::writer, ILLIXR::switchboard::topic)</li> <li>ptr (ILLIXR::switchboard)</li> <li>pose_time (ILLIXR::texture_pose)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> </ul>"},{"location":"api/class_members/#q","title":"q","text":"<ul> <li>quat (ILLIXR::imu_integrator_input, ILLIXR::imu_raw_type)</li> </ul>"},{"location":"api/class_members/#r","title":"r","text":"<ul> <li>reference (CSVIterator)</li> <li>readNextRow (CSVRow)</li> <li>rep (ILLIXR::RelativeClock)</li> <li>register_impl (ILLIXR::phonebook)</li> <li>record_logger_ (ILLIXR::plugin)</li> <li>record (ILLIXR::record)</li> <li>rh (ILLIXR::record)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>render_pose (ILLIXR::rendered_frame)</li> <li>render_time (ILLIXR::rendered_frame)</li> <li>rendered_frame (ILLIXR::rendered_frame)</li> <li>rgb (ILLIXR::rgb_depth_type)</li> <li>rgb_depth_type (ILLIXR::rgb_depth_type)</li> <li>reader (ILLIXR::switchboard::reader)</li> <li>render_quaternion (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_members/#s","title":"s","text":"<ul> <li>size (CSVRow, ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer)</li> <li>set (ILLIXR::Event)</li> <li>start (ILLIXR::RelativeClock, ILLIXR::connection_signal, ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::threadloop)</li> <li>start_time (ILLIXR::RelativeClock)</li> <li>signal_ready (ILLIXR::Stoplight)</li> <li>signal_should_stop (ILLIXR::Stoplight)</li> <li>signal_shutdown_complete (ILLIXR::Stoplight)</li> <li>seq (ILLIXR::hologram_input, ILLIXR::signal_to_quad)</li> <li>state (ILLIXR::managed_thread)</li> <li>stop (ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::threadloop, ILLIXR::switchboard::topic)</li> <li>spdlogger (ILLIXR::plugin)</li> <li>sensor_time (ILLIXR::pose_type)</li> <li>sample_time (ILLIXR::rendered_frame)</li> <li>swap_indices (ILLIXR::rendered_frame)</li> <li>swapchain_indices (ILLIXR::rendered_frame)</li> <li>signal_to_quad (ILLIXR::signal_to_quad)</li> <li>serial_no (ILLIXR::switchboard::buffered_reader, print_timer2)</li> <li>schedule (ILLIXR::switchboard, ILLIXR::switchboard::topic)</li> <li>switchboard (ILLIXR::switchboard)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>skip_no (ILLIXR::threadloop)</li> <li>skip_option (ILLIXR::threadloop)</li> <li>set_offset (pose_prediction)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_members/#t","title":"t","text":"<ul> <li>time (ILLIXR::cam_type, ILLIXR::imu_type, ILLIXR::rgb_depth_type)</li> <li>type (ILLIXR::image_handle)</li> <li>t_offset (ILLIXR::imu_integrator_input)</li> <li>thread_main (ILLIXR::managed_thread, ILLIXR::threadloop)</li> <li>to_string (ILLIXR::record_header)</li> <li>try_register_topic (ILLIXR::switchboard)</li> <li>texture_pose (ILLIXR::texture_pose)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>time_point (ILLIXR::time_point)</li> <li>time_since_epoch (ILLIXR::time_point)</li> <li>topic (ILLIXR::switchboard::topic)</li> <li>ty (ILLIXR::switchboard::topic)</li> <li>topic_buffer (ILLIXR::switchboard::topic_buffer)</li> <li>thread_body (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_start (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_stop (ILLIXR::switchboard::topic_subscription)</li> <li>topic_subscription (ILLIXR::switchboard::topic_subscription)</li> <li>true_pose_reliable (pose_prediction)</li> <li>timer (timer)</li> </ul>"},{"location":"api/class_members/#u","title":"u","text":"<ul> <li>used (ILLIXR::data_use_indicator)</li> <li>usage (ILLIXR::image_handle)</li> <li>underlying_data (ILLIXR::switchboard::event_wrapper)</li> </ul>"},{"location":"api/class_members/#v","title":"v","text":"<ul> <li>value_type (CSVIterator)</li> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> <li>vk_handle (ILLIXR::image_handle)</li> <li>velocity (ILLIXR::imu_integrator_input)</li> <li>vel (ILLIXR::imu_raw_type)</li> <li>values (ILLIXR::record)</li> <li>vk_image_handle (ILLIXR::vk_image_handle)</li> </ul>"},{"location":"api/class_members/#w","title":"w","text":"<ul> <li>wait (ILLIXR::Event, ILLIXR::runtime)</li> <li>wait_timeout (ILLIXR::Event)</li> <li>wait_for_ready (ILLIXR::Stoplight)</li> <li>wait_for_shutdown_complete (ILLIXR::Stoplight)</li> <li>width_meters (ILLIXR::display_params)</li> <li>width_pixels (ILLIXR::display_params)</li> <li>w_hat (ILLIXR::imu_raw_type)</li> <li>w_hat2 (ILLIXR::imu_raw_type)</li> <li>writer (ILLIXR::switchboard::writer)</li> <li>width (ILLIXR::vk_image_handle, ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>wall_time_start (print_timer2)</li> </ul>"},{"location":"api/class_members/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_members/#_1","title":"~","text":"<ul> <li>~dynamic_lib (ILLIXR::dynamic_lib)</li> <li>~managed_thread (ILLIXR::managed_thread)</li> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~event (ILLIXR::switchboard::event)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>~pose_prediction (pose_prediction)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_members/#_","title":"_","text":"<ul> <li>_m_cv (ILLIXR::Event)</li> <li>_m_mutex (ILLIXR::Event, ILLIXR::phonebook)</li> <li>_m_value (ILLIXR::Event)</li> <li>_m_start (ILLIXR::RelativeClock)</li> <li>_m_ready (ILLIXR::Stoplight)</li> <li>_m_should_stop (ILLIXR::Stoplight)</li> <li>_m_shutdown_complete (ILLIXR::Stoplight)</li> <li>_m_handle (ILLIXR::dynamic_lib)</li> <li>_m_lib_path (ILLIXR::dynamic_lib)</li> <li>_m_body (ILLIXR::managed_thread)</li> <li>_m_on_start (ILLIXR::managed_thread)</li> <li>_m_on_stop (ILLIXR::managed_thread)</li> <li>_m_stop (ILLIXR::managed_thread)</li> <li>_m_thread (ILLIXR::managed_thread, ILLIXR::threadloop, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry (ILLIXR::phonebook, ILLIXR::switchboard)</li> <li>_m_tb (ILLIXR::switchboard::buffered_reader)</li> <li>_m_topic (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::reader, ILLIXR::switchboard::writer)</li> <li>_m_record_logger (ILLIXR::switchboard, ILLIXR::switchboard::topic, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry_lock (ILLIXR::switchboard)</li> <li>_m_internal_stop (ILLIXR::threadloop)</li> <li>_m_stoplight (ILLIXR::threadloop)</li> <li>_p_one_iteration (ILLIXR::threadloop)</li> <li>_p_should_skip (ILLIXR::threadloop)</li> <li>_p_thread_setup (ILLIXR::threadloop)</li> <li>_m_time_since_epoch (ILLIXR::time_point)</li> <li>_m_cmap (ILLIXR::xlib_gl_extended_window)</li> <li>_m_buffers (ILLIXR::switchboard::topic)</li> <li>_m_latest_buffer (ILLIXR::switchboard::topic)</li> <li>_m_latest_buffer_size (ILLIXR::switchboard::topic)</li> <li>_m_latest_index (ILLIXR::switchboard::topic)</li> <li>_m_name (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions_lock (ILLIXR::switchboard::topic)</li> <li>_m_ty (ILLIXR::switchboard::topic)</li> <li>_m_ctok (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue_size (ILLIXR::switchboard::topic_buffer)</li> <li>_m_callback (ILLIXR::switchboard::topic_subscription)</li> <li>_m_cb_log (ILLIXR::switchboard::topic_subscription)</li> <li>_m_dequeued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_enqueued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_idle_cycles (ILLIXR::switchboard::topic_subscription)</li> <li>_m_plugin_id (ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue_timeout (ILLIXR::switchboard::topic_subscription)</li> <li>_m_topic_name (ILLIXR::switchboard::topic_subscription)</li> <li>_p_duration (print_timer, print_timer::print_in_destructor, timer)</li> <li>_p_print_in_destructor (print_timer)</li> <li>_p_timer (print_timer)</li> <li>_p_account_name (print_timer::print_in_destructor)</li> <li>_p_now (timer)</li> <li>_p_start (timer)</li> </ul>"},{"location":"api/class_member_functions/","title":"Class Member Functions","text":""},{"location":"api/class_member_functions/#a","title":"a","text":"<ul> <li>absolute_ns (ILLIXR::RelativeClock)</li> <li>allocate (ILLIXR::switchboard::writer)</li> </ul>"},{"location":"api/class_member_functions/#b","title":"b","text":"<ul> <li>buffered_reader (ILLIXR::switchboard::buffered_reader)</li> </ul>"},{"location":"api/class_member_functions/#c","title":"c","text":"<ul> <li>CSVIterator (CSVIterator)</li> <li>clear (ILLIXR::Event)</li> <li>check_should_stop (ILLIXR::Stoplight)</li> <li>check_shutdown_complete (ILLIXR::Stoplight)</li> <li>cam_type (ILLIXR::cam_type)</li> <li>connection_signal (ILLIXR::connection_signal)</li> <li>create (ILLIXR::dynamic_lib)</li> <li>correct_pose (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#d","title":"d","text":"<ul> <li>data_use_indicator (ILLIXR::data_use_indicator)</li> <li>dynamic_lib (ILLIXR::dynamic_lib)</li> <li>dequeue (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer)</li> </ul>"},{"location":"api/class_member_functions/#e","title":"e","text":"<ul> <li>event_wrapper (ILLIXR::switchboard::event_wrapper)</li> <li>enqueue (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> </ul>"},{"location":"api/class_member_functions/#f","title":"f","text":"<ul> <li>flush (ILLIXR::record_coalescer)</li> <li>fast_pose_reliable (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#g","title":"g","text":"<ul> <li>get (ILLIXR::dynamic_lib, ILLIXR::gen_guid, ILLIXR::switchboard::topic)</li> <li>get_state (ILLIXR::managed_thread)</li> <li>get_name (ILLIXR::plugin, ILLIXR::record_header)</li> <li>get_record_header (ILLIXR::record)</li> <li>get_value (ILLIXR::record)</li> <li>get_column_name (ILLIXR::record_header)</li> <li>get_column_type (ILLIXR::record_header)</li> <li>get_columns (ILLIXR::record_header)</li> <li>get_id (ILLIXR::record_header)</li> <li>get_ro (ILLIXR::switchboard::reader)</li> <li>get_ro_nullable (ILLIXR::switchboard::reader)</li> <li>get_rw (ILLIXR::switchboard::reader)</li> <li>get_buffered_reader (ILLIXR::switchboard)</li> <li>get_reader (ILLIXR::switchboard)</li> <li>get_writer (ILLIXR::switchboard)</li> <li>get_buffer (ILLIXR::switchboard::topic)</li> <li>get_fast_pose (pose_prediction)</li> <li>get_offset (pose_prediction)</li> <li>get_true_pose (pose_prediction)</li> </ul>"},{"location":"api/class_member_functions/#h","title":"h","text":"<ul> <li>hologram_input (ILLIXR::hologram_input)</li> </ul>"},{"location":"api/class_member_functions/#i","title":"i","text":"<ul> <li>is_set (ILLIXR::Event)</li> <li>is_started (ILLIXR::RelativeClock)</li> <li>is_used (ILLIXR::data_use_indicator)</li> <li>image_handle (ILLIXR::image_handle)</li> <li>imu_integrator_input (ILLIXR::imu_integrator_input)</li> <li>imu_raw_type (ILLIXR::imu_raw_type)</li> <li>imu_type (ILLIXR::imu_type)</li> <li>internal_stop (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_functions/#l","title":"l","text":"<ul> <li>lookup_impl (ILLIXR::phonebook)</li> <li>log (ILLIXR::record_coalescer, ILLIXR::record_logger)</li> <li>load_plugin_factory (ILLIXR::runtime)</li> <li>load_so (ILLIXR::runtime)</li> </ul>"},{"location":"api/class_member_functions/#m","title":"m","text":"<ul> <li>mark_unused (ILLIXR::data_use_indicator)</li> <li>mark_used (ILLIXR::data_use_indicator, ILLIXR::record)</li> <li>managed_thread (ILLIXR::managed_thread)</li> <li>maybe_flush (ILLIXR::record_coalescer)</li> </ul>"},{"location":"api/class_member_functions/#n","title":"n","text":"<ul> <li>now (ILLIXR::RelativeClock)</li> <li>name (ILLIXR::switchboard::topic)</li> </ul>"},{"location":"api/class_member_functions/#o","title":"o","text":"<ul> <li>operator!= (CSVIterator, ILLIXR::record_header)</li> <li>operator* (CSVIterator, ILLIXR::switchboard::event_wrapper)</li> <li>operator++ (CSVIterator)</li> <li>operator+= (CSVIterator, ILLIXR::time_point)</li> <li>operator-&gt; (CSVIterator)</li> <li>operator== (CSVIterator, ILLIXR::record_header)</li> <li>operator[] (CSVIterator, CSVRow, ILLIXR::dynamic_lib)</li> <li>operator= (ILLIXR::data_use_indicator, ILLIXR::dynamic_lib)</li> <li>operator bool (ILLIXR::record_coalescer)</li> <li>operator underlying_type (ILLIXR::switchboard::event_wrapper)</li> <li>operator-= (ILLIXR::time_point)</li> <li>operator() (should_profile_class)</li> </ul>"},{"location":"api/class_member_functions/#p","title":"p","text":"<ul> <li>plugin (ILLIXR::plugin)</li> <li>pose_type (ILLIXR::pose_type)</li> <li>put (ILLIXR::switchboard::writer, ILLIXR::switchboard::topic)</li> <li>print_timer (print_timer)</li> <li>print_timer2 (print_timer2)</li> <li>print_in_destructor (print_timer::print_in_destructor)</li> </ul>"},{"location":"api/class_member_functions/#r","title":"r","text":"<ul> <li>readNextRow (CSVRow)</li> <li>register_impl (ILLIXR::phonebook)</li> <li>record (ILLIXR::record)</li> <li>record_coalescer (ILLIXR::record_coalescer)</li> <li>record_header (ILLIXR::record_header)</li> <li>rendered_frame (ILLIXR::rendered_frame)</li> <li>rgb_depth_type (ILLIXR::rgb_depth_type)</li> <li>reader (ILLIXR::switchboard::reader)</li> </ul>"},{"location":"api/class_member_functions/#s","title":"s","text":"<ul> <li>size (CSVRow, ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::topic_buffer)</li> <li>set (ILLIXR::Event)</li> <li>start (ILLIXR::RelativeClock, ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::threadloop)</li> <li>start_time (ILLIXR::RelativeClock)</li> <li>signal_ready (ILLIXR::Stoplight)</li> <li>signal_should_stop (ILLIXR::Stoplight)</li> <li>signal_shutdown_complete (ILLIXR::Stoplight)</li> <li>stop (ILLIXR::managed_thread, ILLIXR::plugin, ILLIXR::runtime, ILLIXR::switchboard, ILLIXR::threadloop, ILLIXR::switchboard::topic)</li> <li>spdlogger (ILLIXR::plugin)</li> <li>signal_to_quad (ILLIXR::signal_to_quad)</li> <li>schedule (ILLIXR::switchboard, ILLIXR::switchboard::topic)</li> <li>switchboard (ILLIXR::switchboard)</li> <li>should_terminate (ILLIXR::threadloop)</li> <li>set_offset (pose_prediction)</li> <li>should_profile_class (should_profile_class)</li> </ul>"},{"location":"api/class_member_functions/#t","title":"t","text":"<ul> <li>thread_main (ILLIXR::managed_thread, ILLIXR::threadloop)</li> <li>to_string (ILLIXR::record_header)</li> <li>try_register_topic (ILLIXR::switchboard)</li> <li>texture_pose (ILLIXR::texture_pose)</li> <li>threadloop (ILLIXR::threadloop)</li> <li>time_point (ILLIXR::time_point)</li> <li>time_since_epoch (ILLIXR::time_point)</li> <li>topic (ILLIXR::switchboard::topic)</li> <li>ty (ILLIXR::switchboard::topic)</li> <li>topic_buffer (ILLIXR::switchboard::topic_buffer)</li> <li>thread_body (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_start (ILLIXR::switchboard::topic_subscription)</li> <li>thread_on_stop (ILLIXR::switchboard::topic_subscription)</li> <li>topic_subscription (ILLIXR::switchboard::topic_subscription)</li> <li>true_pose_reliable (pose_prediction)</li> <li>timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#v","title":"v","text":"<ul> <li>vk_image_handle (ILLIXR::vk_image_handle)</li> </ul>"},{"location":"api/class_member_functions/#w","title":"w","text":"<ul> <li>wait (ILLIXR::Event, ILLIXR::runtime)</li> <li>wait_timeout (ILLIXR::Event)</li> <li>wait_for_ready (ILLIXR::Stoplight)</li> <li>wait_for_shutdown_complete (ILLIXR::Stoplight)</li> <li>writer (ILLIXR::switchboard::writer)</li> </ul>"},{"location":"api/class_member_functions/#x","title":"x","text":"<ul> <li>xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_functions/#_1","title":"~","text":"<ul> <li>~dynamic_lib (ILLIXR::dynamic_lib)</li> <li>~managed_thread (ILLIXR::managed_thread)</li> <li>~service (ILLIXR::phonebook::service)</li> <li>~plugin (ILLIXR::plugin)</li> <li>~record (ILLIXR::record)</li> <li>~record_coalescer (ILLIXR::record_coalescer)</li> <li>~record_logger (ILLIXR::record_logger)</li> <li>~runtime (ILLIXR::runtime)</li> <li>~event (ILLIXR::switchboard::event)</li> <li>~threadloop (ILLIXR::threadloop)</li> <li>~xlib_gl_extended_window (ILLIXR::xlib_gl_extended_window)</li> <li>~pose_prediction (pose_prediction)</li> <li>~print_timer2 (print_timer2)</li> <li>~print_in_destructor (print_timer::print_in_destructor)</li> <li>~timer (timer)</li> </ul>"},{"location":"api/class_member_functions/#_","title":"_","text":"<ul> <li>_p_one_iteration (ILLIXR::threadloop)</li> <li>_p_should_skip (ILLIXR::threadloop)</li> <li>_p_thread_setup (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/","title":"Class Member Variables","text":""},{"location":"api/class_member_variables/#a","title":"a","text":"<ul> <li>aberration (ILLIXR::display_params)</li> <li>acc_noise (ILLIXR::imu_params)</li> <li>acc_walk (ILLIXR::imu_params)</li> <li>a_hat (ILLIXR::imu_raw_type)</li> <li>a_hat2 (ILLIXR::imu_raw_type)</li> <li>angular_v (ILLIXR::imu_type)</li> <li>allocation_size (ILLIXR::vk_image_handle)</li> <li>actually_should_profile (should_profile_class)</li> </ul>"},{"location":"api/class_member_variables/#b","title":"b","text":"<ul> <li>biasAcc (ILLIXR::imu_integrator_input)</li> <li>biasGyro (ILLIXR::imu_integrator_input)</li> <li>buffer (ILLIXR::record_coalescer)</li> </ul>"},{"location":"api/class_member_variables/#c","title":"c","text":"<ul> <li>chromaticAberration (ILLIXR::hmd_physical_info)</li> <li>columns (ILLIXR::record_header)</li> <li>cpu_time_start (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#d","title":"d","text":"<ul> <li>displayPixelsHigh (ILLIXR::hmd_physical_info)</li> <li>displayPixelsWide (ILLIXR::hmd_physical_info)</li> <li>data_use_indicator_ (ILLIXR::record)</li> <li>depth (ILLIXR::rgb_depth_type)</li> <li>dpy (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#f","title":"f","text":"<ul> <li>fov_x (ILLIXR::display_params)</li> <li>fov_y (ILLIXR::display_params)</li> <li>frequency (ILLIXR::display_params)</li> <li>far_z (ILLIXR::rendering_params)</li> <li>file_descriptor (ILLIXR::vk_image_handle)</li> <li>format (ILLIXR::vk_image_handle)</li> </ul>"},{"location":"api/class_member_variables/#g","title":"g","text":"<ul> <li>guid_starts (ILLIXR::gen_guid)</li> <li>gl_handle (ILLIXR::image_handle)</li> <li>gyro_noise (ILLIXR::imu_params)</li> <li>gyro_walk (ILLIXR::imu_params)</li> <li>gen_guid_ (ILLIXR::plugin)</li> <li>glc (ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#h","title":"h","text":"<ul> <li>height_meters (ILLIXR::display_params)</li> <li>height_pixels (ILLIXR::display_params)</li> <li>height (ILLIXR::vk_image_handle, ILLIXR::xlib_gl_extended_window)</li> </ul>"},{"location":"api/class_member_variables/#i","title":"i","text":"<ul> <li>is_steady (ILLIXR::RelativeClock)</li> <li>img0 (ILLIXR::cam_type)</li> <li>img1 (ILLIXR::cam_type)</li> <li>ipd (ILLIXR::display_params, ILLIXR::hmd_physical_info)</li> <li>image_handle (ILLIXR::image_handle)</li> <li>imu_integration_sigma (ILLIXR::imu_params)</li> <li>imu_time (ILLIXR::imu_raw_type)</li> <li>id (ILLIXR::plugin, ILLIXR::record_header)</li> <li>image (ILLIXR::texture_pose)</li> <li>iteration_no (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/#k","title":"k","text":"<ul> <li>K (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#l","title":"l","text":"<ul> <li>lens_separation (ILLIXR::display_params)</li> <li>lens_vertical_position (ILLIXR::display_params)</li> <li>lensSeparationInMeters (ILLIXR::hmd_physical_info)</li> <li>last_cam_integration_time (ILLIXR::imu_integrator_input)</li> <li>linear_a (ILLIXR::imu_type)</li> <li>last_log (ILLIXR::record_coalescer)</li> <li>logger (ILLIXR::record_coalescer)</li> <li>latest_quaternion (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#m","title":"m","text":"<ul> <li>m_row (CSVIterator)</li> <li>m_str (CSVIterator)</li> <li>m_data (CSVRow)</li> <li>meters_per_tan_angle (ILLIXR::display_params)</li> <li>metersPerTanAngleAtCenter (ILLIXR::hmd_physical_info)</li> </ul>"},{"location":"api/class_member_variables/#n","title":"n","text":"<ul> <li>num_images (ILLIXR::image_handle)</li> <li>n_gravity (ILLIXR::imu_params)</li> <li>nominal_rate (ILLIXR::imu_params)</li> <li>name (ILLIXR::plugin, ILLIXR::record_header, print_timer2)</li> <li>near_z (ILLIXR::rendering_params)</li> </ul>"},{"location":"api/class_member_variables/#o","title":"o","text":"<ul> <li>orientation (ILLIXR::pose_type)</li> <li>offload_duration (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#p","title":"p","text":"<ul> <li>period (ILLIXR::display_params)</li> <li>pose (ILLIXR::fast_pose_type)</li> <li>predict_computed_time (ILLIXR::fast_pose_type)</li> <li>predict_target_time (ILLIXR::fast_pose_type)</li> <li>params (ILLIXR::imu_integrator_input)</li> <li>position (ILLIXR::imu_integrator_input, ILLIXR::pose_type, ILLIXR::texture_pose)</li> <li>pos (ILLIXR::imu_raw_type)</li> <li>pb (ILLIXR::plugin)</li> <li>pose_time (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#q","title":"q","text":"<ul> <li>quat (ILLIXR::imu_integrator_input, ILLIXR::imu_raw_type)</li> </ul>"},{"location":"api/class_member_variables/#r","title":"r","text":"<ul> <li>record_logger_ (ILLIXR::plugin)</li> <li>rh (ILLIXR::record)</li> <li>render_pose (ILLIXR::rendered_frame)</li> <li>render_time (ILLIXR::rendered_frame)</li> <li>rgb (ILLIXR::rgb_depth_type)</li> <li>render_quaternion (ILLIXR::texture_pose)</li> </ul>"},{"location":"api/class_member_variables/#s","title":"s","text":"<ul> <li>start (ILLIXR::connection_signal)</li> <li>seq (ILLIXR::hologram_input, ILLIXR::signal_to_quad)</li> <li>sensor_time (ILLIXR::pose_type)</li> <li>sample_time (ILLIXR::rendered_frame)</li> <li>swap_indices (ILLIXR::rendered_frame)</li> <li>swapchain_indices (ILLIXR::rendered_frame)</li> <li>serial_no (ILLIXR::switchboard::buffered_reader, print_timer2)</li> <li>skip_no (ILLIXR::threadloop)</li> </ul>"},{"location":"api/class_member_variables/#t","title":"t","text":"<ul> <li>time (ILLIXR::cam_type, ILLIXR::imu_type, ILLIXR::rgb_depth_type)</li> <li>type (ILLIXR::image_handle)</li> <li>t_offset (ILLIXR::imu_integrator_input)</li> </ul>"},{"location":"api/class_member_variables/#u","title":"u","text":"<ul> <li>used (ILLIXR::data_use_indicator)</li> <li>usage (ILLIXR::image_handle)</li> <li>underlying_data (ILLIXR::switchboard::event_wrapper)</li> </ul>"},{"location":"api/class_member_variables/#v","title":"v","text":"<ul> <li>visibleMetersHigh (ILLIXR::hmd_physical_info)</li> <li>visibleMetersWide (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsHigh (ILLIXR::hmd_physical_info)</li> <li>visiblePixelsWide (ILLIXR::hmd_physical_info)</li> <li>vk_handle (ILLIXR::image_handle)</li> <li>velocity (ILLIXR::imu_integrator_input)</li> <li>vel (ILLIXR::imu_raw_type)</li> <li>values (ILLIXR::record)</li> </ul>"},{"location":"api/class_member_variables/#w","title":"w","text":"<ul> <li>width_meters (ILLIXR::display_params)</li> <li>width_pixels (ILLIXR::display_params)</li> <li>w_hat (ILLIXR::imu_raw_type)</li> <li>w_hat2 (ILLIXR::imu_raw_type)</li> <li>width (ILLIXR::vk_image_handle, ILLIXR::xlib_gl_extended_window)</li> <li>win (ILLIXR::xlib_gl_extended_window)</li> <li>wall_time_start (print_timer2)</li> </ul>"},{"location":"api/class_member_variables/#_","title":"_","text":"<ul> <li>_m_cv (ILLIXR::Event)</li> <li>_m_mutex (ILLIXR::Event, ILLIXR::phonebook)</li> <li>_m_value (ILLIXR::Event)</li> <li>_m_start (ILLIXR::RelativeClock)</li> <li>_m_ready (ILLIXR::Stoplight)</li> <li>_m_should_stop (ILLIXR::Stoplight)</li> <li>_m_shutdown_complete (ILLIXR::Stoplight)</li> <li>_m_handle (ILLIXR::dynamic_lib)</li> <li>_m_lib_path (ILLIXR::dynamic_lib)</li> <li>_m_body (ILLIXR::managed_thread)</li> <li>_m_on_start (ILLIXR::managed_thread)</li> <li>_m_on_stop (ILLIXR::managed_thread)</li> <li>_m_stop (ILLIXR::managed_thread)</li> <li>_m_thread (ILLIXR::managed_thread, ILLIXR::threadloop, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry (ILLIXR::phonebook, ILLIXR::switchboard)</li> <li>_m_tb (ILLIXR::switchboard::buffered_reader)</li> <li>_m_topic (ILLIXR::switchboard::buffered_reader, ILLIXR::switchboard::reader, ILLIXR::switchboard::writer)</li> <li>_m_record_logger (ILLIXR::switchboard, ILLIXR::switchboard::topic, ILLIXR::switchboard::topic_subscription)</li> <li>_m_registry_lock (ILLIXR::switchboard)</li> <li>_m_internal_stop (ILLIXR::threadloop)</li> <li>_m_stoplight (ILLIXR::threadloop)</li> <li>_m_time_since_epoch (ILLIXR::time_point)</li> <li>_m_cmap (ILLIXR::xlib_gl_extended_window)</li> <li>_m_buffers (ILLIXR::switchboard::topic)</li> <li>_m_latest_buffer (ILLIXR::switchboard::topic)</li> <li>_m_latest_buffer_size (ILLIXR::switchboard::topic)</li> <li>_m_latest_index (ILLIXR::switchboard::topic)</li> <li>_m_name (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions (ILLIXR::switchboard::topic)</li> <li>_m_subscriptions_lock (ILLIXR::switchboard::topic)</li> <li>_m_ty (ILLIXR::switchboard::topic)</li> <li>_m_ctok (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue (ILLIXR::switchboard::topic_buffer, ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue_size (ILLIXR::switchboard::topic_buffer)</li> <li>_m_callback (ILLIXR::switchboard::topic_subscription)</li> <li>_m_cb_log (ILLIXR::switchboard::topic_subscription)</li> <li>_m_dequeued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_enqueued (ILLIXR::switchboard::topic_subscription)</li> <li>_m_idle_cycles (ILLIXR::switchboard::topic_subscription)</li> <li>_m_plugin_id (ILLIXR::switchboard::topic_subscription)</li> <li>_m_queue_timeout (ILLIXR::switchboard::topic_subscription)</li> <li>_m_topic_name (ILLIXR::switchboard::topic_subscription)</li> <li>_p_duration (print_timer, print_timer::print_in_destructor, timer)</li> <li>_p_print_in_destructor (print_timer)</li> <li>_p_timer (print_timer)</li> <li>_p_account_name (print_timer::print_in_destructor)</li> <li>_p_now (timer)</li> <li>_p_start (timer)</li> </ul>"},{"location":"api/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"api/class_member_typedefs/#d","title":"d","text":"<ul> <li>difference_type (CSVIterator)</li> <li>duration (ILLIXR::RelativeClock, ILLIXR::time_point)</li> </ul>"},{"location":"api/class_member_typedefs/#i","title":"i","text":"<ul> <li>iterator_category (CSVIterator)</li> </ul>"},{"location":"api/class_member_typedefs/#p","title":"p","text":"<ul> <li>pointer (CSVIterator)</li> <li>period (ILLIXR::RelativeClock)</li> <li>ptr (ILLIXR::switchboard)</li> </ul>"},{"location":"api/class_member_typedefs/#r","title":"r","text":"<ul> <li>reference (CSVIterator)</li> <li>rep (ILLIXR::RelativeClock)</li> </ul>"},{"location":"api/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (CSVIterator)</li> </ul>"},{"location":"api/class_member_enums/","title":"Class Member Enums","text":""},{"location":"api/class_member_enums/#s","title":"s","text":"<ul> <li>state (ILLIXR::managed_thread)</li> <li>skip_option (ILLIXR::threadloop)</li> </ul>"},{"location":"api/namespace_members/","title":"Namespace Members","text":""},{"location":"api/namespace_members/#a","title":"a","text":"<ul> <li>abort (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#d","title":"d","text":"<ul> <li>duration (ILLIXR)</li> <li>duration2double (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#e","title":"e","text":"<ul> <li>ENABLE_VERBOSE_ERRORS (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#f","title":"f","text":"<ul> <li>freq2period (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#g","title":"g","text":"<ul> <li>getenv_or (ILLIXR)</li> <li>graphics_api (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#l","title":"l","text":"<ul> <li>LOG_BUFFER_DELAY (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#o","title":"o","text":"<ul> <li>operator!= (ILLIXR)</li> <li>operator+ (ILLIXR)</li> <li>operator- (ILLIXR)</li> <li>operator&lt; (ILLIXR)</li> <li>operator&lt;= (ILLIXR)</li> <li>operator== (ILLIXR)</li> <li>operator&gt; (ILLIXR)</li> <li>operator&gt;= (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#p","title":"p","text":"<ul> <li>projection (ILLIXR::math_util)</li> <li>projection_fov (ILLIXR::math_util)</li> <li>plugin_factory (ILLIXR)</li> <li>plugin_id_t (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#r","title":"r","text":"<ul> <li>report_and_clear_errno (ILLIXR)</li> <li>runtime_factory (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#s","title":"s","text":"<ul> <li>str_to_bool (ILLIXR)</li> <li>swapchain_usage (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#v","title":"v","text":"<ul> <li>vk_image_handle (ILLIXR)</li> <li>void_ptr (ILLIXR)</li> </ul>"},{"location":"api/namespace_members/#_","title":"_","text":"<ul> <li>__plugin_start_header (ILLIXR)</li> <li>__switchboard_callback_header (ILLIXR)</li> <li>__switchboard_topic_stop_header (ILLIXR)</li> <li>__threadloop_iteration_header (ILLIXR)</li> <li>_clock_duration (ILLIXR)</li> <li>_clock_period (ILLIXR)</li> <li>_clock_rep (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"api/namespace_member_functions/#a","title":"a","text":"<ul> <li>abort (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#d","title":"d","text":"<ul> <li>duration2double (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#f","title":"f","text":"<ul> <li>freq2period (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#g","title":"g","text":"<ul> <li>getenv_or (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator!= (ILLIXR)</li> <li>operator+ (ILLIXR)</li> <li>operator- (ILLIXR)</li> <li>operator&lt; (ILLIXR)</li> <li>operator&lt;= (ILLIXR)</li> <li>operator== (ILLIXR)</li> <li>operator&gt; (ILLIXR)</li> <li>operator&gt;= (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#p","title":"p","text":"<ul> <li>projection (ILLIXR::math_util)</li> <li>projection_fov (ILLIXR::math_util)</li> </ul>"},{"location":"api/namespace_member_functions/#r","title":"r","text":"<ul> <li>report_and_clear_errno (ILLIXR)</li> <li>runtime_factory (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_functions/#s","title":"s","text":"<ul> <li>str_to_bool (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"api/namespace_member_variables/#e","title":"e","text":"<ul> <li>ENABLE_VERBOSE_ERRORS (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#l","title":"l","text":"<ul> <li>LOG_BUFFER_DELAY (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_variables/#_","title":"_","text":"<ul> <li>__plugin_start_header (ILLIXR)</li> <li>__switchboard_callback_header (ILLIXR)</li> <li>__switchboard_topic_stop_header (ILLIXR)</li> <li>__threadloop_iteration_header (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"api/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>duration (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>plugin_factory (ILLIXR)</li> <li>plugin_id_t (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#u","title":"u","text":"<ul> <li>ullong (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>vk_image_handle (ILLIXR)</li> <li>void_ptr (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_typedefs/#_","title":"_","text":"<ul> <li>_clock_duration (ILLIXR)</li> <li>_clock_period (ILLIXR)</li> <li>_clock_rep (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"api/namespace_member_enums/#g","title":"g","text":"<ul> <li>graphics_api (ILLIXR)</li> </ul>"},{"location":"api/namespace_member_enums/#s","title":"s","text":"<ul> <li>swapchain_usage (ILLIXR)</li> </ul>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#c","title":"c","text":"<ul> <li>count_duration (cpu_timer.hpp)</li> <li>cpp_clock_gettime (cpu_timer.hpp)</li> </ul>"},{"location":"api/functions/#g","title":"g","text":"<ul> <li>gen_serial_no (cpu_timer.hpp)</li> </ul>"},{"location":"api/functions/#i","title":"i","text":"<ul> <li>init_and_link (shader_util.hpp)</li> </ul>"},{"location":"api/functions/#m","title":"m","text":"<ul> <li>MessageCallback (shader_util.hpp)</li> </ul>"},{"location":"api/functions/#o","title":"o","text":"<ul> <li>operator&gt;&gt; (csv_iterator.hpp)</li> </ul>"},{"location":"api/functions/#t","title":"t","text":"<ul> <li>thread_cpu_time (cpu_timer.hpp, switchboard.hpp)</li> <li>timed_thread (cpu_timer.hpp)</li> </ul>"},{"location":"api/macros/","title":"Macros","text":""},{"location":"api/macros/#g","title":"g","text":"<ul> <li>GLX_CONTEXT_MAJOR_VERSION_ARB (extended_window.hpp)</li> <li>GLX_CONTEXT_MINOR_VERSION_ARB (extended_window.hpp)</li> </ul>"},{"location":"api/macros/#p","title":"p","text":"<ul> <li>PRINT_CPU_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_RECORD_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PRINT_WALL_TIME_FOR_THIS_BLOCK (cpu_timer.hpp)</li> <li>PLUGIN_MAIN (plugin.hpp)</li> </ul>"},{"location":"api/macros/#r","title":"r","text":"<ul> <li>RAC_ERRNO (error_util.hpp)</li> <li>RAC_ERRNO_MSG (error_util.hpp)</li> </ul>"},{"location":"api/macros/#u","title":"u","text":"<ul> <li>USE_ALT_EYE_FORMAT (data_format.hpp)</li> </ul>"},{"location":"api/variables/","title":"Variables","text":""},{"location":"api/variables/#g","title":"g","text":"<ul> <li>glXCreateContextAttribsARBProc (extended_window.hpp)</li> <li>GL_MAX_LOG_LENGTH (shader_util.hpp)</li> </ul>"},{"location":"api/variables/#s","title":"s","text":"<ul> <li>should_profile (cpu_timer.hpp)</li> </ul>"},{"location":"api/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}